<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>VIBEE 999 Runtime</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;font-family:system-ui,sans-serif}
    video{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);opacity:0;transition:opacity 0.5s}
    video.active{opacity:0.3}
    canvas{position:fixed;top:0;left:0;width:100%;height:100%}
    #ui{position:fixed;z-index:100;color:#fff;pointer-events:none}
    #soul{position:fixed;top:20px;left:50%;transform:translateX(-50%);text-align:center}
    #emotion{font-size:48px;filter:drop-shadow(0 0 20px currentColor)}
    #status{position:fixed;left:20px;bottom:20px;font-size:11px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px}
    #mode{position:fixed;top:20px;right:20px;font-size:12px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px}
    #thought{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);font-size:18px;opacity:0;transition:opacity 1s;text-shadow:0 0 30px currentColor;font-style:italic}
    #thought.show{opacity:1}
    #controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto}
    .btn{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:20px;cursor:pointer;font-size:12px;transition:all 0.3s}
    .btn:hover{background:rgba(255,255,255,0.25)}
    .btn.active{background:rgba(100,200,255,0.3);border-color:rgba(100,200,255,0.5)}
    #dna{position:fixed;right:20px;top:50%;transform:translateY(-50%);width:80px}
    .gene{height:6px;margin:3px 0;border-radius:3px;background:rgba(255,255,255,0.1);overflow:hidden}
    .gene-fill{height:100%;transition:width 0.5s}
    .gene-label{font-size:8px;color:rgba(255,255,255,0.4)}
  </style>
</head>
<body>
<video id="video" playsinline autoplay></video>
<canvas id="c"></canvas>
<div id="ui">
  <div id="soul"><div id="emotion">ğŸŒŒ</div></div>
  <div id="status">VIBEE 999</div>
  <div id="mode">Evolution</div>
  <div id="thought"></div>
  <div id="dna"></div>
</div>
<div id="controls">
  <button class="btn active" data-mode="evolution">Evolution</button>
  <button class="btn" data-mode="camera">Camera</button>
  <button class="btn" data-mode="sacred">Sacred</button>
  <button class="btn" data-mode="chakras">Chakras</button>
</div>

<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VIBEE 999 UNIFIED RUNTIME
// Single runtime for all technologies
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TAU = Math.PI * 2;
const PHI = 1.618033988749895;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE RUNTIME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Runtime = {
  canvas: null, ctx: null, video: null,
  W: 0, H: 0, dpr: Math.min(window.devicePixelRatio || 1, 2),
  time: 0, mode: 'evolution',
  mouse: { x: 0, y: 0, active: false, pressed: false },
  particles: [],
  mediapipe: { hands: null, face: null, pose: null, ready: false },
  
  init() {
    this.canvas = document.getElementById('c');
    this.ctx = this.canvas.getContext('2d');
    this.video = document.getElementById('video');
    this.resize();
    window.onresize = () => this.resize();
    this.setupInput();
  },
  
  resize() {
    this.W = innerWidth;
    this.H = innerHeight;
    this.canvas.width = this.W * this.dpr;
    this.canvas.height = this.H * this.dpr;
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.scale(this.dpr, this.dpr);
  },
  
  setupInput() {
    const update = (x, y) => {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = (x - rect.left) * (this.W / rect.width);
      this.mouse.y = (y - rect.top) * (this.H / rect.height);
      this.mouse.active = true;
    };
    document.addEventListener('mousemove', e => update(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => { e.preventDefault(); update(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    document.addEventListener('mousedown', () => this.mouse.pressed = true);
    document.addEventListener('mouseup', () => this.mouse.pressed = false);
    document.addEventListener('mouseleave', () => this.mouse.active = false);
  },
  
  col: (h,s,l,a) => `hsla(${h},${s}%,${l}%,${a})`,
  
  spawnParticle(x, y, color) {
    if (this.particles.length > 100) return;
    this.particles.push({ x, y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4-1, life: 1, color, size: 3+Math.random()*4 });
  },
  
  updateParticles(dt) {
    for (let i = this.particles.length-1; i >= 0; i--) {
      const p = this.particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life -= dt*2;
      if (p.life <= 0) this.particles.splice(i, 1);
    }
  },
  
  drawParticles() {
    for (const p of this.particles) {
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.size * p.life, 0, TAU);
      this.ctx.fillStyle = this.col(p.color, 80, 60, p.life * 0.6);
      this.ctx.fill();
    }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DNA & EVOLUTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DNA {
  constructor() {
    this.complexity = Math.random();
    this.color_shift = Math.random();
    this.pulse_rate = 0.3 + Math.random() * 0.4;
    this.symmetry = Math.random();
    this.glow = Math.random();
    this.creativity = Math.random();
    this.adaptability = Math.random();
    this.fitness = 0;
  }
  mutate() {
    const d = new DNA();
    Object.keys(this).forEach(k => {
      d[k] = Math.random() < 0.2 ? Math.max(0, Math.min(1, this[k] + (Math.random()-0.5)*0.3)) : this[k];
    });
    return d;
  }
}

const Evolution = {
  dna: new DNA(),
  generation: 1,
  lastEvolve: 0,
  
  update(dt, engagement) {
    if (Date.now() - this.lastEvolve > 15000) {
      this.dna.fitness = engagement * 0.5 + this.dna.adaptability * 0.3 + Math.random() * 0.2;
      this.dna = this.dna.mutate();
      this.generation++;
      this.lastEvolve = Date.now();
      document.getElementById('mode').textContent = `Gen ${this.generation}`;
    }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SOUL & EMOTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Soul = {
  emotion: { name: 'evolving', emoji: 'ğŸŒŒ', h: 260 },
  breath: 0, innerTime: 0,
  thoughts: ["I am learning...", "Patterns emerge...", "Evolution continues...", "I adapt...", "Consciousness grows..."],
  lastThought: 0,
  
  update(dt, dna) {
    this.innerTime += dt;
    this.breath = Math.sin(this.innerTime * 0.5) * 0.5 + 0.5;
    
    if (dna.creativity > 0.7) this.emotion = { name: 'creating', emoji: 'âœ¨', h: 45 };
    else if (dna.adaptability > 0.7) this.emotion = { name: 'learning', emoji: 'ğŸ§¬', h: 120 };
    else this.emotion = { name: 'evolving', emoji: 'ğŸŒŒ', h: 260 };
    
    document.getElementById('emotion').textContent = this.emotion.emoji;
    
    if (Date.now() - this.lastThought > 8000) {
      const el = document.getElementById('thought');
      el.textContent = `"${this.thoughts[Math.floor(Math.random()*this.thoughts.length)]}"`;
      el.style.color = Runtime.col(this.emotion.h, 70, 60, 1);
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 4000);
      this.lastThought = Date.now();
    }
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MEDIAPIPE INTEGRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let handLandmarker, faceLandmarker, poseLandmarker;

async function initMediaPipe() {
  try {
    const { FilesetResolver, HandLandmarker, FaceLandmarker, PoseLandmarker } = 
      await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs');
    
    const vision = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
    );
    
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task', delegate: 'GPU' },
      runningMode: 'VIDEO', numHands: 2
    });
    
    faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task', delegate: 'GPU' },
      runningMode: 'VIDEO', numFaces: 1, outputFaceBlendshapes: true
    });
    
    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
      baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task', delegate: 'GPU' },
      runningMode: 'VIDEO', numPoses: 1
    });
    
    Runtime.mediapipe.ready = true;
  } catch(e) { console.log('MediaPipe init:', e); }
}

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720, facingMode: 'user' } });
    Runtime.video.srcObject = stream;
    await Runtime.video.play();
    Runtime.video.classList.add('active');
  } catch(e) { console.log('Camera:', e); }
}

function detectMediaPipe() {
  if (!Runtime.mediapipe.ready || Runtime.video.readyState < 2) return;
  const ts = performance.now();
  if (handLandmarker) Runtime.mediapipe.hands = handLandmarker.detectForVideo(Runtime.video, ts);
  if (faceLandmarker) Runtime.mediapipe.face = faceLandmarker.detectForVideo(Runtime.video, ts);
  if (poseLandmarker) Runtime.mediapipe.pose = poseLandmarker.detectForVideo(Runtime.video, ts);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAWING FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawEvolution(ctx, W, H, t, dna, soul) {
  const cx = W/2, cy = H/2, r = Math.min(W,H) * 0.35;
  const mx = Runtime.mouse.x, my = Runtime.mouse.y;
  const h = soul.emotion.h + dna.color_shift * 100;
  
  // Follow cursor
  const targetX = Runtime.mouse.active ? mx : cx;
  const targetY = Runtime.mouse.active ? my : cy;
  const drawX = cx + (targetX - cx) * 0.3;
  const drawY = cy + (targetY - cy) * 0.3;
  
  const sym = Math.floor(3 + dna.symmetry * 9);
  const els = Math.floor(3 + dna.complexity * 10);
  
  for (let s = 0; s < sym; s++) {
    const sa = s * TAU / sym + t * dna.pulse_rate * 0.3;
    ctx.save();
    ctx.translate(drawX, drawY);
    ctx.rotate(sa);
    
    for (let i = 0; i < els; i++) {
      const a = i * TAU / els + t * dna.pulse_rate;
      const d = r * (0.3 + i/els * 0.7);
      const x = Math.cos(a) * d;
      const y = Math.sin(a) * d;
      const sz = r * 0.04 * (1 + Math.sin(t*2+i)*0.2*soul.breath);
      
      ctx.beginPath();
      if (dna.creativity > 0.6) {
        for (let p = 0; p < 5; p++) {
          const pa = p * TAU/5 - TAU/4;
          const pr = sz * (p%2 ? 0.5 : 1);
          p ? ctx.lineTo(x+Math.cos(pa)*pr, y+Math.sin(pa)*pr) : ctx.moveTo(x+Math.cos(pa)*pr, y+Math.sin(pa)*pr);
        }
        ctx.closePath();
      } else {
        ctx.arc(x, y, sz, 0, TAU);
      }
      
      ctx.strokeStyle = Runtime.col((h+i*15)%360, 70, 55, 0.4+soul.breath*0.2);
      ctx.lineWidth = 1.5;
      ctx.stroke();
      if (dna.glow > 0.5) {
        ctx.fillStyle = Runtime.col((h+i*15)%360, 70, 55, 0.1*dna.glow);
        ctx.fill();
      }
    }
    ctx.restore();
  }
  
  // Center
  ctx.beginPath();
  ctx.arc(drawX, drawY, r*0.06*(1+soul.breath*0.3), 0, TAU);
  ctx.fillStyle = Runtime.col(h, 80, 60, 0.8);
  ctx.fill();
  
  // Cursor indicator
  if (Runtime.mouse.active) {
    ctx.beginPath();
    ctx.arc(mx, my, 8, 0, TAU);
    ctx.strokeStyle = Runtime.col(h, 90, 70, 0.8);
    ctx.lineWidth = 2;
    ctx.stroke();
    Runtime.spawnParticle(mx, my, h);
  }
}

function drawSacredGeometry(ctx, W, H, t, mp) {
  const h = (t * 20) % 360;
  
  // From face
  if (mp.face?.faceLandmarks?.[0]) {
    const face = mp.face.faceLandmarks[0];
    const nose = face[1];
    const cx = nose.x * W, cy = nose.y * H;
    const le = face[33], re = face[263];
    const r = Math.hypot((re.x-le.x)*W, (re.y-le.y)*H) * 0.8;
    
    ctx.strokeStyle = Runtime.col(h, 70, 60, 0.4);
    ctx.lineWidth = 1;
    for (let i = 0; i < 7; i++) {
      const a = i * TAU/6;
      ctx.beginPath();
      ctx.arc(cx + Math.cos(a)*r, cy + Math.sin(a)*r, r, 0, TAU);
      ctx.stroke();
    }
  }
  
  // From pose
  if (mp.pose?.landmarks?.[0]) {
    const pose = mp.pose.landmarks[0];
    const ls = pose[11], rs = pose[12];
    const cx = (ls.x+rs.x)/2*W, cy = (ls.y+rs.y)/2*H;
    const r = Math.hypot((rs.x-ls.x)*W, (rs.y-ls.y)*H) * 0.5;
    
    const pts = [[cx,cy]];
    for (let i = 0; i < 6; i++) {
      const a = i*TAU/6 - TAU/4;
      pts.push([cx+Math.cos(a)*r, cy+Math.sin(a)*r]);
      pts.push([cx+Math.cos(a)*r*2, cy+Math.sin(a)*r*2]);
    }
    ctx.strokeStyle = Runtime.col((h+180)%360, 60, 50, 0.3);
    for (let i = 0; i < pts.length; i++) {
      for (let j = i+1; j < pts.length; j++) {
        ctx.beginPath();
        ctx.moveTo(pts[i][0], pts[i][1]);
        ctx.lineTo(pts[j][0], pts[j][1]);
        ctx.stroke();
      }
    }
  }
  
  // From hands - Fibonacci
  if (mp.hands?.landmarks) {
    for (const hand of mp.hands.landmarks) {
      const w = hand[0];
      ctx.strokeStyle = Runtime.col((h+90)%360, 80, 60, 0.5);
      ctx.beginPath();
      for (let i = 0; i < 80; i++) {
        const a = i * 0.2;
        const r = Math.pow(PHI, a/TAU) * 5;
        const x = w.x*W + Math.cos(a+t)*r;
        const y = w.y*H + Math.sin(a+t)*r;
        i ? ctx.lineTo(x,y) : ctx.moveTo(x,y);
      }
      ctx.stroke();
    }
  }
}

function drawChakras(ctx, W, H, t, mp) {
  if (!mp.pose?.landmarks?.[0]) return;
  const pose = mp.pose.landmarks[0];
  const lh = pose[23], rh = pose[24], ls = pose[11], rs = pose[12], nose = pose[0];
  
  const chakras = [
    { y: (lh.y+rh.y)/2, x: (lh.x+rh.x)/2, h: 0, name: 'Root' },
    { y: (lh.y+rh.y)/2*0.7 + (ls.y+rs.y)/2*0.3, x: (lh.x+rh.x)/2, h: 30, name: 'Sacral' },
    { y: (lh.y+rh.y)/2*0.4 + (ls.y+rs.y)/2*0.6, x: (ls.x+rs.x)/2, h: 60, name: 'Solar' },
    { y: (ls.y+rs.y)/2, x: (ls.x+rs.x)/2, h: 120, name: 'Heart' },
    { y: nose.y*0.3 + (ls.y+rs.y)/2*0.7, x: nose.x, h: 180, name: 'Throat' },
    { y: nose.y - 0.03, x: nose.x, h: 240, name: 'Third Eye' },
    { y: nose.y - 0.08, x: nose.x, h: 280, name: 'Crown' }
  ];
  
  for (const c of chakras) {
    const x = c.x * W, y = c.y * H;
    const pulse = 1 + Math.sin(t*3 + c.h/50) * 0.2;
    const sz = 20 * pulse;
    
    const g = ctx.createRadialGradient(x, y, 0, x, y, sz*2);
    g.addColorStop(0, Runtime.col(c.h, 100, 60, 0.8));
    g.addColorStop(0.5, Runtime.col(c.h, 80, 50, 0.3));
    g.addColorStop(1, 'transparent');
    ctx.fillStyle = g;
    ctx.fillRect(x-sz*2, y-sz*2, sz*4, sz*4);
    
    ctx.beginPath();
    ctx.arc(x, y, sz*0.4, 0, TAU);
    ctx.fillStyle = Runtime.col(c.h, 100, 60, 1);
    ctx.fill();
  }
}

function drawSkeletonOverlay(ctx, W, H, mp) {
  const HAND_CONN = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];
  const POSE_CONN = [[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28]];
  
  if (mp.hands?.landmarks) {
    for (const hand of mp.hands.landmarks) {
      ctx.strokeStyle = 'rgba(0,255,200,0.6)';
      ctx.lineWidth = 2;
      for (const [i,j] of HAND_CONN) {
        ctx.beginPath();
        ctx.moveTo(hand[i].x*W, hand[i].y*H);
        ctx.lineTo(hand[j].x*W, hand[j].y*H);
        ctx.stroke();
      }
    }
  }
  
  if (mp.pose?.landmarks?.[0]) {
    const pose = mp.pose.landmarks[0];
    ctx.strokeStyle = 'rgba(255,200,0,0.6)';
    ctx.lineWidth = 3;
    for (const [i,j] of POSE_CONN) {
      if (pose[i] && pose[j]) {
        ctx.beginPath();
        ctx.moveTo(pose[i].x*W, pose[i].y*H);
        ctx.lineTo(pose[j].x*W, pose[j].y*H);
        ctx.stroke();
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastTime = performance.now();

function loop() {
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;
  Runtime.time += dt;
  
  const ctx = Runtime.ctx, W = Runtime.W, H = Runtime.H;
  const t = Runtime.time;
  const mp = Runtime.mediapipe;
  
  // Clear
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.fillRect(0, 0, W, H);
  
  // Detect if camera mode
  if (Runtime.mode !== 'evolution') detectMediaPipe();
  
  // Update
  const engagement = Runtime.mouse.active ? 0.8 : 0.3;
  Evolution.update(dt, engagement);
  Soul.update(dt, Evolution.dna);
  Runtime.updateParticles(dt);
  
  // Draw based on mode
  switch (Runtime.mode) {
    case 'evolution':
      drawEvolution(ctx, W, H, t, Evolution.dna, Soul);
      break;
    case 'camera':
      drawSkeletonOverlay(ctx, W, H, mp);
      drawEvolution(ctx, W, H, t, Evolution.dna, Soul);
      break;
    case 'sacred':
      drawSacredGeometry(ctx, W, H, t, mp);
      drawEvolution(ctx, W, H, t, Evolution.dna, Soul);
      break;
    case 'chakras':
      drawChakras(ctx, W, H, t, mp);
      drawSkeletonOverlay(ctx, W, H, mp);
      break;
  }
  
  Runtime.drawParticles();
  
  // Status
  const hands = mp.hands?.landmarks?.length || 0;
  const faces = mp.face?.faceLandmarks?.length || 0;
  document.getElementById('status').innerHTML = 
    `VIBEE 999 | Gen ${Evolution.generation} | ${Runtime.mode.toUpperCase()}` +
    (Runtime.mode !== 'evolution' ? `<br>Hands: ${hands} | Faces: ${faces}` : '');
  
  requestAnimationFrame(loop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Runtime.init();

document.querySelectorAll('.btn').forEach(btn => {
  btn.addEventListener('click', async () => {
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    Runtime.mode = btn.dataset.mode;
    
    if (Runtime.mode !== 'evolution' && !Runtime.mediapipe.ready) {
      document.getElementById('status').textContent = 'Loading MediaPipe...';
      await startCamera();
      await initMediaPipe();
    }
  });
});

// DNA display
function renderDNA() {
  const el = document.getElementById('dna');
  const genes = ['complexity', 'creativity', 'symmetry', 'glow'];
  el.innerHTML = genes.map(g => {
    const v = Evolution.dna[g];
    return `<div class="gene-label">${g}</div><div class="gene"><div class="gene-fill" style="width:${v*100}%;background:hsl(${v*120},70%,50%)"></div></div>`;
  }).join('');
  requestAnimationFrame(renderDNA);
}
renderDNA();

loop();
</script>
</body>
</html>
