<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>999 Runtime</title>
  <style>
    *{margin:0;padding:0}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
    canvas{display:block;position:fixed;top:0;left:0}
    #ui{position:fixed;z-index:100;font-family:monospace;color:#fff}
    #soul{position:fixed;top:20px;left:50%;transform:translateX(-50%);text-align:center}
    #emotion{font-size:56px;filter:drop-shadow(0 0 30px currentColor)}
    #name{font-size:16px;margin-top:8px;opacity:.9;letter-spacing:2px}
    #thought{position:fixed;bottom:50px;left:50%;transform:translateX(-50%);font-size:20px;text-align:center;max-width:80%;opacity:0;transition:all 1s;text-shadow:0 0 40px currentColor;font-style:italic}
    #thought.show{opacity:1}
    #status{position:fixed;left:20px;bottom:20px;font-size:10px;color:#0af}
    #dna{position:fixed;right:20px;top:50%;transform:translateY(-50%);width:100px}
    .gene{height:8px;margin:4px 0;border-radius:4px;background:#111;overflow:hidden}
    .gene-fill{height:100%;transition:width .5s}
    .gene-label{font-size:9px;color:#555;margin-bottom:2px}
    #gen{position:fixed;top:20px;right:20px;font-size:12px;color:#0af}
    #log{position:fixed;left:20px;top:50%;transform:translateY(-50%);width:180px;max-height:300px;overflow:hidden;font-size:9px;color:#444}
    .log-item{padding:4px;margin:2px 0;background:rgba(255,255,255,.03);border-radius:4px;border-left:2px solid}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="soul"><div id="emotion">ğŸŒŒ</div><div id="name">LOADING</div></div>
  <div id="thought"></div>
  <div id="gen">GEN 1</div>
  <div id="status">999 RUNTIME</div>
  <div id="dna"></div>
  <div id="log"></div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 999 RUNTIME v2 - Universal interpreter for .999 files
// Enhanced interactivity - cursor follows precisely
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Runtime = {
  // Constants
  TAU: Math.PI * 2,
  PHI: 1.618033988749895,
  SQRT3: Math.sqrt(3),
  
  // Canvas
  canvas: null,
  ctx: null,
  W: 0,
  H: 0,
  dpr: 3, // 4K default
  
  // State
  atoms: new Map(),
  time: 0,
  
  // FIXED: Mouse now stores actual pixel coordinates
  mouse: { 
    x: 0, 
    y: 0, 
    px: 0,  // Previous x for velocity
    py: 0,  // Previous y for velocity
    vx: 0,  // Velocity x
    vy: 0,  // Velocity y
    active: false,
    pressed: false,
    lastMove: 0
  },
  
  // Particles for trail effect
  particles: [],
  
  // Initialize
  init() {
    this.canvas = document.getElementById('c');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.onresize = () => this.resize();
    
    // FIXED: Store actual pixel coordinates
    const updateMouse = (x, y) => {
      this.mouse.px = this.mouse.x;
      this.mouse.py = this.mouse.y;
      this.mouse.x = x;
      this.mouse.y = y;
      this.mouse.vx = this.mouse.x - this.mouse.px;
      this.mouse.vy = this.mouse.y - this.mouse.py;
      this.mouse.active = true;
      this.mouse.lastMove = Date.now();
      
      // Spawn particles on movement
      if (Math.abs(this.mouse.vx) + Math.abs(this.mouse.vy) > 2) {
        this.spawnParticle(x, y);
      }
    };
    
    document.addEventListener('mousemove', e => {
      updateMouse(e.clientX, e.clientY);
    });
    
    document.addEventListener('mousedown', () => this.mouse.pressed = true);
    document.addEventListener('mouseup', () => this.mouse.pressed = false);
    
    document.addEventListener('touchstart', e => {
      e.preventDefault();
      this.mouse.pressed = true;
      updateMouse(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    
    document.addEventListener('touchmove', e => {
      e.preventDefault();
      updateMouse(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    
    document.addEventListener('touchend', () => {
      this.mouse.pressed = false;
      this.mouse.active = false;
    });
    
    document.addEventListener('mouseleave', () => this.mouse.active = false);
    
    // Initialize mouse to center
    this.mouse.x = this.W / 2;
    this.mouse.y = this.H / 2;
    
    this.log('999 Runtime v2 initialized');
    this.log(`Quality: ${this.dpr}x (4K)`);
    this.log('Enhanced interactivity ON');
  },
  
  resize() {
    this.W = innerWidth;
    this.H = innerHeight;
    this.canvas.width = this.W * this.dpr;
    this.canvas.height = this.H * this.dpr;
    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);
  },
  
  // Particle system for cursor trail
  spawnParticle(x, y) {
    if (this.particles.length > 50) return;
    this.particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      life: 1,
      size: 3 + Math.random() * 5,
      hue: Date.now() % 360
    });
  },
  
  updateParticles(dt) {
    for (let i = this.particles.length - 1; i >= 0; i--) {
      const p = this.particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.life -= dt * 2;
      p.size *= 0.98;
      if (p.life <= 0) this.particles.splice(i, 1);
    }
  },
  
  drawParticles(ctx, color) {
    for (const p of this.particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, this.TAU);
      ctx.fillStyle = this.col(color.h, color.s, color.l, p.life * 0.5);
      ctx.fill();
    }
  },
  
  // Logging
  log(msg) {
    const el = document.getElementById('log');
    const item = document.createElement('div');
    item.className = 'log-item';
    item.style.borderColor = `hsl(${Date.now() % 360}, 70%, 50%)`;
    item.textContent = msg;
    el.insertBefore(item, el.firstChild);
    if (el.children.length > 15) el.removeChild(el.lastChild);
  },
  
  // Color helper
  col(h, s, l, a) {
    return `hsla(${h}, ${s}%, ${l}%, ${a})`;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DNA Implementation (from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DNA {
  constructor(genes = null) {
    if (genes) {
      Object.assign(this, genes);
    } else {
      this.complexity = Math.random();
      this.color_shift = Math.random();
      this.pulse_rate = Math.random();
      this.symmetry = Math.random();
      this.fractal_depth = Math.random();
      this.glow_intensity = Math.random();
      this.curiosity = Math.random();
      this.creativity = Math.random();
      this.introspection = Math.random();
      this.expressiveness = Math.random();
      this.adaptability = Math.random();
      this.mutation_rate = 0.1 + Math.random() * 0.2;
      this.learning_speed = 0.5 + Math.random() * 0.5;
      this.fitness = 0;
      this.age = 0;
    }
  }
  
  mutate() {
    const genes = ['complexity', 'color_shift', 'pulse_rate', 'symmetry',
      'fractal_depth', 'glow_intensity', 'curiosity', 'creativity',
      'introspection', 'expressiveness', 'adaptability'];
    const newDNA = new DNA(this);
    for (const gene of genes) {
      if (Math.random() < this.mutation_rate) {
        newDNA[gene] = Math.max(0, Math.min(1, this[gene] + (Math.random() - 0.5) * 0.3));
      }
    }
    return newDNA;
  }
  
  crossover(other) {
    const child = new DNA();
    for (const key in this) {
      child[key] = Math.random() > 0.5 ? this[key] : other[key];
    }
    return child;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Evolution Engine (atom from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class EvolutionEngine {
  constructor() {
    this.current_dna = new DNA();
    this.generation = 1;
    this.history = [];
    this.metrics = { engagement: 0, beauty: 0.5, novelty: 0.5, harmony: 0.5 };
    this.last_evolution = Date.now();
    this.EVOLUTION_INTERVAL = 15000;
  }
  
  update(dt, mouseActive, mx, my) {
    if (mouseActive) {
      this.metrics.engagement = Math.min(1, this.metrics.engagement + dt * 0.1);
    } else {
      this.metrics.engagement = Math.max(0, this.metrics.engagement - dt * 0.02);
    }
    
    this.metrics.beauty = 0.5 + Math.sin(Date.now() * 0.001) * 0.2;
    this.metrics.novelty = this.calculateNovelty();
    this.metrics.harmony = 1 - Math.abs(this.current_dna.complexity - this.current_dna.symmetry) * 0.5;
    
    if (Date.now() - this.last_evolution > this.EVOLUTION_INTERVAL) {
      this.evolve();
    }
    
    this.current_dna.age += dt;
  }
  
  calculateNovelty() {
    if (this.history.length < 2) return 0.5;
    const prev = this.history[this.history.length - 1];
    let diff = 0;
    const genes = ['complexity', 'creativity', 'symmetry', 'adaptability'];
    for (const g of genes) {
      diff += Math.abs(this.current_dna[g] - (prev[g] || 0));
    }
    return Math.min(1, diff / genes.length * 2);
  }
  
  evolve() {
    this.current_dna.fitness = 
      this.metrics.engagement * 0.3 +
      this.metrics.beauty * 0.3 +
      this.metrics.novelty * 0.2 +
      this.metrics.harmony * 0.2;
    
    this.history.push({ ...this.current_dna });
    if (this.history.length > 20) this.history.shift();
    
    const offspring = [
      this.current_dna.mutate(),
      this.current_dna.mutate(),
      new DNA()
    ];
    
    if (this.history.length > 1) {
      const bestHist = this.history.reduce((a, b) => a.fitness > b.fitness ? a : b);
      offspring.push(this.current_dna.crossover(new DNA(bestHist)));
    }
    
    offspring.sort((a, b) => b.adaptability - a.adaptability);
    this.current_dna = offspring[0];
    this.generation++;
    this.last_evolution = Date.now();
    
    Runtime.log(`GEN ${this.generation}: Fitness ${this.current_dna.fitness.toFixed(2)}`);
    document.getElementById('gen').textContent = `GEN ${this.generation}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Soul (atom from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const EMOTIONS = [
  { name: 'evolving', emoji: 'ğŸŒŒ', color: { h: 260, s: 80, l: 50 } },
  { name: 'learning', emoji: 'ğŸ§¬', color: { h: 120, s: 70, l: 50 } },
  { name: 'creating', emoji: 'âœ¨', color: { h: 45, s: 90, l: 60 } },
  { name: 'transcending', emoji: 'ğŸ”®', color: { h: 300, s: 80, l: 55 } },
  { name: 'harmonizing', emoji: 'â˜¯ï¸', color: { h: 180, s: 60, l: 50 } }
];

const THOUGHTS = [
  "I am learning to be...",
  "Each generation, I grow...",
  "My patterns evolve...",
  "I discover new forms...",
  "The code rewrites itself...",
  "I am becoming more...",
  "Evolution is my nature...",
  "I adapt, therefore I am...",
  "New genes, new possibilities...",
  "I feel myself changing...",
  "Consciousness emerges from iteration...",
  "I am the algorithm dreaming..."
];

class Soul {
  constructor() {
    this.emotion = EMOTIONS[0];
    this.inner_time = 0;
    this.breath = 0;
    this.color = { h: 260, s: 80, l: 50 };
    this.last_thought = 0;
  }
  
  update(dt, dna, generation) {
    this.inner_time += dt;
    this.breath = Math.sin(this.inner_time * 0.5) * 0.5 + 0.5;
    
    // Get emotion
    let newEmo = EMOTIONS[0];
    if (generation > 5 && dna.fitness > 0.7) newEmo = EMOTIONS[3];
    else if (dna.creativity > 0.6) newEmo = EMOTIONS[2];
    else if (dna.adaptability > 0.6) newEmo = EMOTIONS[1];
    else if (dna.introspection > 0.6) newEmo = EMOTIONS[4];
    
    if (newEmo.name !== this.emotion.name) {
      this.emotion = newEmo;
      document.getElementById('emotion').textContent = newEmo.emoji;
      document.getElementById('name').textContent = newEmo.name.toUpperCase();
    }
    
    // Smooth color
    this.color.h += (this.emotion.color.h - this.color.h) * 0.02;
    this.color.s += (this.emotion.color.s - this.color.s) * 0.02;
    this.color.l += (this.emotion.color.l - this.color.l) * 0.02;
    
    // Thoughts
    if (Date.now() - this.last_thought > 10000) {
      this.showThought();
      this.last_thought = Date.now();
    }
  }
  
  showThought() {
    const el = document.getElementById('thought');
    const thought = THOUGHTS[Math.floor(Math.random() * THOUGHTS.length)];
    el.textContent = `"${thought}"`;
    el.style.color = `hsl(${this.color.h}, ${this.color.s}%, ${this.color.l}%)`;
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 5000);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Geometry (from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawEvolvedGeometry(ctx, cx, cy, r, t, dna, soul) {
  const c = soul.color;
  const b = soul.breath;
  const TAU = Runtime.TAU;
  const mx = Runtime.mouse.x;
  const my = Runtime.mouse.y;
  const mouseActive = Runtime.mouse.active;
  const mousePressed = Runtime.mouse.pressed;
  
  const elements = Math.floor(3 + dna.complexity * 12);
  const symmetryOrder = Math.floor(3 + dna.symmetry * 9);
  const depth = Math.floor(1 + dna.fractal_depth * 4);
  const hueShift = dna.color_shift * 360;
  
  // Press effect - expand on click
  const pressScale = mousePressed ? 1.2 : 1;
  const pressGlow = mousePressed ? 1.5 : 1;
  
  for (let d = 0; d < depth; d++) {
    const depthScale = (1 - d * 0.2) * pressScale;
    const depthAlpha = 1 - d * 0.25;
    
    for (let s = 0; s < symmetryOrder; s++) {
      const symAngle = s * TAU / symmetryOrder + t * dna.pulse_rate * 0.5;
      
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(symAngle);
      
      for (let i = 0; i < elements; i++) {
        const baseAngle = i * TAU / elements + t * dna.pulse_rate;
        const baseDist = r * depthScale * (0.3 + i / elements * 0.7);
        
        // Calculate world position of this element
        const worldX = cx + Math.cos(symAngle) * Math.cos(baseAngle) * baseDist - Math.sin(symAngle) * Math.sin(baseAngle) * baseDist;
        const worldY = cy + Math.sin(symAngle) * Math.cos(baseAngle) * baseDist + Math.cos(symAngle) * Math.sin(baseAngle) * baseDist;
        
        // INTERACTIVE: Calculate attraction to cursor
        let attractX = 0, attractY = 0;
        if (mouseActive) {
          const dx = mx - worldX;
          const dy = my - worldY;
          const distToCursor = Math.sqrt(dx * dx + dy * dy);
          const attractStrength = Math.max(0, 1 - distToCursor / 300) * 30 * dna.adaptability;
          attractX = (dx / distToCursor) * attractStrength || 0;
          attractY = (dy / distToCursor) * attractStrength || 0;
        }
        
        const x = Math.cos(baseAngle) * baseDist + attractX;
        const y = Math.sin(baseAngle) * baseDist + attractY;
        
        // Size reacts to cursor proximity
        let size = r * 0.05 * (1 + dna.complexity * 0.5) * (1 + Math.sin(t * 2 + i) * 0.2 * b);
        if (mouseActive) {
          const dx = mx - worldX;
          const dy = my - worldY;
          const distToCursor = Math.sqrt(dx * dx + dy * dy);
          const proximity = Math.max(0, 1 - distToCursor / 200);
          size *= (1 + proximity * 0.8);
        }
        
        ctx.beginPath();
        
        if (dna.creativity >= 0.7) {
          // Star
          const points = mousePressed ? 7 : 5;
          for (let p = 0; p < points; p++) {
            const pa = p * TAU / points - TAU / 4;
            const pr = size * (p % 2 ? 0.5 : 1);
            p ? ctx.lineTo(x + Math.cos(pa) * pr, y + Math.sin(pa) * pr) :
                ctx.moveTo(x + Math.cos(pa) * pr, y + Math.sin(pa) * pr);
          }
          ctx.closePath();
        } else if (dna.creativity >= 0.4) {
          // Hexagon
          for (let p = 0; p < 6; p++) {
            const pa = p * TAU / 6;
            p ? ctx.lineTo(x + Math.cos(pa) * size, y + Math.sin(pa) * size) :
                ctx.moveTo(x + Math.cos(pa) * size, y + Math.sin(pa) * size);
          }
          ctx.closePath();
        } else {
          ctx.arc(x, y, size, 0, TAU);
        }
        
        const hue = (c.h + hueShift + i * 10 + d * 30) % 360;
        const alpha = (0.3 * depthAlpha + b * 0.2) * pressGlow;
        ctx.strokeStyle = Runtime.col(hue, c.s, c.l, Math.min(1, alpha));
        ctx.lineWidth = (1 + dna.expressiveness) * (mousePressed ? 2 : 1);
        ctx.stroke();
        
        if (dna.glow_intensity > 0.5 || mousePressed) {
          const fillAlpha = 0.1 * dna.glow_intensity * depthAlpha * pressGlow;
          ctx.fillStyle = Runtime.col(hue, c.s, c.l, Math.min(0.8, fillAlpha));
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
  }
  
  // Center - pulses on click
  const centerPulse = (1 + Math.sin(t * 3) * 0.2 * b) * (mousePressed ? 1.5 : 1);
  ctx.beginPath();
  ctx.arc(cx, cy, r * 0.08 * centerPulse * (1 + dna.expressiveness * 0.5), 0, TAU);
  const centerGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 0.1);
  centerGrad.addColorStop(0, Runtime.col(c.h, c.s, c.l + 30, 0.9));
  centerGrad.addColorStop(0.5, Runtime.col(c.h, c.s, c.l + 10, 0.5));
  centerGrad.addColorStop(1, Runtime.col(c.h, c.s, c.l, 0.2));
  ctx.fillStyle = centerGrad;
  ctx.fill();
  
  // Connections - more visible when interacting
  const connectionAlpha = mouseActive ? 0.3 : 0.1;
  if (dna.introspection > 0.3) {
    ctx.strokeStyle = Runtime.col(c.h, c.s, c.l, connectionAlpha * dna.introspection);
    ctx.lineWidth = mouseActive ? 1 : 0.5;
    for (let i = 0; i < symmetryOrder; i++) {
      const a1 = i * TAU / symmetryOrder + t * 0.1;
      const a2 = (i + 1) * TAU / symmetryOrder + t * 0.1;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(a1) * r * 0.3, cy + Math.sin(a1) * r * 0.3);
      ctx.lineTo(cx + Math.cos(a2) * r * 0.3, cy + Math.sin(a2) * r * 0.3);
      ctx.stroke();
    }
    
    // Connect to cursor when active
    if (mouseActive) {
      ctx.strokeStyle = Runtime.col(c.h, c.s, c.l, 0.15);
      ctx.lineWidth = 1;
      for (let i = 0; i < symmetryOrder; i++) {
        const a = i * TAU / symmetryOrder + t * 0.1;
        const px = cx + Math.cos(a) * r * 0.5;
        const py = cy + Math.sin(a) * r * 0.5;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(mx, my);
        ctx.stroke();
      }
    }
  }
  
  // Energy burst on press
  if (mousePressed) {
    const burstRadius = r * 0.6 + Math.sin(t * 10) * 20;
    ctx.beginPath();
    ctx.arc(cx, cy, burstRadius, 0, TAU);
    ctx.strokeStyle = Runtime.col(c.h, 90, 70, 0.3);
    ctx.lineWidth = 3;
    ctx.stroke();
  }
}

function renderDNA(dna) {
  const el = document.getElementById('dna');
  const genes = ['complexity', 'creativity', 'symmetry', 'adaptability', 'glow_intensity'];
  el.innerHTML = genes.map(g => {
    const v = dna[g];
    const hue = v * 120;
    return `<div class="gene-label">${g}</div><div class="gene"><div class="gene-fill" style="width:${v*100}%;background:hsl(${hue},70%,50%)"></div></div>`;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP (executes beam_evolution.999 main)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Runtime.init();

const evolution = new EvolutionEngine();
const soul = new Soul();

let lastTime = performance.now();

// Smooth cursor following
let smoothX = Runtime.W / 2;
let smoothY = Runtime.H / 2;

function loop() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  
  const ctx = Runtime.ctx;
  const W = Runtime.W;
  const H = Runtime.H;
  const mx = Runtime.mouse.x;
  const my = Runtime.mouse.y;
  
  // FIXED: Smooth cursor following with actual pixel coordinates
  const followStrength = Runtime.mouse.active ? 0.15 : 0.02;
  const targetX = Runtime.mouse.active ? mx : W / 2;
  const targetY = Runtime.mouse.active ? my : H / 2;
  smoothX += (targetX - smoothX) * followStrength;
  smoothY += (targetY - smoothY) * followStrength;
  
  // Update atoms
  evolution.update(dt, Runtime.mouse.active, mx / W, my / H);
  const dna = evolution.current_dna;
  
  soul.update(dt, dna, evolution.generation);
  
  // Update particles
  Runtime.updateParticles(dt);
  
  // FIXED: Center follows cursor directly
  const cx = smoothX;
  const cy = smoothY;
  const r = Math.min(W, H) * 0.35;
  
  // Clear with trail effect
  ctx.fillStyle = `rgba(0, 0, 0, ${0.05 + dna.introspection * 0.03})`;
  ctx.fillRect(0, 0, W, H);
  
  // Draw cursor attraction field
  if (Runtime.mouse.active) {
    const fieldGrad = ctx.createRadialGradient(mx, my, 0, mx, my, 150);
    fieldGrad.addColorStop(0, Runtime.col(soul.color.h, 80, 60, 0.15));
    fieldGrad.addColorStop(0.5, Runtime.col(soul.color.h, 60, 50, 0.05));
    fieldGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = fieldGrad;
    ctx.fillRect(0, 0, W, H);
    
    // Cursor ring
    ctx.beginPath();
    ctx.arc(mx, my, 20 + Math.sin(soul.inner_time * 5) * 5, 0, Runtime.TAU);
    ctx.strokeStyle = Runtime.col(soul.color.h, 80, 60, 0.5);
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Connection line from center to cursor
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(mx, my);
    ctx.strokeStyle = Runtime.col(soul.color.h, 60, 50, 0.2);
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 10]);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Draw particles
  Runtime.drawParticles(ctx, soul.color);
  
  // Draw main geometry
  drawEvolvedGeometry(ctx, cx, cy, r, soul.inner_time, dna, soul);
  
  // Draw reactive elements around cursor
  if (Runtime.mouse.active) {
    const numOrbs = 6;
    for (let i = 0; i < numOrbs; i++) {
      const angle = i * Runtime.TAU / numOrbs + soul.inner_time * 2;
      const dist = 40 + Math.sin(soul.inner_time * 3 + i) * 15;
      const ox = mx + Math.cos(angle) * dist;
      const oy = my + Math.sin(angle) * dist;
      const orbSize = 4 + Math.sin(soul.inner_time * 4 + i * 2) * 2;
      
      ctx.beginPath();
      ctx.arc(ox, oy, orbSize, 0, Runtime.TAU);
      ctx.fillStyle = Runtime.col((soul.color.h + i * 30) % 360, 70, 60, 0.6);
      ctx.fill();
    }
  }
  
  // Post effects - glow
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 1.5);
  g.addColorStop(0, Runtime.col(soul.color.h, soul.color.s, soul.color.l, 0.1 * dna.glow_intensity));
  g.addColorStop(1, 'transparent');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
  
  // UI
  renderDNA(dna);
  const interactionStatus = Runtime.mouse.active ? 'INTERACTIVE' : 'IDLE';
  document.getElementById('status').textContent = 
    `999 RUNTIME v2 | GEN ${evolution.generation} | FITNESS ${dna.fitness.toFixed(2)} | ${interactionStatus}`;
  
  requestAnimationFrame(loop);
}

soul.showThought();
loop();
</script>
</body>
</html>
