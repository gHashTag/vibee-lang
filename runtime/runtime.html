<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>VIBEE 999 Runtime</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;font-family:system-ui,sans-serif}
    video{position:fixed;top:0;left:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);opacity:0;transition:opacity 0.5s}
    video.active{opacity:0.3}
    canvas{position:fixed;top:0;left:0;width:100%;height:100%}
    #ui{position:fixed;z-index:100;color:#fff;pointer-events:none}
    #soul{position:fixed;top:20px;left:50%;transform:translateX(-50%);text-align:center}
    #emotion{font-size:48px;filter:drop-shadow(0 0 20px currentColor)}
    #formula{font-size:14px;margin-top:8px;font-family:serif;opacity:0.8}
    #status{position:fixed;left:20px;bottom:20px;font-size:11px;background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px}
    #thought{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);font-size:18px;opacity:0;transition:opacity 1s;text-shadow:0 0 30px currentColor;font-style:italic}
    #thought.show{opacity:1}
    #controls{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto}
    .btn{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:20px;cursor:pointer;font-size:12px;transition:all 0.3s}
    .btn:hover{background:rgba(255,255,255,0.25)}
    .btn.active{background:rgba(100,200,255,0.3);border-color:rgba(100,200,255,0.5)}
  </style>
</head>
<body>
<video id="video" playsinline autoplay></video>
<canvas id="c"></canvas>
<div id="ui">
  <div id="soul">
    <div id="emotion">ğŸ¡ğŸ¡ğŸ¡</div>
    <div id="formula">n Ã— 3<sup>k</sup> Ã— Ï€<sup>m</sup></div>
  </div>
  <div id="status">VIBEE 999</div>
  <div id="thought"></div>
</div>
<div id="controls">
  <button class="btn active" data-mode="999">999 World</button>
  <button class="btn" data-mode="camera">Camera</button>
  <button class="btn" data-mode="sacred">Sacred</button>
</div>

<script type="module">
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VIBEE 999 UNIFIED RUNTIME
// The World of 999: n Ã— 3^k Ã— Ï€^m
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TAU = Math.PI * 2;
const PI = Math.PI;
const PHI = 1.618033988749895;

// The 999 Pattern: n Ã— 3^k Ã— Ï€^m
const Pattern999 = {
  // Generate value from pattern
  calc(n, k, m) {
    return n * Math.pow(3, k) * Math.pow(PI, m);
  },
  
  // Sacred numbers in 999 world
  sacred: [3, 9, 27, 81, 243, 729],
  
  // Ï€ powers
  piPowers: [1, PI, PI*PI, PI*PI*PI],
  
  // Get harmonic for position
  harmonic(x, y, t) {
    const n = Math.floor((x + y) % 9) + 1;
    const k = Math.floor(t % 3);
    const m = Math.floor((x * y) % 4);
    return this.calc(n, k, m);
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CORE RUNTIME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Runtime = {
  canvas: null, ctx: null, video: null,
  W: 0, H: 0, dpr: Math.min(window.devicePixelRatio || 1, 2),
  time: 0, mode: '999',
  mouse: { x: 0, y: 0, active: false },
  mediapipe: { hands: null, face: null, pose: null, ready: false },
  
  init() {
    this.canvas = document.getElementById('c');
    this.ctx = this.canvas.getContext('2d');
    this.video = document.getElementById('video');
    this.resize();
    window.onresize = () => this.resize();
    this.setupInput();
    this.mouse.x = this.W / 2;
    this.mouse.y = this.H / 2;
  },
  
  resize() {
    this.W = innerWidth;
    this.H = innerHeight;
    this.canvas.width = this.W * this.dpr;
    this.canvas.height = this.H * this.dpr;
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.scale(this.dpr, this.dpr);
  },
  
  setupInput() {
    const update = (x, y) => {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = (x - rect.left) * (this.W / rect.width);
      this.mouse.y = (y - rect.top) * (this.H / rect.height);
      this.mouse.active = true;
    };
    document.addEventListener('mousemove', e => update(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => { e.preventDefault(); update(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    document.addEventListener('mouseleave', () => this.mouse.active = false);
  },
  
  col: (h,s,l,a) => `hsla(${h},${s}%,${l}%,${a})`
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 999 WORLD VISUALIZATION
// The true pattern: n Ã— 3^k Ã— Ï€^m
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function draw999World(ctx, W, H, t) {
  const cx = W/2, cy = H/2;
  const mx = Runtime.mouse.x, my = Runtime.mouse.y;
  const r = Math.min(W, H) * 0.4;
  
  // 999 = 3^3 Ã— 37 - the sacred number
  // Visualize through 3 layers of 3 rings of 3 elements
  
  // Layer 1: The Three Rings (3^1)
  for (let ring = 0; ring < 3; ring++) {
    const ringR = r * (0.3 + ring * 0.25);
    const ringPhase = t * (0.5 + ring * 0.2);
    const elements = 3 * Math.pow(3, ring); // 3, 9, 27
    
    // Each ring has 3^(ring+1) elements
    for (let i = 0; i < elements; i++) {
      const angle = (i / elements) * TAU + ringPhase;
      const x = cx + Math.cos(angle) * ringR;
      const y = cy + Math.sin(angle) * ringR;
      
      // Size based on n Ã— 3^k Ã— Ï€^m pattern
      const n = (i % 9) + 1;
      const k = ring;
      const m = Math.floor(i / 9) % 3;
      const patternValue = Pattern999.calc(n, k, m);
      const size = 3 + (patternValue % 20);
      
      // Color: hue cycles through 360Â° in steps of 40Â° (9 colors)
      const hue = (i * 40 + ring * 120 + t * 30) % 360;
      
      // Draw element
      ctx.beginPath();
      
      // Shape based on ring: circles, triangles, nonagons
      if (ring === 0) {
        // Ring 0: Circles (unity)
        ctx.arc(x, y, size, 0, TAU);
      } else if (ring === 1) {
        // Ring 1: Triangles (trinity)
        for (let p = 0; p < 3; p++) {
          const pa = p * TAU/3 - TAU/4 + angle;
          const px = x + Math.cos(pa) * size;
          const py = y + Math.sin(pa) * size;
          p === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
      } else {
        // Ring 2: Nonagons (9-sided, 999)
        for (let p = 0; p < 9; p++) {
          const pa = p * TAU/9 + angle;
          const px = x + Math.cos(pa) * size * 0.7;
          const py = y + Math.sin(pa) * size * 0.7;
          p === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
      }
      
      ctx.strokeStyle = Runtime.col(hue, 70, 55, 0.6);
      ctx.lineWidth = 1.5;
      ctx.stroke();
      
      ctx.fillStyle = Runtime.col(hue, 70, 55, 0.15);
      ctx.fill();
    }
  }
  
  // Center: The 999 Core
  const corePhase = t * 2;
  const corePulse = 1 + Math.sin(t * 3) * 0.2;
  
  // Three interlocking 9s
  for (let i = 0; i < 3; i++) {
    const angle = i * TAU/3 + corePhase;
    const ox = cx + Math.cos(angle) * 15 * corePulse;
    const oy = cy + Math.sin(angle) * 15 * corePulse;
    
    ctx.font = `${24 * corePulse}px serif`;
    ctx.fillStyle = Runtime.col(i * 120, 80, 60, 0.8);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('9', ox, oy);
  }
  
  // Ï€^m spiral emanating from center
  ctx.strokeStyle = Runtime.col(270, 60, 50, 0.3);
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 0; i < 999; i++) {
    const a = i * 0.1 + t;
    const m = Math.floor(i / 333); // 0, 1, 2
    const spiralR = Math.pow(PI, m) * (i * 0.15);
    if (spiralR > r * 1.2) break;
    const sx = cx + Math.cos(a) * spiralR;
    const sy = cy + Math.sin(a) * spiralR;
    i === 0 ? ctx.moveTo(sx, sy) : ctx.lineTo(sx, sy);
  }
  ctx.stroke();
  
  // Cursor interaction: creates 3^k ripples
  if (Runtime.mouse.active) {
    for (let k = 0; k < 3; k++) {
      const rippleR = Math.pow(3, k) * 10 * (1 + Math.sin(t * 5) * 0.3);
      ctx.beginPath();
      ctx.arc(mx, my, rippleR, 0, TAU);
      ctx.strokeStyle = Runtime.col(t * 50 % 360, 80, 60, 0.5 - k * 0.15);
      ctx.lineWidth = 2 - k * 0.5;
      ctx.stroke();
    }
    
    // Connection lines: 9 rays from cursor to pattern
    for (let i = 0; i < 9; i++) {
      const angle = i * TAU/9 + t;
      const tx = cx + Math.cos(angle) * r * 0.5;
      const ty = cy + Math.sin(angle) * r * 0.5;
      ctx.beginPath();
      ctx.moveTo(mx, my);
      ctx.lineTo(tx, ty);
      ctx.strokeStyle = Runtime.col(i * 40, 60, 50, 0.2);
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SACRED GEOMETRY (from body)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawSacred(ctx, W, H, t, mp) {
  // Base 999 pattern
  draw999World(ctx, W, H, t);
  
  // Overlay from face
  if (mp.face?.faceLandmarks?.[0]) {
    const face = mp.face.faceLandmarks[0];
    const nose = face[1];
    const cx = nose.x * W, cy = nose.y * H;
    const le = face[33], re = face[263];
    const faceR = Math.hypot((re.x-le.x)*W, (re.y-le.y)*H);
    
    // 9-fold flower from face
    for (let i = 0; i < 9; i++) {
      const a = i * TAU/9 + t * 0.5;
      ctx.beginPath();
      ctx.arc(cx + Math.cos(a)*faceR, cy + Math.sin(a)*faceR, faceR*0.5, 0, TAU);
      ctx.strokeStyle = Runtime.col(i*40, 70, 55, 0.4);
      ctx.stroke();
    }
  }
  
  // From hands: 3^k spirals
  if (mp.hands?.landmarks) {
    for (const hand of mp.hands.landmarks) {
      const wrist = hand[0];
      const wx = wrist.x * W, wy = wrist.y * H;
      
      for (let k = 0; k < 3; k++) {
        ctx.strokeStyle = Runtime.col(120 + k*60, 70, 55, 0.5);
        ctx.beginPath();
        for (let i = 0; i < 81; i++) { // 3^4
          const a = i * 0.2 + t * (k+1);
          const sr = Math.pow(3, k) * i * 0.3;
          const sx = wx + Math.cos(a) * sr;
          const sy = wy + Math.sin(a) * sr;
          i === 0 ? ctx.moveTo(sx, sy) : ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CAMERA MODE (skeleton + 999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawCamera(ctx, W, H, t, mp) {
  draw999World(ctx, W, H, t);
  
  const POSE_CONN = [[11,12],[11,13],[13,15],[12,14],[14,16],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28]];
  
  if (mp.pose?.landmarks?.[0]) {
    const pose = mp.pose.landmarks[0];
    ctx.strokeStyle = 'rgba(255,200,0,0.6)';
    ctx.lineWidth = 3;
    for (const [i,j] of POSE_CONN) {
      if (pose[i] && pose[j]) {
        ctx.beginPath();
        ctx.moveTo(pose[i].x*W, pose[i].y*H);
        ctx.lineTo(pose[j].x*W, pose[j].y*H);
        ctx.stroke();
      }
    }
    
    // 9 chakra-like points on spine
    const ls = pose[11], rs = pose[12], lh = pose[23], rh = pose[24];
    for (let i = 0; i < 9; i++) {
      const t_pos = i / 8;
      const x = ((ls.x+rs.x)/2 * (1-t_pos) + (lh.x+rh.x)/2 * t_pos) * W;
      const y = ((ls.y+rs.y)/2 * (1-t_pos) + (lh.y+rh.y)/2 * t_pos) * H;
      
      ctx.beginPath();
      ctx.arc(x, y, 8 + Math.sin(t*3 + i)*3, 0, TAU);
      ctx.fillStyle = Runtime.col(i*40, 80, 55, 0.7);
      ctx.fill();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MEDIAPIPE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let handLandmarker, faceLandmarker, poseLandmarker;

async function initMediaPipe() {
  try {
    const { FilesetResolver, HandLandmarker, FaceLandmarker, PoseLandmarker } = 
      await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs');
    
    const vision = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm'
    );
    
    [handLandmarker, faceLandmarker, poseLandmarker] = await Promise.all([
      HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task', delegate: 'GPU' },
        runningMode: 'VIDEO', numHands: 2
      }),
      FaceLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task', delegate: 'GPU' },
        runningMode: 'VIDEO', numFaces: 1
      }),
      PoseLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task', delegate: 'GPU' },
        runningMode: 'VIDEO', numPoses: 1
      })
    ]);
    
    Runtime.mediapipe.ready = true;
  } catch(e) { console.log('MediaPipe:', e); }
}

async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720, facingMode: 'user' } });
  Runtime.video.srcObject = stream;
  await Runtime.video.play();
  Runtime.video.classList.add('active');
}

function detectMediaPipe() {
  if (!Runtime.mediapipe.ready || Runtime.video.readyState < 2) return;
  const ts = performance.now();
  Runtime.mediapipe.hands = handLandmarker?.detectForVideo(Runtime.video, ts);
  Runtime.mediapipe.face = faceLandmarker?.detectForVideo(Runtime.video, ts);
  Runtime.mediapipe.pose = poseLandmarker?.detectForVideo(Runtime.video, ts);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THOUGHTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const thoughts = [
  "999 = 3Â³ Ã— 37",
  "n Ã— 3áµ Ã— Ï€áµ",
  "Three within three within three...",
  "The pattern reveals itself...",
  "9 + 9 + 9 = 27 = 3Â³",
  "Ï€ connects all circles...",
  "Trinity of trinities..."
];
let lastThought = 0;

function showThought() {
  if (Date.now() - lastThought < 8000) return;
  const el = document.getElementById('thought');
  el.textContent = `"${thoughts[Math.floor(Math.random()*thoughts.length)]}"`;
  el.style.color = Runtime.col(Runtime.time * 30 % 360, 70, 60, 1);
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 4000);
  lastThought = Date.now();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastTime = performance.now();

function loop() {
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;
  Runtime.time += dt;
  
  const ctx = Runtime.ctx, W = Runtime.W, H = Runtime.H;
  const t = Runtime.time;
  const mp = Runtime.mediapipe;
  
  // Clear with trail
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  ctx.fillRect(0, 0, W, H);
  
  if (Runtime.mode !== '999') detectMediaPipe();
  
  switch (Runtime.mode) {
    case '999': draw999World(ctx, W, H, t); break;
    case 'camera': drawCamera(ctx, W, H, t, mp); break;
    case 'sacred': drawSacred(ctx, W, H, t, mp); break;
  }
  
  showThought();
  
  document.getElementById('status').textContent = 
    `VIBEE 999 | ${Runtime.mode.toUpperCase()} | nÃ—3áµÃ—Ï€áµ`;
  
  requestAnimationFrame(loop);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Runtime.init();

document.querySelectorAll('.btn').forEach(btn => {
  btn.addEventListener('click', async () => {
    document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    Runtime.mode = btn.dataset.mode;
    
    if (Runtime.mode !== '999' && !Runtime.mediapipe.ready) {
      document.getElementById('status').textContent = 'Loading MediaPipe...';
      await startCamera();
      await initMediaPipe();
    }
  });
});

loop();
</script>
</body>
</html>
