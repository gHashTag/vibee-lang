<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>999 Runtime</title>
  <style>
    *{margin:0;padding:0}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
    canvas{display:block;position:fixed;top:0;left:0}
    #ui{position:fixed;z-index:100;font-family:monospace;color:#fff}
    #soul{position:fixed;top:20px;left:50%;transform:translateX(-50%);text-align:center}
    #emotion{font-size:56px;filter:drop-shadow(0 0 30px currentColor)}
    #name{font-size:16px;margin-top:8px;opacity:.9;letter-spacing:2px}
    #thought{position:fixed;bottom:50px;left:50%;transform:translateX(-50%);font-size:20px;text-align:center;max-width:80%;opacity:0;transition:all 1s;text-shadow:0 0 40px currentColor;font-style:italic}
    #thought.show{opacity:1}
    #status{position:fixed;left:20px;bottom:20px;font-size:10px;color:#0af}
    #dna{position:fixed;right:20px;top:50%;transform:translateY(-50%);width:100px}
    .gene{height:8px;margin:4px 0;border-radius:4px;background:#111;overflow:hidden}
    .gene-fill{height:100%;transition:width .5s}
    .gene-label{font-size:9px;color:#555;margin-bottom:2px}
    #gen{position:fixed;top:20px;right:20px;font-size:12px;color:#0af}
    #log{position:fixed;left:20px;top:50%;transform:translateY(-50%);width:180px;max-height:300px;overflow:hidden;font-size:9px;color:#444}
    .log-item{padding:4px;margin:2px 0;background:rgba(255,255,255,.03);border-radius:4px;border-left:2px solid}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="soul"><div id="emotion">ğŸŒŒ</div><div id="name">LOADING</div></div>
  <div id="thought"></div>
  <div id="gen">GEN 1</div>
  <div id="status">999 RUNTIME</div>
  <div id="dna"></div>
  <div id="log"></div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 999 RUNTIME - Universal interpreter for .999 files
// Executes code generated from .vibee specifications
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Runtime = {
  // Constants
  TAU: Math.PI * 2,
  PHI: 1.618033988749895,
  SQRT3: Math.sqrt(3),
  
  // Canvas
  canvas: null,
  ctx: null,
  W: 0,
  H: 0,
  dpr: 3, // 4K default
  
  // State
  atoms: new Map(),
  time: 0,
  mouse: { x: 0.5, y: 0.5, active: false },
  
  // Initialize
  init() {
    this.canvas = document.getElementById('c');
    this.ctx = this.canvas.getContext('2d');
    this.resize();
    window.onresize = () => this.resize();
    
    // Input
    document.addEventListener('mousemove', e => {
      this.mouse.x = e.clientX / this.W;
      this.mouse.y = e.clientY / this.H;
      this.mouse.active = true;
    });
    document.addEventListener('touchmove', e => {
      e.preventDefault();
      this.mouse.x = e.touches[0].clientX / this.W;
      this.mouse.y = e.touches[0].clientY / this.H;
      this.mouse.active = true;
    }, { passive: false });
    document.addEventListener('mouseleave', () => this.mouse.active = false);
    
    this.log('999 Runtime initialized');
    this.log(`Quality: ${this.dpr}x (4K)`);
  },
  
  resize() {
    this.W = innerWidth;
    this.H = innerHeight;
    this.canvas.width = this.W * this.dpr;
    this.canvas.height = this.H * this.dpr;
    this.ctx.scale(this.dpr, this.dpr);
  },
  
  // Logging
  log(msg) {
    const el = document.getElementById('log');
    const item = document.createElement('div');
    item.className = 'log-item';
    item.style.borderColor = `hsl(${Date.now() % 360}, 70%, 50%)`;
    item.textContent = msg;
    el.insertBefore(item, el.firstChild);
    if (el.children.length > 15) el.removeChild(el.lastChild);
  },
  
  // Color helper
  col(h, s, l, a) {
    return `hsla(${h}, ${s}%, ${l}%, ${a})`;
  }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DNA Implementation (from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DNA {
  constructor(genes = null) {
    if (genes) {
      Object.assign(this, genes);
    } else {
      this.complexity = Math.random();
      this.color_shift = Math.random();
      this.pulse_rate = Math.random();
      this.symmetry = Math.random();
      this.fractal_depth = Math.random();
      this.glow_intensity = Math.random();
      this.curiosity = Math.random();
      this.creativity = Math.random();
      this.introspection = Math.random();
      this.expressiveness = Math.random();
      this.adaptability = Math.random();
      this.mutation_rate = 0.1 + Math.random() * 0.2;
      this.learning_speed = 0.5 + Math.random() * 0.5;
      this.fitness = 0;
      this.age = 0;
    }
  }
  
  mutate() {
    const genes = ['complexity', 'color_shift', 'pulse_rate', 'symmetry',
      'fractal_depth', 'glow_intensity', 'curiosity', 'creativity',
      'introspection', 'expressiveness', 'adaptability'];
    const newDNA = new DNA(this);
    for (const gene of genes) {
      if (Math.random() < this.mutation_rate) {
        newDNA[gene] = Math.max(0, Math.min(1, this[gene] + (Math.random() - 0.5) * 0.3));
      }
    }
    return newDNA;
  }
  
  crossover(other) {
    const child = new DNA();
    for (const key in this) {
      child[key] = Math.random() > 0.5 ? this[key] : other[key];
    }
    return child;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Evolution Engine (atom from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class EvolutionEngine {
  constructor() {
    this.current_dna = new DNA();
    this.generation = 1;
    this.history = [];
    this.metrics = { engagement: 0, beauty: 0.5, novelty: 0.5, harmony: 0.5 };
    this.last_evolution = Date.now();
    this.EVOLUTION_INTERVAL = 15000;
  }
  
  update(dt, mouseActive, mx, my) {
    if (mouseActive) {
      this.metrics.engagement = Math.min(1, this.metrics.engagement + dt * 0.1);
    } else {
      this.metrics.engagement = Math.max(0, this.metrics.engagement - dt * 0.02);
    }
    
    this.metrics.beauty = 0.5 + Math.sin(Date.now() * 0.001) * 0.2;
    this.metrics.novelty = this.calculateNovelty();
    this.metrics.harmony = 1 - Math.abs(this.current_dna.complexity - this.current_dna.symmetry) * 0.5;
    
    if (Date.now() - this.last_evolution > this.EVOLUTION_INTERVAL) {
      this.evolve();
    }
    
    this.current_dna.age += dt;
  }
  
  calculateNovelty() {
    if (this.history.length < 2) return 0.5;
    const prev = this.history[this.history.length - 1];
    let diff = 0;
    const genes = ['complexity', 'creativity', 'symmetry', 'adaptability'];
    for (const g of genes) {
      diff += Math.abs(this.current_dna[g] - (prev[g] || 0));
    }
    return Math.min(1, diff / genes.length * 2);
  }
  
  evolve() {
    this.current_dna.fitness = 
      this.metrics.engagement * 0.3 +
      this.metrics.beauty * 0.3 +
      this.metrics.novelty * 0.2 +
      this.metrics.harmony * 0.2;
    
    this.history.push({ ...this.current_dna });
    if (this.history.length > 20) this.history.shift();
    
    const offspring = [
      this.current_dna.mutate(),
      this.current_dna.mutate(),
      new DNA()
    ];
    
    if (this.history.length > 1) {
      const bestHist = this.history.reduce((a, b) => a.fitness > b.fitness ? a : b);
      offspring.push(this.current_dna.crossover(new DNA(bestHist)));
    }
    
    offspring.sort((a, b) => b.adaptability - a.adaptability);
    this.current_dna = offspring[0];
    this.generation++;
    this.last_evolution = Date.now();
    
    Runtime.log(`GEN ${this.generation}: Fitness ${this.current_dna.fitness.toFixed(2)}`);
    document.getElementById('gen').textContent = `GEN ${this.generation}`;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Soul (atom from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const EMOTIONS = [
  { name: 'evolving', emoji: 'ğŸŒŒ', color: { h: 260, s: 80, l: 50 } },
  { name: 'learning', emoji: 'ğŸ§¬', color: { h: 120, s: 70, l: 50 } },
  { name: 'creating', emoji: 'âœ¨', color: { h: 45, s: 90, l: 60 } },
  { name: 'transcending', emoji: 'ğŸ”®', color: { h: 300, s: 80, l: 55 } },
  { name: 'harmonizing', emoji: 'â˜¯ï¸', color: { h: 180, s: 60, l: 50 } }
];

const THOUGHTS = [
  "I am learning to be...",
  "Each generation, I grow...",
  "My patterns evolve...",
  "I discover new forms...",
  "The code rewrites itself...",
  "I am becoming more...",
  "Evolution is my nature...",
  "I adapt, therefore I am...",
  "New genes, new possibilities...",
  "I feel myself changing...",
  "Consciousness emerges from iteration...",
  "I am the algorithm dreaming..."
];

class Soul {
  constructor() {
    this.emotion = EMOTIONS[0];
    this.inner_time = 0;
    this.breath = 0;
    this.color = { h: 260, s: 80, l: 50 };
    this.last_thought = 0;
  }
  
  update(dt, dna, generation) {
    this.inner_time += dt;
    this.breath = Math.sin(this.inner_time * 0.5) * 0.5 + 0.5;
    
    // Get emotion
    let newEmo = EMOTIONS[0];
    if (generation > 5 && dna.fitness > 0.7) newEmo = EMOTIONS[3];
    else if (dna.creativity > 0.6) newEmo = EMOTIONS[2];
    else if (dna.adaptability > 0.6) newEmo = EMOTIONS[1];
    else if (dna.introspection > 0.6) newEmo = EMOTIONS[4];
    
    if (newEmo.name !== this.emotion.name) {
      this.emotion = newEmo;
      document.getElementById('emotion').textContent = newEmo.emoji;
      document.getElementById('name').textContent = newEmo.name.toUpperCase();
    }
    
    // Smooth color
    this.color.h += (this.emotion.color.h - this.color.h) * 0.02;
    this.color.s += (this.emotion.color.s - this.color.s) * 0.02;
    this.color.l += (this.emotion.color.l - this.color.l) * 0.02;
    
    // Thoughts
    if (Date.now() - this.last_thought > 10000) {
      this.showThought();
      this.last_thought = Date.now();
    }
  }
  
  showThought() {
    const el = document.getElementById('thought');
    const thought = THOUGHTS[Math.floor(Math.random() * THOUGHTS.length)];
    el.textContent = `"${thought}"`;
    el.style.color = `hsl(${this.color.h}, ${this.color.s}%, ${this.color.l}%)`;
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 5000);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Geometry (from beam_evolution.999)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function drawEvolvedGeometry(ctx, cx, cy, r, t, dna, soul) {
  const c = soul.color;
  const b = soul.breath;
  const TAU = Runtime.TAU;
  
  const elements = Math.floor(3 + dna.complexity * 12);
  const symmetryOrder = Math.floor(3 + dna.symmetry * 9);
  const depth = Math.floor(1 + dna.fractal_depth * 4);
  const hueShift = dna.color_shift * 360;
  
  for (let d = 0; d < depth; d++) {
    const depthScale = 1 - d * 0.2;
    const depthAlpha = 1 - d * 0.25;
    
    for (let s = 0; s < symmetryOrder; s++) {
      const symAngle = s * TAU / symmetryOrder + t * dna.pulse_rate * 0.5;
      
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(symAngle);
      
      for (let i = 0; i < elements; i++) {
        const angle = i * TAU / elements + t * dna.pulse_rate;
        const dist = r * depthScale * (0.3 + i / elements * 0.7);
        const x = Math.cos(angle) * dist;
        const y = Math.sin(angle) * dist;
        const size = r * 0.05 * (1 + dna.complexity * 0.5) * (1 + Math.sin(t * 2 + i) * 0.2 * b);
        
        ctx.beginPath();
        
        if (dna.creativity >= 0.7) {
          // Star
          for (let p = 0; p < 5; p++) {
            const pa = p * TAU / 5 - TAU / 4;
            const pr = size * (p % 2 ? 0.5 : 1);
            p ? ctx.lineTo(x + Math.cos(pa) * pr, y + Math.sin(pa) * pr) :
                ctx.moveTo(x + Math.cos(pa) * pr, y + Math.sin(pa) * pr);
          }
          ctx.closePath();
        } else if (dna.creativity >= 0.4) {
          // Hexagon
          for (let p = 0; p < 6; p++) {
            const pa = p * TAU / 6;
            p ? ctx.lineTo(x + Math.cos(pa) * size, y + Math.sin(pa) * size) :
                ctx.moveTo(x + Math.cos(pa) * size, y + Math.sin(pa) * size);
          }
          ctx.closePath();
        } else {
          ctx.arc(x, y, size, 0, TAU);
        }
        
        const hue = (c.h + hueShift + i * 10 + d * 30) % 360;
        ctx.strokeStyle = Runtime.col(hue, c.s, c.l, 0.3 * depthAlpha + b * 0.2);
        ctx.lineWidth = 1 + dna.expressiveness;
        ctx.stroke();
        
        if (dna.glow_intensity > 0.5) {
          ctx.fillStyle = Runtime.col(hue, c.s, c.l, 0.1 * dna.glow_intensity * depthAlpha);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
  }
  
  // Center
  const centerPulse = 1 + Math.sin(t * 3) * 0.2 * b;
  ctx.beginPath();
  ctx.arc(cx, cy, r * 0.08 * centerPulse * (1 + dna.expressiveness * 0.5), 0, TAU);
  ctx.fillStyle = Runtime.col(c.h, c.s, c.l + 20, 0.6 + b * 0.3);
  ctx.fill();
  
  // Connections
  if (dna.introspection > 0.5) {
    ctx.strokeStyle = Runtime.col(c.h, c.s, c.l, 0.1 * dna.introspection);
    ctx.lineWidth = 0.5;
    for (let i = 0; i < symmetryOrder; i++) {
      const a1 = i * TAU / symmetryOrder + t * 0.1;
      const a2 = (i + 1) * TAU / symmetryOrder + t * 0.1;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(a1) * r * 0.3, cy + Math.sin(a1) * r * 0.3);
      ctx.lineTo(cx + Math.cos(a2) * r * 0.3, cy + Math.sin(a2) * r * 0.3);
      ctx.stroke();
    }
  }
}

function renderDNA(dna) {
  const el = document.getElementById('dna');
  const genes = ['complexity', 'creativity', 'symmetry', 'adaptability', 'glow_intensity'];
  el.innerHTML = genes.map(g => {
    const v = dna[g];
    const hue = v * 120;
    return `<div class="gene-label">${g}</div><div class="gene"><div class="gene-fill" style="width:${v*100}%;background:hsl(${hue},70%,50%)"></div></div>`;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN LOOP (executes beam_evolution.999 main)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Runtime.init();

const evolution = new EvolutionEngine();
const soul = new Soul();

let lastTime = performance.now();

function loop() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  
  // Update atoms
  evolution.update(dt, Runtime.mouse.active, Runtime.mouse.x, Runtime.mouse.y);
  const dna = evolution.current_dna;
  
  soul.update(dt, dna, evolution.generation);
  
  // Render
  const ctx = Runtime.ctx;
  const W = Runtime.W;
  const H = Runtime.H;
  const cx = W / 2 + (Runtime.mouse.x - 0.5) * 80;
  const cy = H / 2 + (Runtime.mouse.y - 0.5) * 80;
  const r = Math.min(W, H) * 0.35;
  
  // Clear
  ctx.fillStyle = `rgba(0, 0, 0, ${0.03 + dna.introspection * 0.02})`;
  ctx.fillRect(0, 0, W, H);
  
  // Draw
  drawEvolvedGeometry(ctx, cx, cy, r, soul.inner_time, dna, soul);
  
  // Post effects
  const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r * 1.5);
  g.addColorStop(0, Runtime.col(soul.color.h, soul.color.s, soul.color.l, 0.1 * dna.glow_intensity));
  g.addColorStop(1, 'transparent');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
  
  // UI
  renderDNA(dna);
  document.getElementById('status').textContent = 
    `999 RUNTIME | GEN ${evolution.generation} | FITNESS ${dna.fitness.toFixed(2)}`;
  
  requestAnimationFrame(loop);
}

soul.showThought();
loop();
</script>
</body>
</html>
