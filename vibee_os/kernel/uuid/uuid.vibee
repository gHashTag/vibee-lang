# ============================================================================
# UUID - Генерация идентификаторов на Vibee
# ============================================================================
# UUID v1, v4, v5, v7, ULID, nanoid, snowflake
# ============================================================================

Specification UUID:
  """UUID как спецификация уникальных идентификаторов."""

  # ==========================================================================
  # UUID TYPE
  # ==========================================================================

  Type UUID:
    bytes: Bytes  # 16 bytes

    Static Method nil() -> UUID:
      return UUID(Bytes.filled(16, 0))

    Static Method max() -> UUID:
      return UUID(Bytes.filled(16, 0xFF))

    # UUID v1 - Time-based
    Static Method v1() -> UUID:
      timestamp = get_uuid_timestamp()  # 100-nanosecond intervals since Oct 15, 1582
      clock_seq = random.int(0, 0x3FFF)
      node = get_mac_address() ?? random.bytes(6)
      
      bytes = Bytes(16)
      
      # time_low (4 bytes)
      bytes[0] = (timestamp >> 24) & 0xFF
      bytes[1] = (timestamp >> 16) & 0xFF
      bytes[2] = (timestamp >> 8) & 0xFF
      bytes[3] = timestamp & 0xFF
      
      # time_mid (2 bytes)
      bytes[4] = (timestamp >> 40) & 0xFF
      bytes[5] = (timestamp >> 32) & 0xFF
      
      # time_hi_and_version (2 bytes)
      bytes[6] = ((timestamp >> 56) & 0x0F) | 0x10  # version 1
      bytes[7] = (timestamp >> 48) & 0xFF
      
      # clock_seq_hi_and_reserved
      bytes[8] = ((clock_seq >> 8) & 0x3F) | 0x80  # variant
      bytes[9] = clock_seq & 0xFF
      
      # node (6 bytes)
      for i in 0..6:
        bytes[10 + i] = node[i]
      
      return UUID(bytes)

    # UUID v4 - Random
    Static Method v4() -> UUID:
      bytes = random.bytes(16)
      
      # Set version (4)
      bytes[6] = (bytes[6] & 0x0F) | 0x40
      
      # Set variant (RFC 4122)
      bytes[8] = (bytes[8] & 0x3F) | 0x80
      
      return UUID(bytes)

    # UUID v5 - Name-based (SHA-1)
    Static Method v5(namespace: UUID, name: String) -> UUID:
      data = namespace.bytes + name.to_bytes()
      hash = sha1(data)
      
      bytes = hash.slice(0, 16)
      
      # Set version (5)
      bytes[6] = (bytes[6] & 0x0F) | 0x50
      
      # Set variant
      bytes[8] = (bytes[8] & 0x3F) | 0x80
      
      return UUID(bytes)

    # UUID v3 - Name-based (MD5)
    Static Method v3(namespace: UUID, name: String) -> UUID:
      data = namespace.bytes + name.to_bytes()
      hash = md5(data)
      
      bytes = hash.slice(0, 16)
      
      # Set version (3)
      bytes[6] = (bytes[6] & 0x0F) | 0x30
      
      # Set variant
      bytes[8] = (bytes[8] & 0x3F) | 0x80
      
      return UUID(bytes)

    # UUID v7 - Unix Epoch time-based (sortable)
    Static Method v7() -> UUID:
      timestamp = Instant.now().to_unix_millis()
      
      bytes = Bytes(16)
      
      # timestamp (48 bits)
      bytes[0] = (timestamp >> 40) & 0xFF
      bytes[1] = (timestamp >> 32) & 0xFF
      bytes[2] = (timestamp >> 24) & 0xFF
      bytes[3] = (timestamp >> 16) & 0xFF
      bytes[4] = (timestamp >> 8) & 0xFF
      bytes[5] = timestamp & 0xFF
      
      # random (74 bits)
      rand = random.bytes(10)
      
      # version (4 bits) + random (12 bits)
      bytes[6] = 0x70 | (rand[0] & 0x0F)
      bytes[7] = rand[1]
      
      # variant (2 bits) + random (62 bits)
      bytes[8] = 0x80 | (rand[2] & 0x3F)
      for i in 3..10:
        bytes[6 + i] = rand[i]
      
      return UUID(bytes)

    # Parsing
    Static Method parse(input: String) -> Result<UUID, ParseError>:
      # Remove hyphens and validate
      clean = input.replace("-", "").lowercase()
      
      if clean.length != 32:
        return Err(ParseError("Invalid UUID length"))
      
      if not clean.all(c -> c.is_hex_digit()):
        return Err(ParseError("Invalid UUID characters"))
      
      bytes = Bytes(16)
      for i in 0..16:
        bytes[i] = parse_hex(clean.slice(i * 2, i * 2 + 2))
      
      return Ok(UUID(bytes))

    # Properties
    Method version() -> Int:
      return (bytes[6] >> 4) & 0x0F

    Method variant() -> UUIDVariant:
      b = bytes[8]
      if (b & 0x80) == 0:
        return NCS
      if (b & 0xC0) == 0x80:
        return RFC4122
      if (b & 0xE0) == 0xC0:
        return Microsoft
      return Future

    Method is_nil() -> Boolean:
      return bytes.all(b -> b == 0)

    Method timestamp() -> Option<DateTime>:
      if version() == 1:
        # Extract timestamp from v1
        time_low = (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3]
        time_mid = (bytes[4] << 8) | bytes[5]
        time_hi = ((bytes[6] & 0x0F) << 8) | bytes[7]
        timestamp = (time_hi << 48) | (time_mid << 32) | time_low
        # Convert from 100-ns intervals since 1582 to unix timestamp
        unix_ns = (timestamp - 0x01B21DD213814000) * 100
        return Some(DateTime.from_unix_nanos(unix_ns))
      
      if version() == 7:
        # Extract timestamp from v7
        timestamp = (bytes[0] << 40) | (bytes[1] << 32) | (bytes[2] << 24) |
                    (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]
        return Some(DateTime.from_unix_millis(timestamp))
      
      return None

    # Formatting
    Method to_string() -> String:
      hex = bytes.map(b -> b.to_hex().pad_start(2, '0')).join("")
      return "${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20, 32)}"

    Method to_urn() -> String:
      return "urn:uuid:${to_string()}"

    Method to_bytes() -> Bytes:
      return bytes.clone()

    Method to_base64() -> String:
      return base64.encode(bytes)

    # Comparison
    Operator ==(other: UUID) -> Boolean:
      return bytes == other.bytes

    Operator <(other: UUID) -> Boolean:
      for i in 0..16:
        if bytes[i] < other.bytes[i]:
          return true
        if bytes[i] > other.bytes[i]:
          return false
      return false

    Method hash() -> Int:
      return bytes.hash()

  Type UUIDVariant:
    variants: [NCS, RFC4122, Microsoft, Future]

  # Namespace UUIDs
  Const NAMESPACE_DNS = UUID.parse("6ba7b810-9dad-11d1-80b4-00c04fd430c8").unwrap()
  Const NAMESPACE_URL = UUID.parse("6ba7b811-9dad-11d1-80b4-00c04fd430c8").unwrap()
  Const NAMESPACE_OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8").unwrap()
  Const NAMESPACE_X500 = UUID.parse("6ba7b814-9dad-11d1-80b4-00c04fd430c8").unwrap()

  # ==========================================================================
  # ULID
  # ==========================================================================

  Type ULID:
    """Universally Unique Lexicographically Sortable Identifier."""
    bytes: Bytes  # 16 bytes

    Static ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"

    Static Method new() -> ULID:
      timestamp = Instant.now().to_unix_millis()
      
      bytes = Bytes(16)
      
      # Timestamp (48 bits = 6 bytes)
      bytes[0] = (timestamp >> 40) & 0xFF
      bytes[1] = (timestamp >> 32) & 0xFF
      bytes[2] = (timestamp >> 24) & 0xFF
      bytes[3] = (timestamp >> 16) & 0xFF
      bytes[4] = (timestamp >> 8) & 0xFF
      bytes[5] = timestamp & 0xFF
      
      # Randomness (80 bits = 10 bytes)
      rand = random.bytes(10)
      for i in 0..10:
        bytes[6 + i] = rand[i]
      
      return ULID(bytes)

    Static Method from_timestamp(timestamp: Int) -> ULID:
      bytes = Bytes(16)
      
      bytes[0] = (timestamp >> 40) & 0xFF
      bytes[1] = (timestamp >> 32) & 0xFF
      bytes[2] = (timestamp >> 24) & 0xFF
      bytes[3] = (timestamp >> 16) & 0xFF
      bytes[4] = (timestamp >> 8) & 0xFF
      bytes[5] = timestamp & 0xFF
      
      rand = random.bytes(10)
      for i in 0..10:
        bytes[6 + i] = rand[i]
      
      return ULID(bytes)

    Static Method parse(input: String) -> Result<ULID, ParseError>:
      if input.length != 26:
        return Err(ParseError("Invalid ULID length"))
      
      # Decode Crockford Base32
      bytes = decode_crockford_base32(input.uppercase())?
      return Ok(ULID(bytes))

    Method timestamp() -> Int:
      return (bytes[0] << 40) | (bytes[1] << 32) | (bytes[2] << 24) |
             (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]

    Method datetime() -> DateTime:
      return DateTime.from_unix_millis(timestamp())

    Method to_string() -> String:
      return encode_crockford_base32(bytes)

    Method to_uuid() -> UUID:
      uuid_bytes = bytes.clone()
      # Set version 4 and variant
      uuid_bytes[6] = (uuid_bytes[6] & 0x0F) | 0x40
      uuid_bytes[8] = (uuid_bytes[8] & 0x3F) | 0x80
      return UUID(uuid_bytes)

    Operator ==(other: ULID) -> Boolean:
      return bytes == other.bytes

    Operator <(other: ULID) -> Boolean:
      for i in 0..16:
        if bytes[i] < other.bytes[i]:
          return true
        if bytes[i] > other.bytes[i]:
          return false
      return false

  # ==========================================================================
  # NANOID
  # ==========================================================================

  Behavior NanoID:
    Const DEFAULT_ALPHABET = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    Const DEFAULT_SIZE = 21

    When nanoid() -> String:
      Then: nanoid_with_size(DEFAULT_SIZE)

    When nanoid_with_size(size: Int) -> String:
      Then: nanoid_custom(size, DEFAULT_ALPHABET)

    When nanoid_custom(size: Int, alphabet: String) -> String:
      Then:
        mask = (2 << (31 - clz32((alphabet.length - 1) | 1))) - 1
        step = ceil(1.6 * mask * size / alphabet.length)
        
        result = StringBuilder()
        
        while result.length < size:
          bytes = random.bytes(step)
          for byte in bytes:
            index = byte & mask
            if index < alphabet.length:
              result.append(alphabet[index])
              if result.length >= size:
                break
        
        return result.to_string()

  # ==========================================================================
  # SNOWFLAKE ID
  # ==========================================================================

  Type SnowflakeGenerator:
    """Twitter Snowflake-style ID generator."""
    epoch: Int  # Custom epoch in milliseconds
    worker_id: Int  # 5 bits (0-31)
    datacenter_id: Int  # 5 bits (0-31)
    sequence: Int = 0
    last_timestamp: Int = -1

    Static Method new(worker_id: Int, datacenter_id: Int, epoch: Int? = null) -> SnowflakeGenerator:
      return SnowflakeGenerator(
        epoch: epoch ?? 1288834974657,  # Twitter epoch
        worker_id: worker_id & 0x1F,
        datacenter_id: datacenter_id & 0x1F
      )

    Method generate() -> Int:
      timestamp = Instant.now().to_unix_millis()
      
      if timestamp < last_timestamp:
        throw Error("Clock moved backwards")
      
      if timestamp == last_timestamp:
        sequence = (sequence + 1) & 0xFFF  # 12 bits
        if sequence == 0:
          # Wait for next millisecond
          timestamp = wait_next_millis(last_timestamp)
      else:
        sequence = 0
      
      last_timestamp = timestamp
      
      # 64-bit ID structure:
      # 1 bit unused | 41 bits timestamp | 5 bits datacenter | 5 bits worker | 12 bits sequence
      id = ((timestamp - epoch) << 22) |
           (datacenter_id << 17) |
           (worker_id << 12) |
           sequence
      
      return id

    Method wait_next_millis(last: Int) -> Int:
      timestamp = Instant.now().to_unix_millis()
      while timestamp <= last:
        timestamp = Instant.now().to_unix_millis()
      return timestamp

    Static Method parse(id: Int) -> SnowflakeInfo:
      return SnowflakeInfo(
        timestamp: (id >> 22) + 1288834974657,
        datacenter_id: (id >> 17) & 0x1F,
        worker_id: (id >> 12) & 0x1F,
        sequence: id & 0xFFF
      )

  Type SnowflakeInfo:
    timestamp: Int
    datacenter_id: Int
    worker_id: Int
    sequence: Int

    Method datetime() -> DateTime:
      return DateTime.from_unix_millis(timestamp)

  # ==========================================================================
  # CUID
  # ==========================================================================

  Behavior CUID:
    """Collision-resistant Unique Identifier."""
    
    Static counter: Int = 0
    Static fingerprint: String = generate_fingerprint()

    When cuid() -> String:
      Then:
        timestamp = Instant.now().to_unix_millis().to_base36()
        count = (counter++).to_base36().pad_start(4, '0')
        random_block = random_base36(4)
        
        return "c${timestamp}${count}${fingerprint}${random_block}"

    When cuid2(length: Int = 24) -> String:
      Then:
        # CUID2 - improved version
        timestamp = Instant.now().to_unix_millis()
        count = counter++
        random_data = random.bytes(length)
        
        hash_input = "${timestamp}${count}${fingerprint}${random_data.to_hex()}"
        hash = sha256(hash_input)
        
        return hash.to_base36().slice(0, length)

    When generate_fingerprint() -> String:
      Then:
        # Generate machine fingerprint
        pid = process.pid.to_base36().pad_start(2, '0')
        hostname = hash(os.hostname()).to_base36().slice(0, 2)
        return pid + hostname

    When random_base36(length: Int) -> String:
      Then:
        chars = "0123456789abcdefghijklmnopqrstuvwxyz"
        return (0..length).map(_ -> chars[random.int(0, 35)]).join("")

  # ==========================================================================
  # KSUID
  # ==========================================================================

  Type KSUID:
    """K-Sortable Unique Identifier."""
    bytes: Bytes  # 20 bytes (4 timestamp + 16 random)

    Static EPOCH = 1400000000  # May 13, 2014

    Static Method new() -> KSUID:
      timestamp = Instant.now().to_unix() - EPOCH
      
      bytes = Bytes(20)
      
      # Timestamp (4 bytes, big-endian)
      bytes[0] = (timestamp >> 24) & 0xFF
      bytes[1] = (timestamp >> 16) & 0xFF
      bytes[2] = (timestamp >> 8) & 0xFF
      bytes[3] = timestamp & 0xFF
      
      # Random payload (16 bytes)
      rand = random.bytes(16)
      for i in 0..16:
        bytes[4 + i] = rand[i]
      
      return KSUID(bytes)

    Static Method parse(input: String) -> Result<KSUID, ParseError>:
      if input.length != 27:
        return Err(ParseError("Invalid KSUID length"))
      
      bytes = base62_decode(input)
      if bytes.length != 20:
        return Err(ParseError("Invalid KSUID encoding"))
      
      return Ok(KSUID(bytes))

    Method timestamp() -> Int:
      return ((bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3]) + EPOCH

    Method datetime() -> DateTime:
      return DateTime.from_unix(timestamp())

    Method to_string() -> String:
      return base62_encode(bytes).pad_start(27, '0')

    Operator <(other: KSUID) -> Boolean:
      for i in 0..20:
        if bytes[i] < other.bytes[i]:
          return true
        if bytes[i] > other.bytes[i]:
          return false
      return false

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "UUID":
    ```vibee
    # UUID v4 (random)
    id = UUID.v4()
    log.info("UUID v4: ${id}")  # e.g., "550e8400-e29b-41d4-a716-446655440000"

    # UUID v7 (time-sortable)
    id = UUID.v7()
    log.info("UUID v7: ${id}")
    log.info("Timestamp: ${id.timestamp()}")

    # UUID v5 (name-based)
    id = UUID.v5(NAMESPACE_DNS, "example.com")
    log.info("UUID v5: ${id}")  # Always same for same input

    # Parsing
    id = UUID.parse("550e8400-e29b-41d4-a716-446655440000")?
    log.info("Version: ${id.version()}")  # 4

    # ULID (sortable)
    ulid = ULID.new()
    log.info("ULID: ${ulid}")  # e.g., "01ARZ3NDEKTSV4RRFFQ69G5FAV"
    log.info("Timestamp: ${ulid.datetime()}")

    # NanoID (URL-safe)
    id = nanoid()  # 21 chars by default
    log.info("NanoID: ${id}")  # e.g., "V1StGXR8_Z5jdHi6B-myT"

    # Custom NanoID
    id = nanoid_custom(10, "0123456789")  # Numeric only
    log.info("Custom NanoID: ${id}")  # e.g., "4829371056"

    # Snowflake ID
    generator = SnowflakeGenerator.new(worker_id: 1, datacenter_id: 1)
    id = generator.generate()
    log.info("Snowflake: ${id}")  # e.g., 1234567890123456789

    info = SnowflakeGenerator.parse(id)
    log.info("Generated at: ${info.datetime()}")

    # CUID
    id = cuid()
    log.info("CUID: ${id}")  # e.g., "cjld2cjxh0000qzrmn831i7rn"

    # CUID2 (improved)
    id = cuid2()
    log.info("CUID2: ${id}")

    # KSUID
    id = KSUID.new()
    log.info("KSUID: ${id}")  # e.g., "0ujsswThIGTUYm2K8FjOOfXtY1K"
    log.info("Created: ${id.datetime()}")

    # Sorting ULIDs/UUIDs v7
    ids = (0..10).map(_ -> ULID.new())
    sorted_ids = ids.sort()  # Already sorted by creation time!

    # Use as database primary key
    @model(table: "users")
    class User:
      @field(UUID, primary_key: true, default: UUID.v7)
      id: UUID

      @field(String)
      name: String

    # Or with ULID
    @model(table: "events")
    class Event:
      @field(String, primary_key: true, default: () -> ULID.new().to_string())
      id: String

      @field(String)
      type: String
    ```
