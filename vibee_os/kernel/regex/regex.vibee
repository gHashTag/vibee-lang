# ============================================================================
# REGEX - Регулярные выражения на Vibee
# ============================================================================
# Pattern matching, capture groups, replace
# ============================================================================

Specification Regex:
  """Регулярные выражения как спецификация поиска по шаблону."""

  # ==========================================================================
  # CORE TYPES
  # ==========================================================================

  Type Regex:
    pattern: String
    flags: RegexFlags
    compiled: CompiledRegex

    Static Method new(pattern: String, flags: String = "") -> Result<Regex, RegexError>:
      parsed_flags = parse_flags(flags)
      compiled = compile_regex(pattern, parsed_flags)?
      return Ok(Regex(pattern, parsed_flags, compiled))

    Static Method escape(text: String) -> String:
      special_chars = "\\^$.|?*+()[]{}"
      result = StringBuilder()
      for char in text:
        if char in special_chars:
          result.append('\\')
        result.append(char)
      return result.to_string()

    # Testing
    Method test(input: String) -> Boolean:
      return find(input).is_some()

    Method is_match(input: String) -> Boolean:
      return test(input)

    # Finding
    Method find(input: String) -> Option<Match>:
      return find_at(input, 0)

    Method find_at(input: String, start: Int) -> Option<Match>:
      result = execute(input, start)
      if result.matched:
        return Some(Match(
          text: result.text,
          start: result.start,
          end: result.end,
          groups: result.groups
        ))
      return None

    Method find_all(input: String) -> List<Match>:
      matches = []
      pos = 0
      while pos < input.length:
        match find_at(input, pos):
          Some(m) ->
            matches.push(m)
            pos = max(m.end, pos + 1)
          None ->
            break
      return matches

    Method find_iter(input: String) -> Iterator<Match>:
      pos = 0
      return Iterator(
        next: () -> {
          if pos >= input.length:
            return None
          match find_at(input, pos):
            Some(m) ->
              pos = max(m.end, pos + 1)
              return Some(m)
            None ->
              return None
        }
      )

    # Capturing
    Method captures(input: String) -> Option<Captures>:
      match find(input):
        Some(m) -> Some(Captures(m, named_groups))
        None -> None

    Method captures_all(input: String) -> List<Captures>:
      return find_all(input).map(m -> Captures(m, named_groups))

    # Splitting
    Method split(input: String) -> List<String>:
      return split_n(input, 0)

    Method split_n(input: String, limit: Int) -> List<String>:
      result = []
      last_end = 0
      count = 0
      
      for m in find_iter(input):
        if limit > 0 and count >= limit - 1:
          break
        result.push(input.slice(last_end, m.start))
        last_end = m.end
        count += 1
      
      result.push(input.slice(last_end))
      return result

    # Replacing
    Method replace(input: String, replacement: String) -> String:
      match find(input):
        Some(m) ->
          return input.slice(0, m.start) + expand_replacement(replacement, m) + input.slice(m.end)
        None ->
          return input

    Method replace_all(input: String, replacement: String) -> String:
      result = StringBuilder()
      last_end = 0
      
      for m in find_iter(input):
        result.append(input.slice(last_end, m.start))
        result.append(expand_replacement(replacement, m))
        last_end = m.end
      
      result.append(input.slice(last_end))
      return result.to_string()

    Method replace_fn(input: String, replacer: (Match) -> String) -> String:
      match find(input):
        Some(m) ->
          return input.slice(0, m.start) + replacer(m) + input.slice(m.end)
        None ->
          return input

    Method replace_all_fn(input: String, replacer: (Match) -> String) -> String:
      result = StringBuilder()
      last_end = 0
      
      for m in find_iter(input):
        result.append(input.slice(last_end, m.start))
        result.append(replacer(m))
        last_end = m.end
      
      result.append(input.slice(last_end))
      return result.to_string()

    Method replace_n(input: String, replacement: String, n: Int) -> String:
      result = StringBuilder()
      last_end = 0
      count = 0
      
      for m in find_iter(input):
        if count >= n:
          break
        result.append(input.slice(last_end, m.start))
        result.append(expand_replacement(replacement, m))
        last_end = m.end
        count += 1
      
      result.append(input.slice(last_end))
      return result.to_string()

  Type RegexFlags:
    case_insensitive: Boolean = false
    multiline: Boolean = false
    dot_matches_newline: Boolean = false
    unicode: Boolean = true
    global: Boolean = false

  Type Match:
    text: String
    start: Int
    end: Int
    groups: List<Group?>

    Method group(index: Int) -> Option<String>:
      if index == 0:
        return Some(text)
      if index > 0 and index <= groups.length:
        return groups[index - 1]?.text
      return None

    Method length() -> Int:
      return end - start

    Method range() -> (Int, Int):
      return (start, end)

  Type Group:
    text: String
    start: Int
    end: Int
    name: String?

  Type Captures:
    match: Match
    named_groups: Map<String, Int>

    Method get(index: Int) -> Option<String>:
      return match.group(index)

    Method get_named(name: String) -> Option<String>:
      if name in named_groups:
        return match.group(named_groups[name])
      return None

    Method len() -> Int:
      return match.groups.length + 1

    Operator [](index: Int) -> Option<String>:
      return get(index)

    Operator [](name: String) -> Option<String>:
      return get_named(name)

  Type RegexError:
    message: String
    position: Int?
    pattern: String

  # ==========================================================================
  # REGEX BUILDER
  # ==========================================================================

  Behavior RegexBuilder:
    When regex.builder() -> RegexBuilder:
      Then: RegexBuilder()

    Type RegexBuilder:
      parts: List<String> = []
      flags: RegexFlags = RegexFlags()

      # Flags
      Method case_insensitive() -> RegexBuilder:
        flags.case_insensitive = true
        return self

      Method multiline() -> RegexBuilder:
        flags.multiline = true
        return self

      Method dot_all() -> RegexBuilder:
        flags.dot_matches_newline = true
        return self

      # Literals
      Method literal(text: String) -> RegexBuilder:
        parts.push(Regex.escape(text))
        return self

      Method raw(pattern: String) -> RegexBuilder:
        parts.push(pattern)
        return self

      # Character classes
      Method digit() -> RegexBuilder:
        parts.push("\\d")
        return self

      Method non_digit() -> RegexBuilder:
        parts.push("\\D")
        return self

      Method word() -> RegexBuilder:
        parts.push("\\w")
        return self

      Method non_word() -> RegexBuilder:
        parts.push("\\W")
        return self

      Method whitespace() -> RegexBuilder:
        parts.push("\\s")
        return self

      Method non_whitespace() -> RegexBuilder:
        parts.push("\\S")
        return self

      Method any() -> RegexBuilder:
        parts.push(".")
        return self

      Method char_class(chars: String) -> RegexBuilder:
        parts.push("[${Regex.escape(chars)}]")
        return self

      Method char_range(from: Char, to: Char) -> RegexBuilder:
        parts.push("[${from}-${to}]")
        return self

      Method negated_class(chars: String) -> RegexBuilder:
        parts.push("[^${Regex.escape(chars)}]")
        return self

      # Anchors
      Method start() -> RegexBuilder:
        parts.push("^")
        return self

      Method end() -> RegexBuilder:
        parts.push("$")
        return self

      Method word_boundary() -> RegexBuilder:
        parts.push("\\b")
        return self

      # Quantifiers
      Method optional() -> RegexBuilder:
        wrap_last("?")
        return self

      Method zero_or_more() -> RegexBuilder:
        wrap_last("*")
        return self

      Method one_or_more() -> RegexBuilder:
        wrap_last("+")
        return self

      Method exactly(n: Int) -> RegexBuilder:
        wrap_last("{${n}}")
        return self

      Method at_least(n: Int) -> RegexBuilder:
        wrap_last("{${n},}")
        return self

      Method between(min: Int, max: Int) -> RegexBuilder:
        wrap_last("{${min},${max}}")
        return self

      Method lazy() -> RegexBuilder:
        parts.push("?")
        return self

      # Groups
      Method group(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(${inner.build_pattern()})")
        return self

      Method named_group(name: String, fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(?<${name}>${inner.build_pattern()})")
        return self

      Method non_capturing(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(?:${inner.build_pattern()})")
        return self

      Method backreference(n: Int) -> RegexBuilder:
        parts.push("\\${n}")
        return self

      Method named_backreference(name: String) -> RegexBuilder:
        parts.push("\\k<${name}>")
        return self

      # Alternation
      Method or(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("|${inner.build_pattern()}")
        return self

      Method either(...patterns: String) -> RegexBuilder:
        parts.push("(?:${patterns.join("|")})")
        return self

      # Lookahead/Lookbehind
      Method lookahead(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(?=${inner.build_pattern()})")
        return self

      Method negative_lookahead(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(?!${inner.build_pattern()})")
        return self

      Method lookbehind(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(?<=${inner.build_pattern()})")
        return self

      Method negative_lookbehind(fn: (RegexBuilder) -> RegexBuilder) -> RegexBuilder:
        inner = RegexBuilder()
        fn(inner)
        parts.push("(?<!${inner.build_pattern()})")
        return self

      # Building
      Method build_pattern() -> String:
        return parts.join("")

      Method build() -> Result<Regex, RegexError>:
        pattern = build_pattern()
        flag_str = build_flags()
        return Regex.new(pattern, flag_str)

      Method build_flags() -> String:
        result = ""
        if flags.case_insensitive:
          result += "i"
        if flags.multiline:
          result += "m"
        if flags.dot_matches_newline:
          result += "s"
        return result

      Method wrap_last(suffix: String):
        if parts.length > 0:
          last = parts.pop()
          if last.length > 1 and not last.starts_with("("):
            parts.push("(?:${last})${suffix}")
          else:
            parts.push("${last}${suffix}")

  # ==========================================================================
  # COMMON PATTERNS
  # ==========================================================================

  Behavior CommonPatterns:
    Static email = Regex.new(
      "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    ).unwrap()

    Static url = Regex.new(
      "^https?://[\\w.-]+(?:\\.[\\w.-]+)+[\\w.,@?^=%&:/~+#-]*$"
    ).unwrap()

    Static ipv4 = Regex.new(
      "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
    ).unwrap()

    Static ipv6 = Regex.new(
      "^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$"
    ).unwrap()

    Static phone = Regex.new(
      "^\\+?[1-9]\\d{1,14}$"
    ).unwrap()

    Static uuid = Regex.new(
      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
    ).unwrap()

    Static hex_color = Regex.new(
      "^#(?:[0-9a-fA-F]{3}){1,2}$"
    ).unwrap()

    Static date_iso = Regex.new(
      "^\\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])$"
    ).unwrap()

    Static time_24h = Regex.new(
      "^(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d)?$"
    ).unwrap()

    Static credit_card = Regex.new(
      "^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13})$"
    ).unwrap()

    Static slug = Regex.new(
      "^[a-z0-9]+(?:-[a-z0-9]+)*$"
    ).unwrap()

    Static username = Regex.new(
      "^[a-zA-Z][a-zA-Z0-9_-]{2,31}$"
    ).unwrap()

    Static password_strong = Regex.new(
      "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$"
    ).unwrap()

  # ==========================================================================
  # STRING EXTENSIONS
  # ==========================================================================

  Extension String:
    Method match_regex(pattern: String) -> Option<Match>:
      regex = Regex.new(pattern)?
      return regex.find(self)

    Method matches(pattern: String) -> Boolean:
      regex = Regex.new(pattern)?
      return regex.test(self)

    Method replace_regex(pattern: String, replacement: String) -> String:
      regex = Regex.new(pattern)?
      return regex.replace_all(self, replacement)

    Method split_regex(pattern: String) -> List<String>:
      regex = Regex.new(pattern)?
      return regex.split(self)

    Method scan(pattern: String) -> List<Match>:
      regex = Regex.new(pattern)?
      return regex.find_all(self)

    Method is_email() -> Boolean:
      return CommonPatterns.email.test(self)

    Method is_url() -> Boolean:
      return CommonPatterns.url.test(self)

    Method is_uuid() -> Boolean:
      return CommonPatterns.uuid.test(self)

    Method is_ipv4() -> Boolean:
      return CommonPatterns.ipv4.test(self)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Regex":
    ```vibee
    # Basic matching
    email_regex = Regex.new("^[\\w.+-]+@[\\w.-]+\\.[a-z]{2,}$", "i")?
    
    if email_regex.test("user@example.com"):
      log.info("Valid email!")

    # Finding matches
    text = "Contact us at support@example.com or sales@example.com"
    email_pattern = Regex.new("[\\w.+-]+@[\\w.-]+\\.[a-z]{2,}", "gi")?
    
    for match in email_pattern.find_all(text):
      log.info("Found email: ${match.text} at position ${match.start}")

    # Capture groups
    date_regex = Regex.new("(\\d{4})-(\\d{2})-(\\d{2})")?
    
    match date_regex.captures("Date: 2024-01-15"):
      Some(caps) ->
        year = caps[1]   # "2024"
        month = caps[2]  # "01"
        day = caps[3]    # "15"
      None ->
        log.error("No match")

    # Named groups
    url_regex = Regex.new("(?<protocol>https?)://(?<host>[\\w.-]+)(?<path>/[\\w/]*)?")? 
    
    match url_regex.captures("https://example.com/api/users"):
      Some(caps) ->
        protocol = caps["protocol"]  # "https"
        host = caps["host"]          # "example.com"
        path = caps["path"]          # "/api/users"

    # Replacing
    text = "Hello World"
    result = Regex.new("World")?.replace(text, "Vibee")  # "Hello Vibee"

    # Replace with backreferences
    text = "John Smith"
    result = Regex.new("(\\w+) (\\w+)")?.replace(text, "$2, $1")  # "Smith, John"

    # Replace with function
    text = "prices: $10, $20, $30"
    result = Regex.new("\\$(\\d+)")?.replace_all_fn(text, (m) -> {
      price = parse_int(m.group(1).unwrap())
      return "$${price * 2}"  # Double all prices
    })

    # Splitting
    text = "one,two;three four"
    parts = Regex.new("[,;\\s]+")?.split(text)  # ["one", "two", "three", "four"]

    # Builder API
    phone_regex = regex.builder()
      .start()
      .literal("+").optional()
      .digit().between(1, 3)
      .literal("-").optional()
      .group(b -> b.digit().exactly(3))
      .literal("-").optional()
      .group(b -> b.digit().between(3, 4))
      .end()
      .build()?

    # Lookahead
    password_regex = regex.builder()
      .start()
      .lookahead(b -> b.any().zero_or_more().digit())  # Must contain digit
      .lookahead(b -> b.any().zero_or_more().char_class("A-Z"))  # Must contain uppercase
      .any().at_least(8)
      .end()
      .build()?

    # Common patterns
    if "user@example.com".is_email():
      log.info("Valid email")

    if "https://example.com".is_url():
      log.info("Valid URL")

    if "550e8400-e29b-41d4-a716-446655440000".is_uuid():
      log.info("Valid UUID")

    # Extract all numbers
    numbers = "Price: $19.99, Qty: 5".scan("\\d+\\.?\\d*")
      .map(m -> parse_float(m.text))
    # [19.99, 5.0]

    # Validate and extract
    log_regex = Regex.new("\\[(?<level>\\w+)\\] (?<time>[\\d:]+) - (?<msg>.*)")?
    
    for line in log_lines:
      match log_regex.captures(line):
        Some(caps) ->
          level = caps["level"]
          time = caps["time"]
          message = caps["msg"]
          process_log_entry(level, time, message)
    ```
