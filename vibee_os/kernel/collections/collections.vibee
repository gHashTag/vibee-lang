# ============================================================================
# COLLECTIONS - Расширенные коллекции на Vibee
# ============================================================================
# List, Map, Set, Queue, Stack, Tree, Graph
# ============================================================================

Specification Collections:
  """Коллекции как спецификация структур данных."""

  # ==========================================================================
  # LIST EXTENSIONS
  # ==========================================================================

  Extension List<T>:
    # Transformations
    Method map<U>(fn: (T) -> U) -> List<U>:
      result = []
      for item in self:
        result.push(fn(item))
      return result

    Method flat_map<U>(fn: (T) -> List<U>) -> List<U>:
      result = []
      for item in self:
        result.extend(fn(item))
      return result

    Method filter(predicate: (T) -> Boolean) -> List<T>:
      result = []
      for item in self:
        if predicate(item):
          result.push(item)
      return result

    Method filter_map<U>(fn: (T) -> Option<U>) -> List<U>:
      result = []
      for item in self:
        match fn(item):
          Some(value) -> result.push(value)
          None -> ()
      return result

    Method reduce<U>(initial: U, fn: (U, T) -> U) -> U:
      acc = initial
      for item in self:
        acc = fn(acc, item)
      return acc

    Method fold<U>(initial: U, fn: (U, T) -> U) -> U:
      return reduce(initial, fn)

    Method scan<U>(initial: U, fn: (U, T) -> U) -> List<U>:
      result = [initial]
      acc = initial
      for item in self:
        acc = fn(acc, item)
        result.push(acc)
      return result

    # Searching
    Method find(predicate: (T) -> Boolean) -> Option<T>:
      for item in self:
        if predicate(item):
          return Some(item)
      return None

    Method find_index(predicate: (T) -> Boolean) -> Option<Int>:
      for (i, item) in enumerate():
        if predicate(item):
          return Some(i)
      return None

    Method find_last(predicate: (T) -> Boolean) -> Option<T>:
      for item in reversed():
        if predicate(item):
          return Some(item)
      return None

    Method index_of(item: T) -> Option<Int>:
      return find_index(x -> x == item)

    Method last_index_of(item: T) -> Option<Int>:
      for i in (length - 1)..0:
        if self[i] == item:
          return Some(i)
      return None

    Method binary_search(item: T) -> Option<Int>:
      low = 0
      high = length - 1
      while low <= high:
        mid = (low + high) / 2
        if self[mid] < item:
          low = mid + 1
        else if self[mid] > item:
          high = mid - 1
        else:
          return Some(mid)
      return None

    # Predicates
    Method any(predicate: (T) -> Boolean) -> Boolean:
      for item in self:
        if predicate(item):
          return true
      return false

    Method all(predicate: (T) -> Boolean) -> Boolean:
      for item in self:
        if not predicate(item):
          return false
      return true

    Method none(predicate: (T) -> Boolean) -> Boolean:
      return not any(predicate)

    Method contains(item: T) -> Boolean:
      return any(x -> x == item)

    # Aggregation
    Method count(predicate: ((T) -> Boolean)? = null) -> Int:
      if predicate == null:
        return length
      return filter(predicate).length

    Method sum() -> T where T: Numeric:
      return reduce(0, (acc, x) -> acc + x)

    Method product() -> T where T: Numeric:
      return reduce(1, (acc, x) -> acc * x)

    Method min() -> Option<T> where T: Ord:
      if is_empty():
        return None
      return Some(reduce(self[0], (acc, x) -> if x < acc then x else acc))

    Method max() -> Option<T> where T: Ord:
      if is_empty():
        return None
      return Some(reduce(self[0], (acc, x) -> if x > acc then x else acc))

    Method min_by<K: Ord>(key_fn: (T) -> K) -> Option<T>:
      if is_empty():
        return None
      return Some(reduce(self[0], (acc, x) -> if key_fn(x) < key_fn(acc) then x else acc))

    Method max_by<K: Ord>(key_fn: (T) -> K) -> Option<T>:
      if is_empty():
        return None
      return Some(reduce(self[0], (acc, x) -> if key_fn(x) > key_fn(acc) then x else acc))

    Method average() -> Float where T: Numeric:
      if is_empty():
        return 0.0
      return sum() / length

    # Slicing
    Method take(n: Int) -> List<T>:
      return slice(0, min(n, length))

    Method take_while(predicate: (T) -> Boolean) -> List<T>:
      result = []
      for item in self:
        if not predicate(item):
          break
        result.push(item)
      return result

    Method skip(n: Int) -> List<T>:
      return slice(min(n, length))

    Method skip_while(predicate: (T) -> Boolean) -> List<T>:
      result = []
      skipping = true
      for item in self:
        if skipping and predicate(item):
          continue
        skipping = false
        result.push(item)
      return result

    Method first() -> Option<T>:
      if is_empty():
        return None
      return Some(self[0])

    Method last() -> Option<T>:
      if is_empty():
        return None
      return Some(self[length - 1])

    Method nth(n: Int) -> Option<T>:
      if n < 0 or n >= length:
        return None
      return Some(self[n])

    # Grouping
    Method group_by<K>(key_fn: (T) -> K) -> Map<K, List<T>>:
      result = Map()
      for item in self:
        key = key_fn(item)
        if key not in result:
          result[key] = []
        result[key].push(item)
      return result

    Method partition(predicate: (T) -> Boolean) -> (List<T>, List<T>):
      left = []
      right = []
      for item in self:
        if predicate(item):
          left.push(item)
        else:
          right.push(item)
      return (left, right)

    Method chunk(size: Int) -> List<List<T>>:
      result = []
      for i in 0..length by size:
        result.push(slice(i, min(i + size, length)))
      return result

    Method window(size: Int) -> List<List<T>>:
      if size > length:
        return []
      result = []
      for i in 0..(length - size + 1):
        result.push(slice(i, i + size))
      return result

    # Sorting
    Method sort() -> List<T> where T: Ord:
      return sorted(self)

    Method sort_by<K: Ord>(key_fn: (T) -> K) -> List<T>:
      return sorted(self, key: key_fn)

    Method sort_desc() -> List<T> where T: Ord:
      return sorted(self, reverse: true)

    # Uniqueness
    Method unique() -> List<T> where T: Eq + Hash:
      seen = Set()
      result = []
      for item in self:
        if item not in seen:
          seen.add(item)
          result.push(item)
      return result

    Method unique_by<K: Eq + Hash>(key_fn: (T) -> K) -> List<T>:
      seen = Set()
      result = []
      for item in self:
        key = key_fn(item)
        if key not in seen:
          seen.add(key)
          result.push(item)
      return result

    Method dedup() -> List<T> where T: Eq:
      if is_empty():
        return []
      result = [self[0]]
      for item in skip(1):
        if item != result.last().unwrap():
          result.push(item)
      return result

    # Combining
    Method zip<U>(other: List<U>) -> List<(T, U)>:
      result = []
      for i in 0..min(length, other.length):
        result.push((self[i], other[i]))
      return result

    Method zip_with<U, V>(other: List<U>, fn: (T, U) -> V) -> List<V>:
      result = []
      for i in 0..min(length, other.length):
        result.push(fn(self[i], other[i]))
      return result

    Method interleave(other: List<T>) -> List<T>:
      result = []
      max_len = max(length, other.length)
      for i in 0..max_len:
        if i < length:
          result.push(self[i])
        if i < other.length:
          result.push(other[i])
      return result

    Method flatten() -> List<T::Item> where T: Iterable:
      result = []
      for item in self:
        result.extend(item)
      return result

    # Misc
    Method enumerate() -> List<(Int, T)>:
      result = []
      for (i, item) in self.iter().enumerate():
        result.push((i, item))
      return result

    Method reversed() -> List<T>:
      result = []
      for i in (length - 1)..0:
        result.push(self[i])
      return result

    Method shuffled() -> List<T>:
      result = clone()
      for i in (length - 1)..0:
        j = random_int(0, i)
        (result[i], result[j]) = (result[j], result[i])
      return result

    Method sample(n: Int) -> List<T>:
      return shuffled().take(n)

    Method repeat(n: Int) -> List<T>:
      result = []
      for _ in 0..n:
        result.extend(self)
      return result

    Method intersperse(separator: T) -> List<T>:
      if length <= 1:
        return clone()
      result = [self[0]]
      for item in skip(1):
        result.push(separator)
        result.push(item)
      return result

    Method join(separator: String) -> String where T: ToString:
      return map(x -> x.to_string()).reduce("", (acc, s) -> 
        if acc == "" then s else acc + separator + s
      )

    Method to_map<K, V>(fn: (T) -> (K, V)) -> Map<K, V>:
      result = Map()
      for item in self:
        (key, value) = fn(item)
        result[key] = value
      return result

    Method to_set() -> Set<T> where T: Eq + Hash:
      return Set.from(self)

  # ==========================================================================
  # MAP EXTENSIONS
  # ==========================================================================

  Extension Map<K, V>:
    Method get_or_default(key: K, default: V) -> V:
      return self[key] ?? default

    Method get_or_insert(key: K, default: V) -> V:
      if key not in self:
        self[key] = default
      return self[key]

    Method get_or_insert_with(key: K, fn: () -> V) -> V:
      if key not in self:
        self[key] = fn()
      return self[key]

    Method map_values<U>(fn: (V) -> U) -> Map<K, U>:
      result = Map()
      for (key, value) in entries():
        result[key] = fn(value)
      return result

    Method map_keys<K2>(fn: (K) -> K2) -> Map<K2, V>:
      result = Map()
      for (key, value) in entries():
        result[fn(key)] = value
      return result

    Method filter_entries(predicate: (K, V) -> Boolean) -> Map<K, V>:
      result = Map()
      for (key, value) in entries():
        if predicate(key, value):
          result[key] = value
      return result

    Method merge(other: Map<K, V>) -> Map<K, V>:
      result = clone()
      for (key, value) in other.entries():
        result[key] = value
      return result

    Method merge_with(other: Map<K, V>, fn: (V, V) -> V) -> Map<K, V>:
      result = clone()
      for (key, value) in other.entries():
        if key in result:
          result[key] = fn(result[key], value)
        else:
          result[key] = value
      return result

    Method invert() -> Map<V, K> where V: Eq + Hash:
      result = Map()
      for (key, value) in entries():
        result[value] = key
      return result

    Method pick(keys: List<K>) -> Map<K, V>:
      result = Map()
      for key in keys:
        if key in self:
          result[key] = self[key]
      return result

    Method omit(keys: List<K>) -> Map<K, V>:
      result = Map()
      key_set = Set.from(keys)
      for (key, value) in entries():
        if key not in key_set:
          result[key] = value
      return result

    Method to_list() -> List<(K, V)>:
      return entries()

  # ==========================================================================
  # SET EXTENSIONS
  # ==========================================================================

  Extension Set<T>:
    Method union(other: Set<T>) -> Set<T>:
      result = clone()
      for item in other:
        result.add(item)
      return result

    Method intersection(other: Set<T>) -> Set<T>:
      result = Set()
      for item in self:
        if item in other:
          result.add(item)
      return result

    Method difference(other: Set<T>) -> Set<T>:
      result = Set()
      for item in self:
        if item not in other:
          result.add(item)
      return result

    Method symmetric_difference(other: Set<T>) -> Set<T>:
      return union(other).difference(intersection(other))

    Method is_subset(other: Set<T>) -> Boolean:
      for item in self:
        if item not in other:
          return false
      return true

    Method is_superset(other: Set<T>) -> Boolean:
      return other.is_subset(self)

    Method is_disjoint(other: Set<T>) -> Boolean:
      return intersection(other).is_empty()

    Method map<U: Eq + Hash>(fn: (T) -> U) -> Set<U>:
      result = Set()
      for item in self:
        result.add(fn(item))
      return result

    Method filter(predicate: (T) -> Boolean) -> Set<T>:
      result = Set()
      for item in self:
        if predicate(item):
          result.add(item)
      return result

    Method to_list() -> List<T>:
      result = []
      for item in self:
        result.push(item)
      return result

  # ==========================================================================
  # QUEUE
  # ==========================================================================

  Type Queue<T>:
    items: List<T>

    Static Method new() -> Queue<T>:
      return Queue([])

    Method enqueue(item: T):
      items.push(item)

    Method dequeue() -> Option<T>:
      if is_empty():
        return None
      return Some(items.shift())

    Method peek() -> Option<T>:
      return items.first()

    Method is_empty() -> Boolean:
      return items.is_empty()

    Method length() -> Int:
      return items.length

    Method clear():
      items.clear()

    Method to_list() -> List<T>:
      return items.clone()

  # ==========================================================================
  # PRIORITY QUEUE
  # ==========================================================================

  Type PriorityQueue<T>:
    heap: List<T>
    compare: (T, T) -> Int

    Static Method new(compare: ((T, T) -> Int)? = null) -> PriorityQueue<T>:
      return PriorityQueue([], compare ?? default_compare)

    Static Method min_heap() -> PriorityQueue<T> where T: Ord:
      return PriorityQueue([], (a, b) -> if a < b then -1 else if a > b then 1 else 0)

    Static Method max_heap() -> PriorityQueue<T> where T: Ord:
      return PriorityQueue([], (a, b) -> if a > b then -1 else if a < b then 1 else 0)

    Method push(item: T):
      heap.push(item)
      sift_up(heap.length - 1)

    Method pop() -> Option<T>:
      if is_empty():
        return None
      result = heap[0]
      last = heap.pop()
      if not is_empty():
        heap[0] = last
        sift_down(0)
      return Some(result)

    Method peek() -> Option<T>:
      return heap.first()

    Method is_empty() -> Boolean:
      return heap.is_empty()

    Method length() -> Int:
      return heap.length

    Method sift_up(index: Int):
      while index > 0:
        parent = (index - 1) / 2
        if compare(heap[index], heap[parent]) >= 0:
          break
        (heap[index], heap[parent]) = (heap[parent], heap[index])
        index = parent

    Method sift_down(index: Int):
      while true:
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        
        if left < heap.length and compare(heap[left], heap[smallest]) < 0:
          smallest = left
        if right < heap.length and compare(heap[right], heap[smallest]) < 0:
          smallest = right
        
        if smallest == index:
          break
        
        (heap[index], heap[smallest]) = (heap[smallest], heap[index])
        index = smallest

  # ==========================================================================
  # STACK
  # ==========================================================================

  Type Stack<T>:
    items: List<T>

    Static Method new() -> Stack<T>:
      return Stack([])

    Method push(item: T):
      items.push(item)

    Method pop() -> Option<T>:
      if is_empty():
        return None
      return Some(items.pop())

    Method peek() -> Option<T>:
      return items.last()

    Method is_empty() -> Boolean:
      return items.is_empty()

    Method length() -> Int:
      return items.length

    Method clear():
      items.clear()

  # ==========================================================================
  # DEQUE (Double-ended Queue)
  # ==========================================================================

  Type Deque<T>:
    items: List<T>

    Static Method new() -> Deque<T>:
      return Deque([])

    Method push_front(item: T):
      items.unshift(item)

    Method push_back(item: T):
      items.push(item)

    Method pop_front() -> Option<T>:
      if is_empty():
        return None
      return Some(items.shift())

    Method pop_back() -> Option<T>:
      if is_empty():
        return None
      return Some(items.pop())

    Method front() -> Option<T>:
      return items.first()

    Method back() -> Option<T>:
      return items.last()

    Method is_empty() -> Boolean:
      return items.is_empty()

    Method length() -> Int:
      return items.length

  # ==========================================================================
  # LINKED LIST
  # ==========================================================================

  Type LinkedList<T>:
    head: Node<T>?
    tail: Node<T>?
    length: Int

    Type Node<T>:
      value: T
      next: Node<T>?
      prev: Node<T>?

    Static Method new() -> LinkedList<T>:
      return LinkedList(null, null, 0)

    Method push_front(value: T):
      node = Node(value, head, null)
      if head:
        head.prev = node
      head = node
      if tail == null:
        tail = node
      length += 1

    Method push_back(value: T):
      node = Node(value, null, tail)
      if tail:
        tail.next = node
      tail = node
      if head == null:
        head = node
      length += 1

    Method pop_front() -> Option<T>:
      if head == null:
        return None
      value = head.value
      head = head.next
      if head:
        head.prev = null
      else:
        tail = null
      length -= 1
      return Some(value)

    Method pop_back() -> Option<T>:
      if tail == null:
        return None
      value = tail.value
      tail = tail.prev
      if tail:
        tail.next = null
      else:
        head = null
      length -= 1
      return Some(value)

    Method iter() -> Iterator<T>:
      current = head
      return Iterator(
        next: () -> {
          if current == null:
            return None
          value = current.value
          current = current.next
          return Some(value)
        }
      )

  # ==========================================================================
  # ORDERED MAP (TreeMap)
  # ==========================================================================

  Type OrderedMap<K: Ord, V>:
    root: TreeNode<K, V>?
    length: Int

    Type TreeNode<K, V>:
      key: K
      value: V
      left: TreeNode<K, V>?
      right: TreeNode<K, V>?
      height: Int

    Static Method new() -> OrderedMap<K, V>:
      return OrderedMap(null, 0)

    Method get(key: K) -> Option<V>:
      node = find_node(root, key)
      return if node then Some(node.value) else None

    Method set(key: K, value: V):
      root = insert_node(root, key, value)

    Method remove(key: K) -> Option<V>:
      (new_root, removed) = remove_node(root, key)
      root = new_root
      return removed

    Method min_key() -> Option<K>:
      if root == null:
        return None
      node = root
      while node.left:
        node = node.left
      return Some(node.key)

    Method max_key() -> Option<K>:
      if root == null:
        return None
      node = root
      while node.right:
        node = node.right
      return Some(node.key)

    Method range(from: K, to: K) -> List<(K, V)>:
      result = []
      range_traverse(root, from, to, result)
      return result

    Method keys() -> List<K>:
      result = []
      inorder_keys(root, result)
      return result

    Method values() -> List<V>:
      result = []
      inorder_values(root, result)
      return result

  # ==========================================================================
  # LRU CACHE
  # ==========================================================================

  Type LRUCache<K, V>:
    capacity: Int
    map: Map<K, CacheNode<K, V>>
    head: CacheNode<K, V>?
    tail: CacheNode<K, V>?

    Type CacheNode<K, V>:
      key: K
      value: V
      prev: CacheNode<K, V>?
      next: CacheNode<K, V>?

    Static Method new(capacity: Int) -> LRUCache<K, V>:
      return LRUCache(capacity, Map(), null, null)

    Method get(key: K) -> Option<V>:
      if key not in map:
        return None
      node = map[key]
      move_to_front(node)
      return Some(node.value)

    Method set(key: K, value: V):
      if key in map:
        node = map[key]
        node.value = value
        move_to_front(node)
      else:
        if map.length >= capacity:
          evict()
        node = CacheNode(key, value, null, head)
        if head:
          head.prev = node
        head = node
        if tail == null:
          tail = node
        map[key] = node

    Method remove(key: K) -> Option<V>:
      if key not in map:
        return None
      node = map[key]
      remove_node(node)
      map.delete(key)
      return Some(node.value)

    Method evict():
      if tail == null:
        return
      map.delete(tail.key)
      remove_node(tail)

    Method move_to_front(node: CacheNode<K, V>):
      if node == head:
        return
      remove_node(node)
      node.prev = null
      node.next = head
      if head:
        head.prev = node
      head = node

    Method remove_node(node: CacheNode<K, V>):
      if node.prev:
        node.prev.next = node.next
      else:
        head = node.next
      if node.next:
        node.next.prev = node.prev
      else:
        tail = node.prev

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Collections":
    ```vibee
    # List operations
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

    evens = numbers.filter(n -> n % 2 == 0)  # [2, 4, 6, 8, 10]
    doubled = numbers.map(n -> n * 2)  # [2, 4, 6, 8, ...]
    sum = numbers.sum()  # 55
    avg = numbers.average()  # 5.5

    # Chaining
    result = numbers
      .filter(n -> n > 3)
      .map(n -> n * 2)
      .take(3)
      .sum()  # 24

    # Grouping
    users = [
      { name: "Alice", age: 25 },
      { name: "Bob", age: 30 },
      { name: "Charlie", age: 25 }
    ]

    by_age = users.group_by(u -> u.age)
    # { 25: [Alice, Charlie], 30: [Bob] }

    # Priority Queue
    pq = PriorityQueue.min_heap<Int>()
    pq.push(5)
    pq.push(2)
    pq.push(8)
    pq.push(1)

    while not pq.is_empty():
      log.info(pq.pop())  # 1, 2, 5, 8

    # LRU Cache
    cache = LRUCache<String, User>.new(100)
    cache.set("user:1", user1)
    cache.set("user:2", user2)

    user = cache.get("user:1")  # Moves to front

    # Ordered Map
    scores = OrderedMap<String, Int>.new()
    scores.set("Alice", 100)
    scores.set("Bob", 85)
    scores.set("Charlie", 92)

    for key in scores.keys():  # Sorted: Alice, Bob, Charlie
      log.info("${key}: ${scores.get(key)}")

    # Set operations
    set1 = Set.from([1, 2, 3, 4])
    set2 = Set.from([3, 4, 5, 6])

    union = set1.union(set2)  # {1, 2, 3, 4, 5, 6}
    intersection = set1.intersection(set2)  # {3, 4}
    difference = set1.difference(set2)  # {1, 2}
    ```
