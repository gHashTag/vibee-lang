name: vibee_os_event_bus
version: "0.1.0"
language: gleam
module: kernel/ipc/event_bus
description: Event Bus - центральная событийная шина для всех компонентов Vibee OS

behaviors:
  - name: publish_event
    given: Event is created
    when: publish is called
    then: All subscribers receive the event
    test_cases:
      - name: publish_to_subscribers
        input:
          event: {type: "user.created", data: {id: "123"}}
          subscribers: 3
        expected:
          delivered: 3
          order_preserved: true
      - name: publish_no_subscribers
        input:
          event: {type: "unknown.event"}
          subscribers: 0
        expected:
          delivered: 0
          no_error: true

  - name: subscribe_to_events
    given: Component wants to receive events
    when: subscribe is called with pattern
    then: Component receives matching events
    test_cases:
      - name: subscribe_exact
        input:
          pattern: "user.created"
          event: {type: "user.created"}
        expected:
          received: true
      - name: subscribe_wildcard
        input:
          pattern: "user.*"
          events: ["user.created", "user.updated", "user.deleted"]
        expected:
          received: 3
      - name: subscribe_all
        input:
          pattern: "*"
          events: ["a", "b", "c"]
        expected:
          received: 3

  - name: unsubscribe_from_events
    given: Component is subscribed
    when: unsubscribe is called
    then: Component no longer receives events
    test_cases:
      - name: unsubscribe_success
        input:
          subscription_id: "sub_1"
        expected:
          unsubscribed: true
          no_more_events: true

  - name: event_filtering
    given: Subscriber has filter
    when: Event is published
    then: Only matching events are delivered
    test_cases:
      - name: filter_by_field
        input:
          filter: {field: "priority", value: "high"}
          events:
            - {type: "task", priority: "high"}
            - {type: "task", priority: "low"}
        expected:
          received: 1
          received_priority: "high"

  - name: event_replay
    given: Events are persisted
    when: replay is requested
    then: Historical events are replayed
    test_cases:
      - name: replay_from_timestamp
        input:
          from_timestamp: 1000
          to_timestamp: 2000
          total_events: 100
        expected:
          replayed: 100
          order_preserved: true

  - name: dead_letter_queue
    given: Event delivery fails
    when: Max retries exceeded
    then: Event is moved to dead letter queue
    test_cases:
      - name: move_to_dlq
        input:
          event: {type: "failed.event"}
          delivery_attempts: 3
          max_retries: 3
        expected:
          in_dlq: true
          can_retry_manually: true

types:
  # Event
  Event:
    id: str
    type: str
    source: str
    timestamp: int
    data: {str: EventValue}
    metadata: EventMetadata
    correlation_id: str?
    causation_id: str?

  EventValue:
    variants:
      - Null
      - Bool: {value: bool}
      - Int: {value: int}
      - Float: {value: float}
      - String: {value: str}
      - List: {values: [EventValue]}
      - Map: {entries: {str: EventValue}}

  EventMetadata:
    version: int
    content_type: str
    encoding: str?
    ttl_ms: int?
    priority: Priority
    tags: [str]

  Priority:
    variants:
      - Low
      - Normal
      - High
      - Critical

  # Subscription
  Subscription:
    id: str
    pattern: str
    handler: str
    filter: EventFilter?
    options: SubscriptionOptions

  EventFilter:
    conditions: [FilterCondition]
    operator: FilterOperator

  FilterCondition:
    field: str
    operator: CompareOperator
    value: EventValue

  CompareOperator:
    variants:
      - Equals
      - NotEquals
      - Contains
      - StartsWith
      - GreaterThan
      - LessThan
      - In
      - Exists

  FilterOperator:
    variants:
      - And
      - Or

  SubscriptionOptions:
    queue_group: str?
    max_in_flight: int
    ack_wait_ms: int
    max_retries: int
    retry_delay_ms: int
    dead_letter_queue: str?

  # Delivery
  Delivery:
    event: Event
    subscription_id: str
    attempt: int
    delivered_at: int
    status: DeliveryStatus

  DeliveryStatus:
    variants:
      - Pending
      - Delivered
      - Acknowledged
      - Failed: {error: str}
      - DeadLettered

  # Event Store
  EventStore:
    backend: StoreBackend
    retention_days: int
    max_events: int

  StoreBackend:
    variants:
      - Memory
      - SQLite: {path: str}
      - File: {path: str}

  # Bus Configuration
  EventBusConfig:
    store: EventStore?
    max_subscribers: int
    max_events_per_second: int
    default_ttl_ms: int
    enable_replay: bool
    enable_dlq: bool

  # Statistics
  EventBusStats:
    total_published: int
    total_delivered: int
    total_failed: int
    active_subscriptions: int
    events_per_second: float
    avg_delivery_time_ms: float

  # Replay
  ReplayRequest:
    from_timestamp: int?
    to_timestamp: int?
    event_types: [str]?
    limit: int?

  ReplayResult:
    events: [Event]
    count: int
    has_more: bool

functions:
  # Publishing
  - name: publish
    params: {event: Event}
    returns: bool
    description: Publish event to bus

  - name: publish_batch
    params: {events: [Event]}
    returns: int
    description: Publish multiple events

  - name: publish_delayed
    params: {event: Event, delay_ms: int}
    returns: str
    description: Publish event after delay

  # Subscribing
  - name: subscribe
    params: {pattern: str, handler: str, options: SubscriptionOptions?}
    returns: Subscription
    description: Subscribe to events

  - name: unsubscribe
    params: {subscription_id: str}
    returns: bool
    description: Unsubscribe from events

  - name: unsubscribe_all
    params: {source: str}
    returns: int
    description: Unsubscribe all for source

  # Acknowledgment
  - name: ack
    params: {delivery: Delivery}
    returns: bool
    description: Acknowledge event delivery

  - name: nack
    params: {delivery: Delivery, requeue: bool}
    returns: bool
    description: Negative acknowledge

  # Replay
  - name: replay
    params: {request: ReplayRequest}
    returns: ReplayResult
    description: Replay historical events

  # Dead Letter Queue
  - name: dlq_list
    params: {limit: int}
    returns: [Delivery]
    description: List dead letter queue

  - name: dlq_retry
    params: {delivery_id: str}
    returns: bool
    description: Retry dead lettered event

  - name: dlq_purge
    params: {}
    returns: int
    description: Purge dead letter queue

  # Statistics
  - name: stats
    params: {}
    returns: EventBusStats
    description: Get bus statistics

  # Lifecycle
  - name: bus_init
    params: {config: EventBusConfig}
    returns: bool
    description: Initialize event bus

  - name: bus_shutdown
    params: {}
    returns: bool
    description: Shutdown event bus

imports:
  - kernel.ipc.message

event_types: |
  # Standard Event Types
  
  ## System Events
  - system.started
  - system.shutdown
  - system.error
  - system.health_check
  
  ## Agent Events
  - agent.created
  - agent.started
  - agent.stopped
  - agent.task.started
  - agent.task.completed
  - agent.task.failed
  
  ## LLM Events
  - llm.request.started
  - llm.request.completed
  - llm.request.failed
  - llm.cache.hit
  - llm.cache.miss
  
  ## Spec Events
  - spec.parsed
  - spec.validated
  - spec.compiled
  - spec.test.started
  - spec.test.passed
  - spec.test.failed
  
  ## UI Events
  - ui.click
  - ui.input
  - ui.focus
  - ui.blur
  - ui.gesture

pattern_matching: |
  # Event Pattern Matching
  
  ## Exact Match
  ```
  pattern: "user.created"
  matches: ["user.created"]
  ```
  
  ## Single Wildcard (*)
  ```
  pattern: "user.*"
  matches: ["user.created", "user.updated", "user.deleted"]
  not matches: ["user.profile.updated"]
  ```
  
  ## Multi-level Wildcard (>)
  ```
  pattern: "user.>"
  matches: ["user.created", "user.profile.updated", "user.settings.theme.changed"]
  ```
  
  ## All Events
  ```
  pattern: "*" or ">"
  matches: everything
  ```

usage_example: |
  # Usage Example
  
  ```vibee
  behavior on_user_created
    given: Subscribed to user.created
    when: user.created event received
    then:
      send_welcome_email(event.data.email)
      create_default_settings(event.data.id)
      publish({type: "user.onboarded", data: {id: event.data.id}})
  
  behavior subscribe_on_start
    given: System is starting
    when: init is called
    then:
      subscribe("user.created", "on_user_created")
      subscribe("user.*", "log_user_events")
      subscribe("error.>", "alert_on_error", {priority: Critical})
  ```
