name: vibee_os_behavior_verifier
version: "0.1.0"
language: zig
module: kernel/vibee/verifier
description: Behavior Verifier - runtime verification of Given/When/Then behaviors (BDD Completeness Theorem)

behaviors:
  - name: verify_behavior_at_runtime
    given: A behavior specification and generated code exist
    when: verify_behavior is called during execution
    then: Behavior is verified against specification
    test_cases:
      - name: verify_passing_behavior
        input: {behavior: "greet", input: {name: "Alice"}, actual: {message: "Hello, Alice!"}}
        expected: {verified: true, matches_spec: true}
      - name: verify_failing_behavior
        input: {behavior: "greet", input: {name: "Alice"}, actual: {message: "Hi Alice"}}
        expected: {verified: false, mismatch: "expected 'Hello, Alice!' got 'Hi Alice'"}

  - name: continuous_verification
    given: System is running with behaviors
    when: Any behavior is executed
    then: Verification happens automatically in background
    test_cases:
      - name: auto_verify_enabled
        input: {mode: "continuous", behavior_executed: "greet"}
        expected: {verified: true, logged: true}

  - name: verify_bdd_completeness
    given: A specification with behaviors and tests
    when: verify_completeness is called
    then: BDD Completeness Theorem is checked
    test_cases:
      - name: complete_spec
        input: {behaviors: 5, tests_per_behavior: 3, all_pass: true}
        expected: {complete: true, theorem_satisfied: true}
      - name: incomplete_spec
        input: {behaviors: 5, tests_per_behavior: 0}
        expected: {complete: false, reason: "behaviors_without_tests"}

  - name: detect_specification_drift
    given: Code has been running for some time
    when: verify_drift is called
    then: Any drift between spec and actual behavior is detected
    test_cases:
      - name: no_drift
        input: {spec_hash: "abc123", behavior_hash: "abc123"}
        expected: {drift_detected: false}
      - name: drift_detected
        input: {spec_hash: "abc123", behavior_hash: "def456"}
        expected: {drift_detected: true, action: "regenerate"}

types:
  VerificationResult:
    verified: bool
    behavior_name: str
    input: {str: str}
    expected: {str: str}
    actual: {str: str}
    matches: bool
    mismatches: [Mismatch]
    timestamp: int
    duration_ms: int

  Mismatch:
    field: str
    expected: str
    actual: str
    severity: MismatchSeverity

  MismatchSeverity:
    variants:
      - Critical    # Breaks functionality
      - Major       # Significant difference
      - Minor       # Small difference
      - Cosmetic    # Formatting only

  CompletenessResult:
    complete: bool
    theorem_satisfied: bool
    coverage: CoverageReport
    missing: [str]
    recommendations: [str]

  CoverageReport:
    total_behaviors: int
    tested_behaviors: int
    total_tests: int
    passing_tests: int
    coverage_percent: float

  DriftReport:
    drift_detected: bool
    drifted_behaviors: [str]
    spec_version: str
    code_version: str
    action_required: DriftAction

  DriftAction:
    variants:
      - None
      - Regenerate
      - UpdateSpec
      - ManualReview

  VerificationMode:
    variants:
      - Disabled      # No verification
      - OnDemand      # Manual verification
      - Continuous    # Verify every execution
      - Sampling      # Verify random sample

  VerificationConfig:
    mode: VerificationMode
    sample_rate: float?      # For sampling mode
    log_all: bool
    fail_on_mismatch: bool
    alert_on_drift: bool

  BehaviorTrace:
    behavior_name: str
    invocations: int
    last_invocation: int
    verification_results: [VerificationResult]
    average_duration_ms: float

  VerificationLog:
    entries: [VerificationEntry]
    total_verifications: int
    total_passes: int
    total_failures: int

  VerificationEntry:
    timestamp: int
    behavior: str
    result: bool
    details: str?

functions:
  # Core verification
  - name: verify_behavior
    params: {behavior_name: str, input: {str: str}, actual: {str: str}}
    returns: VerificationResult
    description: Verify a single behavior execution

  - name: verify_all_behaviors
    params: {spec: str}
    returns: [VerificationResult]
    description: Verify all behaviors in specification

  # Completeness
  - name: verify_completeness
    params: {spec: str}
    returns: CompletenessResult
    description: Check BDD Completeness Theorem

  - name: verify_coverage
    params: {spec: str}
    returns: CoverageReport
    description: Calculate test coverage

  # Drift detection
  - name: verify_drift
    params: {spec: str, code: str}
    returns: DriftReport
    description: Detect specification drift

  - name: compute_spec_hash
    params: {spec: str}
    returns: str
    description: Compute hash of specification

  - name: compute_behavior_hash
    params: {behavior_name: str}
    returns: str
    description: Compute hash of behavior implementation

  # Configuration
  - name: verifier_configure
    params: {config: VerificationConfig}
    returns: bool
    description: Configure verification mode

  - name: verifier_enable
    params: {}
    returns: void
    description: Enable continuous verification

  - name: verifier_disable
    params: {}
    returns: void
    description: Disable verification

  # Logging and tracing
  - name: verifier_log
    params: {}
    returns: VerificationLog
    description: Get verification log

  - name: verifier_trace
    params: {behavior_name: str}
    returns: BehaviorTrace
    description: Get trace for specific behavior

  - name: verifier_clear_log
    params: {}
    returns: void
    description: Clear verification log

  # Hooks
  - name: verifier_before_hook
    params: {behavior_name: str, callback: str}
    returns: void
    description: Register before-execution hook

  - name: verifier_after_hook
    params: {behavior_name: str, callback: str}
    returns: void
    description: Register after-execution hook

imports:
  - kernel.vibee.compiler
  - kernel.agent.core

bdd_completeness_theorem: |
  BDD Completeness Theorem (from Vibee Formal Specification):
  
  Spec(C) ⊢ ∀s. ⟦C(s)⟧ = ⟦s⟧
  
  In words: If all behaviors in Spec(C) pass, then compiler C
  preserves semantics for all inputs.
  
  Verification Process:
  
  1. PARSE: Load specification
     Spec = parse("module.vibee")
  
  2. EXTRACT: Get all behaviors
     Behaviors = Spec.behaviors
  
  3. FOR EACH behavior B:
     a. Get test cases: Tests = B.test_cases
     b. FOR EACH test T:
        - Execute: actual = execute(B, T.input)
        - Compare: assert(actual == T.expected)
     c. IF any test fails: THEOREM VIOLATED
  
  4. IF all tests pass: THEOREM SATISFIED
     → Code is correct by construction
  
  Runtime Verification:
  
  In VIBEE OS, we verify behaviors at runtime:
  
  ┌─────────────────────────────────────────────────────────┐
  │                    Behavior Execution                   │
  │                                                         │
  │  Input ──► [Given] ──► [When] ──► [Then] ──► Output    │
  │              │           │          │                   │
  │              ▼           ▼          ▼                   │
  │           Verify      Verify     Verify                 │
  │         Precond.     Action    Postcond.                │
  │              │           │          │                   │
  │              └───────────┼──────────┘                   │
  │                          ▼                              │
  │                   Verification                          │
  │                      Result                             │
  └─────────────────────────────────────────────────────────┘
  
  Benefits:
  - Catch regressions immediately
  - Detect specification drift
  - Ensure continuous correctness
  - Build confidence in system
