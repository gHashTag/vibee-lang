# ============================================================================
# DATE/TIME - Работа с датами и временем на Vibee
# ============================================================================
# DateTime, Duration, Timezone, Formatting, Parsing
# ============================================================================

Specification DateTime:
  """Дата и время как спецификация временных операций."""

  # ==========================================================================
  # INSTANT
  # ==========================================================================

  Type Instant:
    """Момент времени в UTC (наносекунды с Unix epoch)."""
    nanos: Int

    Static Method now() -> Instant:
      return Instant(system_time_nanos())

    Static Method from_unix(seconds: Int) -> Instant:
      return Instant(seconds * 1_000_000_000)

    Static Method from_unix_millis(millis: Int) -> Instant:
      return Instant(millis * 1_000_000)

    Method to_unix() -> Int:
      return nanos / 1_000_000_000

    Method to_unix_millis() -> Int:
      return nanos / 1_000_000

    Method add(duration: Duration) -> Instant:
      return Instant(nanos + duration.nanos)

    Method subtract(duration: Duration) -> Instant:
      return Instant(nanos - duration.nanos)

    Method duration_since(other: Instant) -> Duration:
      return Duration(nanos - other.nanos)

    Method elapsed() -> Duration:
      return Instant.now().duration_since(self)

    Operator +(duration: Duration) -> Instant:
      return add(duration)

    Operator -(other: Instant) -> Duration:
      return duration_since(other)

    Operator <(other: Instant) -> Boolean:
      return nanos < other.nanos

    Operator ==(other: Instant) -> Boolean:
      return nanos == other.nanos

  # ==========================================================================
  # DURATION
  # ==========================================================================

  Type Duration:
    """Промежуток времени."""
    nanos: Int

    Static zero = Duration(0)

    Static Method nanoseconds(n: Int) -> Duration:
      return Duration(n)

    Static Method microseconds(n: Int) -> Duration:
      return Duration(n * 1_000)

    Static Method milliseconds(n: Int) -> Duration:
      return Duration(n * 1_000_000)

    Static Method seconds(n: Int) -> Duration:
      return Duration(n * 1_000_000_000)

    Static Method minutes(n: Int) -> Duration:
      return Duration(n * 60 * 1_000_000_000)

    Static Method hours(n: Int) -> Duration:
      return Duration(n * 3600 * 1_000_000_000)

    Static Method days(n: Int) -> Duration:
      return Duration(n * 86400 * 1_000_000_000)

    Static Method weeks(n: Int) -> Duration:
      return Duration(n * 7 * 86400 * 1_000_000_000)

    Method as_nanos() -> Int:
      return nanos

    Method as_micros() -> Int:
      return nanos / 1_000

    Method as_millis() -> Int:
      return nanos / 1_000_000

    Method as_secs() -> Int:
      return nanos / 1_000_000_000

    Method as_secs_f64() -> Float:
      return nanos / 1_000_000_000.0

    Method as_minutes() -> Int:
      return nanos / (60 * 1_000_000_000)

    Method as_hours() -> Int:
      return nanos / (3600 * 1_000_000_000)

    Method as_days() -> Int:
      return nanos / (86400 * 1_000_000_000)

    Method add(other: Duration) -> Duration:
      return Duration(nanos + other.nanos)

    Method subtract(other: Duration) -> Duration:
      return Duration(nanos - other.nanos)

    Method multiply(factor: Int) -> Duration:
      return Duration(nanos * factor)

    Method divide(divisor: Int) -> Duration:
      return Duration(nanos / divisor)

    Method abs() -> Duration:
      return Duration(abs(nanos))

    Method is_zero() -> Boolean:
      return nanos == 0

    Method is_negative() -> Boolean:
      return nanos < 0

    Operator +(other: Duration) -> Duration:
      return add(other)

    Operator -(other: Duration) -> Duration:
      return subtract(other)

    Operator *(factor: Int) -> Duration:
      return multiply(factor)

    Operator /(divisor: Int) -> Duration:
      return divide(divisor)

    Operator <(other: Duration) -> Boolean:
      return nanos < other.nanos

    Operator ==(other: Duration) -> Boolean:
      return nanos == other.nanos

    Method to_string() -> String:
      if nanos < 1_000:
        return "${nanos}ns"
      if nanos < 1_000_000:
        return "${nanos / 1_000}µs"
      if nanos < 1_000_000_000:
        return "${nanos / 1_000_000}ms"
      if nanos < 60_000_000_000:
        return "${as_secs_f64().format(2)}s"
      if nanos < 3600_000_000_000:
        return "${as_minutes()}m ${(as_secs() % 60)}s"
      return "${as_hours()}h ${(as_minutes() % 60)}m"

  # Extension for Int
  Extension Int:
    Method nanoseconds() -> Duration:
      return Duration.nanoseconds(self)

    Method microseconds() -> Duration:
      return Duration.microseconds(self)

    Method milliseconds() -> Duration:
      return Duration.milliseconds(self)

    Method ms() -> Duration:
      return Duration.milliseconds(self)

    Method seconds() -> Duration:
      return Duration.seconds(self)

    Method second() -> Duration:
      return Duration.seconds(self)

    Method minutes() -> Duration:
      return Duration.minutes(self)

    Method minute() -> Duration:
      return Duration.minutes(self)

    Method hours() -> Duration:
      return Duration.hours(self)

    Method hour() -> Duration:
      return Duration.hours(self)

    Method days() -> Duration:
      return Duration.days(self)

    Method day() -> Duration:
      return Duration.days(self)

    Method weeks() -> Duration:
      return Duration.weeks(self)

    Method week() -> Duration:
      return Duration.weeks(self)

  # ==========================================================================
  # DATETIME
  # ==========================================================================

  Type DateTime:
    """Дата и время с часовым поясом."""
    instant: Instant
    timezone: Timezone

    Static Method now() -> DateTime:
      return DateTime(Instant.now(), Timezone.local())

    Static Method now_utc() -> DateTime:
      return DateTime(Instant.now(), Timezone.utc())

    Static Method from_parts(
      year: Int,
      month: Int,
      day: Int,
      hour: Int = 0,
      minute: Int = 0,
      second: Int = 0,
      nanosecond: Int = 0,
      timezone: Timezone = Timezone.utc()
    ) -> DateTime:
      instant = calculate_instant(year, month, day, hour, minute, second, nanosecond, timezone)
      return DateTime(instant, timezone)

    Static Method parse(input: String, format: String? = null) -> Result<DateTime, ParseError>:
      if format:
        return parse_with_format(input, format)
      return parse_iso8601(input)

    Static Method from_unix(seconds: Int) -> DateTime:
      return DateTime(Instant.from_unix(seconds), Timezone.utc())

    Static Method from_unix_millis(millis: Int) -> DateTime:
      return DateTime(Instant.from_unix_millis(millis), Timezone.utc())

    # Components
    Method year() -> Int:
      return extract_year(instant, timezone)

    Method month() -> Int:
      return extract_month(instant, timezone)

    Method day() -> Int:
      return extract_day(instant, timezone)

    Method hour() -> Int:
      return extract_hour(instant, timezone)

    Method minute() -> Int:
      return extract_minute(instant, timezone)

    Method second() -> Int:
      return extract_second(instant, timezone)

    Method nanosecond() -> Int:
      return extract_nanosecond(instant, timezone)

    Method millisecond() -> Int:
      return nanosecond() / 1_000_000

    Method weekday() -> Weekday:
      return calculate_weekday(instant, timezone)

    Method day_of_year() -> Int:
      return calculate_day_of_year(instant, timezone)

    Method week_of_year() -> Int:
      return calculate_week_of_year(instant, timezone)

    Method is_leap_year() -> Boolean:
      y = year()
      return (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)

    # Arithmetic
    Method add(duration: Duration) -> DateTime:
      return DateTime(instant.add(duration), timezone)

    Method subtract(duration: Duration) -> DateTime:
      return DateTime(instant.subtract(duration), timezone)

    Method add_years(years: Int) -> DateTime:
      return DateTime.from_parts(
        year() + years, month(), day(),
        hour(), minute(), second(), nanosecond(),
        timezone
      )

    Method add_months(months: Int) -> DateTime:
      total_months = (year() * 12 + month() - 1) + months
      new_year = total_months / 12
      new_month = (total_months % 12) + 1
      new_day = min(day(), days_in_month(new_year, new_month))
      return DateTime.from_parts(
        new_year, new_month, new_day,
        hour(), minute(), second(), nanosecond(),
        timezone
      )

    Method add_days(days: Int) -> DateTime:
      return add(Duration.days(days))

    Method add_hours(hours: Int) -> DateTime:
      return add(Duration.hours(hours))

    Method add_minutes(minutes: Int) -> DateTime:
      return add(Duration.minutes(minutes))

    Method add_seconds(seconds: Int) -> DateTime:
      return add(Duration.seconds(seconds))

    Method duration_since(other: DateTime) -> Duration:
      return instant.duration_since(other.instant)

    # Comparison
    Method is_before(other: DateTime) -> Boolean:
      return instant < other.instant

    Method is_after(other: DateTime) -> Boolean:
      return instant > other.instant

    Method is_same_day(other: DateTime) -> Boolean:
      return year() == other.year() and month() == other.month() and day() == other.day()

    # Truncation
    Method start_of_day() -> DateTime:
      return DateTime.from_parts(year(), month(), day(), 0, 0, 0, 0, timezone)

    Method end_of_day() -> DateTime:
      return DateTime.from_parts(year(), month(), day(), 23, 59, 59, 999_999_999, timezone)

    Method start_of_month() -> DateTime:
      return DateTime.from_parts(year(), month(), 1, 0, 0, 0, 0, timezone)

    Method end_of_month() -> DateTime:
      return DateTime.from_parts(year(), month(), days_in_month(year(), month()), 23, 59, 59, 999_999_999, timezone)

    Method start_of_year() -> DateTime:
      return DateTime.from_parts(year(), 1, 1, 0, 0, 0, 0, timezone)

    Method end_of_year() -> DateTime:
      return DateTime.from_parts(year(), 12, 31, 23, 59, 59, 999_999_999, timezone)

    Method start_of_week(start_day: Weekday = Monday) -> DateTime:
      days_since_start = (weekday().value - start_day.value + 7) % 7
      return start_of_day().subtract(Duration.days(days_since_start))

    # Timezone
    Method in_timezone(tz: Timezone) -> DateTime:
      return DateTime(instant, tz)

    Method to_utc() -> DateTime:
      return in_timezone(Timezone.utc())

    Method to_local() -> DateTime:
      return in_timezone(Timezone.local())

    # Formatting
    Method format(pattern: String) -> String:
      return format_datetime(self, pattern)

    Method to_iso_string() -> String:
      return format("YYYY-MM-DDTHH:mm:ss.SSSZ")

    Method to_rfc2822() -> String:
      return format("ddd, DD MMM YYYY HH:mm:ss ZZ")

    Method to_rfc3339() -> String:
      return format("YYYY-MM-DDTHH:mm:ssXXX")

    Method to_unix() -> Int:
      return instant.to_unix()

    Method to_unix_millis() -> Int:
      return instant.to_unix_millis()

    Method to_string() -> String:
      return to_iso_string()

    Operator +(duration: Duration) -> DateTime:
      return add(duration)

    Operator -(other: DateTime) -> Duration:
      return duration_since(other)

    Operator <(other: DateTime) -> Boolean:
      return is_before(other)

    Operator ==(other: DateTime) -> Boolean:
      return instant == other.instant

  # ==========================================================================
  # DATE
  # ==========================================================================

  Type Date:
    """Дата без времени."""
    year: Int
    month: Int
    day: Int

    Static Method today() -> Date:
      dt = DateTime.now()
      return Date(dt.year(), dt.month(), dt.day())

    Static Method from_parts(year: Int, month: Int, day: Int) -> Date:
      validate_date(year, month, day)
      return Date(year, month, day)

    Static Method parse(input: String, format: String? = null) -> Result<Date, ParseError>:
      if format:
        return parse_date_with_format(input, format)
      return parse_iso_date(input)

    Method weekday() -> Weekday:
      return calculate_weekday_for_date(year, month, day)

    Method day_of_year() -> Int:
      return calculate_day_of_year_for_date(year, month, day)

    Method is_leap_year() -> Boolean:
      return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

    Method add_days(days: Int) -> Date:
      dt = to_datetime().add_days(days)
      return Date(dt.year(), dt.month(), dt.day())

    Method add_months(months: Int) -> Date:
      dt = to_datetime().add_months(months)
      return Date(dt.year(), dt.month(), dt.day())

    Method add_years(years: Int) -> Date:
      return Date(year + years, month, min(day, days_in_month(year + years, month)))

    Method days_until(other: Date) -> Int:
      return (other.to_datetime().instant.to_unix() - to_datetime().instant.to_unix()) / 86400

    Method to_datetime(time: Time? = null, timezone: Timezone? = null) -> DateTime:
      t = time ?? Time(0, 0, 0, 0)
      tz = timezone ?? Timezone.local()
      return DateTime.from_parts(year, month, day, t.hour, t.minute, t.second, t.nanosecond, tz)

    Method format(pattern: String) -> String:
      return format_date(self, pattern)

    Method to_iso_string() -> String:
      return format("YYYY-MM-DD")

    Method to_string() -> String:
      return to_iso_string()

    Operator ==(other: Date) -> Boolean:
      return year == other.year and month == other.month and day == other.day

    Operator <(other: Date) -> Boolean:
      if year != other.year:
        return year < other.year
      if month != other.month:
        return month < other.month
      return day < other.day

  # ==========================================================================
  # TIME
  # ==========================================================================

  Type Time:
    """Время без даты."""
    hour: Int
    minute: Int
    second: Int
    nanosecond: Int

    Static Method now() -> Time:
      dt = DateTime.now()
      return Time(dt.hour(), dt.minute(), dt.second(), dt.nanosecond())

    Static Method from_parts(hour: Int, minute: Int, second: Int = 0, nanosecond: Int = 0) -> Time:
      validate_time(hour, minute, second, nanosecond)
      return Time(hour, minute, second, nanosecond)

    Static Method parse(input: String, format: String? = null) -> Result<Time, ParseError>:
      if format:
        return parse_time_with_format(input, format)
      return parse_iso_time(input)

    Method millisecond() -> Int:
      return nanosecond / 1_000_000

    Method add(duration: Duration) -> Time:
      total_nanos = to_nanos() + duration.nanos
      total_nanos = total_nanos % (24 * 3600 * 1_000_000_000)
      if total_nanos < 0:
        total_nanos += 24 * 3600 * 1_000_000_000
      return from_nanos(total_nanos)

    Method to_nanos() -> Int:
      return hour * 3600_000_000_000 + minute * 60_000_000_000 + second * 1_000_000_000 + nanosecond

    Static Method from_nanos(nanos: Int) -> Time:
      h = (nanos / 3600_000_000_000) % 24
      m = (nanos / 60_000_000_000) % 60
      s = (nanos / 1_000_000_000) % 60
      ns = nanos % 1_000_000_000
      return Time(h, m, s, ns)

    Method format(pattern: String) -> String:
      return format_time(self, pattern)

    Method to_iso_string() -> String:
      return format("HH:mm:ss.SSS")

    Method to_string() -> String:
      return to_iso_string()

    Operator ==(other: Time) -> Boolean:
      return to_nanos() == other.to_nanos()

    Operator <(other: Time) -> Boolean:
      return to_nanos() < other.to_nanos()

  # ==========================================================================
  # TIMEZONE
  # ==========================================================================

  Type Timezone:
    id: String
    offset_seconds: Int
    name: String

    Static Method utc() -> Timezone:
      return Timezone("UTC", 0, "Coordinated Universal Time")

    Static Method local() -> Timezone:
      return get_local_timezone()

    Static Method from_offset(hours: Int, minutes: Int = 0) -> Timezone:
      offset = hours * 3600 + minutes * 60
      sign = if offset >= 0 then "+" else "-"
      id = "${sign}${abs(hours).pad_start(2, '0')}:${abs(minutes).pad_start(2, '0')}"
      return Timezone(id, offset, id)

    Static Method from_id(id: String) -> Result<Timezone, Error>:
      return lookup_timezone(id)

    Method offset() -> Duration:
      return Duration.seconds(offset_seconds)

    Method format_offset() -> String:
      hours = abs(offset_seconds) / 3600
      minutes = (abs(offset_seconds) % 3600) / 60
      sign = if offset_seconds >= 0 then "+" else "-"
      return "${sign}${hours.pad_start(2, '0')}:${minutes.pad_start(2, '0')}"

  # ==========================================================================
  # WEEKDAY
  # ==========================================================================

  Type Weekday:
    variants:
      - Monday = 1
      - Tuesday = 2
      - Wednesday = 3
      - Thursday = 4
      - Friday = 5
      - Saturday = 6
      - Sunday = 7

    Method value() -> Int:
      match self:
        Monday -> 1
        Tuesday -> 2
        Wednesday -> 3
        Thursday -> 4
        Friday -> 5
        Saturday -> 6
        Sunday -> 7

    Method name() -> String:
      match self:
        Monday -> "Monday"
        Tuesday -> "Tuesday"
        Wednesday -> "Wednesday"
        Thursday -> "Thursday"
        Friday -> "Friday"
        Saturday -> "Saturday"
        Sunday -> "Sunday"

    Method short_name() -> String:
      return name().slice(0, 3)

    Method is_weekend() -> Boolean:
      return self in [Saturday, Sunday]

    Method is_weekday() -> Boolean:
      return not is_weekend()

    Method next() -> Weekday:
      return Weekday.from_value((value() % 7) + 1)

    Method prev() -> Weekday:
      return Weekday.from_value(((value() - 2 + 7) % 7) + 1)

    Static Method from_value(v: Int) -> Weekday:
      match v:
        1 -> Monday
        2 -> Tuesday
        3 -> Wednesday
        4 -> Thursday
        5 -> Friday
        6 -> Saturday
        7 -> Sunday

  # ==========================================================================
  # FORMATTING
  # ==========================================================================

  Behavior Formatting:
    # Format tokens:
    # YYYY - 4-digit year
    # YY   - 2-digit year
    # MM   - 2-digit month
    # M    - month (1-12)
    # DD   - 2-digit day
    # D    - day (1-31)
    # HH   - 2-digit hour (24h)
    # hh   - 2-digit hour (12h)
    # mm   - 2-digit minute
    # ss   - 2-digit second
    # SSS  - 3-digit millisecond
    # A    - AM/PM
    # a    - am/pm
    # ddd  - short weekday
    # dddd - full weekday
    # MMM  - short month name
    # MMMM - full month name
    # Z    - timezone offset (+00:00)
    # ZZ   - timezone offset (+0000)
    # X    - unix timestamp
    # x    - unix timestamp (ms)

    When format_datetime(dt: DateTime, pattern: String) -> String:
      Then:
        - return pattern
            .replace("YYYY", dt.year().to_string().pad_start(4, '0'))
            .replace("YY", (dt.year() % 100).to_string().pad_start(2, '0'))
            .replace("MMMM", month_name(dt.month()))
            .replace("MMM", month_name(dt.month()).slice(0, 3))
            .replace("MM", dt.month().to_string().pad_start(2, '0'))
            .replace("M", dt.month().to_string())
            .replace("DD", dt.day().to_string().pad_start(2, '0'))
            .replace("D", dt.day().to_string())
            .replace("dddd", dt.weekday().name())
            .replace("ddd", dt.weekday().short_name())
            .replace("HH", dt.hour().to_string().pad_start(2, '0'))
            .replace("hh", ((dt.hour() - 1) % 12 + 1).to_string().pad_start(2, '0'))
            .replace("mm", dt.minute().to_string().pad_start(2, '0'))
            .replace("ss", dt.second().to_string().pad_start(2, '0'))
            .replace("SSS", dt.millisecond().to_string().pad_start(3, '0'))
            .replace("A", if dt.hour() < 12 then "AM" else "PM")
            .replace("a", if dt.hour() < 12 then "am" else "pm")
            .replace("Z", dt.timezone.format_offset())
            .replace("X", dt.to_unix().to_string())
            .replace("x", dt.to_unix_millis().to_string())

  # ==========================================================================
  # UTILITIES
  # ==========================================================================

  Behavior Utilities:
    When days_in_month(year: Int, month: Int) -> Int:
      Then:
        - match month:
            1, 3, 5, 7, 8, 10, 12 -> 31
            4, 6, 9, 11 -> 30
            2 -> if is_leap_year(year) then 29 else 28

    When month_name(month: Int) -> String:
      Then:
        - names = ["January", "February", "March", "April", "May", "June",
                   "July", "August", "September", "October", "November", "December"]
        - return names[month - 1]

    When is_leap_year(year: Int) -> Boolean:
      Then:
        - return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "DateTime":
    ```vibee
    # Current time
    now = DateTime.now()
    now_utc = DateTime.now_utc()

    # Create from parts
    birthday = DateTime.from_parts(1990, 5, 15, 10, 30, 0)

    # Parse
    dt = DateTime.parse("2024-01-15T10:30:00Z")?
    dt2 = DateTime.parse("15/01/2024", "DD/MM/YYYY")?

    # Components
    log.info("Year: ${dt.year()}, Month: ${dt.month()}, Day: ${dt.day()}")
    log.info("Weekday: ${dt.weekday().name()}")

    # Arithmetic
    tomorrow = now + 1.day
    next_week = now + 1.week
    in_3_months = now.add_months(3)

    # Duration
    age = now - birthday
    log.info("Age: ${age.as_days()} days")

    # Comparison
    if deadline.is_before(now):
      log.warn("Deadline passed!")

    # Formatting
    formatted = now.format("MMMM D, YYYY at h:mm A")
    # "January 15, 2024 at 10:30 AM"

    iso = now.to_iso_string()
    # "2024-01-15T10:30:00.000Z"

    # Timezone
    tokyo = now.in_timezone(Timezone.from_id("Asia/Tokyo")?)
    la = now.in_timezone(Timezone.from_offset(-8))

    # Date only
    today = Date.today()
    christmas = Date.from_parts(2024, 12, 25)
    days_until_christmas = today.days_until(christmas)

    # Time only
    meeting_time = Time.from_parts(14, 30)
    end_time = meeting_time.add(1.hour + 30.minutes)

    # Duration literals
    timeout = 5.seconds
    interval = 100.milliseconds
    cache_ttl = 1.hour

    # Sleep
    await sleep(500.ms)

    # Measure time
    start = Instant.now()
    do_work()
    elapsed = start.elapsed()
    log.info("Took ${elapsed}")

    # Truncation
    start_of_day = now.start_of_day()
    start_of_month = now.start_of_month()
    start_of_week = now.start_of_week(Monday)

    # Iteration
    current = Date.from_parts(2024, 1, 1)
    end_date = Date.from_parts(2024, 1, 31)
    
    while current <= end_date:
      if current.weekday().is_weekday():
        log.info("Working day: ${current}")
      current = current.add_days(1)
    ```
