# ============================================================================
# NOTIFICATIONS - Уведомления на Vibee
# ============================================================================
# Push, SMS, webhooks, in-app notifications
# ============================================================================

Specification Notifications:
  """Уведомления как спецификация коммуникации."""

  # ==========================================================================
  # TYPES
  # ==========================================================================

  Type Notification:
    id: NotificationId
    type: NotificationType
    channel: Channel
    recipient: Recipient
    content: Content
    priority: Priority
    status: NotificationStatus
    metadata: Map<String, Any>
    scheduled_at: Timestamp?
    sent_at: Timestamp?
    delivered_at: Timestamp?
    read_at: Timestamp?
    created_at: Timestamp

  Type NotificationId:
    value: UUID

  Type NotificationType:
    key: String
    name: String
    template: String?
    channels: List<Channel>
    settings: NotificationSettings

  Type NotificationSettings:
    throttle: ThrottleConfig?
    batch: BatchConfig?
    retry: RetryConfig?

  Type ThrottleConfig:
    max_per_hour: Int?
    max_per_day: Int?
    cooldown: Duration?

  Type BatchConfig:
    enabled: Boolean
    window: Duration
    max_size: Int

  Type RetryConfig:
    max_attempts: Int = 3
    backoff: Duration = 1.minute

  Type Channel:
    variants:
      - Email
      - Push
      - SMS
      - InApp
      - Webhook
      - Slack
      - Discord
      - Telegram

  Type Recipient:
    user_id: String?
    email: String?
    phone: String?
    device_tokens: List<DeviceToken>?
    webhook_url: String?
    slack_channel: String?
    discord_channel: String?
    telegram_chat_id: String?

  Type DeviceToken:
    token: String
    platform: Platform
    app_id: String?

  Type Platform:
    variants: [iOS, Android, Web, MacOS, Windows]

  Type Content:
    title: String?
    body: String
    data: Map<String, Any>?
    image: String?
    action_url: String?
    actions: List<Action>?

  Type Action:
    id: String
    title: String
    url: String?
    type: ActionType

  Type ActionType:
    variants: [Open, Dismiss, Custom]

  Type Priority:
    variants:
      - Critical
      - High
      - Normal
      - Low

  Type NotificationStatus:
    variants:
      - Pending
      - Queued
      - Sending
      - Sent
      - Delivered
      - Read
      - Failed: String
      - Cancelled

  # ==========================================================================
  # PUSH NOTIFICATIONS
  # ==========================================================================

  Type PushConfig:
    apns: APNSConfig?
    fcm: FCMConfig?
    web_push: WebPushConfig?

  Type APNSConfig:
    key_id: String
    team_id: String
    bundle_id: String
    private_key: String
    production: Boolean = false

  Type FCMConfig:
    project_id: String
    private_key: String
    client_email: String

  Type WebPushConfig:
    vapid_public_key: String
    vapid_private_key: String
    vapid_subject: String

  Type PushPayload:
    title: String
    body: String
    icon: String?
    badge: Int?
    sound: String?
    data: Map<String, Any>?
    category: String?
    thread_id: String?
    collapse_key: String?
    ttl: Duration?
    priority: PushPriority?

  Type PushPriority:
    variants: [High, Normal]

  Behavior PushNotifications:
    When push.send(token, payload):
      Then:
        - match token.platform:
            iOS | MacOS -> send_apns(token, payload)
            Android -> send_fcm(token, payload)
            Web -> send_web_push(token, payload)

    When send_apns(token, payload):
      Then:
        - jwt = generate_apns_jwt(config.apns)
        - apns_payload = {
            aps: {
              alert: {
                title: payload.title,
                body: payload.body
              },
              badge: payload.badge,
              sound: payload.sound ?? "default",
              category: payload.category,
              "thread-id": payload.thread_id
            },
            ...payload.data
          }
        
        - endpoint = if config.apns.production 
            then "https://api.push.apple.com"
            else "https://api.sandbox.push.apple.com"
        
        - response = await http.post(
            "${endpoint}/3/device/${token.token}",
            headers: {
              "authorization": "bearer ${jwt}",
              "apns-topic": config.apns.bundle_id,
              "apns-priority": if payload.priority == High then "10" else "5",
              "apns-expiration": (now() + (payload.ttl ?? 1.day)).unix.to_string()
            },
            body: JSON.stringify(apns_payload)
          )
        
        - if response.status != 200:
            - raise PushError(response.body)

    When send_fcm(token, payload):
      Then:
        - access_token = await get_fcm_access_token(config.fcm)
        
        - fcm_payload = {
            message: {
              token: token.token,
              notification: {
                title: payload.title,
                body: payload.body,
                image: payload.icon
              },
              data: payload.data,
              android: {
                priority: if payload.priority == High then "HIGH" else "NORMAL",
                ttl: "${payload.ttl?.seconds ?? 86400}s",
                collapse_key: payload.collapse_key,
                notification: {
                  sound: payload.sound ?? "default",
                  click_action: payload.category
                }
              }
            }
          }
        
        - response = await http.post(
            "https://fcm.googleapis.com/v1/projects/${config.fcm.project_id}/messages:send",
            headers: {
              "Authorization": "Bearer ${access_token}",
              "Content-Type": "application/json"
            },
            body: JSON.stringify(fcm_payload)
          )
        
        - if response.status != 200:
            - raise PushError(response.body)

    When send_web_push(token, payload):
      Then:
        - subscription = JSON.parse(token.token)
        
        - web_payload = JSON.stringify({
            title: payload.title,
            body: payload.body,
            icon: payload.icon,
            badge: payload.badge,
            data: payload.data
          })
        
        - await web_push_send(
            subscription,
            web_payload,
            vapid_details: {
              subject: config.web_push.vapid_subject,
              public_key: config.web_push.vapid_public_key,
              private_key: config.web_push.vapid_private_key
            },
            ttl: payload.ttl?.seconds ?? 86400
          )

  # ==========================================================================
  # SMS
  # ==========================================================================

  Type SMSConfig:
    provider: SMSProvider
    from_number: String

  Type SMSProvider:
    variants:
      - Twilio: TwilioConfig
      - Nexmo: NexmoConfig
      - AWS_SNS: AWSSNSConfig
      - Custom: CustomSMSProvider

  Type TwilioConfig:
    account_sid: String
    auth_token: String

  Type NexmoConfig:
    api_key: String
    api_secret: String

  Type SMSMessage:
    to: String
    body: String
    from: String?

  Behavior SMSNotifications:
    When sms.send(message):
      Then:
        - match config.provider:
            Twilio(c) -> send_twilio(c, message)
            Nexmo(c) -> send_nexmo(c, message)
            AWS_SNS(c) -> send_sns(c, message)
            Custom(p) -> p.send(message)

    When send_twilio(config, message):
      Then:
        - response = await http.post(
            "https://api.twilio.com/2010-04-01/Accounts/${config.account_sid}/Messages.json",
            auth: (config.account_sid, config.auth_token),
            form: {
              To: message.to,
              From: message.from ?? sms_config.from_number,
              Body: message.body
            }
          )
        
        - if response.status != 201:
            - raise SMSError(response.body)
        
        - return response.json().sid

  # ==========================================================================
  # WEBHOOKS
  # ==========================================================================

  Type WebhookConfig:
    url: String
    secret: String?
    headers: Map<String, String>?
    retry: RetryConfig?
    timeout: Duration = 30.seconds

  Type WebhookPayload:
    event: String
    data: Any
    timestamp: Timestamp
    signature: String?

  Behavior Webhooks:
    When webhook.send(config, event, data):
      Then:
        - payload = WebhookPayload(
            event: event,
            data: data,
            timestamp: now()
          )
        
        - body = JSON.stringify(payload)
        
        - # Sign payload
        - if config.secret:
            - signature = crypto.hmac(SHA256, config.secret, body).hex()
            - payload.signature = signature
        
        - headers = merge(config.headers ?? {}, {
            "Content-Type": "application/json",
            "X-Webhook-Event": event,
            "X-Webhook-Timestamp": payload.timestamp.unix.to_string()
          })
        
        - if config.secret:
            - headers["X-Webhook-Signature"] = "sha256=${signature}"
        
        - response = await http.post(config.url, {
            headers: headers,
            body: body,
            timeout: config.timeout
          })
        
        - if response.status >= 400:
            - raise WebhookError(response.status, response.body)
        
        - emit WebhookSent(config.url, event)
        - return response

    When webhook.verify(request, secret):
      Then:
        - signature = request.headers["X-Webhook-Signature"]
        - if not signature:
            - return false
        
        - expected = "sha256=${crypto.hmac(SHA256, secret, request.body).hex()}"
        - return crypto.constant_time_compare(signature, expected)

  # ==========================================================================
  # IN-APP NOTIFICATIONS
  # ==========================================================================

  Type InAppNotification:
    id: NotificationId
    user_id: String
    type: String
    title: String
    body: String
    icon: String?
    action_url: String?
    data: Map<String, Any>?
    read: Boolean
    archived: Boolean
    created_at: Timestamp

  Behavior InAppNotifications:
    State:
      notifications: Map<String, List<InAppNotification>>
      subscriptions: Map<String, List<Subscriber>>

    When in_app.send(user_id, notification):
      Then:
        - notif = InAppNotification(
            id: generate_id(),
            user_id: user_id,
            type: notification.type,
            title: notification.title,
            body: notification.body,
            icon: notification.icon,
            action_url: notification.action_url,
            data: notification.data,
            read: false,
            archived: false,
            created_at: now()
          )
        
        - user_notifications = notifications.get_or_create(user_id, [])
        - add notif to user_notifications
        
        - # Notify subscribers (real-time)
        - for subscriber in subscriptions.get(user_id) ?? []:
            - subscriber.callback(notif)
        
        - emit InAppNotificationSent(user_id, notif.id)
        - return notif

    When in_app.get_unread(user_id):
      Then:
        - return notifications.get(user_id)?.filter(n -> not n.read and not n.archived) ?? []

    When in_app.get_all(user_id, options):
      Then:
        - all = notifications.get(user_id) ?? []
        - if not options.include_archived:
            - all = all.filter(n -> not n.archived)
        - return all.sort_by(n -> -n.created_at.unix).take(options.limit ?? 50)

    When in_app.mark_read(user_id, notification_id):
      Then:
        - notif = find_notification(user_id, notification_id)
        - if notif:
            - notif.read = true
            - emit NotificationRead(user_id, notification_id)

    When in_app.mark_all_read(user_id):
      Then:
        - for notif in notifications.get(user_id) ?? []:
            - notif.read = true
        - emit AllNotificationsRead(user_id)

    When in_app.archive(user_id, notification_id):
      Then:
        - notif = find_notification(user_id, notification_id)
        - if notif:
            - notif.archived = true

    When in_app.subscribe(user_id, callback):
      Then:
        - subscriber = Subscriber(generate_id(), callback)
        - subscriptions.get_or_create(user_id, []).push(subscriber)
        - return () -> subscriptions.get(user_id).remove(subscriber)

  # ==========================================================================
  # NOTIFICATION SERVICE
  # ==========================================================================

  Behavior NotificationService:
    State:
      types: Map<String, NotificationType>
      preferences: Map<String, UserPreferences>
      queue: NotificationQueue

    Type UserPreferences:
      user_id: String
      channels: Map<String, ChannelPreference>
      quiet_hours: QuietHours?
      frequency: FrequencyPreference?

    Type ChannelPreference:
      enabled: Boolean
      types: Map<String, Boolean>?

    Type QuietHours:
      enabled: Boolean
      start: Time
      end: Time
      timezone: String

    Type FrequencyPreference:
      max_per_day: Int?
      digest: DigestPreference?

    Type DigestPreference:
      enabled: Boolean
      frequency: DigestFrequency
      time: Time

    Type DigestFrequency:
      variants: [Daily, Weekly]

    When notify.send(type_key, recipient, data, options):
      Then:
        - type = types.get(type_key)
        - if not type:
            - raise NotificationTypeNotFound(type_key)
        
        - # Check user preferences
        - prefs = preferences.get(recipient.user_id)
        - if prefs:
            - # Check quiet hours
            - if is_quiet_hours(prefs):
                - if options.respect_quiet_hours ?? true:
                    - return queue_for_later(type, recipient, data)
            
            - # Check throttling
            - if is_throttled(type, recipient):
                - return null
        
        - # Render content
        - content = render_notification(type, data)
        
        - # Send to each enabled channel
        - results = []
        - for channel in type.channels:
            - if is_channel_enabled(prefs, channel, type_key):
                - result = await send_to_channel(channel, recipient, content, options)
                - add result to results
        
        - return results

    When send_to_channel(channel, recipient, content, options):
      Then:
        - notification = Notification(
            id: generate_id(),
            type: options.type_key,
            channel: channel,
            recipient: recipient,
            content: content,
            priority: options.priority ?? Normal,
            status: Pending,
            created_at: now()
          )
        
        - try:
            - match channel:
                Email -> await email.send(build_email(recipient, content))
                Push -> await push.send_to_user(recipient.user_id, build_push(content))
                SMS -> await sms.send(SMSMessage(to: recipient.phone, body: content.body))
                InApp -> await in_app.send(recipient.user_id, content)
                Webhook -> await webhook.send(recipient.webhook_url, "notification", content)
                Slack -> await slack.send(recipient.slack_channel, build_slack(content))
                Discord -> await discord.send(recipient.discord_channel, build_discord(content))
                Telegram -> await telegram.send(recipient.telegram_chat_id, content.body)
            
            - notification.status = Sent
            - notification.sent_at = now()
            - emit NotificationSent(notification)
          catch error:
            - notification.status = Failed(error.message)
            - emit NotificationFailed(notification, error)
            
            - # Retry if configured
            - if type.settings.retry:
                - await queue.retry(notification, type.settings.retry)
        
        - return notification

    When notify.register_type(type):
      Then:
        - types[type.key] = type

    When notify.set_preferences(user_id, prefs):
      Then:
        - preferences[user_id] = prefs

  # ==========================================================================
  # EVENTS
  # ==========================================================================

  Events:
    NotificationSent:
      notification_id: NotificationId
      channel: Channel
      recipient: String

    NotificationDelivered:
      notification_id: NotificationId
      delivered_at: Timestamp

    NotificationFailed:
      notification_id: NotificationId
      error: String

    NotificationRead:
      user_id: String
      notification_id: NotificationId

    WebhookSent:
      url: String
      event: String

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Notifications Usage":
    ```vibee
    # Register notification types
    notify.register_type(NotificationType(
      key: "order_shipped",
      name: "Order Shipped",
      channels: [Email, Push, InApp],
      template: "Your order {{order_id}} has been shipped!"
    ))

    notify.register_type(NotificationType(
      key: "payment_received",
      name: "Payment Received",
      channels: [Email, SMS],
      settings: NotificationSettings(
        throttle: ThrottleConfig(max_per_hour: 5)
      )
    ))

    # Set user preferences
    notify.set_preferences("user_123", UserPreferences(
      channels: {
        "email": ChannelPreference(enabled: true),
        "push": ChannelPreference(enabled: true),
        "sms": ChannelPreference(enabled: false)
      },
      quiet_hours: QuietHours(
        enabled: true,
        start: Time(22, 0),
        end: Time(8, 0),
        timezone: "America/New_York"
      )
    ))

    # Send notification
    await notify.send("order_shipped", 
      Recipient(
        user_id: "user_123",
        email: "user@example.com",
        device_tokens: [DeviceToken(token: "...", platform: iOS)]
      ),
      { order_id: "ORD-12345", tracking_url: "https://..." }
    )

    # Push notification directly
    await push.send(device_token, PushPayload(
      title: "New Message",
      body: "You have a new message from John",
      badge: 5,
      data: { conversation_id: "conv_123" }
    ))

    # SMS
    await sms.send(SMSMessage(
      to: "+1234567890",
      body: "Your verification code is: 123456"
    ))

    # Webhook
    await webhook.send(
      WebhookConfig(
        url: "https://api.example.com/webhooks",
        secret: "webhook_secret"
      ),
      "user.created",
      { user_id: "123", email: "user@example.com" }
    )

    # In-app notifications with real-time updates
    unsubscribe = in_app.subscribe("user_123", (notification) ->
      update_notification_badge(notification)
    )

    notifications = await in_app.get_unread("user_123")
    await in_app.mark_read("user_123", notification_id)
    ```
