# ============================================================================
# CRYPTOGRAPHY - Криптография на Vibee
# ============================================================================
# Encryption, hashing, signatures, key management
# ============================================================================

Specification Cryptography:
  """Криптография как спецификация безопасности."""

  # ==========================================================================
  # HASH FUNCTIONS
  # ==========================================================================

  Type HashAlgorithm:
    variants:
      - MD5           # Deprecated, for legacy only
      - SHA1          # Deprecated
      - SHA256
      - SHA384
      - SHA512
      - SHA3_256
      - SHA3_384
      - SHA3_512
      - BLAKE2b: Int  # Output size
      - BLAKE2s: Int
      - BLAKE3

  Type Hash:
    algorithm: HashAlgorithm
    digest: Bytes

  Behavior Hashing:
    When crypto.hash(algorithm, data):
      Then:
        - hasher = create_hasher(algorithm)
        - hasher.update(data)
        - return Hash(algorithm, hasher.finalize())

    When crypto.hash_stream(algorithm, stream):
      Then:
        - hasher = create_hasher(algorithm)
        - async for chunk in stream:
            - hasher.update(chunk)
        - return Hash(algorithm, hasher.finalize())

    When crypto.hash_file(algorithm, path):
      Then:
        - stream = await fs.create_read_stream(path)
        - return await crypto.hash_stream(algorithm, stream)

    When hasher.update(data):
      Then:
        - internal_state.update(data)
        - return hasher

    When hasher.finalize():
      Then:
        - return internal_state.finalize()

    When hasher.copy():
      Then:
        - return Hasher(internal_state.copy())

    When hash.hex():
      Then: digest.to_hex()

    When hash.base64():
      Then: base64_encode(digest)

    When hash.verify(expected):
      Then: constant_time_compare(digest, expected)

  # ==========================================================================
  # HMAC
  # ==========================================================================

  Type HMAC:
    algorithm: HashAlgorithm
    key: Bytes

  Behavior HMACBehavior:
    When crypto.hmac(algorithm, key, data):
      Then:
        - hmac = create_hmac(algorithm, key)
        - hmac.update(data)
        - return hmac.finalize()

    When crypto.hmac_verify(algorithm, key, data, signature):
      Then:
        - expected = crypto.hmac(algorithm, key, data)
        - return constant_time_compare(expected, signature)

  # ==========================================================================
  # PASSWORD HASHING
  # ==========================================================================

  Type PasswordHashAlgorithm:
    variants:
      - Argon2id: Argon2Config
      - Argon2i: Argon2Config
      - Argon2d: Argon2Config
      - Bcrypt: BcryptConfig
      - Scrypt: ScryptConfig
      - PBKDF2: PBKDF2Config

  Type Argon2Config:
    memory: Int = 65536      # KB
    iterations: Int = 3
    parallelism: Int = 4
    salt_length: Int = 16
    hash_length: Int = 32

  Type BcryptConfig:
    cost: Int = 12

  Type ScryptConfig:
    n: Int = 16384
    r: Int = 8
    p: Int = 1
    key_length: Int = 32

  Type PBKDF2Config:
    algorithm: HashAlgorithm = SHA256
    iterations: Int = 100000
    key_length: Int = 32

  Behavior PasswordHashing:
    When crypto.password_hash(password, algorithm):
      Then:
        - salt = crypto.random_bytes(algorithm.salt_length ?? 16)
        - hash = match algorithm:
            Argon2id(config) -> argon2id_hash(password, salt, config)
            Argon2i(config) -> argon2i_hash(password, salt, config)
            Bcrypt(config) -> bcrypt_hash(password, config.cost)
            Scrypt(config) -> scrypt_hash(password, salt, config)
            PBKDF2(config) -> pbkdf2_hash(password, salt, config)
        - return encode_password_hash(algorithm, salt, hash)

    When crypto.password_verify(password, encoded_hash):
      Then:
        - (algorithm, salt, expected_hash) = decode_password_hash(encoded_hash)
        - computed = match algorithm:
            Argon2id(config) -> argon2id_hash(password, salt, config)
            Argon2i(config) -> argon2i_hash(password, salt, config)
            Bcrypt(_) -> bcrypt_verify(password, encoded_hash)
            Scrypt(config) -> scrypt_hash(password, salt, config)
            PBKDF2(config) -> pbkdf2_hash(password, salt, config)
        - return constant_time_compare(computed, expected_hash)

    When crypto.password_needs_rehash(encoded_hash, algorithm):
      Then:
        - (current_algo, _, _) = decode_password_hash(encoded_hash)
        - return current_algo != algorithm

  # ==========================================================================
  # SYMMETRIC ENCRYPTION
  # ==========================================================================

  Type SymmetricAlgorithm:
    variants:
      - AES_128_GCM
      - AES_256_GCM
      - AES_128_CBC
      - AES_256_CBC
      - AES_128_CTR
      - AES_256_CTR
      - ChaCha20Poly1305
      - XChaCha20Poly1305

  Type SymmetricKey:
    algorithm: SymmetricAlgorithm
    key: Bytes

  Type EncryptedData:
    algorithm: SymmetricAlgorithm
    ciphertext: Bytes
    nonce: Bytes
    tag: Bytes?  # For AEAD
    aad: Bytes?  # Additional authenticated data

  Behavior SymmetricEncryption:
    When crypto.generate_key(algorithm):
      Then:
        - key_size = match algorithm:
            AES_128_GCM | AES_128_CBC | AES_128_CTR -> 16
            AES_256_GCM | AES_256_CBC | AES_256_CTR -> 32
            ChaCha20Poly1305 | XChaCha20Poly1305 -> 32
        - key = crypto.random_bytes(key_size)
        - return SymmetricKey(algorithm, key)

    When crypto.encrypt(key, plaintext, aad):
      Then:
        - nonce = generate_nonce(key.algorithm)
        - (ciphertext, tag) = match key.algorithm:
            AES_128_GCM | AES_256_GCM ->
              aes_gcm_encrypt(key.key, nonce, plaintext, aad)
            AES_128_CBC | AES_256_CBC ->
              (aes_cbc_encrypt(key.key, nonce, pkcs7_pad(plaintext)), null)
            AES_128_CTR | AES_256_CTR ->
              (aes_ctr_encrypt(key.key, nonce, plaintext), null)
            ChaCha20Poly1305 ->
              chacha20_poly1305_encrypt(key.key, nonce, plaintext, aad)
            XChaCha20Poly1305 ->
              xchacha20_poly1305_encrypt(key.key, nonce, plaintext, aad)
        - return EncryptedData(key.algorithm, ciphertext, nonce, tag, aad)

    When crypto.decrypt(key, encrypted):
      Then:
        - plaintext = match key.algorithm:
            AES_128_GCM | AES_256_GCM ->
              aes_gcm_decrypt(key.key, encrypted.nonce, encrypted.ciphertext, encrypted.tag, encrypted.aad)
            AES_128_CBC | AES_256_CBC ->
              pkcs7_unpad(aes_cbc_decrypt(key.key, encrypted.nonce, encrypted.ciphertext))
            AES_128_CTR | AES_256_CTR ->
              aes_ctr_decrypt(key.key, encrypted.nonce, encrypted.ciphertext)
            ChaCha20Poly1305 ->
              chacha20_poly1305_decrypt(key.key, encrypted.nonce, encrypted.ciphertext, encrypted.tag, encrypted.aad)
            XChaCha20Poly1305 ->
              xchacha20_poly1305_decrypt(key.key, encrypted.nonce, encrypted.ciphertext, encrypted.tag, encrypted.aad)
        - return plaintext

    When generate_nonce(algorithm):
      Then:
        - size = match algorithm:
            AES_128_GCM | AES_256_GCM -> 12
            AES_128_CBC | AES_256_CBC -> 16
            AES_128_CTR | AES_256_CTR -> 16
            ChaCha20Poly1305 -> 12
            XChaCha20Poly1305 -> 24
        - return crypto.random_bytes(size)

  # ==========================================================================
  # ASYMMETRIC ENCRYPTION
  # ==========================================================================

  Type AsymmetricAlgorithm:
    variants:
      - RSA: Int           # Key size: 2048, 3072, 4096
      - Ed25519
      - Ed448
      - X25519
      - X448
      - ECDSA: Curve
      - ECDH: Curve

  Type Curve:
    variants:
      - P256
      - P384
      - P521
      - Secp256k1

  Type KeyPair:
    algorithm: AsymmetricAlgorithm
    public_key: PublicKey
    private_key: PrivateKey

  Type PublicKey:
    algorithm: AsymmetricAlgorithm
    key: Bytes

  Type PrivateKey:
    algorithm: AsymmetricAlgorithm
    key: Bytes

  Type KeyFormat:
    variants:
      - PEM
      - DER
      - JWK
      - Raw

  Behavior AsymmetricEncryption:
    When crypto.generate_keypair(algorithm):
      Then:
        - (public, private) = match algorithm:
            RSA(bits) -> rsa_generate(bits)
            Ed25519 -> ed25519_generate()
            Ed448 -> ed448_generate()
            X25519 -> x25519_generate()
            X448 -> x448_generate()
            ECDSA(curve) -> ecdsa_generate(curve)
            ECDH(curve) -> ecdh_generate(curve)
        - return KeyPair(algorithm, PublicKey(algorithm, public), PrivateKey(algorithm, private))

    When crypto.encrypt_asymmetric(public_key, plaintext, padding):
      Then:
        - match public_key.algorithm:
            RSA(_) ->
              rsa_encrypt(public_key.key, plaintext, padding ?? OAEP_SHA256)
            _ ->
              raise UnsupportedOperation("Encryption not supported for this algorithm")

    When crypto.decrypt_asymmetric(private_key, ciphertext, padding):
      Then:
        - match private_key.algorithm:
            RSA(_) ->
              rsa_decrypt(private_key.key, ciphertext, padding ?? OAEP_SHA256)
            _ ->
              raise UnsupportedOperation("Decryption not supported for this algorithm")

    When crypto.derive_shared_secret(private_key, public_key):
      Then:
        - match (private_key.algorithm, public_key.algorithm):
            (X25519, X25519) -> x25519_derive(private_key.key, public_key.key)
            (X448, X448) -> x448_derive(private_key.key, public_key.key)
            (ECDH(c1), ECDH(c2)) if c1 == c2 -> ecdh_derive(private_key.key, public_key.key, c1)
            _ -> raise IncompatibleKeys

  # ==========================================================================
  # DIGITAL SIGNATURES
  # ==========================================================================

  Type Signature:
    algorithm: AsymmetricAlgorithm
    signature: Bytes

  Type SignatureScheme:
    variants:
      - RSA_PKCS1_SHA256
      - RSA_PKCS1_SHA384
      - RSA_PKCS1_SHA512
      - RSA_PSS_SHA256
      - RSA_PSS_SHA384
      - RSA_PSS_SHA512
      - ECDSA_SHA256
      - ECDSA_SHA384
      - ECDSA_SHA512
      - Ed25519
      - Ed448

  Behavior DigitalSignatures:
    When crypto.sign(private_key, data, scheme):
      Then:
        - signature = match scheme:
            RSA_PKCS1_SHA256 -> rsa_pkcs1_sign(private_key.key, sha256(data))
            RSA_PKCS1_SHA384 -> rsa_pkcs1_sign(private_key.key, sha384(data))
            RSA_PKCS1_SHA512 -> rsa_pkcs1_sign(private_key.key, sha512(data))
            RSA_PSS_SHA256 -> rsa_pss_sign(private_key.key, sha256(data))
            RSA_PSS_SHA384 -> rsa_pss_sign(private_key.key, sha384(data))
            RSA_PSS_SHA512 -> rsa_pss_sign(private_key.key, sha512(data))
            ECDSA_SHA256 -> ecdsa_sign(private_key.key, sha256(data))
            ECDSA_SHA384 -> ecdsa_sign(private_key.key, sha384(data))
            ECDSA_SHA512 -> ecdsa_sign(private_key.key, sha512(data))
            Ed25519 -> ed25519_sign(private_key.key, data)
            Ed448 -> ed448_sign(private_key.key, data)
        - return Signature(private_key.algorithm, signature)

    When crypto.verify(public_key, data, signature, scheme):
      Then:
        - return match scheme:
            RSA_PKCS1_SHA256 -> rsa_pkcs1_verify(public_key.key, sha256(data), signature.signature)
            RSA_PKCS1_SHA384 -> rsa_pkcs1_verify(public_key.key, sha384(data), signature.signature)
            RSA_PKCS1_SHA512 -> rsa_pkcs1_verify(public_key.key, sha512(data), signature.signature)
            RSA_PSS_SHA256 -> rsa_pss_verify(public_key.key, sha256(data), signature.signature)
            RSA_PSS_SHA384 -> rsa_pss_verify(public_key.key, sha384(data), signature.signature)
            RSA_PSS_SHA512 -> rsa_pss_verify(public_key.key, sha512(data), signature.signature)
            ECDSA_SHA256 -> ecdsa_verify(public_key.key, sha256(data), signature.signature)
            ECDSA_SHA384 -> ecdsa_verify(public_key.key, sha384(data), signature.signature)
            ECDSA_SHA512 -> ecdsa_verify(public_key.key, sha512(data), signature.signature)
            Ed25519 -> ed25519_verify(public_key.key, data, signature.signature)
            Ed448 -> ed448_verify(public_key.key, data, signature.signature)

  # ==========================================================================
  # KEY DERIVATION
  # ==========================================================================

  Type KDF:
    variants:
      - HKDF: HKDFConfig
      - PBKDF2: PBKDF2Config
      - Scrypt: ScryptConfig
      - Argon2: Argon2Config

  Type HKDFConfig:
    algorithm: HashAlgorithm
    salt: Bytes?
    info: Bytes?
    length: Int

  Behavior KeyDerivation:
    When crypto.derive_key(kdf, input):
      Then:
        - match kdf:
            HKDF(config) ->
              hkdf_derive(config.algorithm, input, config.salt, config.info, config.length)
            PBKDF2(config) ->
              pbkdf2_derive(config.algorithm, input, config.salt, config.iterations, config.key_length)
            Scrypt(config) ->
              scrypt_derive(input, config.salt, config.n, config.r, config.p, config.key_length)
            Argon2(config) ->
              argon2_derive(input, config.salt, config)

    When crypto.hkdf_expand(algorithm, prk, info, length):
      Then:
        - hkdf_expand_only(algorithm, prk, info, length)

    When crypto.hkdf_extract(algorithm, ikm, salt):
      Then:
        - hkdf_extract_only(algorithm, ikm, salt)

  # ==========================================================================
  # RANDOM
  # ==========================================================================

  Behavior RandomGeneration:
    When crypto.random_bytes(length):
      Then:
        - return secure_random_bytes(length)

    When crypto.random_int(min, max):
      Then:
        - range = max - min
        - bytes_needed = ceil(log2(range) / 8)
        - loop:
            - bytes = crypto.random_bytes(bytes_needed)
            - value = bytes_to_int(bytes)
            - if value < range:
                - return min + value

    When crypto.random_uuid():
      Then:
        - bytes = crypto.random_bytes(16)
        - # Set version 4
        - bytes[6] = (bytes[6] & 0x0f) | 0x40
        - # Set variant
        - bytes[8] = (bytes[8] & 0x3f) | 0x80
        - return format_uuid(bytes)

    When crypto.random_string(length, charset):
      Then:
        - charset = charset ?? "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        - result = ""
        - for i in 0..length:
            - idx = crypto.random_int(0, charset.length)
            - result += charset[idx]
        - return result

  # ==========================================================================
  # KEY MANAGEMENT
  # ==========================================================================

  Behavior KeyManagement:
    When crypto.export_key(key, format, password):
      Then:
        - match format:
            PEM ->
              if password:
                encrypt_pem(key, password)
              else:
                encode_pem(key)
            DER ->
              encode_der(key)
            JWK ->
              encode_jwk(key)
            Raw ->
              key.key

    When crypto.import_key(data, format, password):
      Then:
        - match format:
            PEM ->
              if password:
                decrypt_pem(data, password)
              else:
                decode_pem(data)
            DER ->
              decode_der(data)
            JWK ->
              decode_jwk(data)
            Raw ->
              data

    When crypto.key_fingerprint(key, algorithm):
      Then:
        - der = crypto.export_key(key, DER)
        - return crypto.hash(algorithm ?? SHA256, der).hex()

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Cryptography Usage":
    ```vibee
    # Hashing
    hash = crypto.hash(SHA256, "Hello, World!")
    log.info("SHA256: ${hash.hex()}")

    # Password hashing
    hashed = crypto.password_hash("secret123", Argon2id(Argon2Config()))
    valid = crypto.password_verify("secret123", hashed)

    # Symmetric encryption
    key = crypto.generate_key(AES_256_GCM)
    encrypted = crypto.encrypt(key, "Secret message".encode(), aad: "context")
    decrypted = crypto.decrypt(key, encrypted)

    # Asymmetric encryption
    keypair = crypto.generate_keypair(RSA(4096))
    encrypted = crypto.encrypt_asymmetric(keypair.public_key, "Secret")
    decrypted = crypto.decrypt_asymmetric(keypair.private_key, encrypted)

    # Digital signatures
    keypair = crypto.generate_keypair(Ed25519)
    signature = crypto.sign(keypair.private_key, document, Ed25519)
    valid = crypto.verify(keypair.public_key, document, signature, Ed25519)

    # Key exchange
    alice = crypto.generate_keypair(X25519)
    bob = crypto.generate_keypair(X25519)
    alice_secret = crypto.derive_shared_secret(alice.private_key, bob.public_key)
    bob_secret = crypto.derive_shared_secret(bob.private_key, alice.public_key)
    # alice_secret == bob_secret

    # Key derivation
    master_key = crypto.random_bytes(32)
    derived = crypto.derive_key(HKDF(HKDFConfig(
      algorithm: SHA256,
      salt: crypto.random_bytes(32),
      info: "encryption key".encode(),
      length: 32
    )), master_key)
    ```
