# ============================================================================
# ERROR HANDLING - Система обработки ошибок на Vibee
# ============================================================================
# Result types, error types, recovery, reporting
# ============================================================================

Specification ErrorHandling:
  """Обработка ошибок как спецификация надёжности."""

  # ==========================================================================
  # RESULT TYPE
  # ==========================================================================

  Type Result<T, E>:
    variants:
      - Ok: T
      - Err: E

    Method is_ok() -> Boolean:
      match self:
        Ok(_) -> true
        Err(_) -> false

    Method is_err() -> Boolean:
      match self:
        Ok(_) -> false
        Err(_) -> true

    Method unwrap() -> T:
      match self:
        Ok(value) -> value
        Err(error) -> throw UnwrapError(error)

    Method unwrap_or(default: T) -> T:
      match self:
        Ok(value) -> value
        Err(_) -> default

    Method unwrap_or_else(fn: (E) -> T) -> T:
      match self:
        Ok(value) -> value
        Err(error) -> fn(error)

    Method expect(message: String) -> T:
      match self:
        Ok(value) -> value
        Err(error) -> throw ExpectError(message, error)

    Method map<U>(fn: (T) -> U) -> Result<U, E>:
      match self:
        Ok(value) -> Ok(fn(value))
        Err(error) -> Err(error)

    Method map_err<F>(fn: (E) -> F) -> Result<T, F>:
      match self:
        Ok(value) -> Ok(value)
        Err(error) -> Err(fn(error))

    Method and_then<U>(fn: (T) -> Result<U, E>) -> Result<U, E>:
      match self:
        Ok(value) -> fn(value)
        Err(error) -> Err(error)

    Method or_else<F>(fn: (E) -> Result<T, F>) -> Result<T, F>:
      match self:
        Ok(value) -> Ok(value)
        Err(error) -> fn(error)

    Method ok() -> Option<T>:
      match self:
        Ok(value) -> Some(value)
        Err(_) -> None

    Method err() -> Option<E>:
      match self:
        Ok(_) -> None
        Err(error) -> Some(error)

    Method transpose() -> Option<Result<T, E>>:
      # For Result<Option<T>, E>
      match self:
        Ok(Some(value)) -> Some(Ok(value))
        Ok(None) -> None
        Err(error) -> Some(Err(error))

  # ==========================================================================
  # OPTION TYPE
  # ==========================================================================

  Type Option<T>:
    variants:
      - Some: T
      - None

    Method is_some() -> Boolean:
      match self:
        Some(_) -> true
        None -> false

    Method is_none() -> Boolean:
      match self:
        Some(_) -> false
        None -> true

    Method unwrap() -> T:
      match self:
        Some(value) -> value
        None -> throw UnwrapError("Called unwrap on None")

    Method unwrap_or(default: T) -> T:
      match self:
        Some(value) -> value
        None -> default

    Method unwrap_or_else(fn: () -> T) -> T:
      match self:
        Some(value) -> value
        None -> fn()

    Method expect(message: String) -> T:
      match self:
        Some(value) -> value
        None -> throw ExpectError(message)

    Method map<U>(fn: (T) -> U) -> Option<U>:
      match self:
        Some(value) -> Some(fn(value))
        None -> None

    Method and_then<U>(fn: (T) -> Option<U>) -> Option<U>:
      match self:
        Some(value) -> fn(value)
        None -> None

    Method or_else(fn: () -> Option<T>) -> Option<T>:
      match self:
        Some(value) -> Some(value)
        None -> fn()

    Method filter(predicate: (T) -> Boolean) -> Option<T>:
      match self:
        Some(value) -> if predicate(value) then Some(value) else None
        None -> None

    Method ok_or<E>(error: E) -> Result<T, E>:
      match self:
        Some(value) -> Ok(value)
        None -> Err(error)

    Method ok_or_else<E>(fn: () -> E) -> Result<T, E>:
      match self:
        Some(value) -> Ok(value)
        None -> Err(fn())

  # ==========================================================================
  # ERROR TYPES
  # ==========================================================================

  Type Error:
    message: String
    code: String?
    cause: Error?
    stack: StackTrace?
    context: Map<String, Any>

    Static Method new(message: String) -> Error:
      return Error(
        message: message,
        stack: capture_stack_trace()
      )

    Method with_code(code: String) -> Error:
      self.code = code
      return self

    Method with_cause(cause: Error) -> Error:
      self.cause = cause
      return self

    Method with_context(key: String, value: Any) -> Error:
      self.context[key] = value
      return self

    Method chain() -> List<Error>:
      errors = [self]
      current = self.cause
      while current != null:
        errors.push(current)
        current = current.cause
      return errors

    Method root_cause() -> Error:
      current = self
      while current.cause != null:
        current = current.cause
      return current

    Method to_string() -> String:
      parts = [self.message]
      if self.code:
        parts.insert(0, "[${self.code}]")
      if self.cause:
        parts.push("Caused by: ${self.cause.to_string()}")
      return parts.join(" ")

  Type StackTrace:
    frames: List<StackFrame>

    Method to_string() -> String:
      return frames.map(f -> f.to_string()).join("\n")

  Type StackFrame:
    function_name: String
    file_path: String
    line: Int
    column: Int

    Method to_string() -> String:
      return "  at ${function_name} (${file_path}:${line}:${column})"

  # ==========================================================================
  # COMMON ERROR TYPES
  # ==========================================================================

  Type ValidationError extends Error:
    field: String?
    value: Any?
    constraint: String?

  Type NotFoundError extends Error:
    resource_type: String
    resource_id: Any

  Type UnauthorizedError extends Error:
    reason: String?

  Type ForbiddenError extends Error:
    action: String?
    resource: String?

  Type ConflictError extends Error:
    existing_resource: Any?

  Type TimeoutError extends Error:
    timeout: Duration
    operation: String?

  Type NetworkError extends Error:
    url: URL?
    status_code: Int?

  Type IOError extends Error:
    path: Path?
    operation: String?

  Type ParseError extends Error:
    input: String?
    position: Int?
    expected: String?

  Type ConfigError extends Error:
    key: String?
    expected_type: String?

  Type DatabaseError extends Error:
    query: String?
    sql_state: String?

  # ==========================================================================
  # ERROR BUILDER
  # ==========================================================================

  Behavior ErrorBuilder:
    When error(message: String) -> ErrorBuilder:
      Then:
        - return ErrorBuilder(message)

    Type ErrorBuilder:
      message: String
      code: String?
      cause: Error?
      context: Map<String, Any> = {}
      http_status: Int?

      Method code(code: String) -> ErrorBuilder:
        self.code = code
        return self

      Method cause(error: Error) -> ErrorBuilder:
        self.cause = error
        return self

      Method context(key: String, value: Any) -> ErrorBuilder:
        self.context[key] = value
        return self

      Method http_status(status: Int) -> ErrorBuilder:
        self.http_status = status
        return self

      Method build() -> Error:
        return Error(
          message: message,
          code: code,
          cause: cause,
          context: context,
          stack: capture_stack_trace()
        )

      Method throw():
        throw build()

  # ==========================================================================
  # TRY-CATCH UTILITIES
  # ==========================================================================

  Behavior TryCatch:
    When try_catch<T>(fn: () -> T) -> Result<T, Error>:
      Then:
        - try:
            - return Ok(fn())
          catch e:
            - return Err(wrap_error(e))

    When try_catch_async<T>(fn: () -> Promise<T>) -> Promise<Result<T, Error>>:
      Then:
        - try:
            - return Ok(await fn())
          catch e:
            - return Err(wrap_error(e))

    When wrap_error(e: Any) -> Error:
      Then:
        - if e is Error:
            - return e
        - if e is String:
            - return Error.new(e)
        - return Error.new(e.to_string())

    When retry<T>(fn: () -> T, options: RetryOptions) -> T:
      Then:
        - attempts = 0
        - last_error = null
        
        - while attempts < options.max_attempts:
            - attempts += 1
            - try:
                - return fn()
              catch e:
                - last_error = e
                - if not options.should_retry(e, attempts):
                    - throw e
                - delay = calculate_delay(attempts, options)
                - await sleep(delay)
                - if options.on_retry:
                    - options.on_retry(e, attempts)
        
        - throw last_error

    Type RetryOptions:
      max_attempts: Int = 3
      initial_delay: Duration = 1.second
      max_delay: Duration = 30.seconds
      multiplier: Float = 2.0
      jitter: Float = 0.1
      should_retry: ((Error, Int) -> Boolean)?
      on_retry: ((Error, Int) -> Void)?

    When fallback<T>(fn: () -> T, fallback_value: T) -> T:
      Then:
        - try:
            - return fn()
          catch:
            - return fallback_value

    When fallback_async<T>(fn: () -> Promise<T>, fallback_fn: () -> Promise<T>) -> Promise<T>:
      Then:
        - try:
            - return await fn()
          catch:
            - return await fallback_fn()

  # ==========================================================================
  # ERROR RECOVERY
  # ==========================================================================

  Behavior ErrorRecovery:
    When recover<T, E>(result: Result<T, E>, recovery: (E) -> T) -> T:
      Then:
        - match result:
            Ok(value) -> value
            Err(error) -> recovery(error)

    When recover_with<T, E>(result: Result<T, E>, recovery: (E) -> Result<T, E>) -> Result<T, E>:
      Then:
        - match result:
            Ok(value) -> Ok(value)
            Err(error) -> recovery(error)

    When ensure<T>(condition: Boolean, error: Error) -> Result<Unit, Error>:
      Then:
        - if condition:
            - return Ok(())
          else:
            - return Err(error)

    When require<T>(value: T?, error: Error) -> Result<T, Error>:
      Then:
        - if value != null:
            - return Ok(value)
          else:
            - return Err(error)

  # ==========================================================================
  # ERROR AGGREGATION
  # ==========================================================================

  Behavior ErrorAggregation:
    Type AggregateError extends Error:
      errors: List<Error>

      Method add(error: Error):
        errors.push(error)

      Method has_errors() -> Boolean:
        return errors.length > 0

      Method to_string() -> String:
        if errors.length == 0:
          return "No errors"
        if errors.length == 1:
          return errors[0].to_string()
        return "Multiple errors:\n" + errors.map((e, i) -> "  ${i + 1}. ${e.message}").join("\n")

    When collect_errors<T>(results: List<Result<T, Error>>) -> Result<List<T>, AggregateError>:
      Then:
        - values = []
        - errors = AggregateError(errors: [])
        
        - for result in results:
            - match result:
                Ok(value) -> values.push(value)
                Err(error) -> errors.add(error)
        
        - if errors.has_errors():
            - return Err(errors)
          else:
            - return Ok(values)

    When partition_results<T>(results: List<Result<T, Error>>) -> (List<T>, List<Error>):
      Then:
        - values = []
        - errors = []
        
        - for result in results:
            - match result:
                Ok(value) -> values.push(value)
                Err(error) -> errors.push(error)
        
        - return (values, errors)

  # ==========================================================================
  # ERROR REPORTING
  # ==========================================================================

  Behavior ErrorReporting:
    When error_reporter.create(options: ReporterOptions) -> ErrorReporter:
      Then:
        - return ErrorReporter(options)

    Type ErrorReporter:
      options: ReporterOptions
      handlers: List<ErrorHandler>

      Method report(error: Error, context: ErrorContext?):
        enriched = enrich_error(error, context)
        
        for handler in handlers:
          try:
            await handler.handle(enriched)
          catch e:
            log.error("Error handler failed: ${e}")

      Method add_handler(handler: ErrorHandler):
        handlers.push(handler)

      Method enrich_error(error: Error, context: ErrorContext?) -> EnrichedError:
        return EnrichedError(
          error: error,
          timestamp: now(),
          environment: options.environment,
          release: options.release,
          user: context?.user,
          request: context?.request,
          tags: { ...options.default_tags, ...context?.tags },
          extra: { ...options.default_extra, ...context?.extra }
        )

    Type ReporterOptions:
      environment: String
      release: String?
      default_tags: Map<String, String>
      default_extra: Map<String, Any>
      sample_rate: Float = 1.0
      before_send: ((EnrichedError) -> EnrichedError?)?

    Type ErrorContext:
      user: UserInfo?
      request: RequestInfo?
      tags: Map<String, String>?
      extra: Map<String, Any>?

    Type UserInfo:
      id: String
      email: String?
      username: String?

    Type RequestInfo:
      method: String
      url: String
      headers: Map<String, String>
      body: Any?

    Type EnrichedError:
      error: Error
      timestamp: DateTime
      environment: String
      release: String?
      user: UserInfo?
      request: RequestInfo?
      tags: Map<String, String>
      extra: Map<String, Any>

    Type ErrorHandler:
      handle: (EnrichedError) -> Promise<Void>

    # Built-in handlers
    Type ConsoleHandler:
      Method handle(error: EnrichedError) -> Promise<Void>:
        log.error("Error: ${error.error.message}")
        if error.error.stack:
          log.error(error.error.stack.to_string())

    Type SentryHandler:
      dsn: String

      Method handle(error: EnrichedError) -> Promise<Void>:
        await sentry.capture_exception(error)

    Type SlackHandler:
      webhook_url: URL
      channel: String?

      Method handle(error: EnrichedError) -> Promise<Void>:
        await http.post(webhook_url, {
          channel: channel,
          text: format_slack_message(error)
        })

    Type FileHandler:
      path: Path

      Method handle(error: EnrichedError) -> Promise<Void>:
        line = JSON.stringify(error) + "\n"
        await fs.append_file(path, line)

  # ==========================================================================
  # PANIC & RECOVERY
  # ==========================================================================

  Behavior PanicRecovery:
    When panic(message: String):
      Then:
        - error = PanicError(message, capture_stack_trace())
        - throw error

    When recover(fn: () -> Any) -> Result<Any, PanicError>:
      Then:
        - try:
            - return Ok(fn())
          catch e:
            - if e is PanicError:
                - return Err(e)
            - throw e  # Re-throw non-panic errors

    Type PanicError extends Error:
      # Unrecoverable error

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Error Handling":
    ```vibee
    # Using Result type
    fn divide(a: Float, b: Float) -> Result<Float, Error>:
      if b == 0:
        return Err(error("Division by zero").code("DIVISION_BY_ZERO").build())
      return Ok(a / b)

    result = divide(10, 2)
    match result:
      Ok(value) -> log.info("Result: ${value}")
      Err(error) -> log.error("Error: ${error.message}")

    # Chaining operations
    fn parse_and_divide(input: String) -> Result<Float, Error>:
      return parse_float(input)
        .map_err(e -> error("Invalid number").cause(e).build())
        .and_then(n -> divide(100, n))

    # Using Option
    fn find_user(id: String) -> Option<User>:
      user = db.users.find(id)
      return if user then Some(user) else None

    user = find_user("123")
      .map(u -> u.name)
      .unwrap_or("Unknown")

    # Error builder
    throw error("User not found")
      .code("USER_NOT_FOUND")
      .context("user_id", user_id)
      .http_status(404)
      .build()

    # Retry with backoff
    result = await retry(
      () -> http.get("https://api.example.com/data"),
      {
        max_attempts: 5,
        initial_delay: 1.second,
        multiplier: 2.0,
        should_retry: (e, attempt) -> e is NetworkError and attempt < 5,
        on_retry: (e, attempt) -> log.warn("Retry ${attempt}: ${e.message}")
      }
    )

    # Fallback
    config = fallback(
      () -> load_config_from_file(),
      default_config
    )

    # Collect errors
    results = await Promise.all([
      validate_email(data.email),
      validate_password(data.password),
      validate_username(data.username)
    ])

    match collect_errors(results):
      Ok(values) -> proceed_with_registration()
      Err(errors) -> return ValidationResponse(errors.errors)

    # Error reporting
    reporter = error_reporter.create({
      environment: "production",
      release: "1.0.0",
      default_tags: { service: "api" }
    })

    reporter.add_handler(ConsoleHandler())
    reporter.add_handler(SentryHandler(dsn: env.SENTRY_DSN))
    reporter.add_handler(SlackHandler(
      webhook_url: env.SLACK_WEBHOOK,
      channel: "#errors"
    ))

    # Global error handler
    app.on_error(async (error, req) -> {
      await reporter.report(error, {
        user: { id: req.user?.id, email: req.user?.email },
        request: {
          method: req.method,
          url: req.url,
          headers: req.headers
        },
        tags: { endpoint: req.path }
      })

      # Return appropriate response
      match error:
        ValidationError -> Response.bad_request(error.message)
        NotFoundError -> Response.not_found(error.message)
        UnauthorizedError -> Response.unauthorized(error.message)
        ForbiddenError -> Response.forbidden(error.message)
        _ -> Response.internal_error("Internal server error")
    })

    # Custom error types
    Type InsufficientFundsError extends Error:
      account_id: String
      required: Money
      available: Money

      Static Method new(account_id: String, required: Money, available: Money) -> InsufficientFundsError:
        return InsufficientFundsError(
          message: "Insufficient funds: required ${required}, available ${available}",
          code: "INSUFFICIENT_FUNDS",
          account_id: account_id,
          required: required,
          available: available
        )

    fn withdraw(account_id: String, amount: Money) -> Result<Transaction, Error>:
      account = await get_account(account_id)?
      
      if account.balance < amount:
        return Err(InsufficientFundsError.new(account_id, amount, account.balance))
      
      transaction = await create_transaction(account, amount)?
      return Ok(transaction)
    ```
