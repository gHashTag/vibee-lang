# ============================================================================
# ENCODING - Кодирование данных на Vibee
# ============================================================================
# Base64, Hex, URL, HTML, Unicode
# ============================================================================

Specification Encoding:
  """Кодирование как спецификация преобразования данных."""

  # ==========================================================================
  # BASE64
  # ==========================================================================

  Behavior Base64:
    Const STANDARD_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    Const URL_SAFE_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"

    When base64.encode(data: Bytes) -> String:
      Then: encode_base64(data, STANDARD_ALPHABET, true)

    When base64.encode_no_padding(data: Bytes) -> String:
      Then: encode_base64(data, STANDARD_ALPHABET, false)

    When base64.encode_url_safe(data: Bytes) -> String:
      Then: encode_base64(data, URL_SAFE_ALPHABET, false)

    When base64.decode(input: String) -> Result<Bytes, DecodeError>:
      Then: decode_base64(input, STANDARD_ALPHABET)

    When base64.decode_url_safe(input: String) -> Result<Bytes, DecodeError>:
      Then: decode_base64(input, URL_SAFE_ALPHABET)

    When encode_base64(data: Bytes, alphabet: String, padding: Boolean) -> String:
      Then:
        result = StringBuilder()
        
        i = 0
        while i < data.length:
          # Get 3 bytes (24 bits)
          b1 = data[i]
          b2 = if i + 1 < data.length then data[i + 1] else 0
          b3 = if i + 2 < data.length then data[i + 2] else 0
          
          # Convert to 4 base64 characters
          result.append(alphabet[(b1 >> 2) & 0x3F])
          result.append(alphabet[((b1 << 4) | (b2 >> 4)) & 0x3F])
          
          if i + 1 < data.length:
            result.append(alphabet[((b2 << 2) | (b3 >> 6)) & 0x3F])
          else if padding:
            result.append('=')
          
          if i + 2 < data.length:
            result.append(alphabet[b3 & 0x3F])
          else if padding:
            result.append('=')
          
          i += 3
        
        return result.to_string()

    When decode_base64(input: String, alphabet: String) -> Result<Bytes, DecodeError>:
      Then:
        # Remove whitespace and padding
        clean = input.replace_regex("\\s", "").trim_end('=')
        
        # Build reverse lookup
        lookup = Map()
        for (i, char) in alphabet.enumerate():
          lookup[char] = i
        
        result = ByteBuffer()
        
        i = 0
        while i < clean.length:
          # Get 4 characters
          c1 = lookup.get(clean[i]) ?? return Err(DecodeError("Invalid character: ${clean[i]}"))
          c2 = lookup.get(clean[i + 1]) ?? return Err(DecodeError("Invalid character"))
          c3 = if i + 2 < clean.length then lookup.get(clean[i + 2]) else null
          c4 = if i + 3 < clean.length then lookup.get(clean[i + 3]) else null
          
          # Convert to 3 bytes
          result.write_byte((c1 << 2) | (c2 >> 4))
          
          if c3 != null:
            result.write_byte(((c2 << 4) | (c3 >> 2)) & 0xFF)
          
          if c4 != null:
            result.write_byte(((c3 << 6) | c4) & 0xFF)
          
          i += 4
        
        return Ok(result.to_bytes())

  # ==========================================================================
  # BASE32
  # ==========================================================================

  Behavior Base32:
    Const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
    Const HEX_ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUV"
    Const CROCKFORD_ALPHABET = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"

    When base32.encode(data: Bytes) -> String:
      Then: encode_base32(data, ALPHABET, true)

    When base32.encode_hex(data: Bytes) -> String:
      Then: encode_base32(data, HEX_ALPHABET, true)

    When base32.encode_crockford(data: Bytes) -> String:
      Then: encode_base32(data, CROCKFORD_ALPHABET, false)

    When base32.decode(input: String) -> Result<Bytes, DecodeError>:
      Then: decode_base32(input.uppercase(), ALPHABET)

    When base32.decode_crockford(input: String) -> Result<Bytes, DecodeError>:
      Then:
        # Crockford allows lowercase and some substitutions
        normalized = input.uppercase()
          .replace("O", "0")
          .replace("I", "1")
          .replace("L", "1")
        decode_base32(normalized, CROCKFORD_ALPHABET)

  # ==========================================================================
  # BASE62
  # ==========================================================================

  Behavior Base62:
    Const ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

    When base62.encode(data: Bytes) -> String:
      Then:
        # Convert bytes to big integer
        num = bytes_to_bigint(data)
        
        if num == 0:
          return "0"
        
        result = StringBuilder()
        while num > 0:
          result.prepend(ALPHABET[num % 62])
          num = num / 62
        
        return result.to_string()

    When base62.decode(input: String) -> Result<Bytes, DecodeError>:
      Then:
        num = 0
        for char in input:
          index = ALPHABET.index_of(char)
          if index == null:
            return Err(DecodeError("Invalid character: ${char}"))
          num = num * 62 + index
        
        return Ok(bigint_to_bytes(num))

    When base62.encode_int(n: Int) -> String:
      Then:
        if n == 0:
          return "0"
        
        result = StringBuilder()
        while n > 0:
          result.prepend(ALPHABET[n % 62])
          n = n / 62
        
        return result.to_string()

    When base62.decode_int(input: String) -> Result<Int, DecodeError>:
      Then:
        num = 0
        for char in input:
          index = ALPHABET.index_of(char)
          if index == null:
            return Err(DecodeError("Invalid character: ${char}"))
          num = num * 62 + index
        
        return Ok(num)

  # ==========================================================================
  # HEX
  # ==========================================================================

  Behavior Hex:
    When hex.encode(data: Bytes) -> String:
      Then:
        return data.map(b -> b.to_hex().pad_start(2, '0')).join("")

    When hex.encode_upper(data: Bytes) -> String:
      Then:
        return hex.encode(data).uppercase()

    When hex.decode(input: String) -> Result<Bytes, DecodeError>:
      Then:
        clean = input.replace_regex("\\s", "")
        
        if clean.length % 2 != 0:
          return Err(DecodeError("Hex string must have even length"))
        
        result = Bytes(clean.length / 2)
        
        for i in 0..(clean.length / 2):
          hex_pair = clean.slice(i * 2, i * 2 + 2)
          byte = parse_hex(hex_pair)
          if byte == null:
            return Err(DecodeError("Invalid hex: ${hex_pair}"))
          result[i] = byte
        
        return Ok(result)

  Extension Bytes:
    Method to_hex() -> String:
      return hex.encode(self)

    Method to_base64() -> String:
      return base64.encode(self)

  Extension Int:
    Method to_hex() -> String:
      if self == 0:
        return "0"
      
      digits = "0123456789abcdef"
      result = StringBuilder()
      n = abs(self)
      
      while n > 0:
        result.prepend(digits[n % 16])
        n = n / 16
      
      if self < 0:
        result.prepend('-')
      
      return result.to_string()

    Method to_base36() -> String:
      if self == 0:
        return "0"
      
      digits = "0123456789abcdefghijklmnopqrstuvwxyz"
      result = StringBuilder()
      n = abs(self)
      
      while n > 0:
        result.prepend(digits[n % 36])
        n = n / 36
      
      if self < 0:
        result.prepend('-')
      
      return result.to_string()

  # ==========================================================================
  # URL ENCODING
  # ==========================================================================

  Behavior URLEncoding:
    When url.encode(input: String) -> String:
      Then:
        result = StringBuilder()
        
        for char in input:
          if is_url_safe(char):
            result.append(char)
          else:
            # Encode as %XX
            for byte in char.to_utf8():
              result.append('%')
              result.append(byte.to_hex().pad_start(2, '0').uppercase())
        
        return result.to_string()

    When url.decode(input: String) -> Result<String, DecodeError>:
      Then:
        result = ByteBuffer()
        i = 0
        
        while i < input.length:
          char = input[i]
          
          if char == '%':
            if i + 2 >= input.length:
              return Err(DecodeError("Incomplete percent encoding"))
            
            hex = input.slice(i + 1, i + 3)
            byte = parse_hex(hex)
            if byte == null:
              return Err(DecodeError("Invalid percent encoding: %${hex}"))
            
            result.write_byte(byte)
            i += 3
          else if char == '+':
            result.write_byte(0x20)  # Space
            i += 1
          else:
            result.write_bytes(char.to_utf8())
            i += 1
        
        return Ok(result.to_string())

    When url.encode_component(input: String) -> String:
      Then:
        # More aggressive encoding for URL components
        result = StringBuilder()
        
        for char in input:
          if is_unreserved(char):
            result.append(char)
          else:
            for byte in char.to_utf8():
              result.append('%')
              result.append(byte.to_hex().pad_start(2, '0').uppercase())
        
        return result.to_string()

    When url.encode_query(params: Map<String, String>) -> String:
      Then:
        return params.entries()
          .map((key, value) -> "${url.encode_component(key)}=${url.encode_component(value)}")
          .join("&")

    When url.decode_query(query: String) -> Map<String, String>:
      Then:
        result = Map()
        
        for pair in query.split("&"):
          if pair.length == 0:
            continue
          
          parts = pair.split("=", 2)
          key = url.decode(parts[0]).unwrap_or(parts[0])
          value = if parts.length > 1 then url.decode(parts[1]).unwrap_or(parts[1]) else ""
          result[key] = value
        
        return result

    When is_url_safe(char: Char) -> Boolean:
      Then:
        return char.is_alphanumeric() or char in "-_.~"

    When is_unreserved(char: Char) -> Boolean:
      Then:
        return char.is_alphanumeric() or char in "-_.~"

  # ==========================================================================
  # HTML ENCODING
  # ==========================================================================

  Behavior HTMLEncoding:
    When html.escape(input: String) -> String:
      Then:
        return input
          .replace("&", "&amp;")
          .replace("<", "&lt;")
          .replace(">", "&gt;")
          .replace('"', "&quot;")
          .replace("'", "&#39;")

    When html.unescape(input: String) -> String:
      Then:
        return input
          .replace("&amp;", "&")
          .replace("&lt;", "<")
          .replace("&gt;", ">")
          .replace("&quot;", '"')
          .replace("&#39;", "'")
          .replace("&nbsp;", " ")
          .replace_regex("&#(\\d+);", (m) -> {
            code = parse_int(m.group(1).unwrap())
            return char_from_code(code)
          })
          .replace_regex("&#x([0-9a-fA-F]+);", (m) -> {
            code = parse_hex(m.group(1).unwrap())
            return char_from_code(code)
          })

    When html.escape_attribute(input: String) -> String:
      Then:
        return html.escape(input)
          .replace("\n", "&#10;")
          .replace("\r", "&#13;")
          .replace("\t", "&#9;")

    When html.strip_tags(input: String) -> String:
      Then:
        return input.replace_regex("<[^>]*>", "")

  # ==========================================================================
  # UNICODE
  # ==========================================================================

  Behavior Unicode:
    When unicode.normalize(input: String, form: NormalizationForm) -> String:
      Then: normalize_unicode(input, form)

    Type NormalizationForm:
      variants:
        - NFC   # Canonical Decomposition, followed by Canonical Composition
        - NFD   # Canonical Decomposition
        - NFKC  # Compatibility Decomposition, followed by Canonical Composition
        - NFKD  # Compatibility Decomposition

    When unicode.is_valid_utf8(data: Bytes) -> Boolean:
      Then: validate_utf8(data)

    When unicode.to_utf8(input: String) -> Bytes:
      Then: encode_utf8(input)

    When unicode.from_utf8(data: Bytes) -> Result<String, DecodeError>:
      Then: decode_utf8(data)

    When unicode.to_utf16(input: String) -> Bytes:
      Then: encode_utf16(input)

    When unicode.from_utf16(data: Bytes) -> Result<String, DecodeError>:
      Then: decode_utf16(data)

    When unicode.code_points(input: String) -> List<Int>:
      Then:
        result = []
        for char in input:
          result.push(char.code_point())
        return result

    When unicode.from_code_points(points: List<Int>) -> String:
      Then:
        return points.map(p -> char_from_code(p)).join("")

    When unicode.escape(input: String) -> String:
      Then:
        result = StringBuilder()
        for char in input:
          cp = char.code_point()
          if cp < 128 and char.is_printable():
            result.append(char)
          else if cp <= 0xFFFF:
            result.append("\\u${cp.to_hex().pad_start(4, '0')}")
          else:
            result.append("\\U${cp.to_hex().pad_start(8, '0')}")
        return result.to_string()

    When unicode.unescape(input: String) -> String:
      Then:
        return input
          .replace_regex("\\\\u([0-9a-fA-F]{4})", (m) -> {
            char_from_code(parse_hex(m.group(1).unwrap()))
          })
          .replace_regex("\\\\U([0-9a-fA-F]{8})", (m) -> {
            char_from_code(parse_hex(m.group(1).unwrap()))
          })

  # ==========================================================================
  # PUNYCODE (IDN)
  # ==========================================================================

  Behavior Punycode:
    When punycode.encode(input: String) -> String:
      Then: encode_punycode(input)

    When punycode.decode(input: String) -> Result<String, DecodeError>:
      Then: decode_punycode(input)

    When punycode.to_ascii(domain: String) -> String:
      Then:
        return domain.split(".")
          .map(label -> {
            if label.all(c -> c.is_ascii()):
              label
            else:
              "xn--${punycode.encode(label)}"
          })
          .join(".")

    When punycode.to_unicode(domain: String) -> String:
      Then:
        return domain.split(".")
          .map(label -> {
            if label.starts_with("xn--"):
              punycode.decode(label.slice(4)).unwrap_or(label)
            else:
              label
          })
          .join(".")

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Encoding":
    ```vibee
    # Base64
    data = "Hello, World!".to_bytes()
    encoded = base64.encode(data)  # "SGVsbG8sIFdvcmxkIQ=="
    decoded = base64.decode(encoded)?  # "Hello, World!"

    # URL-safe Base64
    encoded = base64.encode_url_safe(data)  # No + or /

    # Hex
    hex_str = hex.encode(data)  # "48656c6c6f2c20576f726c6421"
    decoded = hex.decode(hex_str)?

    # Shorthand
    hex_str = data.to_hex()
    b64_str = data.to_base64()

    # URL encoding
    url_encoded = url.encode("Hello World!")  # "Hello%20World%21"
    decoded = url.decode(url_encoded)?

    # Query string
    params = { "name": "John Doe", "city": "New York" }
    query = url.encode_query(params)  # "name=John%20Doe&city=New%20York"
    
    parsed = url.decode_query(query)
    # { "name": "John Doe", "city": "New York" }

    # HTML escaping
    safe = html.escape("<script>alert('XSS')</script>")
    # "&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;"

    original = html.unescape(safe)

    # Strip HTML tags
    text = html.strip_tags("<p>Hello <b>World</b></p>")  # "Hello World"

    # Base62 (for short URLs)
    id = 123456789
    short = base62.encode_int(id)  # "8M0kX"
    original_id = base62.decode_int(short)?  # 123456789

    # Unicode
    normalized = unicode.normalize("café", NFC)
    code_points = unicode.code_points("Hello")  # [72, 101, 108, 108, 111]

    # Punycode (internationalized domain names)
    ascii_domain = punycode.to_ascii("münchen.de")  # "xn--mnchen-3ya.de"
    unicode_domain = punycode.to_unicode("xn--mnchen-3ya.de")  # "münchen.de"

    # Number conversions
    n = 255
    hex = n.to_hex()  # "ff"
    base36 = n.to_base36()  # "73"
    ```
