# ============================================================================
# POOL - Пулы ресурсов на Vibee
# ============================================================================
# Object Pool, Connection Pool, Thread Pool, Worker Pool
# ============================================================================

Specification Pool:
  """Пулы как спецификация переиспользования ресурсов."""

  # ==========================================================================
  # GENERIC OBJECT POOL
  # ==========================================================================

  Type ObjectPool<T>:
    factory: () -> T
    reset: Option<(T) -> ()>
    validate: Option<(T) -> Boolean>
    available: List<PooledObject<T>>
    in_use: Set<PooledObject<T>>
    config: PoolConfig
    stats: PoolStats
    mutex: Mutex<()>
    available_cond: Condvar

    Static Method new(factory: () -> T) -> ObjectPool<T>:
      return ObjectPool.with_config(factory, PoolConfig.default())

    Static Method with_config(factory: () -> T, config: PoolConfig) -> ObjectPool<T>:
      pool = ObjectPool(
        factory: factory,
        reset: null,
        validate: null,
        available: [],
        in_use: Set(),
        config: config,
        stats: PoolStats.new(),
        mutex: Mutex.new(()),
        available_cond: Condvar.new()
      )
      
      # Pre-create minimum objects
      for _ in 0..config.min_size:
        obj = pool.create_object()
        pool.available.push(obj)
      
      return pool

    Method with_reset(reset: (T) -> ()) -> ObjectPool<T>:
      self.reset = Some(reset)
      return self

    Method with_validate(validate: (T) -> Boolean) -> ObjectPool<T>:
      self.validate = Some(validate)
      return self

    Method acquire() -> PooledObject<T>:
      guard = self.mutex.lock()
      
      while self.available.is_empty() and self.total_count() >= self.config.max_size:
        if self.config.block_when_exhausted:
          guard = self.available_cond.wait(guard)
        else:
          panic("Pool exhausted")
      
      obj = if self.available.length > 0:
        self.available.pop()
      else:
        self.create_object()
      
      # Validate object
      if self.validate is Some(v):
        if not v(obj.value):
          # Object invalid, create new one
          self.stats.invalidated.fetch_add(1)
          obj = self.create_object()
      
      obj.acquired_at = Some(Instant.now())
      self.in_use.add(obj)
      self.stats.acquired.fetch_add(1)
      
      return obj

    Method try_acquire() -> Option<PooledObject<T>>:
      guard = self.mutex.lock()
      
      if self.available.is_empty() and self.total_count() >= self.config.max_size:
        return null
      
      obj = if self.available.length > 0:
        self.available.pop()
      else:
        self.create_object()
      
      obj.acquired_at = Some(Instant.now())
      self.in_use.add(obj)
      self.stats.acquired.fetch_add(1)
      
      return Some(obj)

    Method try_acquire_timeout(timeout: Duration) -> Option<PooledObject<T>>:
      deadline = Instant.now() + timeout
      guard = self.mutex.lock()
      
      while self.available.is_empty() and self.total_count() >= self.config.max_size:
        remaining = deadline - Instant.now()
        if remaining.is_negative():
          return null
        
        (guard, timed_out) = self.available_cond.wait_timeout(guard, remaining)
        if timed_out:
          return null
      
      obj = if self.available.length > 0:
        self.available.pop()
      else:
        self.create_object()
      
      obj.acquired_at = Some(Instant.now())
      self.in_use.add(obj)
      self.stats.acquired.fetch_add(1)
      
      return Some(obj)

    Method release(obj: PooledObject<T>):
      guard = self.mutex.lock()
      
      self.in_use.remove(obj)
      
      # Check if object is still valid
      should_return = true
      
      if self.validate is Some(v):
        if not v(obj.value):
          should_return = false
          self.stats.invalidated.fetch_add(1)
      
      # Check max idle time
      if obj.created_at + self.config.max_idle_time < Instant.now():
        should_return = false
      
      if should_return and self.available.length < self.config.max_size:
        # Reset object
        if self.reset is Some(r):
          r(obj.value)
        
        obj.acquired_at = null
        self.available.push(obj)
        self.stats.returned.fetch_add(1)
        self.available_cond.notify_one()
      else:
        self.stats.destroyed.fetch_add(1)

    Method create_object() -> PooledObject<T>:
      value = self.factory()
      self.stats.created.fetch_add(1)
      return PooledObject(
        value: value,
        pool: self,
        created_at: Instant.now(),
        acquired_at: null
      )

    Method total_count() -> Int:
      return self.available.length + self.in_use.length

    Method available_count() -> Int:
      return self.available.length

    Method in_use_count() -> Int:
      return self.in_use.length

    Method stats() -> PoolStats:
      return self.stats

    Method clear():
      guard = self.mutex.lock()
      self.available.clear()
      self.in_use.clear()

    Method with<R>(f: (T) -> R) -> R:
      obj = self.acquire()
      try:
        return f(obj.value)
      finally:
        self.release(obj)

    Method with_async<R>(f: (T) -> Promise<R>) -> Promise<R>:
      obj = self.acquire()
      return f(obj.value).finally(() -> self.release(obj))

  Type PooledObject<T>:
    value: T
    pool: ObjectPool<T>
    created_at: Instant
    acquired_at: Option<Instant>

    Method get() -> T:
      return self.value

    Method release():
      self.pool.release(self)

    Method drop():
      self.release()

  Type PoolConfig:
    min_size: Int
    max_size: Int
    max_idle_time: Duration
    block_when_exhausted: Boolean
    test_on_acquire: Boolean
    test_on_return: Boolean

    Static Method default() -> PoolConfig:
      return PoolConfig(
        min_size: 0,
        max_size: 10,
        max_idle_time: Duration.minutes(30),
        block_when_exhausted: true,
        test_on_acquire: false,
        test_on_return: false
      )

  Type PoolStats:
    created: Atomic<Int>
    destroyed: Atomic<Int>
    acquired: Atomic<Int>
    returned: Atomic<Int>
    invalidated: Atomic<Int>

    Static Method new() -> PoolStats:
      return PoolStats(
        Atomic(0),
        Atomic(0),
        Atomic(0),
        Atomic(0),
        Atomic(0)
      )

  # ==========================================================================
  # CONNECTION POOL
  # ==========================================================================

  Type ConnectionPool<C>:
    pool: ObjectPool<C>
    health_check: Option<(C) -> Boolean>
    on_connect: Option<(C) -> ()>

    Static Method new(factory: () -> C, config: ConnectionPoolConfig) -> ConnectionPool<C>:
      pool_config = PoolConfig(
        min_size: config.min_connections,
        max_size: config.max_connections,
        max_idle_time: config.idle_timeout,
        block_when_exhausted: true,
        test_on_acquire: config.test_on_checkout,
        test_on_return: false
      )
      
      return ConnectionPool(
        pool: ObjectPool.with_config(factory, pool_config),
        health_check: null,
        on_connect: null
      )

    Method with_health_check(check: (C) -> Boolean) -> ConnectionPool<C>:
      self.health_check = Some(check)
      self.pool.validate = Some(check)
      return self

    Method with_on_connect(callback: (C) -> ()) -> ConnectionPool<C>:
      self.on_connect = Some(callback)
      return self

    Method get() -> PooledConnection<C>:
      obj = self.pool.acquire()
      return PooledConnection(obj)

    Method try_get() -> Option<PooledConnection<C>>:
      obj = self.pool.try_acquire()?
      return Some(PooledConnection(obj))

    Method try_get_timeout(timeout: Duration) -> Option<PooledConnection<C>>:
      obj = self.pool.try_acquire_timeout(timeout)?
      return Some(PooledConnection(obj))

    Method execute<R>(f: (C) -> R) -> R:
      return self.pool.with(f)

    Method execute_async<R>(f: (C) -> Promise<R>) -> Promise<R>:
      return self.pool.with_async(f)

    Method stats() -> PoolStats:
      return self.pool.stats()

    Method close():
      self.pool.clear()

  Type PooledConnection<C>:
    inner: PooledObject<C>

    Method get() -> C:
      return self.inner.value

    Method release():
      self.inner.release()

    Method drop():
      self.release()

  Type ConnectionPoolConfig:
    min_connections: Int
    max_connections: Int
    idle_timeout: Duration
    connection_timeout: Duration
    test_on_checkout: Boolean

    Static Method default() -> ConnectionPoolConfig:
      return ConnectionPoolConfig(
        min_connections: 1,
        max_connections: 10,
        idle_timeout: Duration.minutes(10),
        connection_timeout: Duration.seconds(30),
        test_on_checkout: true
      )

  # ==========================================================================
  # THREAD POOL
  # ==========================================================================

  Type ThreadPool:
    workers: List<Worker>
    task_queue: Channel<Task>
    shutdown: Atomic<Boolean>
    config: ThreadPoolConfig

    Static Method new(size: Int) -> ThreadPool:
      return ThreadPool.with_config(ThreadPoolConfig(
        core_size: size,
        max_size: size,
        keep_alive: Duration.seconds(60),
        queue_capacity: 1000
      ))

    Static Method with_config(config: ThreadPoolConfig) -> ThreadPool:
      pool = ThreadPool(
        workers: [],
        task_queue: Channel.bounded(config.queue_capacity),
        shutdown: Atomic(false),
        config: config
      )
      
      for i in 0..config.core_size:
        pool.spawn_worker(i)
      
      return pool

    Method spawn_worker(id: Int):
      worker = Worker(
        id: id,
        thread: spawn {
          self.worker_loop()
        }
      )
      self.workers.push(worker)

    Method worker_loop():
      while not self.shutdown.load():
        task = self.task_queue.recv_timeout(self.config.keep_alive)
        
        match task:
          Some(t) -> t.run()
          null -> 
            # Check if we should exit (non-core worker)
            if self.workers.length > self.config.core_size:
              break

    Method submit<T>(f: () -> T) -> Future<T>:
      future = Future.new()
      
      task = Task(() -> {
        try:
          result = f()
          future.complete(Ok(result))
        catch error:
          future.complete(Err(error))
      })
      
      self.task_queue.send(task)
      return future

    Method execute(f: () -> ()):
      task = Task(f)
      self.task_queue.send(task)

    Method schedule(delay: Duration, f: () -> ()):
      spawn {
        sleep(delay)
        self.execute(f)
      }

    Method schedule_at_fixed_rate(initial_delay: Duration, period: Duration, f: () -> ()):
      spawn {
        sleep(initial_delay)
        while not self.shutdown.load():
          start = Instant.now()
          self.execute(f)
          elapsed = Instant.now() - start
          sleep(max(Duration.zero(), period - elapsed))
      }

    Method shutdown():
      self.shutdown.store(true)
      self.task_queue.close()

    Method shutdown_now():
      self.shutdown.store(true)
      self.task_queue.close()
      
      for worker in self.workers:
        worker.thread.cancel()

    Method await_termination(timeout: Duration) -> Boolean:
      deadline = Instant.now() + timeout
      
      for worker in self.workers:
        remaining = deadline - Instant.now()
        if remaining.is_negative():
          return false
        
        if not worker.thread.join_timeout(remaining):
          return false
      
      return true

    Method active_count() -> Int:
      return self.workers.length

    Method queue_size() -> Int:
      return self.task_queue.len()

  Type Worker:
    id: Int
    thread: Task

  Type Task:
    run: () -> ()

  Type ThreadPoolConfig:
    core_size: Int
    max_size: Int
    keep_alive: Duration
    queue_capacity: Int

  # ==========================================================================
  # WORKER POOL
  # ==========================================================================

  Type WorkerPool<T, R>:
    workers: Int
    input_channel: Channel<T>
    output_channel: Channel<(T, Result<R, Error>)>
    processor: (T) -> R
    tasks: List<Task>
    shutdown: Atomic<Boolean>

    Static Method new(workers: Int, processor: (T) -> R) -> WorkerPool<T, R>:
      pool = WorkerPool(
        workers: workers,
        input_channel: Channel.bounded(workers * 2),
        output_channel: Channel.unbounded(),
        processor: processor,
        tasks: [],
        shutdown: Atomic(false)
      )
      
      for _ in 0..workers:
        pool.spawn_worker()
      
      return pool

    Method spawn_worker():
      task = spawn {
        while not self.shutdown.load():
          item = self.input_channel.recv()
          
          if item == null:
            break
          
          result = try:
            Ok(self.processor(item))
          catch error:
            Err(error)
          
          self.output_channel.send((item, result))
      }
      self.tasks.push(task)

    Method submit(item: T):
      self.input_channel.send(item)

    Method submit_batch(items: List<T>):
      for item in items:
        self.submit(item)

    Method results() -> Channel<(T, Result<R, Error>)>:
      return self.output_channel

    Method process_all(items: List<T>) -> List<(T, Result<R, Error>)>:
      for item in items:
        self.submit(item)
      
      results = []
      for _ in 0..items.length:
        result = self.output_channel.recv()
        results.push(result)
      
      return results

    Method map(items: List<T>) -> List<R>:
      results = self.process_all(items)
      return results.map((_, r) -> r.unwrap())

    Method shutdown():
      self.shutdown.store(true)
      self.input_channel.close()

    Method await_completion():
      for task in self.tasks:
        task.join()

  # ==========================================================================
  # BUFFER POOL
  # ==========================================================================

  Type BufferPool:
    pools: Map<Int, ObjectPool<Bytes>>
    sizes: List<Int>

    Static Method new() -> BufferPool:
      return BufferPool.with_sizes([64, 256, 1024, 4096, 16384, 65536])

    Static Method with_sizes(sizes: List<Int>) -> BufferPool:
      pools = {}
      
      for size in sizes:
        pools[size] = ObjectPool.new(() -> Bytes(size))
          .with_reset(buf -> buf.clear())
      
      return BufferPool(pools, sizes.sorted())

    Method acquire(min_size: Int) -> PooledBuffer:
      # Find smallest buffer that fits
      for size in self.sizes:
        if size >= min_size:
          obj = self.pools[size].acquire()
          return PooledBuffer(obj, size)
      
      # Allocate custom size
      return PooledBuffer(null, Bytes(min_size))

    Method release(buffer: PooledBuffer):
      if buffer.pooled is Some(obj):
        obj.release()

  Type PooledBuffer:
    pooled: Option<PooledObject<Bytes>>
    buffer: Bytes
    size: Int

    Method get() -> Bytes:
      if self.pooled is Some(obj):
        return obj.value
      return self.buffer

    Method release():
      if self.pooled is Some(obj):
        obj.release()

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Pool":
    ```vibee
    # Object Pool
    pool = ObjectPool.new(() -> ExpensiveObject.create())
      .with_reset(obj -> obj.reset())
      .with_validate(obj -> obj.is_valid())

    # Acquire and release
    obj = pool.acquire()
    obj.get().do_work()
    obj.release()

    # With helper (auto-release)
    result = pool.with(obj -> {
      obj.process(data)
    })

    # Try acquire with timeout
    if pool.try_acquire_timeout(Duration.seconds(5)) is Some(obj):
      obj.get().do_work()
      obj.release()
    else:
      print("Pool exhausted")

    # Pool stats
    stats = pool.stats()
    print("Created: ${stats.created.load()}")
    print("In use: ${pool.in_use_count()}")
    print("Available: ${pool.available_count()}")

    # Connection Pool
    db_pool = ConnectionPool.new(
      () -> Database.connect("postgres://localhost/mydb"),
      ConnectionPoolConfig(
        min_connections: 5,
        max_connections: 20,
        idle_timeout: Duration.minutes(10),
        connection_timeout: Duration.seconds(30),
        test_on_checkout: true
      )
    ).with_health_check(conn -> conn.ping())

    # Get connection
    conn = db_pool.get()
    result = conn.get().query("SELECT * FROM users")
    conn.release()

    # Execute with auto-release
    users = db_pool.execute(conn -> {
      conn.query("SELECT * FROM users")
    })

    # Async
    users = await db_pool.execute_async(async conn -> {
      await conn.query_async("SELECT * FROM users")
    })

    # Thread Pool
    executor = ThreadPool.new(4)

    # Submit task
    future = executor.submit(() -> {
      expensive_computation()
    })

    result = future.get()

    # Execute without result
    executor.execute(() -> {
      send_email(user)
    })

    # Schedule
    executor.schedule(Duration.seconds(10), () -> {
      cleanup()
    })

    # Fixed rate
    executor.schedule_at_fixed_rate(
      Duration.zero(),
      Duration.minutes(1),
      () -> collect_metrics()
    )

    # Shutdown
    executor.shutdown()
    executor.await_termination(Duration.seconds(30))

    # Worker Pool
    processor = WorkerPool.new(8, (url: String) -> {
      http.get(url).send()
    })

    # Submit work
    urls = ["http://a.com", "http://b.com", "http://c.com"]
    
    for url in urls:
      processor.submit(url)

    # Collect results
    for (url, result) in processor.results():
      match result:
        Ok(response) -> print("${url}: ${response.status}")
        Err(error) -> print("${url}: failed - ${error}")

    # Or process all at once
    results = processor.process_all(urls)

    # Map (like parallel map)
    responses = processor.map(urls)

    # Buffer Pool
    buffers = BufferPool.new()

    buf = buffers.acquire(1000)  # Gets 1024-byte buffer
    buf.get().write(data)
    buf.release()

    # Custom pool config
    pool = ObjectPool.with_config(
      () -> create_resource(),
      PoolConfig(
        min_size: 5,
        max_size: 50,
        max_idle_time: Duration.minutes(5),
        block_when_exhausted: true,
        test_on_acquire: true,
        test_on_return: false
      )
    )
    ```
