# ============================================================================
# LOGGING - Логирование и трейсинг на Vibee
# ============================================================================
# Structured logging, Log levels, Handlers, Tracing
# ============================================================================

Specification Logging:
  """Логирование как спецификация записи событий системы."""

  # ==========================================================================
  # LOG LEVELS
  # ==========================================================================

  Type LogLevel:
    variants:
      - Trace
      - Debug
      - Info
      - Warn
      - Error
      - Fatal

    Method priority() -> Int:
      match self:
        Trace -> 0
        Debug -> 1
        Info -> 2
        Warn -> 3
        Error -> 4
        Fatal -> 5

    Method to_string() -> String:
      match self:
        Trace -> "TRACE"
        Debug -> "DEBUG"
        Info -> "INFO"
        Warn -> "WARN"
        Error -> "ERROR"
        Fatal -> "FATAL"

    Method color() -> String:
      match self:
        Trace -> "\x1b[90m"    # Gray
        Debug -> "\x1b[36m"    # Cyan
        Info -> "\x1b[32m"     # Green
        Warn -> "\x1b[33m"     # Yellow
        Error -> "\x1b[31m"    # Red
        Fatal -> "\x1b[35m"    # Magenta

    Method >= (other: LogLevel) -> Boolean:
      return self.priority() >= other.priority()

  # ==========================================================================
  # LOG RECORD
  # ==========================================================================

  Type LogRecord:
    level: LogLevel
    message: String
    timestamp: Instant
    target: String
    module_path: Option<String>
    file: Option<String>
    line: Option<Int>
    fields: Map<String, Any>
    span_id: Option<SpanId>
    trace_id: Option<TraceId>

    Static Method new(level: LogLevel, message: String) -> LogRecord:
      return LogRecord(
        level: level,
        message: message,
        timestamp: Instant.now(),
        target: "",
        module_path: null,
        file: null,
        line: null,
        fields: {},
        span_id: null,
        trace_id: null
      )

    Method with_target(target: String) -> LogRecord:
      return LogRecord(..self, target: target)

    Method with_field(key: String, value: Any) -> LogRecord:
      return LogRecord(..self, fields: self.fields.set(key, value))

    Method with_fields(fields: Map<String, Any>) -> LogRecord:
      return LogRecord(..self, fields: self.fields.merge(fields))

    Method with_location(file: String, line: Int) -> LogRecord:
      return LogRecord(..self, file: Some(file), line: Some(line))

  # ==========================================================================
  # LOGGER
  # ==========================================================================

  Type Logger:
    name: String
    level: LogLevel
    handlers: List<Handler>
    parent: Option<Logger>

    Static Method root() -> Logger:
      return GLOBAL_LOGGER

    Static Method get(name: String) -> Logger:
      return get_or_create_logger(name)

    Method trace(message: String):
      self.log(LogLevel.Trace, message)

    Method debug(message: String):
      self.log(LogLevel.Debug, message)

    Method info(message: String):
      self.log(LogLevel.Info, message)

    Method warn(message: String):
      self.log(LogLevel.Warn, message)

    Method error(message: String):
      self.log(LogLevel.Error, message)

    Method fatal(message: String):
      self.log(LogLevel.Fatal, message)

    Method log(level: LogLevel, message: String):
      if level >= self.effective_level():
        record = LogRecord.new(level, message)
          .with_target(self.name)
        self.emit(record)

    Method log_with(level: LogLevel, message: String, fields: Map<String, Any>):
      if level >= self.effective_level():
        record = LogRecord.new(level, message)
          .with_target(self.name)
          .with_fields(fields)
        self.emit(record)

    Method effective_level() -> LogLevel:
      if self.level != null:
        return self.level
      if self.parent is Some(p):
        return p.effective_level()
      return LogLevel.Info

    Method emit(record: LogRecord):
      for handler in self.handlers:
        handler.handle(record)
      
      if self.parent is Some(p):
        p.emit(record)

    Method set_level(level: LogLevel) -> Logger:
      return Logger(..self, level: level)

    Method add_handler(handler: Handler) -> Logger:
      return Logger(..self, handlers: self.handlers + [handler])

    Method child(name: String) -> Logger:
      child_name = if self.name.is_empty() then name else "${self.name}.${name}"
      return Logger(
        name: child_name,
        level: null,
        handlers: [],
        parent: Some(self)
      )

  # ==========================================================================
  # GLOBAL LOGGING FUNCTIONS
  # ==========================================================================

  Behavior GlobalLogging:
    When trace(message: String):
      Then: Logger.root().trace(message)

    When debug(message: String):
      Then: Logger.root().debug(message)

    When info(message: String):
      Then: Logger.root().info(message)

    When warn(message: String):
      Then: Logger.root().warn(message)

    When error(message: String):
      Then: Logger.root().error(message)

    When fatal(message: String):
      Then: Logger.root().fatal(message)

    When log(level: LogLevel, message: String):
      Then: Logger.root().log(level, message)

    When log_with(level: LogLevel, message: String, fields: Map<String, Any>):
      Then: Logger.root().log_with(level, message, fields)

  # ==========================================================================
  # HANDLERS
  # ==========================================================================

  Trait Handler:
    Method handle(record: LogRecord)
    Method flush()

  Type ConsoleHandler:
    level: LogLevel
    formatter: Formatter
    colored: Boolean

    Static Method new() -> ConsoleHandler:
      return ConsoleHandler(
        level: LogLevel.Trace,
        formatter: DefaultFormatter(),
        colored: true
      )

    Static Method stderr() -> ConsoleHandler:
      return ConsoleHandler(
        level: LogLevel.Warn,
        formatter: DefaultFormatter(),
        colored: true
      )

    Trait Handler:
      Method handle(record: LogRecord):
        if record.level >= self.level:
          output = self.formatter.format(record, self.colored)
          
          if record.level >= LogLevel.Warn:
            stderr.write_line(output)
          else:
            stdout.write_line(output)

      Method flush():
        stdout.flush()
        stderr.flush()

  Type FileHandler:
    path: Path
    level: LogLevel
    formatter: Formatter
    file: File
    max_size: Option<Int>
    backup_count: Int

    Static Method new(path: Path) -> FileHandler:
      return FileHandler(
        path: path,
        level: LogLevel.Trace,
        formatter: JsonFormatter(),
        file: File.open_append(path),
        max_size: null,
        backup_count: 5
      )

    Static Method rotating(path: Path, max_size: Int) -> FileHandler:
      return FileHandler(
        path: path,
        level: LogLevel.Trace,
        formatter: JsonFormatter(),
        file: File.open_append(path),
        max_size: Some(max_size),
        backup_count: 5
      )

    Trait Handler:
      Method handle(record: LogRecord):
        if record.level >= self.level:
          self.maybe_rotate()
          output = self.formatter.format(record, false)
          self.file.write_line(output)

      Method flush():
        self.file.flush()

    Method maybe_rotate():
      if self.max_size is Some(max):
        if self.file.size() >= max:
          self.rotate()

    Method rotate():
      self.file.close()
      
      # Rotate existing backups
      for i in (self.backup_count - 1)..0 by -1:
        old_path = Path("${self.path}.${i}")
        new_path = Path("${self.path}.${i + 1}")
        if old_path.exists():
          if i + 1 >= self.backup_count:
            old_path.delete()
          else:
            old_path.rename(new_path)
      
      # Rename current to .1
      self.path.rename(Path("${self.path}.1"))
      
      # Open new file
      self.file = File.open_append(self.path)

  Type AsyncHandler:
    inner: Handler
    queue: Channel<LogRecord>
    worker: Task

    Static Method new(handler: Handler) -> AsyncHandler:
      queue = Channel.bounded(1000)
      
      worker = spawn {
        for record in queue:
          handler.handle(record)
      }
      
      return AsyncHandler(inner: handler, queue: queue, worker: worker)

    Trait Handler:
      Method handle(record: LogRecord):
        self.queue.try_send(record)

      Method flush():
        # Wait for queue to drain
        while not self.queue.is_empty():
          sleep(Duration.millis(10))
        self.inner.flush()

  Type FilterHandler:
    inner: Handler
    filter: (LogRecord) -> Boolean

    Trait Handler:
      Method handle(record: LogRecord):
        if self.filter(record):
          self.inner.handle(record)

      Method flush():
        self.inner.flush()

  # ==========================================================================
  # FORMATTERS
  # ==========================================================================

  Trait Formatter:
    Method format(record: LogRecord, colored: Boolean) -> String

  Type DefaultFormatter:
    Trait Formatter:
      Method format(record: LogRecord, colored: Boolean) -> String:
        timestamp = record.timestamp.format("%Y-%m-%d %H:%M:%S%.3f")
        level = record.level.to_string().pad_end(5)
        
        if colored:
          color = record.level.color()
          reset = "\x1b[0m"
          return "${timestamp} ${color}${level}${reset} ${record.target}: ${record.message}"
        else:
          return "${timestamp} ${level} ${record.target}: ${record.message}"

  Type JsonFormatter:
    Trait Formatter:
      Method format(record: LogRecord, colored: Boolean) -> String:
        obj = {
          "timestamp": record.timestamp.to_iso8601(),
          "level": record.level.to_string(),
          "target": record.target,
          "message": record.message
        }
        
        if record.fields.length > 0:
          obj["fields"] = record.fields
        
        if record.trace_id is Some(tid):
          obj["trace_id"] = tid.to_string()
        
        if record.span_id is Some(sid):
          obj["span_id"] = sid.to_string()
        
        if record.file is Some(f):
          obj["file"] = f
          obj["line"] = record.line
        
        return json.encode(obj)

  Type PrettyFormatter:
    Trait Formatter:
      Method format(record: LogRecord, colored: Boolean) -> String:
        timestamp = record.timestamp.format("%H:%M:%S%.3f")
        level = record.level.to_string()
        
        lines = StringBuilder()
        
        if colored:
          color = record.level.color()
          reset = "\x1b[0m"
          lines.append("${color}${level}${reset} ")
        else:
          lines.append("${level} ")
        
        lines.append("[${timestamp}] ")
        
        if not record.target.is_empty():
          lines.append("${record.target}: ")
        
        lines.append(record.message)
        
        if record.fields.length > 0:
          for (key, value) in record.fields:
            lines.append("\n    ${key}=${value}")
        
        return lines.to_string()

  # ==========================================================================
  # TRACING
  # ==========================================================================

  Type TraceId:
    bytes: Bytes  # 16 bytes

    Static Method new() -> TraceId:
      return TraceId(random.bytes(16))

    Method to_string() -> String:
      return self.bytes.to_hex()

    Static Method from_string(s: String) -> Result<TraceId, ParseError>:
      bytes = hex.decode(s)?
      if bytes.length != 16:
        return Err(ParseError("Invalid trace ID length"))
      return Ok(TraceId(bytes))

  Type SpanId:
    bytes: Bytes  # 8 bytes

    Static Method new() -> SpanId:
      return SpanId(random.bytes(8))

    Method to_string() -> String:
      return self.bytes.to_hex()

  Type Span:
    name: String
    trace_id: TraceId
    span_id: SpanId
    parent_id: Option<SpanId>
    start_time: Instant
    end_time: Option<Instant>
    attributes: Map<String, Any>
    events: List<SpanEvent>
    status: SpanStatus

    Static Method new(name: String) -> Span:
      current = Span.current()
      
      return Span(
        name: name,
        trace_id: current?.trace_id ?? TraceId.new(),
        span_id: SpanId.new(),
        parent_id: current?.span_id,
        start_time: Instant.now(),
        end_time: null,
        attributes: {},
        events: [],
        status: SpanStatus.Unset
      )

    Static Method current() -> Option<Span>:
      return CURRENT_SPAN.get()

    Method enter() -> SpanGuard:
      old = CURRENT_SPAN.get()
      CURRENT_SPAN.set(Some(self))
      return SpanGuard(old)

    Method set_attribute(key: String, value: Any) -> Span:
      return Span(..self, attributes: self.attributes.set(key, value))

    Method add_event(name: String):
      event = SpanEvent(name: name, timestamp: Instant.now(), attributes: {})
      self.events.push(event)

    Method add_event_with(name: String, attributes: Map<String, Any>):
      event = SpanEvent(name: name, timestamp: Instant.now(), attributes: attributes)
      self.events.push(event)

    Method set_status(status: SpanStatus):
      self.status = status

    Method set_error(error: Error):
      self.status = SpanStatus.Error(error.message())
      self.set_attribute("error.type", error.type_name())
      self.set_attribute("error.message", error.message())

    Method end():
      self.end_time = Some(Instant.now())
      export_span(self)

  Type SpanGuard:
    previous: Option<Span>

    Method drop():
      CURRENT_SPAN.set(self.previous)

  Type SpanEvent:
    name: String
    timestamp: Instant
    attributes: Map<String, Any>

  Type SpanStatus:
    variants:
      - Unset
      - Ok
      - Error(String)

  # ==========================================================================
  # TRACING MACROS
  # ==========================================================================

  Behavior TracingMacros:
    When @trace(name: String):
      Then:
        # Decorator that wraps function in a span
        span = Span.new(name)
        guard = span.enter()
        
        try:
          result = original_function()
          span.set_status(SpanStatus.Ok)
          return result
        catch error:
          span.set_error(error)
          throw error
        finally:
          span.end()

    When instrument<T>(name: String, f: () -> T) -> T:
      Then:
        span = Span.new(name)
        guard = span.enter()
        
        try:
          result = f()
          span.set_status(SpanStatus.Ok)
          return result
        catch error:
          span.set_error(error)
          throw error
        finally:
          span.end()

  # ==========================================================================
  # SPAN EXPORTERS
  # ==========================================================================

  Trait SpanExporter:
    Method export(spans: List<Span>)
    Method shutdown()

  Type ConsoleSpanExporter:
    Trait SpanExporter:
      Method export(spans: List<Span>):
        for span in spans:
          duration = span.end_time.map(e -> e - span.start_time).unwrap_or(Duration.zero())
          print("[SPAN] ${span.name} (${duration.as_millis()}ms) trace=${span.trace_id}")

      Method shutdown():
        pass

  Type OTLPSpanExporter:
    endpoint: String
    headers: Map<String, String>

    Static Method new(endpoint: String) -> OTLPSpanExporter:
      return OTLPSpanExporter(endpoint, {})

    Trait SpanExporter:
      Method export(spans: List<Span>):
        # Convert to OTLP format and send
        payload = convert_to_otlp(spans)
        http.post(self.endpoint)
          .headers(self.headers)
          .json(payload)
          .send()

      Method shutdown():
        pass

  # ==========================================================================
  # CONTEXT PROPAGATION
  # ==========================================================================

  Behavior ContextPropagation:
    When inject_context(headers: Map<String, String>) -> Map<String, String>:
      Then:
        span = Span.current()
        if span is Some(s):
          # W3C Trace Context format
          traceparent = "00-${s.trace_id}-${s.span_id}-01"
          return headers.set("traceparent", traceparent)
        return headers

    When extract_context(headers: Map<String, String>) -> Option<(TraceId, SpanId)>:
      Then:
        traceparent = headers.get("traceparent")?
        parts = traceparent.split("-")
        
        if parts.length != 4:
          return null
        
        trace_id = TraceId.from_string(parts[1]).ok()?
        span_id = SpanId.from_string(parts[2]).ok()?
        
        return Some((trace_id, span_id))

  # ==========================================================================
  # CONFIGURATION
  # ==========================================================================

  Behavior LoggingConfig:
    When configure_logging(config: LogConfig):
      Then:
        root = Logger.root()
        root.level = config.level
        root.handlers = []
        
        if config.console:
          root.handlers.push(ConsoleHandler.new())
        
        if config.file is Some(path):
          root.handlers.push(FileHandler.new(path))
        
        if config.json:
          for handler in root.handlers:
            handler.formatter = JsonFormatter()

    Type LogConfig:
      level: LogLevel
      console: Boolean
      file: Option<Path>
      json: Boolean

      Static Method default() -> LogConfig:
        return LogConfig(
          level: LogLevel.Info,
          console: true,
          file: null,
          json: false
        )

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Logging":
    ```vibee
    # Basic logging
    info("Application started")
    debug("Processing request")
    warn("Deprecated API used")
    error("Failed to connect to database")

    # With fields
    log_with(LogLevel.Info, "User logged in", {
      "user_id": 123,
      "ip": "192.168.1.1"
    })

    # Named logger
    logger = Logger.get("myapp.auth")
    logger.info("Authentication successful")

    # Child logger
    db_logger = logger.child("database")
    db_logger.debug("Query executed")

    # Configure logging
    configure_logging(LogConfig(
      level: LogLevel.Debug,
      console: true,
      file: Some(Path("app.log")),
      json: false
    ))

    # File handler with rotation
    handler = FileHandler.rotating(Path("app.log"), 10 * 1024 * 1024)  # 10MB
    Logger.root().add_handler(handler)

    # Async handler for performance
    async_handler = AsyncHandler.new(FileHandler.new(Path("app.log")))
    Logger.root().add_handler(async_handler)

    # Tracing
    @trace("process_order")
    fn process_order(order_id: Int) -> Result<Order, Error>:
      span = Span.current().unwrap()
      span.set_attribute("order_id", order_id)
      
      # Nested span
      instrument("validate_order", () -> {
        validate(order_id)
      })
      
      span.add_event("order_validated")
      
      result = instrument("save_order", () -> {
        save_to_database(order_id)
      })
      
      return result

    # Manual span
    span = Span.new("http_request")
    span.set_attribute("http.method", "GET")
    span.set_attribute("http.url", "/api/users")
    
    guard = span.enter()
    # ... do work ...
    span.end()

    # Context propagation
    headers = inject_context({})
    # headers = { "traceparent": "00-abc123...-def456...-01" }

    # Extract on receiving side
    (trace_id, parent_span_id) = extract_context(headers)?
    ```
