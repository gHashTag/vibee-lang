# ============================================================================
# PROCESS MANAGER - Управление процессами на Vibee
# ============================================================================
# Processes, signals, IPC, supervision
# ============================================================================

Specification ProcessManager:
  """Управление процессами как спецификация выполнения."""

  # ==========================================================================
  # PROCESS TYPES
  # ==========================================================================

  Type Process:
    pid: ProcessId
    ppid: ProcessId?
    name: String
    state: ProcessState
    priority: Int
    nice: Int
    user: UserId
    group: GroupId
    cwd: Path
    env: Map<String, String>
    args: List<String>
    stdin: Stream?
    stdout: Stream?
    stderr: Stream?
    exit_code: Int?
    start_time: Timestamp
    cpu_time: Duration
    memory: MemoryUsage
    children: List<ProcessId>
    threads: List<ThreadId>

  Type ProcessId:
    value: Int

  Type ThreadId:
    value: Int

  Type ProcessState:
    variants:
      - Created
      - Ready
      - Running
      - Blocked: BlockReason
      - Sleeping: Duration
      - Stopped
      - Zombie
      - Terminated: Int

  Type BlockReason:
    variants:
      - IO
      - Lock
      - Signal
      - IPC
      - Child

  Type MemoryUsage:
    virtual: ByteSize
    resident: ByteSize
    shared: ByteSize
    heap: ByteSize
    stack: ByteSize

  Type SpawnOptions:
    cwd: Path?
    env: Map<String, String>?
    inherit_env: Boolean = true
    stdin: StdioOption = Inherit
    stdout: StdioOption = Inherit
    stderr: StdioOption = Inherit
    detached: Boolean = false
    uid: UserId?
    gid: GroupId?
    nice: Int = 0

  Type StdioOption:
    variants:
      - Inherit
      - Pipe
      - Null
      - File: Path

  # ==========================================================================
  # SIGNALS
  # ==========================================================================

  Type Signal:
    SIGHUP: 1
    SIGINT: 2
    SIGQUIT: 3
    SIGILL: 4
    SIGTRAP: 5
    SIGABRT: 6
    SIGBUS: 7
    SIGFPE: 8
    SIGKILL: 9
    SIGUSR1: 10
    SIGSEGV: 11
    SIGUSR2: 12
    SIGPIPE: 13
    SIGALRM: 14
    SIGTERM: 15
    SIGCHLD: 17
    SIGCONT: 18
    SIGSTOP: 19
    SIGTSTP: 20
    SIGTTIN: 21
    SIGTTOU: 22

  Type SignalHandler:
    variants:
      - Default
      - Ignore
      - Custom: (Signal) -> Unit

  Type SignalMask:
    blocked: Set<Signal>

  # ==========================================================================
  # IPC TYPES
  # ==========================================================================

  Type IPCChannel:
    variants:
      - Pipe: PipeChannel
      - Socket: SocketChannel
      - SharedMemory: SharedMemoryChannel
      - MessageQueue: MessageQueueChannel
      - Semaphore: SemaphoreChannel

  Type PipeChannel:
    read_fd: Int
    write_fd: Int
    buffer_size: Int

  Type SocketChannel:
    type: SocketType
    path: Path?
    address: (String, Port)?

  Type SocketType:
    variants: [Unix, TCP, UDP]

  Type SharedMemoryChannel:
    name: String
    size: ByteSize
    address: Int

  Type MessageQueueChannel:
    name: String
    max_messages: Int
    max_message_size: ByteSize

  Type SemaphoreChannel:
    name: String
    value: Int

  Type IPCMessage:
    sender: ProcessId
    type: String
    payload: Bytes
    timestamp: Timestamp

  # ==========================================================================
  # PROCESS OPERATIONS
  # ==========================================================================

  Behavior ProcessOperations:
    State:
      processes: Map<ProcessId, Process>
      next_pid: ProcessId = 1
      signal_handlers: Map<Signal, SignalHandler>

    When process.spawn(command, args, options):
      Then:
        - pid = allocate_pid()
        - parent = current_process()
        
        - # Setup environment
        - env = if options.inherit_env then
            merge(parent.env, options.env ?? {})
          else
            options.env ?? {}
        
        - # Setup stdio
        - (stdin, stdout, stderr) = setup_stdio(options)
        
        - # Create process
        - proc = Process(
            pid: pid,
            ppid: parent.pid,
            name: command,
            state: Created,
            priority: 0,
            nice: options.nice,
            user: options.uid ?? parent.user,
            group: options.gid ?? parent.group,
            cwd: options.cwd ?? parent.cwd,
            env: env,
            args: args,
            stdin: stdin,
            stdout: stdout,
            stderr: stderr,
            start_time: now(),
            children: [],
            threads: []
          )
        
        - processes[pid] = proc
        - parent.children.push(pid)
        
        - # Start execution
        - if options.detached:
            - proc.ppid = 1  # Reparent to init
        
        - schedule(proc)
        - emit ProcessSpawned(pid, command)
        
        - return ChildProcess(proc, stdin, stdout, stderr)

    When process.exec(command, options):
      """Execute and wait for completion"""
      Then:
        - child = await process.spawn(command, [], options with { stdout: Pipe, stderr: Pipe })
        - stdout_data = []
        - stderr_data = []
        
        - await parallel(
            child.stdout.read_all().then(d -> stdout_data = d),
            child.stderr.read_all().then(d -> stderr_data = d),
            child.wait()
          )
        
        - return ExecResult(
            exit_code: child.exit_code,
            stdout: stdout_data.join(),
            stderr: stderr_data.join()
          )

    When process.fork():
      """Fork current process"""
      Then:
        - parent = current_process()
        - pid = allocate_pid()
        
        - child = Process(
            pid: pid,
            ppid: parent.pid,
            name: parent.name,
            state: Ready,
            priority: parent.priority,
            nice: parent.nice,
            user: parent.user,
            group: parent.group,
            cwd: parent.cwd,
            env: parent.env.copy(),
            args: parent.args.copy(),
            start_time: now(),
            children: [],
            threads: []
          )
        
        - # Copy memory (copy-on-write)
        - child.memory = copy_on_write(parent.memory)
        
        - processes[pid] = child
        - parent.children.push(pid)
        
        - # Return 0 in child, pid in parent
        - if in_child():
            - return 0
        - else:
            - return pid

    When process.wait(pid):
      """Wait for child process"""
      Then:
        - child = processes[pid]
        - if not child:
            - raise ProcessNotFound(pid)
        - if child.ppid != current_process().pid:
            - raise NotChildProcess(pid)
        
        - while child.state not in [Zombie, Terminated(_)]:
            - await sleep_until_signal(SIGCHLD)
        
        - exit_code = match child.state:
            Terminated(code) -> code
            Zombie -> child.exit_code ?? -1
        
        - # Reap zombie
        - processes.remove(pid)
        - current_process().children.remove(pid)
        
        - return exit_code

    When process.wait_any():
      """Wait for any child"""
      Then:
        - parent = current_process()
        - if parent.children.is_empty():
            - raise NoChildProcesses
        
        - loop:
            - for pid in parent.children:
                - child = processes[pid]
                - if child.state in [Zombie, Terminated(_)]:
                    - return (pid, await process.wait(pid))
            - await sleep_until_signal(SIGCHLD)

    When process.kill(pid, signal):
      Then:
        - proc = processes[pid]
        - if not proc:
            - raise ProcessNotFound(pid)
        
        - # Check permissions
        - if not can_signal(current_process(), proc):
            - raise PermissionDenied
        
        - deliver_signal(proc, signal)

    When process.exit(code):
      Then:
        - proc = current_process()
        - proc.state = Terminated(code)
        - proc.exit_code = code
        
        - # Close file descriptors
        - close_all_fds(proc)
        
        - # Reparent children to init
        - for child_pid in proc.children:
            - child = processes[child_pid]
            - child.ppid = 1
        
        - # Notify parent
        - if proc.ppid:
            - parent = processes[proc.ppid]
            - deliver_signal(parent, SIGCHLD)
        
        - # Become zombie until reaped
        - proc.state = Zombie
        - emit ProcessExited(proc.pid, code)

  # ==========================================================================
  # SIGNAL HANDLING
  # ==========================================================================

  Behavior SignalHandling:
    When signal.handle(sig, handler):
      Then:
        - if sig in [SIGKILL, SIGSTOP]:
            - raise CannotCatchSignal(sig)
        - old_handler = signal_handlers[sig]
        - signal_handlers[sig] = handler
        - return old_handler

    When signal.ignore(sig):
      Then:
        - signal.handle(sig, Ignore)

    When signal.reset(sig):
      Then:
        - signal.handle(sig, Default)

    When signal.mask(signals):
      Then:
        - proc = current_process()
        - proc.signal_mask.blocked.add_all(signals)

    When signal.unmask(signals):
      Then:
        - proc = current_process()
        - proc.signal_mask.blocked.remove_all(signals)
        - # Deliver pending signals
        - for sig in signals:
            - if proc.pending_signals.has(sig):
                - deliver_signal(proc, sig)

    When deliver_signal(proc, sig):
      Then:
        - if proc.signal_mask.blocked.has(sig):
            - proc.pending_signals.add(sig)
            - return
        
        - handler = signal_handlers.get(sig) ?? Default
        
        - match handler:
            Default ->
              match sig:
                SIGTERM | SIGINT | SIGKILL | SIGQUIT ->
                  process.exit(128 + sig)
                SIGSTOP | SIGTSTP ->
                  proc.state = Stopped
                SIGCONT ->
                  if proc.state == Stopped:
                    proc.state = Ready
                SIGCHLD | SIGUSR1 | SIGUSR2 ->
                  # Ignore by default
                  pass
                _ ->
                  process.exit(128 + sig)
            
            Ignore ->
              pass
            
            Custom(fn) ->
              fn(sig)

  # ==========================================================================
  # IPC OPERATIONS
  # ==========================================================================

  Behavior IPCOperations:
    When ipc.pipe():
      Then:
        - (read_fd, write_fd) = create_pipe()
        - return PipeChannel(read_fd, write_fd, 65536)

    When ipc.socketpair(type):
      Then:
        - (fd1, fd2) = create_socketpair(type)
        - return (SocketChannel(type, fd1), SocketChannel(type, fd2))

    When ipc.shared_memory_create(name, size):
      Then:
        - address = allocate_shared_memory(size)
        - shm = SharedMemoryChannel(name, size, address)
        - shared_memory_registry[name] = shm
        - return shm

    When ipc.shared_memory_open(name):
      Then:
        - shm = shared_memory_registry[name]
        - if not shm:
            - raise SharedMemoryNotFound(name)
        - return shm

    When ipc.message_queue_create(name, options):
      Then:
        - mq = MessageQueueChannel(
            name: name,
            max_messages: options.max_messages ?? 10,
            max_message_size: options.max_message_size ?? 8.KB
          )
        - message_queues[name] = mq
        - return mq

    When ipc.message_queue_send(mq, message):
      Then:
        - if mq.messages.size >= mq.max_messages:
            - await wait_for_space(mq)
        - if message.size > mq.max_message_size:
            - raise MessageTooLarge
        - mq.messages.push(IPCMessage(
            sender: current_process().pid,
            type: message.type,
            payload: message.payload,
            timestamp: now()
          ))
        - notify_receivers(mq)

    When ipc.message_queue_receive(mq, timeout):
      Then:
        - if mq.messages.is_empty():
            - await wait_for_message(mq, timeout)
        - return mq.messages.pop()

    When ipc.semaphore_create(name, value):
      Then:
        - sem = SemaphoreChannel(name, value)
        - semaphores[name] = sem
        - return sem

    When ipc.semaphore_wait(sem):
      Then:
        - while sem.value <= 0:
            - await wait_for_semaphore(sem)
        - sem.value -= 1

    When ipc.semaphore_post(sem):
      Then:
        - sem.value += 1
        - notify_semaphore_waiters(sem)

  # ==========================================================================
  # PROCESS SUPERVISION
  # ==========================================================================

  Behavior Supervision:
    Type Supervisor:
      name: String
      strategy: SupervisorStrategy
      children: List<ChildSpec>
      max_restarts: Int
      max_seconds: Duration
      restarts: List<Timestamp>

    Type SupervisorStrategy:
      variants:
        - OneForOne      # Restart only failed child
        - OneForAll      # Restart all children
        - RestForOne     # Restart failed and children started after it
        - SimpleOneForOne  # Dynamic children

    Type ChildSpec:
      id: String
      start: () -> Async<ProcessId>
      restart: RestartStrategy
      shutdown: ShutdownStrategy
      type: ChildType

    Type RestartStrategy:
      variants:
        - Permanent    # Always restart
        - Temporary    # Never restart
        - Transient    # Restart only on abnormal exit

    Type ShutdownStrategy:
      variants:
        - Brutal: Duration
        - Timeout: Duration
        - Infinity

    Type ChildType:
      variants: [Worker, Supervisor]

    When supervisor.start(spec):
      Then:
        - sup = Supervisor(
            name: spec.name,
            strategy: spec.strategy,
            children: spec.children,
            max_restarts: spec.max_restarts ?? 3,
            max_seconds: spec.max_seconds ?? 5.seconds,
            restarts: []
          )
        
        - # Start all children
        - for child_spec in spec.children:
            - await start_child(sup, child_spec)
        
        - # Monitor children
        - spawn monitor_children(sup)
        
        - return sup

    When start_child(sup, spec):
      Then:
        - pid = await spec.start()
        - sup.running_children[spec.id] = pid
        - emit ChildStarted(sup.name, spec.id, pid)

    When monitor_children(sup):
      Then:
        - loop:
            - (pid, exit_code) = await process.wait_any()
            - child_id = find_child_by_pid(sup, pid)
            - if not child_id: continue
            
            - spec = sup.children.find(c -> c.id == child_id)
            - emit ChildExited(sup.name, child_id, exit_code)
            
            - # Check restart strategy
            - should_restart = match spec.restart:
                Permanent -> true
                Temporary -> false
                Transient -> exit_code != 0
            
            - if should_restart:
                - await handle_restart(sup, spec, exit_code)

    When handle_restart(sup, spec, exit_code):
      Then:
        - # Check restart intensity
        - now_ts = now()
        - sup.restarts = sup.restarts.filter(t -> now_ts - t < sup.max_seconds)
        - sup.restarts.push(now_ts)
        
        - if sup.restarts.size > sup.max_restarts:
            - emit SupervisorShutdown(sup.name, "max_restarts_exceeded")
            - await shutdown_supervisor(sup)
            - return
        
        - # Apply strategy
        - match sup.strategy:
            OneForOne ->
              await start_child(sup, spec)
            
            OneForAll ->
              await stop_all_children(sup)
              for child_spec in sup.children:
                await start_child(sup, child_spec)
            
            RestForOne ->
              idx = sup.children.index_of(spec)
              for i in idx..sup.children.size:
                await stop_child(sup, sup.children[i])
              for i in idx..sup.children.size:
                await start_child(sup, sup.children[i])

    When stop_child(sup, spec):
      Then:
        - pid = sup.running_children[spec.id]
        - match spec.shutdown:
            Brutal(timeout) ->
              process.kill(pid, SIGKILL)
            Timeout(timeout) ->
              process.kill(pid, SIGTERM)
              result = await race(
                process.wait(pid),
                sleep(timeout)
              )
              if result == Timeout:
                process.kill(pid, SIGKILL)
            Infinity ->
              process.kill(pid, SIGTERM)
              await process.wait(pid)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Process Management":
    ```vibee
    # Spawn child process
    child = await process.spawn("python", ["script.py"], SpawnOptions(
      cwd: "/app",
      env: { "DEBUG": "true" },
      stdout: Pipe,
      stderr: Pipe
    ))

    # Read output
    output = await child.stdout.read_all()
    exit_code = await child.wait()

    # Execute command
    result = await process.exec("ls -la")
    log.info("Output: ${result.stdout}")

    # Signal handling
    signal.handle(SIGTERM, (sig) ->
      log.info("Received SIGTERM, shutting down...")
      cleanup()
      process.exit(0)
    )

    # IPC with pipes
    (read_pipe, write_pipe) = ipc.pipe()
    child = await process.spawn("worker", [], SpawnOptions(
      stdin: read_pipe
    ))
    await write_pipe.write("task data")

    # Shared memory
    shm = ipc.shared_memory_create("buffer", 1.MB)
    shm.write(0, data)
    # In another process:
    shm = ipc.shared_memory_open("buffer")
    data = shm.read(0, 1.MB)

    # Supervisor
    sup = await supervisor.start(SupervisorSpec(
      name: "app_supervisor",
      strategy: OneForOne,
      max_restarts: 5,
      max_seconds: 60.seconds,
      children: [
        ChildSpec(
          id: "web_server",
          start: () -> spawn_web_server(),
          restart: Permanent,
          shutdown: Timeout(30.seconds)
        ),
        ChildSpec(
          id: "worker",
          start: () -> spawn_worker(),
          restart: Transient,
          shutdown: Timeout(10.seconds)
        )
      ]
    ))
    ```
