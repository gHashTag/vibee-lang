# ============================================================================
# ENVIRONMENT - Переменные окружения на Vibee
# ============================================================================
# Environment variables, .env files, Configuration
# ============================================================================

Specification Environment:
  """Окружение как спецификация конфигурации через переменные."""

  # ==========================================================================
  # ENVIRONMENT VARIABLES
  # ==========================================================================

  Behavior Env:
    When env.get(key: String) -> Option<String>:
      Then: native_getenv(key)

    When env.get_or(key: String, default: String) -> String:
      Then: env.get(key).unwrap_or(default)

    When env.require(key: String) -> Result<String, EnvError>:
      Then:
        match env.get(key):
          Some(value) -> Ok(value)
          null -> Err(EnvError.NotFound(key))

    When env.set(key: String, value: String):
      Then: native_setenv(key, value)

    When env.remove(key: String):
      Then: native_unsetenv(key)

    When env.exists(key: String) -> Boolean:
      Then: env.get(key) != null

    When env.all() -> Map<String, String>:
      Then: native_environ()

    When env.keys() -> List<String>:
      Then: env.all().keys().to_list()

    When env.values() -> List<String>:
      Then: env.all().values().to_list()

    # Typed getters
    When env.get_int(key: String) -> Option<Int>:
      Then: env.get(key).and_then(v -> v.parse_int().ok())

    When env.get_int_or(key: String, default: Int) -> Int:
      Then: env.get_int(key).unwrap_or(default)

    When env.get_float(key: String) -> Option<Float>:
      Then: env.get(key).and_then(v -> v.parse_float().ok())

    When env.get_float_or(key: String, default: Float) -> Float:
      Then: env.get_float(key).unwrap_or(default)

    When env.get_bool(key: String) -> Option<Boolean>:
      Then:
        value = env.get(key)?
        match value.lowercase():
          "true" | "1" | "yes" | "on" -> Some(true)
          "false" | "0" | "no" | "off" -> Some(false)
          _ -> null

    When env.get_bool_or(key: String, default: Boolean) -> Boolean:
      Then: env.get_bool(key).unwrap_or(default)

    When env.get_list(key: String, separator: String = ",") -> List<String>:
      Then:
        value = env.get(key)?
        return value.split(separator).map(s -> s.trim()).to_list()

    When env.get_path(key: String) -> Option<Path>:
      Then: env.get(key).map(v -> Path(v))

    When env.get_duration(key: String) -> Option<Duration>:
      Then:
        value = env.get(key)?
        parse_duration(value).ok()

    When env.get_url(key: String) -> Option<Url>:
      Then:
        value = env.get(key)?
        Url.parse(value).ok()

  Type EnvError:
    variants:
      - NotFound(String)
      - ParseError(String, String)
      - InvalidValue(String, String)

    Method message() -> String:
      match self:
        NotFound(key) -> "Environment variable not found: ${key}"
        ParseError(key, msg) -> "Failed to parse ${key}: ${msg}"
        InvalidValue(key, msg) -> "Invalid value for ${key}: ${msg}"

  # ==========================================================================
  # DOTENV
  # ==========================================================================

  Type DotEnv:
    vars: Map<String, String>
    path: Path

    Static Method load() -> Result<DotEnv, EnvError>:
      return DotEnv.load_from(Path(".env"))

    Static Method load_from(path: Path) -> Result<DotEnv, EnvError>:
      if not path.exists():
        return Ok(DotEnv({}, path))
      
      content = File.read_string(path)?
      vars = DotEnv.parse(content)?
      
      dotenv = DotEnv(vars, path)
      dotenv.apply()
      
      return Ok(dotenv)

    Static Method load_if_exists() -> DotEnv:
      return DotEnv.load().unwrap_or(DotEnv({}, Path(".env")))

    Static Method load_multiple(paths: List<Path>) -> Result<DotEnv, EnvError>:
      combined = {}
      
      for path in paths:
        if path.exists():
          content = File.read_string(path)?
          vars = DotEnv.parse(content)?
          combined = combined.merge(vars)
      
      dotenv = DotEnv(combined, paths.first().unwrap_or(Path(".env")))
      dotenv.apply()
      
      return Ok(dotenv)

    Static Method parse(content: String) -> Result<Map<String, String>, EnvError>:
      vars = {}
      
      for (line_num, line) in content.lines().enumerate():
        line = line.trim()
        
        # Skip empty lines and comments
        if line.is_empty() or line.starts_with("#"):
          continue
        
        # Parse key=value
        if not line.contains("="):
          continue
        
        parts = line.split("=", 2)
        key = parts[0].trim()
        value = if parts.length > 1 then parts[1].trim() else ""
        
        # Remove quotes
        value = DotEnv.unquote(value)
        
        # Expand variables
        value = DotEnv.expand_vars(value, vars)
        
        vars[key] = value
      
      return Ok(vars)

    Static Method unquote(value: String) -> String:
      if value.length >= 2:
        if (value.starts_with('"') and value.ends_with('"')) or
           (value.starts_with("'") and value.ends_with("'")):
          return value.slice(1, value.length - 1)
      return value

    Static Method expand_vars(value: String, vars: Map<String, String>) -> String:
      # Expand ${VAR} and $VAR
      result = value
      
      # ${VAR} syntax
      result = Regex("\\$\\{([^}]+)\\}").replace_all(result, match -> {
        var_name = match.group(1).unwrap()
        vars.get(var_name).or_else(() -> env.get(var_name)).unwrap_or("")
      })
      
      # $VAR syntax (word boundary)
      result = Regex("\\$([A-Za-z_][A-Za-z0-9_]*)").replace_all(result, match -> {
        var_name = match.group(1).unwrap()
        vars.get(var_name).or_else(() -> env.get(var_name)).unwrap_or("")
      })
      
      return result

    Method apply():
      for (key, value) in self.vars:
        # Don't override existing env vars
        if env.get(key) == null:
          env.set(key, value)

    Method apply_override():
      for (key, value) in self.vars:
        env.set(key, value)

    Method get(key: String) -> Option<String>:
      return self.vars.get(key)

    Method all() -> Map<String, String>:
      return self.vars.clone()

  # ==========================================================================
  # ENVIRONMENT BUILDER
  # ==========================================================================

  Type EnvBuilder:
    vars: Map<String, String>
    inherit: Boolean

    Static Method new() -> EnvBuilder:
      return EnvBuilder({}, true)

    Static Method empty() -> EnvBuilder:
      return EnvBuilder({}, false)

    Method set(key: String, value: String) -> EnvBuilder:
      return EnvBuilder(self.vars.set(key, value), self.inherit)

    Method set_if_missing(key: String, value: String) -> EnvBuilder:
      if key not in self.vars:
        return self.set(key, value)
      return self

    Method remove(key: String) -> EnvBuilder:
      new_vars = self.vars.clone()
      new_vars.remove(key)
      return EnvBuilder(new_vars, self.inherit)

    Method inherit_all() -> EnvBuilder:
      return EnvBuilder(self.vars, true)

    Method clear_inherit() -> EnvBuilder:
      return EnvBuilder(self.vars, false)

    Method merge(other: Map<String, String>) -> EnvBuilder:
      return EnvBuilder(self.vars.merge(other), self.inherit)

    Method build() -> Map<String, String>:
      if self.inherit:
        return env.all().merge(self.vars)
      else:
        return self.vars.clone()

  # ==========================================================================
  # CONFIGURATION
  # ==========================================================================

  Type Config:
    sources: List<ConfigSource>
    cache: Map<String, Any>
    prefix: Option<String>

    Static Method new() -> Config:
      return Config([], {}, null)

    Static Method from_env() -> Config:
      return Config.new().add_source(EnvConfigSource())

    Static Method from_dotenv() -> Config:
      return Config.new()
        .add_source(DotEnvConfigSource(Path(".env")))
        .add_source(EnvConfigSource())

    Method add_source(source: ConfigSource) -> Config:
      return Config(self.sources + [source], {}, self.prefix)

    Method with_prefix(prefix: String) -> Config:
      return Config(self.sources, self.cache, Some(prefix))

    Method get<T>(key: String) -> Option<T>:
      full_key = self.full_key(key)
      
      # Check cache
      if self.cache.get(full_key) is Some(v):
        return Some(v as T)
      
      # Search sources (last added has priority)
      for source in self.sources.reverse():
        if source.get(full_key) is Some(value):
          parsed = parse_value<T>(value)
          if parsed is Some(v):
            self.cache[full_key] = v
            return Some(v)
      
      return null

    Method get_or<T>(key: String, default: T) -> T:
      return self.get<T>(key).unwrap_or(default)

    Method require<T>(key: String) -> Result<T, ConfigError>:
      match self.get<T>(key):
        Some(v) -> Ok(v)
        null -> Err(ConfigError.NotFound(self.full_key(key)))

    Method full_key(key: String) -> String:
      if self.prefix is Some(p):
        return "${p}_${key}".uppercase()
      return key.uppercase()

    Method get_string(key: String) -> Option<String>:
      return self.get<String>(key)

    Method get_int(key: String) -> Option<Int>:
      return self.get<Int>(key)

    Method get_bool(key: String) -> Option<Boolean>:
      return self.get<Boolean>(key)

    Method get_list(key: String) -> Option<List<String>>:
      return self.get<List<String>>(key)

    Method get_nested(prefix: String) -> Config:
      return self.with_prefix(
        if self.prefix is Some(p) then "${p}_${prefix}" else prefix
      )

  Trait ConfigSource:
    Method get(key: String) -> Option<String>

  Type EnvConfigSource:
    Trait ConfigSource:
      Method get(key: String) -> Option<String>:
        return env.get(key)

  Type DotEnvConfigSource:
    path: Path
    vars: Map<String, String>

    Static Method new(path: Path) -> DotEnvConfigSource:
      vars = if path.exists():
        DotEnv.load_from(path).map(d -> d.vars).unwrap_or({})
      else:
        {}
      return DotEnvConfigSource(path, vars)

    Trait ConfigSource:
      Method get(key: String) -> Option<String>:
        return self.vars.get(key)

  Type MapConfigSource:
    values: Map<String, String>

    Trait ConfigSource:
      Method get(key: String) -> Option<String>:
        return self.values.get(key)

  Type FileConfigSource:
    path: Path
    format: ConfigFormat
    values: Map<String, Any>

    Static Method json(path: Path) -> FileConfigSource:
      content = File.read_string(path).unwrap_or("{}")
      values = json.parse(content).unwrap_or({})
      return FileConfigSource(path, ConfigFormat.JSON, values)

    Static Method yaml(path: Path) -> FileConfigSource:
      content = File.read_string(path).unwrap_or("")
      values = yaml.parse(content).unwrap_or({})
      return FileConfigSource(path, ConfigFormat.YAML, values)

    Static Method toml(path: Path) -> FileConfigSource:
      content = File.read_string(path).unwrap_or("")
      values = toml.parse(content).unwrap_or({})
      return FileConfigSource(path, ConfigFormat.TOML, values)

    Trait ConfigSource:
      Method get(key: String) -> Option<String>:
        # Support nested keys with dots
        parts = key.split(".")
        current = self.values
        
        for part in parts.slice(0, parts.length - 1):
          current = current.get(part)? as Map<String, Any>
        
        value = current.get(parts.last())?
        return Some(value.to_string())

  Type ConfigFormat:
    variants:
      - JSON
      - YAML
      - TOML
      - ENV

  Type ConfigError:
    variants:
      - NotFound(String)
      - ParseError(String)
      - InvalidType(String)

  # ==========================================================================
  # SPECIAL DIRECTORIES
  # ==========================================================================

  Behavior Directories:
    When home_dir() -> Option<Path>:
      Then:
        env.get("HOME")
          .or_else(() -> env.get("USERPROFILE"))
          .map(p -> Path(p))

    When config_dir() -> Option<Path>:
      Then:
        if is_macos():
          home_dir().map(h -> h.join("Library/Application Support"))
        else if is_windows():
          env.get("APPDATA").map(p -> Path(p))
        else:
          env.get("XDG_CONFIG_HOME")
            .map(p -> Path(p))
            .or_else(() -> home_dir().map(h -> h.join(".config")))

    When data_dir() -> Option<Path>:
      Then:
        if is_macos():
          home_dir().map(h -> h.join("Library/Application Support"))
        else if is_windows():
          env.get("LOCALAPPDATA").map(p -> Path(p))
        else:
          env.get("XDG_DATA_HOME")
            .map(p -> Path(p))
            .or_else(() -> home_dir().map(h -> h.join(".local/share")))

    When cache_dir() -> Option<Path>:
      Then:
        if is_macos():
          home_dir().map(h -> h.join("Library/Caches"))
        else if is_windows():
          env.get("LOCALAPPDATA").map(p -> Path(p).join("cache"))
        else:
          env.get("XDG_CACHE_HOME")
            .map(p -> Path(p))
            .or_else(() -> home_dir().map(h -> h.join(".cache")))

    When temp_dir() -> Path:
      Then:
        env.get("TMPDIR")
          .or_else(() -> env.get("TMP"))
          .or_else(() -> env.get("TEMP"))
          .map(p -> Path(p))
          .unwrap_or(Path("/tmp"))

    When current_dir() -> Result<Path, IOError>:
      Then: native_getcwd()

    When current_exe() -> Result<Path, IOError>:
      Then: native_current_exe()

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Environment":
    ```vibee
    # Get environment variable
    home = env.get("HOME")
    port = env.get_int_or("PORT", 8080)
    debug = env.get_bool_or("DEBUG", false)

    # Require variable (error if missing)
    db_url = env.require("DATABASE_URL")?

    # Set variable
    env.set("MY_VAR", "value")

    # Remove variable
    env.remove("MY_VAR")

    # Get all variables
    for (key, value) in env.all():
      print("${key}=${value}")

    # Load .env file
    DotEnv.load()?

    # Load specific file
    DotEnv.load_from(Path(".env.production"))?

    # Load multiple files (later files override)
    DotEnv.load_multiple([
      Path(".env"),
      Path(".env.local"),
      Path(".env.${env.get_or("NODE_ENV", "development")}")
    ])?

    # .env file format:
    # DATABASE_URL=postgres://localhost/mydb
    # PORT=3000
    # DEBUG=true
    # SECRET_KEY="my secret key"
    # API_URL=${BASE_URL}/api
    # # This is a comment

    # Configuration with multiple sources
    config = Config.new()
      .add_source(FileConfigSource.yaml(Path("config/default.yaml")))
      .add_source(FileConfigSource.yaml(Path("config/${env.get_or("ENV", "development")}.yaml")))
      .add_source(DotEnvConfigSource.new(Path(".env")))
      .add_source(EnvConfigSource())

    # Get config values
    db_host = config.get_string("database.host")?
    db_port = config.get_int("database.port").unwrap_or(5432)
    features = config.get_list("features").unwrap_or([])

    # Nested config with prefix
    db_config = config.get_nested("database")
    host = db_config.get_string("host")?
    port = db_config.get_int("port")?

    # Environment builder for subprocess
    child_env = EnvBuilder.new()
      .set("NODE_ENV", "production")
      .set("PORT", "3000")
      .remove("DEBUG")
      .build()

    Command.new("node")
      .arg("server.js")
      .envs(child_env)
      .spawn()?

    # Special directories
    home = home_dir()?
    config_path = config_dir()?.join("myapp/config.toml")
    cache_path = cache_dir()?.join("myapp")
    temp = temp_dir()

    # Current directory
    cwd = current_dir()?
    exe = current_exe()?
    ```
