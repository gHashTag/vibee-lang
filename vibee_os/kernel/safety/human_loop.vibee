name: vibee_os_human_loop
version: "0.1.0"
language: zig
module: kernel/safety/human_loop
description: Human-in-the-Loop Safety Layer - ensures human oversight for critical operations (Claude Computer Use inspired)

behaviors:
  - name: require_approval_for_critical
    given: Agent wants to perform a critical action
    when: Action risk level exceeds threshold
    then: Human approval is required before execution
    test_cases:
      - name: approve_file_delete
        input: {action: "delete", target: "/important/data.db", risk: "high"}
        expected: {requires_approval: true, approval_type: "explicit"}
      - name: auto_approve_safe
        input: {action: "read", target: "/tmp/test.txt", risk: "low"}
        expected: {requires_approval: false, auto_approved: true}

  - name: checkpoint_long_tasks
    given: Agent is executing a long-running task
    when: Checkpoint interval is reached
    then: Human is notified and can intervene
    test_cases:
      - name: checkpoint_at_30min
        input: {task_duration_min: 30, checkpoint_interval_min: 30}
        expected: {checkpoint_triggered: true, human_notified: true}
      - name: continue_after_approval
        input: {checkpoint: true, human_response: "continue"}
        expected: {task_continues: true}

  - name: emergency_stop
    given: Human detects problematic agent behavior
    when: emergency_stop is triggered
    then: All agent actions are immediately halted
    test_cases:
      - name: stop_all_agents
        input: {trigger: "user_command"}
        expected: {all_stopped: true, state_saved: true, rollback_ready: true}

  - name: audit_trail
    given: Agent performs any action
    when: Action completes
    then: Full audit trail is recorded for human review
    test_cases:
      - name: log_file_modification
        input: {action: "write", target: "config.yaml", content_hash: "abc123"}
        expected: {logged: true, reversible: true, human_reviewable: true}

  - name: explain_decision
    given: Human asks why agent made a decision
    when: explain_decision is called
    then: Agent provides clear reasoning chain
    test_cases:
      - name: explain_code_change
        input: {decision_id: "dec_123", question: "why did you change this function?"}
        expected: {explanation_provided: true, reasoning_clear: true}

types:
  SafetyPolicy:
    name: str
    rules: [SafetyRule]
    default_action: DefaultAction
    escalation_chain: [str]

  SafetyRule:
    id: str
    condition: RuleCondition
    action: RuleAction
    risk_level: RiskLevel
    description: str

  RuleCondition:
    action_type: ActionType?
    target_pattern: str?
    risk_threshold: RiskLevel?
    time_constraint: TimeConstraint?

  ActionType:
    variants:
      - FileRead
      - FileWrite
      - FileDelete
      - ProcessExecute
      - NetworkRequest
      - SystemConfig
      - CodeGenerate
      - CodeDeploy
      - DataAccess
      - ExternalAPI

  TimeConstraint:
    max_duration_minutes: int?
    allowed_hours: {start: int, end: int}?
    require_checkpoint_after_minutes: int?

  RuleAction:
    variants:
      - Allow
      - Deny
      - RequireApproval
      - RequireExplanation
      - Checkpoint
      - Notify
      - Log

  RiskLevel:
    variants:
      - None
      - Low
      - Medium
      - High
      - Critical

  DefaultAction:
    variants:
      - AllowWithLog
      - RequireApproval
      - Deny

  ApprovalRequest:
    id: str
    agent_id: str
    action: PendingAction
    risk_level: RiskLevel
    explanation: str
    context: str
    created_at: int
    expires_at: int
    status: ApprovalStatus

  PendingAction:
    type: ActionType
    target: str
    parameters: {str: str}
    reversible: bool
    impact_description: str

  ApprovalStatus:
    variants:
      - Pending
      - Approved
      - Denied
      - Expired
      - Escalated

  ApprovalResponse:
    request_id: str
    decision: ApprovalDecision
    responder: str
    reason: str?
    timestamp: int

  ApprovalDecision:
    variants:
      - Approve
      - ApproveOnce
      - ApproveAlways
      - Deny
      - DenyAlways
      - Escalate

  Checkpoint:
    id: str
    task_id: str
    agent_id: str
    progress_percent: int
    summary: str
    decisions_made: [Decision]
    actions_taken: [AuditEntry]
    next_steps: [str]
    human_options: [CheckpointOption]

  CheckpointOption:
    variants:
      - Continue
      - Pause
      - Modify
      - Rollback
      - Stop

  Decision:
    id: str
    description: str
    rationale: str
    alternatives_considered: [str]
    confidence: float
    timestamp: int

  AuditEntry:
    id: str
    timestamp: int
    agent_id: str
    action_type: ActionType
    target: str
    parameters: {str: str}
    result: ActionResult
    reversible: bool
    reversal_action: str?

  ActionResult:
    variants:
      - Success
      - Failure
      - Partial
      - Blocked
      - Rolled_back

  EmergencyStop:
    triggered_at: int
    triggered_by: str
    reason: str
    agents_stopped: [str]
    state_snapshot: str
    rollback_available: bool

  Explanation:
    decision_id: str
    question: str
    reasoning_chain: [ReasoningStep]
    confidence: float
    alternatives: [Alternative]

  ReasoningStep:
    step: int
    thought: str
    evidence: str?

  Alternative:
    description: str
    why_not_chosen: str

functions:
  # Approval workflow
  - name: request_approval
    params: {action: PendingAction, explanation: str}
    returns: ApprovalRequest
    description: Request human approval for action

  - name: check_approval
    params: {request_id: str}
    returns: ApprovalStatus
    description: Check status of approval request

  - name: respond_to_approval
    params: {request_id: str, decision: ApprovalDecision, reason: str?}
    returns: bool
    description: Human responds to approval request

  - name: auto_approve_check
    params: {action: PendingAction}
    returns: bool
    description: Check if action can be auto-approved

  # Checkpoints
  - name: create_checkpoint
    params: {task_id: str, summary: str}
    returns: Checkpoint
    description: Create checkpoint for human review

  - name: await_checkpoint_response
    params: {checkpoint_id: str, timeout_ms: int}
    returns: CheckpointOption
    description: Wait for human response to checkpoint

  - name: schedule_checkpoint
    params: {task_id: str, interval_minutes: int}
    returns: void
    description: Schedule periodic checkpoints

  # Emergency controls
  - name: emergency_stop
    params: {reason: str}
    returns: EmergencyStop
    description: Immediately stop all agent activity

  - name: resume_from_stop
    params: {stop_id: str}
    returns: bool
    description: Resume after emergency stop

  - name: rollback_to_checkpoint
    params: {checkpoint_id: str}
    returns: bool
    description: Rollback to previous checkpoint

  # Audit
  - name: log_action
    params: {action: ActionType, target: str, result: ActionResult}
    returns: AuditEntry
    description: Log action to audit trail

  - name: get_audit_trail
    params: {agent_id: str?, time_range: {start: int, end: int}?}
    returns: [AuditEntry]
    description: Get audit trail

  - name: export_audit
    params: {format: str}
    returns: str
    description: Export audit trail

  # Explanation
  - name: explain_decision
    params: {decision_id: str, question: str}
    returns: Explanation
    description: Explain why a decision was made

  - name: explain_action
    params: {audit_entry_id: str}
    returns: Explanation
    description: Explain why an action was taken

  # Policy management
  - name: set_policy
    params: {policy: SafetyPolicy}
    returns: bool
    description: Set safety policy

  - name: get_policy
    params: {}
    returns: SafetyPolicy
    description: Get current safety policy

  - name: evaluate_risk
    params: {action: PendingAction}
    returns: RiskLevel
    description: Evaluate risk level of action

imports:
  - kernel.agent.core
  - kernel.security.capability

safety_principles: |
  VIBEE OS Safety Principles (from Claude Computer Use research):
  
  1. BOUNDED AUTONOMY
  ─────────────────────
  - Max session duration: 3 hours
  - Checkpoint every 30 minutes
  - Human can intervene at any time
  
  2. APPROVAL HIERARCHY
  ─────────────────────
  Risk Level → Required Approval
  
  None/Low   → Auto-approve with logging
  Medium     → Notify human, proceed if no objection
  High       → Require explicit approval
  Critical   → Require approval + confirmation
  
  3. REVERSIBILITY
  ─────────────────────
  - All actions should be reversible when possible
  - State snapshots before critical operations
  - Rollback capability always available
  
  4. TRANSPARENCY
  ─────────────────────
  - Full audit trail of all actions
  - Explain any decision on request
  - No hidden operations
  
  5. FAIL-SAFE DEFAULTS
  ─────────────────────
  - When in doubt, ask human
  - Emergency stop always available
  - Default to safer option

default_policy: |
  Default Safety Policy:
  
  rules:
    - id: "file_delete"
      condition: {action_type: FileDelete}
      action: RequireApproval
      risk_level: High
      
    - id: "system_config"
      condition: {action_type: SystemConfig}
      action: RequireApproval
      risk_level: Critical
      
    - id: "code_deploy"
      condition: {action_type: CodeDeploy}
      action: RequireApproval
      risk_level: High
      
    - id: "external_api"
      condition: {action_type: ExternalAPI}
      action: Notify
      risk_level: Medium
      
    - id: "file_read"
      condition: {action_type: FileRead}
      action: Allow
      risk_level: Low
      
    - id: "long_task"
      condition: {time_constraint: {require_checkpoint_after_minutes: 30}}
      action: Checkpoint
      risk_level: Medium
  
  default_action: AllowWithLog
  escalation_chain: ["user", "admin", "emergency_stop"]
