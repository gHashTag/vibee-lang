# ============================================================================
# WEBSOCKET - Real-time коммуникация на Vibee
# ============================================================================
# Полнофункциональный WebSocket сервер с комнатами, broadcast и pub/sub
# ============================================================================

Specification WebSocket:
  """
  WebSocket как спецификация двунаправленной коммуникации.
  Каждое соединение - актор, каждое сообщение - событие.
  """

  # ==========================================================================
  # ТИПЫ ДАННЫХ
  # ==========================================================================

  Type WebSocketState:
    variants:
      - Connecting
      - Open
      - Closing
      - Closed

  Type CloseCode:
    NORMAL: 1000
    GOING_AWAY: 1001
    PROTOCOL_ERROR: 1002
    UNSUPPORTED_DATA: 1003
    NO_STATUS: 1005
    ABNORMAL: 1006
    INVALID_PAYLOAD: 1007
    POLICY_VIOLATION: 1008
    MESSAGE_TOO_BIG: 1009
    EXTENSION_REQUIRED: 1010
    INTERNAL_ERROR: 1011
    SERVICE_RESTART: 1012
    TRY_AGAIN_LATER: 1013
    BAD_GATEWAY: 1014
    TLS_HANDSHAKE_FAILED: 1015

  Type Frame:
    opcode: Opcode
    fin: Boolean
    payload: Bytes
    mask: Bytes?

  Type Opcode:
    variants:
      - Continuation: 0x0
      - Text: 0x1
      - Binary: 0x2
      - Close: 0x8
      - Ping: 0x9
      - Pong: 0xA

  Type Message:
    variants:
      - Text: String
      - Binary: Bytes
      - Ping: Bytes
      - Pong: Bytes
      - Close: (code: CloseCode, reason: String)

  Type Connection:
    id: ConnectionId
    state: WebSocketState
    remote_addr: IPAddress
    path: String
    query: Map<String, String>
    headers: Map<String, String>
    user: User?
    metadata: Map<String, Any>
    rooms: Set<RoomId>
    created_at: Timestamp
    last_ping: Timestamp
    last_pong: Timestamp
    messages_sent: Int
    messages_received: Int
    bytes_sent: Int
    bytes_received: Int

  Type ConnectionId:
    value: UUID

  # ==========================================================================
  # КОМНАТЫ И ГРУППЫ
  # ==========================================================================

  Type Room:
    id: RoomId
    name: String
    connections: Set<ConnectionId>
    metadata: Map<String, Any>
    created_at: Timestamp
    max_connections: Int?
    password: String?

  Type RoomId:
    value: String

  Type RoomOptions:
    max_connections: Int?
    password: String?
    metadata: Map<String, Any> = {}
    auto_delete_when_empty: Boolean = true

  # ==========================================================================
  # КОНФИГУРАЦИЯ
  # ==========================================================================

  Type WebSocketConfig:
    # Limits
    max_connections: Int = 100000
    max_message_size: ByteSize = 1.MB
    max_frame_size: ByteSize = 64.KB
    
    # Timeouts
    handshake_timeout: Duration = 10.seconds
    ping_interval: Duration = 30.seconds
    ping_timeout: Duration = 10.seconds
    close_timeout: Duration = 5.seconds
    
    # Compression
    compression: CompressionConfig?
    
    # Subprotocols
    subprotocols: List<String> = []
    
    # Origins
    allowed_origins: List<String> = ["*"]
    
    # Backpressure
    send_buffer_size: Int = 256
    receive_buffer_size: Int = 256

  Type CompressionConfig:
    enabled: Boolean = true
    threshold: ByteSize = 1.KB
    level: Int = 6  # 1-9

  # ==========================================================================
  # СОСТОЯНИЕ СЕРВЕРА
  # ==========================================================================

  Type ServerState:
    config: WebSocketConfig
    connections: Map<ConnectionId, Connection>
    rooms: Map<RoomId, Room>
    handlers: EventHandlers
    stats: ServerStats

  Type ServerStats:
    total_connections: Int
    active_connections: Int
    total_messages: Int
    messages_per_second: Float
    bytes_sent: Int
    bytes_received: Int
    rooms_count: Int

  Type EventHandlers:
    on_connect: (Connection) -> Async<Boolean>
    on_message: (Connection, Message) -> Async<Unit>
    on_close: (Connection, CloseCode, String) -> Async<Unit>
    on_error: (Connection, Error) -> Async<Unit>

  # ==========================================================================
  # ПОВЕДЕНИЯ СОЕДИНЕНИЯ
  # ==========================================================================

  Behavior ConnectionLifecycle:
    """Жизненный цикл WebSocket соединения"""

    When upgrade_request(http_request):
      Then:
        # Validate upgrade request
        - if http_request.header("Upgrade") != "websocket":
            - return HTTP_Response(status: 400)
        
        - if http_request.header("Connection") != "Upgrade":
            - return HTTP_Response(status: 400)
        
        - key = http_request.header("Sec-WebSocket-Key")
        - if not key:
            - return HTTP_Response(status: 400)
        
        # Check origin
        - origin = http_request.header("Origin")
        - if not is_origin_allowed(origin):
            - return HTTP_Response(status: 403)
        
        # Negotiate subprotocol
        - requested = http_request.header("Sec-WebSocket-Protocol")
        - subprotocol = negotiate_subprotocol(requested)
        
        # Create connection
        - connection = Connection(
            id: generate_id(),
            state: Connecting,
            remote_addr: http_request.remote_addr,
            path: http_request.path,
            query: http_request.query,
            headers: http_request.headers,
            rooms: {},
            created_at: now()
          )
        
        # Call connect handler
        - allowed = await handlers.on_connect(connection)
        - if not allowed:
            - return HTTP_Response(status: 403)
        
        # Complete handshake
        - accept_key = compute_accept_key(key)
        - add connection to state.connections
        - set connection.state to Open
        - emit ConnectionOpened(connection)
        
        - return HTTP_Response(
            status: 101,
            headers: [
              ("Upgrade", "websocket"),
              ("Connection", "Upgrade"),
              ("Sec-WebSocket-Accept", accept_key),
              ("Sec-WebSocket-Protocol", subprotocol) if subprotocol
            ]
          )

    When connection.close(code, reason):
      Given connection.state is Open
      Then:
        - set connection.state to Closing
        - send Close frame with (code, reason)
        - wait for Close frame or timeout config.close_timeout
        - set connection.state to Closed
        - leave all rooms
        - remove from state.connections
        - await handlers.on_close(connection, code, reason)
        - emit ConnectionClosed(connection, code, reason)

    When connection receives Close frame:
      Given connection.state is Open
      Then:
        - send Close frame with same code
        - set connection.state to Closed
        - leave all rooms
        - remove from state.connections
        - await handlers.on_close(connection, code, reason)

  Behavior MessageHandling:
    """Обработка сообщений"""

    When connection.send(message):
      Given connection.state is Open
      Then:
        - frames = encode_message(message)
        - for frame in frames:
            - if config.compression and should_compress(frame):
                - frame = compress(frame)
            - write frame to connection
        - increment connection.messages_sent
        - add frame.size to connection.bytes_sent
        - emit MessageSent(connection, message)

    When connection receives frame:
      Given connection.state is Open
      Then:
        - if frame.opcode is Ping:
            - send Pong with frame.payload
            - return
        
        - if frame.opcode is Pong:
            - set connection.last_pong to now()
            - return
        
        - if frame.opcode is Close:
            - handle close frame
            - return
        
        # Accumulate fragments
        - if not frame.fin:
            - add frame to fragment_buffer
            - return
        
        # Complete message
        - message = decode_message(fragment_buffer + frame)
        - clear fragment_buffer
        
        # Validate size
        - if message.size > config.max_message_size:
            - connection.close(MESSAGE_TOO_BIG, "Message too large")
            - return
        
        - increment connection.messages_received
        - add message.size to connection.bytes_received
        - emit MessageReceived(connection, message)
        - await handlers.on_message(connection, message)

    When connection.send_text(text):
      Then: connection.send(Message.Text(text))

    When connection.send_binary(data):
      Then: connection.send(Message.Binary(data))

    When connection.send_json(data):
      Then: connection.send(Message.Text(JSON.stringify(data)))

  Behavior PingPong:
    """Heartbeat для поддержания соединения"""

    When ping_loop():
      Then:
        - loop every config.ping_interval:
            - for connection in state.connections.values():
                - if connection.state is Open:
                    - if now() - connection.last_pong > config.ping_timeout:
                        - connection.close(GOING_AWAY, "Ping timeout")
                    - else:
                        - send Ping to connection
                        - set connection.last_ping to now()

  # ==========================================================================
  # КОМНАТЫ
  # ==========================================================================

  Behavior RoomManagement:
    """Управление комнатами"""

    When create_room(name, options):
      Then:
        - room_id = RoomId(name)
        - if state.rooms.has(room_id):
            - return Error("Room already exists")
        
        - room = Room(
            id: room_id,
            name: name,
            connections: {},
            metadata: options.metadata,
            created_at: now(),
            max_connections: options.max_connections,
            password: options.password
          )
        
        - add room to state.rooms
        - emit RoomCreated(room)
        - return Ok(room)

    When delete_room(room_id):
      Then:
        - room = state.rooms.get(room_id)
        - if not room:
            - return Error("Room not found")
        
        # Notify all connections
        - for conn_id in room.connections:
            - connection = state.connections.get(conn_id)
            - if connection:
                - remove room_id from connection.rooms
                - emit LeftRoom(connection, room)
        
        - remove room from state.rooms
        - emit RoomDeleted(room)
        - return Ok()

    When connection.join(room_id, password):
      Given connection.state is Open
      Then:
        - room = state.rooms.get(room_id)
        - if not room:
            - return Error("Room not found")
        
        - if room.password and room.password != password:
            - return Error("Invalid password")
        
        - if room.max_connections and room.connections.size >= room.max_connections:
            - return Error("Room is full")
        
        - add connection.id to room.connections
        - add room_id to connection.rooms
        - emit JoinedRoom(connection, room)
        - return Ok(room)

    When connection.leave(room_id):
      Then:
        - room = state.rooms.get(room_id)
        - if not room:
            - return Error("Room not found")
        
        - remove connection.id from room.connections
        - remove room_id from connection.rooms
        - emit LeftRoom(connection, room)
        
        # Auto-delete empty room
        - if room.connections.is_empty() and room.auto_delete_when_empty:
            - delete_room(room_id)
        
        - return Ok()

    When connection.leave_all_rooms():
      Then:
        - for room_id in connection.rooms:
            - connection.leave(room_id)

  # ==========================================================================
  # BROADCAST И MESSAGING
  # ==========================================================================

  Behavior Broadcasting:
    """Рассылка сообщений"""

    When broadcast(message):
      """Отправить всем подключённым клиентам"""
      Then:
        - for connection in state.connections.values():
            - if connection.state is Open:
                - connection.send(message)

    When broadcast_except(message, exclude_ids):
      """Отправить всем кроме указанных"""
      Then:
        - for connection in state.connections.values():
            - if connection.state is Open and connection.id not in exclude_ids:
                - connection.send(message)

    When broadcast_to_room(room_id, message):
      """Отправить всем в комнате"""
      Then:
        - room = state.rooms.get(room_id)
        - if not room:
            - return Error("Room not found")
        
        - for conn_id in room.connections:
            - connection = state.connections.get(conn_id)
            - if connection and connection.state is Open:
                - connection.send(message)

    When broadcast_to_room_except(room_id, message, exclude_id):
      """Отправить всем в комнате кроме отправителя"""
      Then:
        - room = state.rooms.get(room_id)
        - if not room:
            - return Error("Room not found")
        
        - for conn_id in room.connections:
            - if conn_id != exclude_id:
                - connection = state.connections.get(conn_id)
                - if connection and connection.state is Open:
                    - connection.send(message)

    When send_to(connection_id, message):
      """Отправить конкретному клиенту"""
      Then:
        - connection = state.connections.get(connection_id)
        - if not connection:
            - return Error("Connection not found")
        - if connection.state is not Open:
            - return Error("Connection not open")
        - connection.send(message)

    When send_to_user(user_id, message):
      """Отправить всем соединениям пользователя"""
      Then:
        - for connection in state.connections.values():
            - if connection.user?.id == user_id and connection.state is Open:
                - connection.send(message)

  # ==========================================================================
  # PUB/SUB
  # ==========================================================================

  Behavior PubSub:
    """Publish/Subscribe паттерн"""

    State:
      subscriptions: Map<Topic, Set<ConnectionId>>
      patterns: Map<Pattern, Set<ConnectionId>>

    Type Topic:
      value: String

    Type Pattern:
      value: String  # Glob pattern: "chat.*", "user.*.events"

    When connection.subscribe(topic):
      Then:
        - subscribers = subscriptions.get_or_default(topic, {})
        - add connection.id to subscribers
        - set subscriptions[topic] = subscribers
        - emit Subscribed(connection, topic)

    When connection.subscribe_pattern(pattern):
      Then:
        - subscribers = patterns.get_or_default(pattern, {})
        - add connection.id to subscribers
        - set patterns[pattern] = subscribers
        - emit SubscribedPattern(connection, pattern)

    When connection.unsubscribe(topic):
      Then:
        - subscribers = subscriptions.get(topic)
        - if subscribers:
            - remove connection.id from subscribers
            - if subscribers.is_empty():
                - remove topic from subscriptions
        - emit Unsubscribed(connection, topic)

    When connection.unsubscribe_all():
      Then:
        - for (topic, subscribers) in subscriptions:
            - remove connection.id from subscribers
        - for (pattern, subscribers) in patterns:
            - remove connection.id from subscribers

    When publish(topic, message):
      Then:
        - sent_to = Set<ConnectionId>()
        
        # Direct subscribers
        - subscribers = subscriptions.get(topic) ?? {}
        - for conn_id in subscribers:
            - connection = state.connections.get(conn_id)
            - if connection and connection.state is Open:
                - connection.send(message)
                - add conn_id to sent_to
        
        # Pattern subscribers
        - for (pattern, pattern_subscribers) in patterns:
            - if topic.matches(pattern):
                - for conn_id in pattern_subscribers:
                    - if conn_id not in sent_to:
                        - connection = state.connections.get(conn_id)
                        - if connection and connection.state is Open:
                            - connection.send(message)
                            - add conn_id to sent_to
        
        - emit Published(topic, message, sent_to.size)

  # ==========================================================================
  # ПРОТОКОЛЫ СООБЩЕНИЙ
  # ==========================================================================

  Behavior MessageProtocol:
    """Структурированные протоколы сообщений"""

    Type ProtocolMessage:
      type: String
      payload: Any
      id: String?
      timestamp: Timestamp

    Type RequestMessage:
      id: RequestId
      method: String
      params: Any

    Type ResponseMessage:
      id: RequestId
      result: Any?
      error: ProtocolError?

    Type ProtocolError:
      code: Int
      message: String
      data: Any?

    When parse_protocol_message(raw):
      Then:
        - json = JSON.parse(raw)
        - return ProtocolMessage(
            type: json.type,
            payload: json.payload,
            id: json.id,
            timestamp: json.timestamp ?? now()
          )

    When send_protocol_message(connection, type, payload):
      Then:
        - message = ProtocolMessage(
            type: type,
            payload: payload,
            id: generate_id(),
            timestamp: now()
          )
        - connection.send_json(message)

    # JSON-RPC style request/response
    When connection.request(method, params, timeout):
      Then:
        - request_id = generate_id()
        - request = RequestMessage(
            id: request_id,
            method: method,
            params: params
          )
        
        - promise = create_promise()
        - pending_requests[request_id] = promise
        
        - connection.send_json(request)
        
        - result = await race(
            promise,
            sleep(timeout).then(() -> TimeoutError)
          )
        
        - remove request_id from pending_requests
        - return result

    When connection receives response_message:
      Given pending_requests.has(response_message.id)
      Then:
        - promise = pending_requests[response_message.id]
        - if response_message.error:
            - promise.reject(response_message.error)
        - else:
            - promise.resolve(response_message.result)

  # ==========================================================================
  # АДАПТЕРЫ
  # ==========================================================================

  Behavior SocketIOAdapter:
    """Совместимость с Socket.IO протоколом"""

    Type SocketIOPacket:
      type: PacketType
      namespace: String
      data: Any
      id: Int?

    Type PacketType:
      CONNECT: 0
      DISCONNECT: 1
      EVENT: 2
      ACK: 3
      CONNECT_ERROR: 4
      BINARY_EVENT: 5
      BINARY_ACK: 6

    When parse_socketio_packet(raw):
      Then:
        - type = raw[0].to_int()
        - rest = raw.substring(1)
        - # Parse namespace, data, id...
        - return SocketIOPacket(type, namespace, data, id)

    When connection.emit(event, data):
      """Socket.IO style emit"""
      Then:
        - packet = SocketIOPacket(
            type: EVENT,
            namespace: "/",
            data: [event, data]
          )
        - connection.send_text(encode_socketio(packet))

    When connection.on(event, handler):
      """Socket.IO style event handler"""
      Then:
        - add (event, handler) to connection.event_handlers

  # ==========================================================================
  # SCALING
  # ==========================================================================

  Behavior ClusterSupport:
    """Поддержка кластеризации через Redis/другие адаптеры"""

    Type Adapter:
      variants:
        - Memory
        - Redis: RedisConfig
        - Kafka: KafkaConfig
        - NATS: NATSConfig

    Type RedisConfig:
      url: String
      prefix: String = "ws:"
      pub_channel: String = "ws:pub"
      sub_channel: String = "ws:sub"

    When use_adapter(adapter):
      Then:
        - match adapter:
            - Memory -> use_memory_adapter()
            - Redis(config) -> use_redis_adapter(config)
            - Kafka(config) -> use_kafka_adapter(config)
            - NATS(config) -> use_nats_adapter(config)

    When use_redis_adapter(config):
      Then:
        - pub_client = Redis.connect(config.url)
        - sub_client = Redis.connect(config.url)
        
        # Subscribe to cluster messages
        - sub_client.subscribe(config.sub_channel, (message) ->
            handle_cluster_message(message)
          )
        
        # Override broadcast to publish to Redis
        - original_broadcast = broadcast
        - broadcast = (message) ->
            pub_client.publish(config.pub_channel, serialize(message))

    When handle_cluster_message(message):
      Then:
        - deserialized = deserialize(message)
        - match deserialized.type:
            - "broadcast" -> local_broadcast(deserialized.message)
            - "room_broadcast" -> local_room_broadcast(deserialized.room, deserialized.message)
            - "direct" -> local_send_to(deserialized.connection_id, deserialized.message)

  # ==========================================================================
  # СОБЫТИЯ
  # ==========================================================================

  Events:
    ConnectionOpened:
      connection_id: ConnectionId
      remote_addr: IPAddress
      path: String
      timestamp: Timestamp

    ConnectionClosed:
      connection_id: ConnectionId
      code: CloseCode
      reason: String
      duration: Duration
      messages_count: Int

    MessageReceived:
      connection_id: ConnectionId
      message_type: String
      size: Int
      timestamp: Timestamp

    MessageSent:
      connection_id: ConnectionId
      message_type: String
      size: Int
      timestamp: Timestamp

    RoomCreated:
      room_id: RoomId
      name: String
      timestamp: Timestamp

    RoomDeleted:
      room_id: RoomId
      timestamp: Timestamp

    JoinedRoom:
      connection_id: ConnectionId
      room_id: RoomId
      timestamp: Timestamp

    LeftRoom:
      connection_id: ConnectionId
      room_id: RoomId
      timestamp: Timestamp

    Subscribed:
      connection_id: ConnectionId
      topic: Topic
      timestamp: Timestamp

    Published:
      topic: Topic
      recipients_count: Int
      timestamp: Timestamp

  # ==========================================================================
  # ПРИМЕР ИСПОЛЬЗОВАНИЯ
  # ==========================================================================

  Example "Chat Application":
    ```vibee
    # Создание WebSocket сервера
    ws_server = WebSocketServer(
      config: WebSocketConfig(
        max_connections: 10000,
        ping_interval: 30.seconds
      ),
      handlers: EventHandlers(
        on_connect: (conn) -> 
          log.info("New connection: ${conn.id}")
          true,
        
        on_message: (conn, msg) ->
          handle_chat_message(conn, msg),
        
        on_close: (conn, code, reason) ->
          log.info("Connection closed: ${conn.id}")
      )
    )

    # Обработчик сообщений чата
    handle_chat_message = (conn, msg) ->
      match msg:
        Text(text) ->
          data = JSON.parse(text)
          match data.type:
            "join_room" ->
              conn.join(data.room)
              broadcast_to_room(data.room, JSON({
                type: "user_joined",
                user: conn.user.name
              }))
            
            "leave_room" ->
              broadcast_to_room(data.room, JSON({
                type: "user_left",
                user: conn.user.name
              }))
              conn.leave(data.room)
            
            "message" ->
              broadcast_to_room_except(data.room, JSON({
                type: "message",
                user: conn.user.name,
                text: data.text,
                timestamp: now()
              }), conn.id)
            
            "typing" ->
              broadcast_to_room_except(data.room, JSON({
                type: "typing",
                user: conn.user.name
              }), conn.id)

    # Интеграция с HTTP сервером
    http_server.get("/ws", (req, params) ->
      ws_server.upgrade(req)
    )
    ```

  Example "Real-time Dashboard":
    ```vibee
    # Pub/Sub для метрик
    metrics_ws = WebSocketServer(config)

    # Подписка на метрики
    metrics_ws.handlers.on_message = (conn, msg) ->
      data = JSON.parse(msg.text)
      match data.type:
        "subscribe" ->
          for topic in data.topics:
            conn.subscribe(topic)
        
        "unsubscribe" ->
          for topic in data.topics:
            conn.unsubscribe(topic)

    # Публикация метрик (из другой части системы)
    publish_metric = (name, value) ->
      metrics_ws.publish(
        Topic("metrics.${name}"),
        JSON({
          name: name,
          value: value,
          timestamp: now()
        })
      )

    # Периодическая публикация системных метрик
    every 1.second:
      publish_metric("cpu", get_cpu_usage())
      publish_metric("memory", get_memory_usage())
      publish_metric("requests", get_requests_per_second())
    ```

  Example "Multiplayer Game":
    ```vibee
    # Игровой сервер
    game_ws = WebSocketServer(
      config: WebSocketConfig(
        ping_interval: 5.seconds  # Быстрый пинг для игр
      )
    )

    # Игровые комнаты
    game_ws.handlers.on_message = (conn, msg) ->
      data = JSON.parse(msg.text)
      match data.type:
        "create_game" ->
          room = create_room(generate_game_id(), RoomOptions(
            max_connections: data.max_players,
            metadata: { game_type: data.game_type }
          ))
          conn.join(room.id)
          conn.send_json({ type: "game_created", game_id: room.id })
        
        "join_game" ->
          result = conn.join(data.game_id)
          match result:
            Ok(room) ->
              broadcast_to_room(data.game_id, JSON({
                type: "player_joined",
                player: conn.user
              }))
            Error(e) ->
              conn.send_json({ type: "error", message: e })
        
        "game_action" ->
          # Валидация и применение игрового действия
          action = validate_action(conn, data.action)
          if action.valid:
            game_state = apply_action(data.game_id, action)
            broadcast_to_room(data.game_id, JSON({
              type: "game_state",
              state: game_state
            }))
        
        "player_position" ->
          # Быстрая синхронизация позиции
          broadcast_to_room_except(conn.rooms.first(), JSON({
            type: "player_position",
            player_id: conn.id,
            position: data.position,
            velocity: data.velocity
          }), conn.id)
    ```
