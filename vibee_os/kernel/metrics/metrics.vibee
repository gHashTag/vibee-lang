# ============================================================================
# METRICS - Метрики и мониторинг на Vibee
# ============================================================================
# Counters, Gauges, Histograms, Prometheus, OpenTelemetry
# ============================================================================

Specification Metrics:
  """Метрики как спецификация измерения состояния системы."""

  # ==========================================================================
  # METRIC TYPES
  # ==========================================================================

  Trait Metric:
    Method name() -> String
    Method description() -> String
    Method labels() -> Map<String, String>
    Method collect() -> List<MetricSample>

  Type MetricSample:
    name: String
    value: Float
    timestamp: Instant
    labels: Map<String, String>

  # ==========================================================================
  # COUNTER
  # ==========================================================================

  Type Counter:
    name: String
    description: String
    labels: Map<String, String>
    value: Atomic<Int>

    Static Method new(name: String, description: String) -> Counter:
      return Counter(name, description, {}, Atomic(0))

    Static Method with_labels(name: String, description: String, labels: Map<String, String>) -> Counter:
      return Counter(name, description, labels, Atomic(0))

    Method inc():
      self.value.fetch_add(1)

    Method inc_by(n: Int):
      self.value.fetch_add(n)

    Method get() -> Int:
      return self.value.load()

    Method reset():
      self.value.store(0)

    Trait Metric:
      Method name() -> String:
        return self.name

      Method description() -> String:
        return self.description

      Method labels() -> Map<String, String>:
        return self.labels

      Method collect() -> List<MetricSample>:
        return [MetricSample(
          name: self.name,
          value: self.value.load().to_float(),
          timestamp: Instant.now(),
          labels: self.labels
        )]

  Type CounterVec:
    name: String
    description: String
    label_names: List<String>
    counters: Map<String, Counter>

    Static Method new(name: String, description: String, label_names: List<String>) -> CounterVec:
      return CounterVec(name, description, label_names, {})

    Method with_labels(labels: Map<String, String>) -> Counter:
      key = self.labels_to_key(labels)
      
      if key not in self.counters:
        self.counters[key] = Counter.with_labels(self.name, self.description, labels)
      
      return self.counters[key]

    Method labels_to_key(labels: Map<String, String>) -> String:
      return self.label_names
        .map(name -> "${name}=${labels.get(name) ?? ""}")
        .join(",")

    Trait Metric:
      Method name() -> String:
        return self.name

      Method description() -> String:
        return self.description

      Method labels() -> Map<String, String>:
        return {}

      Method collect() -> List<MetricSample>:
        return self.counters.values().flat_map(c -> c.collect())

  # ==========================================================================
  # GAUGE
  # ==========================================================================

  Type Gauge:
    name: String
    description: String
    labels: Map<String, String>
    value: Atomic<Float>

    Static Method new(name: String, description: String) -> Gauge:
      return Gauge(name, description, {}, Atomic(0.0))

    Static Method with_labels(name: String, description: String, labels: Map<String, String>) -> Gauge:
      return Gauge(name, description, labels, Atomic(0.0))

    Method set(value: Float):
      self.value.store(value)

    Method inc():
      self.value.fetch_add(1.0)

    Method inc_by(n: Float):
      self.value.fetch_add(n)

    Method dec():
      self.value.fetch_add(-1.0)

    Method dec_by(n: Float):
      self.value.fetch_add(-n)

    Method get() -> Float:
      return self.value.load()

    Method set_to_current_time():
      self.value.store(Instant.now().to_unix_secs().to_float())

    Trait Metric:
      Method name() -> String:
        return self.name

      Method description() -> String:
        return self.description

      Method labels() -> Map<String, String>:
        return self.labels

      Method collect() -> List<MetricSample>:
        return [MetricSample(
          name: self.name,
          value: self.value.load(),
          timestamp: Instant.now(),
          labels: self.labels
        )]

  Type GaugeVec:
    name: String
    description: String
    label_names: List<String>
    gauges: Map<String, Gauge>

    Static Method new(name: String, description: String, label_names: List<String>) -> GaugeVec:
      return GaugeVec(name, description, label_names, {})

    Method with_labels(labels: Map<String, String>) -> Gauge:
      key = self.labels_to_key(labels)
      
      if key not in self.gauges:
        self.gauges[key] = Gauge.with_labels(self.name, self.description, labels)
      
      return self.gauges[key]

    Method labels_to_key(labels: Map<String, String>) -> String:
      return self.label_names
        .map(name -> "${name}=${labels.get(name) ?? ""}")
        .join(",")

    Trait Metric:
      Method name() -> String:
        return self.name

      Method description() -> String:
        return self.description

      Method labels() -> Map<String, String>:
        return {}

      Method collect() -> List<MetricSample>:
        return self.gauges.values().flat_map(g -> g.collect())

  # ==========================================================================
  # HISTOGRAM
  # ==========================================================================

  Type Histogram:
    name: String
    description: String
    labels: Map<String, String>
    buckets: List<Float>
    bucket_counts: List<Atomic<Int>>
    sum: Atomic<Float>
    count: Atomic<Int>

    Static Method new(name: String, description: String) -> Histogram:
      return Histogram.with_buckets(name, description, DEFAULT_BUCKETS)

    Static Method with_buckets(name: String, description: String, buckets: List<Float>) -> Histogram:
      return Histogram(
        name: name,
        description: description,
        labels: {},
        buckets: buckets.sorted(),
        bucket_counts: buckets.map(_ -> Atomic(0)),
        sum: Atomic(0.0),
        count: Atomic(0)
      )

    Static Method linear(name: String, description: String, start: Float, width: Float, count: Int) -> Histogram:
      buckets = (0..count).map(i -> start + width * i.to_float()).to_list()
      return Histogram.with_buckets(name, description, buckets)

    Static Method exponential(name: String, description: String, start: Float, factor: Float, count: Int) -> Histogram:
      buckets = (0..count).map(i -> start * pow(factor, i.to_float())).to_list()
      return Histogram.with_buckets(name, description, buckets)

    Method observe(value: Float):
      self.sum.fetch_add(value)
      self.count.fetch_add(1)
      
      for (i, bucket) in self.buckets.enumerate():
        if value <= bucket:
          self.bucket_counts[i].fetch_add(1)

    Method time<T>(f: () -> T) -> T:
      start = Instant.now()
      result = f()
      duration = (Instant.now() - start).as_secs_float()
      self.observe(duration)
      return result

    Method start_timer() -> HistogramTimer:
      return HistogramTimer(self, Instant.now())

    Trait Metric:
      Method name() -> String:
        return self.name

      Method description() -> String:
        return self.description

      Method labels() -> Map<String, String>:
        return self.labels

      Method collect() -> List<MetricSample>:
        samples = []
        now = Instant.now()
        cumulative = 0
        
        for (i, bucket) in self.buckets.enumerate():
          cumulative += self.bucket_counts[i].load()
          samples.push(MetricSample(
            name: "${self.name}_bucket",
            value: cumulative.to_float(),
            timestamp: now,
            labels: self.labels.set("le", bucket.to_string())
          ))
        
        # +Inf bucket
        samples.push(MetricSample(
          name: "${self.name}_bucket",
          value: self.count.load().to_float(),
          timestamp: now,
          labels: self.labels.set("le", "+Inf")
        ))
        
        # Sum and count
        samples.push(MetricSample(
          name: "${self.name}_sum",
          value: self.sum.load(),
          timestamp: now,
          labels: self.labels
        ))
        
        samples.push(MetricSample(
          name: "${self.name}_count",
          value: self.count.load().to_float(),
          timestamp: now,
          labels: self.labels
        ))
        
        return samples

  Type HistogramTimer:
    histogram: Histogram
    start: Instant

    Method observe_duration():
      duration = (Instant.now() - self.start).as_secs_float()
      self.histogram.observe(duration)

  Type HistogramVec:
    name: String
    description: String
    label_names: List<String>
    buckets: List<Float>
    histograms: Map<String, Histogram>

    Static Method new(name: String, description: String, label_names: List<String>) -> HistogramVec:
      return HistogramVec(name, description, label_names, DEFAULT_BUCKETS, {})

    Method with_labels(labels: Map<String, String>) -> Histogram:
      key = self.labels_to_key(labels)
      
      if key not in self.histograms:
        self.histograms[key] = Histogram.with_buckets(self.name, self.description, self.buckets)
        self.histograms[key].labels = labels
      
      return self.histograms[key]

    Method labels_to_key(labels: Map<String, String>) -> String:
      return self.label_names
        .map(name -> "${name}=${labels.get(name) ?? ""}")
        .join(",")

  Const DEFAULT_BUCKETS = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]

  # ==========================================================================
  # SUMMARY
  # ==========================================================================

  Type Summary:
    name: String
    description: String
    labels: Map<String, String>
    quantiles: List<Float>
    max_age: Duration
    values: RingBuffer<(Instant, Float)>
    sum: Atomic<Float>
    count: Atomic<Int>

    Static Method new(name: String, description: String) -> Summary:
      return Summary.with_quantiles(name, description, [0.5, 0.9, 0.99])

    Static Method with_quantiles(name: String, description: String, quantiles: List<Float>) -> Summary:
      return Summary(
        name: name,
        description: description,
        labels: {},
        quantiles: quantiles,
        max_age: Duration.minutes(10),
        values: RingBuffer(10000),
        sum: Atomic(0.0),
        count: Atomic(0)
      )

    Method observe(value: Float):
      now = Instant.now()
      self.values.push((now, value))
      self.sum.fetch_add(value)
      self.count.fetch_add(1)

    Method time<T>(f: () -> T) -> T:
      start = Instant.now()
      result = f()
      duration = (Instant.now() - start).as_secs_float()
      self.observe(duration)
      return result

    Trait Metric:
      Method name() -> String:
        return self.name

      Method description() -> String:
        return self.description

      Method labels() -> Map<String, String>:
        return self.labels

      Method collect() -> List<MetricSample>:
        now = Instant.now()
        cutoff = now - self.max_age
        
        # Filter recent values
        recent = self.values.iter()
          .filter((ts, _) -> ts >= cutoff)
          .map((_, v) -> v)
          .sorted()
          .to_list()
        
        samples = []
        
        for q in self.quantiles:
          value = if recent.is_empty():
            0.0
          else:
            index = (q * (recent.length - 1).to_float()).round().to_int()
            recent[index]
          
          samples.push(MetricSample(
            name: self.name,
            value: value,
            timestamp: now,
            labels: self.labels.set("quantile", q.to_string())
          ))
        
        samples.push(MetricSample(
          name: "${self.name}_sum",
          value: self.sum.load(),
          timestamp: now,
          labels: self.labels
        ))
        
        samples.push(MetricSample(
          name: "${self.name}_count",
          value: self.count.load().to_float(),
          timestamp: now,
          labels: self.labels
        ))
        
        return samples

  # ==========================================================================
  # REGISTRY
  # ==========================================================================

  Type MetricRegistry:
    metrics: Map<String, Metric>

    Static Method global() -> MetricRegistry:
      return GLOBAL_REGISTRY

    Static Method new() -> MetricRegistry:
      return MetricRegistry({})

    Method register(metric: Metric):
      self.metrics[metric.name()] = metric

    Method unregister(name: String):
      self.metrics.remove(name)

    Method get(name: String) -> Option<Metric>:
      return self.metrics.get(name)

    Method collect() -> List<MetricSample>:
      return self.metrics.values().flat_map(m -> m.collect())

    Method counter(name: String, description: String) -> Counter:
      counter = Counter.new(name, description)
      self.register(counter)
      return counter

    Method counter_vec(name: String, description: String, labels: List<String>) -> CounterVec:
      counter = CounterVec.new(name, description, labels)
      self.register(counter)
      return counter

    Method gauge(name: String, description: String) -> Gauge:
      gauge = Gauge.new(name, description)
      self.register(gauge)
      return gauge

    Method gauge_vec(name: String, description: String, labels: List<String>) -> GaugeVec:
      gauge = GaugeVec.new(name, description, labels)
      self.register(gauge)
      return gauge

    Method histogram(name: String, description: String) -> Histogram:
      histogram = Histogram.new(name, description)
      self.register(histogram)
      return histogram

    Method histogram_vec(name: String, description: String, labels: List<String>) -> HistogramVec:
      histogram = HistogramVec.new(name, description, labels)
      self.register(histogram)
      return histogram

  # ==========================================================================
  # PROMETHEUS EXPORTER
  # ==========================================================================

  Behavior PrometheusExporter:
    When prometheus.export(registry: MetricRegistry) -> String:
      Then:
        output = StringBuilder()
        samples = registry.collect()
        
        # Group by metric name
        by_name = samples.group_by(s -> s.name.split("_bucket")[0].split("_sum")[0].split("_count")[0])
        
        for (name, metric_samples) in by_name:
          metric = registry.get(name)
          
          if metric is Some(m):
            output.append("# HELP ${name} ${m.description()}\n")
            output.append("# TYPE ${name} ${get_prometheus_type(m)}\n")
          
          for sample in metric_samples:
            labels_str = if sample.labels.is_empty():
              ""
            else:
              "{" + sample.labels.entries()
                .map((k, v) -> "${k}=\"${escape_label_value(v)}\"")
                .join(",") + "}"
            
            output.append("${sample.name}${labels_str} ${sample.value}\n")
        
        return output.to_string()

    When get_prometheus_type(metric: Metric) -> String:
      Then:
        match metric:
          _: Counter -> "counter"
          _: CounterVec -> "counter"
          _: Gauge -> "gauge"
          _: GaugeVec -> "gauge"
          _: Histogram -> "histogram"
          _: HistogramVec -> "histogram"
          _: Summary -> "summary"
          _ -> "untyped"

    When escape_label_value(value: String) -> String:
      Then:
        return value
          .replace("\\", "\\\\")
          .replace("\"", "\\\"")
          .replace("\n", "\\n")

  # ==========================================================================
  # OPENTELEMETRY EXPORTER
  # ==========================================================================

  Behavior OTLPMetricsExporter:
    When otlp.export(registry: MetricRegistry, endpoint: String):
      Then:
        samples = registry.collect()
        payload = convert_to_otlp_metrics(samples)
        
        http.post(endpoint)
          .header("Content-Type", "application/x-protobuf")
          .body(payload)
          .send()

  # ==========================================================================
  # PUSH GATEWAY
  # ==========================================================================

  Type PushGateway:
    url: String
    job: String
    instance: Option<String>

    Static Method new(url: String, job: String) -> PushGateway:
      return PushGateway(url, job, null)

    Method push(registry: MetricRegistry) -> Result<(), Error>:
      path = "/metrics/job/${url.encode_component(self.job)}"
      
      if self.instance is Some(i):
        path += "/instance/${url.encode_component(i)}"
      
      body = prometheus.export(registry)
      
      return http.post("${self.url}${path}")
        .header("Content-Type", "text/plain")
        .body(body)
        .send()
        .map(_ -> ())

    Method push_add(registry: MetricRegistry) -> Result<(), Error>:
      # Same as push but uses POST instead of PUT
      path = "/metrics/job/${url.encode_component(self.job)}"
      
      if self.instance is Some(i):
        path += "/instance/${url.encode_component(i)}"
      
      body = prometheus.export(registry)
      
      return http.post("${self.url}${path}")
        .header("Content-Type", "text/plain")
        .body(body)
        .send()
        .map(_ -> ())

    Method delete() -> Result<(), Error>:
      path = "/metrics/job/${url.encode_component(self.job)}"
      
      if self.instance is Some(i):
        path += "/instance/${url.encode_component(i)}"
      
      return http.delete("${self.url}${path}")
        .send()
        .map(_ -> ())

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Metrics":
    ```vibee
    # Create metrics
    requests_total = Counter.new("http_requests_total", "Total HTTP requests")
    requests_total.inc()
    requests_total.inc_by(5)

    # Counter with labels
    requests = CounterVec.new(
      "http_requests",
      "HTTP requests by method and status",
      ["method", "status"]
    )

    requests.with_labels({"method": "GET", "status": "200"}).inc()
    requests.with_labels({"method": "POST", "status": "201"}).inc()

    # Gauge
    active_connections = Gauge.new("active_connections", "Active connections")
    active_connections.set(42)
    active_connections.inc()
    active_connections.dec()

    # Gauge with labels
    temperature = GaugeVec.new("temperature", "Temperature by location", ["location"])
    temperature.with_labels({"location": "server_room"}).set(22.5)

    # Histogram
    request_duration = Histogram.new(
      "http_request_duration_seconds",
      "HTTP request duration"
    )

    # Observe directly
    request_duration.observe(0.25)

    # Time a function
    result = request_duration.time(() -> {
      process_request()
    })

    # Timer pattern
    timer = request_duration.start_timer()
    # ... do work ...
    timer.observe_duration()

    # Custom buckets
    response_size = Histogram.with_buckets(
      "http_response_size_bytes",
      "Response size",
      [100, 1000, 10000, 100000, 1000000]
    )

    # Linear buckets
    latency = Histogram.linear("latency_ms", "Latency", 0, 10, 20)  # 0, 10, 20, ..., 190

    # Exponential buckets
    duration = Histogram.exponential("duration_seconds", "Duration", 0.001, 2, 10)

    # Summary with quantiles
    summary = Summary.with_quantiles(
      "request_latency",
      "Request latency",
      [0.5, 0.9, 0.95, 0.99]
    )

    # Registry
    registry = MetricRegistry.new()
    counter = registry.counter("my_counter", "My counter")
    gauge = registry.gauge("my_gauge", "My gauge")

    # Export to Prometheus format
    output = prometheus.export(registry)
    # http_requests_total 6
    # active_connections 43
    # http_request_duration_seconds_bucket{le="0.005"} 0
    # ...

    # HTTP endpoint for Prometheus scraping
    http.get("/metrics", (req, res) -> {
      res.header("Content-Type", "text/plain")
      res.body(prometheus.export(MetricRegistry.global()))
    })

    # Push to Pushgateway
    gateway = PushGateway.new("http://pushgateway:9091", "my_job")
    gateway.push(registry)?

    # OTLP export
    otlp.export(registry, "http://otel-collector:4317/v1/metrics")
    ```
