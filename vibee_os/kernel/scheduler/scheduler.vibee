# ============================================================================
# SCHEDULER - Планировщик задач на Vibee
# ============================================================================
# Cron, Intervals, Delayed tasks, Job scheduling
# ============================================================================

Specification Scheduler:
  """Планировщик как спецификация отложенного выполнения задач."""

  # ==========================================================================
  # SCHEDULER
  # ==========================================================================

  Type Scheduler:
    jobs: Map<String, ScheduledJob>
    running: Atomic<Boolean>
    worker: Option<Task>
    mutex: Mutex

    Static Method new() -> Scheduler:
      return Scheduler({}, Atomic(false), null, Mutex.new())

    Static Method global() -> Scheduler:
      return GLOBAL_SCHEDULER

    Method start():
      if self.running.compare_exchange(false, true):
        self.worker = Some(spawn {
          self.run_loop()
        })

    Method stop():
      self.running.store(false)
      if self.worker is Some(w):
        w.cancel()

    Method run_loop():
      while self.running.load():
        now = Instant.now()
        
        guard = self.mutex.lock()
        for (id, job) in self.jobs:
          if job.should_run(now):
            spawn {
              job.execute()
            }
            job.update_last_run(now)
            job.update_next_run()
        drop(guard)
        
        sleep(Duration.millis(100))

    Method schedule(job: ScheduledJob) -> String:
      guard = self.mutex.lock()
      id = job.id
      self.jobs[id] = job
      return id

    Method schedule_cron(name: String, cron: String, task: () -> ()) -> Result<String, CronError>:
      schedule = CronSchedule.parse(cron)?
      job = ScheduledJob.cron(name, schedule, task)
      return Ok(self.schedule(job))

    Method schedule_interval(name: String, interval: Duration, task: () -> ()) -> String:
      job = ScheduledJob.interval(name, interval, task)
      return self.schedule(job)

    Method schedule_at(name: String, time: DateTime, task: () -> ()) -> String:
      job = ScheduledJob.once(name, time, task)
      return self.schedule(job)

    Method schedule_after(name: String, delay: Duration, task: () -> ()) -> String:
      time = DateTime.now() + delay
      job = ScheduledJob.once(name, time, task)
      return self.schedule(job)

    Method cancel(job_id: String) -> Boolean:
      guard = self.mutex.lock()
      return self.jobs.remove(job_id) != null

    Method pause(job_id: String) -> Boolean:
      guard = self.mutex.lock()
      if self.jobs.get(job_id) is Some(job):
        job.paused = true
        return true
      return false

    Method resume(job_id: String) -> Boolean:
      guard = self.mutex.lock()
      if self.jobs.get(job_id) is Some(job):
        job.paused = false
        return true
      return false

    Method list_jobs() -> List<JobInfo>:
      guard = self.mutex.lock()
      return self.jobs.values().map(j -> j.info()).to_list()

    Method get_job(job_id: String) -> Option<JobInfo>:
      guard = self.mutex.lock()
      return self.jobs.get(job_id).map(j -> j.info())

    Method run_now(job_id: String) -> Boolean:
      guard = self.mutex.lock()
      if self.jobs.get(job_id) is Some(job):
        spawn { job.execute() }
        return true
      return false

  # ==========================================================================
  # SCHEDULED JOB
  # ==========================================================================

  Type ScheduledJob:
    id: String
    name: String
    schedule: JobSchedule
    task: () -> ()
    last_run: Option<Instant>
    next_run: Option<Instant>
    run_count: Int
    paused: Boolean
    max_runs: Option<Int>
    timeout: Option<Duration>
    retry_config: Option<RetryConfig>
    on_success: Option<() -> ()>
    on_failure: Option<(Error) -> ()>

    Static Method cron(name: String, schedule: CronSchedule, task: () -> ()) -> ScheduledJob:
      job = ScheduledJob(
        id: UUID.v4().to_string(),
        name: name,
        schedule: JobSchedule.Cron(schedule),
        task: task,
        last_run: null,
        next_run: null,
        run_count: 0,
        paused: false,
        max_runs: null,
        timeout: null,
        retry_config: null,
        on_success: null,
        on_failure: null
      )
      job.update_next_run()
      return job

    Static Method interval(name: String, interval: Duration, task: () -> ()) -> ScheduledJob:
      job = ScheduledJob(
        id: UUID.v4().to_string(),
        name: name,
        schedule: JobSchedule.Interval(interval),
        task: task,
        last_run: null,
        next_run: Some(Instant.now() + interval),
        run_count: 0,
        paused: false,
        max_runs: null,
        timeout: null,
        retry_config: null,
        on_success: null,
        on_failure: null
      )
      return job

    Static Method once(name: String, time: DateTime, task: () -> ()) -> ScheduledJob:
      return ScheduledJob(
        id: UUID.v4().to_string(),
        name: name,
        schedule: JobSchedule.Once(time),
        task: task,
        last_run: null,
        next_run: Some(time.to_instant()),
        run_count: 0,
        paused: false,
        max_runs: Some(1),
        timeout: null,
        retry_config: null,
        on_success: null,
        on_failure: null
      )

    Method should_run(now: Instant) -> Boolean:
      if self.paused:
        return false
      
      if self.max_runs is Some(max) and self.run_count >= max:
        return false
      
      if self.next_run is Some(next):
        return now >= next
      
      return false

    Method execute():
      try:
        if self.timeout is Some(t):
          timeout_call(t, self.task)
        else:
          self.task()
        
        self.run_count += 1
        
        if self.on_success is Some(callback):
          callback()
      catch error:
        if self.retry_config is Some(config):
          self.retry_with_config(config, error)
        else if self.on_failure is Some(callback):
          callback(error)

    Method retry_with_config(config: RetryConfig, error: Error):
      for attempt in 0..config.max_attempts:
        delay = config.calculate_delay(attempt)
        sleep(delay)
        
        try:
          self.task()
          return
        catch e:
          error = e
      
      if self.on_failure is Some(callback):
        callback(error)

    Method update_last_run(time: Instant):
      self.last_run = Some(time)

    Method update_next_run():
      match self.schedule:
        Cron(schedule) ->
          self.next_run = schedule.next_occurrence()
        Interval(duration) ->
          base = self.last_run.unwrap_or(Instant.now())
          self.next_run = Some(base + duration)
        Once(_) ->
          if self.run_count > 0:
            self.next_run = null

    Method info() -> JobInfo:
      return JobInfo(
        id: self.id,
        name: self.name,
        schedule: self.schedule.to_string(),
        last_run: self.last_run,
        next_run: self.next_run,
        run_count: self.run_count,
        paused: self.paused
      )

    Method with_timeout(timeout: Duration) -> ScheduledJob:
      return ScheduledJob(..self, timeout: Some(timeout))

    Method with_retry(config: RetryConfig) -> ScheduledJob:
      return ScheduledJob(..self, retry_config: Some(config))

    Method with_max_runs(max: Int) -> ScheduledJob:
      return ScheduledJob(..self, max_runs: Some(max))

    Method on_success(callback: () -> ()) -> ScheduledJob:
      return ScheduledJob(..self, on_success: Some(callback))

    Method on_failure(callback: (Error) -> ()) -> ScheduledJob:
      return ScheduledJob(..self, on_failure: Some(callback))

  Type JobSchedule:
    variants:
      - Cron(CronSchedule)
      - Interval(Duration)
      - Once(DateTime)

    Method to_string() -> String:
      match self:
        Cron(s) -> s.to_string()
        Interval(d) -> "every ${d}"
        Once(t) -> "at ${t}"

  Type JobInfo:
    id: String
    name: String
    schedule: String
    last_run: Option<Instant>
    next_run: Option<Instant>
    run_count: Int
    paused: Boolean

  # ==========================================================================
  # CRON SCHEDULE
  # ==========================================================================

  Type CronSchedule:
    minute: CronField
    hour: CronField
    day_of_month: CronField
    month: CronField
    day_of_week: CronField
    second: Option<CronField>

    Static Method parse(expr: String) -> Result<CronSchedule, CronError>:
      parts = expr.trim().split(" ")
      
      if parts.length == 5:
        return Ok(CronSchedule(
          minute: CronField.parse(parts[0], 0, 59)?,
          hour: CronField.parse(parts[1], 0, 23)?,
          day_of_month: CronField.parse(parts[2], 1, 31)?,
          month: CronField.parse(parts[3], 1, 12)?,
          day_of_week: CronField.parse(parts[4], 0, 6)?,
          second: null
        ))
      else if parts.length == 6:
        return Ok(CronSchedule(
          second: Some(CronField.parse(parts[0], 0, 59)?),
          minute: CronField.parse(parts[1], 0, 59)?,
          hour: CronField.parse(parts[2], 0, 23)?,
          day_of_month: CronField.parse(parts[3], 1, 31)?,
          month: CronField.parse(parts[4], 1, 12)?,
          day_of_week: CronField.parse(parts[5], 0, 6)?
        ))
      else:
        return Err(CronError("Invalid cron expression"))

    Static Method every_minute() -> CronSchedule:
      return CronSchedule.parse("* * * * *").unwrap()

    Static Method every_hour() -> CronSchedule:
      return CronSchedule.parse("0 * * * *").unwrap()

    Static Method every_day(hour: Int, minute: Int) -> CronSchedule:
      return CronSchedule.parse("${minute} ${hour} * * *").unwrap()

    Static Method every_week(day: Int, hour: Int, minute: Int) -> CronSchedule:
      return CronSchedule.parse("${minute} ${hour} * * ${day}").unwrap()

    Static Method every_month(day: Int, hour: Int, minute: Int) -> CronSchedule:
      return CronSchedule.parse("${minute} ${hour} ${day} * *").unwrap()

    Method matches(dt: DateTime) -> Boolean:
      if self.second is Some(s):
        if not s.matches(dt.second()):
          return false
      
      return self.minute.matches(dt.minute()) and
             self.hour.matches(dt.hour()) and
             self.day_of_month.matches(dt.day()) and
             self.month.matches(dt.month()) and
             self.day_of_week.matches(dt.weekday())

    Method next_occurrence() -> Option<Instant>:
      return self.next_occurrence_after(DateTime.now())

    Method next_occurrence_after(start: DateTime) -> Option<Instant>:
      dt = start + Duration.seconds(1)
      
      # Reset seconds if not specified
      if self.second == null:
        dt = dt.with_second(0)
      
      # Search for next matching time (max 4 years)
      max_iterations = 4 * 365 * 24 * 60
      
      for _ in 0..max_iterations:
        if self.matches(dt):
          return Some(dt.to_instant())
        
        # Increment by smallest unit
        if self.second != null:
          dt = dt + Duration.seconds(1)
        else:
          dt = dt + Duration.minutes(1)
      
      return null

    Method to_string() -> String:
      parts = [
        self.minute.to_string(),
        self.hour.to_string(),
        self.day_of_month.to_string(),
        self.month.to_string(),
        self.day_of_week.to_string()
      ]
      
      if self.second is Some(s):
        parts = [s.to_string()] + parts
      
      return parts.join(" ")

  Type CronField:
    values: Set<Int>
    min: Int
    max: Int

    Static Method parse(expr: String, min: Int, max: Int) -> Result<CronField, CronError>:
      values = Set()
      
      for part in expr.split(","):
        if part == "*":
          for i in min..=max:
            values.add(i)
        else if part.contains("/"):
          # Step values: */5 or 0-30/5
          parts = part.split("/")
          step = parse_int(parts[1])?
          
          range_part = parts[0]
          if range_part == "*":
            for i in (min..=max).step_by(step):
              values.add(i)
          else:
            range_values = parse_range(range_part, min, max)?
            for i in range_values.step_by(step):
              values.add(i)
        else if part.contains("-"):
          # Range: 1-5
          range_values = parse_range(part, min, max)?
          for i in range_values:
            values.add(i)
        else:
          # Single value
          value = parse_int(part)?
          if value < min or value > max:
            return Err(CronError("Value ${value} out of range ${min}-${max}"))
          values.add(value)
      
      return Ok(CronField(values, min, max))

    Method matches(value: Int) -> Boolean:
      return value in self.values

    Method to_string() -> String:
      if self.values.length == self.max - self.min + 1:
        return "*"
      return self.values.to_list().sorted().map(v -> v.to_string()).join(",")

  Type CronError:
    message: String

  # ==========================================================================
  # FLUENT SCHEDULER BUILDER
  # ==========================================================================

  Type SchedulerBuilder:
    scheduler: Scheduler

    Static Method new() -> SchedulerBuilder:
      return SchedulerBuilder(Scheduler.new())

    Method every(interval: Duration) -> JobBuilder:
      return JobBuilder(self.scheduler, JobSchedule.Interval(interval))

    Method cron(expr: String) -> Result<JobBuilder, CronError>:
      schedule = CronSchedule.parse(expr)?
      return Ok(JobBuilder(self.scheduler, JobSchedule.Cron(schedule)))

    Method at(time: DateTime) -> JobBuilder:
      return JobBuilder(self.scheduler, JobSchedule.Once(time))

    Method after(delay: Duration) -> JobBuilder:
      time = DateTime.now() + delay
      return JobBuilder(self.scheduler, JobSchedule.Once(time))

    Method daily_at(hour: Int, minute: Int) -> JobBuilder:
      schedule = CronSchedule.every_day(hour, minute)
      return JobBuilder(self.scheduler, JobSchedule.Cron(schedule))

    Method weekly_on(day: Int, hour: Int, minute: Int) -> JobBuilder:
      schedule = CronSchedule.every_week(day, hour, minute)
      return JobBuilder(self.scheduler, JobSchedule.Cron(schedule))

    Method monthly_on(day: Int, hour: Int, minute: Int) -> JobBuilder:
      schedule = CronSchedule.every_month(day, hour, minute)
      return JobBuilder(self.scheduler, JobSchedule.Cron(schedule))

    Method build() -> Scheduler:
      return self.scheduler

  Type JobBuilder:
    scheduler: Scheduler
    schedule: JobSchedule
    name: Option<String>
    timeout: Option<Duration>
    retry_config: Option<RetryConfig>
    max_runs: Option<Int>

    Method named(name: String) -> JobBuilder:
      return JobBuilder(..self, name: Some(name))

    Method with_timeout(timeout: Duration) -> JobBuilder:
      return JobBuilder(..self, timeout: Some(timeout))

    Method with_retry(config: RetryConfig) -> JobBuilder:
      return JobBuilder(..self, retry_config: Some(config))

    Method max_runs(n: Int) -> JobBuilder:
      return JobBuilder(..self, max_runs: Some(n))

    Method do(task: () -> ()) -> String:
      job_name = self.name.unwrap_or("job_${UUID.v4()}")
      
      job = match self.schedule:
        Cron(s) -> ScheduledJob.cron(job_name, s, task)
        Interval(d) -> ScheduledJob.interval(job_name, d, task)
        Once(t) -> ScheduledJob.once(job_name, t, task)
      
      if self.timeout is Some(t):
        job = job.with_timeout(t)
      
      if self.retry_config is Some(r):
        job = job.with_retry(r)
      
      if self.max_runs is Some(n):
        job = job.with_max_runs(n)
      
      return self.scheduler.schedule(job)

  # ==========================================================================
  # DISTRIBUTED SCHEDULER
  # ==========================================================================

  Type DistributedScheduler:
    scheduler: Scheduler
    lock_provider: DistributedLockProvider
    node_id: String

    Static Method new(lock_provider: DistributedLockProvider) -> DistributedScheduler:
      return DistributedScheduler(
        scheduler: Scheduler.new(),
        lock_provider: lock_provider,
        node_id: UUID.v4().to_string()
      )

    Method schedule(job: ScheduledJob) -> String:
      # Wrap task with distributed lock
      original_task = job.task
      job.task = () -> {
        lock_key = "scheduler:job:${job.id}"
        
        if self.lock_provider.try_acquire(lock_key, Duration.minutes(5)):
          try:
            original_task()
          finally:
            self.lock_provider.release(lock_key)
      }
      
      return self.scheduler.schedule(job)

    Method start():
      self.scheduler.start()

    Method stop():
      self.scheduler.stop()

  Trait DistributedLockProvider:
    Method try_acquire(key: String, ttl: Duration) -> Boolean
    Method release(key: String)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Scheduler":
    ```vibee
    # Create scheduler
    scheduler = Scheduler.new()
    scheduler.start()

    # Schedule with cron expression
    scheduler.schedule_cron("cleanup", "0 0 * * *", () -> {
      cleanup_old_files()
    })?

    # Every 5 minutes
    scheduler.schedule_cron("health_check", "*/5 * * * *", () -> {
      check_system_health()
    })?

    # Schedule interval
    scheduler.schedule_interval("metrics", Duration.seconds(30), () -> {
      collect_metrics()
    })

    # Schedule once
    scheduler.schedule_at("reminder", DateTime.parse("2024-12-25 09:00:00"), () -> {
      send_reminder()
    })

    # Schedule after delay
    scheduler.schedule_after("delayed", Duration.hours(1), () -> {
      process_delayed_task()
    })

    # Fluent API
    builder = SchedulerBuilder.new()

    builder.every(Duration.minutes(5))
      .named("sync_data")
      .with_timeout(Duration.minutes(2))
      .do(() -> sync_data())

    builder.cron("0 9 * * 1-5")?  # 9 AM weekdays
      .named("daily_report")
      .do(() -> generate_report())

    builder.daily_at(3, 0)  # 3 AM
      .named("nightly_backup")
      .with_retry(RetryConfig.default())
      .do(() -> backup_database())

    builder.weekly_on(0, 10, 0)  # Sunday 10 AM
      .named("weekly_summary")
      .do(() -> send_weekly_summary())

    scheduler = builder.build()
    scheduler.start()

    # Job management
    jobs = scheduler.list_jobs()
    for job in jobs:
      print("${job.name}: next run at ${job.next_run}")

    scheduler.pause("sync_data")
    scheduler.resume("sync_data")
    scheduler.run_now("sync_data")
    scheduler.cancel("sync_data")

    # Cron expressions
    # ┌───────────── minute (0 - 59)
    # │ ┌───────────── hour (0 - 23)
    # │ │ ┌───────────── day of month (1 - 31)
    # │ │ │ ┌───────────── month (1 - 12)
    # │ │ │ │ ┌───────────── day of week (0 - 6) (Sunday = 0)
    # │ │ │ │ │
    # * * * * *

    "* * * * *"       # Every minute
    "*/5 * * * *"     # Every 5 minutes
    "0 * * * *"       # Every hour
    "0 0 * * *"       # Every day at midnight
    "0 9 * * 1-5"     # 9 AM on weekdays
    "0 0 1 * *"       # First day of month
    "0 0 * * 0"       # Every Sunday

    # With callbacks
    job = ScheduledJob.interval("task", Duration.minutes(1), () -> {
      risky_operation()
    })
      .with_timeout(Duration.seconds(30))
      .with_retry(RetryConfig(max_attempts: 3))
      .on_success(() -> log.info("Task completed"))
      .on_failure(e -> alert.send("Task failed: ${e}"))

    scheduler.schedule(job)

    # Distributed scheduler (for multiple instances)
    lock_provider = RedisLockProvider.new(redis_client)
    dist_scheduler = DistributedScheduler.new(lock_provider)

    dist_scheduler.schedule(ScheduledJob.cron(
      "singleton_job",
      CronSchedule.every_minute(),
      () -> {
        # Only one instance will run this
        process_queue()
      }
    ))

    dist_scheduler.start()
    ```
