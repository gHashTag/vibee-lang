# ============================================================================
# FSM - Конечные автоматы на Vibee
# ============================================================================
# State Machine, Transitions, Guards, Actions, Hierarchical States
# ============================================================================

Specification FSM:
  """Конечный автомат как спецификация управления состояниями."""

  # ==========================================================================
  # STATE MACHINE
  # ==========================================================================

  Type StateMachine<S, E, C>:
    """
    S - State type
    E - Event type  
    C - Context type
    """
    current_state: S
    context: C
    config: StateMachineConfig<S, E, C>
    history: List<StateTransition<S, E>>
    listeners: List<StateChangeListener<S, E, C>>
    mutex: Mutex

    Static Method new(config: StateMachineConfig<S, E, C>) -> StateMachine<S, E, C>:
      return StateMachine(
        current_state: config.initial_state,
        context: config.initial_context,
        config: config,
        history: [],
        listeners: [],
        mutex: Mutex.new()
      )

    Method state() -> S:
      return self.current_state

    Method send(event: E) -> TransitionResult<S>:
      guard = self.mutex.lock()
      
      # Find matching transition
      transitions = self.config.transitions.get(self.current_state)
      
      if transitions == null:
        return TransitionResult.NoTransition
      
      for transition in transitions:
        if transition.event == event:
          # Check guard
          if transition.guard is Some(g):
            if not g(self.context, event):
              continue
          
          # Execute transition
          return self.execute_transition(transition, event)
      
      return TransitionResult.NoTransition

    Method execute_transition(transition: Transition<S, E, C>, event: E) -> TransitionResult<S>:
      from_state = self.current_state
      to_state = transition.target
      
      # Exit actions
      if self.config.on_exit.get(from_state) is Some(actions):
        for action in actions:
          action(self.context)
      
      # Transition action
      if transition.action is Some(a):
        a(self.context, event)
      
      # Update state
      self.current_state = to_state
      
      # Entry actions
      if self.config.on_entry.get(to_state) is Some(actions):
        for action in actions:
          action(self.context)
      
      # Record history
      record = StateTransition(
        from: from_state,
        to: to_state,
        event: event,
        timestamp: Instant.now()
      )
      self.history.push(record)
      
      # Notify listeners
      for listener in self.listeners:
        listener.on_transition(from_state, to_state, event, self.context)
      
      return TransitionResult.Success(to_state)

    Method can_send(event: E) -> Boolean:
      transitions = self.config.transitions.get(self.current_state)
      
      if transitions == null:
        return false
      
      for transition in transitions:
        if transition.event == event:
          if transition.guard is Some(g):
            return g(self.context, event)
          return true
      
      return false

    Method available_events() -> List<E>:
      transitions = self.config.transitions.get(self.current_state)
      
      if transitions == null:
        return []
      
      return transitions
        .filter(t -> {
          if t.guard is Some(g):
            g(self.context, t.event)
          else:
            true
        })
        .map(t -> t.event)

    Method is_in_state(state: S) -> Boolean:
      return self.current_state == state

    Method is_final() -> Boolean:
      return self.current_state in self.config.final_states

    Method reset():
      guard = self.mutex.lock()
      self.current_state = self.config.initial_state
      self.context = self.config.initial_context
      self.history.clear()

    Method add_listener(listener: StateChangeListener<S, E, C>):
      self.listeners.push(listener)

    Method get_history() -> List<StateTransition<S, E>>:
      return self.history.clone()

  Type StateMachineConfig<S, E, C>:
    initial_state: S
    initial_context: C
    transitions: Map<S, List<Transition<S, E, C>>>
    on_entry: Map<S, List<(C) -> ()>>
    on_exit: Map<S, List<(C) -> ()>>
    final_states: Set<S>

  Type Transition<S, E, C>:
    event: E
    target: S
    guard: Option<(C, E) -> Boolean>
    action: Option<(C, E) -> ()>

  Type StateTransition<S, E>:
    from: S
    to: S
    event: E
    timestamp: Instant

  Type TransitionResult<S>:
    variants:
      - Success(S)
      - NoTransition
      - GuardFailed

  Trait StateChangeListener<S, E, C>:
    Method on_transition(from: S, to: S, event: E, context: C)

  # ==========================================================================
  # STATE MACHINE BUILDER
  # ==========================================================================

  Type StateMachineBuilder<S, E, C>:
    initial_state: Option<S>
    initial_context: Option<C>
    transitions: Map<S, List<Transition<S, E, C>>>
    on_entry: Map<S, List<(C) -> ()>>
    on_exit: Map<S, List<(C) -> ()>>
    final_states: Set<S>

    Static Method new() -> StateMachineBuilder<S, E, C>:
      return StateMachineBuilder(null, null, {}, {}, {}, Set())

    Method initial(state: S) -> StateMachineBuilder<S, E, C>:
      return StateMachineBuilder(..self, initial_state: Some(state))

    Method context(ctx: C) -> StateMachineBuilder<S, E, C>:
      return StateMachineBuilder(..self, initial_context: Some(ctx))

    Method transition(from: S, event: E, to: S) -> StateMachineBuilder<S, E, C>:
      transition = Transition(event: event, target: to, guard: null, action: null)
      return self.add_transition(from, transition)

    Method transition_with_guard(from: S, event: E, to: S, guard: (C, E) -> Boolean) -> StateMachineBuilder<S, E, C>:
      transition = Transition(event: event, target: to, guard: Some(guard), action: null)
      return self.add_transition(from, transition)

    Method transition_with_action(from: S, event: E, to: S, action: (C, E) -> ()) -> StateMachineBuilder<S, E, C>:
      transition = Transition(event: event, target: to, guard: null, action: Some(action))
      return self.add_transition(from, transition)

    Method transition_full(from: S, event: E, to: S, guard: (C, E) -> Boolean, action: (C, E) -> ()) -> StateMachineBuilder<S, E, C>:
      transition = Transition(event: event, target: to, guard: Some(guard), action: Some(action))
      return self.add_transition(from, transition)

    Method add_transition(from: S, transition: Transition<S, E, C>) -> StateMachineBuilder<S, E, C>:
      transitions = self.transitions.clone()
      if from not in transitions:
        transitions[from] = []
      transitions[from].push(transition)
      return StateMachineBuilder(..self, transitions: transitions)

    Method on_entry(state: S, action: (C) -> ()) -> StateMachineBuilder<S, E, C>:
      on_entry = self.on_entry.clone()
      if state not in on_entry:
        on_entry[state] = []
      on_entry[state].push(action)
      return StateMachineBuilder(..self, on_entry: on_entry)

    Method on_exit(state: S, action: (C) -> ()) -> StateMachineBuilder<S, E, C>:
      on_exit = self.on_exit.clone()
      if state not in on_exit:
        on_exit[state] = []
      on_exit[state].push(action)
      return StateMachineBuilder(..self, on_exit: on_exit)

    Method final_state(state: S) -> StateMachineBuilder<S, E, C>:
      final_states = self.final_states.clone()
      final_states.add(state)
      return StateMachineBuilder(..self, final_states: final_states)

    Method build() -> StateMachine<S, E, C>:
      config = StateMachineConfig(
        initial_state: self.initial_state.expect("Initial state required"),
        initial_context: self.initial_context.expect("Initial context required"),
        transitions: self.transitions,
        on_entry: self.on_entry,
        on_exit: self.on_exit,
        final_states: self.final_states
      )
      return StateMachine.new(config)

  # ==========================================================================
  # HIERARCHICAL STATE MACHINE
  # ==========================================================================

  Type HierarchicalStateMachine<S, E, C>:
    root: StateNode<S, E, C>
    current_path: List<S>
    context: C
    listeners: List<StateChangeListener<S, E, C>>

    Static Method new(root: StateNode<S, E, C>, context: C) -> HierarchicalStateMachine<S, E, C>:
      initial_path = compute_initial_path(root)
      return HierarchicalStateMachine(root, initial_path, context, [])

    Method state() -> S:
      return self.current_path.last()

    Method state_path() -> List<S>:
      return self.current_path.clone()

    Method is_in_state(state: S) -> Boolean:
      return state in self.current_path

    Method send(event: E) -> TransitionResult<S>:
      # Try transitions from innermost to outermost state
      for i in (self.current_path.length - 1)..=0 by -1:
        state = self.current_path[i]
        node = self.find_node(state)
        
        if node == null:
          continue
        
        for transition in node.transitions:
          if transition.event == event:
            if transition.guard is Some(g):
              if not g(self.context, event):
                continue
            
            return self.execute_transition(transition, event, i)
      
      return TransitionResult.NoTransition

    Method execute_transition(transition: Transition<S, E, C>, event: E, level: Int) -> TransitionResult<S>:
      # Exit states from current to transition level
      for i in (self.current_path.length - 1)..=level by -1:
        state = self.current_path[i]
        node = self.find_node(state)
        if node != null and node.on_exit is Some(action):
          action(self.context)
      
      # Transition action
      if transition.action is Some(a):
        a(self.context, event)
      
      # Compute new path
      target_node = self.find_node(transition.target)
      new_path = self.current_path.slice(0, level)
      new_path.push(transition.target)
      
      # Add initial substates
      while target_node != null and target_node.initial is Some(initial):
        new_path.push(initial)
        target_node = self.find_node(initial)
      
      # Entry actions for new states
      for i in level..new_path.length:
        state = new_path[i]
        node = self.find_node(state)
        if node != null and node.on_entry is Some(action):
          action(self.context)
      
      self.current_path = new_path
      
      return TransitionResult.Success(self.state())

    Method find_node(state: S) -> Option<StateNode<S, E, C>>:
      return find_node_recursive(self.root, state)

  Type StateNode<S, E, C>:
    state: S
    transitions: List<Transition<S, E, C>>
    children: List<StateNode<S, E, C>>
    initial: Option<S>
    on_entry: Option<(C) -> ()>
    on_exit: Option<(C) -> ()>
    is_final: Boolean

  # ==========================================================================
  # PARALLEL STATE MACHINE
  # ==========================================================================

  Type ParallelStateMachine<S, E, C>:
    regions: Map<String, StateMachine<S, E, C>>
    context: C

    Static Method new(regions: Map<String, StateMachineConfig<S, E, C>>, context: C) -> ParallelStateMachine<S, E, C>:
      machines = regions.map_values(config -> StateMachine.new(config))
      return ParallelStateMachine(machines, context)

    Method send(event: E) -> Map<String, TransitionResult<S>>:
      results = {}
      for (name, machine) in self.regions:
        results[name] = machine.send(event)
      return results

    Method state(region: String) -> Option<S>:
      return self.regions.get(region).map(m -> m.state())

    Method all_states() -> Map<String, S>:
      return self.regions.map_values(m -> m.state())

    Method is_in_state(region: String, state: S) -> Boolean:
      return self.regions.get(region).map(m -> m.is_in_state(state)).unwrap_or(false)

    Method all_final() -> Boolean:
      return self.regions.values().all(m -> m.is_final())

  # ==========================================================================
  # ASYNC STATE MACHINE
  # ==========================================================================

  Type AsyncStateMachine<S, E, C>:
    machine: StateMachine<S, E, C>
    event_queue: Channel<E>
    running: Atomic<Boolean>

    Static Method new(config: StateMachineConfig<S, E, C>) -> AsyncStateMachine<S, E, C>:
      return AsyncStateMachine(
        machine: StateMachine.new(config),
        event_queue: Channel.unbounded(),
        running: Atomic(false)
      )

    Method start():
      if self.running.compare_exchange(false, true):
        spawn {
          while self.running.load():
            event = self.event_queue.recv()
            self.machine.send(event)
        }

    Method stop():
      self.running.store(false)

    Method send(event: E):
      self.event_queue.send(event)

    Method send_async(event: E) -> Promise<TransitionResult<S>>:
      return Promise.new((resolve, _) -> {
        result = self.machine.send(event)
        resolve(result)
      })

    Method state() -> S:
      return self.machine.state()

  # ==========================================================================
  # DECLARATIVE DSL
  # ==========================================================================

  Behavior StateMachineDSL:
    When define_machine<S, E, C>(definition: StateMachineDefinition<S, E, C>) -> StateMachine<S, E, C>:
      Then:
        builder = StateMachineBuilder<S, E, C>.new()
          .initial(definition.initial)
          .context(definition.context)
        
        for state_def in definition.states:
          for transition in state_def.transitions:
            builder = builder.transition_full(
              state_def.state,
              transition.on,
              transition.to,
              transition.guard ?? (_ -> true),
              transition.action ?? (_ -> {})
            )
          
          if state_def.on_entry is Some(action):
            builder = builder.on_entry(state_def.state, action)
          
          if state_def.on_exit is Some(action):
            builder = builder.on_exit(state_def.state, action)
          
          if state_def.is_final:
            builder = builder.final_state(state_def.state)
        
        return builder.build()

  Type StateMachineDefinition<S, E, C>:
    initial: S
    context: C
    states: List<StateDefinition<S, E, C>>

  Type StateDefinition<S, E, C>:
    state: S
    transitions: List<TransitionDefinition<S, E, C>>
    on_entry: Option<(C) -> ()>
    on_exit: Option<(C) -> ()>
    is_final: Boolean

  Type TransitionDefinition<S, E, C>:
    on: E
    to: S
    guard: Option<(C, E) -> Boolean>
    action: Option<(C, E) -> ()>

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "StateMachine":
    ```vibee
    # Define states and events
    Type TrafficLightState:
      variants:
        - Red
        - Yellow
        - Green

    Type TrafficLightEvent:
      variants:
        - Timer
        - Emergency

    Type TrafficLightContext:
      timer_count: Int

    # Build state machine
    machine = StateMachineBuilder<TrafficLightState, TrafficLightEvent, TrafficLightContext>.new()
      .initial(Red)
      .context(TrafficLightContext(timer_count: 0))
      .transition(Red, Timer, Green)
      .transition(Green, Timer, Yellow)
      .transition(Yellow, Timer, Red)
      .transition_with_action(Red, Emergency, Red, (ctx, _) -> {
        ctx.timer_count = 0
      })
      .on_entry(Red, ctx -> print("Stop!"))
      .on_entry(Green, ctx -> print("Go!"))
      .on_entry(Yellow, ctx -> print("Caution!"))
      .build()

    # Use state machine
    print(machine.state())  # Red
    
    machine.send(Timer)
    print(machine.state())  # Green
    
    machine.send(Timer)
    print(machine.state())  # Yellow

    # Check available events
    events = machine.available_events()  # [Timer, Emergency]

    # Order state machine with guards
    Type OrderState:
      variants:
        - Pending
        - Paid
        - Shipped
        - Delivered
        - Cancelled

    Type OrderEvent:
      variants:
        - Pay(amount: Float)
        - Ship
        - Deliver
        - Cancel

    Type OrderContext:
      total: Float
      paid: Float
      shipped_at: Option<Instant>

    order_machine = StateMachineBuilder<OrderState, OrderEvent, OrderContext>.new()
      .initial(Pending)
      .context(OrderContext(total: 100.0, paid: 0.0, shipped_at: null))
      .transition_full(
        Pending, 
        Pay(_), 
        Paid,
        (ctx, event) -> match event { Pay(amount) -> amount >= ctx.total },
        (ctx, event) -> match event { Pay(amount) -> ctx.paid = amount }
      )
      .transition(Paid, Ship, Shipped)
      .transition(Shipped, Deliver, Delivered)
      .transition(Pending, Cancel, Cancelled)
      .transition(Paid, Cancel, Cancelled)
      .final_state(Delivered)
      .final_state(Cancelled)
      .build()

    # Hierarchical state machine
    Type PlayerState:
      variants:
        - Idle
        - Playing
          - Running
          - Jumping
          - Attacking
        - Dead

    root = StateNode(
      state: Idle,
      transitions: [
        Transition(event: Start, target: Playing, guard: null, action: null)
      ],
      children: [
        StateNode(
          state: Playing,
          initial: Some(Running),
          transitions: [
            Transition(event: Die, target: Dead, guard: null, action: null)
          ],
          children: [
            StateNode(state: Running, transitions: [
              Transition(event: Jump, target: Jumping, guard: null, action: null),
              Transition(event: Attack, target: Attacking, guard: null, action: null)
            ]),
            StateNode(state: Jumping, transitions: [
              Transition(event: Land, target: Running, guard: null, action: null)
            ]),
            StateNode(state: Attacking, transitions: [
              Transition(event: Done, target: Running, guard: null, action: null)
            ])
          ]
        )
      ]
    )

    hsm = HierarchicalStateMachine.new(root, PlayerContext())
    
    hsm.send(Start)   # Idle -> Playing.Running
    hsm.send(Jump)    # Playing.Running -> Playing.Jumping
    hsm.send(Land)    # Playing.Jumping -> Playing.Running
    hsm.send(Die)     # Playing.* -> Dead

    # Parallel state machine
    parallel = ParallelStateMachine.new({
      "movement": movement_config,
      "combat": combat_config,
      "inventory": inventory_config
    }, context)

    parallel.send(MoveForward)  # Affects movement region
    parallel.send(Attack)       # Affects combat region

    # Async state machine
    async_machine = AsyncStateMachine.new(config)
    async_machine.start()
    
    async_machine.send(Event1)
    async_machine.send(Event2)
    
    result = await async_machine.send_async(Event3)
    ```
