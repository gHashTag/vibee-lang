# ============================================================================
# RANDOM - Генерация случайных чисел на Vibee
# ============================================================================
# CSPRNG, PRNG, Distributions, Sampling
# ============================================================================

Specification Random:
  """Случайность как спецификация генерации непредсказуемых значений."""

  # ==========================================================================
  # CRYPTOGRAPHICALLY SECURE RANDOM (CSPRNG)
  # ==========================================================================

  Behavior SecureRandom:
    When random.bytes(count: Int) -> Bytes:
      Then: native_secure_random_bytes(count)

    When random.int() -> Int:
      Then:
        bytes = random.bytes(8)
        return bytes_to_int(bytes)

    When random.int_range(min: Int, max: Int) -> Int:
      Then:
        if min >= max:
          panic("min must be less than max")
        
        range = max - min
        # Rejection sampling to avoid modulo bias
        threshold = (Int.MAX - range + 1) % range
        
        loop:
          value = random.int().abs()
          if value >= threshold:
            return min + (value % range)

    When random.float() -> Float:
      Then:
        # Generate 53 bits of randomness for double precision
        bytes = random.bytes(8)
        bits = bytes_to_int(bytes) & 0x1FFFFFFFFFFFFF
        return bits.to_float() / 9007199254740992.0  # 2^53

    When random.float_range(min: Float, max: Float) -> Float:
      Then:
        return min + random.float() * (max - min)

    When random.bool() -> Boolean:
      Then: random.bytes(1)[0] & 1 == 1

    When random.bool_probability(p: Float) -> Boolean:
      Then: random.float() < p

    When random.uuid() -> UUID:
      Then: UUID.v4()

    When random.string(length: Int, charset: String) -> String:
      Then:
        result = StringBuilder()
        for _ in 0..length:
          index = random.int_range(0, charset.length)
          result.append(charset[index])
        return result.to_string()

    When random.alphanumeric(length: Int) -> String:
      Then:
        charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        return random.string(length, charset)

    When random.hex(length: Int) -> String:
      Then:
        return random.bytes((length + 1) / 2).to_hex().slice(0, length)

    When random.base64(length: Int) -> String:
      Then:
        # Calculate bytes needed
        bytes_needed = (length * 3 + 3) / 4
        return base64.encode_no_padding(random.bytes(bytes_needed)).slice(0, length)

  # ==========================================================================
  # PSEUDO-RANDOM NUMBER GENERATORS (PRNG)
  # ==========================================================================

  Type Rng:
    """Seedable PRNG for reproducible randomness."""
    state: RngState

    Static Method new() -> Rng:
      return Rng(init_rng_state(random.bytes(32)))

    Static Method seeded(seed: Int) -> Rng:
      return Rng(init_rng_state_from_int(seed))

    Static Method from_bytes(seed: Bytes) -> Rng:
      return Rng(init_rng_state(seed))

    Method next_int() -> Int:
      return rng_next_int(self.state)

    Method next_int_range(min: Int, max: Int) -> Int:
      range = max - min
      return min + (self.next_int().abs() % range)

    Method next_float() -> Float:
      bits = self.next_int() & 0x1FFFFFFFFFFFFF
      return bits.to_float() / 9007199254740992.0

    Method next_float_range(min: Float, max: Float) -> Float:
      return min + self.next_float() * (max - min)

    Method next_bool() -> Boolean:
      return self.next_int() & 1 == 1

    Method next_bytes(count: Int) -> Bytes:
      result = Bytes(count)
      for i in 0..count:
        result[i] = self.next_int() & 0xFF
      return result

    Method shuffle<T>(list: List<T>) -> List<T>:
      result = list.clone()
      for i in (result.length - 1)..0 by -1:
        j = self.next_int_range(0, i + 1)
        result.swap(i, j)
      return result

    Method sample<T>(list: List<T>, count: Int) -> List<T>:
      if count >= list.length:
        return self.shuffle(list)
      
      # Reservoir sampling
      result = list.slice(0, count)
      for i in count..list.length:
        j = self.next_int_range(0, i + 1)
        if j < count:
          result[j] = list[i]
      return result

    Method choice<T>(list: List<T>) -> T:
      return list[self.next_int_range(0, list.length)]

    Method weighted_choice<T>(items: List<(T, Float)>) -> T:
      total = items.map((_, w) -> w).sum()
      threshold = self.next_float() * total
      
      cumulative = 0.0
      for (item, weight) in items:
        cumulative += weight
        if cumulative >= threshold:
          return item
      
      return items.last().0

  # ==========================================================================
  # SPECIFIC PRNG ALGORITHMS
  # ==========================================================================

  Type Xoshiro256:
    """Fast, high-quality PRNG."""
    state: [Int; 4]

    Static Method new() -> Xoshiro256:
      bytes = random.bytes(32)
      return Xoshiro256([
        bytes_to_int(bytes.slice(0, 8)),
        bytes_to_int(bytes.slice(8, 16)),
        bytes_to_int(bytes.slice(16, 24)),
        bytes_to_int(bytes.slice(24, 32))
      ])

    Static Method seeded(seed: Int) -> Xoshiro256:
      # Use SplitMix64 to expand seed
      state = [0; 4]
      z = seed
      for i in 0..4:
        z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9
        z = (z ^ (z >> 27)) * 0x94D049BB133111EB
        state[i] = z ^ (z >> 31)
      return Xoshiro256(state)

    Method next() -> Int:
      result = rotl(self.state[1] * 5, 7) * 9
      
      t = self.state[1] << 17
      
      self.state[2] ^= self.state[0]
      self.state[3] ^= self.state[1]
      self.state[1] ^= self.state[2]
      self.state[0] ^= self.state[3]
      
      self.state[2] ^= t
      self.state[3] = rotl(self.state[3], 45)
      
      return result

    Method jump():
      # Jump 2^128 steps
      native_xoshiro256_jump(self.state)

    Method long_jump():
      # Jump 2^192 steps
      native_xoshiro256_long_jump(self.state)

  Type PCG32:
    """Permuted Congruential Generator."""
    state: Int
    inc: Int

    Static Method new() -> PCG32:
      return PCG32(
        state: bytes_to_int(random.bytes(8)),
        inc: bytes_to_int(random.bytes(8)) | 1
      )

    Static Method seeded(seed: Int, seq: Int) -> PCG32:
      pcg = PCG32(state: 0, inc: (seq << 1) | 1)
      pcg.next()
      pcg.state += seed
      pcg.next()
      return pcg

    Method next() -> Int:
      old_state = self.state
      self.state = old_state * 6364136223846793005 + self.inc
      
      xorshifted = ((old_state >> 18) ^ old_state) >> 27
      rot = old_state >> 59
      
      return (xorshifted >> rot) | (xorshifted << ((-rot) & 31))

  Type MersenneTwister:
    """Classic MT19937."""
    state: [Int; 624]
    index: Int

    Static Method new() -> MersenneTwister:
      return MersenneTwister.seeded(bytes_to_int(random.bytes(8)))

    Static Method seeded(seed: Int) -> MersenneTwister:
      mt = MersenneTwister(state: [0; 624], index: 624)
      mt.state[0] = seed
      
      for i in 1..624:
        mt.state[i] = 1812433253 * (mt.state[i-1] ^ (mt.state[i-1] >> 30)) + i
      
      return mt

    Method next() -> Int:
      if self.index >= 624:
        self.twist()
      
      y = self.state[self.index]
      self.index += 1
      
      y ^= (y >> 11)
      y ^= (y << 7) & 0x9D2C5680
      y ^= (y << 15) & 0xEFC60000
      y ^= (y >> 18)
      
      return y

    Method twist():
      for i in 0..624:
        x = (self.state[i] & 0x80000000) + (self.state[(i + 1) % 624] & 0x7FFFFFFF)
        xa = x >> 1
        if x % 2 != 0:
          xa ^= 0x9908B0DF
        self.state[i] = self.state[(i + 397) % 624] ^ xa
      self.index = 0

  # ==========================================================================
  # PROBABILITY DISTRIBUTIONS
  # ==========================================================================

  Behavior Distributions:
    When random.uniform(min: Float, max: Float) -> Float:
      Then: random.float_range(min, max)

    When random.normal(mean: Float, std_dev: Float) -> Float:
      Then:
        # Box-Muller transform
        u1 = random.float()
        u2 = random.float()
        
        z0 = sqrt(-2.0 * ln(u1)) * cos(2.0 * PI * u2)
        return mean + z0 * std_dev

    When random.gaussian() -> Float:
      Then: random.normal(0.0, 1.0)

    When random.exponential(lambda: Float) -> Float:
      Then: -ln(1.0 - random.float()) / lambda

    When random.poisson(lambda: Float) -> Int:
      Then:
        if lambda < 30.0:
          # Direct method
          l = exp(-lambda)
          k = 0
          p = 1.0
          
          loop:
            k += 1
            p *= random.float()
            if p <= l:
              return k - 1
        else:
          # Normal approximation
          return max(0, round(random.normal(lambda, sqrt(lambda))))

    When random.binomial(n: Int, p: Float) -> Int:
      Then:
        if n * p < 10.0:
          # Direct method
          successes = 0
          for _ in 0..n:
            if random.float() < p:
              successes += 1
          return successes
        else:
          # Normal approximation
          mean = n.to_float() * p
          std = sqrt(mean * (1.0 - p))
          return clamp(round(random.normal(mean, std)), 0, n)

    When random.geometric(p: Float) -> Int:
      Then:
        return ceil(ln(1.0 - random.float()) / ln(1.0 - p)).to_int()

    When random.beta(alpha: Float, beta: Float) -> Float:
      Then:
        x = random.gamma(alpha, 1.0)
        y = random.gamma(beta, 1.0)
        return x / (x + y)

    When random.gamma(shape: Float, scale: Float) -> Float:
      Then:
        if shape < 1.0:
          return random.gamma(shape + 1.0, scale) * pow(random.float(), 1.0 / shape)
        
        # Marsaglia and Tsang's method
        d = shape - 1.0 / 3.0
        c = 1.0 / sqrt(9.0 * d)
        
        loop:
          x = random.gaussian()
          v = pow(1.0 + c * x, 3.0)
          
          if v > 0.0:
            u = random.float()
            if u < 1.0 - 0.0331 * pow(x, 4.0):
              return d * v * scale
            if ln(u) < 0.5 * pow(x, 2.0) + d * (1.0 - v + ln(v)):
              return d * v * scale

    When random.chi_squared(df: Int) -> Float:
      Then: random.gamma(df.to_float() / 2.0, 2.0)

    When random.student_t(df: Int) -> Float:
      Then:
        return random.gaussian() / sqrt(random.chi_squared(df) / df.to_float())

    When random.pareto(alpha: Float, xm: Float) -> Float:
      Then: xm / pow(1.0 - random.float(), 1.0 / alpha)

    When random.weibull(shape: Float, scale: Float) -> Float:
      Then: scale * pow(-ln(1.0 - random.float()), 1.0 / shape)

    When random.log_normal(mean: Float, std_dev: Float) -> Float:
      Then: exp(random.normal(mean, std_dev))

    When random.cauchy(location: Float, scale: Float) -> Float:
      Then: location + scale * tan(PI * (random.float() - 0.5))

  # ==========================================================================
  # SAMPLING
  # ==========================================================================

  Behavior Sampling:
    When random.shuffle<T>(list: List<T>) -> List<T>:
      Then:
        result = list.clone()
        for i in (result.length - 1)..0 by -1:
          j = random.int_range(0, i + 1)
          result.swap(i, j)
        return result

    When random.sample<T>(list: List<T>, count: Int) -> List<T>:
      Then:
        if count >= list.length:
          return random.shuffle(list)
        
        # Floyd's algorithm
        result = Set()
        for i in (list.length - count)..list.length:
          j = random.int_range(0, i + 1)
          if j in result:
            result.add(i)
          else:
            result.add(j)
        
        return result.to_list().map(i -> list[i])

    When random.choice<T>(list: List<T>) -> T:
      Then: list[random.int_range(0, list.length)]

    When random.choices<T>(list: List<T>, count: Int) -> List<T>:
      Then:
        result = []
        for _ in 0..count:
          result.push(random.choice(list))
        return result

    When random.weighted_choice<T>(items: List<(T, Float)>) -> T:
      Then:
        total = items.map((_, w) -> w).sum()
        threshold = random.float() * total
        
        cumulative = 0.0
        for (item, weight) in items:
          cumulative += weight
          if cumulative >= threshold:
            return item
        
        return items.last().0

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Random":
    ```vibee
    # Secure random bytes
    key = random.bytes(32)
    nonce = random.bytes(12)

    # Random integers
    n = random.int()
    dice = random.int_range(1, 7)  # 1-6

    # Random floats
    f = random.float()  # 0.0 to 1.0
    temp = random.float_range(-10.0, 40.0)

    # Random strings
    password = random.alphanumeric(16)
    token = random.hex(32)
    api_key = random.base64(24)

    # Booleans
    coin = random.bool()
    rare_event = random.bool_probability(0.01)  # 1% chance

    # Seeded PRNG for reproducibility
    rng = Rng.seeded(42)
    
    a = rng.next_int()
    b = rng.next_float()
    
    # Same seed = same sequence
    rng2 = Rng.seeded(42)
    assert(rng2.next_int() == a)

    # Shuffling
    deck = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    shuffled = random.shuffle(deck)

    # Sampling
    winners = random.sample(participants, 3)
    
    # Random choice
    color = random.choice(["red", "green", "blue"])

    # Weighted choice
    item = random.weighted_choice([
      ("common", 70.0),
      ("rare", 25.0),
      ("legendary", 5.0)
    ])

    # Distributions
    height = random.normal(170.0, 10.0)  # Normal distribution
    wait_time = random.exponential(0.5)  # Exponential
    events = random.poisson(5.0)         # Poisson
    success = random.binomial(10, 0.3)   # Binomial

    # Specific PRNG algorithms
    xo = Xoshiro256.seeded(12345)
    pcg = PCG32.seeded(12345, 1)
    mt = MersenneTwister.seeded(12345)

    # Parallel streams with jump
    rng1 = Xoshiro256.seeded(42)
    rng2 = Xoshiro256.seeded(42)
    rng2.jump()  # Now independent stream
    ```
