name: vibee_os_gesture_language
version: "0.1.0"
language: gleam
module: kernel/ui/gesture_language
description: Gesture Language - Given/When/Then для всех типов жестов (touch, mouse, pen, air gestures)

behaviors:
  - name: recognize_swipe
    given: Touch starts at point A
    when: Touch moves to point B with velocity > threshold
    then: Swipe gesture is recognized with direction
    test_cases:
      - name: swipe_right
        input: {start: {x: 100, y: 300}, end: {x: 400, y: 310}, duration_ms: 200}
        expected: {gesture: "swipe", direction: "right", velocity: 1.5}
      - name: swipe_up
        input: {start: {x: 200, y: 500}, end: {x: 210, y: 100}, duration_ms: 150}
        expected: {gesture: "swipe", direction: "up", velocity: 2.67}
      - name: too_slow_not_swipe
        input: {start: {x: 100, y: 300}, end: {x: 400, y: 310}, duration_ms: 2000}
        expected: {gesture: "drag", not: "swipe"}

  - name: recognize_pinch
    given: Two touches are active
    when: Distance between touches changes
    then: Pinch gesture is recognized with scale factor
    test_cases:
      - name: pinch_zoom_in
        input: {touch1_start: {x: 300, y: 400}, touch2_start: {x: 500, y: 400}, touch1_end: {x: 200, y: 400}, touch2_end: {x: 600, y: 400}}
        expected: {gesture: "pinch", scale: 2.0, direction: "out"}
      - name: pinch_zoom_out
        input: {touch1_start: {x: 200, y: 400}, touch2_start: {x: 600, y: 400}, touch1_end: {x: 300, y: 400}, touch2_end: {x: 500, y: 400}}
        expected: {gesture: "pinch", scale: 0.5, direction: "in"}

  - name: recognize_rotate
    given: Two touches are active
    when: Angle between touches changes
    then: Rotate gesture is recognized with angle
    test_cases:
      - name: rotate_clockwise
        input: {touch1: {x: 300, y: 300}, touch2: {x: 500, y: 300}, rotation: 45}
        expected: {gesture: "rotate", angle: 45, direction: "clockwise"}
      - name: rotate_counter
        input: {touch1: {x: 300, y: 300}, touch2: {x: 500, y: 300}, rotation: -30}
        expected: {gesture: "rotate", angle: -30, direction: "counter_clockwise"}

  - name: recognize_long_press
    given: Touch starts at point
    when: Touch remains stationary for duration > threshold
    then: Long press gesture is recognized
    test_cases:
      - name: long_press_500ms
        input: {point: {x: 400, y: 300}, duration_ms: 500, movement: 2}
        expected: {gesture: "long_press", duration: 500}
      - name: moved_too_much
        input: {point: {x: 400, y: 300}, duration_ms: 500, movement: 20}
        expected: {gesture: null, reason: "movement_exceeded"}

  - name: recognize_double_tap
    given: First tap occurred
    when: Second tap occurs within time and distance threshold
    then: Double tap gesture is recognized
    test_cases:
      - name: quick_double_tap
        input: {tap1: {x: 400, y: 300, time: 0}, tap2: {x: 402, y: 301, time: 150}}
        expected: {gesture: "double_tap", interval_ms: 150}
      - name: too_slow
        input: {tap1: {x: 400, y: 300, time: 0}, tap2: {x: 402, y: 301, time: 500}}
        expected: {gesture: null, reason: "interval_exceeded"}

  - name: recognize_multi_finger_tap
    given: Multiple touches start simultaneously
    when: All touches end within short duration
    then: Multi-finger tap is recognized
    test_cases:
      - name: two_finger_tap
        input: {touches: 2, duration_ms: 100}
        expected: {gesture: "tap", fingers: 2}
      - name: three_finger_tap
        input: {touches: 3, duration_ms: 100}
        expected: {gesture: "tap", fingers: 3}

  - name: gesture_sequence
    given: Multiple gestures occur in sequence
    when: Sequence matches pattern
    then: Compound gesture is recognized
    test_cases:
      - name: swipe_then_tap
        input: {gestures: ["swipe_right", "tap"]}
        expected: {compound: "swipe_tap", recognized: true}
      - name: double_swipe
        input: {gestures: ["swipe_up", "swipe_up"]}
        expected: {compound: "double_swipe_up", recognized: true}

types:
  # Input Sources
  InputSource:
    variants:
      - Touch: {id: int, pressure: float}
      - Mouse: {buttons: int}
      - Pen: {pressure: float, tilt: Tilt, barrel_button: bool}
      - Trackpad: {fingers: int}
      - AirGesture: {hand: Hand, confidence: float}
      - EyeGaze: {confidence: float}
      - Voice: {transcript: str, confidence: float}

  Tilt:
    x: float                          # -90 to 90 degrees
    y: float

  Hand:
    variants:
      - Left
      - Right
      - Both

  # Touch Points
  TouchPoint:
    id: int
    x: float
    y: float
    pressure: float
    radius: float
    timestamp: int
    source: InputSource

  TouchPhase:
    variants:
      - Began
      - Moved
      - Stationary
      - Ended
      - Cancelled

  TouchEvent:
    phase: TouchPhase
    touches: [TouchPoint]
    timestamp: int
    target: str?                      # Semantic element ID

  # Gestures
  Gesture:
    type: GestureType
    state: GestureState
    touches: [TouchPoint]
    start_time: int
    duration: int
    velocity: Velocity?
    source: InputSource

  GestureType:
    variants:
      # Single touch
      - Tap: {count: int}
      - DoubleTap
      - LongPress: {duration: int}
      - Swipe: {direction: Direction}
      - Drag: {delta: Delta}
      - Pan: {delta: Delta}
      - Flick: {velocity: Velocity}
      
      # Multi-touch
      - Pinch: {scale: float}
      - Rotate: {angle: float}
      - TwoFingerTap
      - TwoFingerSwipe: {direction: Direction}
      - ThreeFingerSwipe: {direction: Direction}
      - FourFingerSwipe: {direction: Direction}
      - Spread: {scale: float}
      
      # Pen specific
      - PenTap: {pressure: float}
      - PenDrag: {pressure: float, tilt: Tilt}
      - PenHover
      - BarrelClick
      
      # Air gestures (Leap Motion, etc.)
      - AirTap
      - AirSwipe: {direction: Direction}
      - AirGrab
      - AirRelease
      - AirPinch: {scale: float}
      - AirRotate: {angle: float}
      - AirPush
      - AirPull
      
      # Eye gaze
      - GazeDwell: {duration: int}
      - GazeSelect
      - Blink: {eye: Eye}
      - Wink: {eye: Eye}
      
      # Voice (as gesture)
      - VoiceCommand: {command: str}
      
      # Custom
      - Custom: {name: str, params: {str: str}}

  Eye:
    variants:
      - Left
      - Right
      - Both

  GestureState:
    variants:
      - Possible
      - Began
      - Changed
      - Ended
      - Cancelled
      - Failed

  Direction:
    variants:
      - Up
      - Down
      - Left
      - Right
      - UpLeft
      - UpRight
      - DownLeft
      - DownRight

  Delta:
    x: float
    y: float

  Velocity:
    x: float
    y: float
    magnitude: float

  # Gesture Recognition
  GestureRecognizer:
    type: GestureType
    state: GestureState
    enabled: bool
    requires_exclusive: bool          # Fails other recognizers
    can_prevent: [str]                # Recognizer IDs it can prevent
    can_be_prevented_by: [str]
    min_touches: int
    max_touches: int
    config: GestureConfig

  GestureConfig:
    # Tap
    tap_max_duration: int?
    tap_max_movement: float?
    double_tap_interval: int?
    
    # Long press
    long_press_min_duration: int?
    long_press_max_movement: float?
    
    # Swipe
    swipe_min_velocity: float?
    swipe_min_distance: float?
    swipe_max_angle_deviation: float?
    
    # Pinch
    pinch_min_scale_change: float?
    
    # Rotate
    rotate_min_angle: float?
    
    # Custom thresholds
    custom: {str: float}

  # Gesture Specification (Given/When/Then)
  GestureSpec:
    name: str
    given: GestureGiven
    when: GestureWhen
    then: GestureThen
    test_cases: [GestureTestCase]

  GestureGiven:
    conditions: [GestureCondition]

  GestureCondition:
    variants:
      - TouchCount: {count: int, operator: Operator}
      - InRegion: {region: str}
      - ElementFocused: {element: str}
      - GestureActive: {gesture: str}
      - StateIs: {state: str}
      - Custom: {predicate: str}

  Operator:
    variants:
      - Equals
      - GreaterThan
      - LessThan
      - GreaterOrEqual
      - LessOrEqual

  GestureWhen:
    trigger: GestureTrigger

  GestureTrigger:
    variants:
      - GestureRecognized: {type: GestureType}
      - GestureChanged: {type: GestureType}
      - GestureEnded: {type: GestureType}
      - TouchBegan
      - TouchMoved
      - TouchEnded
      - Sequence: {gestures: [GestureType], timeout: int}

  GestureThen:
    outcomes: [GestureOutcome]

  GestureOutcome:
    variants:
      - EmitEvent: {event: str, params: {str: str}}
      - Navigate: {to: str}
      - Scroll: {delta: Delta}
      - Zoom: {scale: float, center: Point}
      - Rotate: {angle: float, center: Point}
      - Select: {element: str}
      - Drag: {element: str, to: Point}
      - ShowMenu: {at: Point}
      - Dismiss
      - Undo
      - Redo
      - Custom: {action: str, params: {str: str}}

  Point:
    x: float
    y: float

  GestureTestCase:
    name: str
    input: GestureTestInput
    expected: GestureTestExpected

  GestureTestInput:
    touches: [TouchSequence]
    duration_ms: int

  TouchSequence:
    id: int
    points: [TouchPoint]

  GestureTestExpected:
    gesture: GestureType?
    state: GestureState?
    outcome: str?
    error: str?

  # Gesture Conflict Resolution
  GestureConflict:
    recognizers: [str]
    resolution: ConflictResolution

  ConflictResolution:
    variants:
      - FirstWins
      - LastWins
      - Simultaneous
      - Priority: {order: [str]}
      - Custom: {resolver: str}

functions:
  # Recognizer management
  - name: recognizer_create
    params: {type: GestureType, config: GestureConfig}
    returns: GestureRecognizer
    description: Create gesture recognizer

  - name: recognizer_attach
    params: {recognizer: GestureRecognizer, region: str}
    returns: bool
    description: Attach recognizer to region

  - name: recognizer_detach
    params: {recognizer: GestureRecognizer, region: str}
    returns: bool
    description: Detach recognizer from region

  - name: recognizer_enable
    params: {recognizer: GestureRecognizer}
    returns: void
    description: Enable recognizer

  - name: recognizer_disable
    params: {recognizer: GestureRecognizer}
    returns: void
    description: Disable recognizer

  # Touch processing
  - name: touch_began
    params: {event: TouchEvent}
    returns: void
    description: Process touch began event

  - name: touch_moved
    params: {event: TouchEvent}
    returns: void
    description: Process touch moved event

  - name: touch_ended
    params: {event: TouchEvent}
    returns: void
    description: Process touch ended event

  - name: touch_cancelled
    params: {event: TouchEvent}
    returns: void
    description: Process touch cancelled event

  # Gesture recognition
  - name: recognize
    params: {touches: [TouchPoint]}
    returns: [Gesture]
    description: Recognize gestures from touch points

  - name: recognize_sequence
    params: {gestures: [Gesture], pattern: [GestureType]}
    returns: bool
    description: Check if gesture sequence matches pattern

  # Gesture specification
  - name: gesture_spec_parse
    params: {source: str}
    returns: GestureSpec
    description: Parse gesture specification

  - name: gesture_spec_attach
    params: {spec: GestureSpec, region: str}
    returns: bool
    description: Attach gesture spec to region

  - name: gesture_spec_test
    params: {spec: GestureSpec}
    returns: {passed: int, failed: int}
    description: Run gesture spec tests

  # Conflict resolution
  - name: conflict_resolve
    params: {recognizers: [GestureRecognizer], resolution: ConflictResolution}
    returns: GestureRecognizer?
    description: Resolve gesture conflict

  # Utilities
  - name: calculate_velocity
    params: {points: [TouchPoint]}
    returns: Velocity
    description: Calculate velocity from touch points

  - name: calculate_direction
    params: {start: Point, end: Point}
    returns: Direction
    description: Calculate direction from two points

  - name: calculate_angle
    params: {touch1: TouchPoint, touch2: TouchPoint}
    returns: float
    description: Calculate angle between two touches

  - name: calculate_distance
    params: {touch1: TouchPoint, touch2: TouchPoint}
    returns: float
    description: Calculate distance between two touches

imports:
  - kernel.ui.plastic_screen
  - kernel.ui.semantic_pixel

gesture_spec_syntax: |
  # Gesture Specification Syntax
  
  ## Basic Gesture
  ```vscreen
  gesture swipe_to_delete {
    given: 
      touch_count == 1
      in_region list_item
      state is Idle
    
    when: swipe direction Left velocity > 1.0
    
    then:
      emit "delete_item" with {id: item.id}
      animate slide_out
  }
  ```
  
  ## Multi-Touch Gesture
  ```vscreen
  gesture pinch_to_zoom {
    given:
      touch_count == 2
      in_region zoomable_area
    
    when: pinch scale_change > 0.1
    
    then:
      zoom scale gesture.scale center gesture.center
      emit "zoom_changed" with {scale: gesture.scale}
  }
  ```
  
  ## Gesture Sequence
  ```vscreen
  gesture double_swipe_refresh {
    given:
      in_region scrollable
      scroll_position == 0
    
    when: sequence [swipe_down, swipe_down] timeout 500ms
    
    then:
      emit "refresh"
      animate pull_to_refresh
  }
  ```
  
  ## Air Gesture
  ```vscreen
  gesture air_swipe_navigate {
    given:
      input_source is AirGesture
      hand is Right
      confidence > 0.8
    
    when: air_swipe direction Right
    
    then:
      navigate to next_page
  }
  ```
  
  ## Eye Gaze
  ```vscreen
  gesture gaze_select {
    given:
      input_source is EyeGaze
      element is focusable
    
    when: gaze_dwell duration > 1000ms
    
    then:
      select element
      announce "Selected {element.label}"
  }
  ```

gesture_conflict_examples: |
  # Gesture Conflict Resolution
  
  ## Problem: Tap vs Long Press
  ```
  User touches screen...
  - After 100ms: Could be tap
  - After 500ms: Could be long press
  - User lifts finger at 200ms: It's a tap!
  ```
  
  ## Solution: Delayed Recognition
  ```vscreen
  recognizer tap {
    requires_exclusive: false
    can_be_prevented_by: [long_press]
  }
  
  recognizer long_press {
    requires_exclusive: true
    can_prevent: [tap]
    min_duration: 500ms
  }
  ```
  
  ## Problem: Swipe vs Scroll
  ```
  User drags finger...
  - Slow: Scroll
  - Fast: Swipe
  ```
  
  ## Solution: Velocity Threshold
  ```vscreen
  recognizer scroll {
    type: Pan
    max_velocity: 1.0
  }
  
  recognizer swipe {
    type: Swipe
    min_velocity: 1.0
  }
  ```

multi_modal_integration: |
  # Multi-Modal Input Integration
  
  All input sources use the same Given/When/Then:
  
  ```vscreen
  behavior universal_select {
    given: element is selectable
    
    when:
      # Any of these triggers
      tap on element OR
      key_press Enter on element OR
      voice_command "select" OR
      gaze_dwell 1000ms on element OR
      air_tap on element
    
    then:
      select element
      announce "Selected {element.label}"
  }
  ```
  
  This means:
  - Same behavior, multiple input methods
  - Accessibility built-in
  - Future input methods just add triggers
