name: vibee_os_canvas_renderer
version: "0.1.0"
language: gleam
module: kernel/ui/canvas
description: Canvas Renderer - BEAM to Browser bridge. Binary protocol, WebSocket, zero frameworks.

behaviors:
  - name: connect_to_browser
    given: Browser has canvas element ready
    when: renderer_connect is called
    then: WebSocket connection established with binary protocol
    test_cases:
      - name: connect_success
        input: {canvas_id: "main", width: 1920, height: 1080}
        expected: {connected: true, protocol: "binary", latency_ms: 5}

  - name: push_frame_buffer
    given: Connection established and frame ready
    when: renderer_push is called with pixel data
    then: Binary data sent to browser and rendered
    test_cases:
      - name: push_full_frame
        input: {width: 1920, height: 1080, pixels: [...]}
        expected: {bytes_sent: 8294400, render_time_ms: 16}
      - name: push_diff_only
        input: {dirty_rects: [{x: 100, y: 100, w: 200, h: 50}]}
        expected: {bytes_sent: 40000, render_time_ms: 1}

  - name: receive_input_events
    given: User interacts with canvas
    when: Mouse/keyboard/touch event occurs
    then: Event sent to BEAM as binary message
    test_cases:
      - name: mouse_move
        input: {type: "mousemove", x: 500, y: 300}
        expected: {event_received: true, latency_ms: 2}
      - name: click
        input: {type: "click", x: 500, y: 300, button: 0}
        expected: {event_received: true, routed_to: "pixel_500_300"}

  - name: batch_render_commands
    given: Multiple render operations pending
    when: Frame tick occurs
    then: Commands batched and sent as single binary blob
    test_cases:
      - name: batch_1000_pixels
        input: {commands: 1000, type: "set_pixel"}
        expected: {batched: true, packets: 1, bytes: 12000}

types:
  Connection:
    id: str
    socket: str           # WebSocket reference
    canvas_id: str
    width: int
    height: int
    protocol: Protocol
    state: ConnectionState

  Protocol:
    variants:
      - Binary            # Raw bytes, fastest
      - MessagePack       # Compressed binary
      - JSON              # Fallback, slow

  ConnectionState:
    variants:
      - Connecting
      - Connected
      - Disconnected
      - Error

  BinaryFrame:
    header: FrameHeader
    data: [int]           # Raw pixel bytes

  FrameHeader:
    magic: int            # 0xVIBE
    version: int
    width: int
    height: int
    format: PixelFormat
    compression: Compression
    timestamp: int

  PixelFormat:
    variants:
      - RGB24             # 3 bytes per pixel
      - RGBA32            # 4 bytes per pixel
      - RGB565            # 2 bytes per pixel (mobile)
      - Indexed8          # 1 byte + palette

  Compression:
    variants:
      - None
      - RLE               # Run-length encoding
      - Delta             # Only changes
      - LZ4               # Fast compression

  InputEvent:
    type: EventType
    timestamp: int
    x: int
    y: int
    data: EventData

  EventType:
    variants:
      - MouseMove
      - MouseDown
      - MouseUp
      - Click
      - DoubleClick
      - Wheel
      - KeyDown
      - KeyUp
      - TouchStart
      - TouchMove
      - TouchEnd

  EventData:
    button: int?
    buttons: int?
    key: str?
    key_code: int?
    delta_x: float?
    delta_y: float?
    pressure: float?
    touches: [Touch]?

  Touch:
    id: int
    x: int
    y: int
    pressure: float

  RenderBatch:
    commands: [RenderOp]
    priority: int
    deadline_ms: int

  RenderOp:
    variants:
      - Clear: {color: int}
      - Pixel: {x: int, y: int, color: int}
      - Rect: {x: int, y: int, w: int, h: int, color: int}
      - Line: {x1: int, y1: int, x2: int, y2: int, color: int}
      - Circle: {cx: int, cy: int, r: int, color: int}
      - Pixels: {data: [{x: int, y: int, c: int}]}
      - Image: {x: int, y: int, w: int, h: int, data: [int]}

  RendererStats:
    fps: float
    frame_time_ms: float
    bytes_per_second: int
    dropped_frames: int
    latency_ms: float

functions:
  # Connection
  - name: renderer_connect
    params: {canvas_id: str, width: int, height: int}
    returns: Connection
    description: Connect to browser canvas

  - name: renderer_disconnect
    params: {conn: Connection}
    returns: void
    description: Disconnect from browser

  - name: renderer_reconnect
    params: {conn: Connection}
    returns: Connection
    description: Reconnect after disconnect

  # Rendering
  - name: renderer_push
    params: {conn: Connection, frame: BinaryFrame}
    returns: bool
    description: Push full frame to browser

  - name: renderer_push_diff
    params: {conn: Connection, ops: [RenderOp]}
    returns: bool
    description: Push diff operations only

  - name: renderer_batch
    params: {conn: Connection, batch: RenderBatch}
    returns: bool
    description: Push batched commands

  - name: renderer_clear
    params: {conn: Connection, color: int}
    returns: void
    description: Clear canvas with color

  # Input
  - name: renderer_on_input
    params: {conn: Connection, callback: str}
    returns: void
    description: Register input event callback

  - name: renderer_route_event
    params: {event: InputEvent, grid: str}
    returns: void
    description: Route event to appropriate pixel/region

  # Stats
  - name: renderer_stats
    params: {conn: Connection}
    returns: RendererStats
    description: Get rendering statistics

  # Frame management
  - name: frame_encode
    params: {pixels: [[int]], format: PixelFormat, compression: Compression}
    returns: BinaryFrame
    description: Encode pixel array to binary frame

  - name: frame_decode
    params: {frame: BinaryFrame}
    returns: [[int]]
    description: Decode binary frame to pixel array

imports:
  - kernel.ui.pixel_grid

binary_protocol: |
  # VIBEE Binary Protocol
  
  ## Frame Format (Big Endian)
  
  ```
  +--------+--------+--------+--------+
  | MAGIC (4 bytes) = 0x56494245     | "VIBE"
  +--------+--------+--------+--------+
  | VERSION (2) | FLAGS (2)          |
  +--------+--------+--------+--------+
  | WIDTH (2)   | HEIGHT (2)         |
  +--------+--------+--------+--------+
  | FORMAT (1)  | COMPRESS (1) | RSV |
  +--------+--------+--------+--------+
  | TIMESTAMP (8 bytes)              |
  +--------+--------+--------+--------+
  | DATA LENGTH (4 bytes)            |
  +--------+--------+--------+--------+
  | PIXEL DATA (variable)            |
  | ...                              |
  +--------+--------+--------+--------+
  ```
  
  ## Pixel Formats
  
  - 0x01: RGB24 (3 bytes/pixel)
  - 0x02: RGBA32 (4 bytes/pixel)
  - 0x03: RGB565 (2 bytes/pixel)
  - 0x04: Indexed8 (1 byte + 256*3 palette)
  
  ## Compression
  
  - 0x00: None
  - 0x01: RLE
  - 0x02: Delta (XOR with previous frame)
  - 0x03: LZ4
  
  ## Input Event Format
  
  ```
  +--------+--------+--------+--------+
  | TYPE (1) | FLAGS (1) | X (2)     |
  +--------+--------+--------+--------+
  | Y (2)    | DATA (variable)       |
  +--------+--------+--------+--------+
  ```

browser_client: |
  # Browser Client (Minimal JS)
  
  ```javascript
  // vibee_canvas.js - Minimal browser client
  
  class VibeeCanvas {
    constructor(canvasId) {
      this.canvas = document.getElementById(canvasId);
      this.ctx = this.canvas.getContext('2d');
      this.imageData = null;
      this.ws = null;
    }
    
    connect(url) {
      this.ws = new WebSocket(url);
      this.ws.binaryType = 'arraybuffer';
      
      this.ws.onmessage = (e) => this.onFrame(e.data);
      
      // Input events
      this.canvas.onmousemove = (e) => this.sendInput(0x01, e);
      this.canvas.onclick = (e) => this.sendInput(0x03, e);
    }
    
    onFrame(buffer) {
      const view = new DataView(buffer);
      
      // Parse header
      const magic = view.getUint32(0);
      if (magic !== 0x56494245) return; // "VIBE"
      
      const width = view.getUint16(6);
      const height = view.getUint16(8);
      const format = view.getUint8(10);
      
      // Get pixel data
      const dataOffset = 20;
      const pixels = new Uint8ClampedArray(buffer, dataOffset);
      
      // Render
      if (!this.imageData || 
          this.imageData.width !== width) {
        this.imageData = this.ctx.createImageData(width, height);
      }
      
      // Copy pixels (RGB24 -> RGBA32)
      if (format === 0x01) {
        for (let i = 0, j = 0; i < pixels.length; i += 3, j += 4) {
          this.imageData.data[j] = pixels[i];
          this.imageData.data[j+1] = pixels[i+1];
          this.imageData.data[j+2] = pixels[i+2];
          this.imageData.data[j+3] = 255;
        }
      }
      
      this.ctx.putImageData(this.imageData, 0, 0);
    }
    
    sendInput(type, event) {
      const buffer = new ArrayBuffer(8);
      const view = new DataView(buffer);
      view.setUint8(0, type);
      view.setUint16(2, event.offsetX);
      view.setUint16(4, event.offsetY);
      this.ws.send(buffer);
    }
  }
  
  // Usage: new VibeeCanvas('canvas').connect('ws://localhost:8080');
  ```

performance_targets: |
  # Performance Targets
  
  ## 1920x1080 @ 60fps
  
  - Frame time budget: 16.67ms
  - Pixels per frame: 2,073,600
  - Bytes per frame (RGB24): 6,220,800
  - Required bandwidth: 373 MB/s
  
  ## Optimizations
  
  1. **Delta Compression**
     - Only send changed pixels
     - Typical: 1-5% of pixels change per frame
     - Reduces to ~3-15 MB/s
  
  2. **Region-based Updates**
     - Track dirty rectangles
     - Only update changed regions
  
  3. **Double Buffering**
     - Render to back buffer
     - Swap on vsync
  
  4. **WebGL Path**
     - Use WebGL for final compositing
     - GPU-accelerated blitting
