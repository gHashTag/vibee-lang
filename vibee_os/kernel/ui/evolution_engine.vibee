name: vibee_os_ui_evolution
version: "0.1.0"
language: gleam
module: kernel/ui/evolution
description: Evolutionary UI Engine - self-improving interfaces through genetic algorithms and agent-driven mutations

behaviors:
  - name: mutate_ui_element
    given: UI element exists with current properties
    when: mutate is called with mutation type
    then: Element properties are modified according to mutation rules
    test_cases:
      - name: mutate_color
        input: {element: "button_1", mutation: "color_shift", intensity: 0.2}
        expected: {mutated: true, property: "color", change_percent: 20}
      - name: mutate_position
        input: {element: "panel_1", mutation: "position_drift", max_delta: 10}
        expected: {mutated: true, property: "position", within_bounds: true}

  - name: crossover_layouts
    given: Two parent layouts exist
    when: crossover is called
    then: Child layout inherits traits from both parents
    test_cases:
      - name: crossover_two_layouts
        input: {parent_a: "layout_1", parent_b: "layout_2"}
        expected: {child_created: true, traits_from_a: true, traits_from_b: true}

  - name: evaluate_fitness
    given: UI layout is rendered and user interacts
    when: fitness_evaluate is called with metrics
    then: Fitness score calculated based on UX metrics
    test_cases:
      - name: evaluate_good_ui
        input: {click_accuracy: 0.95, task_time_ms: 2000, error_rate: 0.02}
        expected: {fitness: 0.92, rank: "excellent"}
      - name: evaluate_bad_ui
        input: {click_accuracy: 0.5, task_time_ms: 10000, error_rate: 0.3}
        expected: {fitness: 0.25, rank: "poor"}

  - name: evolve_generation
    given: Population of UI variants exists
    when: evolve is called
    then: New generation created through selection, crossover, mutation
    test_cases:
      - name: evolve_10_generations
        input: {population_size: 50, generations: 10}
        expected: {best_fitness_improved: true, diversity_maintained: true}

  - name: agent_guided_evolution
    given: SWE Agent observes user behavior
    when: agent_suggest_mutation is called
    then: Agent proposes intelligent mutations based on patterns
    test_cases:
      - name: agent_suggests_larger_button
        input: {observation: "users miss button frequently", element: "submit_btn"}
        expected: {suggestion: "increase_size", confidence: 0.85}

types:
  UIGenome:
    id: str
    genes: [Gene]
    fitness: float
    generation: int
    parent_ids: [str]
    mutations_applied: [str]

  Gene:
    id: str
    element_type: ElementType
    properties: GeneProperties
    constraints: GeneConstraints

  ElementType:
    variants:
      - Button
      - Panel
      - Text
      - Input
      - Image
      - Container
      - Custom

  GeneProperties:
    x: float
    y: float
    width: float
    height: float
    color: int
    alpha: float
    rotation: float
    scale: float
    z_index: int
    custom: {str: float}

  GeneConstraints:
    min_x: float
    max_x: float
    min_y: float
    max_y: float
    min_width: float
    max_width: float
    min_height: float
    max_height: float
    color_palette: [int]?
    snap_to_grid: int?

  Mutation:
    type: MutationType
    target: str           # Gene ID
    intensity: float      # 0.0 - 1.0
    params: {str: float}

  MutationType:
    variants:
      - ColorShift
      - PositionDrift
      - SizeScale
      - RotationTwist
      - AlphaFade
      - PropertySwap
      - GeneDelete
      - GeneAdd
      - LayoutShuffle

  Crossover:
    type: CrossoverType
    parent_a: str
    parent_b: str
    split_point: float?

  CrossoverType:
    variants:
      - SinglePoint        # Split at one point
      - TwoPoint           # Split at two points
      - Uniform            # Random gene selection
      - Blend              # Interpolate properties

  FitnessMetrics:
    click_accuracy: float
    task_completion_time_ms: int
    error_rate: float
    user_satisfaction: float
    accessibility_score: float
    aesthetic_score: float
    performance_score: float

  FitnessWeights:
    usability: float
    aesthetics: float
    performance: float
    accessibility: float

  Population:
    id: str
    genomes: [UIGenome]
    generation: int
    best_fitness: float
    average_fitness: float
    diversity: float

  EvolutionConfig:
    population_size: int
    generations: int
    mutation_rate: float
    crossover_rate: float
    elitism_count: int
    tournament_size: int
    fitness_weights: FitnessWeights

  EvolutionResult:
    best_genome: UIGenome
    generations_run: int
    fitness_history: [float]
    convergence_generation: int?

  AgentSuggestion:
    mutation: Mutation
    confidence: float
    reasoning: str
    expected_improvement: float

  UserBehavior:
    clicks: [ClickEvent]
    hovers: [HoverEvent]
    scrolls: [ScrollEvent]
    errors: [ErrorEvent]
    task_completions: [TaskCompletion]

  ClickEvent:
    x: int
    y: int
    target: str?
    timestamp: int
    success: bool

  HoverEvent:
    x: int
    y: int
    duration_ms: int
    target: str?

  ScrollEvent:
    delta_x: float
    delta_y: float
    timestamp: int

  ErrorEvent:
    type: str
    target: str?
    timestamp: int
    recovered: bool

  TaskCompletion:
    task_id: str
    duration_ms: int
    errors: int
    success: bool

functions:
  # Mutation
  - name: mutate
    params: {genome: UIGenome, mutation: Mutation}
    returns: UIGenome
    description: Apply mutation to genome

  - name: mutate_random
    params: {genome: UIGenome, rate: float}
    returns: UIGenome
    description: Apply random mutations at given rate

  - name: mutate_guided
    params: {genome: UIGenome, suggestion: AgentSuggestion}
    returns: UIGenome
    description: Apply agent-guided mutation

  # Crossover
  - name: crossover
    params: {parent_a: UIGenome, parent_b: UIGenome, type: CrossoverType}
    returns: UIGenome
    description: Create child from two parents

  # Fitness
  - name: fitness_evaluate
    params: {genome: UIGenome, metrics: FitnessMetrics, weights: FitnessWeights}
    returns: float
    description: Calculate fitness score

  - name: fitness_from_behavior
    params: {genome: UIGenome, behavior: UserBehavior}
    returns: FitnessMetrics
    description: Extract metrics from user behavior

  # Evolution
  - name: evolve
    params: {population: Population, config: EvolutionConfig}
    returns: Population
    description: Evolve one generation

  - name: evolve_until
    params: {population: Population, config: EvolutionConfig, target_fitness: float}
    returns: EvolutionResult
    description: Evolve until target fitness reached

  - name: select_parents
    params: {population: Population, count: int}
    returns: [UIGenome]
    description: Select parents for next generation

  # Agent integration
  - name: agent_observe
    params: {behavior: UserBehavior}
    returns: [AgentSuggestion]
    description: Agent analyzes behavior and suggests mutations

  - name: agent_evaluate_aesthetic
    params: {genome: UIGenome}
    returns: float
    description: Agent evaluates aesthetic quality

  # Population management
  - name: population_create
    params: {size: int, template: UIGenome?}
    returns: Population
    description: Create initial population

  - name: population_diversity
    params: {population: Population}
    returns: float
    description: Calculate population diversity

  - name: population_best
    params: {population: Population, count: int}
    returns: [UIGenome]
    description: Get best genomes

imports:
  - kernel.ui.pixel_grid
  - kernel.agent.core

evolution_algorithm: |
  # Evolutionary UI Algorithm
  
  ```
  1. INITIALIZE
     population = random_genomes(size=50)
     
  2. EVALUATE
     for genome in population:
       render(genome)
       metrics = collect_user_behavior()
       genome.fitness = calculate_fitness(metrics)
  
  3. SELECT
     parents = tournament_selection(population, k=3)
  
  4. CROSSOVER
     children = []
     for i in range(0, len(parents), 2):
       child = crossover(parents[i], parents[i+1])
       children.append(child)
  
  5. MUTATE
     for child in children:
       if random() < mutation_rate:
         child = mutate(child)
  
  6. AGENT GUIDANCE (optional)
     suggestions = agent.observe(user_behavior)
     for suggestion in suggestions:
       best_child = select_best(children)
       best_child = mutate_guided(best_child, suggestion)
  
  7. REPLACE
     population = elites + children
  
  8. REPEAT from step 2 until convergence
  ```

fitness_function: |
  # Fitness Function
  
  ```
  fitness = w1 * usability + w2 * aesthetics + w3 * performance + w4 * accessibility
  
  usability = (
    click_accuracy * 0.3 +
    (1 - task_time / max_time) * 0.3 +
    (1 - error_rate) * 0.2 +
    user_satisfaction * 0.2
  )
  
  aesthetics = agent_evaluate_aesthetic(genome)
  
  performance = (
    (1 - render_time / budget) * 0.5 +
    (1 - memory_usage / limit) * 0.3 +
    frame_rate / 60 * 0.2
  )
  
  accessibility = (
    contrast_ratio_score * 0.3 +
    touch_target_score * 0.3 +
    keyboard_nav_score * 0.2 +
    screen_reader_score * 0.2
  )
  ```

agent_guided_mutations: |
  # Agent-Guided Mutations
  
  The SWE Agent observes user behavior and suggests intelligent mutations:
  
  ## Pattern Recognition
  
  1. **Missed Clicks**
     - Observation: Users click near but miss button
     - Suggestion: Increase button size, add padding
  
  2. **Long Hover**
     - Observation: Users hover over element for >2s
     - Suggestion: Add tooltip, clarify purpose
  
  3. **Repeated Errors**
     - Observation: Same error occurs multiple times
     - Suggestion: Redesign flow, add guidance
  
  4. **Scroll Fatigue**
     - Observation: Excessive scrolling
     - Suggestion: Reorganize layout, add navigation
  
  ## Agent Reasoning
  
  ```
  Agent: "I observed that users miss the submit button 30% of the time.
         The button is 80x30 pixels. Fitts's Law suggests larger targets
         are easier to hit. I recommend increasing to 120x40 pixels.
         Expected improvement: 15% increase in click accuracy."
  ```
