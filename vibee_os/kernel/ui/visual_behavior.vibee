name: vibee_os_visual_behavior
version: "0.1.0"
language: gleam
module: kernel/ui/visual_behavior
description: Visual Behavior System - Given/When/Then for pixels. Every visual change is a testable behavior.

behaviors:
  - name: pixel_behavior_execution
    given: Pixel has attached behavior specification
    when: Trigger condition is met
    then: Pixel executes behavior and transitions state
    test_cases:
      - name: execute_hover_behavior
        input: {pixel: "p_100_200", behavior: "hover", trigger: "cursor_enter"}
        expected: {executed: true, state_changed: true, color_changed: true}

  - name: behavior_chain_execution
    given: Multiple behaviors are chained
    when: First behavior completes
    then: Next behavior in chain is triggered
    test_cases:
      - name: hover_then_glow
        input: {chain: ["hover", "glow"], trigger: "cursor_enter"}
        expected: {all_executed: true, final_state: "glowing"}

  - name: behavior_verification
    given: Behavior has test cases
    when: verify_behavior is called
    then: All test cases are executed and results reported
    test_cases:
      - name: verify_button_behavior
        input: {behavior: "button_click", test_count: 5}
        expected: {verified: true, passed: 5, failed: 0}

  - name: behavior_composition
    given: Two behaviors exist
    when: compose_behaviors is called
    then: New composite behavior is created
    test_cases:
      - name: compose_hover_and_scale
        input: {behaviors: ["hover_color", "hover_scale"]}
        expected: {composed: true, new_behavior: "hover_color_scale"}

  - name: agent_creates_behavior
    given: Agent observes user interaction pattern
    when: Agent generates behavior specification
    then: New behavior is created and attached to pixels
    test_cases:
      - name: agent_creates_hover
        input: {pattern: "users expect color change on hover", region: "button"}
        expected: {behavior_created: true, spec_valid: true, attached: true}

types:
  VisualBehaviorSpec:
    id: str
    name: str
    given: GivenSpec
    when: WhenSpec
    then: ThenSpec
    test_cases: [VisualTestCase]
    metadata: BehaviorMetadata

  GivenSpec:
    conditions: [Condition]
    operator: LogicalOp

  Condition:
    variants:
      - PixelState: {state: str}
      - PixelColor: {color: int, tolerance: int}
      - RegionMembership: {region: str}
      - CursorDistance: {op: CompareOp, value: int}
      - TimeElapsed: {op: CompareOp, ms: int}
      - WavePhase: {op: CompareOp, phase: float}
      - Custom: {expr: str}

  CompareOp:
    variants:
      - Eq
      - Ne
      - Lt
      - Le
      - Gt
      - Ge

  LogicalOp:
    variants:
      - And
      - Or

  WhenSpec:
    trigger: Trigger
    debounce_ms: int?
    throttle_ms: int?

  Trigger:
    variants:
      - CursorEnter
      - CursorLeave
      - CursorMove
      - Click: {button: int}
      - DoubleClick
      - RightClick
      - DragStart
      - DragEnd
      - Drop
      - KeyDown: {key: str, modifiers: [str]}
      - KeyUp: {key: str}
      - Scroll: {direction: str}
      - Touch: {fingers: int}
      - Pinch
      - Swipe: {direction: str}
      - TimeInterval: {every_ms: int}
      - WavePulse
      - Message: {type: str, from: str}
      - StateChange: {from: str, to: str}
      - Custom: {name: str, params: {str: str}}

  ThenSpec:
    outcomes: [Outcome]
    parallel: bool

  Outcome:
    variants:
      - SetState: {state: str}
      - SetColor: {color: int}
      - TransitionColor: {to: int, duration_ms: int, easing: str}
      - TransitionOpacity: {to: float, duration_ms: int, easing: str}
      - TransitionPosition: {dx: int, dy: int, duration_ms: int, easing: str}
      - TransitionScale: {to: float, duration_ms: int, easing: str}
      - TransitionRotation: {to: float, duration_ms: int, easing: str}
      - EmitEvent: {event: str, data: {str: str}}
      - SendMessage: {to: str, type: str, data: {str: str}}
      - SpawnWave: {wave_type: str, params: {str: float}}
      - TriggerAction: {action: str, params: {str: str}}
      - PlayAnimation: {name: str}
      - StopAnimation: {name: str}
      - ChainBehavior: {behavior: str, delay_ms: int}
      - Conditional: {if_cond: str, then_outcome: Outcome, else_outcome: Outcome}

  VisualTestCase:
    name: str
    description: str?
    setup: TestSetup
    trigger: Trigger
    expected: TestExpectation
    timeout_ms: int

  TestSetup:
    pixel_states: {str: str}
    pixel_colors: {str: int}
    cursor_position: Point?
    time_offset_ms: int?

  Point:
    x: int
    y: int

  TestExpectation:
    pixel_states: {str: str}?
    pixel_colors: {str: int}?
    events_emitted: [str]?
    messages_sent: [str]?
    animations_playing: [str]?

  BehaviorMetadata:
    author: str?
    created_at: int
    modified_at: int
    version: int
    tags: [str]
    description: str?

  BehaviorRegistry:
    behaviors: {str: VisualBehaviorSpec}
    by_trigger: {str: [str]}
    by_region: {str: [str]}

  BehaviorExecution:
    behavior_id: str
    pixel_id: str
    trigger: Trigger
    started_at: int
    completed_at: int?
    outcomes_executed: [str]
    success: bool
    error: str?

  ComposedBehavior:
    id: str
    name: str
    components: [str]
    composition_type: CompositionType

  CompositionType:
    variants:
      - Sequential      # One after another
      - Parallel        # All at once
      - Conditional     # Based on condition
      - Override        # Later overrides earlier

  BehaviorVerification:
    behavior_id: str
    test_results: [TestResult]
    passed: int
    failed: int
    coverage: float

  TestResult:
    test_name: str
    passed: bool
    duration_ms: int
    error: str?
    actual: {str: str}?
    expected: {str: str}?

functions:
  # Behavior definition
  - name: behavior_define
    params: {spec: VisualBehaviorSpec}
    returns: str
    description: Define new visual behavior

  - name: behavior_from_pattern
    params: {pattern: str, region: str}
    returns: VisualBehaviorSpec
    description: Agent creates behavior from observed pattern

  - name: behavior_compose
    params: {behaviors: [str], type: CompositionType}
    returns: ComposedBehavior
    description: Compose multiple behaviors

  # Behavior attachment
  - name: behavior_attach
    params: {behavior_id: str, pixel_ids: [str]}
    returns: int
    description: Attach behavior to pixels

  - name: behavior_detach
    params: {behavior_id: str, pixel_ids: [str]}
    returns: int
    description: Detach behavior from pixels

  - name: behavior_attach_region
    params: {behavior_id: str, region_id: str}
    returns: int
    description: Attach behavior to all pixels in region

  # Behavior execution
  - name: behavior_execute
    params: {behavior_id: str, pixel_id: str, trigger: Trigger}
    returns: BehaviorExecution
    description: Execute behavior on pixel

  - name: behavior_check_conditions
    params: {behavior_id: str, pixel_id: str}
    returns: bool
    description: Check if behavior conditions are met

  # Verification
  - name: behavior_verify
    params: {behavior_id: str}
    returns: BehaviorVerification
    description: Run all test cases for behavior

  - name: behavior_verify_all
    params: {}
    returns: [BehaviorVerification]
    description: Verify all registered behaviors

  - name: behavior_test
    params: {behavior_id: str, test_name: str}
    returns: TestResult
    description: Run specific test case

  # Registry
  - name: behavior_register
    params: {spec: VisualBehaviorSpec}
    returns: bool
    description: Register behavior in registry

  - name: behavior_get
    params: {behavior_id: str}
    returns: VisualBehaviorSpec?
    description: Get behavior by ID

  - name: behavior_list
    params: {filter: {str: str}?}
    returns: [VisualBehaviorSpec]
    description: List behaviors with optional filter

  - name: behavior_search
    params: {query: str}
    returns: [VisualBehaviorSpec]
    description: Search behaviors by description

imports:
  - kernel.ui.pixel_grid
  - kernel.ui.screen_spec

given_when_then_visual: |
  # Given/When/Then for Visual Behaviors
  
  ## Traditional Code Behavior
  
  ```yaml
  behavior: add_numbers
  given: Two integers a and b
  when: add(a, b) is called
  then: Returns sum of a and b
  ```
  
  ## Visual Behavior (Same Pattern!)
  
  ```yaml
  behavior: button_hover
  given: 
    - Pixel state is Idle
    - Pixel is in button region
  when: Cursor enters pixel
  then:
    - Set state to Hover
    - Transition color to #45A049 over 200ms
    - Spawn ripple wave
  ```
  
  ## The Insight
  
  Visual interactions ARE behaviors!
  - Given: Visual preconditions
  - When: User/system trigger
  - Then: Visual outcomes
  
  This means:
  1. Every visual change is SPECIFIED
  2. Every visual change is TESTABLE
  3. Every visual change is VERIFIABLE
  4. Agent can CREATE visual behaviors
  5. Agent can EVOLVE visual behaviors

behavior_examples: |
  # Visual Behavior Examples
  
  ## 1. Hover Effect
  ```yaml
  behavior: hover_glow
  given:
    - state is Idle
    - cursor_distance > 0
  when: cursor_enter
  then:
    - set_state Hover
    - transition_color to #ffffff duration 150ms ease_out
    - spawn_wave type glow amplitude 0.5
  test_cases:
    - name: hover_changes_color
      setup: {state: Idle, color: 0x333333}
      trigger: cursor_enter
      expected: {state: Hover, color: 0xffffff}
  ```
  
  ## 2. Click Ripple
  ```yaml
  behavior: click_ripple
  given:
    - state is Hover
  when: click button 0
  then:
    - set_state Active
    - spawn_wave type ripple origin cursor amplitude 1.0
    - emit_event "clicked"
    - chain_behavior "return_to_idle" delay 300ms
  test_cases:
    - name: click_spawns_ripple
      setup: {state: Hover}
      trigger: click
      expected: {state: Active, events: ["clicked"]}
  ```
  
  ## 3. Loading Animation
  ```yaml
  behavior: loading_pulse
  given:
    - state is Loading
  when: time_interval every 500ms
  then:
    - transition_opacity to 0.5 duration 250ms ease_in_out
    - chain_behavior "loading_pulse_back" delay 250ms
  test_cases:
    - name: loading_pulses
      setup: {state: Loading, opacity: 1.0}
      trigger: time_interval
      expected: {opacity: 0.5}
  ```
  
  ## 4. Drag and Drop
  ```yaml
  behavior: draggable
  given:
    - state is Idle or Hover
  when: drag_start
  then:
    - set_state Dragging
    - transition_opacity to 0.7 duration 100ms
    - emit_event "drag_started"
  test_cases:
    - name: drag_reduces_opacity
      setup: {state: Hover, opacity: 1.0}
      trigger: drag_start
      expected: {state: Dragging, opacity: 0.7}
  ```

agent_behavior_creation: |
  # Agent Creates Visual Behaviors
  
  ## Process
  
  1. Agent OBSERVES user interactions
  2. Agent IDENTIFIES patterns
  3. Agent GENERATES behavior specification
  4. Agent TESTS behavior
  5. Agent ATTACHES to pixels
  
  ## Example
  
  Agent observes: "Users hover over buttons expecting feedback"
  
  Agent generates:
  ```yaml
  behavior: auto_hover_feedback
  given:
    - region is interactive
    - state is Idle
  when: cursor_enter
  then:
    - set_state Hover
    - transition_color to lighten(current, 20%) duration 150ms
  test_cases:
    - name: hover_lightens
      setup: {state: Idle, color: 0x4CAF50}
      trigger: cursor_enter
      expected: {state: Hover, color: 0x6FBF73}
  ```
  
  Agent verifies: All test cases pass
  Agent attaches: To all interactive regions
  
  ## Self-Improvement
  
  Agent monitors: Click accuracy after hover
  Agent learns: "Longer transition = better accuracy"
  Agent mutates: duration 150ms â†’ 200ms
  Agent verifies: Improvement confirmed
  Agent deploys: New behavior version
