name: vibee_os_vibee_evolution
version: "0.1.0"
language: gleam
module: kernel/ui/vibee_evolution
description: Vibee Evolution - the Vibee algorithm (Given/When/Then + BDD) as the DEFAULT evolution mechanism for all UI

behaviors:
  - name: evolve_using_vibee_algorithm
    given: UI exists as screen specification
    when: evolution_cycle is triggered
    then: UI evolves through specification mutations, not pixel mutations
    test_cases:
      - name: evolve_button_behavior
        input: {spec: "button.vscreen", generations: 10}
        expected: {evolved: true, spec_mutated: true, behaviors_improved: true}

  - name: mutation_is_spec_change
    given: Evolution wants to mutate UI
    when: mutate is called
    then: Mutation changes specification, which recompiles to pixels
    test_cases:
      - name: mutate_color_in_spec
        input: {spec: "button", mutation: "color_shift"}
        expected: {spec_changed: true, recompiled: true, pixels_updated: true}

  - name: fitness_includes_bdd_compliance
    given: UI variant is evaluated
    when: fitness is calculated
    then: BDD test pass rate is part of fitness score
    test_cases:
      - name: fitness_with_tests
        input: {variant: "v1", tests_passed: 10, tests_total: 10}
        expected: {bdd_score: 1.0, fitness_boosted: true}
      - name: fitness_with_failures
        input: {variant: "v2", tests_passed: 5, tests_total: 10}
        expected: {bdd_score: 0.5, fitness_penalized: true}

  - name: crossover_merges_specs
    given: Two parent specifications exist
    when: crossover is performed
    then: Child specification inherits behaviors from both parents
    test_cases:
      - name: crossover_behaviors
        input: {parent_a: "spec_a", parent_b: "spec_b"}
        expected: {child_has_behaviors_from_a: true, child_has_behaviors_from_b: true}

  - name: agent_guides_evolution_with_specs
    given: Agent observes user behavior
    when: Agent suggests improvement
    then: Agent generates new behavior specification
    test_cases:
      - name: agent_adds_behavior
        input: {observation: "users miss button", suggestion: "add hover feedback"}
        expected: {new_behavior_spec: true, attached_to_region: true}

types:
  VibeeEvolutionConfig:
    population_size: int
    generations: int
    mutation_rate: float
    crossover_rate: float
    bdd_weight: float           # Weight of BDD compliance in fitness
    usability_weight: float
    aesthetics_weight: float
    performance_weight: float
    elitism_count: int
    require_all_tests_pass: bool

  SpecGenome:
    id: str
    spec: ScreenSpec
    fitness: float
    bdd_score: float
    generation: int
    parent_ids: [str]
    mutations: [SpecMutation]

  ScreenSpec:
    name: str
    version: str
    canvas: CanvasSpec
    behaviors: [BehaviorSpec]
    regions: [RegionSpec]
    tests: [TestSpec]

  CanvasSpec:
    width: int
    height: int
    background: int
    fps: int

  BehaviorSpec:
    id: str
    name: str
    given: str
    when: str
    then: str
    test_cases: [TestCaseSpec]

  TestCaseSpec:
    name: str
    input: {str: str}
    expected: {str: str}

  RegionSpec:
    id: str
    bounds: Rect
    behavior: str
    style: StyleSpec
    children: [RegionSpec]

  Rect:
    x: int
    y: int
    width: int
    height: int

  StyleSpec:
    background: int?
    foreground: int?
    border_color: int?
    border_width: int?
    border_radius: int?
    opacity: float?

  TestSpec:
    name: str
    steps: [str]
    assertions: [str]

  SpecMutation:
    type: SpecMutationType
    target: str
    params: {str: str}

  SpecMutationType:
    variants:
      # Behavior mutations
      - AddBehavior: {template: str}
      - RemoveBehavior: {behavior_id: str}
      - ModifyGiven: {behavior_id: str, new_given: str}
      - ModifyWhen: {behavior_id: str, new_when: str}
      - ModifyThen: {behavior_id: str, new_then: str}
      - AddTestCase: {behavior_id: str}
      - ModifyTestCase: {behavior_id: str, test_name: str}
      
      # Region mutations
      - AddRegion: {template: str}
      - RemoveRegion: {region_id: str}
      - MoveRegion: {region_id: str, dx: int, dy: int}
      - ResizeRegion: {region_id: str, dw: int, dh: int}
      - RecolorRegion: {region_id: str, color: int}
      - ReparentRegion: {region_id: str, new_parent: str}
      
      # Style mutations
      - ModifyStyle: {region_id: str, property: str, value: str}
      
      # Canvas mutations
      - ModifyCanvas: {property: str, value: str}

  SpecCrossover:
    type: SpecCrossoverType
    parent_a: str
    parent_b: str

  SpecCrossoverType:
    variants:
      - BehaviorSwap       # Swap behaviors between parents
      - RegionSwap         # Swap regions between parents
      - StyleBlend         # Blend styles from both parents
      - TestMerge          # Merge test cases from both parents

  VibeeEvolutionState:
    config: VibeeEvolutionConfig
    population: [SpecGenome]
    generation: int
    best_fitness: float
    best_genome: SpecGenome?
    bdd_compliance: float
    running: bool

  VibeeEvolutionResult:
    best_spec: ScreenSpec
    generations_run: int
    final_fitness: float
    final_bdd_score: float
    fitness_history: [float]
    bdd_history: [float]

  BDDVerification:
    spec_id: str
    total_tests: int
    passed_tests: int
    failed_tests: int
    coverage: float
    failures: [TestFailure]

  TestFailure:
    behavior: str
    test_name: str
    expected: str
    actual: str

functions:
  # Evolution lifecycle
  - name: vibee_evolve_start
    params: {initial_spec: ScreenSpec, config: VibeeEvolutionConfig}
    returns: VibeeEvolutionState
    description: Start Vibee-based evolution

  - name: vibee_evolve_step
    params: {state: VibeeEvolutionState}
    returns: VibeeEvolutionState
    description: Run one evolution generation

  - name: vibee_evolve_until
    params: {state: VibeeEvolutionState, target_fitness: float}
    returns: VibeeEvolutionResult
    description: Evolve until target fitness reached

  - name: vibee_evolve_stop
    params: {state: VibeeEvolutionState}
    returns: VibeeEvolutionResult
    description: Stop evolution and return best result

  # Mutation
  - name: vibee_mutate_spec
    params: {genome: SpecGenome, mutation: SpecMutation}
    returns: SpecGenome
    description: Apply mutation to specification

  - name: vibee_mutate_random
    params: {genome: SpecGenome, rate: float}
    returns: SpecGenome
    description: Apply random mutations at given rate

  - name: vibee_mutate_guided
    params: {genome: SpecGenome, observation: str}
    returns: SpecGenome
    description: Agent-guided mutation based on observation

  # Crossover
  - name: vibee_crossover
    params: {parent_a: SpecGenome, parent_b: SpecGenome, type: SpecCrossoverType}
    returns: SpecGenome
    description: Create child from two parent specs

  # Fitness
  - name: vibee_fitness
    params: {genome: SpecGenome, config: VibeeEvolutionConfig}
    returns: float
    description: Calculate fitness including BDD compliance

  - name: vibee_bdd_score
    params: {genome: SpecGenome}
    returns: float
    description: Calculate BDD compliance score

  - name: vibee_verify_bdd
    params: {genome: SpecGenome}
    returns: BDDVerification
    description: Verify all BDD test cases

  # Selection
  - name: vibee_select_parents
    params: {population: [SpecGenome], count: int}
    returns: [SpecGenome]
    description: Select parents for next generation

  - name: vibee_select_survivors
    params: {population: [SpecGenome], count: int}
    returns: [SpecGenome]
    description: Select survivors (elitism)

  # Agent integration
  - name: vibee_agent_observe
    params: {genome: SpecGenome, user_behavior: str}
    returns: [SpecMutation]
    description: Agent suggests mutations based on observation

  - name: vibee_agent_create_behavior
    params: {observation: str, region: str}
    returns: BehaviorSpec
    description: Agent creates new behavior specification

imports:
  - kernel.ui.screen_spec
  - kernel.ui.visual_behavior
  - kernel.ui.evolution_engine
  - kernel.agent.core

vibee_evolution_algorithm: |
  # Vibee Evolution Algorithm
  
  The key insight: Evolution operates on SPECIFICATIONS, not pixels!
  
  ## Traditional UI Evolution
  ```
  Mutate pixels → Render → Evaluate → Select
  ```
  
  ## Vibee UI Evolution
  ```
  Mutate SPEC → Verify BDD → Compile → Render → Evaluate → Select
  ```
  
  ## The Algorithm
  
  ```
  1. INITIALIZE
     population = [random_spec_variants(base_spec)]
     
  2. FOR each generation:
     
     a. VERIFY BDD
        for genome in population:
          genome.bdd_score = run_all_tests(genome.spec)
          if config.require_all_tests_pass and genome.bdd_score < 1.0:
            genome.fitness = 0  # Reject invalid specs
     
     b. COMPILE & RENDER
        for genome in population:
          compiled = compile_spec(genome.spec)
          render(compiled)
     
     c. EVALUATE FITNESS
        for genome in population:
          usability = measure_usability(genome)
          aesthetics = agent_evaluate_aesthetics(genome)
          performance = measure_performance(genome)
          
          genome.fitness = (
            config.bdd_weight * genome.bdd_score +
            config.usability_weight * usability +
            config.aesthetics_weight * aesthetics +
            config.performance_weight * performance
          )
     
     d. SELECT PARENTS
        parents = tournament_select(population, k=3)
     
     e. CROSSOVER SPECS
        children = []
        for i in range(0, len(parents), 2):
          child_spec = crossover_specs(parents[i], parents[i+1])
          children.append(child_spec)
     
     f. MUTATE SPECS
        for child in children:
          if random() < config.mutation_rate:
            mutation = select_mutation()
            child.spec = apply_mutation(child.spec, mutation)
     
     g. AGENT GUIDANCE
        observations = agent.observe(user_behavior)
        for obs in observations:
          best_child = select_best(children)
          new_behavior = agent.create_behavior(obs)
          best_child.spec.behaviors.append(new_behavior)
     
     h. VERIFY NEW SPECS
        for child in children:
          child.bdd_score = run_all_tests(child.spec)
     
     i. REPLACE
        population = elites + children
  
  3. RETURN best_genome.spec
  ```

fitness_with_bdd: |
  # Fitness Function with BDD Compliance
  
  ```
  fitness = (
    bdd_weight * bdd_score +
    usability_weight * usability_score +
    aesthetics_weight * aesthetics_score +
    performance_weight * performance_score
  )
  
  where:
  
  bdd_score = passed_tests / total_tests
  
  usability_score = (
    click_accuracy * 0.3 +
    task_completion_rate * 0.3 +
    (1 - error_rate) * 0.2 +
    user_satisfaction * 0.2
  )
  
  aesthetics_score = agent_evaluate(spec)
  
  performance_score = (
    (1 - render_time / budget) * 0.5 +
    (1 - memory / limit) * 0.3 +
    fps / 60 * 0.2
  )
  ```
  
  ## Default Weights
  
  ```
  bdd_weight: 0.3        # 30% - Correctness is critical
  usability_weight: 0.3  # 30% - User experience
  aesthetics_weight: 0.2 # 20% - Visual appeal
  performance_weight: 0.2 # 20% - Speed
  ```
  
  ## BDD as Gatekeeper
  
  If `require_all_tests_pass = true`:
  - Any spec with failing tests gets fitness = 0
  - Only correct specs can survive
  - Evolution CANNOT break functionality

spec_mutation_examples: |
  # Specification Mutation Examples
  
  ## 1. Add Behavior
  ```yaml
  mutation: AddBehavior
  template: hover_feedback
  result:
    behaviors:
      - name: hover_feedback
        given: state is Idle
        when: cursor_enter
        then: transition_color to lighten(20%)
  ```
  
  ## 2. Modify Then Clause
  ```yaml
  mutation: ModifyThen
  behavior_id: button_click
  new_then: |
    set_state Active
    spawn_wave ripple amplitude 1.5  # Was 1.0
    emit_event "clicked"
  ```
  
  ## 3. Add Test Case
  ```yaml
  mutation: AddTestCase
  behavior_id: button_hover
  result:
    test_cases:
      - name: hover_on_disabled
        input: {state: Disabled}
        trigger: cursor_enter
        expected: {state: Disabled}  # No change
  ```
  
  ## 4. Resize Region
  ```yaml
  mutation: ResizeRegion
  region_id: submit_btn
  dw: +50
  dh: +10
  result:
    bounds: {x: 810, y: 520, width: 350, height: 60}  # Was 300x50
  ```

why_vibee_evolution: |
  # Why Vibee Algorithm for Evolution?
  
  ## Problem with Pixel-Level Evolution
  
  1. Mutations can break functionality
  2. No way to verify correctness
  3. Chaotic, unpredictable results
  4. Hard to understand what changed
  
  ## Solution: Specification-Level Evolution
  
  1. Mutations are MEANINGFUL (change behaviors, not random pixels)
  2. BDD tests VERIFY correctness
  3. Predictable, controlled evolution
  4. Changes are DOCUMENTED in spec
  
  ## The Vibee Guarantee
  
  ```
  If all BDD tests pass → UI is correct by construction
  ```
  
  This means:
  - Evolution CANNOT break working features
  - Every mutation is TESTED before deployment
  - Agent can TRUST the evolved UI
  - Users get RELIABLE improvements
