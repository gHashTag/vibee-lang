# ============================================================================
# GRAPHQL - GraphQL Server на Vibee
# ============================================================================
# Schema, resolvers, subscriptions, dataloaders
# ============================================================================

Specification GraphQL:
  """GraphQL как спецификация API."""

  # ==========================================================================
  # SCHEMA TYPES
  # ==========================================================================

  Type Schema:
    query: ObjectType
    mutation: ObjectType?
    subscription: ObjectType?
    types: Map<String, TypeDefinition>
    directives: List<Directive>

  Type TypeDefinition:
    variants:
      - Scalar: ScalarType
      - Object: ObjectType
      - Interface: InterfaceType
      - Union: UnionType
      - Enum: EnumType
      - InputObject: InputObjectType

  Type ObjectType:
    name: String
    fields: Map<String, Field>
    interfaces: List<String>
    directives: List<DirectiveUsage>

  Type Field:
    name: String
    type: FieldType
    args: Map<String, Argument>
    resolver: Resolver?
    directives: List<DirectiveUsage>

  Type FieldType:
    variants:
      - Named: String
      - NonNull: FieldType
      - List: FieldType

  Type Argument:
    name: String
    type: FieldType
    default_value: Any?

  Type ScalarType:
    name: String
    serialize: (Any) -> Any
    parse_value: (Any) -> Any
    parse_literal: (AST) -> Any

  Type EnumType:
    name: String
    values: List<EnumValue>

  Type EnumValue:
    name: String
    value: Any
    deprecated: String?

  Type InterfaceType:
    name: String
    fields: Map<String, Field>
    resolve_type: (Any) -> String

  Type UnionType:
    name: String
    types: List<String>
    resolve_type: (Any) -> String

  Type InputObjectType:
    name: String
    fields: Map<String, InputField>

  Type InputField:
    name: String
    type: FieldType
    default_value: Any?

  Type Directive:
    name: String
    locations: List<DirectiveLocation>
    args: Map<String, Argument>

  Type DirectiveLocation:
    variants: [Query, Mutation, Subscription, Field, FragmentDefinition, 
               FragmentSpread, InlineFragment, Schema, Scalar, Object,
               FieldDefinition, ArgumentDefinition, Interface, Union,
               Enum, EnumValue, InputObject, InputFieldDefinition]

  Type DirectiveUsage:
    name: String
    args: Map<String, Any>

  # ==========================================================================
  # RESOLVERS
  # ==========================================================================

  Type Resolver:
    function: (parent: Any, args: Map<String, Any>, context: Context, info: ResolveInfo) -> Async<Any>

  Type Context:
    request: Request
    user: User?
    dataloaders: Map<String, DataLoader>
    services: Map<String, Any>

  Type ResolveInfo:
    field_name: String
    return_type: FieldType
    parent_type: ObjectType
    path: List<String | Int>
    schema: Schema
    fragments: Map<String, Fragment>
    operation: Operation
    variable_values: Map<String, Any>

  Type Operation:
    type: OperationType
    name: String?
    selection_set: SelectionSet
    variables: List<VariableDefinition>

  Type OperationType:
    variants: [Query, Mutation, Subscription]

  Type SelectionSet:
    selections: List<Selection>

  Type Selection:
    variants:
      - Field: FieldSelection
      - FragmentSpread: String
      - InlineFragment: InlineFragmentSelection

  Type FieldSelection:
    name: String
    alias: String?
    args: Map<String, Any>
    selection_set: SelectionSet?

  # ==========================================================================
  # DATALOADER
  # ==========================================================================

  Type DataLoader<K, V>:
    batch_fn: (List<K>) -> Async<List<V>>
    cache: Map<K, Promise<V>>
    queue: List<K>
    options: DataLoaderOptions

  Type DataLoaderOptions:
    batch: Boolean = true
    max_batch_size: Int = 100
    cache: Boolean = true

  Behavior DataLoaderBehavior:
    When loader.load(key):
      Then:
        - if options.cache and cache.has(key):
            - return cache.get(key)
        - promise = create_promise()
        - cache.set(key, promise)
        - queue.push(key)
        - schedule_batch()
        - return promise

    When loader.load_many(keys):
      Then: Promise.all(keys.map(k -> loader.load(k)))

    When schedule_batch():
      Then:
        - if batch_scheduled: return
        - batch_scheduled = true
        - next_tick(() ->
            - keys = queue.splice(0, options.max_batch_size)
            - batch_scheduled = false
            - if keys.is_empty(): return
            - results = await batch_fn(keys)
            - for (key, result) in zip(keys, results):
                - cache.get(key).resolve(result)
          )

    When loader.clear(key):
      Then: cache.delete(key)

    When loader.clear_all():
      Then: cache.clear()

  # ==========================================================================
  # EXECUTION
  # ==========================================================================

  Behavior Executor:
    When execute(schema, document, variables, context):
      Then:
        - operation = get_operation(document)
        - coerced_vars = coerce_variables(operation.variables, variables)
        - root_value = get_root_value(operation.type)
        
        - match operation.type:
            Query -> execute_query(schema, operation, root_value, coerced_vars, context)
            Mutation -> execute_mutation(schema, operation, root_value, coerced_vars, context)
            Subscription -> subscribe(schema, operation, root_value, coerced_vars, context)

    When execute_query(schema, operation, root, variables, context):
      Then:
        - type = schema.query
        - return await execute_selection_set(operation.selection_set, type, root, variables, context)

    When execute_selection_set(selection_set, type, root, variables, context):
      Then:
        - result = {}
        - for selection in selection_set.selections:
            - match selection:
                Field(f) ->
                  key = f.alias ?? f.name
                  result[key] = await execute_field(f, type, root, variables, context)
                FragmentSpread(name) ->
                  fragment = context.fragments[name]
                  if applies_to(fragment, type):
                    merge(result, await execute_selection_set(fragment.selection_set, type, root, variables, context))
                InlineFragment(f) ->
                  if applies_to(f, type):
                    merge(result, await execute_selection_set(f.selection_set, type, root, variables, context))
        - return result

    When execute_field(field, parent_type, parent, variables, context):
      Then:
        - field_def = parent_type.fields[field.name]
        - args = coerce_arguments(field_def.args, field.args, variables)
        - info = ResolveInfo(field.name, field_def.type, parent_type, ...)
        
        - resolver = field_def.resolver ?? default_resolver
        - result = await resolver(parent, args, context, info)
        
        - return complete_value(field_def.type, field.selection_set, result, variables, context)

    When complete_value(type, selection_set, result, variables, context):
      Then:
        - match type:
            NonNull(inner) ->
              value = await complete_value(inner, selection_set, result, variables, context)
              if value == null: raise NonNullViolation
              value
            List(inner) ->
              result.map(item -> complete_value(inner, selection_set, item, variables, context))
            Named(name) ->
              type_def = schema.types[name]
              match type_def:
                Scalar(s) -> s.serialize(result)
                Enum(e) -> serialize_enum(e, result)
                Object(o) -> execute_selection_set(selection_set, o, result, variables, context)
                Interface(i) -> 
                  concrete = i.resolve_type(result)
                  execute_selection_set(selection_set, schema.types[concrete], result, variables, context)
                Union(u) ->
                  concrete = u.resolve_type(result)
                  execute_selection_set(selection_set, schema.types[concrete], result, variables, context)

  # ==========================================================================
  # SUBSCRIPTIONS
  # ==========================================================================

  Behavior Subscriptions:
    Type SubscriptionManager:
      subscriptions: Map<String, Set<Subscriber>>
      pubsub: PubSub

    Type Subscriber:
      id: String
      query: String
      variables: Map<String, Any>
      context: Context
      callback: (Any) -> Unit

    When subscribe(schema, operation, root, variables, context):
      Then:
        - field = operation.selection_set.selections[0] as Field
        - field_def = schema.subscription.fields[field.name]
        - subscribe_fn = field_def.subscribe
        - async_iterator = await subscribe_fn(root, coerce_arguments(field_def.args, field.args, variables), context)
        
        - return async_iterator.map(event ->
            execute_selection_set(field.selection_set, field_def.type, event, variables, context)
          )

    When pubsub.publish(topic, payload):
      Then:
        - subscribers = subscriptions.get(topic) ?? []
        - for subscriber in subscribers:
            - result = await execute(schema, parse(subscriber.query), subscriber.variables, subscriber.context)
            - subscriber.callback(result)

    When pubsub.subscribe(topic, callback):
      Then:
        - subscriber = Subscriber(generate_id(), topic, callback)
        - subscriptions.get_or_create(topic, Set()).add(subscriber)
        - return () -> subscriptions.get(topic).remove(subscriber)

  # ==========================================================================
  # SCHEMA DSL
  # ==========================================================================

  Behavior SchemaDSL:
    When GraphQL.schema(define):
      Then:
        - builder = SchemaBuilder()
        - define(builder)
        - return builder.build()

    When builder.type(name, define):
      Then:
        - type_builder = ObjectTypeBuilder(name)
        - define(type_builder)
        - add type_builder.build() to types

    When type_builder.field(name, type, resolve):
      Then:
        - add Field(name, parse_type(type), resolve) to fields

    When type_builder.field(name, type, args, resolve):
      Then:
        - add Field(name, parse_type(type), parse_args(args), resolve) to fields

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "GraphQL API":
    ```vibee
    schema = GraphQL.schema((s) ->
      s.type("Query", (t) ->
        t.field("user", "User", { id: "ID!" }, (_, args, ctx) ->
          ctx.dataloaders.user.load(args.id)
        )
        t.field("users", "[User!]!", (_, _, ctx) ->
          UserRepository.find_all()
        )
      )
      
      s.type("User", (t) ->
        t.field("id", "ID!")
        t.field("name", "String!")
        t.field("posts", "[Post!]!", (user, _, ctx) ->
          ctx.dataloaders.posts_by_user.load(user.id)
        )
      )
      
      s.type("Mutation", (t) ->
        t.field("createUser", "User!", { input: "CreateUserInput!" }, (_, args, ctx) ->
          UserRepository.create(args.input)
        )
      )
      
      s.type("Subscription", (t) ->
        t.field("userCreated", "User!", subscribe: (_, _, ctx) ->
          ctx.pubsub.async_iterator("USER_CREATED")
        )
      )
    )
    ```
