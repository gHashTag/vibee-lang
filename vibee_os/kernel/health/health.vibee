# ============================================================================
# HEALTH - Проверка здоровья системы на Vibee
# ============================================================================
# Health checks, Readiness, Liveness, Dependencies
# ============================================================================

Specification Health:
  """Health checks как спецификация мониторинга состояния системы."""

  # ==========================================================================
  # HEALTH STATUS
  # ==========================================================================

  Type HealthStatus:
    variants:
      - Healthy
      - Degraded
      - Unhealthy

    Method is_healthy() -> Boolean:
      return self == Healthy

    Method is_up() -> Boolean:
      return self != Unhealthy

    Method to_string() -> String:
      match self:
        Healthy -> "healthy"
        Degraded -> "degraded"
        Unhealthy -> "unhealthy"

    Method http_status() -> Int:
      match self:
        Healthy -> 200
        Degraded -> 200
        Unhealthy -> 503

  Type HealthCheckResult:
    name: String
    status: HealthStatus
    message: Option<String>
    duration: Duration
    details: Map<String, Any>
    timestamp: Instant

    Static Method healthy(name: String) -> HealthCheckResult:
      return HealthCheckResult(
        name: name,
        status: HealthStatus.Healthy,
        message: null,
        duration: Duration.zero(),
        details: {},
        timestamp: Instant.now()
      )

    Static Method unhealthy(name: String, message: String) -> HealthCheckResult:
      return HealthCheckResult(
        name: name,
        status: HealthStatus.Unhealthy,
        message: Some(message),
        duration: Duration.zero(),
        details: {},
        timestamp: Instant.now()
      )

    Static Method degraded(name: String, message: String) -> HealthCheckResult:
      return HealthCheckResult(
        name: name,
        status: HealthStatus.Degraded,
        message: Some(message),
        duration: Duration.zero(),
        details: {},
        timestamp: Instant.now()
      )

    Method with_duration(duration: Duration) -> HealthCheckResult:
      return HealthCheckResult(..self, duration: duration)

    Method with_details(details: Map<String, Any>) -> HealthCheckResult:
      return HealthCheckResult(..self, details: details)

    Method with_detail(key: String, value: Any) -> HealthCheckResult:
      return HealthCheckResult(..self, details: self.details.set(key, value))

  # ==========================================================================
  # HEALTH CHECK TRAIT
  # ==========================================================================

  Trait HealthCheck:
    Method name() -> String
    Method check() -> HealthCheckResult
    Method check_async() -> Promise<HealthCheckResult>:
      return Promise.resolve(self.check())

  # ==========================================================================
  # HEALTH REGISTRY
  # ==========================================================================

  Type HealthRegistry:
    checks: Map<String, HealthCheck>
    liveness_checks: Set<String>
    readiness_checks: Set<String>
    config: HealthConfig
    cache: Option<CachedHealth>
    mutex: Mutex<()>

    Static Method new() -> HealthRegistry:
      return HealthRegistry.with_config(HealthConfig.default())

    Static Method with_config(config: HealthConfig) -> HealthRegistry:
      return HealthRegistry(
        checks: {},
        liveness_checks: Set(),
        readiness_checks: Set(),
        config: config,
        cache: null,
        mutex: Mutex.new(())
      )

    Method register(check: HealthCheck):
      name = check.name()
      self.checks[name] = check
      self.readiness_checks.add(name)

    Method register_liveness(check: HealthCheck):
      name = check.name()
      self.checks[name] = check
      self.liveness_checks.add(name)

    Method register_readiness(check: HealthCheck):
      name = check.name()
      self.checks[name] = check
      self.readiness_checks.add(name)

    Method unregister(name: String):
      self.checks.remove(name)
      self.liveness_checks.remove(name)
      self.readiness_checks.remove(name)

    Method check_health() -> HealthReport:
      return self.run_checks(self.checks.keys().to_list())

    Method check_liveness() -> HealthReport:
      return self.run_checks(self.liveness_checks.to_list())

    Method check_readiness() -> HealthReport:
      return self.run_checks(self.readiness_checks.to_list())

    Method run_checks(names: List<String>) -> HealthReport:
      # Check cache
      if self.config.cache_duration is Some(duration):
        guard = self.mutex.lock()
        if self.cache is Some(cached):
          if cached.timestamp + duration > Instant.now():
            return cached.report
      
      start = Instant.now()
      results = []
      
      if self.config.parallel:
        # Run checks in parallel
        futures = names.map(name -> {
          check = self.checks[name]
          spawn { self.run_single_check(check) }
        })
        
        for future in futures:
          results.push(future.join())
      else:
        # Run checks sequentially
        for name in names:
          check = self.checks[name]
          results.push(self.run_single_check(check))
      
      report = HealthReport.from_results(results)
      report.duration = Instant.now() - start
      
      # Update cache
      if self.config.cache_duration is Some(_):
        guard = self.mutex.lock()
        self.cache = Some(CachedHealth(report, Instant.now()))
      
      return report

    Method run_single_check(check: HealthCheck) -> HealthCheckResult:
      start = Instant.now()
      
      result = if self.config.timeout is Some(timeout):
        try:
          timeout_call(timeout, () -> check.check())
        catch TimeoutError:
          HealthCheckResult.unhealthy(check.name(), "Health check timed out")
      else:
        try:
          check.check()
        catch error:
          HealthCheckResult.unhealthy(check.name(), error.message())
      
      return result.with_duration(Instant.now() - start)

    Method check_health_async() -> Promise<HealthReport>:
      return Promise.new((resolve, _) -> {
        resolve(self.check_health())
      })

  Type CachedHealth:
    report: HealthReport
    timestamp: Instant

  Type HealthConfig:
    timeout: Option<Duration>
    cache_duration: Option<Duration>
    parallel: Boolean
    include_details: Boolean

    Static Method default() -> HealthConfig:
      return HealthConfig(
        timeout: Some(Duration.seconds(10)),
        cache_duration: null,
        parallel: true,
        include_details: true
      )

  # ==========================================================================
  # HEALTH REPORT
  # ==========================================================================

  Type HealthReport:
    status: HealthStatus
    checks: List<HealthCheckResult>
    duration: Duration
    timestamp: Instant

    Static Method from_results(results: List<HealthCheckResult>) -> HealthReport:
      status = HealthStatus.Healthy
      
      for result in results:
        match result.status:
          Unhealthy -> status = HealthStatus.Unhealthy
          Degraded -> 
            if status == Healthy:
              status = HealthStatus.Degraded
          Healthy -> pass
      
      return HealthReport(
        status: status,
        checks: results,
        duration: Duration.zero(),
        timestamp: Instant.now()
      )

    Method is_healthy() -> Boolean:
      return self.status.is_healthy()

    Method is_up() -> Boolean:
      return self.status.is_up()

    Method to_json() -> String:
      return json.encode({
        "status": self.status.to_string(),
        "checks": self.checks.map(c -> {
          "name": c.name,
          "status": c.status.to_string(),
          "message": c.message,
          "duration_ms": c.duration.as_millis(),
          "details": c.details
        }),
        "duration_ms": self.duration.as_millis(),
        "timestamp": self.timestamp.to_iso8601()
      })

    Method to_simple_json() -> String:
      return json.encode({
        "status": self.status.to_string()
      })

  # ==========================================================================
  # BUILT-IN HEALTH CHECKS
  # ==========================================================================

  Type DatabaseHealthCheck:
    name: String
    connection: () -> DatabaseConnection
    query: String

    Static Method new(name: String, connection: () -> DatabaseConnection) -> DatabaseHealthCheck:
      return DatabaseHealthCheck(name, connection, "SELECT 1")

    Static Method with_query(name: String, connection: () -> DatabaseConnection, query: String) -> DatabaseHealthCheck:
      return DatabaseHealthCheck(name, connection, query)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        try:
          conn = self.connection()
          start = Instant.now()
          conn.execute(self.query)
          latency = Instant.now() - start
          
          return HealthCheckResult.healthy(self.name)
            .with_detail("latency_ms", latency.as_millis())
        catch error:
          return HealthCheckResult.unhealthy(self.name, error.message())

  Type HttpHealthCheck:
    name: String
    url: String
    timeout: Duration
    expected_status: Int

    Static Method new(name: String, url: String) -> HttpHealthCheck:
      return HttpHealthCheck(name, url, Duration.seconds(5), 200)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        try:
          start = Instant.now()
          response = http.get(self.url)
            .timeout(self.timeout)
            .send()
          latency = Instant.now() - start
          
          if response.status == self.expected_status:
            return HealthCheckResult.healthy(self.name)
              .with_detail("status", response.status)
              .with_detail("latency_ms", latency.as_millis())
          else:
            return HealthCheckResult.unhealthy(
              self.name,
              "Unexpected status: ${response.status}"
            ).with_detail("status", response.status)
        catch error:
          return HealthCheckResult.unhealthy(self.name, error.message())

  Type RedisHealthCheck:
    name: String
    client: () -> RedisClient

    Static Method new(name: String, client: () -> RedisClient) -> RedisHealthCheck:
      return RedisHealthCheck(name, client)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        try:
          client = self.client()
          start = Instant.now()
          result = client.ping()
          latency = Instant.now() - start
          
          if result == "PONG":
            return HealthCheckResult.healthy(self.name)
              .with_detail("latency_ms", latency.as_millis())
          else:
            return HealthCheckResult.unhealthy(self.name, "Unexpected ping response")
        catch error:
          return HealthCheckResult.unhealthy(self.name, error.message())

  Type DiskSpaceHealthCheck:
    name: String
    path: Path
    threshold_percent: Float

    Static Method new(path: Path) -> DiskSpaceHealthCheck:
      return DiskSpaceHealthCheck("disk_space", path, 90.0)

    Static Method with_threshold(path: Path, threshold: Float) -> DiskSpaceHealthCheck:
      return DiskSpaceHealthCheck("disk_space", path, threshold)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        try:
          info = disk_usage(self.path)
          used_percent = (info.used.to_float() / info.total.to_float()) * 100.0
          
          details = {
            "total_bytes": info.total,
            "used_bytes": info.used,
            "free_bytes": info.free,
            "used_percent": used_percent
          }
          
          if used_percent >= self.threshold_percent:
            return HealthCheckResult.unhealthy(
              self.name,
              "Disk usage ${used_percent.round(1)}% exceeds threshold ${self.threshold_percent}%"
            ).with_details(details)
          else if used_percent >= self.threshold_percent * 0.9:
            return HealthCheckResult.degraded(
              self.name,
              "Disk usage ${used_percent.round(1)}% approaching threshold"
            ).with_details(details)
          else:
            return HealthCheckResult.healthy(self.name)
              .with_details(details)
        catch error:
          return HealthCheckResult.unhealthy(self.name, error.message())

  Type MemoryHealthCheck:
    name: String
    threshold_percent: Float

    Static Method new() -> MemoryHealthCheck:
      return MemoryHealthCheck("memory", 90.0)

    Static Method with_threshold(threshold: Float) -> MemoryHealthCheck:
      return MemoryHealthCheck("memory", threshold)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        try:
          info = memory_usage()
          used_percent = (info.used.to_float() / info.total.to_float()) * 100.0
          
          details = {
            "total_bytes": info.total,
            "used_bytes": info.used,
            "free_bytes": info.free,
            "used_percent": used_percent
          }
          
          if used_percent >= self.threshold_percent:
            return HealthCheckResult.unhealthy(
              self.name,
              "Memory usage ${used_percent.round(1)}% exceeds threshold"
            ).with_details(details)
          else:
            return HealthCheckResult.healthy(self.name)
              .with_details(details)
        catch error:
          return HealthCheckResult.unhealthy(self.name, error.message())

  Type CustomHealthCheck:
    name: String
    check_fn: () -> HealthCheckResult

    Static Method new(name: String, check: () -> HealthCheckResult) -> CustomHealthCheck:
      return CustomHealthCheck(name, check)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        return self.check_fn()

  # ==========================================================================
  # COMPOSITE HEALTH CHECK
  # ==========================================================================

  Type CompositeHealthCheck:
    name: String
    checks: List<HealthCheck>
    strategy: CompositeStrategy

    Static Method all(name: String, checks: List<HealthCheck>) -> CompositeHealthCheck:
      return CompositeHealthCheck(name, checks, CompositeStrategy.All)

    Static Method any(name: String, checks: List<HealthCheck>) -> CompositeHealthCheck:
      return CompositeHealthCheck(name, checks, CompositeStrategy.Any)

    Trait HealthCheck:
      Method name() -> String:
        return self.name

      Method check() -> HealthCheckResult:
        results = self.checks.map(c -> c.check())
        
        status = match self.strategy:
          All ->
            if results.all(r -> r.status == Healthy):
              HealthStatus.Healthy
            else if results.any(r -> r.status == Unhealthy):
              HealthStatus.Unhealthy
            else:
              HealthStatus.Degraded
          Any ->
            if results.any(r -> r.status == Healthy):
              HealthStatus.Healthy
            else if results.all(r -> r.status == Unhealthy):
              HealthStatus.Unhealthy
            else:
              HealthStatus.Degraded
        
        return HealthCheckResult(
          name: self.name,
          status: status,
          message: null,
          duration: Duration.zero(),
          details: {
            "checks": results.map(r -> {
              "name": r.name,
              "status": r.status.to_string()
            })
          },
          timestamp: Instant.now()
        )

  Type CompositeStrategy:
    variants:
      - All  # All must be healthy
      - Any  # At least one must be healthy

  # ==========================================================================
  # HTTP ENDPOINTS
  # ==========================================================================

  Behavior HealthEndpoints:
    When health_handler(registry: HealthRegistry) -> Handler:
      Then:
        return (req: Request, res: Response) -> {
          report = registry.check_health()
          
          res.status(report.status.http_status())
          res.header("Content-Type", "application/json")
          res.body(report.to_json())
        }

    When liveness_handler(registry: HealthRegistry) -> Handler:
      Then:
        return (req: Request, res: Response) -> {
          report = registry.check_liveness()
          
          res.status(report.status.http_status())
          res.header("Content-Type", "application/json")
          res.body(report.to_simple_json())
        }

    When readiness_handler(registry: HealthRegistry) -> Handler:
      Then:
        return (req: Request, res: Response) -> {
          report = registry.check_readiness()
          
          res.status(report.status.http_status())
          res.header("Content-Type", "application/json")
          res.body(report.to_json())
        }

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Health":
    ```vibee
    # Create health registry
    health = HealthRegistry.new()

    # Register health checks
    health.register(DatabaseHealthCheck.new("postgres", () -> db.connection()))
    health.register(RedisHealthCheck.new("redis", () -> redis.client()))
    health.register(HttpHealthCheck.new("api", "http://api.example.com/health"))
    health.register(DiskSpaceHealthCheck.with_threshold(Path("/"), 85.0))
    health.register(MemoryHealthCheck.with_threshold(80.0))

    # Custom health check
    health.register(CustomHealthCheck.new("queue", () -> {
      queue_size = message_queue.size()
      
      if queue_size > 10000:
        HealthCheckResult.unhealthy("queue", "Queue backlog too large: ${queue_size}")
      else if queue_size > 5000:
        HealthCheckResult.degraded("queue", "Queue backlog growing: ${queue_size}")
          .with_detail("size", queue_size)
      else:
        HealthCheckResult.healthy("queue")
          .with_detail("size", queue_size)
    }))

    # Liveness vs Readiness
    health.register_liveness(CustomHealthCheck.new("alive", () -> {
      # Basic check - is the process running?
      HealthCheckResult.healthy("alive")
    }))

    health.register_readiness(DatabaseHealthCheck.new("db", () -> db.connection()))

    # Check health
    report = health.check_health()
    
    if report.is_healthy():
      print("All systems operational")
    else:
      for check in report.checks:
        if not check.status.is_healthy():
          print("${check.name}: ${check.status} - ${check.message}")

    # HTTP endpoints
    app.get("/health", health_handler(health))
    app.get("/health/live", liveness_handler(health))
    app.get("/health/ready", readiness_handler(health))

    # Response example:
    # {
    #   "status": "healthy",
    #   "checks": [
    #     {
    #       "name": "postgres",
    #       "status": "healthy",
    #       "duration_ms": 5,
    #       "details": { "latency_ms": 5 }
    #     },
    #     {
    #       "name": "redis",
    #       "status": "healthy",
    #       "duration_ms": 2,
    #       "details": { "latency_ms": 2 }
    #     },
    #     {
    #       "name": "disk_space",
    #       "status": "healthy",
    #       "duration_ms": 1,
    #       "details": {
    #         "total_bytes": 107374182400,
    #         "used_bytes": 53687091200,
    #         "free_bytes": 53687091200,
    #         "used_percent": 50.0
    #       }
    #     }
    #   ],
    #   "duration_ms": 15,
    #   "timestamp": "2024-01-15T10:30:00Z"
    # }

    # Composite health check
    databases = CompositeHealthCheck.all("databases", [
      DatabaseHealthCheck.new("primary", () -> primary_db.connection()),
      DatabaseHealthCheck.new("replica", () -> replica_db.connection())
    ])

    caches = CompositeHealthCheck.any("caches", [
      RedisHealthCheck.new("redis1", () -> redis1.client()),
      RedisHealthCheck.new("redis2", () -> redis2.client())
    ])

    health.register(databases)
    health.register(caches)

    # With caching
    health = HealthRegistry.with_config(HealthConfig(
      timeout: Some(Duration.seconds(5)),
      cache_duration: Some(Duration.seconds(10)),
      parallel: true,
      include_details: true
    ))

    # Kubernetes probes
    # livenessProbe:
    #   httpGet:
    #     path: /health/live
    #     port: 8080
    #   initialDelaySeconds: 10
    #   periodSeconds: 10
    #
    # readinessProbe:
    #   httpGet:
    #     path: /health/ready
    #     port: 8080
    #   initialDelaySeconds: 5
    #   periodSeconds: 5
    ```
