# ============================================================================
# MIME - Определение типов файлов на Vibee
# ============================================================================
# MIME types, Magic bytes, Content-Type
# ============================================================================

Specification MIME:
  """MIME как спецификация определения типов контента."""

  # ==========================================================================
  # MIME TYPE
  # ==========================================================================

  Type MimeType:
    type: String
    subtype: String
    parameters: Map<String, String>

    Static Method parse(s: String) -> Result<MimeType, MimeError>:
      # Parse: type/subtype; param=value
      parts = s.split(";")
      type_part = parts[0].trim()
      
      if not type_part.contains("/"):
        return Err(MimeError.InvalidFormat(s))
      
      type_parts = type_part.split("/")
      mime_type = type_parts[0].trim().lowercase()
      subtype = type_parts[1].trim().lowercase()
      
      params = {}
      for i in 1..parts.length:
        param = parts[i].trim()
        if param.contains("="):
          kv = param.split("=", 2)
          key = kv[0].trim().lowercase()
          value = kv[1].trim().trim_matches('"')
          params[key] = value
      
      return Ok(MimeType(mime_type, subtype, params))

    Static Method new(type: String, subtype: String) -> MimeType:
      return MimeType(type.lowercase(), subtype.lowercase(), {})

    Method to_string() -> String:
      base = "${self.type}/${self.subtype}"
      
      if self.parameters.is_empty():
        return base
      
      params = self.parameters.entries()
        .map((k, v) -> "${k}=${v}")
        .join("; ")
      
      return "${base}; ${params}"

    Method with_charset(charset: String) -> MimeType:
      return MimeType(self.type, self.subtype, self.parameters.set("charset", charset))

    Method charset() -> Option<String>:
      return self.parameters.get("charset")

    Method essence() -> String:
      return "${self.type}/${self.subtype}"

    Method is_text() -> Boolean:
      return self.type == "text"

    Method is_image() -> Boolean:
      return self.type == "image"

    Method is_audio() -> Boolean:
      return self.type == "audio"

    Method is_video() -> Boolean:
      return self.type == "video"

    Method is_application() -> Boolean:
      return self.type == "application"

    Method is_json() -> Boolean:
      return self.subtype == "json" or self.subtype.ends_with("+json")

    Method is_xml() -> Boolean:
      return self.subtype == "xml" or self.subtype.ends_with("+xml")

    Method is_html() -> Boolean:
      return self.essence() == "text/html"

    Method is_binary() -> Boolean:
      return self.essence() == "application/octet-stream"

    # Common MIME types
    Static Method text_plain() -> MimeType:
      MimeType.new("text", "plain")

    Static Method text_html() -> MimeType:
      MimeType.new("text", "html")

    Static Method text_css() -> MimeType:
      MimeType.new("text", "css")

    Static Method text_javascript() -> MimeType:
      MimeType.new("text", "javascript")

    Static Method application_json() -> MimeType:
      MimeType.new("application", "json")

    Static Method application_xml() -> MimeType:
      MimeType.new("application", "xml")

    Static Method application_octet_stream() -> MimeType:
      MimeType.new("application", "octet-stream")

    Static Method application_pdf() -> MimeType:
      MimeType.new("application", "pdf")

    Static Method application_zip() -> MimeType:
      MimeType.new("application", "zip")

    Static Method application_gzip() -> MimeType:
      MimeType.new("application", "gzip")

    Static Method application_form_urlencoded() -> MimeType:
      MimeType.new("application", "x-www-form-urlencoded")

    Static Method multipart_form_data() -> MimeType:
      MimeType.new("multipart", "form-data")

    Static Method image_png() -> MimeType:
      MimeType.new("image", "png")

    Static Method image_jpeg() -> MimeType:
      MimeType.new("image", "jpeg")

    Static Method image_gif() -> MimeType:
      MimeType.new("image", "gif")

    Static Method image_webp() -> MimeType:
      MimeType.new("image", "webp")

    Static Method image_svg() -> MimeType:
      MimeType.new("image", "svg+xml")

    Static Method audio_mpeg() -> MimeType:
      MimeType.new("audio", "mpeg")

    Static Method video_mp4() -> MimeType:
      MimeType.new("video", "mp4")

  Type MimeError:
    variants:
      - InvalidFormat(String)
      - UnknownType(String)

  # ==========================================================================
  # MIME DETECTION
  # ==========================================================================

  Behavior MimeDetection:
    When mime.from_extension(ext: String) -> Option<MimeType>:
      Then:
        ext_lower = ext.trim_start(".").lowercase()
        
        match ext_lower:
          # Text
          "txt" -> Some(MimeType.text_plain())
          "html" | "htm" -> Some(MimeType.text_html())
          "css" -> Some(MimeType.text_css())
          "js" | "mjs" -> Some(MimeType.text_javascript())
          "json" -> Some(MimeType.application_json())
          "xml" -> Some(MimeType.application_xml())
          "csv" -> Some(MimeType.new("text", "csv"))
          "md" | "markdown" -> Some(MimeType.new("text", "markdown"))
          "yaml" | "yml" -> Some(MimeType.new("text", "yaml"))
          "toml" -> Some(MimeType.new("text", "toml"))
          
          # Images
          "png" -> Some(MimeType.image_png())
          "jpg" | "jpeg" -> Some(MimeType.image_jpeg())
          "gif" -> Some(MimeType.image_gif())
          "webp" -> Some(MimeType.image_webp())
          "svg" -> Some(MimeType.image_svg())
          "ico" -> Some(MimeType.new("image", "x-icon"))
          "bmp" -> Some(MimeType.new("image", "bmp"))
          "tiff" | "tif" -> Some(MimeType.new("image", "tiff"))
          "avif" -> Some(MimeType.new("image", "avif"))
          
          # Audio
          "mp3" -> Some(MimeType.audio_mpeg())
          "wav" -> Some(MimeType.new("audio", "wav"))
          "ogg" -> Some(MimeType.new("audio", "ogg"))
          "flac" -> Some(MimeType.new("audio", "flac"))
          "aac" -> Some(MimeType.new("audio", "aac"))
          "m4a" -> Some(MimeType.new("audio", "mp4"))
          "weba" -> Some(MimeType.new("audio", "webm"))
          
          # Video
          "mp4" | "m4v" -> Some(MimeType.video_mp4())
          "webm" -> Some(MimeType.new("video", "webm"))
          "avi" -> Some(MimeType.new("video", "x-msvideo"))
          "mov" -> Some(MimeType.new("video", "quicktime"))
          "mkv" -> Some(MimeType.new("video", "x-matroska"))
          "wmv" -> Some(MimeType.new("video", "x-ms-wmv"))
          "flv" -> Some(MimeType.new("video", "x-flv"))
          
          # Documents
          "pdf" -> Some(MimeType.application_pdf())
          "doc" -> Some(MimeType.new("application", "msword"))
          "docx" -> Some(MimeType.new("application", "vnd.openxmlformats-officedocument.wordprocessingml.document"))
          "xls" -> Some(MimeType.new("application", "vnd.ms-excel"))
          "xlsx" -> Some(MimeType.new("application", "vnd.openxmlformats-officedocument.spreadsheetml.sheet"))
          "ppt" -> Some(MimeType.new("application", "vnd.ms-powerpoint"))
          "pptx" -> Some(MimeType.new("application", "vnd.openxmlformats-officedocument.presentationml.presentation"))
          "odt" -> Some(MimeType.new("application", "vnd.oasis.opendocument.text"))
          "ods" -> Some(MimeType.new("application", "vnd.oasis.opendocument.spreadsheet"))
          "rtf" -> Some(MimeType.new("application", "rtf"))
          
          # Archives
          "zip" -> Some(MimeType.application_zip())
          "gz" | "gzip" -> Some(MimeType.application_gzip())
          "tar" -> Some(MimeType.new("application", "x-tar"))
          "rar" -> Some(MimeType.new("application", "vnd.rar"))
          "7z" -> Some(MimeType.new("application", "x-7z-compressed"))
          "bz2" -> Some(MimeType.new("application", "x-bzip2"))
          "xz" -> Some(MimeType.new("application", "x-xz"))
          
          # Fonts
          "woff" -> Some(MimeType.new("font", "woff"))
          "woff2" -> Some(MimeType.new("font", "woff2"))
          "ttf" -> Some(MimeType.new("font", "ttf"))
          "otf" -> Some(MimeType.new("font", "otf"))
          "eot" -> Some(MimeType.new("application", "vnd.ms-fontobject"))
          
          # Code
          "wasm" -> Some(MimeType.new("application", "wasm"))
          "sh" -> Some(MimeType.new("application", "x-sh"))
          
          _ -> null

    When mime.from_path(path: Path) -> Option<MimeType>:
      Then:
        ext = path.extension()
        if ext.is_empty():
          return null
        return mime.from_extension(ext)

    When mime.from_bytes(data: Bytes) -> Option<MimeType>:
      Then:
        if data.length < 4:
          return null
        
        # Check magic bytes
        magic = data.slice(0, min(16, data.length))
        
        # Images
        if magic.starts_with([0x89, 0x50, 0x4E, 0x47]):  # PNG
          return Some(MimeType.image_png())
        if magic.starts_with([0xFF, 0xD8, 0xFF]):  # JPEG
          return Some(MimeType.image_jpeg())
        if magic.starts_with([0x47, 0x49, 0x46, 0x38]):  # GIF
          return Some(MimeType.image_gif())
        if magic.starts_with([0x52, 0x49, 0x46, 0x46]) and data.length >= 12:
          if data.slice(8, 12) == [0x57, 0x45, 0x42, 0x50]:  # WEBP
            return Some(MimeType.image_webp())
        if magic.starts_with([0x42, 0x4D]):  # BMP
          return Some(MimeType.new("image", "bmp"))
        
        # Audio/Video
        if magic.starts_with([0x49, 0x44, 0x33]) or magic.starts_with([0xFF, 0xFB]):  # MP3
          return Some(MimeType.audio_mpeg())
        if magic.starts_with([0x4F, 0x67, 0x67, 0x53]):  # OGG
          return Some(MimeType.new("audio", "ogg"))
        if magic.starts_with([0x66, 0x4C, 0x61, 0x43]):  # FLAC
          return Some(MimeType.new("audio", "flac"))
        if magic.starts_with([0x52, 0x49, 0x46, 0x46]) and data.length >= 12:
          if data.slice(8, 12) == [0x57, 0x41, 0x56, 0x45]:  # WAV
            return Some(MimeType.new("audio", "wav"))
          if data.slice(8, 12) == [0x41, 0x56, 0x49, 0x20]:  # AVI
            return Some(MimeType.new("video", "x-msvideo"))
        
        # Documents
        if magic.starts_with([0x25, 0x50, 0x44, 0x46]):  # PDF
          return Some(MimeType.application_pdf())
        
        # Archives
        if magic.starts_with([0x50, 0x4B, 0x03, 0x04]):  # ZIP
          return Some(MimeType.application_zip())
        if magic.starts_with([0x1F, 0x8B]):  # GZIP
          return Some(MimeType.application_gzip())
        if magic.starts_with([0x42, 0x5A, 0x68]):  # BZIP2
          return Some(MimeType.new("application", "x-bzip2"))
        if magic.starts_with([0xFD, 0x37, 0x7A, 0x58, 0x5A]):  # XZ
          return Some(MimeType.new("application", "x-xz"))
        if magic.starts_with([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C]):  # 7Z
          return Some(MimeType.new("application", "x-7z-compressed"))
        if magic.starts_with([0x52, 0x61, 0x72, 0x21]):  # RAR
          return Some(MimeType.new("application", "vnd.rar"))
        
        # Executables
        if magic.starts_with([0x7F, 0x45, 0x4C, 0x46]):  # ELF
          return Some(MimeType.new("application", "x-executable"))
        if magic.starts_with([0x4D, 0x5A]):  # PE/EXE
          return Some(MimeType.new("application", "x-msdownload"))
        if magic.starts_with([0xCA, 0xFE, 0xBA, 0xBE]):  # Mach-O
          return Some(MimeType.new("application", "x-mach-binary"))
        
        # WebAssembly
        if magic.starts_with([0x00, 0x61, 0x73, 0x6D]):  # WASM
          return Some(MimeType.new("application", "wasm"))
        
        # Try to detect text
        if is_likely_text(data):
          # Check for specific text formats
          text = String.from_utf8_lossy(data.slice(0, min(1000, data.length)))
          
          if text.trim().starts_with("<!DOCTYPE html") or text.trim().starts_with("<html"):
            return Some(MimeType.text_html())
          if text.trim().starts_with("<?xml"):
            return Some(MimeType.application_xml())
          if text.trim().starts_with("{") or text.trim().starts_with("["):
            return Some(MimeType.application_json())
          
          return Some(MimeType.text_plain())
        
        return Some(MimeType.application_octet_stream())

    When mime.guess(path: Path, data: Option<Bytes>) -> MimeType:
      Then:
        # Try magic bytes first
        if data is Some(d):
          if mime.from_bytes(d) is Some(m):
            return m
        
        # Fall back to extension
        if mime.from_path(path) is Some(m):
          return m
        
        return MimeType.application_octet_stream()

    When is_likely_text(data: Bytes) -> Boolean:
      Then:
        # Check if data looks like text
        # Allow UTF-8 BOM
        start = 0
        if data.starts_with([0xEF, 0xBB, 0xBF]):
          start = 3
        
        # Check for null bytes and control characters
        for i in start..min(1000, data.length):
          byte = data[i]
          
          # Null byte usually means binary
          if byte == 0:
            return false
          
          # Control characters (except common ones)
          if byte < 32 and byte not in [9, 10, 13]:  # tab, newline, carriage return
            return false
        
        return true

  # ==========================================================================
  # EXTENSION LOOKUP
  # ==========================================================================

  Behavior ExtensionLookup:
    When mime.extension(mime_type: MimeType) -> Option<String>:
      Then:
        essence = mime_type.essence()
        
        match essence:
          # Text
          "text/plain" -> Some("txt")
          "text/html" -> Some("html")
          "text/css" -> Some("css")
          "text/javascript" -> Some("js")
          "text/csv" -> Some("csv")
          "text/markdown" -> Some("md")
          "text/yaml" -> Some("yaml")
          
          # Application
          "application/json" -> Some("json")
          "application/xml" -> Some("xml")
          "application/pdf" -> Some("pdf")
          "application/zip" -> Some("zip")
          "application/gzip" -> Some("gz")
          "application/x-tar" -> Some("tar")
          "application/wasm" -> Some("wasm")
          
          # Images
          "image/png" -> Some("png")
          "image/jpeg" -> Some("jpg")
          "image/gif" -> Some("gif")
          "image/webp" -> Some("webp")
          "image/svg+xml" -> Some("svg")
          "image/x-icon" -> Some("ico")
          
          # Audio
          "audio/mpeg" -> Some("mp3")
          "audio/wav" -> Some("wav")
          "audio/ogg" -> Some("ogg")
          "audio/flac" -> Some("flac")
          
          # Video
          "video/mp4" -> Some("mp4")
          "video/webm" -> Some("webm")
          "video/quicktime" -> Some("mov")
          
          # Fonts
          "font/woff" -> Some("woff")
          "font/woff2" -> Some("woff2")
          "font/ttf" -> Some("ttf")
          "font/otf" -> Some("otf")
          
          _ -> null

    When mime.extensions(mime_type: MimeType) -> List<String>:
      Then:
        essence = mime_type.essence()
        
        match essence:
          "text/html" -> ["html", "htm"]
          "text/javascript" -> ["js", "mjs"]
          "text/yaml" -> ["yaml", "yml"]
          "text/markdown" -> ["md", "markdown"]
          "image/jpeg" -> ["jpg", "jpeg"]
          "image/tiff" -> ["tiff", "tif"]
          "video/mp4" -> ["mp4", "m4v"]
          _ -> mime.extension(mime_type).map(e -> [e]).unwrap_or([])

  # ==========================================================================
  # CONTENT TYPE HEADER
  # ==========================================================================

  Type ContentType:
    mime_type: MimeType
    boundary: Option<String>

    Static Method parse(header: String) -> Result<ContentType, MimeError>:
      mime = MimeType.parse(header)?
      boundary = mime.parameters.get("boundary")
      return Ok(ContentType(mime, boundary))

    Static Method json() -> ContentType:
      return ContentType(MimeType.application_json().with_charset("utf-8"), null)

    Static Method html() -> ContentType:
      return ContentType(MimeType.text_html().with_charset("utf-8"), null)

    Static Method text() -> ContentType:
      return ContentType(MimeType.text_plain().with_charset("utf-8"), null)

    Static Method form() -> ContentType:
      return ContentType(MimeType.application_form_urlencoded(), null)

    Static Method multipart() -> ContentType:
      boundary = generate_boundary()
      mime = MimeType.multipart_form_data()
        .with_parameter("boundary", boundary)
      return ContentType(mime, Some(boundary))

    Method to_string() -> String:
      return self.mime_type.to_string()

  Behavior GenerateBoundary:
    When generate_boundary() -> String:
      Then:
        return "----VibeeFormBoundary" + random.alphanumeric(16)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "MIME":
    ```vibee
    # Parse MIME type
    mime = MimeType.parse("text/html; charset=utf-8")?
    print(mime.type)      # "text"
    print(mime.subtype)   # "html"
    print(mime.charset()) # Some("utf-8")

    # Create MIME type
    mime = MimeType.application_json().with_charset("utf-8")
    print(mime.to_string())  # "application/json; charset=utf-8"

    # Check type
    if mime.is_json():
      parse_json(content)
    else if mime.is_text():
      process_text(content)

    # Get MIME from extension
    mime = mime.from_extension("png")?
    print(mime.essence())  # "image/png"

    # Get MIME from path
    mime = mime.from_path(Path("document.pdf"))?
    print(mime.essence())  # "application/pdf"

    # Detect from content (magic bytes)
    data = File.read_bytes(path)?
    mime = mime.from_bytes(data)?
    print(mime.essence())

    # Smart guess (tries magic bytes, then extension)
    mime = mime.guess(path, Some(data))

    # Get extension for MIME type
    ext = mime.extension(MimeType.image_png())?  # "png"
    exts = mime.extensions(MimeType.image_jpeg())  # ["jpg", "jpeg"]

    # Content-Type header
    ct = ContentType.json()
    response.header("Content-Type", ct.to_string())

    # Multipart form data
    ct = ContentType.multipart()
    print(ct.boundary)  # Some("----VibeeFormBoundary...")

    # Common patterns
    fn serve_file(path: Path) -> Response:
      data = File.read_bytes(path)?
      mime = mime.guess(path, Some(data))
      
      Response.ok()
        .header("Content-Type", mime.to_string())
        .body(data)

    fn validate_upload(file: UploadedFile, allowed: List<MimeType>) -> Boolean:
      detected = mime.from_bytes(file.content)?
      return allowed.any(m -> m.essence() == detected.essence())

    # Validate image upload
    allowed_images = [
      MimeType.image_png(),
      MimeType.image_jpeg(),
      MimeType.image_gif(),
      MimeType.image_webp()
    ]

    if not validate_upload(file, allowed_images):
      return Err("Invalid file type")
    ```
