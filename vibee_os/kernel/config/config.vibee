# ============================================================================
# CONFIG MANAGEMENT - Управление конфигурацией на Vibee
# ============================================================================
# Environment variables, config files, secrets, validation
# ============================================================================

Specification ConfigManagement:
  """Конфигурация как спецификация настроек приложения."""

  # ==========================================================================
  # CORE TYPES
  # ==========================================================================

  Type Config:
    values: Map<String, Any>
    schema: ConfigSchema?
    sources: List<ConfigSource>
    environment: String

  Type ConfigSchema:
    fields: Map<String, FieldSchema>
    strict: Boolean = false

  Type FieldSchema:
    type: ConfigType
    required: Boolean = false
    default: Any?
    description: String?
    env_var: String?
    secret: Boolean = false
    validator: ((Any) -> Result<Any, String>)?
    transform: ((Any) -> Any)?

  Type ConfigType:
    variants:
      - String
      - Int
      - Float
      - Boolean
      - Array: ConfigType
      - Object: Map<String, FieldSchema>
      - Enum: List<String>
      - Duration
      - URL
      - Path
      - Email
      - Port
      - Any

  Type ConfigSource:
    variants:
      - Environment
      - File: (path: Path, format: ConfigFormat)
      - Remote: (url: URL, format: ConfigFormat)
      - Vault: VaultConfig
      - AWS_SSM: SSMConfig
      - Custom: (() -> Map<String, Any>)

  Type ConfigFormat:
    variants: [JSON, YAML, TOML, INI, ENV, Properties]

  Type VaultConfig:
    address: URL
    token: String?
    path: String
    namespace: String?

  Type SSMConfig:
    region: String
    path_prefix: String
    decrypt: Boolean = true

  # ==========================================================================
  # CONFIG BUILDER
  # ==========================================================================

  Behavior ConfigBuilder:
    When config.create():
      Then:
        - return ConfigBuilder()

    Type ConfigBuilder:
      sources: List<ConfigSource> = []
      schema: ConfigSchema?
      defaults: Map<String, Any> = {}

      Method from_env() -> ConfigBuilder:
        sources.push(Environment)
        return self

      Method from_file(path: Path, format: ConfigFormat?) -> ConfigBuilder:
        detected_format = format ?? detect_format(path)
        sources.push(File(path, detected_format))
        return self

      Method from_json(path: Path) -> ConfigBuilder:
        return from_file(path, JSON)

      Method from_yaml(path: Path) -> ConfigBuilder:
        return from_file(path, YAML)

      Method from_toml(path: Path) -> ConfigBuilder:
        return from_file(path, TOML)

      Method from_env_file(path: Path = ".env") -> ConfigBuilder:
        sources.push(File(path, ENV))
        return self

      Method from_vault(config: VaultConfig) -> ConfigBuilder:
        sources.push(Vault(config))
        return self

      Method from_ssm(config: SSMConfig) -> ConfigBuilder:
        sources.push(AWS_SSM(config))
        return self

      Method from_custom(loader: () -> Map<String, Any>) -> ConfigBuilder:
        sources.push(Custom(loader))
        return self

      Method with_schema(schema: ConfigSchema) -> ConfigBuilder:
        self.schema = schema
        return self

      Method with_defaults(defaults: Map<String, Any>) -> ConfigBuilder:
        self.defaults = { ...self.defaults, ...defaults }
        return self

      Method define(key: String, field: FieldSchema) -> ConfigBuilder:
        if schema == null:
          schema = ConfigSchema(fields: {})
        schema.fields[key] = field
        return self

      Method build() -> Promise<Config>:
        values = { ...defaults }
        
        # Load from each source in order (later sources override earlier)
        for source in sources:
          source_values = await load_source(source)
          values = deep_merge(values, source_values)
        
        # Apply schema validation and transformation
        if schema:
          values = await validate_and_transform(values, schema)
        
        return Config(
          values: values,
          schema: schema,
          sources: sources,
          environment: values["NODE_ENV"] ?? values["ENVIRONMENT"] ?? "development"
        )

  # ==========================================================================
  # CONFIG ACCESS
  # ==========================================================================

  Behavior ConfigAccess:
    Type Config:
      Method get<T>(key: String, default: T? = null) -> T?:
        value = get_nested(values, key)
        if value == null:
          return default
        return value as T

      Method get_required<T>(key: String) -> T:
        value = get(key)
        if value == null:
          throw ConfigError.MissingRequired(key)
        return value as T

      Method get_string(key: String, default: String? = null) -> String?:
        return get<String>(key, default)

      Method get_int(key: String, default: Int? = null) -> Int?:
        value = get(key, default)
        if value is String:
          return parse_int(value)
        return value as Int?

      Method get_float(key: String, default: Float? = null) -> Float?:
        value = get(key, default)
        if value is String:
          return parse_float(value)
        return value as Float?

      Method get_bool(key: String, default: Boolean? = null) -> Boolean?:
        value = get(key, default)
        if value is String:
          return value.lowercase() in ["true", "1", "yes", "on"]
        return value as Boolean?

      Method get_array<T>(key: String, default: List<T>? = null) -> List<T>?:
        value = get(key, default)
        if value is String:
          return parse_array(value)
        return value as List<T>?

      Method get_duration(key: String, default: Duration? = null) -> Duration?:
        value = get(key)
        if value == null:
          return default
        if value is String:
          return parse_duration(value)
        if value is Int:
          return Duration.milliseconds(value)
        return value as Duration?

      Method get_url(key: String, default: URL? = null) -> URL?:
        value = get_string(key)
        if value == null:
          return default
        return URL.parse(value)

      Method has(key: String) -> Boolean:
        return get(key) != null

      Method all() -> Map<String, Any>:
        return values.clone()

      Method subset(prefix: String) -> Map<String, Any>:
        result = {}
        prefix_with_dot = prefix + "."
        for (key, value) in values:
          if key.starts_with(prefix_with_dot):
            new_key = key.slice(prefix_with_dot.length)
            result[new_key] = value
        return result

      Method is_production() -> Boolean:
        return environment in ["production", "prod"]

      Method is_development() -> Boolean:
        return environment in ["development", "dev"]

      Method is_test() -> Boolean:
        return environment in ["test", "testing"]

  # ==========================================================================
  # ENVIRONMENT VARIABLES
  # ==========================================================================

  Behavior EnvironmentVariables:
    When env.get(key: String, default: String? = null) -> String?:
      Then:
        - return process.env[key] ?? default

    When env.get_required(key: String) -> String:
      Then:
        - value = env.get(key)
        - if value == null:
            - throw ConfigError.MissingEnvVar(key)
        - return value

    When env.get_int(key: String, default: Int? = null) -> Int?:
      Then:
        - value = env.get(key)
        - if value == null:
            - return default
        - return parse_int(value)

    When env.get_bool(key: String, default: Boolean? = null) -> Boolean?:
      Then:
        - value = env.get(key)
        - if value == null:
            - return default
        - return value.lowercase() in ["true", "1", "yes", "on"]

    When env.set(key: String, value: String):
      Then:
        - process.env[key] = value

    When env.unset(key: String):
      Then:
        - delete process.env[key]

    When env.all() -> Map<String, String>:
      Then:
        - return process.env.clone()

  # ==========================================================================
  # CONFIG VALIDATION
  # ==========================================================================

  Behavior ConfigValidation:
    When validate_and_transform(values, schema):
      Then:
        - errors = []
        - result = {}
        
        - for (key, field) in schema.fields:
            - value = get_value_for_field(values, key, field)
            
            - # Check required
            - if value == null:
                - if field.required:
                    - errors.push(ValidationError.Required(key))
                  else if field.default != null:
                    - value = field.default
                  else:
                    - continue
            
            - # Type coercion
            - try:
                - value = coerce_type(value, field.type)
              catch e:
                - errors.push(ValidationError.InvalidType(key, field.type, typeof(value)))
                - continue
            
            - # Custom validator
            - if field.validator:
                - validation_result = field.validator(value)
                - if validation_result is Err:
                    - errors.push(ValidationError.Custom(key, validation_result.error))
                    - continue
            
            - # Transform
            - if field.transform:
                - value = field.transform(value)
            
            - result[key] = value
        
        - # Check for unknown keys in strict mode
        - if schema.strict:
            - for key in values.keys():
                - if key not in schema.fields:
                    - errors.push(ValidationError.UnknownKey(key))
        
        - if errors.length > 0:
            - throw ConfigValidationError(errors)
        
        - return result

    When get_value_for_field(values, key, field):
      Then:
        - # Try env var first if specified
        - if field.env_var:
            - env_value = env.get(field.env_var)
            - if env_value != null:
                - return env_value
        
        - # Try key in values
        - return get_nested(values, key)

    When coerce_type(value, type):
      Then:
        - match type:
            String -> value.to_string()
            Int -> 
              if value is String then parse_int(value)
              else if value is Float then round(value)
              else value as Int
            Float ->
              if value is String then parse_float(value)
              else value as Float
            Boolean ->
              if value is String then value.lowercase() in ["true", "1", "yes", "on"]
              else value as Boolean
            Array(inner_type) ->
              if value is String then parse_array(value).map(v -> coerce_type(v, inner_type))
              else value.map(v -> coerce_type(v, inner_type))
            Duration ->
              if value is String then parse_duration(value)
              else if value is Int then Duration.milliseconds(value)
              else value as Duration
            URL ->
              if value is String then URL.parse(value)
              else value as URL
            Port ->
              port = coerce_type(value, Int)
              if port < 0 or port > 65535:
                throw Error("Invalid port: ${port}")
              port
            Enum(allowed) ->
              str = value.to_string()
              if str not in allowed:
                throw Error("Value must be one of: ${allowed.join(", ")}")
              str
            _ -> value

    Type ValidationError:
      variants:
        - Required: String
        - InvalidType: (key: String, expected: ConfigType, actual: String)
        - Custom: (key: String, message: String)
        - UnknownKey: String

  # ==========================================================================
  # FILE LOADERS
  # ==========================================================================

  Behavior FileLoaders:
    When load_source(source):
      Then:
        - match source:
            Environment -> load_environment()
            File(path, format) -> await load_file(path, format)
            Remote(url, format) -> await load_remote(url, format)
            Vault(config) -> await load_vault(config)
            AWS_SSM(config) -> await load_ssm(config)
            Custom(loader) -> loader()

    When load_environment():
      Then:
        - return process.env.clone()

    When load_file(path, format):
      Then:
        - if not await fs.exists(path):
            - return {}
        
        - content = await fs.read_file(path)
        
        - match format:
            JSON -> JSON.parse(content)
            YAML -> yaml.parse(content)
            TOML -> toml.parse(content)
            INI -> ini.parse(content)
            ENV -> parse_env_file(content)
            Properties -> parse_properties(content)

    When parse_env_file(content):
      Then:
        - result = {}
        - for line in content.split("\n"):
            - line = line.trim()
            - if line == "" or line.starts_with("#"):
                - continue
            - if "=" in line:
                - (key, value) = line.split("=", 2)
                - key = key.trim()
                - value = value.trim()
                - # Remove quotes
                - if (value.starts_with('"') and value.ends_with('"')) or
                     (value.starts_with("'") and value.ends_with("'")):
                    - value = value.slice(1, -1)
                - result[key] = value
        - return result

    When load_vault(config):
      Then:
        - client = vault.client(config.address, config.token)
        - if config.namespace:
            - client.set_namespace(config.namespace)
        - secret = await client.read(config.path)
        - return secret.data

    When load_ssm(config):
      Then:
        - client = aws.ssm.client(region: config.region)
        - params = await client.get_parameters_by_path({
            path: config.path_prefix,
            recursive: true,
            with_decryption: config.decrypt
          })
        
        - result = {}
        - for param in params:
            - key = param.name.replace(config.path_prefix + "/", "").replace("/", ".")
            - result[key] = param.value
        - return result

  # ==========================================================================
  # SECRETS
  # ==========================================================================

  Behavior Secrets:
    When secrets.load(source):
      Then:
        - return SecretsManager(source)

    Type SecretsManager:
      source: SecretSource
      cache: Map<String, CachedSecret> = {}
      ttl: Duration = 5.minutes

      Method get(key: String) -> Promise<String?>:
        # Check cache
        if key in cache:
          cached = cache[key]
          if cached.expires_at > now():
            return cached.value
        
        # Load from source
        value = await load_secret(key)
        
        if value != null:
          cache[key] = CachedSecret(value, now() + ttl)
        
        return value

      Method get_required(key: String) -> Promise<String>:
        value = await get(key)
        if value == null:
          throw SecretNotFoundError(key)
        return value

      Method invalidate(key: String):
        cache.delete(key)

      Method invalidate_all():
        cache.clear()

      Method load_secret(key: String) -> Promise<String?>:
        match source:
          Vault(config) ->
            client = vault.client(config.address, config.token)
            secret = await client.read("${config.path}/${key}")
            return secret.data.value
          
          AWS_SecretsManager(config) ->
            client = aws.secrets_manager.client(region: config.region)
            secret = await client.get_secret_value(secret_id: key)
            return secret.secret_string
          
          Environment(prefix) ->
            return env.get("${prefix}${key}")
          
          File(path) ->
            secret_path = "${path}/${key}"
            if await fs.exists(secret_path):
              return await fs.read_file(secret_path)
            return null

    Type SecretSource:
      variants:
        - Vault: VaultConfig
        - AWS_SecretsManager: (region: String)
        - Environment: (prefix: String)
        - File: Path

    Type CachedSecret:
      value: String
      expires_at: DateTime

  # ==========================================================================
  # TYPED CONFIG
  # ==========================================================================

  Behavior TypedConfig:
    When @config_class(options):
      Then:
        - return ConfigClassDecorator(options)

    When @config_field(options):
      Then:
        - return ConfigFieldDecorator(options)

    # Example typed config class
    Type DatabaseConfig:
      @config_field(env: "DATABASE_HOST", default: "localhost")
      host: String

      @config_field(env: "DATABASE_PORT", default: 5432)
      port: Int

      @config_field(env: "DATABASE_NAME", required: true)
      database: String

      @config_field(env: "DATABASE_USER", required: true)
      username: String

      @config_field(env: "DATABASE_PASSWORD", secret: true, required: true)
      password: String

      @config_field(env: "DATABASE_POOL_SIZE", default: 10)
      pool_size: Int

      @config_field(env: "DATABASE_SSL", default: false)
      ssl: Boolean

      Method connection_string() -> String:
        return "postgres://${username}:${password}@${host}:${port}/${database}"

    When config.load<T>() -> T:
      Then:
        - schema = extract_schema_from_type(T)
        - values = await config.create()
            .from_env()
            .with_schema(schema)
            .build()
        - return hydrate<T>(values)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Config Management":
    ```vibee
    # Define config schema
    app_config = await config.create()
      .from_env_file(".env")
      .from_env()
      .from_yaml("config/app.yaml")
      .define("app.name", {
        type: String,
        required: true,
        description: "Application name"
      })
      .define("app.port", {
        type: Port,
        default: 3000,
        env_var: "PORT"
      })
      .define("app.debug", {
        type: Boolean,
        default: false,
        env_var: "DEBUG"
      })
      .define("database.host", {
        type: String,
        default: "localhost",
        env_var: "DB_HOST"
      })
      .define("database.port", {
        type: Int,
        default: 5432,
        env_var: "DB_PORT"
      })
      .define("database.name", {
        type: String,
        required: true,
        env_var: "DB_NAME"
      })
      .define("database.pool_size", {
        type: Int,
        default: 10,
        validator: (v) -> if v > 0 and v <= 100 then Ok(v) else Err("Pool size must be 1-100")
      })
      .define("redis.url", {
        type: URL,
        env_var: "REDIS_URL",
        default: "redis://localhost:6379"
      })
      .define("jwt.secret", {
        type: String,
        required: true,
        env_var: "JWT_SECRET",
        secret: true
      })
      .define("jwt.expiry", {
        type: Duration,
        default: "1h",
        env_var: "JWT_EXPIRY"
      })
      .define("cors.origins", {
        type: Array(String),
        default: ["http://localhost:3000"],
        env_var: "CORS_ORIGINS"
      })
      .define("log.level", {
        type: Enum(["debug", "info", "warn", "error"]),
        default: "info",
        env_var: "LOG_LEVEL"
      })
      .build()

    # Access config values
    port = app_config.get_int("app.port")
    debug = app_config.get_bool("app.debug")
    db_host = app_config.get_string("database.host")
    jwt_expiry = app_config.get_duration("jwt.expiry")
    cors_origins = app_config.get_array<String>("cors.origins")

    # Get subset
    db_config = app_config.subset("database")
    # { host: "localhost", port: 5432, name: "myapp", pool_size: 10 }

    # Environment checks
    if app_config.is_production():
      log.level = "warn"

    # Typed config
    @config_class(prefix: "database")
    class DatabaseConfig:
      @config_field(env: "DB_HOST", default: "localhost")
      host: String

      @config_field(env: "DB_PORT", default: 5432)
      port: Int

      @config_field(env: "DB_NAME", required: true)
      name: String

      @config_field(env: "DB_USER", required: true)
      user: String

      @config_field(env: "DB_PASSWORD", secret: true)
      password: String

    db_config = await config.load<DatabaseConfig>()
    log.info("Connecting to ${db_config.host}:${db_config.port}")

    # Secrets management
    secrets = secrets.load(Vault({
      address: "https://vault.example.com",
      token: env.get("VAULT_TOKEN"),
      path: "secret/myapp"
    }))

    api_key = await secrets.get_required("api_key")
    db_password = await secrets.get_required("db_password")

    # Config with remote source
    remote_config = await config.create()
      .from_env()
      .from_remote("https://config.example.com/app.json", JSON)
      .build()
    ```
