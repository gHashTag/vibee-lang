name: vibee_os_agent_orchestrator
version: "0.1.0"
language: zig
module: kernel/agent/orchestrator
description: Agent Orchestrator - coordinates multiple agents with single-threaded preference (Devin research insight)

behaviors:
  - name: single_agent_execution
    given: A task requires focused execution
    when: orchestrate_single is called
    then: Single agent executes with full context (preferred mode)
    test_cases:
      - name: swe_task
        input: {task: "implement user authentication", agent: "swe"}
        expected: {success: true, mode: "single_threaded", context_preserved: true}

  - name: sequential_handoff
    given: Task requires multiple agent expertise
    when: orchestrate_sequential is called
    then: Agents execute sequentially with context handoff
    test_cases:
      - name: develop_and_test
        input: {task: "create and test calculator", agents: ["swe", "test"]}
        expected: {success: true, handoffs: 1, context_compressed: true}

  - name: parallel_independent
    given: Tasks are truly independent
    when: orchestrate_parallel is called with independent tasks
    then: Tasks execute in parallel without context sharing
    test_cases:
      - name: independent_modules
        input: {tasks: ["lint code", "check types", "run security scan"]}
        expected: {success: true, parallel: true, no_conflicts: true}

  - name: context_compression_handoff
    given: Context is too large for handoff
    when: compress_for_handoff is called
    then: Context is intelligently compressed preserving key decisions
    test_cases:
      - name: compress_long_session
        input: {context_tokens: 50000, target_tokens: 10000}
        expected: {success: true, key_decisions_preserved: true, summary_quality: 0.9}

  - name: conflict_detection
    given: Multiple agents might make conflicting decisions
    when: detect_conflicts is called
    then: Potential conflicts are identified before execution
    test_cases:
      - name: detect_file_conflict
        input: {agent_a_plan: "modify auth.py", agent_b_plan: "refactor auth.py"}
        expected: {conflict_detected: true, type: "concurrent_modification"}

types:
  OrchestrationMode:
    variants:
      - SingleAgent       # Preferred: one agent, full context
      - Sequential        # Agents in sequence with handoff
      - ParallelIndependent  # Truly independent tasks
      - OrchestratorWorker   # Central orchestrator delegates

  OrchestrationPlan:
    mode: OrchestrationMode
    tasks: [AgentTask]
    dependencies: [TaskDependency]
    estimated_duration_ms: int
    context_strategy: ContextStrategy

  AgentTask:
    id: str
    agent_type: AgentType
    description: str
    input_context: str
    expected_output: str
    timeout_ms: int
    priority: int

  AgentType:
    variants:
      - SWE           # Software engineering
      - Test          # Testing and QA
      - DevOps        # Operations and deployment
      - Docs          # Documentation
      - Review        # Code review
      - Security      # Security analysis
      - Orchestrator  # Meta-agent for coordination

  TaskDependency:
    from_task: str
    to_task: str
    dependency_type: DependencyType

  DependencyType:
    variants:
      - Sequential    # Must complete before
      - DataFlow      # Output feeds input
      - Approval      # Requires approval
      - Optional      # Nice to have

  ContextStrategy:
    variants:
      - FullContext       # Pass entire context (small tasks)
      - CompressedSummary # LLM-compressed summary
      - KeyDecisions      # Only key decisions and outcomes
      - Minimal           # Just task description

  ContextHandoff:
    from_agent: str
    to_agent: str
    original_tokens: int
    compressed_tokens: int
    summary: str
    key_decisions: [Decision]
    artifacts: [str]

  Decision:
    description: str
    rationale: str
    timestamp: int
    reversible: bool

  ConflictReport:
    conflicts: [Conflict]
    resolution_suggestions: [str]
    can_proceed: bool

  Conflict:
    type: ConflictType
    agents: [str]
    resource: str
    description: str
    severity: ConflictSeverity

  ConflictType:
    variants:
      - ConcurrentModification
      - ResourceContention
      - DecisionConflict
      - DependencyViolation

  ConflictSeverity:
    variants:
      - Low       # Can proceed with caution
      - Medium    # Should resolve first
      - High      # Must resolve
      - Blocking  # Cannot proceed

  OrchestrationResult:
    success: bool
    mode_used: OrchestrationMode
    tasks_completed: int
    tasks_failed: int
    total_duration_ms: int
    context_efficiency: float
    artifacts: [str]

  AgentCapability:
    agent_type: AgentType
    capabilities: [str]
    max_context_tokens: int
    preferred_tasks: [str]

  WorkflowPattern:
    variants:
      - PromptChaining    # Sequential with checks
      - Routing           # Classify then specialize
      - Sectioning        # Independent subtasks
      - Voting            # Multiple perspectives
      - EvaluatorOptimizer # Generate-evaluate-refine

functions:
  # Core orchestration
  - name: orchestrate
    params: {task: str, preferred_mode: OrchestrationMode?}
    returns: OrchestrationResult
    description: Orchestrate task execution (auto-selects best mode)

  - name: orchestrate_single
    params: {task: str, agent: AgentType}
    returns: OrchestrationResult
    description: Execute with single agent (preferred)

  - name: orchestrate_sequential
    params: {task: str, agents: [AgentType]}
    returns: OrchestrationResult
    description: Execute with sequential handoff

  - name: orchestrate_parallel
    params: {tasks: [str]}
    returns: OrchestrationResult
    description: Execute independent tasks in parallel

  # Planning
  - name: plan_orchestration
    params: {task: str}
    returns: OrchestrationPlan
    description: Create orchestration plan for task

  - name: analyze_task_complexity
    params: {task: str}
    returns: {complexity: str, recommended_mode: OrchestrationMode}
    description: Analyze task and recommend orchestration mode

  - name: decompose_task
    params: {task: str}
    returns: [AgentTask]
    description: Decompose complex task into subtasks

  # Context management
  - name: compress_for_handoff
    params: {context: str, target_tokens: int}
    returns: ContextHandoff
    description: Compress context for agent handoff

  - name: extract_key_decisions
    params: {context: str}
    returns: [Decision]
    description: Extract key decisions from context

  - name: merge_contexts
    params: {contexts: [str]}
    returns: str
    description: Merge multiple agent contexts

  # Conflict handling
  - name: detect_conflicts
    params: {plans: [OrchestrationPlan]}
    returns: ConflictReport
    description: Detect potential conflicts between plans

  - name: resolve_conflict
    params: {conflict: Conflict}
    returns: str
    description: Suggest resolution for conflict

  # Agent management
  - name: get_agent_capabilities
    params: {agent: AgentType}
    returns: AgentCapability
    description: Get capabilities of agent type

  - name: select_best_agent
    params: {task: str}
    returns: AgentType
    description: Select best agent for task

  - name: agent_available
    params: {agent: AgentType}
    returns: bool
    description: Check if agent is available

imports:
  - kernel.agent.core
  - kernel.agent.scheduler
  - kernel.agent.context_manager

orchestration_philosophy: |
  VIBEE OS Orchestration Philosophy (from Devin research):
  
  "Multi-agent architectures often fail because context and state
  management becomes complex quickly. Subagents lack context from
  the main agent needed for coherent work."
  
  PRINCIPLE 1: PREFER SINGLE-THREADED
  ────────────────────────────────────
  Default to single agent with full context.
  Only use multi-agent when truly necessary.
  
  ┌─────────────────────────────────────────┐
  │  Single Agent (Preferred)               │
  │                                         │
  │  User ──► Agent ──► Result              │
  │           │                             │
  │           └── Full context preserved    │
  └─────────────────────────────────────────┘
  
  PRINCIPLE 2: SEQUENTIAL OVER PARALLEL
  ────────────────────────────────────────
  When multiple agents needed, prefer sequential
  with context compression over parallel.
  
  ┌─────────────────────────────────────────┐
  │  Sequential Handoff                     │
  │                                         │
  │  Agent A ──► Compress ──► Agent B       │
  │     │           │            │          │
  │     └── Key decisions preserved ──┘     │
  └─────────────────────────────────────────┘
  
  PRINCIPLE 3: PARALLEL ONLY FOR INDEPENDENT
  ────────────────────────────────────────────
  Only parallelize truly independent tasks
  that don't share state or decisions.
  
  ┌─────────────────────────────────────────┐
  │  Parallel Independent                   │
  │                                         │
  │  Task A ──► Agent 1 ──┐                │
  │  Task B ──► Agent 2 ──┼──► Merge       │
  │  Task C ──► Agent 3 ──┘                │
  │                                         │
  │  (No shared state between tasks)        │
  └─────────────────────────────────────────┘
  
  PRINCIPLE 4: CONTEXT IS KING
  ────────────────────────────────────────
  The #1 job is managing context effectively.
  - Share full traces, not just messages
  - Compress intelligently, preserve decisions
  - Actions carry implicit decisions

workflow_patterns: |
  Workflow Patterns (from Anthropic research):
  
  1. PROMPT CHAINING
     Step 1 → Check → Step 2 → Check → Step 3
     Use when: Sequential steps with validation
  
  2. ROUTING
     Input → Classify → Specialized Handler
     Use when: Different inputs need different handling
  
  3. SECTIONING (Parallel)
     Task → [Subtask A, Subtask B, Subtask C] → Merge
     Use when: Truly independent subtasks
  
  4. VOTING (Parallel)
     Task → [Perspective 1, 2, 3] → Aggregate
     Use when: Need multiple viewpoints
  
  5. ORCHESTRATOR-WORKERS
     Orchestrator → Plan → Workers → Synthesize
     Use when: Complex tasks needing dynamic breakdown
  
  6. EVALUATOR-OPTIMIZER
     Generate → Evaluate → Refine → Repeat
     Use when: Quality iteration needed
  
  VIBEE OS Default: Single Agent with Prompt Chaining
  Fallback: Sequential Handoff with Context Compression
