name: vibee_os_semantic_memory
version: "0.1.0"
language: zig
module: kernel/agent/memory
description: Semantic Memory - long-term knowledge storage using embeddings and vector search (inspired by A-MEM paper)

behaviors:
  - name: store_memory
    given: Agent has information to remember long-term
    when: memory_store is called with content
    then: Content is embedded and stored in vector database
    test_cases:
      - name: store_code_pattern
        input: {content: "To parse YAML in Zig, use std.yaml.parse()", type: "knowledge"}
        expected: {success: true, memory_id: "mem_1", embedded: true}
      - name: store_user_preference
        input: {content: "User prefers verbose error messages", type: "preference"}
        expected: {success: true, memory_id: "mem_2", embedded: true}

  - name: retrieve_relevant_memories
    given: Agent needs information for current task
    when: memory_search is called with query
    then: Most relevant memories are returned ranked by similarity
    test_cases:
      - name: search_code_help
        input: {query: "how to parse configuration files", limit: 5}
        expected: {success: true, results_count: 5, top_similarity: 0.92}
      - name: search_no_results
        input: {query: "quantum computing algorithms", limit: 5}
        expected: {success: true, results_count: 0}

  - name: memory_consolidation
    given: Related memories exist that can be merged
    when: memory_consolidate is called
    then: Related memories are merged into higher-level knowledge
    test_cases:
      - name: consolidate_similar
        input: {memory_ids: ["mem_1", "mem_2", "mem_3"], similarity_threshold: 0.8}
        expected: {success: true, consolidated_id: "mem_c1", merged_count: 3}

  - name: memory_decay
    given: Memory has not been accessed for a long time
    when: memory_gc is called
    then: Old unused memories are archived or deleted
    test_cases:
      - name: decay_old_memory
        input: {memory_id: "mem_old", last_access_days: 90, access_count: 1}
        expected: {action: "archive", reason: "low_usage"}
      - name: preserve_important
        input: {memory_id: "mem_important", last_access_days: 90, importance: 0.95}
        expected: {action: "keep", reason: "high_importance"}

  - name: memory_linking
    given: Two memories are conceptually related
    when: memory_link is called
    then: Bidirectional link is created between memories
    test_cases:
      - name: link_related
        input: {memory_a: "mem_1", memory_b: "mem_2", relation: "related_to"}
        expected: {success: true, link_id: "link_1"}

types:
  Memory:
    id: str
    content: str
    embedding: [float]
    memory_type: MemoryType
    importance: float
    created_at: int
    last_accessed: int
    access_count: int
    source: MemorySource
    tags: [str]
    links: [MemoryLink]
    metadata: {str: str}

  MemoryType:
    variants:
      - Episodic     # Specific events/experiences
      - Semantic     # General knowledge/facts
      - Procedural   # How to do things
      - Preference   # User preferences
      - Error        # Past mistakes to avoid
      - Success      # Successful patterns

  MemorySource:
    variants:
      - UserInput
      - AgentLearning
      - Consolidation
      - Import
      - Reflection

  MemoryLink:
    id: str
    target_id: str
    relation: LinkRelation
    strength: float
    created_at: int

  LinkRelation:
    variants:
      - RelatedTo
      - PartOf
      - Causes
      - Contradicts
      - Supersedes
      - Example

  SearchResult:
    memory: Memory
    similarity: float
    relevance_score: float

  SearchQuery:
    text: str
    embedding: [float]?
    filters: SearchFilters?
    limit: int
    min_similarity: float

  SearchFilters:
    memory_types: [MemoryType]?
    tags: [str]?
    date_range: {start: int, end: int}?
    min_importance: float?
    source: MemorySource?

  ConsolidationResult:
    new_memory_id: str
    merged_ids: [str]
    summary: str

  MemoryStats:
    total_memories: int
    by_type: {str: int}
    total_links: int
    average_importance: float
    storage_size_bytes: int

  EmbeddingModel:
    name: str
    dimensions: int
    max_tokens: int

  MemoryConfig:
    embedding_model: EmbeddingModel
    similarity_threshold: float
    decay_days: int
    consolidation_threshold: float
    max_memories: int

functions:
  # Core operations
  - name: memory_store
    params: {content: str, memory_type: MemoryType, importance: float, tags: [str]}
    returns: str
    description: Store new memory, returns memory ID

  - name: memory_search
    params: {query: SearchQuery}
    returns: [SearchResult]
    description: Search memories by semantic similarity

  - name: memory_get
    params: {memory_id: str}
    returns: Memory?
    description: Get specific memory by ID

  - name: memory_update
    params: {memory_id: str, content: str?, importance: float?, tags: [str]?}
    returns: bool
    description: Update existing memory

  - name: memory_delete
    params: {memory_id: str}
    returns: bool
    description: Delete memory

  # Linking
  - name: memory_link
    params: {source_id: str, target_id: str, relation: LinkRelation}
    returns: str
    description: Create link between memories

  - name: memory_unlink
    params: {link_id: str}
    returns: bool
    description: Remove link

  - name: memory_get_linked
    params: {memory_id: str, relation: LinkRelation?}
    returns: [Memory]
    description: Get linked memories

  # Consolidation and maintenance
  - name: memory_consolidate
    params: {memory_ids: [str]}
    returns: ConsolidationResult
    description: Merge related memories into higher-level knowledge

  - name: memory_gc
    params: {config: MemoryConfig}
    returns: int
    description: Garbage collect old/unused memories, returns count deleted

  - name: memory_reflect
    params: {recent_count: int}
    returns: [Memory]
    description: Generate reflections from recent memories

  # Embedding
  - name: embed_text
    params: {text: str}
    returns: [float]
    description: Generate embedding for text

  - name: similarity
    params: {embedding_a: [float], embedding_b: [float]}
    returns: float
    description: Calculate cosine similarity

  # Import/Export
  - name: memory_export
    params: {memory_ids: [str]?}
    returns: str
    description: Export memories to JSON

  - name: memory_import
    params: {data: str}
    returns: int
    description: Import memories from JSON, returns count imported

  # Stats
  - name: memory_stats
    params: {}
    returns: MemoryStats
    description: Get memory statistics

imports:
  - kernel.agent.core

a_mem_architecture: |
  A-MEM Inspired Architecture (from NeurIPS 2025 paper):
  
  ┌─────────────────────────────────────────────────────────┐
  │                  Semantic Memory System                  │
  ├─────────────────────────────────────────────────────────┤
  │                                                         │
  │  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
  │  │  Episodic   │    │  Semantic   │    │ Procedural  │ │
  │  │  (Events)   │    │  (Facts)    │    │  (How-to)   │ │
  │  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘ │
  │         │                  │                  │        │
  │         └──────────────────┼──────────────────┘        │
  │                            │                           │
  │                    ┌───────▼───────┐                   │
  │                    │   Embedding   │                   │
  │                    │    Engine     │                   │
  │                    └───────┬───────┘                   │
  │                            │                           │
  │                    ┌───────▼───────┐                   │
  │                    │    Vector     │                   │
  │                    │   Database    │                   │
  │                    └───────┬───────┘                   │
  │                            │                           │
  │  ┌─────────────────────────┼─────────────────────────┐ │
  │  │                         │                         │ │
  │  │  ┌──────────┐   ┌───────▼───────┐   ┌──────────┐ │ │
  │  │  │  Search  │   │     Index     │   │  Links   │ │ │
  │  │  │  Engine  │   │   (HNSW/IVF)  │   │  Graph   │ │ │
  │  │  └──────────┘   └───────────────┘   └──────────┘ │ │
  │  │                                                   │ │
  │  └───────────────────────────────────────────────────┘ │
  │                                                         │
  ├─────────────────────────────────────────────────────────┤
  │                   Memory Operations                      │
  │  • Store: Content → Embed → Index → Link                │
  │  • Search: Query → Embed → ANN Search → Rank → Return   │
  │  • Consolidate: Cluster → Summarize → Create Meta-Memory│
  │  • Decay: Score by (importance × recency × access)      │
  │  • Reflect: Recent memories → LLM → Insights            │
  └─────────────────────────────────────────────────────────┘
  
  Key Innovations from A-MEM:
  1. Zettelkasten-style linking (bidirectional, typed)
  2. Dynamic importance scoring
  3. Automatic consolidation into meta-memories
  4. Reflection-based insight generation
  5. Decay with importance preservation
