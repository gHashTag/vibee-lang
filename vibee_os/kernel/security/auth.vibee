# ============================================================================
# AUTH - Аутентификация и авторизация на Vibee
# ============================================================================
# OAuth2, JWT, RBAC, permissions, MFA
# ============================================================================

Specification Auth:
  """
  Аутентификация и авторизация как спецификация безопасности.
  Каждый запрос проверяется, каждое действие авторизуется.
  """

  # ==========================================================================
  # ТИПЫ ДАННЫХ
  # ==========================================================================

  Type User:
    id: UserId
    email: String
    password_hash: String
    name: String
    avatar: String?
    roles: List<Role>
    permissions: List<Permission>
    metadata: Map<String, Any>
    mfa_enabled: Boolean
    mfa_secret: String?
    email_verified: Boolean
    locked: Boolean
    locked_until: Timestamp?
    failed_attempts: Int
    last_login: Timestamp?
    created_at: Timestamp
    updated_at: Timestamp

  Type UserId:
    value: UUID

  Type Session:
    id: SessionId
    user_id: UserId
    token: String
    refresh_token: String
    device: DeviceInfo
    ip_address: String
    user_agent: String
    created_at: Timestamp
    expires_at: Timestamp
    last_activity: Timestamp
    revoked: Boolean

  Type SessionId:
    value: UUID

  Type DeviceInfo:
    type: DeviceType
    name: String
    os: String
    browser: String?

  Type DeviceType:
    variants: [Desktop, Mobile, Tablet, Unknown]

  # ==========================================================================
  # JWT
  # ==========================================================================

  Type JWT:
    header: JWTHeader
    payload: JWTPayload
    signature: String

  Type JWTHeader:
    alg: Algorithm
    typ: String = "JWT"
    kid: String?

  Type Algorithm:
    variants:
      - HS256
      - HS384
      - HS512
      - RS256
      - RS384
      - RS512
      - ES256
      - ES384
      - ES512
      - PS256
      - PS384
      - PS512
      - EdDSA

  Type JWTPayload:
    # Registered claims
    iss: String?          # Issuer
    sub: String?          # Subject (user_id)
    aud: String?          # Audience
    exp: Timestamp        # Expiration
    nbf: Timestamp?       # Not before
    iat: Timestamp        # Issued at
    jti: String?          # JWT ID
    
    # Custom claims
    roles: List<String>?
    permissions: List<String>?
    scope: String?
    custom: Map<String, Any>?

  Type JWTConfig:
    secret: String                    # For HMAC
    private_key: String?              # For RSA/EC
    public_key: String?               # For RSA/EC
    algorithm: Algorithm = RS256
    issuer: String
    audience: String
    access_token_ttl: Duration = 15.minutes
    refresh_token_ttl: Duration = 7.days
    clock_skew: Duration = 30.seconds

  Behavior JWTBehavior:
    """JWT операции"""

    When JWT.sign(payload, config):
      Then:
        - header = JWTHeader(alg: config.algorithm)
        - payload.iss = config.issuer
        - payload.aud = config.audience
        - payload.iat = now()
        - payload.exp = now() + config.access_token_ttl
        - payload.jti = generate_uuid()
        
        - header_b64 = base64url_encode(JSON.stringify(header))
        - payload_b64 = base64url_encode(JSON.stringify(payload))
        - signing_input = "${header_b64}.${payload_b64}"
        
        - signature = match config.algorithm:
            HS256 -> hmac_sha256(signing_input, config.secret)
            HS384 -> hmac_sha384(signing_input, config.secret)
            HS512 -> hmac_sha512(signing_input, config.secret)
            RS256 -> rsa_sha256_sign(signing_input, config.private_key)
            RS384 -> rsa_sha384_sign(signing_input, config.private_key)
            RS512 -> rsa_sha512_sign(signing_input, config.private_key)
            ES256 -> ecdsa_sha256_sign(signing_input, config.private_key)
            ES384 -> ecdsa_sha384_sign(signing_input, config.private_key)
            ES512 -> ecdsa_sha512_sign(signing_input, config.private_key)
            EdDSA -> eddsa_sign(signing_input, config.private_key)
        
        - return "${signing_input}.${base64url_encode(signature)}"

    When JWT.verify(token, config):
      Then:
        - parts = token.split(".")
        - if parts.size != 3:
            - return Error(InvalidToken("Invalid token format"))
        
        - header = JSON.parse(base64url_decode(parts[0]))
        - payload = JSON.parse(base64url_decode(parts[1]))
        - signature = base64url_decode(parts[2])
        
        - # Verify algorithm
        - if header.alg != config.algorithm:
            - return Error(InvalidToken("Algorithm mismatch"))
        
        - # Verify signature
        - signing_input = "${parts[0]}.${parts[1]}"
        - valid = verify_signature(signing_input, signature, config)
        - if not valid:
            - return Error(InvalidSignature)
        
        - # Verify claims
        - now_ts = now()
        
        - if payload.exp < now_ts - config.clock_skew:
            - return Error(TokenExpired)
        
        - if payload.nbf and payload.nbf > now_ts + config.clock_skew:
            - return Error(TokenNotYetValid)
        
        - if payload.iss != config.issuer:
            - return Error(InvalidIssuer)
        
        - if payload.aud != config.audience:
            - return Error(InvalidAudience)
        
        - return Ok(JWT(header, payload, signature))

    When JWT.decode(token):
      """Decode without verification"""
      Then:
        - parts = token.split(".")
        - header = JSON.parse(base64url_decode(parts[0]))
        - payload = JSON.parse(base64url_decode(parts[1]))
        - return JWT(header, payload, parts[2])

    When JWT.refresh(refresh_token, config):
      Then:
        - # Verify refresh token
        - result = JWT.verify(refresh_token, config with access_token_ttl = config.refresh_token_ttl)
        - if result.is_error():
            - return result
        
        - jwt = result.unwrap()
        
        - # Check if refresh token is revoked
        - if await is_token_revoked(jwt.payload.jti):
            - return Error(TokenRevoked)
        
        - # Generate new tokens
        - new_access = JWT.sign(
            JWTPayload(
              sub: jwt.payload.sub,
              roles: jwt.payload.roles,
              permissions: jwt.payload.permissions
            ),
            config
          )
        
        - new_refresh = JWT.sign(
            JWTPayload(sub: jwt.payload.sub),
            config with access_token_ttl = config.refresh_token_ttl
          )
        
        - # Revoke old refresh token
        - await revoke_token(jwt.payload.jti)
        
        - return Ok(TokenPair(access: new_access, refresh: new_refresh))

  # ==========================================================================
  # OAUTH2
  # ==========================================================================

  Type OAuth2Config:
    authorization_endpoint: String
    token_endpoint: String
    userinfo_endpoint: String?
    revocation_endpoint: String?
    jwks_uri: String?
    client_id: String
    client_secret: String
    redirect_uri: String
    scopes: List<String>

  Type OAuth2Provider:
    variants:
      - Google: OAuth2Config
      - GitHub: OAuth2Config
      - Facebook: OAuth2Config
      - Apple: OAuth2Config
      - Microsoft: OAuth2Config
      - Custom: OAuth2Config

  Type AuthorizationCode:
    code: String
    client_id: String
    redirect_uri: String
    scope: String
    state: String
    code_challenge: String?
    code_challenge_method: CodeChallengeMethod?
    user_id: UserId
    expires_at: Timestamp

  Type CodeChallengeMethod:
    variants: [Plain, S256]

  Type TokenResponse:
    access_token: String
    token_type: String = "Bearer"
    expires_in: Int
    refresh_token: String?
    scope: String?
    id_token: String?

  Behavior OAuth2Behavior:
    """OAuth2 flows"""

    When oauth2.authorization_url(provider, state):
      """Generate authorization URL"""
      Then:
        - config = get_provider_config(provider)
        - params = {
            client_id: config.client_id,
            redirect_uri: config.redirect_uri,
            response_type: "code",
            scope: config.scopes.join(" "),
            state: state
          }
        
        - # PKCE
        - code_verifier = generate_code_verifier()
        - code_challenge = base64url_encode(sha256(code_verifier))
        - params.code_challenge = code_challenge
        - params.code_challenge_method = "S256"
        
        - store_code_verifier(state, code_verifier)
        
        - return "${config.authorization_endpoint}?${url_encode(params)}"

    When oauth2.exchange_code(provider, code, state):
      """Exchange authorization code for tokens"""
      Then:
        - config = get_provider_config(provider)
        - code_verifier = get_code_verifier(state)
        
        - response = await http.post(config.token_endpoint, {
            grant_type: "authorization_code",
            code: code,
            redirect_uri: config.redirect_uri,
            client_id: config.client_id,
            client_secret: config.client_secret,
            code_verifier: code_verifier
          })
        
        - if response.status != 200:
            - return Error(OAuth2Error(response.body))
        
        - tokens = response.json()
        - return Ok(TokenResponse(
            access_token: tokens.access_token,
            token_type: tokens.token_type,
            expires_in: tokens.expires_in,
            refresh_token: tokens.refresh_token,
            scope: tokens.scope,
            id_token: tokens.id_token
          ))

    When oauth2.get_user_info(provider, access_token):
      """Get user info from provider"""
      Then:
        - config = get_provider_config(provider)
        
        - response = await http.get(config.userinfo_endpoint, {
            headers: { Authorization: "Bearer ${access_token}" }
          })
        
        - if response.status != 200:
            - return Error(OAuth2Error(response.body))
        
        - return Ok(normalize_user_info(provider, response.json()))

    When oauth2.refresh_token(provider, refresh_token):
      Then:
        - config = get_provider_config(provider)
        
        - response = await http.post(config.token_endpoint, {
            grant_type: "refresh_token",
            refresh_token: refresh_token,
            client_id: config.client_id,
            client_secret: config.client_secret
          })
        
        - if response.status != 200:
            - return Error(OAuth2Error(response.body))
        
        - return Ok(TokenResponse.from_json(response.json()))

  # ==========================================================================
  # RBAC (Role-Based Access Control)
  # ==========================================================================

  Type Role:
    id: RoleId
    name: String
    description: String?
    permissions: List<Permission>
    parent: RoleId?
    metadata: Map<String, Any>

  Type RoleId:
    value: String

  Type Permission:
    id: PermissionId
    resource: String
    action: Action
    conditions: List<Condition>?

  Type PermissionId:
    value: String

  Type Action:
    variants:
      - Create
      - Read
      - Update
      - Delete
      - Execute
      - Manage
      - All
      - Custom: String

  Type Condition:
    variants:
      - OwnerOnly                    # resource.owner_id == user.id
      - TeamOnly                     # resource.team_id in user.teams
      - DepartmentOnly               # resource.department == user.department
      - TimeRange: (start: Time, end: Time)
      - IPRange: List<CIDR>
      - Custom: (name: String, params: Map<String, Any>)

  Behavior RBACBehavior:
    """Role-Based Access Control"""

    State:
      roles: Map<RoleId, Role>
      user_roles: Map<UserId, List<RoleId>>
      permission_cache: LRUCache<(UserId, String, Action), Boolean>

    When rbac.has_permission(user, resource, action):
      Then:
        - # Check cache
        - cache_key = (user.id, resource, action)
        - cached = permission_cache.get(cache_key)
        - if cached != null:
            - return cached
        
        - # Get all user permissions (including from roles)
        - permissions = get_all_permissions(user)
        
        - # Check if any permission matches
        - result = permissions.any(p ->
            matches_resource(p.resource, resource) and
            matches_action(p.action, action) and
            evaluate_conditions(p.conditions, user, resource)
          )
        
        - permission_cache.put(cache_key, result)
        - return result

    When rbac.check_permission(user, resource, action):
      """Check and throw if not permitted"""
      Then:
        - if not await rbac.has_permission(user, resource, action):
            - raise PermissionDenied(user.id, resource, action)

    When get_all_permissions(user):
      Then:
        - permissions = user.permissions.copy()
        
        - # Add permissions from roles
        - for role_id in user.roles:
            - role = roles[role_id]
            - permissions.extend(role.permissions)
            
            - # Include parent role permissions
            - while role.parent:
                - role = roles[role.parent]
                - permissions.extend(role.permissions)
        
        - return permissions.unique()

    When matches_resource(pattern, resource):
      Then:
        - # Exact match
        - if pattern == resource:
            - return true
        
        - # Wildcard match
        - if pattern == "*":
            - return true
        
        - # Prefix match (e.g., "users:*" matches "users:123")
        - if pattern.ends_with(":*"):
            - prefix = pattern.substring(0, pattern.length - 2)
            - return resource.starts_with(prefix + ":")
        
        - return false

    When matches_action(permission_action, requested_action):
      Then:
        - if permission_action == All:
            - return true
        - if permission_action == Manage:
            - return requested_action in [Create, Read, Update, Delete]
        - return permission_action == requested_action

    When evaluate_conditions(conditions, user, resource):
      Then:
        - if not conditions or conditions.is_empty():
            - return true
        
        - return conditions.all(c ->
            match c:
              OwnerOnly -> resource.owner_id == user.id
              TeamOnly -> resource.team_id in user.teams
              DepartmentOnly -> resource.department == user.department
              TimeRange(start, end) -> now().time between start and end
              IPRange(ranges) -> user.ip in ranges
              Custom(name, params) -> evaluate_custom_condition(name, params, user, resource)
          )

  # ==========================================================================
  # MFA (Multi-Factor Authentication)
  # ==========================================================================

  Type MFAMethod:
    variants:
      - TOTP: TOTPConfig
      - SMS: String          # Phone number
      - Email: String        # Email address
      - WebAuthn: WebAuthnCredential
      - BackupCodes: List<String>

  Type TOTPConfig:
    secret: String
    algorithm: HashAlgorithm = SHA1
    digits: Int = 6
    period: Int = 30

  Type HashAlgorithm:
    variants: [SHA1, SHA256, SHA512]

  Type WebAuthnCredential:
    id: String
    public_key: String
    sign_count: Int
    transports: List<String>

  Behavior MFABehavior:
    """Multi-Factor Authentication"""

    When mfa.setup_totp(user):
      Then:
        - secret = generate_totp_secret()
        - uri = "otpauth://totp/${config.issuer}:${user.email}?secret=${secret}&issuer=${config.issuer}&algorithm=SHA1&digits=6&period=30"
        - qr_code = generate_qr_code(uri)
        
        - # Store secret temporarily until verified
        - await store_pending_mfa(user.id, TOTP(TOTPConfig(secret)))
        
        - return MFASetupResponse(
            secret: secret,
            uri: uri,
            qr_code: qr_code
          )

    When mfa.verify_totp(user, code):
      Then:
        - config = user.mfa_config as TOTPConfig
        - expected = generate_totp(config.secret, now(), config)
        
        - # Check current and adjacent time windows
        - valid_codes = [
            generate_totp(config.secret, now() - config.period, config),
            expected,
            generate_totp(config.secret, now() + config.period, config)
          ]
        
        - if code in valid_codes:
            - # Prevent replay attacks
            - if await is_code_used(user.id, code):
                - return Error(CodeAlreadyUsed)
            - await mark_code_used(user.id, code)
            - return Ok()
        
        - return Error(InvalidCode)

    When generate_totp(secret, timestamp, config):
      Then:
        - counter = floor(timestamp / config.period)
        - hmac = hmac_hash(config.algorithm, secret, counter.to_bytes(8))
        - offset = hmac[hmac.length - 1] & 0x0F
        - code = ((hmac[offset] & 0x7F) << 24 |
                  (hmac[offset + 1] & 0xFF) << 16 |
                  (hmac[offset + 2] & 0xFF) << 8 |
                  (hmac[offset + 3] & 0xFF)) % (10 ** config.digits)
        - return code.to_string().pad_start(config.digits, "0")

    When mfa.generate_backup_codes(user, count):
      Then:
        - codes = []
        - for i in 0..count:
            - code = generate_random_string(8, charset: "0123456789ABCDEF")
            - add code to codes
        
        - # Store hashed codes
        - hashed = codes.map(c -> hash(c))
        - await store_backup_codes(user.id, hashed)
        
        - return codes

    When mfa.verify_backup_code(user, code):
      Then:
        - hashed = hash(code)
        - stored = await get_backup_codes(user.id)
        
        - if hashed in stored:
            - # Remove used code
            - await remove_backup_code(user.id, hashed)
            - return Ok()
        
        - return Error(InvalidBackupCode)

  # ==========================================================================
  # PASSWORD POLICY
  # ==========================================================================

  Type PasswordPolicy:
    min_length: Int = 8
    max_length: Int = 128
    require_uppercase: Boolean = true
    require_lowercase: Boolean = true
    require_numbers: Boolean = true
    require_special: Boolean = true
    special_chars: String = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    disallow_common: Boolean = true
    disallow_user_info: Boolean = true
    history_count: Int = 5
    max_age: Duration = 90.days
    min_age: Duration = 1.day

  Behavior PasswordBehavior:
    """Password management"""

    When password.validate(password, user, policy):
      Then:
        - errors = []
        
        - if password.length < policy.min_length:
            - add "Password must be at least ${policy.min_length} characters" to errors
        
        - if password.length > policy.max_length:
            - add "Password must be at most ${policy.max_length} characters" to errors
        
        - if policy.require_uppercase and not password.matches(/[A-Z]/):
            - add "Password must contain uppercase letter" to errors
        
        - if policy.require_lowercase and not password.matches(/[a-z]/):
            - add "Password must contain lowercase letter" to errors
        
        - if policy.require_numbers and not password.matches(/[0-9]/):
            - add "Password must contain number" to errors
        
        - if policy.require_special and not password.matches_any(policy.special_chars):
            - add "Password must contain special character" to errors
        
        - if policy.disallow_common and is_common_password(password):
            - add "Password is too common" to errors
        
        - if policy.disallow_user_info and user:
            - if password.contains(user.email.split("@")[0]):
                - add "Password cannot contain email" to errors
            - if password.contains(user.name):
                - add "Password cannot contain name" to errors
        
        - if errors.is_empty():
            - return Ok()
        - else:
            - return Error(PasswordValidationError(errors))

    When password.hash(password):
      Then:
        - # Use Argon2id
        - return argon2id_hash(password, {
            memory: 65536,
            iterations: 3,
            parallelism: 4,
            salt_length: 16,
            hash_length: 32
          })

    When password.verify(password, hash):
      Then:
        - return argon2id_verify(password, hash)

    When password.check_history(user, new_password, policy):
      Then:
        - history = await get_password_history(user.id, policy.history_count)
        
        - for old_hash in history:
            - if password.verify(new_password, old_hash):
                - return Error(PasswordInHistory)
        
        - return Ok()

  # ==========================================================================
  # СОБЫТИЯ
  # ==========================================================================

  Events:
    UserRegistered:
      user_id: UserId
      email: String

    UserLoggedIn:
      user_id: UserId
      session_id: SessionId
      ip_address: String
      device: DeviceInfo

    UserLoggedOut:
      user_id: UserId
      session_id: SessionId

    LoginFailed:
      email: String
      reason: String
      ip_address: String

    PasswordChanged:
      user_id: UserId

    PasswordResetRequested:
      user_id: UserId
      email: String

    MFAEnabled:
      user_id: UserId
      method: String

    MFADisabled:
      user_id: UserId

    TokenRefreshed:
      user_id: UserId
      session_id: SessionId

    TokenRevoked:
      token_id: String
      reason: String

    PermissionDenied:
      user_id: UserId
      resource: String
      action: String

    AccountLocked:
      user_id: UserId
      reason: String
      until: Timestamp?

  # ==========================================================================
  # ПРИМЕР ИСПОЛЬЗОВАНИЯ
  # ==========================================================================

  Example "Authentication Flow":
    ```vibee
    # Registration
    router.post("/auth/register", async (req, params) ->
      validation = await password.validate(req.body.password, null, policy)
      if validation.is_error():
        return Response.bad_request().json({ errors: validation.errors }).build()
      
      user = await User.create({
        email: req.body.email,
        password_hash: password.hash(req.body.password),
        name: req.body.name
      })
      
      await send_verification_email(user)
      
      Response.created().json({ user_id: user.id }).build()
    )

    # Login
    router.post("/auth/login", async (req, params) ->
      user = await User.find_by_email(req.body.email)
      
      if not user or not password.verify(req.body.password, user.password_hash):
        await record_failed_login(req.body.email, req.ip)
        return Response.unauthorized().json({ error: "Invalid credentials" }).build()
      
      if user.locked:
        return Response.forbidden().json({ error: "Account locked" }).build()
      
      # Check MFA
      if user.mfa_enabled:
        mfa_token = generate_mfa_token(user.id)
        return Response.ok().json({ mfa_required: true, mfa_token: mfa_token }).build()
      
      # Create session
      session = await create_session(user, req)
      tokens = generate_tokens(user, session)
      
      Response.ok().json(tokens).build()
    )

    # MFA verification
    router.post("/auth/mfa/verify", async (req, params) ->
      user_id = verify_mfa_token(req.body.mfa_token)
      user = await User.find(user_id)
      
      result = await mfa.verify_totp(user, req.body.code)
      if result.is_error():
        return Response.unauthorized().json({ error: "Invalid code" }).build()
      
      session = await create_session(user, req)
      tokens = generate_tokens(user, session)
      
      Response.ok().json(tokens).build()
    )
    ```

  Example "RBAC Authorization":
    ```vibee
    # Define roles
    Role Admin:
      permissions:
        - Permission(resource: "*", action: All)

    Role Editor:
      permissions:
        - Permission(resource: "posts:*", action: Manage)
        - Permission(resource: "comments:*", action: Manage)

    Role Author:
      permissions:
        - Permission(resource: "posts:*", action: Create)
        - Permission(resource: "posts:*", action: Read)
        - Permission(resource: "posts:*", action: Update, conditions: [OwnerOnly])
        - Permission(resource: "posts:*", action: Delete, conditions: [OwnerOnly])

    # Middleware
    authorize = (resource, action) -> async (req, next) ->
      user = req.context.user
      if not user:
        return Response.unauthorized().build()
      
      if not await rbac.has_permission(user, resource, action):
        return Response.forbidden().json({ 
          error: "Permission denied",
          required: { resource: resource, action: action }
        }).build()
      
      await next.call(req)

    # Usage
    router.delete("/posts/:id", 
      authorize("posts:${params.id}", Delete),
      async (req, params) ->
        await Post.delete(params.id)
        Response.no_content().build()
    )
    ```
