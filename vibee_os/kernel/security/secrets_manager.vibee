name: vibee_os_secrets_manager
version: "0.1.0"
language: gleam
module: kernel/security/secrets
description: Secrets Manager - безопасное хранение API ключей, паролей и других секретов

behaviors:
  - name: secrets_never_in_code
    given: Secret value is needed
    when: Code references secret
    then: Secret is loaded from secure store, NEVER hardcoded
    test_cases:
      - name: reject_hardcoded
        input: {code: "api_key: \"sk-abc123\""}
        expected: {valid: false, error: "HARDCODED_SECRET_DETECTED"}
      - name: accept_reference
        input: {code: "api_key: \"${DEEPSEEK_API_KEY}\""}
        expected: {valid: true, resolved_at_runtime: true}

  - name: secrets_encrypted_at_rest
    given: Secret is stored
    when: Secret is written to disk
    then: Secret is encrypted with master key
    test_cases:
      - name: encrypt_on_store
        input: {key: "API_KEY", value: "sk-secret"}
        expected: {stored_encrypted: true, plaintext_not_on_disk: true}

  - name: secrets_access_logged
    given: Secret is accessed
    when: Application reads secret
    then: Access is logged with timestamp and accessor
    test_cases:
      - name: log_access
        input: {key: "API_KEY", accessor: "llm_backend"}
        expected: {logged: true, timestamp: true, accessor_recorded: true}

  - name: secrets_rotatable
    given: Secret exists
    when: Rotation is triggered
    then: Old secret is replaced, applications notified
    test_cases:
      - name: rotate_api_key
        input: {key: "DEEPSEEK_API_KEY", new_value: "sk-new"}
        expected: {rotated: true, old_invalidated: true, apps_notified: true}

  - name: secrets_scoped
    given: Secret has scope
    when: Application outside scope requests secret
    then: Access is denied
    test_cases:
      - name: deny_out_of_scope
        input: {key: "DB_PASSWORD", scope: "database", accessor: "ui"}
        expected: {access: "denied", reason: "scope_mismatch"}

types:
  # Secret Storage
  Secret:
    id: str
    name: str
    encrypted_value: [int]            # Encrypted bytes
    metadata: SecretMetadata
    created_at: int
    updated_at: int
    expires_at: int?
    version: int

  SecretMetadata:
    description: str?
    scope: SecretScope
    rotation_policy: RotationPolicy?
    tags: [str]
    created_by: str
    last_accessed_at: int?
    access_count: int

  SecretScope:
    variants:
      - Global                        # Accessible by all
      - Module: {modules: [str]}      # Only specific modules
      - Service: {services: [str]}    # Only specific services
      - User: {users: [str]}          # Only specific users
      - Environment: {envs: [str]}    # Only in specific environments

  RotationPolicy:
    auto_rotate: bool
    interval_days: int
    notify_before_days: int
    on_compromise: bool

  # Secret Reference (used in configs)
  SecretRef:
    variants:
      - EnvVar: {name: str}           # ${ENV_VAR}
      - SecretStore: {key: str}       # secret://key
      - Vault: {path: str}            # vault://path/to/secret
      - File: {path: str}             # file:///path/to/.secret
      - Keyring: {service: str, account: str}  # OS keyring

  # Encryption
  EncryptionConfig:
    algorithm: EncryptionAlgorithm
    key_derivation: KeyDerivation
    master_key_source: MasterKeySource

  EncryptionAlgorithm:
    variants:
      - AES256_GCM
      - ChaCha20_Poly1305
      - XChaCha20_Poly1305

  KeyDerivation:
    variants:
      - Argon2id: {memory_kb: int, iterations: int, parallelism: int}
      - PBKDF2: {iterations: int, hash: str}
      - Scrypt: {n: int, r: int, p: int}

  MasterKeySource:
    variants:
      - Password: {min_length: int}
      - Keyfile: {path: str}
      - Hardware: {device: str}       # TPM, YubiKey
      - Environment: {var: str}
      - Combined: {sources: [MasterKeySource]}

  # Access Control
  AccessPolicy:
    secret_id: str
    rules: [AccessRule]

  AccessRule:
    principal: Principal
    permissions: [Permission]
    conditions: [AccessCondition]?

  Principal:
    variants:
      - Module: {name: str}
      - Service: {name: str}
      - User: {id: str}
      - Role: {name: str}
      - Any

  Permission:
    variants:
      - Read
      - Write
      - Delete
      - Rotate
      - Admin

  AccessCondition:
    variants:
      - TimeWindow: {start: str, end: str}
      - IPRange: {cidr: str}
      - Environment: {env: str}
      - MFA_Required

  # Audit Log
  AuditEntry:
    id: str
    timestamp: int
    action: AuditAction
    secret_id: str
    principal: str
    success: bool
    details: {str: str}
    ip_address: str?

  AuditAction:
    variants:
      - Read
      - Write
      - Delete
      - Rotate
      - AccessDenied
      - PolicyChange

  # Secret Store Backend
  SecretBackend:
    variants:
      - File: FileBackend
      - SQLite: SQLiteBackend
      - Vault: VaultBackend
      - AWS_SecretsManager: AWSBackend
      - Azure_KeyVault: AzureBackend
      - GCP_SecretManager: GCPBackend
      - Memory: MemoryBackend         # For testing only

  FileBackend:
    path: str
    encryption: EncryptionConfig

  SQLiteBackend:
    path: str
    encryption: EncryptionConfig

  VaultBackend:
    address: str
    auth_method: VaultAuth
    mount_path: str

  VaultAuth:
    variants:
      - Token: {token_ref: str}
      - AppRole: {role_id: str, secret_id_ref: str}
      - Kubernetes: {role: str}

  AWSBackend:
    region: str
    prefix: str

  AzureBackend:
    vault_url: str

  GCPBackend:
    project: str

  MemoryBackend:
    warn_on_use: bool

  # Resolution Result
  ResolvedSecret:
    value: str
    source: SecretRef
    expires_at: int?
    cached: bool

  ResolutionError:
    variants:
      - NotFound: {key: str}
      - AccessDenied: {key: str, reason: str}
      - Expired: {key: str}
      - DecryptionFailed: {key: str}
      - BackendError: {message: str}

functions:
  # Core operations
  - name: secret_get
    params: {key: str}
    returns: ResolvedSecret
    description: Get secret value (decrypted)

  - name: secret_set
    params: {key: str, value: str, metadata: SecretMetadata?}
    returns: Secret
    description: Store secret (encrypted)

  - name: secret_delete
    params: {key: str}
    returns: bool
    description: Delete secret

  - name: secret_exists
    params: {key: str}
    returns: bool
    description: Check if secret exists

  - name: secret_list
    params: {scope: SecretScope?}
    returns: [str]
    description: List secret keys (not values!)

  # Resolution
  - name: resolve_ref
    params: {ref: SecretRef}
    returns: ResolvedSecret
    description: Resolve secret reference to value

  - name: resolve_string
    params: {template: str}
    returns: str
    description: Resolve ${VAR} references in string

  - name: resolve_config
    params: {config: {str: str}}
    returns: {str: str}
    description: Resolve all secret refs in config

  # Rotation
  - name: secret_rotate
    params: {key: str, new_value: str}
    returns: Secret
    description: Rotate secret to new value

  - name: secret_schedule_rotation
    params: {key: str, policy: RotationPolicy}
    returns: bool
    description: Schedule automatic rotation

  # Access control
  - name: policy_set
    params: {policy: AccessPolicy}
    returns: bool
    description: Set access policy for secret

  - name: policy_check
    params: {key: str, principal: Principal, permission: Permission}
    returns: bool
    description: Check if access is allowed

  # Audit
  - name: audit_log
    params: {entry: AuditEntry}
    returns: void
    description: Log audit entry

  - name: audit_query
    params: {secret_id: str?, principal: str?, action: AuditAction?, limit: int}
    returns: [AuditEntry]
    description: Query audit log

  # Backend
  - name: backend_configure
    params: {backend: SecretBackend}
    returns: bool
    description: Configure secret backend

  - name: backend_health
    params: {}
    returns: bool
    description: Check backend health

  # Validation
  - name: validate_no_hardcoded
    params: {content: str}
    returns: {valid: bool, violations: [str]}
    description: Check for hardcoded secrets

imports:
  - kernel.security.crypto
  - kernel.security.audit

secret_storage_locations: |
  # Where Secrets Are Stored
  
  ## Development (Local)
  ```
  ~/.vibee/secrets/
  ├── master.key          # Master encryption key (chmod 600)
  ├── secrets.db          # Encrypted SQLite database
  └── .env.local          # Environment overrides (gitignored)
  ```
  
  ## Production Options
  
  1. **Environment Variables** (Simple)
     ```bash
     export DEEPSEEK_API_KEY="sk-..."
     export ANTHROPIC_API_KEY="sk-..."
     ```
  
  2. **HashiCorp Vault** (Recommended)
     ```yaml
     backend:
       type: Vault
       address: "https://vault.example.com"
       path: "secret/vibee"
     ```
  
  3. **Cloud Secret Managers**
     - AWS Secrets Manager
     - Azure Key Vault
     - GCP Secret Manager
  
  4. **OS Keyring** (Desktop)
     - macOS Keychain
     - Windows Credential Manager
     - Linux Secret Service

secret_reference_syntax: |
  # Secret Reference Syntax
  
  ## Environment Variable
  ```yaml
  api_key: "${DEEPSEEK_API_KEY}"
  ```
  
  ## Secret Store
  ```yaml
  api_key: "secret://deepseek/api_key"
  ```
  
  ## Vault
  ```yaml
  api_key: "vault://secret/llm/deepseek#api_key"
  ```
  
  ## File
  ```yaml
  api_key: "file:///etc/vibee/secrets/deepseek.key"
  ```
  
  ## Combined (with fallback)
  ```yaml
  api_key:
    primary: "${DEEPSEEK_API_KEY}"
    fallback: "secret://deepseek/api_key"
  ```

setup_instructions: |
  # Setting Up Secrets
  
  ## 1. Initialize Secret Store
  ```bash
  vibee secrets init
  # Creates ~/.vibee/secrets/ with master key
  ```
  
  ## 2. Add Secrets
  ```bash
  # Interactive (recommended)
  vibee secrets set DEEPSEEK_API_KEY
  # Prompts for value, never shown in terminal
  
  # From environment
  vibee secrets import-env DEEPSEEK_API_KEY
  
  # From file
  vibee secrets set DEEPSEEK_API_KEY --file /path/to/key
  ```
  
  ## 3. Verify
  ```bash
  vibee secrets list
  # Shows: DEEPSEEK_API_KEY (set, encrypted)
  
  vibee secrets test DEEPSEEK_API_KEY
  # Tests if secret can be resolved
  ```
  
  ## 4. Use in Config
  ```yaml
  # vibee_os/config/llm_providers.vibee
  deepseek:
    api_key: "${DEEPSEEK_API_KEY}"
  ```

security_best_practices: |
  # Security Best Practices
  
  ## DO:
  ✅ Use secret references (${VAR}, secret://)
  ✅ Encrypt secrets at rest
  ✅ Rotate secrets regularly
  ✅ Use scoped access
  ✅ Audit all access
  ✅ Use hardware keys for master key (production)
  
  ## DON'T:
  ❌ Hardcode secrets in code
  ❌ Commit secrets to git
  ❌ Log secret values
  ❌ Share secrets via chat/email
  ❌ Use same secret across environments
  ❌ Store master key with encrypted data

git_protection: |
  # Git Protection
  
  ## .gitignore (REQUIRED)
  ```
  # Secrets - NEVER commit
  .env
  .env.*
  *.key
  *.pem
  secrets/
  .vibee/secrets/
  
  # Config with secrets
  **/secrets.yaml
  **/credentials.yaml
  ```
  
  ## Pre-commit Hook
  ```bash
  #!/bin/bash
  # .git/hooks/pre-commit
  
  # Check for hardcoded secrets
  if git diff --cached | grep -E "(sk-[a-zA-Z0-9]{32}|api_key.*=.*['\"][^$])" ; then
    echo "ERROR: Possible hardcoded secret detected!"
    echo "Use \${VAR} references instead."
    exit 1
  fi
  ```
  
  ## Git-secrets (Recommended)
  ```bash
  git secrets --install
  git secrets --register-aws
  git secrets --add 'sk-[a-zA-Z0-9]{20,}'
  ```
