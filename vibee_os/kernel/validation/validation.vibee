# ============================================================================
# VALIDATION - Валидация данных на Vibee
# ============================================================================
# Schema validation, sanitization, custom rules
# ============================================================================

Specification Validation:
  """Валидация как спецификация корректности данных."""

  # ==========================================================================
  # TYPES
  # ==========================================================================

  Type Schema:
    type: SchemaType
    rules: List<Rule>
    transform: List<Transform>?
    meta: SchemaMeta?

  Type SchemaType:
    variants:
      - StringType
      - NumberType
      - IntegerType
      - BooleanType
      - ArrayType: Schema
      - ObjectType: Map<String, Schema>
      - TupleType: List<Schema>
      - UnionType: List<Schema>
      - LiteralType: Any
      - EnumType: List<Any>
      - NullType
      - AnyType
      - CustomType: String

  Type Rule:
    name: String
    params: Map<String, Any>
    message: String?
    condition: (Any) -> Boolean?

  Type Transform:
    name: String
    function: (Any) -> Any

  Type SchemaMeta:
    label: String?
    description: String?
    examples: List<Any>?
    deprecated: Boolean?
    default: Any?
    optional: Boolean?
    nullable: Boolean?

  Type ValidationResult:
    valid: Boolean
    value: Any?
    errors: List<ValidationError>

  Type ValidationError:
    path: List<String | Int>
    message: String
    rule: String
    value: Any?
    params: Map<String, Any>?

  Type ValidationOptions:
    abort_early: Boolean = false
    strip_unknown: Boolean = false
    allow_unknown: Boolean = false
    context: Map<String, Any>?

  # ==========================================================================
  # SCHEMA BUILDER
  # ==========================================================================

  Behavior SchemaBuilder:
    # String
    When v.string():
      Then: Schema(StringType, [])

    When schema.min(length):
      Given schema.type is StringType
      Then: schema with rules += Rule("min_length", { min: length })

    When schema.max(length):
      Given schema.type is StringType
      Then: schema with rules += Rule("max_length", { max: length })

    When schema.length(exact):
      Given schema.type is StringType
      Then: schema with rules += Rule("length", { length: exact })

    When schema.pattern(regex):
      Given schema.type is StringType
      Then: schema with rules += Rule("pattern", { pattern: regex })

    When schema.email():
      Given schema.type is StringType
      Then: schema with rules += Rule("email", {})

    When schema.url():
      Given schema.type is StringType
      Then: schema with rules += Rule("url", {})

    When schema.uuid():
      Given schema.type is StringType
      Then: schema with rules += Rule("uuid", {})

    When schema.ip():
      Given schema.type is StringType
      Then: schema with rules += Rule("ip", {})

    When schema.ipv4():
      Given schema.type is StringType
      Then: schema with rules += Rule("ipv4", {})

    When schema.ipv6():
      Given schema.type is StringType
      Then: schema with rules += Rule("ipv6", {})

    When schema.alpha():
      Given schema.type is StringType
      Then: schema with rules += Rule("alpha", {})

    When schema.alphanumeric():
      Given schema.type is StringType
      Then: schema with rules += Rule("alphanumeric", {})

    When schema.numeric():
      Given schema.type is StringType
      Then: schema with rules += Rule("numeric", {})

    When schema.lowercase():
      Given schema.type is StringType
      Then: schema with rules += Rule("lowercase", {})

    When schema.uppercase():
      Given schema.type is StringType
      Then: schema with rules += Rule("uppercase", {})

    When schema.trim():
      Given schema.type is StringType
      Then: schema with transform += Transform("trim", s -> s.trim())

    When schema.to_lowercase():
      Given schema.type is StringType
      Then: schema with transform += Transform("to_lowercase", s -> s.to_lowercase())

    When schema.to_uppercase():
      Given schema.type is StringType
      Then: schema with transform += Transform("to_uppercase", s -> s.to_uppercase())

    # Number
    When v.number():
      Then: Schema(NumberType, [])

    When v.integer():
      Then: Schema(IntegerType, [])

    When schema.min(value):
      Given schema.type is NumberType or IntegerType
      Then: schema with rules += Rule("min", { min: value })

    When schema.max(value):
      Given schema.type is NumberType or IntegerType
      Then: schema with rules += Rule("max", { max: value })

    When schema.positive():
      Given schema.type is NumberType or IntegerType
      Then: schema with rules += Rule("positive", {})

    When schema.negative():
      Given schema.type is NumberType or IntegerType
      Then: schema with rules += Rule("negative", {})

    When schema.between(min, max):
      Given schema.type is NumberType or IntegerType
      Then: schema with rules += Rule("between", { min: min, max: max })

    When schema.multiple_of(value):
      Given schema.type is NumberType or IntegerType
      Then: schema with rules += Rule("multiple_of", { value: value })

    # Boolean
    When v.boolean():
      Then: Schema(BooleanType, [])

    # Array
    When v.array(item_schema):
      Then: Schema(ArrayType(item_schema), [])

    When schema.min_items(count):
      Given schema.type is ArrayType
      Then: schema with rules += Rule("min_items", { min: count })

    When schema.max_items(count):
      Given schema.type is ArrayType
      Then: schema with rules += Rule("max_items", { max: count })

    When schema.unique():
      Given schema.type is ArrayType
      Then: schema with rules += Rule("unique", {})

    When schema.non_empty():
      Given schema.type is ArrayType
      Then: schema with rules += Rule("non_empty", {})

    # Object
    When v.object(shape):
      Then: Schema(ObjectType(shape), [])

    When schema.strict():
      Given schema.type is ObjectType
      Then: schema with rules += Rule("strict", {})

    When schema.passthrough():
      Given schema.type is ObjectType
      Then: schema with rules += Rule("passthrough", {})

    # Union & Enum
    When v.union(schemas):
      Then: Schema(UnionType(schemas), [])

    When v.enum(values):
      Then: Schema(EnumType(values), [])

    When v.literal(value):
      Then: Schema(LiteralType(value), [])

    # Special
    When v.null():
      Then: Schema(NullType, [])

    When v.any():
      Then: Schema(AnyType, [])

    # Modifiers
    When schema.optional():
      Then: schema with meta = (schema.meta ?? SchemaMeta()) with optional = true

    When schema.nullable():
      Then: schema with meta = (schema.meta ?? SchemaMeta()) with nullable = true

    When schema.default(value):
      Then: schema with meta = (schema.meta ?? SchemaMeta()) with default = value

    When schema.label(name):
      Then: schema with meta = (schema.meta ?? SchemaMeta()) with label = name

    When schema.description(text):
      Then: schema with meta = (schema.meta ?? SchemaMeta()) with description = text

    # Custom
    When schema.refine(predicate, message):
      Then: schema with rules += Rule("custom", { predicate: predicate, message: message })

    When schema.transform(fn):
      Then: schema with transform += Transform("custom", fn)

  # ==========================================================================
  # VALIDATION ENGINE
  # ==========================================================================

  Behavior ValidationEngine:
    When validate(schema, value, options):
      Then:
        - errors = []
        - path = []
        - result = validate_value(schema, value, path, errors, options)
        
        - return ValidationResult(
            valid: errors.is_empty(),
            value: if errors.is_empty() then result else null,
            errors: errors
          )

    When validate_value(schema, value, path, errors, options):
      Then:
        - # Handle null/undefined
        - if value == null:
            - if schema.meta?.nullable:
                - return null
            - if schema.meta?.optional:
                - return schema.meta?.default
            - add_error(errors, path, "required", "Value is required", value)
            - return null
        
        - # Apply transforms
        - for transform in schema.transform ?? []:
            - value = transform.function(value)
        
        - # Type validation
        - type_result = validate_type(schema.type, value, path, errors, options)
        - if type_result.is_error():
            - if options.abort_early: return null
        - else:
            - value = type_result.value
        
        - # Rule validation
        - for rule in schema.rules:
            - rule_result = validate_rule(rule, value, path, errors, options)
            - if rule_result.is_error() and options.abort_early:
                - return null
        
        - return value

    When validate_type(type, value, path, errors, options):
      Then:
        - match type:
            StringType ->
              if value is not String:
                add_error(errors, path, "type", "Expected string", value)
                Error()
              else:
                Ok(value)
            
            NumberType ->
              if value is not Number:
                add_error(errors, path, "type", "Expected number", value)
                Error()
              else:
                Ok(value)
            
            IntegerType ->
              if value is not Int:
                add_error(errors, path, "type", "Expected integer", value)
                Error()
              else:
                Ok(value)
            
            BooleanType ->
              if value is not Boolean:
                add_error(errors, path, "type", "Expected boolean", value)
                Error()
              else:
                Ok(value)
            
            ArrayType(item_schema) ->
              if value is not List:
                add_error(errors, path, "type", "Expected array", value)
                Error()
              else:
                validated = []
                for (i, item) in value.enumerate():
                  item_result = validate_value(item_schema, item, path + [i], errors, options)
                  add item_result to validated
                Ok(validated)
            
            ObjectType(shape) ->
              if value is not Map:
                add_error(errors, path, "type", "Expected object", value)
                Error()
              else:
                validated = {}
                # Validate known fields
                for (key, field_schema) in shape:
                  field_value = value.get(key)
                  field_result = validate_value(field_schema, field_value, path + [key], errors, options)
                  validated[key] = field_result
                # Handle unknown fields
                for key in value.keys():
                  if key not in shape:
                    if options.strip_unknown:
                      continue
                    elif not options.allow_unknown:
                      add_error(errors, path + [key], "unknown", "Unknown field", value[key])
                    else:
                      validated[key] = value[key]
                Ok(validated)
            
            UnionType(schemas) ->
              for schema in schemas:
                temp_errors = []
                result = validate_value(schema, value, path, temp_errors, options)
                if temp_errors.is_empty():
                  return Ok(result)
              add_error(errors, path, "union", "Value doesn't match any schema", value)
              Error()
            
            EnumType(values) ->
              if value not in values:
                add_error(errors, path, "enum", "Value must be one of: ${values.join(', ')}", value)
                Error()
              else:
                Ok(value)
            
            LiteralType(expected) ->
              if value != expected:
                add_error(errors, path, "literal", "Expected ${expected}", value)
                Error()
              else:
                Ok(value)
            
            NullType ->
              if value != null:
                add_error(errors, path, "type", "Expected null", value)
                Error()
              else:
                Ok(null)
            
            AnyType ->
              Ok(value)

    When validate_rule(rule, value, path, errors, options):
      Then:
        - valid = match rule.name:
            "min_length" -> value.length >= rule.params.min
            "max_length" -> value.length <= rule.params.max
            "length" -> value.length == rule.params.length
            "pattern" -> value.matches(rule.params.pattern)
            "email" -> value.matches(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)
            "url" -> is_valid_url(value)
            "uuid" -> value.matches(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)
            "ip" -> is_valid_ip(value)
            "ipv4" -> is_valid_ipv4(value)
            "ipv6" -> is_valid_ipv6(value)
            "alpha" -> value.matches(/^[a-zA-Z]+$/)
            "alphanumeric" -> value.matches(/^[a-zA-Z0-9]+$/)
            "numeric" -> value.matches(/^[0-9]+$/)
            "lowercase" -> value == value.to_lowercase()
            "uppercase" -> value == value.to_uppercase()
            "min" -> value >= rule.params.min
            "max" -> value <= rule.params.max
            "positive" -> value > 0
            "negative" -> value < 0
            "between" -> value >= rule.params.min and value <= rule.params.max
            "multiple_of" -> value % rule.params.value == 0
            "min_items" -> value.size >= rule.params.min
            "max_items" -> value.size <= rule.params.max
            "unique" -> value.size == value.unique().size
            "non_empty" -> value.is_not_empty()
            "custom" -> rule.params.predicate(value)
            _ -> true
        
        - if not valid:
            - message = rule.message ?? get_default_message(rule.name, rule.params)
            - add_error(errors, path, rule.name, message, value, rule.params)
            - return Error()
        
        - return Ok()

    When add_error(errors, path, rule, message, value, params):
      Then:
        - add ValidationError(path, message, rule, value, params) to errors

  # ==========================================================================
  # SANITIZATION
  # ==========================================================================

  Behavior Sanitization:
    When sanitize.string(value):
      Then:
        - if value is String: return value
        - if value is Number: return value.to_string()
        - if value is Boolean: return value.to_string()
        - return ""

    When sanitize.number(value):
      Then:
        - if value is Number: return value
        - if value is String:
            - parsed = parse_float(value)
            - return if parsed.is_nan() then 0 else parsed
        - return 0

    When sanitize.integer(value):
      Then:
        - if value is Int: return value
        - if value is Number: return floor(value)
        - if value is String:
            - parsed = parse_int(value)
            - return if parsed.is_nan() then 0 else parsed
        - return 0

    When sanitize.boolean(value):
      Then:
        - if value is Boolean: return value
        - if value is String:
            - return value.to_lowercase() in ["true", "1", "yes", "on"]
        - if value is Number: return value != 0
        - return false

    When sanitize.html(value):
      """Remove HTML tags"""
      Then:
        - return value.replace(/<[^>]*>/g, "")

    When sanitize.escape_html(value):
      """Escape HTML entities"""
      Then:
        - return value
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&#x27;")

    When sanitize.sql(value):
      """Escape SQL special characters"""
      Then:
        - return value
            .replace("'", "''")
            .replace("\\", "\\\\")

    When sanitize.trim(value):
      Then: value.trim()

    When sanitize.normalize_email(value):
      Then:
        - email = value.to_lowercase().trim()
        - (local, domain) = email.split("@")
        - # Remove dots from gmail
        - if domain in ["gmail.com", "googlemail.com"]:
            - local = local.replace(".", "")
            - local = local.split("+")[0]
        - return "${local}@${domain}"

    When sanitize.slug(value):
      Then:
        - return value
            .to_lowercase()
            .replace(/[^\w\s-]/g, "")
            .replace(/[\s_-]+/g, "-")
            .replace(/^-+|-+$/g, "")

    When sanitize.phone(value):
      Then:
        - return value.replace(/[^\d+]/g, "")

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Validation Usage":
    ```vibee
    # Define schema
    UserSchema = v.object({
      name: v.string().min(2).max(100).label("Name"),
      email: v.string().email().label("Email"),
      age: v.integer().min(0).max(150).optional(),
      password: v.string().min(8).pattern(/[A-Z]/).pattern(/[0-9]/)
        .label("Password")
        .refine(
          p -> not is_common_password(p),
          "Password is too common"
        ),
      role: v.enum(["user", "admin", "moderator"]).default("user"),
      tags: v.array(v.string()).max_items(10).unique().optional(),
      profile: v.object({
        bio: v.string().max(500).optional(),
        website: v.string().url().optional()
      }).optional()
    })

    # Validate
    result = validate(UserSchema, {
      name: "John Doe",
      email: "john@example.com",
      password: "SecurePass123",
      role: "user"
    })

    if result.valid:
      user = result.value
    else:
      for error in result.errors:
        log.error("${error.path.join('.')}: ${error.message}")

    # With transforms
    EmailSchema = v.string()
      .trim()
      .to_lowercase()
      .email()
      .transform(sanitize.normalize_email)

    # Union types
    IdSchema = v.union([
      v.string().uuid(),
      v.integer().positive()
    ])

    # Conditional validation
    PaymentSchema = v.object({
      method: v.enum(["card", "bank"]),
      card_number: v.string().length(16)
        .refine(
          (val, ctx) -> ctx.parent.method != "card" or val != null,
          "Card number required for card payments"
        ),
      bank_account: v.string()
        .refine(
          (val, ctx) -> ctx.parent.method != "bank" or val != null,
          "Bank account required for bank payments"
        )
    })

    # Sanitization
    clean_input = sanitize.html(user_input)
    safe_email = sanitize.normalize_email(email)
    slug = sanitize.slug(title)
    ```
