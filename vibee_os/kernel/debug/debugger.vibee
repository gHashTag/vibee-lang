name: vibee_os_debugger
version: "0.1.0"
language: gleam
module: kernel/debug/debugger
description: Debugger - отладчик для Vibee спецификаций с breakpoints, stepping, inspection

behaviors:
  - name: set_breakpoint
    given: Behavior exists
    when: breakpoint is set
    then: Execution pauses at breakpoint
    test_cases:
      - name: breakpoint_on_behavior
        input: {behavior: "calculate", line: 5}
        expected: {breakpoint_set: true, id: "bp_1"}
      - name: conditional_breakpoint
        input: {behavior: "process", condition: "x > 10"}
        expected: {breakpoint_set: true, conditional: true}
      - name: breakpoint_invalid_location
        input: {behavior: "nonexistent"}
        expected: {error: "behavior_not_found"}

  - name: step_execution
    given: Execution is paused
    when: Step command is issued
    then: Execution advances one step
    test_cases:
      - name: step_into
        input: {command: "step_into", at_function_call: true}
        expected: {entered_function: true}
      - name: step_over
        input: {command: "step_over", at_function_call: true}
        expected: {skipped_function: true, next_line: true}
      - name: step_out
        input: {command: "step_out", in_function: true}
        expected: {returned_to_caller: true}

  - name: inspect_state
    given: Execution is paused
    when: Inspect command is issued
    then: Current state is displayed
    test_cases:
      - name: inspect_variable
        input: {variable: "x", value: 42}
        expected: {displayed: true, value: 42, type: "int"}
      - name: inspect_context
        input: {command: "context"}
        expected: {variables: true, call_stack: true}
      - name: inspect_expression
        input: {expr: "x + y * 2"}
        expected: {evaluated: true, result: true}

  - name: watch_expression
    given: Watch is set
    when: Watched value changes
    Then: Change is reported
    test_cases:
      - name: watch_variable
        input: {watch: "counter", old: 5, new: 6}
        expected: {notified: true, old_value: 5, new_value: 6}
      - name: watch_expression
        input: {watch: "list.length", old: 3, new: 4}
        expected: {notified: true}

  - name: trace_execution
    given: Tracing is enabled
    when: Behavior executes
    Then: Full execution trace is recorded
    test_cases:
      - name: trace_behavior
        input: {behavior: "calculate", input: {a: 2, b: 3}}
        expected:
          trace_recorded: true
          has_steps: true
          has_timing: true
      - name: trace_with_calls
        input: {behavior: "complex", calls_other: true}
        expected:
          nested_traces: true

  - name: time_travel_debug
    given: Execution history exists
    when: Rewind command is issued
    Then: State is restored to previous point
    test_cases:
      - name: rewind_to_step
        input: {current_step: 10, rewind_to: 5}
        expected: {state_restored: true, at_step: 5}
      - name: replay_from_point
        input: {from_step: 5, to_step: 10}
        expected: {replayed: true, steps: 5}

types:
  # Debugger State
  Debugger:
    state: DebugState
    breakpoints: [Breakpoint]
    watches: [Watch]
    call_stack: [StackFrame]
    history: [ExecutionStep]
    config: DebugConfig

  DebugState:
    variants:
      - Running
      - Paused: {reason: PauseReason}
      - Stepping
      - Terminated

  PauseReason:
    variants:
      - Breakpoint: {id: str}
      - Step
      - Exception: {error: str}
      - WatchTriggered: {watch_id: str}
      - UserRequest

  # Breakpoints
  Breakpoint:
    id: str
    location: BreakpointLocation
    condition: str?
    hit_count: int
    enabled: bool
    temporary: bool

  BreakpointLocation:
    variants:
      - Behavior: {name: str, line: int?}
      - Function: {name: str}
      - File: {path: str, line: int}
      - Exception: {type: str?}

  # Call Stack
  StackFrame:
    id: int
    name: str
    location: str
    locals: {str: DebugValue}
    arguments: {str: DebugValue}

  DebugValue:
    type: str
    value: str
    expandable: bool
    children: {str: DebugValue}?

  # Watch
  Watch:
    id: str
    expression: str
    value: DebugValue?
    error: str?

  # Execution
  ExecutionStep:
    id: int
    timestamp: int
    location: str
    action: StepAction
    state_snapshot: {str: DebugValue}

  StepAction:
    variants:
      - Enter: {name: str}
      - Exit: {name: str, result: DebugValue?}
      - Assign: {variable: str, value: DebugValue}
      - Call: {function: str, args: [DebugValue]}
      - Return: {value: DebugValue}
      - Branch: {condition: str, taken: bool}
      - Loop: {iteration: int}
      - Exception: {error: str}

  # Trace
  ExecutionTrace:
    behavior: str
    input: {str: DebugValue}
    output: DebugValue?
    steps: [ExecutionStep]
    duration_ms: int
    nested_traces: [ExecutionTrace]

  # Commands
  DebugCommand:
    variants:
      - Continue
      - StepInto
      - StepOver
      - StepOut
      - RunToLine: {line: int}
      - Pause
      - Stop
      - Restart
      - SetBreakpoint: {location: BreakpointLocation, condition: str?}
      - RemoveBreakpoint: {id: str}
      - EnableBreakpoint: {id: str}
      - DisableBreakpoint: {id: str}
      - AddWatch: {expression: str}
      - RemoveWatch: {id: str}
      - Evaluate: {expression: str}
      - Inspect: {variable: str}
      - Stack
      - Locals
      - Rewind: {step: int}
      - Replay: {from: int, to: int}

  # Configuration
  DebugConfig:
    break_on_exception: bool
    break_on_entry: bool
    max_history_steps: int
    trace_enabled: bool
    time_travel_enabled: bool

  # Events
  DebugEvent:
    type: DebugEventType
    data: {str: str}
    timestamp: int

  DebugEventType:
    variants:
      - Paused
      - Resumed
      - BreakpointHit
      - StepCompleted
      - WatchChanged
      - ExceptionThrown
      - Terminated

functions:
  # Lifecycle
  - name: debugger_start
    params: {spec: str, config: DebugConfig?}
    returns: Debugger
    description: Start debugger session

  - name: debugger_stop
    params: {debugger: Debugger}
    returns: void
    description: Stop debugger

  - name: debugger_attach
    params: {process_id: str}
    returns: Debugger
    description: Attach to running process

  # Execution control
  - name: continue
    params: {debugger: Debugger}
    returns: void
    description: Continue execution

  - name: step_into
    params: {debugger: Debugger}
    returns: ExecutionStep
    description: Step into function

  - name: step_over
    params: {debugger: Debugger}
    returns: ExecutionStep
    description: Step over function

  - name: step_out
    params: {debugger: Debugger}
    returns: ExecutionStep
    description: Step out of function

  - name: pause
    params: {debugger: Debugger}
    returns: void
    description: Pause execution

  # Breakpoints
  - name: breakpoint_set
    params: {debugger: Debugger, location: BreakpointLocation, condition: str?}
    returns: Breakpoint
    description: Set breakpoint

  - name: breakpoint_remove
    params: {debugger: Debugger, id: str}
    returns: bool
    description: Remove breakpoint

  - name: breakpoint_list
    params: {debugger: Debugger}
    returns: [Breakpoint]
    description: List breakpoints

  # Watches
  - name: watch_add
    params: {debugger: Debugger, expression: str}
    returns: Watch
    description: Add watch expression

  - name: watch_remove
    params: {debugger: Debugger, id: str}
    returns: bool
    description: Remove watch

  - name: watch_evaluate
    params: {debugger: Debugger}
    returns: [Watch]
    description: Evaluate all watches

  # Inspection
  - name: evaluate
    params: {debugger: Debugger, expression: str}
    returns: DebugValue
    description: Evaluate expression

  - name: inspect
    params: {debugger: Debugger, variable: str}
    returns: DebugValue
    description: Inspect variable

  - name: stack_trace
    params: {debugger: Debugger}
    returns: [StackFrame]
    description: Get call stack

  - name: locals
    params: {debugger: Debugger}
    returns: {str: DebugValue}
    description: Get local variables

  # Time travel
  - name: rewind
    params: {debugger: Debugger, step: int}
    returns: bool
    description: Rewind to step

  - name: replay
    params: {debugger: Debugger, from: int, to: int}
    returns: [ExecutionStep]
    description: Replay steps

  # Tracing
  - name: trace_start
    params: {debugger: Debugger, behavior: str}
    returns: void
    description: Start tracing

  - name: trace_stop
    params: {debugger: Debugger}
    returns: ExecutionTrace
    description: Stop and get trace

imports:
  - kernel.vibee.compiler
  - kernel.ipc.event_bus

debug_commands: |
  # Debug Commands
  
  ## Execution
  - `c` / `continue` - Continue execution
  - `s` / `step` - Step into
  - `n` / `next` - Step over
  - `f` / `finish` - Step out
  - `r` / `restart` - Restart
  - `q` / `quit` - Stop debugging
  
  ## Breakpoints
  - `b <behavior>` - Break on behavior
  - `b <behavior>:<line>` - Break on line
  - `b <behavior> if <cond>` - Conditional break
  - `d <id>` - Delete breakpoint
  - `disable <id>` - Disable breakpoint
  - `enable <id>` - Enable breakpoint
  - `bl` - List breakpoints
  
  ## Inspection
  - `p <expr>` - Print expression
  - `pp <var>` - Pretty print variable
  - `locals` - Show local variables
  - `stack` - Show call stack
  - `frame <n>` - Select stack frame
  
  ## Watches
  - `w <expr>` - Add watch
  - `wd <id>` - Delete watch
  - `wl` - List watches
  
  ## Time Travel
  - `rewind <n>` - Go back n steps
  - `replay` - Replay from current
  - `history` - Show execution history

debug_session_example: |
  # Debug Session Example
  
  ```
  vibee debug calculator.vibee
  
  Debugger started. Type 'help' for commands.
  
  (vdb) b divide
  Breakpoint 1 set at behavior 'divide'
  
  (vdb) b divide if b == 0
  Breakpoint 2 set at behavior 'divide' (conditional: b == 0)
  
  (vdb) run divide(10, 2)
  Running...
  Hit breakpoint 1 at divide
  
  → behavior divide
      given: Two numbers a and b
    → when: divide(a, b) is called
      then: Returns a / b
  
  (vdb) p a
  10
  
  (vdb) p b
  2
  
  (vdb) n
  Step: evaluating a / b
  
  (vdb) p a / b
  5
  
  (vdb) c
  Result: 5
  
  (vdb) run divide(10, 0)
  Running...
  Hit breakpoint 2 at divide (condition: b == 0)
  
  (vdb) p b
  0
  
  (vdb) stack
  #0 divide(a=10, b=0) at calculator.vibee:15
  #1 <main> at <repl>:1
  
  (vdb) q
  Debugger terminated.
  ```
