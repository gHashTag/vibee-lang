# ============================================================================
# CLI FRAMEWORK - Создание CLI приложений на Vibee
# ============================================================================
# Commands, arguments, options, prompts, progress bars
# ============================================================================

Specification CLI:
  """CLI как спецификация командного интерфейса."""

  # ==========================================================================
  # CORE TYPES
  # ==========================================================================

  Type Command:
    name: String
    description: String
    aliases: List<String>
    arguments: List<Argument>
    options: List<Option>
    subcommands: List<Command>
    action: (Context) -> Promise<Int>
    examples: List<Example>
    hidden: Boolean = false

  Type Argument:
    name: String
    description: String
    required: Boolean = true
    default: Any?
    variadic: Boolean = false
    validator: ((Any) -> Result<Any, String>)?

  Type Option:
    name: String
    short: Char?
    description: String
    required: Boolean = false
    default: Any?
    type: OptionType
    choices: List<Any>?
    env_var: String?
    hidden: Boolean = false

  Type OptionType:
    variants:
      - String
      - Int
      - Float
      - Boolean
      - Count
      - Array: OptionType
      - Path
      - Choice: List<String>

  Type Example:
    description: String
    command: String

  Type Context:
    command: Command
    args: Map<String, Any>
    options: Map<String, Any>
    raw_args: List<String>
    stdin: InputStream
    stdout: OutputStream
    stderr: OutputStream

  Type ParseResult:
    command: Command
    args: Map<String, Any>
    options: Map<String, Any>
    errors: List<ParseError>

  Type ParseError:
    variants:
      - UnknownCommand: String
      - UnknownOption: String
      - MissingArgument: String
      - MissingOption: String
      - InvalidValue: (name: String, value: String, expected: String)
      - TooManyArguments: Int

  # ==========================================================================
  # COMMAND BUILDER
  # ==========================================================================

  Behavior CommandBuilder:
    When cli.program(name, version):
      Then:
        - return Program(
            name: name,
            version: version,
            description: "",
            commands: [],
            global_options: default_global_options()
          )

    Type Program:
      name: String
      version: String
      description: String
      commands: List<Command>
      global_options: List<Option>

      Method description(desc: String) -> Program:
        self.description = desc
        return self

      Method command(name: String) -> CommandBuilder:
        return CommandBuilder(self, name)

      Method option(name, short, description, config) -> Program:
        global_options.push(build_option(name, short, description, config))
        return self

      Method parse(args: List<String>) -> ParseResult:
        return parse_args(self, args)

      Method run(args: List<String>) -> Promise<Int>:
        result = parse(args)
        if result.errors.length > 0:
          print_errors(result.errors)
          return 1
        return await execute_command(result)

    Type CommandBuilder:
      program: Program
      command: Command

      Method description(desc: String) -> CommandBuilder:
        command.description = desc
        return self

      Method alias(name: String) -> CommandBuilder:
        command.aliases.push(name)
        return self

      Method argument(name, description, config) -> CommandBuilder:
        command.arguments.push(build_argument(name, description, config))
        return self

      Method option(name, short, description, config) -> CommandBuilder:
        command.options.push(build_option(name, short, description, config))
        return self

      Method example(description, cmd) -> CommandBuilder:
        command.examples.push(Example(description, cmd))
        return self

      Method action(fn: (Context) -> Promise<Int>) -> CommandBuilder:
        command.action = fn
        return self

      Method hidden() -> CommandBuilder:
        command.hidden = true
        return self

      Method subcommand(name: String) -> CommandBuilder:
        sub = CommandBuilder(program, name)
        command.subcommands.push(sub.command)
        return sub

      Method end() -> Program:
        program.commands.push(command)
        return program

  # ==========================================================================
  # ARGUMENT PARSING
  # ==========================================================================

  Behavior ArgumentParsing:
    When parse_args(program, args):
      Then:
        - tokens = tokenize(args)
        - result = ParseResult(command: null, args: {}, options: {}, errors: [])
        
        - # Parse global options first
        - (global_opts, remaining) = parse_options(tokens, program.global_options)
        - result.options = global_opts
        
        - # Handle --help and --version
        - if global_opts["help"]:
            - print_help(program, result.command)
            - return result
        - if global_opts["version"]:
            - print("${program.name} ${program.version}")
            - return result
        
        - # Find command
        - if remaining.length > 0:
            - cmd_name = remaining[0]
            - command = find_command(program.commands, cmd_name)
            - if command:
                - result.command = command
                - remaining = remaining.slice(1)
              else:
                - result.errors.push(UnknownCommand(cmd_name))
                - return result
        
        - # Parse command options and arguments
        - if result.command:
            - (cmd_opts, remaining) = parse_options(remaining, result.command.options)
            - result.options = { ...result.options, ...cmd_opts }
            - result.args = parse_arguments(remaining, result.command.arguments, result.errors)
        
        - return result

    When tokenize(args):
      Then:
        - tokens = []
        - for arg in args:
            - if arg.starts_with("--"):
                - if "=" in arg:
                    - (name, value) = arg.split("=", 2)
                    - tokens.push(LongOption(name.slice(2), value))
                  else:
                    - tokens.push(LongOption(arg.slice(2), null))
              else if arg.starts_with("-") and arg.length > 1:
                - for char in arg.slice(1):
                    - tokens.push(ShortOption(char))
              else:
                - tokens.push(Positional(arg))
        - return tokens

    Type Token:
      variants:
        - LongOption: (name: String, value: String?)
        - ShortOption: Char
        - Positional: String

  # ==========================================================================
  # OUTPUT & FORMATTING
  # ==========================================================================

  Behavior Output:
    When print(message, options):
      Then:
        - styled = apply_styles(message, options)
        - stdout.write(styled + "\n")

    When print_error(message):
      Then:
        - stderr.write(style.red("Error: ") + message + "\n")

    When print_warning(message):
      Then:
        - stderr.write(style.yellow("Warning: ") + message + "\n")

    When print_success(message):
      Then:
        - stdout.write(style.green("✓ ") + message + "\n")

    When print_info(message):
      Then:
        - stdout.write(style.blue("ℹ ") + message + "\n")

  Behavior Styling:
    Type Style:
      Method bold(text: String) -> String:
        return "\x1b[1m${text}\x1b[0m"

      Method dim(text: String) -> String:
        return "\x1b[2m${text}\x1b[0m"

      Method italic(text: String) -> String:
        return "\x1b[3m${text}\x1b[0m"

      Method underline(text: String) -> String:
        return "\x1b[4m${text}\x1b[0m"

      Method red(text: String) -> String:
        return "\x1b[31m${text}\x1b[0m"

      Method green(text: String) -> String:
        return "\x1b[32m${text}\x1b[0m"

      Method yellow(text: String) -> String:
        return "\x1b[33m${text}\x1b[0m"

      Method blue(text: String) -> String:
        return "\x1b[34m${text}\x1b[0m"

      Method magenta(text: String) -> String:
        return "\x1b[35m${text}\x1b[0m"

      Method cyan(text: String) -> String:
        return "\x1b[36m${text}\x1b[0m"

      Method white(text: String) -> String:
        return "\x1b[37m${text}\x1b[0m"

      Method bg_red(text: String) -> String:
        return "\x1b[41m${text}\x1b[0m"

      Method bg_green(text: String) -> String:
        return "\x1b[42m${text}\x1b[0m"

      Method rgb(text: String, r: Int, g: Int, b: Int) -> String:
        return "\x1b[38;2;${r};${g};${b}m${text}\x1b[0m"

  # ==========================================================================
  # PROMPTS
  # ==========================================================================

  Behavior Prompts:
    When prompt.input(message, options):
      Then:
        - print("${message}: ", newline: false)
        - value = await stdin.read_line()
        - value = value.trim()
        
        - if value == "" and options.default:
            - return options.default
        
        - if options.validate:
            - result = options.validate(value)
            - if result is Err:
                - print_error(result.error)
                - return await prompt.input(message, options)
        
        - return value

    When prompt.password(message):
      Then:
        - print("${message}: ", newline: false)
        - disable_echo()
        - value = await stdin.read_line()
        - enable_echo()
        - print("")
        - return value.trim()

    When prompt.confirm(message, default):
      Then:
        - hint = if default then "[Y/n]" else "[y/N]"
        - print("${message} ${hint}: ", newline: false)
        - value = await stdin.read_line()
        - value = value.trim().lowercase()
        
        - if value == "":
            - return default ?? false
        
        - return value in ["y", "yes", "true", "1"]

    When prompt.select(message, choices):
      Then:
        - print(message)
        - for (i, choice) in choices.enumerate():
            - print("  ${i + 1}. ${choice.label ?? choice}")
        
        - print("Enter number: ", newline: false)
        - value = await stdin.read_line()
        - index = parse_int(value.trim()) - 1
        
        - if index < 0 or index >= choices.length:
            - print_error("Invalid selection")
            - return await prompt.select(message, choices)
        
        - return choices[index].value ?? choices[index]

    When prompt.multi_select(message, choices):
      Then:
        - print(message)
        - selected = []
        
        - for (i, choice) in choices.enumerate():
            - print("  ${i + 1}. [ ] ${choice.label ?? choice}")
        
        - print("Enter numbers (comma-separated): ", newline: false)
        - value = await stdin.read_line()
        - indices = value.split(",").map(s -> parse_int(s.trim()) - 1)
        
        - for index in indices:
            - if index >= 0 and index < choices.length:
                - selected.push(choices[index].value ?? choices[index])
        
        - return selected

    When prompt.autocomplete(message, source):
      Then:
        - print("${message}: ", newline: false)
        - value = ""
        - suggestions = []
        
        - while true:
            - char = await stdin.read_char()
            
            - if char == "\n":
                - break
            - if char == "\t" and suggestions.length > 0:
                - value = suggestions[0]
                - clear_line()
                - print("${message}: ${value}", newline: false)
              else:
                - value += char
                - suggestions = await source(value)
                - # Show suggestions below
        
        - print("")
        - return value

  # ==========================================================================
  # PROGRESS
  # ==========================================================================

  Behavior Progress:
    When progress.bar(options):
      Then:
        - return ProgressBar(
            total: options.total,
            width: options.width ?? 40,
            complete_char: options.complete ?? "█",
            incomplete_char: options.incomplete ?? "░",
            format: options.format ?? ":bar :percent :eta"
          )

    Type ProgressBar:
      total: Int
      current: Int = 0
      width: Int
      complete_char: String
      incomplete_char: String
      format: String
      start_time: DateTime?

      Method start():
        start_time = now()
        render()

      Method update(value: Int):
        current = value
        render()

      Method increment(amount: Int = 1):
        current += amount
        render()

      Method finish():
        current = total
        render()
        print("")

      Method render():
        percent = current / total
        filled = round(width * percent)
        empty = width - filled
        
        bar = complete_char.repeat(filled) + incomplete_char.repeat(empty)
        percent_str = "${round(percent * 100)}%"
        
        eta = if start_time and current > 0:
          elapsed = now() - start_time
          remaining = elapsed * (total - current) / current
          format_duration(remaining)
        else:
          "..."
        
        line = format
          .replace(":bar", bar)
          .replace(":percent", percent_str)
          .replace(":current", current.to_string())
          .replace(":total", total.to_string())
          .replace(":eta", eta)
        
        clear_line()
        print(line, newline: false)

    When progress.spinner(options):
      Then:
        - return Spinner(
            frames: options.frames ?? ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"],
            interval: options.interval ?? 80.ms,
            text: options.text ?? ""
          )

    Type Spinner:
      frames: List<String>
      interval: Duration
      text: String
      frame_index: Int = 0
      running: Boolean = false
      timer: Timer?

      Method start():
        running = true
        timer = set_interval(interval, () -> {
          frame_index = (frame_index + 1) % frames.length
          render()
        })
        render()

      Method stop():
        running = false
        timer?.cancel()
        clear_line()

      Method succeed(message: String):
        stop()
        print_success(message)

      Method fail(message: String):
        stop()
        print_error(message)

      Method update(text: String):
        self.text = text
        render()

      Method render():
        clear_line()
        print("${frames[frame_index]} ${text}", newline: false)

    When progress.multi(tasks):
      Then:
        - return MultiProgress(tasks)

    Type MultiProgress:
      tasks: List<ProgressTask>

      Method render():
        for task in tasks:
          task.render()

      Method update(index: Int, progress: Float):
        tasks[index].progress = progress
        render()

  # ==========================================================================
  # TABLES
  # ==========================================================================

  Behavior Tables:
    When table(data, options):
      Then:
        - return Table(data, options)

    Type Table:
      data: List<Map<String, Any>>
      columns: List<Column>?
      border: BorderStyle = Single
      header: Boolean = true

      Method render() -> String:
        cols = columns ?? infer_columns(data)
        widths = calculate_widths(data, cols)
        
        lines = []
        
        # Top border
        lines.push(render_border(widths, "top"))
        
        # Header
        if header:
          lines.push(render_row(cols.map(c -> c.header), widths))
          lines.push(render_border(widths, "middle"))
        
        # Data rows
        for row in data:
          values = cols.map(c -> format_cell(row[c.key], c))
          lines.push(render_row(values, widths))
        
        # Bottom border
        lines.push(render_border(widths, "bottom"))
        
        return lines.join("\n")

      Method print():
        stdout.write(render() + "\n")

    Type Column:
      key: String
      header: String
      width: Int?
      align: Alignment = Left
      format: ((Any) -> String)?

    Type Alignment:
      variants: [Left, Center, Right]

    Type BorderStyle:
      variants: [None, Single, Double, Rounded, Heavy]

  # ==========================================================================
  # HELP GENERATION
  # ==========================================================================

  Behavior HelpGeneration:
    When print_help(program, command):
      Then:
        - if command:
            - print_command_help(program, command)
          else:
            - print_program_help(program)

    When print_program_help(program):
      Then:
        - print(style.bold(program.name) + " " + style.dim(program.version))
        - if program.description:
            - print("")
            - print(program.description)
        
        - print("")
        - print(style.bold("USAGE:"))
        - print("  ${program.name} [OPTIONS] <COMMAND>")
        
        - if program.commands.length > 0:
            - print("")
            - print(style.bold("COMMANDS:"))
            - max_len = max(program.commands.map(c -> c.name.length))
            - for cmd in program.commands.filter(c -> !c.hidden):
                - padding = " ".repeat(max_len - cmd.name.length + 2)
                - print("  ${cmd.name}${padding}${cmd.description}")
        
        - print("")
        - print(style.bold("OPTIONS:"))
        - for opt in program.global_options:
            - print_option(opt)
        
        - print("")
        - print("Run '${program.name} <COMMAND> --help' for more information on a command.")

    When print_command_help(program, command):
      Then:
        - print(style.bold(command.name) + " - " + command.description)
        
        - print("")
        - print(style.bold("USAGE:"))
        - args_str = command.arguments.map(a -> 
            if a.required then "<${a.name}>" else "[${a.name}]"
          ).join(" ")
        - print("  ${program.name} ${command.name} [OPTIONS] ${args_str}")
        
        - if command.arguments.length > 0:
            - print("")
            - print(style.bold("ARGUMENTS:"))
            - for arg in command.arguments:
                - req = if arg.required then style.red("(required)") else style.dim("(optional)")
                - print("  <${arg.name}>  ${arg.description} ${req}")
        
        - if command.options.length > 0:
            - print("")
            - print(style.bold("OPTIONS:"))
            - for opt in command.options:
                - print_option(opt)
        
        - if command.examples.length > 0:
            - print("")
            - print(style.bold("EXAMPLES:"))
            - for ex in command.examples:
                - print("  # ${ex.description}")
                - print("  $ ${ex.command}")
                - print("")

    When print_option(opt):
      Then:
        - short = if opt.short then "-${opt.short}, " else "    "
        - long = "--${opt.name}"
        - type_hint = match opt.type:
            String -> " <string>"
            Int -> " <number>"
            Float -> " <number>"
            Path -> " <path>"
            Choice(choices) -> " <${choices.join("|")}>"
            _ -> ""
        - default = if opt.default then style.dim(" [default: ${opt.default}]") else ""
        - print("  ${short}${long}${type_hint}  ${opt.description}${default}")

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "CLI Application":
    ```vibee
    program = cli.program("myapp", "1.0.0")
      .description("My awesome CLI application")
      .option("verbose", "v", "Enable verbose output", type: Boolean)
      .option("config", "c", "Config file path", type: Path, default: "./config.json")

      .command("init")
        .description("Initialize a new project")
        .argument("name", "Project name")
        .option("template", "t", "Template to use", type: Choice(["basic", "full"]), default: "basic")
        .example("Create basic project", "myapp init my-project")
        .example("Create from template", "myapp init my-project -t full")
        .action(async (ctx) -> {
          name = ctx.args["name"]
          template = ctx.options["template"]
          
          spinner = progress.spinner(text: "Creating project...")
          spinner.start()
          
          await create_project(name, template)
          
          spinner.succeed("Project '${name}' created successfully!")
          return 0
        })
        .end()

      .command("build")
        .description("Build the project")
        .option("output", "o", "Output directory", type: Path, default: "./dist")
        .option("minify", "m", "Minify output", type: Boolean)
        .action(async (ctx) -> {
          output = ctx.options["output"]
          minify = ctx.options["minify"]
          
          files = await find_source_files()
          bar = progress.bar(total: files.length)
          bar.start()
          
          for file in files:
            await build_file(file, output, minify)
            bar.increment()
          
          bar.finish()
          print_success("Build complete!")
          return 0
        })
        .end()

      .command("deploy")
        .description("Deploy to production")
        .option("env", "e", "Environment", type: Choice(["staging", "production"]), required: true)
        .action(async (ctx) -> {
          env = ctx.options["env"]
          
          if env == "production":
            confirmed = await prompt.confirm("Deploy to production?", false)
            if not confirmed:
              print_info("Deployment cancelled")
              return 0
          
          # Deploy logic
          print_success("Deployed to ${env}!")
          return 0
        })
        .end()

      .command("config")
        .description("Manage configuration")
        .subcommand("get")
          .description("Get config value")
          .argument("key", "Config key")
          .action(async (ctx) -> {
            key = ctx.args["key"]
            value = await get_config(key)
            print("${key} = ${value}")
            return 0
          })
          .end()
        .subcommand("set")
          .description("Set config value")
          .argument("key", "Config key")
          .argument("value", "Config value")
          .action(async (ctx) -> {
            await set_config(ctx.args["key"], ctx.args["value"])
            print_success("Config updated")
            return 0
          })
          .end()
        .end()

    # Run the CLI
    exit_code = await program.run(process.args)
    exit(exit_code)
    ```
