# ============================================================================
# SIGNAL - Обработка сигналов на Vibee
# ============================================================================
# Unix signals, Signal handlers, Graceful shutdown
# ============================================================================

Specification Signal:
  """Сигналы как спецификация межпроцессного взаимодействия."""

  # ==========================================================================
  # SIGNAL TYPES
  # ==========================================================================

  Type Signal:
    variants:
      # Standard signals
      - SIGHUP      # 1 - Hangup
      - SIGINT      # 2 - Interrupt (Ctrl+C)
      - SIGQUIT     # 3 - Quit
      - SIGILL      # 4 - Illegal instruction
      - SIGTRAP     # 5 - Trace trap
      - SIGABRT     # 6 - Abort
      - SIGBUS      # 7 - Bus error
      - SIGFPE      # 8 - Floating point exception
      - SIGKILL     # 9 - Kill (cannot be caught)
      - SIGUSR1     # 10 - User defined 1
      - SIGSEGV     # 11 - Segmentation fault
      - SIGUSR2     # 12 - User defined 2
      - SIGPIPE     # 13 - Broken pipe
      - SIGALRM     # 14 - Alarm clock
      - SIGTERM     # 15 - Termination
      - SIGSTKFLT   # 16 - Stack fault
      - SIGCHLD     # 17 - Child status changed
      - SIGCONT     # 18 - Continue
      - SIGSTOP     # 19 - Stop (cannot be caught)
      - SIGTSTP     # 20 - Terminal stop (Ctrl+Z)
      - SIGTTIN     # 21 - Background read
      - SIGTTOU     # 22 - Background write
      - SIGURG      # 23 - Urgent condition
      - SIGXCPU     # 24 - CPU time limit
      - SIGXFSZ     # 25 - File size limit
      - SIGVTALRM   # 26 - Virtual timer
      - SIGPROF     # 27 - Profiling timer
      - SIGWINCH    # 28 - Window size change
      - SIGIO       # 29 - I/O possible
      - SIGPWR      # 30 - Power failure
      - SIGSYS      # 31 - Bad system call

    Method number() -> Int:
      match self:
        SIGHUP -> 1
        SIGINT -> 2
        SIGQUIT -> 3
        SIGILL -> 4
        SIGTRAP -> 5
        SIGABRT -> 6
        SIGBUS -> 7
        SIGFPE -> 8
        SIGKILL -> 9
        SIGUSR1 -> 10
        SIGSEGV -> 11
        SIGUSR2 -> 12
        SIGPIPE -> 13
        SIGALRM -> 14
        SIGTERM -> 15
        SIGSTKFLT -> 16
        SIGCHLD -> 17
        SIGCONT -> 18
        SIGSTOP -> 19
        SIGTSTP -> 20
        SIGTTIN -> 21
        SIGTTOU -> 22
        SIGURG -> 23
        SIGXCPU -> 24
        SIGXFSZ -> 25
        SIGVTALRM -> 26
        SIGPROF -> 27
        SIGWINCH -> 28
        SIGIO -> 29
        SIGPWR -> 30
        SIGSYS -> 31

    Static Method from_number(n: Int) -> Option<Signal>:
      match n:
        1 -> Some(SIGHUP)
        2 -> Some(SIGINT)
        3 -> Some(SIGQUIT)
        4 -> Some(SIGILL)
        5 -> Some(SIGTRAP)
        6 -> Some(SIGABRT)
        7 -> Some(SIGBUS)
        8 -> Some(SIGFPE)
        9 -> Some(SIGKILL)
        10 -> Some(SIGUSR1)
        11 -> Some(SIGSEGV)
        12 -> Some(SIGUSR2)
        13 -> Some(SIGPIPE)
        14 -> Some(SIGALRM)
        15 -> Some(SIGTERM)
        16 -> Some(SIGSTKFLT)
        17 -> Some(SIGCHLD)
        18 -> Some(SIGCONT)
        19 -> Some(SIGSTOP)
        20 -> Some(SIGTSTP)
        21 -> Some(SIGTTIN)
        22 -> Some(SIGTTOU)
        23 -> Some(SIGURG)
        24 -> Some(SIGXCPU)
        25 -> Some(SIGXFSZ)
        26 -> Some(SIGVTALRM)
        27 -> Some(SIGPROF)
        28 -> Some(SIGWINCH)
        29 -> Some(SIGIO)
        30 -> Some(SIGPWR)
        31 -> Some(SIGSYS)
        _ -> null

    Method name() -> String:
      match self:
        SIGHUP -> "SIGHUP"
        SIGINT -> "SIGINT"
        SIGQUIT -> "SIGQUIT"
        SIGILL -> "SIGILL"
        SIGTRAP -> "SIGTRAP"
        SIGABRT -> "SIGABRT"
        SIGBUS -> "SIGBUS"
        SIGFPE -> "SIGFPE"
        SIGKILL -> "SIGKILL"
        SIGUSR1 -> "SIGUSR1"
        SIGSEGV -> "SIGSEGV"
        SIGUSR2 -> "SIGUSR2"
        SIGPIPE -> "SIGPIPE"
        SIGALRM -> "SIGALRM"
        SIGTERM -> "SIGTERM"
        SIGSTKFLT -> "SIGSTKFLT"
        SIGCHLD -> "SIGCHLD"
        SIGCONT -> "SIGCONT"
        SIGSTOP -> "SIGSTOP"
        SIGTSTP -> "SIGTSTP"
        SIGTTIN -> "SIGTTIN"
        SIGTTOU -> "SIGTTOU"
        SIGURG -> "SIGURG"
        SIGXCPU -> "SIGXCPU"
        SIGXFSZ -> "SIGXFSZ"
        SIGVTALRM -> "SIGVTALRM"
        SIGPROF -> "SIGPROF"
        SIGWINCH -> "SIGWINCH"
        SIGIO -> "SIGIO"
        SIGPWR -> "SIGPWR"
        SIGSYS -> "SIGSYS"

    Method description() -> String:
      match self:
        SIGHUP -> "Hangup"
        SIGINT -> "Interrupt"
        SIGQUIT -> "Quit"
        SIGILL -> "Illegal instruction"
        SIGTRAP -> "Trace trap"
        SIGABRT -> "Abort"
        SIGBUS -> "Bus error"
        SIGFPE -> "Floating point exception"
        SIGKILL -> "Kill"
        SIGUSR1 -> "User defined signal 1"
        SIGSEGV -> "Segmentation fault"
        SIGUSR2 -> "User defined signal 2"
        SIGPIPE -> "Broken pipe"
        SIGALRM -> "Alarm clock"
        SIGTERM -> "Termination"
        SIGSTKFLT -> "Stack fault"
        SIGCHLD -> "Child status changed"
        SIGCONT -> "Continue"
        SIGSTOP -> "Stop"
        SIGTSTP -> "Terminal stop"
        SIGTTIN -> "Background read"
        SIGTTOU -> "Background write"
        SIGURG -> "Urgent condition"
        SIGXCPU -> "CPU time limit exceeded"
        SIGXFSZ -> "File size limit exceeded"
        SIGVTALRM -> "Virtual timer expired"
        SIGPROF -> "Profiling timer expired"
        SIGWINCH -> "Window size changed"
        SIGIO -> "I/O possible"
        SIGPWR -> "Power failure"
        SIGSYS -> "Bad system call"

    Method is_catchable() -> Boolean:
      return self != SIGKILL and self != SIGSTOP

    Method default_action() -> SignalAction:
      match self:
        SIGHUP | SIGINT | SIGQUIT | SIGILL | SIGTRAP | SIGABRT |
        SIGBUS | SIGFPE | SIGKILL | SIGSEGV | SIGPIPE | SIGALRM |
        SIGTERM | SIGSTKFLT | SIGXCPU | SIGXFSZ | SIGSYS -> SignalAction.Terminate
        SIGUSR1 | SIGUSR2 -> SignalAction.Terminate
        SIGCHLD | SIGURG | SIGWINCH -> SignalAction.Ignore
        SIGCONT -> SignalAction.Continue
        SIGSTOP | SIGTSTP | SIGTTIN | SIGTTOU -> SignalAction.Stop
        _ -> SignalAction.Terminate

  Type SignalAction:
    variants:
      - Terminate
      - Ignore
      - Stop
      - Continue
      - CoreDump

  # ==========================================================================
  # SIGNAL HANDLER
  # ==========================================================================

  Type SignalHandler:
    handlers: Map<Signal, List<SignalCallback>>
    pending: Channel<Signal>
    running: Atomic<Boolean>
    worker: Option<Task>

    Static Method new() -> SignalHandler:
      handler = SignalHandler(
        handlers: {},
        pending: Channel.unbounded(),
        running: Atomic(false),
        worker: null
      )
      return handler

    Static Method global() -> SignalHandler:
      return GLOBAL_SIGNAL_HANDLER

    Method start():
      if self.running.compare_exchange(false, true):
        self.worker = Some(spawn {
          self.run_loop()
        })

    Method run_loop():
      while self.running.load():
        signal = self.pending.recv_timeout(Duration.millis(100))
        
        if signal is Some(sig):
          self.dispatch(sig)

    Method dispatch(signal: Signal):
      if self.handlers.get(signal) is Some(callbacks):
        for callback in callbacks:
          try:
            callback(signal)
          catch error:
            log.error("Signal handler error: ${error}")

    Method stop():
      self.running.store(false)
      if self.worker is Some(w):
        w.join()

    Method on(signal: Signal, callback: SignalCallback) -> SignalSubscription:
      if not signal.is_catchable():
        panic("Cannot catch signal: ${signal.name()}")
      
      if signal not in self.handlers:
        self.handlers[signal] = []
        native_register_signal(signal, self.pending)
      
      self.handlers[signal].push(callback)
      
      return SignalSubscription(self, signal, callback)

    Method off(signal: Signal, callback: SignalCallback):
      if self.handlers.get(signal) is Some(callbacks):
        self.handlers[signal] = callbacks.filter(c -> c != callback)
        
        if self.handlers[signal].is_empty():
          native_unregister_signal(signal)
          self.handlers.remove(signal)

    Method ignore(signal: Signal):
      if signal.is_catchable():
        native_ignore_signal(signal)

    Method reset(signal: Signal):
      native_reset_signal(signal)
      self.handlers.remove(signal)

  Type SignalCallback = (Signal) -> ()

  Type SignalSubscription:
    handler: SignalHandler
    signal: Signal
    callback: SignalCallback

    Method unsubscribe():
      self.handler.off(self.signal, self.callback)

  # ==========================================================================
  # SIGNAL STREAM
  # ==========================================================================

  Type SignalStream:
    signal: Signal
    receiver: Channel<Signal>

    Static Method new(signal: Signal) -> SignalStream:
      receiver = Channel.unbounded()
      native_register_signal(signal, receiver)
      return SignalStream(signal, receiver)

    Method recv() -> Signal:
      return self.receiver.recv()

    Method try_recv() -> Option<Signal>:
      return self.receiver.try_recv()

    Method recv_timeout(timeout: Duration) -> Option<Signal>:
      return self.receiver.recv_timeout(timeout)

    Trait Iterator<Signal>:
      Method next() -> Option<Signal>:
        return Some(self.recv())

    Method close():
      native_unregister_signal(self.signal)
      self.receiver.close()

  # ==========================================================================
  # GRACEFUL SHUTDOWN
  # ==========================================================================

  Type GracefulShutdown:
    shutdown_requested: Atomic<Boolean>
    shutdown_channel: Channel<()>
    handlers: List<ShutdownHandler>
    timeout: Duration
    mutex: Mutex<()>

    Static Method new() -> GracefulShutdown:
      return GracefulShutdown.with_timeout(Duration.seconds(30))

    Static Method with_timeout(timeout: Duration) -> GracefulShutdown:
      shutdown = GracefulShutdown(
        shutdown_requested: Atomic(false),
        shutdown_channel: Channel.bounded(1),
        handlers: [],
        timeout: timeout,
        mutex: Mutex.new(())
      )
      
      # Register default signals
      shutdown.register_signals([Signal.SIGINT, Signal.SIGTERM])
      
      return shutdown

    Method register_signals(signals: List<Signal>):
      for signal in signals:
        SignalHandler.global().on(signal, sig -> {
          log.info("Received ${sig.name()}, initiating shutdown...")
          self.trigger()
        })

    Method on_shutdown(handler: ShutdownHandler):
      guard = self.mutex.lock()
      self.handlers.push(handler)

    Method on_shutdown_async(handler: () -> Promise<()>):
      self.on_shutdown(ShutdownHandler(
        name: "async_handler",
        priority: 0,
        handler: () -> {
          handler().await
        }
      ))

    Method trigger():
      if self.shutdown_requested.compare_exchange(false, true):
        self.shutdown_channel.send(())

    Method is_shutdown_requested() -> Boolean:
      return self.shutdown_requested.load()

    Method wait():
      self.shutdown_channel.recv()

    Method wait_timeout(timeout: Duration) -> Boolean:
      return self.shutdown_channel.recv_timeout(timeout) != null

    Method run_handlers() -> Result<(), ShutdownError>:
      guard = self.mutex.lock()
      
      # Sort by priority (higher first)
      sorted_handlers = self.handlers.sorted_by(h -> -h.priority)
      
      errors = []
      
      for handler in sorted_handlers:
        log.info("Running shutdown handler: ${handler.name}")
        
        result = timeout_call(self.timeout, () -> {
          handler.handler()
        })
        
        match result:
          Ok(_) -> log.info("Handler ${handler.name} completed")
          Err(e) -> 
            log.error("Handler ${handler.name} failed: ${e}")
            errors.push((handler.name, e))
      
      if errors.is_empty():
        return Ok(())
      else:
        return Err(ShutdownError(errors))

    Method shutdown():
      self.trigger()
      self.run_handlers()

  Type ShutdownHandler:
    name: String
    priority: Int
    handler: () -> ()

  Type ShutdownError:
    errors: List<(String, Error)>

    Method message() -> String:
      return "Shutdown errors: " + self.errors
        .map((name, e) -> "${name}: ${e.message()}")
        .join(", ")

  # ==========================================================================
  # SIGNAL UTILITIES
  # ==========================================================================

  Behavior SignalUtils:
    When raise_signal(signal: Signal) -> Result<(), SignalError>:
      Then: native_raise(signal)

    When kill(pid: ProcessId, signal: Signal) -> Result<(), SignalError>:
      Then: native_kill(pid, signal)

    When killpg(pgid: ProcessId, signal: Signal) -> Result<(), SignalError>:
      Then: native_killpg(pgid, signal)

    When alarm(seconds: Int) -> Int:
      Then: native_alarm(seconds)

    When pause():
      Then: native_pause()

    When sigwait(signals: List<Signal>) -> Signal:
      Then: native_sigwait(signals)

    When block_signals(signals: List<Signal>):
      Then: native_sigprocmask_block(signals)

    When unblock_signals(signals: List<Signal>):
      Then: native_sigprocmask_unblock(signals)

    When pending_signals() -> List<Signal>:
      Then: native_sigpending()

  Type SignalError:
    message: String

  # ==========================================================================
  # CTRL+C HANDLER
  # ==========================================================================

  Behavior CtrlC:
    When on_ctrl_c(handler: () -> ()):
      Then:
        SignalHandler.global().on(Signal.SIGINT, _ -> handler())

    When wait_for_ctrl_c():
      Then:
        stream = SignalStream.new(Signal.SIGINT)
        stream.recv()
        stream.close()

    When ctrl_c_stream() -> SignalStream:
      Then: SignalStream.new(Signal.SIGINT)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Signal":
    ```vibee
    # Start signal handler
    SignalHandler.global().start()

    # Handle specific signal
    sub = SignalHandler.global().on(Signal.SIGTERM, sig -> {
      print("Received ${sig.name()}")
      cleanup()
      exit(0)
    })

    # Handle Ctrl+C
    on_ctrl_c(() -> {
      print("Interrupted!")
      exit(1)
    })

    # Wait for Ctrl+C
    print("Press Ctrl+C to exit...")
    wait_for_ctrl_c()
    print("Goodbye!")

    # Signal stream
    stream = SignalStream.new(Signal.SIGUSR1)
    
    spawn {
      for signal in stream:
        print("Received ${signal.name()}")
        reload_config()
    }

    # Graceful shutdown
    shutdown = GracefulShutdown.with_timeout(Duration.seconds(30))

    # Register shutdown handlers
    shutdown.on_shutdown(ShutdownHandler(
      name: "close_database",
      priority: 100,
      handler: () -> {
        db.close()
      }
    ))

    shutdown.on_shutdown(ShutdownHandler(
      name: "stop_server",
      priority: 50,
      handler: () -> {
        server.stop()
      }
    ))

    shutdown.on_shutdown(ShutdownHandler(
      name: "flush_logs",
      priority: 10,
      handler: () -> {
        logger.flush()
      }
    ))

    # Start server
    server.start()

    # Wait for shutdown signal
    shutdown.wait()

    # Run handlers in priority order
    shutdown.run_handlers()?

    print("Shutdown complete")

    # Send signal to process
    kill(pid, Signal.SIGTERM)?

    # Send signal to process group
    killpg(pgid, Signal.SIGKILL)?

    # Raise signal in current process
    raise_signal(Signal.SIGUSR1)?

    # Set alarm
    old_alarm = alarm(30)  # SIGALRM in 30 seconds

    # Block signals temporarily
    block_signals([Signal.SIGINT, Signal.SIGTERM])
    
    # Critical section
    do_critical_work()
    
    unblock_signals([Signal.SIGINT, Signal.SIGTERM])

    # Wait for specific signals
    signal = sigwait([Signal.SIGUSR1, Signal.SIGUSR2])
    print("Received: ${signal.name()}")

    # Check pending signals
    pending = pending_signals()
    for sig in pending:
      print("Pending: ${sig.name()}")

    # Ignore signal
    SignalHandler.global().ignore(Signal.SIGPIPE)

    # Reset to default
    SignalHandler.global().reset(Signal.SIGINT)

    # Unsubscribe
    sub.unsubscribe()

    # Server with graceful shutdown
    fn main():
      shutdown = GracefulShutdown.new()
      
      server = HttpServer.new()
      
      shutdown.on_shutdown(ShutdownHandler(
        name: "http_server",
        priority: 100,
        handler: () -> {
          server.shutdown_gracefully(Duration.seconds(10))
        }
      ))
      
      spawn {
        server.listen(8080)
      }
      
      print("Server running on :8080")
      
      # Wait for SIGINT or SIGTERM
      shutdown.wait()
      
      print("Shutting down...")
      shutdown.run_handlers()?
      
      print("Bye!")
    ```
