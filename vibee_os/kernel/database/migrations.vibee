# ============================================================================
# MIGRATIONS - Миграции базы данных на Vibee
# ============================================================================
# Schema changes, versioning, rollbacks
# ============================================================================

Specification Migrations:
  """Миграции как спецификация эволюции схемы БД."""

  # ==========================================================================
  # CORE TYPES
  # ==========================================================================

  Type Migration:
    id: String
    name: String
    timestamp: Int
    batch: Int?
    up: () -> Promise<Void>
    down: () -> Promise<Void>

  Type MigrationRecord:
    id: Int
    migration: String
    batch: Int
    executed_at: DateTime

  Type MigrationStatus:
    variants:
      - Pending
      - Applied: (batch: Int, executed_at: DateTime)
      - Failed: (error: String)

  # ==========================================================================
  # MIGRATOR
  # ==========================================================================

  Behavior Migrator:
    When migrator.create(db, options):
      Then:
        - return Migrator(db, options)

    Type Migrator:
      db: Database
      options: MigratorOptions
      migrations_table: String = "migrations"

      Method init() -> Promise<Void>:
        # Create migrations table if not exists
        await db.execute("""
          CREATE TABLE IF NOT EXISTS ${migrations_table} (
            id SERIAL PRIMARY KEY,
            migration VARCHAR(255) NOT NULL UNIQUE,
            batch INT NOT NULL,
            executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          )
        """)

      Method get_migrations() -> List<Migration>:
        # Load all migration files
        files = await fs.glob(options.migrations_path + "/*.vibee")
        migrations = []
        
        for file in files.sort():
          migration = await load_migration(file)
          migrations.push(migration)
        
        return migrations

      Method get_applied() -> List<MigrationRecord>:
        return await db.query("""
          SELECT * FROM ${migrations_table} ORDER BY batch, id
        """)

      Method get_pending() -> List<Migration>:
        all_migrations = get_migrations()
        applied = await get_applied()
        applied_names = applied.map(m -> m.migration).to_set()
        
        return all_migrations.filter(m -> m.name not in applied_names)

      Method status() -> List<(Migration, MigrationStatus)>:
        all_migrations = get_migrations()
        applied = await get_applied()
        applied_map = applied.to_map(m -> (m.migration, m))
        
        return all_migrations.map(m -> {
          if m.name in applied_map:
            record = applied_map[m.name]
            (m, Applied(record.batch, record.executed_at))
          else:
            (m, Pending)
        })

      Method migrate(options: RunOptions = {}) -> MigrationResult:
        await init()
        pending = await get_pending()
        
        if pending.length == 0:
          return MigrationResult(applied: [], message: "Nothing to migrate")
        
        # Get next batch number
        batch = await get_next_batch()
        applied = []
        
        for migration in pending:
          if options.step and applied.length >= options.step:
            break
          
          log.info("Migrating: ${migration.name}")
          
          try:
            await db.transaction(async () -> {
              await migration.up()
              await record_migration(migration.name, batch)
            })
            applied.push(migration)
            log.info("Migrated: ${migration.name}")
          catch e:
            log.error("Migration failed: ${migration.name} - ${e.message}")
            throw MigrationError(migration.name, e)
        
        return MigrationResult(
          applied: applied,
          message: "Applied ${applied.length} migration(s)"
        )

      Method rollback(options: RollbackOptions = {}) -> MigrationResult:
        await init()
        
        # Get migrations to rollback
        batch = options.batch ?? await get_last_batch()
        to_rollback = await get_migrations_in_batch(batch)
        
        if options.step:
          to_rollback = to_rollback.take(options.step)
        
        rolled_back = []
        
        for migration in to_rollback.reverse():
          log.info("Rolling back: ${migration.name}")
          
          try:
            await db.transaction(async () -> {
              await migration.down()
              await remove_migration_record(migration.name)
            })
            rolled_back.push(migration)
            log.info("Rolled back: ${migration.name}")
          catch e:
            log.error("Rollback failed: ${migration.name} - ${e.message}")
            throw MigrationError(migration.name, e)
        
        return MigrationResult(
          applied: rolled_back,
          message: "Rolled back ${rolled_back.length} migration(s)"
        )

      Method reset() -> MigrationResult:
        await init()
        applied = await get_applied()
        
        # Rollback all in reverse order
        for record in applied.reverse():
          migration = find_migration(record.migration)
          if migration:
            await migration.down()
            await remove_migration_record(migration.name)
        
        return MigrationResult(
          applied: applied.map(r -> find_migration(r.migration)),
          message: "Reset ${applied.length} migration(s)"
        )

      Method refresh(options: RefreshOptions = {}) -> MigrationResult:
        await reset()
        result = await migrate()
        
        if options.seed:
          await run_seeders()
        
        return result

      Method fresh(options: FreshOptions = {}) -> MigrationResult:
        # Drop all tables
        await drop_all_tables()
        
        # Run all migrations
        result = await migrate()
        
        if options.seed:
          await run_seeders()
        
        return result

      Method get_next_batch() -> Int:
        result = await db.query_one("""
          SELECT COALESCE(MAX(batch), 0) + 1 as next_batch FROM ${migrations_table}
        """)
        return result.next_batch

      Method get_last_batch() -> Int:
        result = await db.query_one("""
          SELECT COALESCE(MAX(batch), 0) as last_batch FROM ${migrations_table}
        """)
        return result.last_batch

      Method record_migration(name: String, batch: Int):
        await db.execute("""
          INSERT INTO ${migrations_table} (migration, batch) VALUES ($1, $2)
        """, [name, batch])

      Method remove_migration_record(name: String):
        await db.execute("""
          DELETE FROM ${migrations_table} WHERE migration = $1
        """, [name])

    Type MigratorOptions:
      migrations_path: String = "./migrations"
      seeders_path: String = "./seeders"

    Type RunOptions:
      step: Int?
      pretend: Boolean = false

    Type RollbackOptions:
      step: Int?
      batch: Int?

    Type RefreshOptions:
      seed: Boolean = false

    Type FreshOptions:
      seed: Boolean = false

    Type MigrationResult:
      applied: List<Migration>
      message: String

  # ==========================================================================
  # SCHEMA BUILDER
  # ==========================================================================

  Behavior SchemaBuilder:
    When schema.create(table_name, callback):
      Then:
        - blueprint = Blueprint(table_name, Create)
        - callback(blueprint)
        - sql = blueprint.to_sql()
        - await db.execute(sql)

    When schema.table(table_name, callback):
      Then:
        - blueprint = Blueprint(table_name, Alter)
        - callback(blueprint)
        - sql = blueprint.to_sql()
        - await db.execute(sql)

    When schema.drop(table_name):
      Then:
        - await db.execute("DROP TABLE ${table_name}")

    When schema.drop_if_exists(table_name):
      Then:
        - await db.execute("DROP TABLE IF EXISTS ${table_name}")

    When schema.rename(from_name, to_name):
      Then:
        - await db.execute("ALTER TABLE ${from_name} RENAME TO ${to_name}")

    When schema.has_table(table_name) -> Boolean:
      Then:
        - result = await db.query_one("""
            SELECT EXISTS (
              SELECT FROM information_schema.tables 
              WHERE table_name = $1
            )
          """, [table_name])
        - return result.exists

    When schema.has_column(table_name, column_name) -> Boolean:
      Then:
        - result = await db.query_one("""
            SELECT EXISTS (
              SELECT FROM information_schema.columns 
              WHERE table_name = $1 AND column_name = $2
            )
          """, [table_name, column_name])
        - return result.exists

    Type Blueprint:
      table_name: String
      mode: BlueprintMode
      columns: List<ColumnDefinition> = []
      indexes: List<IndexDefinition> = []
      foreign_keys: List<ForeignKeyDefinition> = []
      commands: List<Command> = []

      # Column types
      Method id(name: String = "id") -> ColumnBuilder:
        return add_column(name, BigSerial).primary()

      Method uuid(name: String = "id") -> ColumnBuilder:
        return add_column(name, UUID).primary().default("gen_random_uuid()")

      Method string(name: String, length: Int = 255) -> ColumnBuilder:
        return add_column(name, Varchar(length))

      Method text(name: String) -> ColumnBuilder:
        return add_column(name, Text)

      Method integer(name: String) -> ColumnBuilder:
        return add_column(name, Integer)

      Method big_integer(name: String) -> ColumnBuilder:
        return add_column(name, BigInt)

      Method small_integer(name: String) -> ColumnBuilder:
        return add_column(name, SmallInt)

      Method float(name: String) -> ColumnBuilder:
        return add_column(name, Float)

      Method double(name: String) -> ColumnBuilder:
        return add_column(name, DoublePrecision)

      Method decimal(name: String, precision: Int = 8, scale: Int = 2) -> ColumnBuilder:
        return add_column(name, Decimal(precision, scale))

      Method boolean(name: String) -> ColumnBuilder:
        return add_column(name, Boolean)

      Method date(name: String) -> ColumnBuilder:
        return add_column(name, Date)

      Method datetime(name: String) -> ColumnBuilder:
        return add_column(name, Timestamp)

      Method timestamp(name: String) -> ColumnBuilder:
        return add_column(name, Timestamp)

      Method time(name: String) -> ColumnBuilder:
        return add_column(name, Time)

      Method json(name: String) -> ColumnBuilder:
        return add_column(name, JSON)

      Method jsonb(name: String) -> ColumnBuilder:
        return add_column(name, JSONB)

      Method binary(name: String) -> ColumnBuilder:
        return add_column(name, Bytea)

      Method enum(name: String, values: List<String>) -> ColumnBuilder:
        return add_column(name, Enum(values))

      Method array(name: String, type: ColumnType) -> ColumnBuilder:
        return add_column(name, Array(type))

      # Timestamps
      Method timestamps():
        datetime("created_at").default("CURRENT_TIMESTAMP")
        datetime("updated_at").default("CURRENT_TIMESTAMP")

      Method soft_deletes(name: String = "deleted_at"):
        datetime(name).nullable()

      # Foreign keys
      Method foreign_id(name: String) -> ForeignKeyBuilder:
        big_integer(name)
        return ForeignKeyBuilder(self, name)

      Method foreign_uuid(name: String) -> ForeignKeyBuilder:
        uuid(name)
        return ForeignKeyBuilder(self, name)

      # Indexes
      Method index(columns: List<String>, name: String?):
        indexes.push(IndexDefinition(
          name: name ?? generate_index_name(table_name, columns, "idx"),
          columns: columns,
          unique: false
        ))

      Method unique(columns: List<String>, name: String?):
        indexes.push(IndexDefinition(
          name: name ?? generate_index_name(table_name, columns, "unique"),
          columns: columns,
          unique: true
        ))

      Method primary(columns: List<String>):
        commands.push(AddPrimary(columns))

      # Alter table commands
      Method drop_column(name: String):
        commands.push(DropColumn(name))

      Method rename_column(from_name: String, to_name: String):
        commands.push(RenameColumn(from_name, to_name))

      Method drop_index(name: String):
        commands.push(DropIndex(name))

      Method drop_foreign(name: String):
        commands.push(DropForeign(name))

      Method drop_primary():
        commands.push(DropPrimary())

      # SQL generation
      Method to_sql() -> String:
        match mode:
          Create -> generate_create_sql()
          Alter -> generate_alter_sql()

      Method generate_create_sql() -> String:
        parts = []
        
        # Columns
        for col in columns:
          parts.push(col.to_sql())
        
        # Primary key
        primary_cols = columns.filter(c -> c.primary).map(c -> c.name)
        if primary_cols.length > 0:
          parts.push("PRIMARY KEY (${primary_cols.join(", ")})")
        
        # Foreign keys
        for fk in foreign_keys:
          parts.push(fk.to_sql())
        
        sql = "CREATE TABLE ${table_name} (\n  ${parts.join(",\n  ")}\n)"
        
        # Indexes (separate statements)
        for idx in indexes:
          sql += ";\n${idx.to_sql(table_name)}"
        
        return sql

    Type BlueprintMode:
      variants: [Create, Alter]

    Type ColumnDefinition:
      name: String
      type: ColumnType
      nullable: Boolean = false
      default: Any?
      primary: Boolean = false
      unique: Boolean = false
      references: Reference?
      check: String?
      comment: String?

      Method to_sql() -> String:
        parts = ["${name} ${type.to_sql()}"]
        
        if not nullable:
          parts.push("NOT NULL")
        
        if default != null:
          parts.push("DEFAULT ${format_default(default)}")
        
        if unique and not primary:
          parts.push("UNIQUE")
        
        if check:
          parts.push("CHECK (${check})")
        
        return parts.join(" ")

    Type ColumnBuilder:
      column: ColumnDefinition

      Method nullable() -> ColumnBuilder:
        column.nullable = true
        return self

      Method default(value: Any) -> ColumnBuilder:
        column.default = value
        return self

      Method primary() -> ColumnBuilder:
        column.primary = true
        return self

      Method unique() -> ColumnBuilder:
        column.unique = true
        return self

      Method references(table: String, column: String = "id") -> ColumnBuilder:
        column.references = Reference(table, column)
        return self

      Method on_delete(action: ReferenceAction) -> ColumnBuilder:
        column.references.on_delete = action
        return self

      Method on_update(action: ReferenceAction) -> ColumnBuilder:
        column.references.on_update = action
        return self

      Method check(expression: String) -> ColumnBuilder:
        column.check = expression
        return self

      Method comment(text: String) -> ColumnBuilder:
        column.comment = text
        return self

    Type ForeignKeyBuilder:
      blueprint: Blueprint
      column: String

      Method references(table: String, column: String = "id") -> ForeignKeyBuilder:
        blueprint.foreign_keys.push(ForeignKeyDefinition(
          column: self.column,
          references_table: table,
          references_column: column
        ))
        return self

      Method on_delete(action: ReferenceAction) -> ForeignKeyBuilder:
        blueprint.foreign_keys.last().on_delete = action
        return self

      Method on_update(action: ReferenceAction) -> ForeignKeyBuilder:
        blueprint.foreign_keys.last().on_update = action
        return self

    Type ColumnType:
      variants:
        - BigSerial
        - Serial
        - BigInt
        - Integer
        - SmallInt
        - Float
        - DoublePrecision
        - Decimal: (precision: Int, scale: Int)
        - Varchar: Int
        - Text
        - Boolean
        - Date
        - Time
        - Timestamp
        - UUID
        - JSON
        - JSONB
        - Bytea
        - Enum: List<String>
        - Array: ColumnType

      Method to_sql() -> String:
        match self:
          BigSerial -> "BIGSERIAL"
          Serial -> "SERIAL"
          BigInt -> "BIGINT"
          Integer -> "INTEGER"
          SmallInt -> "SMALLINT"
          Float -> "REAL"
          DoublePrecision -> "DOUBLE PRECISION"
          Decimal(p, s) -> "DECIMAL(${p}, ${s})"
          Varchar(n) -> "VARCHAR(${n})"
          Text -> "TEXT"
          Boolean -> "BOOLEAN"
          Date -> "DATE"
          Time -> "TIME"
          Timestamp -> "TIMESTAMP"
          UUID -> "UUID"
          JSON -> "JSON"
          JSONB -> "JSONB"
          Bytea -> "BYTEA"
          Enum(values) -> "VARCHAR(255) CHECK (${column} IN (${values.map(v -> "'${v}'").join(", ")}))"
          Array(t) -> "${t.to_sql()}[]"

  # ==========================================================================
  # SEEDERS
  # ==========================================================================

  Behavior Seeders:
    Type Seeder:
      name: String
      run: () -> Promise<Void>

    When seeder.run(seeders: List<Seeder>):
      Then:
        - for seeder in seeders:
            - log.info("Seeding: ${seeder.name}")
            - await seeder.run()
            - log.info("Seeded: ${seeder.name}")

    When seeder.factory(model, count):
      Then:
        - return Factory(model, count)

    Type Factory<T>:
      model: Model
      count: Int
      definition: () -> Map<String, Any>
      states: Map<String, () -> Map<String, Any>>

      Method define(fn: () -> Map<String, Any>) -> Factory<T>:
        definition = fn
        return self

      Method state(name: String, fn: () -> Map<String, Any>) -> Factory<T>:
        states[name] = fn
        return self

      Method create(overrides: Map<String, Any> = {}) -> Promise<List<T>>:
        records = []
        for i in 0..count:
          data = { ...definition(), ...overrides }
          record = await model.create(data)
          records.push(record)
        return records

      Method make(overrides: Map<String, Any> = {}) -> List<Map<String, Any>>:
        records = []
        for i in 0..count:
          data = { ...definition(), ...overrides }
          records.push(data)
        return records

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Migrations":
    ```vibee
    # Migration file: 2024_01_15_000001_create_users_table.vibee
    migration "create_users_table":
      up: async () -> {
        await schema.create("users", (table) -> {
          table.uuid("id")
          table.string("email").unique()
          table.string("name")
          table.string("password_hash")
          table.enum("role", ["admin", "user", "guest"]).default("user")
          table.boolean("active").default(true)
          table.jsonb("settings").nullable()
          table.timestamps()
          table.soft_deletes()
          
          table.index(["email"])
          table.index(["role", "active"])
        })
      }
      
      down: async () -> {
        await schema.drop("users")
      }

    # Migration file: 2024_01_15_000002_create_posts_table.vibee
    migration "create_posts_table":
      up: async () -> {
        await schema.create("posts", (table) -> {
          table.uuid("id")
          table.string("title")
          table.text("content")
          table.foreign_uuid("author_id").references("users").on_delete(Cascade)
          table.boolean("published").default(false)
          table.datetime("published_at").nullable()
          table.timestamps()
          
          table.index(["author_id"])
          table.index(["published", "published_at"])
        })
      }
      
      down: async () -> {
        await schema.drop("posts")
      }

    # Migration file: 2024_01_16_000001_add_views_to_posts.vibee
    migration "add_views_to_posts":
      up: async () -> {
        await schema.table("posts", (table) -> {
          table.integer("views").default(0)
        })
      }
      
      down: async () -> {
        await schema.table("posts", (table) -> {
          table.drop_column("views")
        })
      }

    # Seeder
    seeder "users":
      run: async () -> {
        # Create admin
        await User.create({
          email: "admin@example.com",
          name: "Admin",
          password: await bcrypt.hash("admin123"),
          role: "admin"
        })
        
        # Create test users with factory
        user_factory = seeder.factory(User, 50)
          .define(() -> {
            email: faker.email(),
            name: faker.name(),
            password: await bcrypt.hash("password"),
            role: "user"
          })
        
        await user_factory.create()
      }

    # CLI commands
    # vibee migrate              - Run pending migrations
    # vibee migrate:rollback     - Rollback last batch
    # vibee migrate:reset        - Rollback all migrations
    # vibee migrate:refresh      - Reset and re-run all migrations
    # vibee migrate:fresh        - Drop all tables and re-run migrations
    # vibee migrate:status       - Show migration status
    # vibee db:seed              - Run seeders

    # Programmatic usage
    migrator = migrator.create(db, {
      migrations_path: "./migrations"
    })

    # Check status
    status = await migrator.status()
    for (migration, state) in status:
      match state:
        Pending -> log.info("[ ] ${migration.name}")
        Applied(batch, at) -> log.info("[x] ${migration.name} (batch ${batch})")

    # Run migrations
    result = await migrator.migrate()
    log.info(result.message)

    # Rollback
    result = await migrator.rollback({ step: 1 })
    log.info(result.message)
    ```
