# ============================================================================
# ORM - Object-Relational Mapping на Vibee
# ============================================================================
# Models, queries, relations, transactions
# ============================================================================

Specification ORM:
  """ORM как спецификация работы с базой данных."""

  # ==========================================================================
  # MODEL DEFINITION
  # ==========================================================================

  Type Model:
    table_name: String
    primary_key: String = "id"
    fields: Map<String, FieldDefinition>
    relations: Map<String, Relation>
    indexes: List<Index>
    timestamps: Boolean = true
    soft_delete: Boolean = false

  Type FieldDefinition:
    name: String
    type: FieldType
    nullable: Boolean = false
    default: Any?
    unique: Boolean = false
    index: Boolean = false
    references: Reference?

  Type FieldType:
    variants:
      - String: (max_length: Int?)
      - Text
      - Int
      - BigInt
      - Float
      - Decimal: (precision: Int, scale: Int)
      - Boolean
      - Date
      - DateTime
      - Time
      - Timestamp
      - JSON
      - JSONB
      - UUID
      - Binary: (max_length: Int?)
      - Enum: List<String>
      - Array: FieldType

  Type Reference:
    table: String
    column: String
    on_delete: ReferenceAction = Restrict
    on_update: ReferenceAction = Cascade

  Type ReferenceAction:
    variants: [Cascade, Restrict, SetNull, SetDefault, NoAction]

  Type Index:
    name: String?
    columns: List<String>
    unique: Boolean = false
    type: IndexType = BTree

  Type IndexType:
    variants: [BTree, Hash, GIN, GiST, BRIN]

  # ==========================================================================
  # RELATIONS
  # ==========================================================================

  Type Relation:
    variants:
      - HasOne: HasOneRelation
      - HasMany: HasManyRelation
      - BelongsTo: BelongsToRelation
      - BelongsToMany: BelongsToManyRelation

  Type HasOneRelation:
    model: String
    foreign_key: String
    local_key: String = "id"

  Type HasManyRelation:
    model: String
    foreign_key: String
    local_key: String = "id"

  Type BelongsToRelation:
    model: String
    foreign_key: String
    owner_key: String = "id"

  Type BelongsToManyRelation:
    model: String
    pivot_table: String
    foreign_pivot_key: String
    related_pivot_key: String
    local_key: String = "id"
    related_key: String = "id"
    pivot_columns: List<String> = []

  # ==========================================================================
  # MODEL DECORATOR
  # ==========================================================================

  Behavior ModelDefinition:
    When @model(options):
      Then:
        - return ModelDecorator(options)

    When @field(type, options):
      Then:
        - return FieldDecorator(type, options)

    When @has_one(model, options):
      Then:
        - return RelationDecorator(HasOne, model, options)

    When @has_many(model, options):
      Then:
        - return RelationDecorator(HasMany, model, options)

    When @belongs_to(model, options):
      Then:
        - return RelationDecorator(BelongsTo, model, options)

    When @belongs_to_many(model, options):
      Then:
        - return RelationDecorator(BelongsToMany, model, options)

    When @index(columns, options):
      Then:
        - return IndexDecorator(columns, options)

  # ==========================================================================
  # BASE MODEL
  # ==========================================================================

  Behavior BaseModel:
    Type BaseModel<T>:
      _data: Map<String, Any>
      _original: Map<String, Any>
      _relations: Map<String, Any>
      _exists: Boolean = false

      # Attribute access
      Method get(key: String) -> Any:
        if key in _relations:
          return _relations[key]
        return _data[key]

      Method set(key: String, value: Any):
        _data[key] = value

      # Dirty checking
      Method is_dirty(key: String?) -> Boolean:
        if key:
          return _data[key] != _original[key]
        return _data != _original

      Method get_dirty() -> Map<String, Any>:
        dirty = {}
        for (key, value) in _data:
          if value != _original[key]:
            dirty[key] = value
        return dirty

      Method get_original(key: String?) -> Any:
        if key:
          return _original[key]
        return _original

      # Persistence
      Static Method create(data: Map<String, Any>) -> Promise<T>:
        instance = new T(data)
        await instance.save()
        return instance

      Method save() -> Promise<T>:
        if _exists:
          await update_record()
        else:
          await insert_record()
        _original = _data.clone()
        return self

      Method delete() -> Promise<Void>:
        if T.soft_delete:
          _data["deleted_at"] = now()
          await update_record()
        else:
          await delete_record()
        _exists = false

      Method refresh() -> Promise<T>:
        fresh = await T.find(_data[T.primary_key])
        _data = fresh._data
        _original = fresh._original
        return self

      Method replicate() -> T:
        clone = new T(_data)
        clone._data.delete(T.primary_key)
        clone._exists = false
        return clone

      # Relations
      Method load(...relations: String) -> Promise<T>:
        for relation in relations:
          _relations[relation] = await load_relation(self, relation)
        return self

      # Serialization
      Method to_json() -> Map<String, Any>:
        result = _data.clone()
        for (key, value) in _relations:
          result[key] = serialize_relation(value)
        return result

      Method to_array() -> Map<String, Any>:
        return to_json()

  # ==========================================================================
  # QUERY BUILDER
  # ==========================================================================

  Behavior QueryBuilder:
    Type QueryBuilder<T>:
      model: Model
      _select: List<String> = ["*"]
      _where: List<WhereClause> = []
      _order_by: List<OrderBy> = []
      _group_by: List<String> = []
      _having: List<WhereClause> = []
      _joins: List<Join> = []
      _limit: Int?
      _offset: Int?
      _with: List<String> = []
      _with_count: List<String> = []

      # Select
      Method select(...columns: String) -> QueryBuilder<T>:
        _select = columns
        return self

      Method select_raw(sql: String, bindings: List<Any>) -> QueryBuilder<T>:
        _select.push(Raw(sql, bindings))
        return self

      # Where
      Method where(column: String, operator: String, value: Any) -> QueryBuilder<T>:
        _where.push(Basic(column, operator, value))
        return self

      Method where(column: String, value: Any) -> QueryBuilder<T>:
        return where(column, "=", value)

      Method where(conditions: Map<String, Any>) -> QueryBuilder<T>:
        for (column, value) in conditions:
          where(column, "=", value)
        return self

      Method where_in(column: String, values: List<Any>) -> QueryBuilder<T>:
        _where.push(In(column, values, false))
        return self

      Method where_not_in(column: String, values: List<Any>) -> QueryBuilder<T>:
        _where.push(In(column, values, true))
        return self

      Method where_null(column: String) -> QueryBuilder<T>:
        _where.push(Null(column, false))
        return self

      Method where_not_null(column: String) -> QueryBuilder<T>:
        _where.push(Null(column, true))
        return self

      Method where_between(column: String, min: Any, max: Any) -> QueryBuilder<T>:
        _where.push(Between(column, min, max, false))
        return self

      Method where_like(column: String, pattern: String) -> QueryBuilder<T>:
        _where.push(Like(column, pattern))
        return self

      Method where_raw(sql: String, bindings: List<Any>) -> QueryBuilder<T>:
        _where.push(Raw(sql, bindings))
        return self

      Method or_where(column: String, operator: String, value: Any) -> QueryBuilder<T>:
        _where.push(Or(Basic(column, operator, value)))
        return self

      Method where_exists(subquery: QueryBuilder) -> QueryBuilder<T>:
        _where.push(Exists(subquery, false))
        return self

      Method where_has(relation: String, callback: (QueryBuilder) -> Void) -> QueryBuilder<T>:
        _where.push(HasRelation(relation, callback))
        return self

      # Order
      Method order_by(column: String, direction: String = "asc") -> QueryBuilder<T>:
        _order_by.push(OrderBy(column, direction))
        return self

      Method order_by_desc(column: String) -> QueryBuilder<T>:
        return order_by(column, "desc")

      Method latest(column: String = "created_at") -> QueryBuilder<T>:
        return order_by(column, "desc")

      Method oldest(column: String = "created_at") -> QueryBuilder<T>:
        return order_by(column, "asc")

      Method in_random_order() -> QueryBuilder<T>:
        _order_by.push(Random())
        return self

      # Group
      Method group_by(...columns: String) -> QueryBuilder<T>:
        _group_by = columns
        return self

      Method having(column: String, operator: String, value: Any) -> QueryBuilder<T>:
        _having.push(Basic(column, operator, value))
        return self

      # Joins
      Method join(table: String, first: String, operator: String, second: String) -> QueryBuilder<T>:
        _joins.push(Join(Inner, table, first, operator, second))
        return self

      Method left_join(table: String, first: String, operator: String, second: String) -> QueryBuilder<T>:
        _joins.push(Join(Left, table, first, operator, second))
        return self

      Method right_join(table: String, first: String, operator: String, second: String) -> QueryBuilder<T>:
        _joins.push(Join(Right, table, first, operator, second))
        return self

      # Limit & Offset
      Method limit(count: Int) -> QueryBuilder<T>:
        _limit = count
        return self

      Method offset(count: Int) -> QueryBuilder<T>:
        _offset = count
        return self

      Method skip(count: Int) -> QueryBuilder<T>:
        return offset(count)

      Method take(count: Int) -> QueryBuilder<T>:
        return limit(count)

      # Eager Loading
      Method with(...relations: String) -> QueryBuilder<T>:
        _with = relations
        return self

      Method with_count(...relations: String) -> QueryBuilder<T>:
        _with_count = relations
        return self

      # Execution
      Method get() -> Promise<List<T>>:
        sql = build_select_sql()
        rows = await execute(sql)
        models = rows.map(row -> hydrate(row))
        
        if _with.length > 0:
          await eager_load(models, _with)
        
        return models

      Method first() -> Promise<T?>:
        _limit = 1
        results = await get()
        return results[0] ?? null

      Method first_or_fail() -> Promise<T>:
        result = await first()
        if result == null:
          throw ModelNotFoundError(model.name)
        return result

      Method find(id: Any) -> Promise<T?>:
        return where(model.primary_key, id).first()

      Method find_or_fail(id: Any) -> Promise<T>:
        result = await find(id)
        if result == null:
          throw ModelNotFoundError(model.name, id)
        return result

      Method find_many(ids: List<Any>) -> Promise<List<T>>:
        return where_in(model.primary_key, ids).get()

      Method exists() -> Promise<Boolean>:
        return (await count()) > 0

      Method count(column: String = "*") -> Promise<Int>:
        return await aggregate("COUNT", column)

      Method sum(column: String) -> Promise<Float>:
        return await aggregate("SUM", column)

      Method avg(column: String) -> Promise<Float>:
        return await aggregate("AVG", column)

      Method min(column: String) -> Promise<Any>:
        return await aggregate("MIN", column)

      Method max(column: String) -> Promise<Any>:
        return await aggregate("MAX", column)

      Method pluck(column: String) -> Promise<List<Any>>:
        _select = [column]
        rows = await get()
        return rows.map(r -> r[column])

      Method value(column: String) -> Promise<Any?>:
        _select = [column]
        row = await first()
        return row?[column]

      # Pagination
      Method paginate(page: Int, per_page: Int = 15) -> Promise<Paginator<T>>:
        total = await count()
        _offset = (page - 1) * per_page
        _limit = per_page
        items = await get()
        
        return Paginator(
          items: items,
          total: total,
          per_page: per_page,
          current_page: page,
          last_page: ceil(total / per_page)
        )

      Method cursor_paginate(cursor: String?, per_page: Int = 15) -> Promise<CursorPaginator<T>>:
        if cursor:
          decoded = decode_cursor(cursor)
          where(model.primary_key, ">", decoded.id)
        
        _limit = per_page + 1
        items = await get()
        
        has_more = items.length > per_page
        if has_more:
          items = items.take(per_page)
        
        next_cursor = if has_more then
          encode_cursor(items.last())
        else
          null
        
        return CursorPaginator(
          items: items,
          next_cursor: next_cursor,
          has_more: has_more
        )

      # Mutations
      Method insert(data: Map<String, Any>) -> Promise<T>:
        if model.timestamps:
          data["created_at"] = now()
          data["updated_at"] = now()
        
        sql = build_insert_sql(data)
        result = await execute(sql)
        
        instance = hydrate(data)
        instance._data[model.primary_key] = result.insert_id
        instance._exists = true
        return instance

      Method insert_many(records: List<Map<String, Any>>) -> Promise<Int>:
        if model.timestamps:
          timestamp = now()
          records = records.map(r -> {
            ...r,
            created_at: timestamp,
            updated_at: timestamp
          })
        
        sql = build_bulk_insert_sql(records)
        result = await execute(sql)
        return result.affected_rows

      Method update(data: Map<String, Any>) -> Promise<Int>:
        if model.timestamps:
          data["updated_at"] = now()
        
        sql = build_update_sql(data)
        result = await execute(sql)
        return result.affected_rows

      Method delete() -> Promise<Int>:
        if model.soft_delete:
          return await update({ deleted_at: now() })
        
        sql = build_delete_sql()
        result = await execute(sql)
        return result.affected_rows

      Method force_delete() -> Promise<Int>:
        sql = build_delete_sql()
        result = await execute(sql)
        return result.affected_rows

      Method restore() -> Promise<Int>:
        return await update({ deleted_at: null })

      # Soft Delete Scopes
      Method with_trashed() -> QueryBuilder<T>:
        # Include soft deleted records
        return self

      Method only_trashed() -> QueryBuilder<T>:
        return where_not_null("deleted_at")

      # Upsert
      Method upsert(data: Map<String, Any>, unique_by: List<String>, update: List<String>?) -> Promise<T>:
        sql = build_upsert_sql(data, unique_by, update)
        await execute(sql)
        return await where(unique_by.map(k -> (k, data[k]))).first()

      Method update_or_create(attributes: Map<String, Any>, values: Map<String, Any>) -> Promise<T>:
        instance = await where(attributes).first()
        if instance:
          instance._data = { ...instance._data, ...values }
          await instance.save()
          return instance
        else:
          return await insert({ ...attributes, ...values })

      Method first_or_create(attributes: Map<String, Any>, values: Map<String, Any> = {}) -> Promise<T>:
        instance = await where(attributes).first()
        if instance:
          return instance
        return await insert({ ...attributes, ...values })

    Type WhereClause:
      variants:
        - Basic: (column: String, operator: String, value: Any)
        - In: (column: String, values: List<Any>, not: Boolean)
        - Null: (column: String, not: Boolean)
        - Between: (column: String, min: Any, max: Any, not: Boolean)
        - Like: (column: String, pattern: String)
        - Raw: (sql: String, bindings: List<Any>)
        - Or: WhereClause
        - Exists: (subquery: QueryBuilder, not: Boolean)
        - HasRelation: (relation: String, callback: (QueryBuilder) -> Void)

    Type Join:
      type: JoinType
      table: String
      first: String
      operator: String
      second: String

    Type JoinType:
      variants: [Inner, Left, Right, Cross]

    Type OrderBy:
      variants:
        - Column: (column: String, direction: String)
        - Random

  # ==========================================================================
  # TRANSACTIONS
  # ==========================================================================

  Behavior Transactions:
    When db.transaction(callback):
      Then:
        - await db.begin_transaction()
        - try:
            - result = await callback()
            - await db.commit()
            - return result
          catch e:
            - await db.rollback()
            - throw e

    When db.begin_transaction():
      Then:
        - await execute("BEGIN")

    When db.commit():
      Then:
        - await execute("COMMIT")

    When db.rollback():
      Then:
        - await execute("ROLLBACK")

    When db.savepoint(name):
      Then:
        - await execute("SAVEPOINT ${name}")

    When db.rollback_to(name):
      Then:
        - await execute("ROLLBACK TO SAVEPOINT ${name}")

  # ==========================================================================
  # SCOPES
  # ==========================================================================

  Behavior Scopes:
    When @scope(name, fn):
      Then:
        - model.scopes[name] = fn

    # Global scopes
    When @global_scope(name, fn):
      Then:
        - model.global_scopes[name] = fn

    # Usage in query
    When query.apply_scope(name, ...args):
      Then:
        - scope_fn = model.scopes[name]
        - scope_fn(self, ...args)
        - return self

  # ==========================================================================
  # EVENTS
  # ==========================================================================

  Behavior ModelEvents:
    When @before_create(fn):
      Then:
        - model.events["creating"].push(fn)

    When @after_create(fn):
      Then:
        - model.events["created"].push(fn)

    When @before_update(fn):
      Then:
        - model.events["updating"].push(fn)

    When @after_update(fn):
      Then:
        - model.events["updated"].push(fn)

    When @before_delete(fn):
      Then:
        - model.events["deleting"].push(fn)

    When @after_delete(fn):
      Then:
        - model.events["deleted"].push(fn)

    When @before_save(fn):
      Then:
        - model.events["saving"].push(fn)

    When @after_save(fn):
      Then:
        - model.events["saved"].push(fn)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "ORM Usage":
    ```vibee
    # Model definition
    @model(table: "users")
    class User extends BaseModel:
      @field(UUID, primary_key: true)
      id: UUID

      @field(String(255), unique: true)
      email: String

      @field(String(255))
      name: String

      @field(String(255))
      password_hash: String

      @field(Enum(["admin", "user", "guest"]), default: "user")
      role: String

      @field(Boolean, default: true)
      active: Boolean

      @field(JSONB, nullable: true)
      settings: Map<String, Any>?

      @has_many(Post, foreign_key: "author_id")
      posts: List<Post>

      @has_one(Profile, foreign_key: "user_id")
      profile: Profile?

      @belongs_to_many(Role, pivot_table: "user_roles")
      roles: List<Role>

      # Scopes
      @scope("active")
      static active(query):
        query.where("active", true)

      @scope("admins")
      static admins(query):
        query.where("role", "admin")

      # Events
      @before_create
      static async hash_password(user):
        if user.password:
          user.password_hash = await bcrypt.hash(user.password)

      # Custom methods
      Method has_role(role: String) -> Boolean:
        return self.roles.any(r -> r.name == role)

    @model(table: "posts")
    class Post extends BaseModel:
      @field(UUID, primary_key: true)
      id: UUID

      @field(String(255))
      title: String

      @field(Text)
      content: String

      @field(UUID)
      author_id: UUID

      @field(Boolean, default: false)
      published: Boolean

      @field(DateTime, nullable: true)
      published_at: DateTime?

      @belongs_to(User, foreign_key: "author_id")
      author: User

      @has_many(Comment, foreign_key: "post_id")
      comments: List<Comment>

      @belongs_to_many(Tag, pivot_table: "post_tags")
      tags: List<Tag>

      @index(["author_id", "published"])
      @index(["created_at"], type: BRIN)

      @scope("published")
      static published(query):
        query.where("published", true)
          .where_not_null("published_at")

    # Queries
    users = await User.query()
      .where("active", true)
      .where("role", "admin")
      .order_by("created_at", "desc")
      .limit(10)
      .get()

    # With relations
    user = await User.query()
      .with("posts", "profile", "roles")
      .find(user_id)

    # Complex query
    posts = await Post.query()
      .select("posts.*", "users.name as author_name")
      .join("users", "posts.author_id", "=", "users.id")
      .where("posts.published", true)
      .where_has("tags", (q) -> q.where("name", "vibee"))
      .order_by("posts.published_at", "desc")
      .paginate(1, 20)

    # Create
    user = await User.create({
      email: "user@example.com",
      name: "John Doe",
      password: "secret123"
    })

    # Update
    user.name = "Jane Doe"
    await user.save()

    # Or bulk update
    await User.query()
      .where("last_login", "<", 30.days.ago)
      .update({ active: false })

    # Delete
    await user.delete()

    # Transaction
    await db.transaction(async () -> {
      user = await User.create({ email: "new@example.com", name: "New User" })
      await Post.create({ title: "First Post", author_id: user.id })
      await Profile.create({ user_id: user.id, bio: "Hello!" })
    })

    # Scopes
    active_admins = await User.query()
      .active()
      .admins()
      .get()

    # Aggregations
    total_users = await User.query().count()
    avg_posts = await Post.query().where("published", true).avg("views")

    # Upsert
    user = await User.query().upsert(
      { email: "user@example.com", name: "Updated Name" },
      unique_by: ["email"],
      update: ["name"]
    )
    ```
