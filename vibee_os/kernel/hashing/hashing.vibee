# ============================================================================
# HASHING - Хеширование на Vibee
# ============================================================================
# MD5, SHA, BLAKE, HMAC, KDF
# ============================================================================

Specification Hashing:
  """Хеширование как спецификация преобразования данных в фиксированный дайджест."""

  # ==========================================================================
  # MD5 (legacy, not secure)
  # ==========================================================================

  Behavior MD5:
    When md5(data: Bytes) -> Hash:
      Then: Hash(native_md5(data), HashAlgorithm.MD5)

    When md5.string(input: String) -> Hash:
      Then: md5(input.to_bytes())

    When md5.file(path: Path) -> Result<Hash, IOError>:
      Then:
        hasher = MD5Hasher.new()
        for chunk in File.read_stream(path):
          hasher.update(chunk)
        return Ok(hasher.finalize())

  Type MD5Hasher:
    state: MD5State

    Static Method new() -> MD5Hasher:
      return MD5Hasher(init_md5_state())

    Method update(data: Bytes) -> MD5Hasher:
      update_md5_state(self.state, data)
      return self

    Method finalize() -> Hash:
      return Hash(finalize_md5_state(self.state), HashAlgorithm.MD5)

  # ==========================================================================
  # SHA-1 (legacy, not secure)
  # ==========================================================================

  Behavior SHA1:
    When sha1(data: Bytes) -> Hash:
      Then: Hash(native_sha1(data), HashAlgorithm.SHA1)

    When sha1.string(input: String) -> Hash:
      Then: sha1(input.to_bytes())

  Type SHA1Hasher:
    state: SHA1State

    Static Method new() -> SHA1Hasher:
      return SHA1Hasher(init_sha1_state())

    Method update(data: Bytes) -> SHA1Hasher:
      update_sha1_state(self.state, data)
      return self

    Method finalize() -> Hash:
      return Hash(finalize_sha1_state(self.state), HashAlgorithm.SHA1)

  # ==========================================================================
  # SHA-2 FAMILY
  # ==========================================================================

  Behavior SHA256:
    When sha256(data: Bytes) -> Hash:
      Then: Hash(native_sha256(data), HashAlgorithm.SHA256)

    When sha256.string(input: String) -> Hash:
      Then: sha256(input.to_bytes())

    When sha256.file(path: Path) -> Result<Hash, IOError>:
      Then:
        hasher = SHA256Hasher.new()
        for chunk in File.read_stream(path):
          hasher.update(chunk)
        return Ok(hasher.finalize())

  Type SHA256Hasher:
    state: SHA256State

    Static Method new() -> SHA256Hasher:
      return SHA256Hasher(init_sha256_state())

    Method update(data: Bytes) -> SHA256Hasher:
      update_sha256_state(self.state, data)
      return self

    Method finalize() -> Hash:
      return Hash(finalize_sha256_state(self.state), HashAlgorithm.SHA256)

  Behavior SHA384:
    When sha384(data: Bytes) -> Hash:
      Then: Hash(native_sha384(data), HashAlgorithm.SHA384)

    When sha384.string(input: String) -> Hash:
      Then: sha384(input.to_bytes())

  Behavior SHA512:
    When sha512(data: Bytes) -> Hash:
      Then: Hash(native_sha512(data), HashAlgorithm.SHA512)

    When sha512.string(input: String) -> Hash:
      Then: sha512(input.to_bytes())

    When sha512.file(path: Path) -> Result<Hash, IOError>:
      Then:
        hasher = SHA512Hasher.new()
        for chunk in File.read_stream(path):
          hasher.update(chunk)
        return Ok(hasher.finalize())

  Type SHA512Hasher:
    state: SHA512State

    Static Method new() -> SHA512Hasher:
      return SHA512Hasher(init_sha512_state())

    Method update(data: Bytes) -> SHA512Hasher:
      update_sha512_state(self.state, data)
      return self

    Method finalize() -> Hash:
      return Hash(finalize_sha512_state(self.state), HashAlgorithm.SHA512)

  # ==========================================================================
  # SHA-3 FAMILY
  # ==========================================================================

  Behavior SHA3_256:
    When sha3_256(data: Bytes) -> Hash:
      Then: Hash(native_sha3_256(data), HashAlgorithm.SHA3_256)

    When sha3_256.string(input: String) -> Hash:
      Then: sha3_256(input.to_bytes())

  Behavior SHA3_512:
    When sha3_512(data: Bytes) -> Hash:
      Then: Hash(native_sha3_512(data), HashAlgorithm.SHA3_512)

    When sha3_512.string(input: String) -> Hash:
      Then: sha3_512(input.to_bytes())

  Behavior Keccak256:
    When keccak256(data: Bytes) -> Hash:
      Then: Hash(native_keccak256(data), HashAlgorithm.Keccak256)

    When keccak256.string(input: String) -> Hash:
      Then: keccak256(input.to_bytes())

  # ==========================================================================
  # BLAKE FAMILY
  # ==========================================================================

  Behavior BLAKE2b:
    When blake2b(data: Bytes) -> Hash:
      Then: blake2b.sized(data, 64)  # 512 bits default

    When blake2b.sized(data: Bytes, output_size: Int) -> Hash:
      Then: Hash(native_blake2b(data, output_size), HashAlgorithm.BLAKE2b)

    When blake2b.keyed(data: Bytes, key: Bytes) -> Hash:
      Then: Hash(native_blake2b_keyed(data, key, 64), HashAlgorithm.BLAKE2b)

    When blake2b.string(input: String) -> Hash:
      Then: blake2b(input.to_bytes())

  Type BLAKE2bHasher:
    state: BLAKE2bState

    Static Method new() -> BLAKE2bHasher:
      return BLAKE2bHasher.with_size(64)

    Static Method with_size(output_size: Int) -> BLAKE2bHasher:
      return BLAKE2bHasher(init_blake2b_state(output_size, null))

    Static Method with_key(key: Bytes) -> BLAKE2bHasher:
      return BLAKE2bHasher(init_blake2b_state(64, key))

    Method update(data: Bytes) -> BLAKE2bHasher:
      update_blake2b_state(self.state, data)
      return self

    Method finalize() -> Hash:
      return Hash(finalize_blake2b_state(self.state), HashAlgorithm.BLAKE2b)

  Behavior BLAKE2s:
    When blake2s(data: Bytes) -> Hash:
      Then: blake2s.sized(data, 32)  # 256 bits default

    When blake2s.sized(data: Bytes, output_size: Int) -> Hash:
      Then: Hash(native_blake2s(data, output_size), HashAlgorithm.BLAKE2s)

    When blake2s.string(input: String) -> Hash:
      Then: blake2s(input.to_bytes())

  Behavior BLAKE3:
    When blake3(data: Bytes) -> Hash:
      Then: Hash(native_blake3(data), HashAlgorithm.BLAKE3)

    When blake3.string(input: String) -> Hash:
      Then: blake3(input.to_bytes())

    When blake3.keyed(data: Bytes, key: Bytes) -> Hash:
      Then:
        if key.length != 32:
          panic("BLAKE3 key must be 32 bytes")
        Hash(native_blake3_keyed(data, key), HashAlgorithm.BLAKE3)

    When blake3.derive_key(context: String, key_material: Bytes) -> Bytes:
      Then: native_blake3_derive_key(context, key_material)

    When blake3.file(path: Path) -> Result<Hash, IOError>:
      Then:
        hasher = BLAKE3Hasher.new()
        for chunk in File.read_stream(path):
          hasher.update(chunk)
        return Ok(hasher.finalize())

  Type BLAKE3Hasher:
    state: BLAKE3State

    Static Method new() -> BLAKE3Hasher:
      return BLAKE3Hasher(init_blake3_state())

    Static Method keyed(key: Bytes) -> BLAKE3Hasher:
      return BLAKE3Hasher(init_blake3_keyed_state(key))

    Method update(data: Bytes) -> BLAKE3Hasher:
      update_blake3_state(self.state, data)
      return self

    Method finalize() -> Hash:
      return Hash(finalize_blake3_state(self.state), HashAlgorithm.BLAKE3)

    Method finalize_xof(length: Int) -> Bytes:
      # Extendable output
      return finalize_blake3_xof(self.state, length)

  # ==========================================================================
  # HASH TYPE
  # ==========================================================================

  Type Hash:
    bytes: Bytes
    algorithm: HashAlgorithm

    Method to_hex() -> String:
      return self.bytes.to_hex()

    Method to_base64() -> String:
      return base64.encode(self.bytes)

    Method to_bytes() -> Bytes:
      return self.bytes

    Method verify(data: Bytes) -> Boolean:
      expected = hash_with_algorithm(data, self.algorithm)
      return constant_time_compare(self.bytes, expected.bytes)

    Method == (other: Hash) -> Boolean:
      return constant_time_compare(self.bytes, other.bytes)

  Type HashAlgorithm:
    variants:
      - MD5
      - SHA1
      - SHA256
      - SHA384
      - SHA512
      - SHA3_256
      - SHA3_512
      - Keccak256
      - BLAKE2b
      - BLAKE2s
      - BLAKE3

    Method output_size() -> Int:
      match self:
        MD5 -> 16
        SHA1 -> 20
        SHA256 -> 32
        SHA384 -> 48
        SHA512 -> 64
        SHA3_256 -> 32
        SHA3_512 -> 64
        Keccak256 -> 32
        BLAKE2b -> 64
        BLAKE2s -> 32
        BLAKE3 -> 32

  # ==========================================================================
  # HMAC
  # ==========================================================================

  Behavior HMAC:
    When hmac(algorithm: HashAlgorithm, key: Bytes, data: Bytes) -> Hash:
      Then:
        block_size = get_block_size(algorithm)
        
        # Normalize key
        k = if key.length > block_size:
          hash_with_algorithm(key, algorithm).bytes
        else:
          key
        
        k = k.pad_end(block_size, 0x00)
        
        # Inner and outer padding
        ipad = k.map(b -> b ^ 0x36)
        opad = k.map(b -> b ^ 0x5C)
        
        # HMAC = H(opad || H(ipad || message))
        inner = hash_with_algorithm(ipad + data, algorithm)
        outer = hash_with_algorithm(opad + inner.bytes, algorithm)
        
        return outer

    When hmac_sha256(key: Bytes, data: Bytes) -> Hash:
      Then: hmac(HashAlgorithm.SHA256, key, data)

    When hmac_sha512(key: Bytes, data: Bytes) -> Hash:
      Then: hmac(HashAlgorithm.SHA512, key, data)

    When hmac_blake3(key: Bytes, data: Bytes) -> Hash:
      Then: blake3.keyed(data, key)

  # ==========================================================================
  # KEY DERIVATION FUNCTIONS
  # ==========================================================================

  Behavior PBKDF2:
    When pbkdf2(password: Bytes, salt: Bytes, iterations: Int, key_length: Int) -> Bytes:
      Then: pbkdf2.sha256(password, salt, iterations, key_length)

    When pbkdf2.sha256(password: Bytes, salt: Bytes, iterations: Int, key_length: Int) -> Bytes:
      Then: native_pbkdf2(password, salt, iterations, key_length, HashAlgorithm.SHA256)

    When pbkdf2.sha512(password: Bytes, salt: Bytes, iterations: Int, key_length: Int) -> Bytes:
      Then: native_pbkdf2(password, salt, iterations, key_length, HashAlgorithm.SHA512)

  Behavior HKDF:
    When hkdf(algorithm: HashAlgorithm, ikm: Bytes, salt: Bytes, info: Bytes, length: Int) -> Bytes:
      Then:
        # Extract
        prk = if salt.length > 0:
          hmac(algorithm, salt, ikm).bytes
        else:
          hmac(algorithm, Bytes(algorithm.output_size()), ikm).bytes
        
        # Expand
        hash_len = algorithm.output_size()
        n = (length + hash_len - 1) / hash_len
        
        okm = ByteBuffer()
        t = Bytes([])
        
        for i in 1..=n:
          t = hmac(algorithm, prk, t + info + Bytes([i])).bytes
          okm.write_bytes(t)
        
        return okm.to_bytes().slice(0, length)

    When hkdf_sha256(ikm: Bytes, salt: Bytes, info: Bytes, length: Int) -> Bytes:
      Then: hkdf(HashAlgorithm.SHA256, ikm, salt, info, length)

  Behavior Scrypt:
    When scrypt(password: Bytes, salt: Bytes, params: ScryptParams) -> Bytes:
      Then: native_scrypt(password, salt, params.n, params.r, params.p, params.key_length)

    Type ScryptParams:
      n: Int       # CPU/memory cost (power of 2)
      r: Int       # Block size
      p: Int       # Parallelization
      key_length: Int

      Static Method default() -> ScryptParams:
        return ScryptParams(n: 16384, r: 8, p: 1, key_length: 32)

      Static Method interactive() -> ScryptParams:
        return ScryptParams(n: 16384, r: 8, p: 1, key_length: 32)

      Static Method sensitive() -> ScryptParams:
        return ScryptParams(n: 1048576, r: 8, p: 1, key_length: 32)

  Behavior Argon2:
    When argon2id(password: Bytes, salt: Bytes, params: Argon2Params) -> Bytes:
      Then: native_argon2id(password, salt, params)

    When argon2i(password: Bytes, salt: Bytes, params: Argon2Params) -> Bytes:
      Then: native_argon2i(password, salt, params)

    When argon2d(password: Bytes, salt: Bytes, params: Argon2Params) -> Bytes:
      Then: native_argon2d(password, salt, params)

    Type Argon2Params:
      memory_cost: Int    # Memory in KiB
      time_cost: Int      # Iterations
      parallelism: Int    # Threads
      key_length: Int

      Static Method default() -> Argon2Params:
        return Argon2Params(
          memory_cost: 65536,  # 64 MiB
          time_cost: 3,
          parallelism: 4,
          key_length: 32
        )

      Static Method interactive() -> Argon2Params:
        return Argon2Params(
          memory_cost: 65536,
          time_cost: 2,
          parallelism: 1,
          key_length: 32
        )

      Static Method moderate() -> Argon2Params:
        return Argon2Params(
          memory_cost: 262144,  # 256 MiB
          time_cost: 3,
          parallelism: 1,
          key_length: 32
        )

      Static Method sensitive() -> Argon2Params:
        return Argon2Params(
          memory_cost: 1048576,  # 1 GiB
          time_cost: 4,
          parallelism: 1,
          key_length: 32
        )

  # ==========================================================================
  # PASSWORD HASHING
  # ==========================================================================

  Behavior PasswordHash:
    When password.hash(password: String) -> String:
      Then: password.hash_argon2id(password, Argon2Params.default())

    When password.hash_argon2id(password: String, params: Argon2Params) -> String:
      Then:
        salt = random.bytes(16)
        hash = argon2id(password.to_bytes(), salt, params)
        
        # PHC string format
        return "$argon2id$v=19$m=${params.memory_cost},t=${params.time_cost},p=${params.parallelism}$${base64.encode_no_padding(salt)}$${base64.encode_no_padding(hash)}"

    When password.verify(password: String, hash: String) -> Boolean:
      Then:
        parsed = parse_phc_string(hash)?
        
        computed = match parsed.algorithm:
          "argon2id" -> argon2id(password.to_bytes(), parsed.salt, parsed.params)
          "argon2i" -> argon2i(password.to_bytes(), parsed.salt, parsed.params)
          "argon2d" -> argon2d(password.to_bytes(), parsed.salt, parsed.params)
          "scrypt" -> scrypt(password.to_bytes(), parsed.salt, parsed.params)
          _ -> return false
        
        return constant_time_compare(computed, parsed.hash)

    When password.needs_rehash(hash: String, params: Argon2Params) -> Boolean:
      Then:
        parsed = parse_phc_string(hash)?
        
        return parsed.params.memory_cost < params.memory_cost or
               parsed.params.time_cost < params.time_cost

  # ==========================================================================
  # UTILITIES
  # ==========================================================================

  Behavior HashUtils:
    When constant_time_compare(a: Bytes, b: Bytes) -> Boolean:
      Then:
        if a.length != b.length:
          return false
        
        result = 0
        for i in 0..a.length:
          result = result | (a[i] ^ b[i])
        
        return result == 0

    When hash_with_algorithm(data: Bytes, algorithm: HashAlgorithm) -> Hash:
      Then:
        match algorithm:
          MD5 -> md5(data)
          SHA1 -> sha1(data)
          SHA256 -> sha256(data)
          SHA384 -> sha384(data)
          SHA512 -> sha512(data)
          SHA3_256 -> sha3_256(data)
          SHA3_512 -> sha3_512(data)
          Keccak256 -> keccak256(data)
          BLAKE2b -> blake2b(data)
          BLAKE2s -> blake2s(data)
          BLAKE3 -> blake3(data)

  Extension String:
    Method sha256() -> Hash:
      return sha256.string(self)

    Method sha512() -> Hash:
      return sha512.string(self)

    Method blake3() -> Hash:
      return blake3.string(self)

    Method md5() -> Hash:
      return md5.string(self)

  Extension Bytes:
    Method sha256() -> Hash:
      return sha256(self)

    Method sha512() -> Hash:
      return sha512(self)

    Method blake3() -> Hash:
      return blake3(self)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Hashing":
    ```vibee
    data = "Hello, World!".to_bytes()

    # Basic hashing
    hash = sha256(data)
    print(hash.to_hex())  # "dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f"

    # String shorthand
    hash = "Hello".sha256()
    hash = "Hello".blake3()

    # File hashing
    hash = sha256.file("large_file.bin")?
    print("SHA256: ${hash.to_hex()}")

    # Streaming hash
    hasher = SHA256Hasher.new()
    for chunk in file.read_stream():
      hasher.update(chunk)
    hash = hasher.finalize()

    # BLAKE3 (fastest, recommended)
    hash = blake3(data)
    
    # Keyed hash (MAC)
    key = random.bytes(32)
    mac = blake3.keyed(data, key)

    # HMAC
    mac = hmac_sha256(key, data)
    
    # Verify
    is_valid = mac.verify(data)

    # Password hashing (Argon2id recommended)
    password = "my_secure_password"
    hash = password.hash(password)
    # "$argon2id$v=19$m=65536,t=3,p=4$..."

    is_valid = password.verify(password, hash)  # true
    is_valid = password.verify("wrong", hash)   # false

    # Check if rehash needed
    if password.needs_rehash(hash, Argon2Params.sensitive()):
      new_hash = password.hash_argon2id(password, Argon2Params.sensitive())

    # Key derivation
    master_key = random.bytes(32)
    salt = random.bytes(16)
    
    # HKDF for key expansion
    derived = hkdf_sha256(master_key, salt, "encryption".to_bytes(), 32)

    # PBKDF2 for password-based keys
    key = pbkdf2.sha256(password.to_bytes(), salt, 100000, 32)

    # Scrypt
    key = scrypt(password.to_bytes(), salt, ScryptParams.sensitive())

    # Argon2 (recommended for passwords)
    key = argon2id(password.to_bytes(), salt, Argon2Params.default())

    # Compare hashes securely
    is_equal = constant_time_compare(hash1.bytes, hash2.bytes)
    ```
