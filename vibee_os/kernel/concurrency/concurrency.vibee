# ============================================================================
# CONCURRENCY - Примитивы конкурентности на Vibee
# ============================================================================
# Async/await, channels, mutexes, semaphores, actors
# ============================================================================

Specification Concurrency:
  """Конкурентность как спецификация параллельного выполнения."""

  # ==========================================================================
  # PROMISES
  # ==========================================================================

  Type Promise<T>:
    state: PromiseState<T>

    Static Method resolve<T>(value: T) -> Promise<T>:
      return Promise(Fulfilled(value))

    Static Method reject<T>(error: Error) -> Promise<T>:
      return Promise(Rejected(error))

    Static Method all<T>(promises: List<Promise<T>>) -> Promise<List<T>>:
      return Promise((resolve, reject) -> {
        results = []
        remaining = promises.length
        
        if remaining == 0:
          resolve([])
          return
        
        for (i, promise) in promises.enumerate():
          promise.then(
            (value) -> {
              results[i] = value
              remaining -= 1
              if remaining == 0:
                resolve(results)
            },
            (error) -> reject(error)
          )
      })

    Static Method all_settled<T>(promises: List<Promise<T>>) -> Promise<List<SettledResult<T>>>:
      return Promise((resolve) -> {
        results = []
        remaining = promises.length
        
        if remaining == 0:
          resolve([])
          return
        
        for (i, promise) in promises.enumerate():
          promise.then(
            (value) -> {
              results[i] = Fulfilled(value)
              remaining -= 1
              if remaining == 0:
                resolve(results)
            },
            (error) -> {
              results[i] = Rejected(error)
              remaining -= 1
              if remaining == 0:
                resolve(results)
            }
          )
      })

    Static Method race<T>(promises: List<Promise<T>>) -> Promise<T>:
      return Promise((resolve, reject) -> {
        for promise in promises:
          promise.then(resolve, reject)
      })

    Static Method any<T>(promises: List<Promise<T>>) -> Promise<T>:
      return Promise((resolve, reject) -> {
        errors = []
        remaining = promises.length
        
        for promise in promises:
          promise.then(
            (value) -> resolve(value),
            (error) -> {
              errors.push(error)
              remaining -= 1
              if remaining == 0:
                reject(AggregateError(errors))
            }
          )
      })

    Method then<U>(on_fulfilled: (T) -> U, on_rejected: ((Error) -> U)?) -> Promise<U>:
      return Promise((resolve, reject) -> {
        match state:
          Pending(callbacks) ->
            callbacks.push((on_fulfilled, on_rejected, resolve, reject))
          Fulfilled(value) ->
            try:
              resolve(on_fulfilled(value))
            catch e:
              reject(e)
          Rejected(error) ->
            if on_rejected:
              try:
                resolve(on_rejected(error))
              catch e:
                reject(e)
            else:
              reject(error)
      })

    Method catch<U>(on_rejected: (Error) -> U) -> Promise<T | U>:
      return then(identity, on_rejected)

    Method finally(on_finally: () -> Void) -> Promise<T>:
      return then(
        (value) -> { on_finally(); value },
        (error) -> { on_finally(); throw error }
      )

  Type PromiseState<T>:
    variants:
      - Pending: List<Callback>
      - Fulfilled: T
      - Rejected: Error

  Type SettledResult<T>:
    variants:
      - Fulfilled: T
      - Rejected: Error

  # ==========================================================================
  # ASYNC/AWAIT UTILITIES
  # ==========================================================================

  Behavior AsyncUtilities:
    When sleep(duration: Duration) -> Promise<Void>:
      Then:
        - return Promise((resolve) -> {
            set_timeout(duration, resolve)
          })

    When delay<T>(duration: Duration, value: T) -> Promise<T>:
      Then:
        - await sleep(duration)
        - return value

    When timeout<T>(promise: Promise<T>, duration: Duration) -> Promise<T>:
      Then:
        - return Promise.race([
            promise,
            sleep(duration).then(() -> throw TimeoutError(duration))
          ])

    When retry<T>(fn: () -> Promise<T>, options: RetryOptions) -> Promise<T>:
      Then:
        - attempts = 0
        - last_error = null
        
        - while attempts < options.max_attempts:
            - attempts += 1
            - try:
                - return await fn()
              catch e:
                - last_error = e
                - if attempts < options.max_attempts:
                    - delay = calculate_backoff(attempts, options)
                    - await sleep(delay)
        
        - throw last_error

    When parallel<T>(tasks: List<() -> Promise<T>>, concurrency: Int) -> Promise<List<T>>:
      Then:
        - results = []
        - running = 0
        - index = 0
        - queue = []
        
        - return Promise((resolve, reject) -> {
            run_next = async () -> {
              if index >= tasks.length:
                if running == 0:
                  resolve(results)
                return
              
              current_index = index
              index += 1
              running += 1
              
              try:
                result = await tasks[current_index]()
                results[current_index] = result
              catch e:
                reject(e)
                return
              
              running -= 1
              run_next()
            }
            
            # Start initial batch
            for i in 0..min(concurrency, tasks.length):
              run_next()
          })

    When sequential<T>(tasks: List<() -> Promise<T>>) -> Promise<List<T>>:
      Then:
        - results = []
        - for task in tasks:
            - result = await task()
            - results.push(result)
        - return results

    When map_async<T, U>(items: List<T>, fn: (T) -> Promise<U>, concurrency: Int = Infinity) -> Promise<List<U>>:
      Then:
        - tasks = items.map(item -> () -> fn(item))
        - return await parallel(tasks, concurrency)

    When filter_async<T>(items: List<T>, predicate: (T) -> Promise<Boolean>) -> Promise<List<T>>:
      Then:
        - results = await map_async(items, async (item) -> {
            if await predicate(item):
              return Some(item)
            return None
          })
        - return results.filter_map(identity)

  # ==========================================================================
  # CHANNELS
  # ==========================================================================

  Behavior Channels:
    When channel<T>(capacity: Int = 0) -> (Sender<T>, Receiver<T>):
      Then:
        - ch = Channel(capacity)
        - return (Sender(ch), Receiver(ch))

    Type Channel<T>:
      capacity: Int
      buffer: Queue<T>
      senders: Queue<SendWaiter<T>>
      receivers: Queue<ReceiveWaiter<T>>
      closed: Boolean = false

    Type Sender<T>:
      channel: Channel<T>

      Method send(value: T) -> Promise<Void>:
        if channel.closed:
          throw ChannelClosedError()
        
        # Try to find waiting receiver
        if channel.receivers.length > 0:
          waiter = channel.receivers.dequeue()
          waiter.resolve(Some(value))
          return
        
        # Buffer if capacity allows
        if channel.buffer.length < channel.capacity:
          channel.buffer.enqueue(value)
          return
        
        # Wait for receiver
        return Promise((resolve, reject) -> {
          channel.senders.enqueue(SendWaiter(value, resolve, reject))
        })

      Method try_send(value: T) -> Boolean:
        if channel.closed:
          return false
        
        if channel.receivers.length > 0:
          waiter = channel.receivers.dequeue()
          waiter.resolve(Some(value))
          return true
        
        if channel.buffer.length < channel.capacity:
          channel.buffer.enqueue(value)
          return true
        
        return false

      Method close():
        channel.closed = true
        
        # Notify all waiting receivers
        while channel.receivers.length > 0:
          waiter = channel.receivers.dequeue()
          waiter.resolve(None)
        
        # Reject all waiting senders
        while channel.senders.length > 0:
          waiter = channel.senders.dequeue()
          waiter.reject(ChannelClosedError())

    Type Receiver<T>:
      channel: Channel<T>

      Method receive() -> Promise<Option<T>>:
        # Check buffer first
        if channel.buffer.length > 0:
          value = channel.buffer.dequeue()
          
          # Unblock waiting sender
          if channel.senders.length > 0:
            waiter = channel.senders.dequeue()
            channel.buffer.enqueue(waiter.value)
            waiter.resolve()
          
          return Some(value)
        
        # Check for waiting sender
        if channel.senders.length > 0:
          waiter = channel.senders.dequeue()
          waiter.resolve()
          return Some(waiter.value)
        
        # Check if closed
        if channel.closed:
          return None
        
        # Wait for sender
        return Promise((resolve) -> {
          channel.receivers.enqueue(ReceiveWaiter(resolve))
        })

      Method try_receive() -> Option<T>:
        if channel.buffer.length > 0:
          return Some(channel.buffer.dequeue())
        
        if channel.senders.length > 0:
          waiter = channel.senders.dequeue()
          waiter.resolve()
          return Some(waiter.value)
        
        return None

      Method iter() -> AsyncIterator<T>:
        return AsyncIterator(
          next: async () -> {
            value = await receive()
            match value:
              Some(v) -> { value: v, done: false }
              None -> { done: true }
          }
        )

    Type SendWaiter<T>:
      value: T
      resolve: () -> Void
      reject: (Error) -> Void

    Type ReceiveWaiter<T>:
      resolve: (Option<T>) -> Void

    # Select from multiple channels
    When select<T>(...receivers: Receiver<T>) -> Promise<(Int, T)>:
      Then:
        - return Promise((resolve) -> {
            for (i, receiver) in receivers.enumerate():
              value = receiver.try_receive()
              if value is Some(v):
                resolve((i, v))
                return
            
            # None ready, wait on all
            for (i, receiver) in receivers.enumerate():
              receiver.receive().then((value) -> {
                if value is Some(v):
                  resolve((i, v))
              })
          })

  # ==========================================================================
  # MUTEX & LOCKS
  # ==========================================================================

  Behavior Locks:
    Type Mutex<T>:
      value: T
      locked: Boolean = false
      waiters: Queue<() -> Void>

      Method lock() -> Promise<MutexGuard<T>>:
        if not locked:
          locked = true
          return MutexGuard(self)
        
        return Promise((resolve) -> {
          waiters.enqueue(() -> {
            locked = true
            resolve(MutexGuard(self))
          })
        })

      Method try_lock() -> Option<MutexGuard<T>>:
        if not locked:
          locked = true
          return Some(MutexGuard(self))
        return None

      Method unlock():
        if waiters.length > 0:
          waiter = waiters.dequeue()
          waiter()
        else:
          locked = false

    Type MutexGuard<T>:
      mutex: Mutex<T>

      Method get() -> T:
        return mutex.value

      Method set(value: T):
        mutex.value = value

      Method release():
        mutex.unlock()

    # RwLock - multiple readers, single writer
    Type RwLock<T>:
      value: T
      readers: Int = 0
      writer: Boolean = false
      read_waiters: Queue<() -> Void>
      write_waiters: Queue<() -> Void>

      Method read() -> Promise<ReadGuard<T>>:
        if not writer and write_waiters.length == 0:
          readers += 1
          return ReadGuard(self)
        
        return Promise((resolve) -> {
          read_waiters.enqueue(() -> {
            readers += 1
            resolve(ReadGuard(self))
          })
        })

      Method write() -> Promise<WriteGuard<T>>:
        if not writer and readers == 0:
          writer = true
          return WriteGuard(self)
        
        return Promise((resolve) -> {
          write_waiters.enqueue(() -> {
            writer = true
            resolve(WriteGuard(self))
          })
        })

    Type ReadGuard<T>:
      lock: RwLock<T>

      Method get() -> T:
        return lock.value

      Method release():
        lock.readers -= 1
        if lock.readers == 0 and lock.write_waiters.length > 0:
          waiter = lock.write_waiters.dequeue()
          waiter()

    Type WriteGuard<T>:
      lock: RwLock<T>

      Method get() -> T:
        return lock.value

      Method set(value: T):
        lock.value = value

      Method release():
        lock.writer = false
        
        # Prefer writers
        if lock.write_waiters.length > 0:
          waiter = lock.write_waiters.dequeue()
          waiter()
        else:
          # Wake all readers
          while lock.read_waiters.length > 0:
            waiter = lock.read_waiters.dequeue()
            waiter()

  # ==========================================================================
  # SEMAPHORE
  # ==========================================================================

  Behavior Semaphores:
    Type Semaphore:
      permits: Int
      max_permits: Int
      waiters: Queue<(Int, () -> Void)>

      Static Method new(permits: Int) -> Semaphore:
        return Semaphore(permits, permits, Queue())

      Method acquire(count: Int = 1) -> Promise<SemaphorePermit>:
        if permits >= count:
          permits -= count
          return SemaphorePermit(self, count)
        
        return Promise((resolve) -> {
          waiters.enqueue((count, () -> {
            permits -= count
            resolve(SemaphorePermit(self, count))
          }))
        })

      Method try_acquire(count: Int = 1) -> Option<SemaphorePermit>:
        if permits >= count:
          permits -= count
          return Some(SemaphorePermit(self, count))
        return None

      Method release(count: Int = 1):
        permits += count
        
        # Wake waiters that can now proceed
        while waiters.length > 0:
          (needed, waiter) = waiters.peek()
          if permits >= needed:
            waiters.dequeue()
            waiter()
          else:
            break

    Type SemaphorePermit:
      semaphore: Semaphore
      count: Int

      Method release():
        semaphore.release(count)

  # ==========================================================================
  # BARRIER
  # ==========================================================================

  Behavior Barriers:
    Type Barrier:
      parties: Int
      count: Int = 0
      generation: Int = 0
      waiters: List<() -> Void>

      Static Method new(parties: Int) -> Barrier:
        return Barrier(parties)

      Method wait() -> Promise<Int>:
        current_gen = generation
        count += 1
        
        if count == parties:
          # All parties arrived
          index = count - 1
          count = 0
          generation += 1
          
          # Wake all waiters
          for waiter in waiters:
            waiter()
          waiters.clear()
          
          return index
        
        return Promise((resolve) -> {
          index = count - 1
          waiters.push(() -> resolve(index))
        })

  # ==========================================================================
  # ONCE
  # ==========================================================================

  Behavior Once:
    Type Once<T>:
      executed: Boolean = false
      value: T?
      waiters: List<(T) -> Void>

      Method call(fn: () -> T) -> Promise<T>:
        if executed:
          return value
        
        if waiters.length > 0:
          # Already executing, wait
          return Promise((resolve) -> {
            waiters.push(resolve)
          })
        
        # First caller executes
        waiters.push(() -> {})  # Mark as executing
        
        try:
          value = await fn()
          executed = true
          
          # Notify waiters
          for waiter in waiters:
            waiter(value)
          waiters.clear()
          
          return value
        catch e:
          waiters.clear()
          throw e

  # ==========================================================================
  # ACTORS
  # ==========================================================================

  Behavior Actors:
    Type Actor<State, Message>:
      state: State
      mailbox: Channel<Message>
      handler: (State, Message) -> Promise<State>
      running: Boolean = false

      Static Method spawn<S, M>(initial_state: S, handler: (S, M) -> Promise<S>) -> ActorRef<M>:
        actor = Actor(initial_state, channel(100), handler)
        actor.start()
        return ActorRef(actor)

      Method start():
        running = true
        spawn async () -> {
          while running:
            message = await mailbox.receive()
            match message:
              Some(msg) ->
                state = await handler(state, msg)
              None ->
                running = false
        }

      Method stop():
        running = false
        mailbox.close()

    Type ActorRef<Message>:
      actor: Actor

      Method send(message: Message) -> Promise<Void>:
        await actor.mailbox.send(message)

      Method ask<Response>(message: Message, timeout: Duration = 5.seconds) -> Promise<Response>:
        (sender, receiver) = channel<Response>(1)
        await send((message, sender))
        
        result = await Promise.race([
          receiver.receive(),
          sleep(timeout).then(() -> throw TimeoutError(timeout))
        ])
        
        match result:
          Some(response) -> response
          None -> throw Error("Actor stopped")

      Method stop():
        actor.stop()

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Concurrency":
    ```vibee
    # Async/await
    async fn fetch_user(id: String) -> User:
      response = await http.get("/users/${id}")
      return response.json()

    # Parallel execution
    users = await Promise.all([
      fetch_user("1"),
      fetch_user("2"),
      fetch_user("3")
    ])

    # With concurrency limit
    user_ids = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]
    users = await map_async(user_ids, fetch_user, concurrency: 3)

    # Timeout
    result = await timeout(
      fetch_user("1"),
      5.seconds
    )

    # Retry
    result = await retry(
      () -> http.get("/flaky-endpoint"),
      { max_attempts: 3, initial_delay: 1.second }
    )

    # Channels
    (sender, receiver) = channel<Int>(10)

    # Producer
    spawn async () -> {
      for i in 1..100:
        await sender.send(i)
      sender.close()
    }

    # Consumer
    for await value in receiver.iter():
      log.info("Received: ${value}")

    # Multiple producers/consumers
    (tx, rx) = channel<Task>(100)

    # Start workers
    for i in 1..4:
      spawn async () -> {
        for await task in rx.iter():
          await process_task(task)
      }

    # Send tasks
    for task in tasks:
      await tx.send(task)
    tx.close()

    # Mutex for shared state
    counter = Mutex(0)

    tasks = (1..100).map(async (_) -> {
      guard = await counter.lock()
      value = guard.get()
      guard.set(value + 1)
      guard.release()
    })

    await Promise.all(tasks)
    log.info("Counter: ${counter.value}")  # 100

    # RwLock for read-heavy workloads
    cache = RwLock(Map())

    # Multiple readers
    async fn read_cache(key: String) -> Any?:
      guard = await cache.read()
      value = guard.get()[key]
      guard.release()
      return value

    # Single writer
    async fn write_cache(key: String, value: Any):
      guard = await cache.write()
      data = guard.get()
      data[key] = value
      guard.set(data)
      guard.release()

    # Semaphore for rate limiting
    rate_limiter = Semaphore.new(10)  # Max 10 concurrent

    async fn rate_limited_request(url: String):
      permit = await rate_limiter.acquire()
      try:
        return await http.get(url)
      finally:
        permit.release()

    # Barrier for synchronization
    barrier = Barrier.new(4)

    for i in 1..4:
      spawn async () -> {
        # Phase 1
        do_work_phase1()
        await barrier.wait()
        
        # Phase 2 (all workers synchronized)
        do_work_phase2()
        await barrier.wait()
        
        # Phase 3
        do_work_phase3()
      }

    # Once for lazy initialization
    db_connection = Once()

    async fn get_db():
      return await db_connection.call(async () -> {
        return await Database.connect(config)
      })

    # Actor model
    Type CounterMessage:
      variants:
        - Increment
        - Decrement
        - Get: Sender<Int>

    counter_actor = Actor.spawn(0, async (state, message) -> {
      match message:
        Increment -> state + 1
        Decrement -> state - 1
        Get(reply) ->
          await reply.send(state)
          state
    })

    await counter_actor.send(Increment)
    await counter_actor.send(Increment)
    count = await counter_actor.ask(Get)  # 2
    ```
