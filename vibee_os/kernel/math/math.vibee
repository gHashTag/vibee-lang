# ============================================================================
# MATH - Математические операции на Vibee
# ============================================================================
# Numbers, trigonometry, statistics, linear algebra
# ============================================================================

Specification Math:
  """Математика как спецификация числовых операций."""

  # ==========================================================================
  # CONSTANTS
  # ==========================================================================

  Const PI = 3.141592653589793
  Const E = 2.718281828459045
  Const TAU = 6.283185307179586
  Const PHI = 1.618033988749895  # Golden ratio
  Const SQRT2 = 1.4142135623730951
  Const SQRT3 = 1.7320508075688772
  Const LN2 = 0.6931471805599453
  Const LN10 = 2.302585092994046
  Const LOG2E = 1.4426950408889634
  Const LOG10E = 0.4342944819032518
  Const INFINITY = Float.infinity
  Const NEG_INFINITY = Float.neg_infinity
  Const NAN = Float.nan
  Const EPSILON = 2.220446049250313e-16

  # ==========================================================================
  # BASIC FUNCTIONS
  # ==========================================================================

  Behavior BasicMath:
    When math.abs(x: Number) -> Number:
      Then: if x < 0 then -x else x

    When math.sign(x: Number) -> Int:
      Then: if x > 0 then 1 else if x < 0 then -1 else 0

    When math.floor(x: Float) -> Int:
      Then: floor_impl(x)

    When math.ceil(x: Float) -> Int:
      Then: ceil_impl(x)

    When math.round(x: Float) -> Int:
      Then: round_impl(x)

    When math.trunc(x: Float) -> Int:
      Then: trunc_impl(x)

    When math.fract(x: Float) -> Float:
      Then: x - trunc(x)

    When math.min(...values: Number) -> Number:
      Then: values.reduce(values[0], (a, b) -> if a < b then a else b)

    When math.max(...values: Number) -> Number:
      Then: values.reduce(values[0], (a, b) -> if a > b then a else b)

    When math.clamp(x: Number, min: Number, max: Number) -> Number:
      Then: math.min(math.max(x, min), max)

    When math.lerp(a: Float, b: Float, t: Float) -> Float:
      Then: a + (b - a) * t

    When math.inverse_lerp(a: Float, b: Float, value: Float) -> Float:
      Then: (value - a) / (b - a)

    When math.remap(value: Float, in_min: Float, in_max: Float, out_min: Float, out_max: Float) -> Float:
      Then: lerp(out_min, out_max, inverse_lerp(in_min, in_max, value))

    When math.mod(x: Number, y: Number) -> Number:
      Then: x - y * floor(x / y)

    When math.gcd(a: Int, b: Int) -> Int:
      Then:
        while b != 0:
          (a, b) = (b, a % b)
        return abs(a)

    When math.lcm(a: Int, b: Int) -> Int:
      Then: abs(a * b) / gcd(a, b)

  # ==========================================================================
  # POWER & ROOTS
  # ==========================================================================

  Behavior PowerFunctions:
    When math.pow(base: Float, exp: Float) -> Float:
      Then: pow_impl(base, exp)

    When math.sqrt(x: Float) -> Float:
      Then: sqrt_impl(x)

    When math.cbrt(x: Float) -> Float:
      Then: cbrt_impl(x)

    When math.nthroot(x: Float, n: Int) -> Float:
      Then: pow(x, 1.0 / n)

    When math.exp(x: Float) -> Float:
      Then: exp_impl(x)

    When math.exp2(x: Float) -> Float:
      Then: pow(2, x)

    When math.expm1(x: Float) -> Float:
      Then: expm1_impl(x)  # exp(x) - 1, more precise for small x

    When math.log(x: Float) -> Float:
      Then: log_impl(x)  # Natural log

    When math.log2(x: Float) -> Float:
      Then: log2_impl(x)

    When math.log10(x: Float) -> Float:
      Then: log10_impl(x)

    When math.log1p(x: Float) -> Float:
      Then: log1p_impl(x)  # log(1 + x), more precise for small x

    When math.log_base(x: Float, base: Float) -> Float:
      Then: log(x) / log(base)

    When math.hypot(x: Float, y: Float) -> Float:
      Then: sqrt(x * x + y * y)

    When math.hypot3(x: Float, y: Float, z: Float) -> Float:
      Then: sqrt(x * x + y * y + z * z)

  # ==========================================================================
  # TRIGONOMETRY
  # ==========================================================================

  Behavior Trigonometry:
    When math.sin(x: Float) -> Float:
      Then: sin_impl(x)

    When math.cos(x: Float) -> Float:
      Then: cos_impl(x)

    When math.tan(x: Float) -> Float:
      Then: tan_impl(x)

    When math.asin(x: Float) -> Float:
      Then: asin_impl(x)

    When math.acos(x: Float) -> Float:
      Then: acos_impl(x)

    When math.atan(x: Float) -> Float:
      Then: atan_impl(x)

    When math.atan2(y: Float, x: Float) -> Float:
      Then: atan2_impl(y, x)

    When math.sinh(x: Float) -> Float:
      Then: sinh_impl(x)

    When math.cosh(x: Float) -> Float:
      Then: cosh_impl(x)

    When math.tanh(x: Float) -> Float:
      Then: tanh_impl(x)

    When math.asinh(x: Float) -> Float:
      Then: asinh_impl(x)

    When math.acosh(x: Float) -> Float:
      Then: acosh_impl(x)

    When math.atanh(x: Float) -> Float:
      Then: atanh_impl(x)

    When math.sincos(x: Float) -> (Float, Float):
      Then: (sin(x), cos(x))

    When math.deg_to_rad(degrees: Float) -> Float:
      Then: degrees * PI / 180

    When math.rad_to_deg(radians: Float) -> Float:
      Then: radians * 180 / PI

  # ==========================================================================
  # RANDOM
  # ==========================================================================

  Behavior Random:
    When random.float() -> Float:
      Then: random_float_impl()  # [0, 1)

    When random.float_range(min: Float, max: Float) -> Float:
      Then: min + random.float() * (max - min)

    When random.int(min: Int, max: Int) -> Int:
      Then: floor(random.float_range(min, max + 1))

    When random.bool() -> Boolean:
      Then: random.float() < 0.5

    When random.bool_weighted(probability: Float) -> Boolean:
      Then: random.float() < probability

    When random.choice<T>(items: List<T>) -> T:
      Then: items[random.int(0, items.length - 1)]

    When random.choices<T>(items: List<T>, count: Int) -> List<T>:
      Then: (0..count).map(_ -> random.choice(items))

    When random.sample<T>(items: List<T>, count: Int) -> List<T>:
      Then: items.shuffled().take(count)

    When random.shuffle<T>(items: List<T>) -> List<T>:
      Then:
        result = items.clone()
        for i in (result.length - 1)..0:
          j = random.int(0, i)
          (result[i], result[j]) = (result[j], result[i])
        return result

    When random.weighted_choice<T>(items: List<(T, Float)>) -> T:
      Then:
        total = items.map((_, w) -> w).sum()
        r = random.float() * total
        cumulative = 0.0
        for (item, weight) in items:
          cumulative += weight
          if r < cumulative:
            return item
        return items.last().0

    When random.gaussian(mean: Float = 0, std_dev: Float = 1) -> Float:
      Then:
        # Box-Muller transform
        u1 = random.float()
        u2 = random.float()
        z = sqrt(-2 * log(u1)) * cos(2 * PI * u2)
        return mean + z * std_dev

    When random.uuid() -> String:
      Then: generate_uuid_v4()

    When random.bytes(count: Int) -> Bytes:
      Then: random_bytes_impl(count)

    # Seeded random
    Type SeededRandom:
      seed: Int
      state: Int

      Static Method new(seed: Int) -> SeededRandom:
        return SeededRandom(seed, seed)

      Method next() -> Float:
        # xorshift algorithm
        state ^= state << 13
        state ^= state >> 17
        state ^= state << 5
        return (state & 0x7FFFFFFF) / 2147483647.0

      Method int(min: Int, max: Int) -> Int:
        return floor(next() * (max - min + 1)) + min

  # ==========================================================================
  # STATISTICS
  # ==========================================================================

  Behavior Statistics:
    When stats.mean(values: List<Float>) -> Float:
      Then: values.sum() / values.length

    When stats.median(values: List<Float>) -> Float:
      Then:
        sorted = values.sort()
        n = sorted.length
        if n % 2 == 0:
          return (sorted[n/2 - 1] + sorted[n/2]) / 2
        return sorted[n/2]

    When stats.mode(values: List<Float>) -> Float:
      Then:
        counts = values.group_by(identity).map_values(v -> v.length)
        return counts.max_by((_, count) -> count).0

    When stats.variance(values: List<Float>, population: Boolean = false) -> Float:
      Then:
        m = mean(values)
        sum_sq = values.map(x -> (x - m) ** 2).sum()
        n = if population then values.length else values.length - 1
        return sum_sq / n

    When stats.std_dev(values: List<Float>, population: Boolean = false) -> Float:
      Then: sqrt(variance(values, population))

    When stats.percentile(values: List<Float>, p: Float) -> Float:
      Then:
        sorted = values.sort()
        index = (p / 100) * (sorted.length - 1)
        lower = floor(index)
        upper = ceil(index)
        if lower == upper:
          return sorted[lower]
        return sorted[lower] * (upper - index) + sorted[upper] * (index - lower)

    When stats.quartiles(values: List<Float>) -> (Float, Float, Float):
      Then:
        return (
          percentile(values, 25),
          percentile(values, 50),
          percentile(values, 75)
        )

    When stats.iqr(values: List<Float>) -> Float:
      Then:
        (q1, _, q3) = quartiles(values)
        return q3 - q1

    When stats.range(values: List<Float>) -> Float:
      Then: values.max().unwrap() - values.min().unwrap()

    When stats.covariance(x: List<Float>, y: List<Float>) -> Float:
      Then:
        mx = mean(x)
        my = mean(y)
        sum = x.zip(y).map((xi, yi) -> (xi - mx) * (yi - my)).sum()
        return sum / (x.length - 1)

    When stats.correlation(x: List<Float>, y: List<Float>) -> Float:
      Then:
        return covariance(x, y) / (std_dev(x) * std_dev(y))

    When stats.linear_regression(x: List<Float>, y: List<Float>) -> (Float, Float):
      Then:
        mx = mean(x)
        my = mean(y)
        num = x.zip(y).map((xi, yi) -> (xi - mx) * (yi - my)).sum()
        den = x.map(xi -> (xi - mx) ** 2).sum()
        slope = num / den
        intercept = my - slope * mx
        return (slope, intercept)

    When stats.z_score(value: Float, mean: Float, std_dev: Float) -> Float:
      Then: (value - mean) / std_dev

    When stats.normalize(values: List<Float>) -> List<Float>:
      Then:
        m = mean(values)
        s = std_dev(values)
        return values.map(x -> (x - m) / s)

    When stats.min_max_scale(values: List<Float>) -> List<Float>:
      Then:
        min_val = values.min().unwrap()
        max_val = values.max().unwrap()
        range = max_val - min_val
        return values.map(x -> (x - min_val) / range)

  # ==========================================================================
  # VECTORS
  # ==========================================================================

  Type Vec2:
    x: Float
    y: Float

    Static zero = Vec2(0, 0)
    Static one = Vec2(1, 1)
    Static up = Vec2(0, 1)
    Static down = Vec2(0, -1)
    Static left = Vec2(-1, 0)
    Static right = Vec2(1, 0)

    Method add(other: Vec2) -> Vec2:
      return Vec2(x + other.x, y + other.y)

    Method sub(other: Vec2) -> Vec2:
      return Vec2(x - other.x, y - other.y)

    Method mul(scalar: Float) -> Vec2:
      return Vec2(x * scalar, y * scalar)

    Method div(scalar: Float) -> Vec2:
      return Vec2(x / scalar, y / scalar)

    Method dot(other: Vec2) -> Float:
      return x * other.x + y * other.y

    Method cross(other: Vec2) -> Float:
      return x * other.y - y * other.x

    Method length() -> Float:
      return sqrt(x * x + y * y)

    Method length_squared() -> Float:
      return x * x + y * y

    Method normalize() -> Vec2:
      len = length()
      return if len > 0 then div(len) else Vec2.zero

    Method distance(other: Vec2) -> Float:
      return sub(other).length()

    Method angle() -> Float:
      return atan2(y, x)

    Method angle_to(other: Vec2) -> Float:
      return atan2(cross(other), dot(other))

    Method rotate(angle: Float) -> Vec2:
      c = cos(angle)
      s = sin(angle)
      return Vec2(x * c - y * s, x * s + y * c)

    Method lerp(other: Vec2, t: Float) -> Vec2:
      return Vec2(
        math.lerp(x, other.x, t),
        math.lerp(y, other.y, t)
      )

    Method reflect(normal: Vec2) -> Vec2:
      return sub(normal.mul(2 * dot(normal)))

    Method project(onto: Vec2) -> Vec2:
      return onto.mul(dot(onto) / onto.length_squared())

    Operator +(other: Vec2) -> Vec2:
      return add(other)

    Operator -(other: Vec2) -> Vec2:
      return sub(other)

    Operator *(scalar: Float) -> Vec2:
      return mul(scalar)

    Operator /(scalar: Float) -> Vec2:
      return div(scalar)

  Type Vec3:
    x: Float
    y: Float
    z: Float

    Static zero = Vec3(0, 0, 0)
    Static one = Vec3(1, 1, 1)
    Static up = Vec3(0, 1, 0)
    Static forward = Vec3(0, 0, 1)
    Static right = Vec3(1, 0, 0)

    Method add(other: Vec3) -> Vec3:
      return Vec3(x + other.x, y + other.y, z + other.z)

    Method sub(other: Vec3) -> Vec3:
      return Vec3(x - other.x, y - other.y, z - other.z)

    Method mul(scalar: Float) -> Vec3:
      return Vec3(x * scalar, y * scalar, z * scalar)

    Method dot(other: Vec3) -> Float:
      return x * other.x + y * other.y + z * other.z

    Method cross(other: Vec3) -> Vec3:
      return Vec3(
        y * other.z - z * other.y,
        z * other.x - x * other.z,
        x * other.y - y * other.x
      )

    Method length() -> Float:
      return sqrt(x * x + y * y + z * z)

    Method normalize() -> Vec3:
      len = length()
      return if len > 0 then mul(1 / len) else Vec3.zero

    Method distance(other: Vec3) -> Float:
      return sub(other).length()

    Method lerp(other: Vec3, t: Float) -> Vec3:
      return Vec3(
        math.lerp(x, other.x, t),
        math.lerp(y, other.y, t),
        math.lerp(z, other.z, t)
      )

  # ==========================================================================
  # MATRICES
  # ==========================================================================

  Type Matrix:
    rows: Int
    cols: Int
    data: List<Float>

    Static Method zeros(rows: Int, cols: Int) -> Matrix:
      return Matrix(rows, cols, List.filled(rows * cols, 0.0))

    Static Method identity(size: Int) -> Matrix:
      m = zeros(size, size)
      for i in 0..size:
        m.set(i, i, 1.0)
      return m

    Method get(row: Int, col: Int) -> Float:
      return data[row * cols + col]

    Method set(row: Int, col: Int, value: Float):
      data[row * cols + col] = value

    Method add(other: Matrix) -> Matrix:
      result = Matrix.zeros(rows, cols)
      for i in 0..(rows * cols):
        result.data[i] = data[i] + other.data[i]
      return result

    Method mul(other: Matrix) -> Matrix:
      result = Matrix.zeros(rows, other.cols)
      for i in 0..rows:
        for j in 0..other.cols:
          sum = 0.0
          for k in 0..cols:
            sum += get(i, k) * other.get(k, j)
          result.set(i, j, sum)
      return result

    Method transpose() -> Matrix:
      result = Matrix.zeros(cols, rows)
      for i in 0..rows:
        for j in 0..cols:
          result.set(j, i, get(i, j))
      return result

    Method determinant() -> Float:
      # For 2x2 and 3x3 matrices
      if rows == 2 and cols == 2:
        return get(0,0) * get(1,1) - get(0,1) * get(1,0)
      # ... more complex for larger matrices

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Math":
    ```vibee
    # Basic math
    x = math.abs(-5)  # 5
    y = math.clamp(15, 0, 10)  # 10
    z = math.lerp(0, 100, 0.5)  # 50

    # Trigonometry
    angle = math.deg_to_rad(45)
    (sin_val, cos_val) = math.sincos(angle)

    # Random
    dice = random.int(1, 6)
    coin = random.bool()
    item = random.choice(["sword", "shield", "potion"])
    shuffled = random.shuffle([1, 2, 3, 4, 5])

    # Seeded random for reproducibility
    rng = SeededRandom.new(12345)
    value = rng.next()

    # Statistics
    data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
    
    mean = stats.mean(data)  # 5.5
    median = stats.median(data)  # 5.5
    std = stats.std_dev(data)  # ~3.03
    
    (q1, q2, q3) = stats.quartiles(data)
    
    # Linear regression
    x_vals = [1, 2, 3, 4, 5]
    y_vals = [2.1, 4.0, 5.9, 8.1, 10.0]
    (slope, intercept) = stats.linear_regression(x_vals, y_vals)

    # Vectors
    pos = Vec2(10, 20)
    vel = Vec2(1, 0.5)
    
    new_pos = pos + vel * delta_time
    distance = pos.distance(target)
    direction = (target - pos).normalize()

    # 3D
    camera_pos = Vec3(0, 5, -10)
    look_at = Vec3(0, 0, 0)
    forward = (look_at - camera_pos).normalize()

    # Cross product for normal
    v1 = Vec3(1, 0, 0)
    v2 = Vec3(0, 1, 0)
    normal = v1.cross(v2)  # (0, 0, 1)

    # Matrix operations
    m1 = Matrix.identity(3)
    m2 = Matrix.zeros(3, 3)
    result = m1.mul(m2)
    ```
