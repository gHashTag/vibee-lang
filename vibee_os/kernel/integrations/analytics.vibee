# ============================================================================
# ANALYTICS - Аналитика и метрики на Vibee
# ============================================================================
# Events, metrics, dashboards, reporting
# ============================================================================

Specification Analytics:
  """Аналитика как спецификация сбора и анализа данных."""

  # ==========================================================================
  # CORE TYPES
  # ==========================================================================

  Type Event:
    id: EventId
    name: String
    timestamp: DateTime
    user_id: UserId?
    session_id: SessionId?
    properties: Map<String, Any>
    context: EventContext

  Type EventContext:
    ip: IPAddress?
    user_agent: String?
    locale: String?
    timezone: String?
    page_url: URL?
    referrer: URL?
    device: DeviceInfo?
    geo: GeoInfo?
    utm: UTMParams?

  Type DeviceInfo:
    type: DeviceType
    os: String
    os_version: String
    browser: String?
    browser_version: String?
    screen_width: Int?
    screen_height: Int?

  Type DeviceType:
    variants: [Desktop, Mobile, Tablet, TV, Bot, Unknown]

  Type GeoInfo:
    country: String
    country_code: String
    region: String?
    city: String?
    latitude: Float?
    longitude: Float?

  Type UTMParams:
    source: String?
    medium: String?
    campaign: String?
    term: String?
    content: String?

  Type Metric:
    name: String
    value: Float
    timestamp: DateTime
    tags: Map<String, String>
    type: MetricType

  Type MetricType:
    variants:
      - Counter
      - Gauge
      - Histogram: (buckets: List<Float>)
      - Summary: (quantiles: List<Float>)

  # ==========================================================================
  # EVENT TRACKING
  # ==========================================================================

  Behavior EventTracking:
    When analytics.track(event_name, properties, options):
      Then:
        - event = Event(
            id: generate_event_id(),
            name: event_name,
            timestamp: now(),
            user_id: options.user_id ?? current_user_id(),
            session_id: options.session_id ?? current_session_id(),
            properties: properties,
            context: build_context(options)
          )
        
        - validate_event(event)
        - await event_queue.enqueue(event)
        - emit EventTracked(event)

    When analytics.identify(user_id, traits):
      Then:
        - await analytics.track("$identify", {
            user_id: user_id,
            traits: traits
          })
        - await user_profiles.upsert(user_id, traits)

    When analytics.alias(new_id, previous_id):
      Then:
        - await analytics.track("$alias", {
            new_id: new_id,
            previous_id: previous_id
          })
        - await user_aliases.create(new_id, previous_id)

    When analytics.group(user_id, group_id, traits):
      Then:
        - await analytics.track("$group", {
            user_id: user_id,
            group_id: group_id,
            traits: traits
          })
        - await group_memberships.add(user_id, group_id)
        - await group_profiles.upsert(group_id, traits)

    When analytics.page(name, properties):
      Then:
        - await analytics.track("$pageview", {
            name: name,
            path: properties.path ?? current_path(),
            title: properties.title ?? document_title(),
            ...properties
          })

    When analytics.screen(name, properties):
      Then:
        - await analytics.track("$screen", {
            name: name,
            ...properties
          })

  # ==========================================================================
  # STANDARD EVENTS
  # ==========================================================================

  Behavior StandardEvents:
    When analytics.sign_up(method, properties):
      Then:
        - await analytics.track("Sign Up", {
            method: method,
            ...properties
          })

    When analytics.login(method, properties):
      Then:
        - await analytics.track("Login", {
            method: method,
            ...properties
          })

    When analytics.logout():
      Then:
        - await analytics.track("Logout", {})

    When analytics.purchase(order_id, total, currency, items, properties):
      Then:
        - await analytics.track("Purchase", {
            order_id: order_id,
            total: total,
            currency: currency,
            items: items,
            item_count: items.length,
            ...properties
          })

    When analytics.add_to_cart(item, properties):
      Then:
        - await analytics.track("Add to Cart", {
            item_id: item.id,
            item_name: item.name,
            price: item.price,
            quantity: item.quantity,
            ...properties
          })

    When analytics.remove_from_cart(item, properties):
      Then:
        - await analytics.track("Remove from Cart", {
            item_id: item.id,
            item_name: item.name,
            ...properties
          })

    When analytics.begin_checkout(cart, properties):
      Then:
        - await analytics.track("Begin Checkout", {
            cart_id: cart.id,
            total: cart.total,
            item_count: cart.items.length,
            ...properties
          })

    When analytics.search(query, results_count, properties):
      Then:
        - await analytics.track("Search", {
            query: query,
            results_count: results_count,
            ...properties
          })

    When analytics.share(content_type, content_id, method, properties):
      Then:
        - await analytics.track("Share", {
            content_type: content_type,
            content_id: content_id,
            method: method,
            ...properties
          })

    When analytics.subscribe(plan, properties):
      Then:
        - await analytics.track("Subscribe", {
            plan: plan,
            ...properties
          })

    When analytics.unsubscribe(plan, reason, properties):
      Then:
        - await analytics.track("Unsubscribe", {
            plan: plan,
            reason: reason,
            ...properties
          })

  # ==========================================================================
  # METRICS
  # ==========================================================================

  Behavior MetricsCollection:
    When metrics.increment(name, value, tags):
      Then:
        - metric = Metric(
            name: name,
            value: value ?? 1,
            timestamp: now(),
            tags: tags ?? {},
            type: Counter
          )
        - await metrics_store.record(metric)

    When metrics.gauge(name, value, tags):
      Then:
        - metric = Metric(
            name: name,
            value: value,
            timestamp: now(),
            tags: tags ?? {},
            type: Gauge
          )
        - await metrics_store.record(metric)

    When metrics.histogram(name, value, tags, buckets):
      Then:
        - metric = Metric(
            name: name,
            value: value,
            timestamp: now(),
            tags: tags ?? {},
            type: Histogram(buckets ?? default_buckets())
          )
        - await metrics_store.record(metric)

    When metrics.timing(name, duration, tags):
      Then:
        - await metrics.histogram(name, duration.milliseconds, tags)

    When metrics.time(name, tags, fn):
      Then:
        - start = now()
        - result = await fn()
        - duration = now() - start
        - await metrics.timing(name, duration, tags)
        - return result

  # ==========================================================================
  # QUERIES
  # ==========================================================================

  Type Query:
    select: List<Selection>
    from: DataSource
    where: List<Filter>?
    group_by: List<String>?
    order_by: List<OrderBy>?
    limit: Int?
    time_range: TimeRange

  Type Selection:
    variants:
      - Field: String
      - Count: (field: String?, distinct: Boolean)
      - Sum: String
      - Avg: String
      - Min: String
      - Max: String
      - Percentile: (field: String, p: Float)
      - UniqueCount: String

  Type DataSource:
    variants:
      - Events: (event_name: String?)
      - Metrics: (metric_name: String)
      - Users
      - Sessions

  Type Filter:
    field: String
    operator: FilterOperator
    value: Any

  Type FilterOperator:
    variants: [Eq, Ne, Gt, Gte, Lt, Lte, In, NotIn, Contains, StartsWith, EndsWith, IsNull, IsNotNull]

  Type OrderBy:
    field: String
    direction: SortDirection

  Type SortDirection:
    variants: [Asc, Desc]

  Type TimeRange:
    variants:
      - Last: Duration
      - Between: (start: DateTime, end: DateTime)
      - Since: DateTime
      - Today
      - Yesterday
      - ThisWeek
      - ThisMonth
      - ThisYear

  Behavior QueryExecution:
    When analytics.query(query):
      Then:
        - validated = validate_query(query)
        - sql = compile_to_sql(validated)
        - result = await execute_query(sql)
        - return QueryResult(
            data: result.rows,
            columns: result.columns,
            row_count: result.rows.length,
            execution_time: result.duration
          )

    Type QueryResult:
      data: List<Map<String, Any>>
      columns: List<ColumnInfo>
      row_count: Int
      execution_time: Duration

    Type ColumnInfo:
      name: String
      type: DataType

    When analytics.count(event_name, filters, time_range):
      Then:
        - return await analytics.query({
            select: [Count()],
            from: Events(event_name),
            where: filters,
            time_range: time_range
          })

    When analytics.unique_users(event_name, filters, time_range):
      Then:
        - return await analytics.query({
            select: [UniqueCount("user_id")],
            from: Events(event_name),
            where: filters,
            time_range: time_range
          })

    When analytics.funnel(steps, time_range, options):
      Then:
        - conversion_window = options.conversion_window ?? 7.days
        - return await execute_funnel_query(steps, time_range, conversion_window)

    Type FunnelStep:
      event_name: String
      filters: List<Filter>?

    Type FunnelResult:
      steps: List<FunnelStepResult>
      overall_conversion: Float

    Type FunnelStepResult:
      step: Int
      event_name: String
      users: Int
      conversion_rate: Float
      drop_off_rate: Float

    When analytics.retention(cohort_event, return_event, time_range, options):
      Then:
        - granularity = options.granularity ?? Day
        - return await execute_retention_query(cohort_event, return_event, time_range, granularity)

    Type RetentionResult:
      cohorts: List<CohortData>
      periods: List<String>

    Type CohortData:
      date: Date
      size: Int
      retention: List<Float>

  # ==========================================================================
  # AGGREGATIONS
  # ==========================================================================

  Behavior Aggregations:
    When analytics.aggregate(metric_name, aggregation, time_range, options):
      Then:
        - granularity = options.granularity ?? Hour
        - tags = options.tags ?? {}
        - return await metrics_store.aggregate(metric_name, aggregation, time_range, granularity, tags)

    Type Aggregation:
      variants: [Sum, Avg, Min, Max, Count, P50, P90, P95, P99]

    Type AggregationResult:
      values: List<DataPoint>
      total: Float?
      average: Float?

    Type DataPoint:
      timestamp: DateTime
      value: Float
      tags: Map<String, String>?

    When analytics.top_values(field, event_name, time_range, limit):
      Then:
        - return await analytics.query({
            select: [Field(field), Count()],
            from: Events(event_name),
            time_range: time_range,
            group_by: [field],
            order_by: [{ field: "count", direction: Desc }],
            limit: limit ?? 10
          })

    When analytics.breakdown(event_name, by_field, time_range, options):
      Then:
        - return await analytics.query({
            select: [Field(by_field), Count(), UniqueCount("user_id")],
            from: Events(event_name),
            time_range: time_range,
            group_by: [by_field],
            order_by: [{ field: "count", direction: Desc }]
          })

  # ==========================================================================
  # DASHBOARDS
  # ==========================================================================

  Type Dashboard:
    id: DashboardId
    name: String
    description: String?
    widgets: List<Widget>
    filters: List<DashboardFilter>
    refresh_interval: Duration?
    created_by: UserId
    created_at: DateTime
    updated_at: DateTime

  Type Widget:
    id: WidgetId
    type: WidgetType
    title: String
    query: Query
    visualization: Visualization
    position: WidgetPosition
    size: WidgetSize

  Type WidgetType:
    variants: [Metric, Chart, Table, Funnel, Retention, Map]

  Type Visualization:
    variants:
      - Number: NumberConfig
      - LineChart: ChartConfig
      - BarChart: ChartConfig
      - PieChart: PieConfig
      - AreaChart: ChartConfig
      - Table: TableConfig
      - Funnel: FunnelConfig
      - Heatmap: HeatmapConfig
      - Map: MapConfig

  Type NumberConfig:
    format: NumberFormat
    comparison: ComparisonConfig?
    prefix: String?
    suffix: String?

  Type NumberFormat:
    variants: [Integer, Decimal, Percent, Currency, Duration, Compact]

  Type ComparisonConfig:
    type: ComparisonType
    period: Duration

  Type ComparisonType:
    variants: [Absolute, Percent, PreviousPeriod]

  Type ChartConfig:
    x_axis: AxisConfig
    y_axis: AxisConfig
    series: List<SeriesConfig>
    legend: Boolean
    stacked: Boolean

  Type AxisConfig:
    label: String?
    format: NumberFormat?
    min: Float?
    max: Float?

  Type SeriesConfig:
    name: String
    color: Color?
    type: SeriesType?

  Type SeriesType:
    variants: [Line, Bar, Area, Scatter]

  Type WidgetPosition:
    x: Int
    y: Int

  Type WidgetSize:
    width: Int
    height: Int

  Type DashboardFilter:
    field: String
    label: String
    type: FilterType
    default_value: Any?
    options: List<FilterOption>?

  Type FilterType:
    variants: [Select, MultiSelect, DateRange, Text, Number]

  Type FilterOption:
    label: String
    value: Any

  Behavior DashboardManagement:
    When dashboard.create(data):
      Then:
        - dashboard = Dashboard(
            id: generate_dashboard_id(),
            name: data.name,
            description: data.description,
            widgets: data.widgets ?? [],
            filters: data.filters ?? [],
            refresh_interval: data.refresh_interval,
            created_by: current_user_id(),
            created_at: now(),
            updated_at: now()
          )
        - await dashboards.save(dashboard)
        - return dashboard

    When dashboard.update(id, data):
      Then:
        - dashboard = await dashboards.get(id)
        - updated = dashboard.merge(data, updated_at: now())
        - await dashboards.save(updated)
        - return updated

    When dashboard.delete(id):
      Then:
        - await dashboards.delete(id)

    When dashboard.add_widget(dashboard_id, widget):
      Then:
        - dashboard = await dashboards.get(dashboard_id)
        - widget_with_id = widget.with_id(generate_widget_id())
        - updated = dashboard.add_widget(widget_with_id)
        - await dashboards.save(updated)
        - return widget_with_id

    When dashboard.render(id, filters):
      Then:
        - dashboard = await dashboards.get(id)
        - widget_data = await Promise.all(
            dashboard.widgets.map(w -> render_widget(w, filters))
          )
        - return RenderedDashboard(dashboard, widget_data)

  # ==========================================================================
  # REPORTS
  # ==========================================================================

  Type Report:
    id: ReportId
    name: String
    description: String?
    type: ReportType
    config: ReportConfig
    schedule: ReportSchedule?
    recipients: List<Email>
    format: ReportFormat
    created_by: UserId

  Type ReportType:
    variants: [Dashboard, Query, Funnel, Retention, Custom]

  Type ReportConfig:
    dashboard_id: DashboardId?
    query: Query?
    time_range: TimeRange
    filters: Map<String, Any>

  Type ReportSchedule:
    frequency: ScheduleFrequency
    time: Time
    timezone: String
    day_of_week: Int?
    day_of_month: Int?

  Type ScheduleFrequency:
    variants: [Daily, Weekly, Monthly]

  Type ReportFormat:
    variants: [PDF, CSV, Excel, HTML]

  Behavior ReportManagement:
    When report.create(data):
      Then:
        - report = Report(
            id: generate_report_id(),
            name: data.name,
            description: data.description,
            type: data.type,
            config: data.config,
            schedule: data.schedule,
            recipients: data.recipients,
            format: data.format,
            created_by: current_user_id()
          )
        - await reports.save(report)
        - if report.schedule:
            - await scheduler.schedule_report(report)
        - return report

    When report.generate(id):
      Then:
        - report = await reports.get(id)
        - data = await gather_report_data(report)
        - rendered = await render_report(data, report.format)
        - return rendered

    When report.send(id):
      Then:
        - report = await reports.get(id)
        - rendered = await report.generate(id)
        - for recipient in report.recipients:
            - await email.send({
                to: recipient,
                subject: "Report: ${report.name}",
                attachments: [{ name: "${report.name}.${report.format.extension}", data: rendered }]
              })

  # ==========================================================================
  # ALERTS
  # ==========================================================================

  Type Alert:
    id: AlertId
    name: String
    description: String?
    condition: AlertCondition
    channels: List<AlertChannel>
    cooldown: Duration
    enabled: Boolean
    last_triggered: DateTime?

  Type AlertCondition:
    metric: String
    operator: ComparisonOperator
    threshold: Float
    window: Duration
    aggregation: Aggregation

  Type ComparisonOperator:
    variants: [Gt, Gte, Lt, Lte, Eq, Ne]

  Type AlertChannel:
    variants:
      - Email: List<Email>
      - Slack: SlackConfig
      - Webhook: URL
      - PagerDuty: String
      - SMS: List<Phone>

  Type SlackConfig:
    webhook_url: URL
    channel: String?
    mention: List<String>?

  Behavior AlertManagement:
    When alert.create(data):
      Then:
        - alert = Alert(
            id: generate_alert_id(),
            name: data.name,
            description: data.description,
            condition: data.condition,
            channels: data.channels,
            cooldown: data.cooldown ?? 1.hour,
            enabled: true,
            last_triggered: null
          )
        - await alerts.save(alert)
        - return alert

    When alert.check(alert):
      Then:
        - if not alert.enabled:
            - return
        
        - if alert.last_triggered and (now() - alert.last_triggered) < alert.cooldown:
            - return
        
        - value = await metrics.aggregate(
            alert.condition.metric,
            alert.condition.aggregation,
            Last(alert.condition.window)
          )
        
        - triggered = evaluate_condition(value, alert.condition)
        
        - if triggered:
            - await alert.trigger(alert, value)

    When alert.trigger(alert, value):
      Then:
        - await alerts.update(alert.id, { last_triggered: now() })
        
        - notification = AlertNotification(
            alert: alert,
            value: value,
            threshold: alert.condition.threshold,
            triggered_at: now()
          )
        
        - for channel in alert.channels:
            - await send_alert_notification(channel, notification)
        
        - emit AlertTriggered(notification)

  # ==========================================================================
  # EXAMPLE
  # ==========================================================================

  Example "Analytics Usage":
    ```vibee
    # Track events
    await analytics.track("Button Clicked", {
      button_id: "signup_cta",
      page: "/landing"
    })

    await analytics.purchase("order_123", 99.99, "USD", [
      { id: "prod_1", name: "Premium Plan", price: 99.99, quantity: 1 }
    ])

    # Identify user
    await analytics.identify(user.id, {
      email: user.email,
      name: user.name,
      plan: "premium",
      created_at: user.created_at
    })

    # Query analytics
    signups_today = await analytics.count("Sign Up", [], Today)
    
    active_users = await analytics.unique_users("$pageview", [], Last(7.days))

    # Funnel analysis
    funnel = await analytics.funnel([
      { event_name: "Visit Landing" },
      { event_name: "Sign Up" },
      { event_name: "Complete Onboarding" },
      { event_name: "Purchase" }
    ], Last(30.days))

    log.info("Conversion rate: ${funnel.overall_conversion}%")

    # Retention analysis
    retention = await analytics.retention(
      "Sign Up",
      "$pageview",
      Last(90.days),
      granularity: Week
    )

    # Create dashboard
    dashboard = await dashboard.create({
      name: "Product Metrics",
      widgets: [
        {
          type: Metric,
          title: "Daily Active Users",
          query: { select: [UniqueCount("user_id")], from: Events("$pageview"), time_range: Today },
          visualization: Number(format: Compact, comparison: { type: PreviousPeriod, period: 1.day })
        },
        {
          type: Chart,
          title: "Signups Over Time",
          query: { select: [Count()], from: Events("Sign Up"), time_range: Last(30.days), group_by: ["date"] },
          visualization: LineChart(...)
        }
      ]
    })

    # Create alert
    alert = await alert.create({
      name: "High Error Rate",
      condition: {
        metric: "errors.count",
        operator: Gt,
        threshold: 100,
        window: 5.minutes,
        aggregation: Sum
      },
      channels: [
        Slack({ webhook_url: env.SLACK_WEBHOOK, channel: "#alerts" }),
        Email(["oncall@company.com"])
      ],
      cooldown: 30.minutes
    })

    # Record metrics
    await metrics.increment("api.requests", 1, { endpoint: "/users", method: "GET" })
    await metrics.timing("api.latency", 45.ms, { endpoint: "/users" })
    await metrics.gauge("queue.size", queue.length, { queue: "emails" })
    ```
