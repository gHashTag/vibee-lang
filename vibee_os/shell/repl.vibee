name: vibee_os_repl
version: "0.1.0"
language: gleam
module: shell/repl
description: REPL - –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –∫–æ–Ω—Å–æ–ª—å –¥–ª—è Vibee OS

behaviors:
  - name: evaluate_expression
    given: User enters expression
    when: Enter is pressed
    then: Expression is evaluated and result displayed
    test_cases:
      - name: simple_expression
        input: {expr: "1 + 2"}
        expected: {result: "3"}
      - name: function_call
        input: {expr: "add(2, 3)"}
        expected: {result: "5"}
      - name: behavior_test
        input: {expr: ":test add_numbers"}
        expected: {tests_run: true, results_shown: true}

  - name: define_inline
    given: User defines behavior/type inline
    when: Definition is entered
    then: Definition is added to session
    test_cases:
      - name: define_behavior
        input:
          code: |
            behavior greet
              given: name is provided
              when: greet(name) is called
              then: returns "Hello, {name}!"
        expected:
          defined: true
          available: true
      - name: define_type
        input:
          code: |
            type Point
              x: int
              y: int
        expected:
          defined: true
          can_use: true

  - name: load_spec_file
    given: .vibee file exists
    when: :load command is used
    then: Spec is loaded into session
    test_cases:
      - name: load_file
        input: {command: ":load calculator.vibee"}
        expected: {loaded: true, behaviors_available: true}
      - name: load_nonexistent
        input: {command: ":load nonexistent.vibee"}
        expected: {error: "file_not_found"}

  - name: autocomplete
    given: User is typing
    when: Tab is pressed
    then: Suggestions are shown
    test_cases:
      - name: complete_function
        input: {partial: "ad", available: ["add", "address", "admin"]}
        expected: {suggestions: ["add", "address", "admin"]}
      - name: complete_command
        input: {partial: ":lo"}
        expected: {suggestions: [":load", ":log"]}

  - name: history_navigation
    given: Commands were entered before
    when: Up/Down arrow is pressed
    then: Previous/next command is shown
    test_cases:
      - name: navigate_up
        input: {history: ["cmd1", "cmd2", "cmd3"], press: "up"}
        expected: {shown: "cmd3"}
      - name: navigate_down
        input: {history: ["cmd1", "cmd2"], at: 0, press: "down"}
        expected: {shown: "cmd2"}

  - name: multiline_input
    given: User enters incomplete expression
    when: Line ends with continuation
    then: REPL waits for more input
    test_cases:
      - name: multiline_behavior
        input:
          lines:
            - "behavior test"
            - "  given: x"
            - "  when: y"
            - "  then: z"
        expected: {complete: true, parsed: true}

  - name: chat_mode
    given: LLM is configured
    when: :chat command is used
    then: Interactive chat with LLM starts
    test_cases:
      - name: chat_generate
        input: {command: ":chat Create a calculator"}
        expected: {llm_called: true, spec_generated: true}

types:
  # REPL State
  REPLState:
    session_id: str
    history: [HistoryEntry]
    context: REPLContext
    mode: REPLMode
    config: REPLConfig

  HistoryEntry:
    input: str
    output: str
    timestamp: int
    duration_ms: int

  REPLContext:
    behaviors: {str: Behavior}
    types: {str: TypeDef}
    functions: {str: FunctionDef}
    variables: {str: Value}
    loaded_specs: [str]

  REPLMode:
    variants:
      - Normal
      - Multiline: {buffer: str}
      - Chat
      - Debug

  REPLConfig:
    prompt: str
    continuation_prompt: str
    history_size: int
    auto_save_history: bool
    colors_enabled: bool
    autocomplete_enabled: bool

  # Commands
  REPLCommand:
    variants:
      - Eval: {expr: str}
      - Define: {code: str}
      - Load: {path: str}
      - Save: {path: str}
      - Test: {behavior: str?}
      - Type: {name: str}
      - Help: {topic: str?}
      - Clear
      - History: {count: int?}
      - Chat: {message: str}
      - Debug: {action: str}
      - Quit

  # Result
  REPLResult:
    success: bool
    output: str
    value: Value?
    error: str?
    suggestions: [str]?

  Value:
    variants:
      - Null
      - Bool: {value: bool}
      - Int: {value: int}
      - Float: {value: float}
      - String: {value: str}
      - List: {values: [Value]}
      - Map: {entries: {str: Value}}
      - Function: {name: str}
      - Behavior: {name: str}
      - Type: {name: str}

  # Autocomplete
  Completion:
    text: str
    type: CompletionType
    description: str?

  CompletionType:
    variants:
      - Command
      - Function
      - Behavior
      - Type
      - Variable
      - Keyword
      - File

  # Prompt
  Prompt:
    text: str
    style: PromptStyle

  PromptStyle:
    foreground: str?
    background: str?
    bold: bool

functions:
  # Core REPL
  - name: repl_start
    params: {config: REPLConfig?}
    returns: REPLState
    description: Start REPL session

  - name: repl_eval
    params: {state: REPLState, input: str}
    returns: {state: REPLState, result: REPLResult}
    description: Evaluate input

  - name: repl_stop
    params: {state: REPLState}
    returns: void
    description: Stop REPL session

  # Commands
  - name: parse_command
    params: {input: str}
    returns: REPLCommand
    description: Parse input into command

  - name: execute_command
    params: {state: REPLState, command: REPLCommand}
    returns: {state: REPLState, result: REPLResult}
    description: Execute command

  # Autocomplete
  - name: autocomplete
    params: {state: REPLState, partial: str, cursor: int}
    returns: [Completion]
    description: Get completions

  # History
  - name: history_add
    params: {state: REPLState, entry: HistoryEntry}
    returns: REPLState
    description: Add to history

  - name: history_search
    params: {state: REPLState, query: str}
    returns: [HistoryEntry]
    description: Search history

  - name: history_save
    params: {state: REPLState, path: str}
    returns: bool
    description: Save history to file

  - name: history_load
    params: {path: str}
    returns: [HistoryEntry]
    description: Load history from file

  # Context
  - name: context_define
    params: {state: REPLState, name: str, value: Value}
    returns: REPLState
    description: Define variable in context

  - name: context_lookup
    params: {state: REPLState, name: str}
    returns: Value?
    description: Lookup in context

  # Formatting
  - name: format_value
    params: {value: Value}
    returns: str
    description: Format value for display

  - name: format_error
    params: {error: str}
    returns: str
    description: Format error message

  - name: format_prompt
    params: {state: REPLState}
    returns: Prompt
    description: Generate prompt

imports:
  - kernel.vibee.compiler
  - kernel.agent.llm_client
  - shell.vibee_cli

commands_reference: |
  # REPL Commands
  
  ## Evaluation
  - `<expr>` - Evaluate expression
  - `<definition>` - Define behavior/type/function
  
  ## File Operations
  - `:load <file>` - Load .vibee file
  - `:save <file>` - Save session to file
  - `:reload` - Reload all loaded files
  
  ## Inspection
  - `:type <name>` - Show type definition
  - `:behavior <name>` - Show behavior definition
  - `:list` - List all definitions
  - `:info <name>` - Show detailed info
  
  ## Testing
  - `:test` - Run all tests
  - `:test <behavior>` - Run tests for behavior
  
  ## History
  - `:history` - Show history
  - `:history <n>` - Show last n entries
  - `‚Üë/‚Üì` - Navigate history
  - `Ctrl+R` - Search history
  
  ## Chat/LLM
  - `:chat <message>` - Chat with LLM
  - `:generate <description>` - Generate spec
  - `:improve` - Improve current spec
  
  ## Debug
  - `:debug on/off` - Toggle debug mode
  - `:trace <behavior>` - Trace behavior execution
  - `:break <behavior>` - Set breakpoint
  
  ## Session
  - `:clear` - Clear screen
  - `:reset` - Reset session
  - `:help [topic]` - Show help
  - `:quit` or `Ctrl+D` - Exit REPL

example_session: |
  # Example REPL Session
  
  ```
  vibee> :load calculator.vibee
  ‚úì Loaded calculator.vibee (4 behaviors, 2 types)
  
  vibee> add(2, 3)
  5
  
  vibee> :test add
  ‚úì add_positive (1ms)
  ‚úì add_negative (1ms)
  ‚úì add_zero (1ms)
  All tests passed!
  
  vibee> behavior multiply
  .....   given: Two numbers a and b
  .....   when: multiply(a, b) is called
  .....   then: Returns a * b
  .....   test_cases:
  .....     - name: multiply_positive
  .....       input: {a: 3, b: 4}
  .....       expected: {result: 12}
  ..... 
  ‚úì Defined behavior: multiply
  
  vibee> multiply(3, 4)
  12
  
  vibee> :chat Add a divide function with error handling
  ü§ñ Generating...
  
  behavior divide
    given: Two numbers a and b where b != 0
    when: divide(a, b) is called
    then: Returns a / b
    test_cases:
      - name: divide_normal
        input: {a: 10, b: 2}
        expected: {result: 5}
      - name: divide_by_zero
        input: {a: 10, b: 0}
        expected: {error: "division_by_zero"}
  
  ‚úì Added to session. Run :test divide to verify.
  
  vibee> :save my_calculator.vibee
  ‚úì Saved to my_calculator.vibee
  
  vibee> :quit
  Goodbye!
  ```
