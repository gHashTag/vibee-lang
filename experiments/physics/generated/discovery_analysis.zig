// АНАЛИЗ ПОТЕНЦИАЛЬНОГО ОТКРЫТИЯ
// √(ℏH₀/c) ≈ me — связь массы электрона с космологией?!

const std = @import("std");
const math = std.math;
const print = std.debug.print;

// Константы с высокой точностью
const c: f64 = 299792458;           // точно
const hbar: f64 = 1.054571817e-34;  // CODATA 2018
const H_0: f64 = 2.2e-18;           // ~70 км/с/Мпк (неопределённость ~5%)
const m_e: f64 = 9.1093837015e-31;  // CODATA 2018
const m_p: f64 = 1.67262192369e-27; // CODATA 2018
const G: f64 = 6.67430e-11;         // CODATA 2018
const k_B: f64 = 1.380649e-23;      // точно (определение)

pub fn main() !void {
    print("\n" ++ "=" ** 70 ++ "\n", .{});
    print("  АНАЛИЗ ПОТЕНЦИАЛЬНОГО ОТКРЫТИЯ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    // ========================================
    // ОСНОВНОЕ СООТНОШЕНИЕ
    // ========================================
    print("ОБНАРУЖЕННОЕ СООТНОШЕНИЕ:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    const m_cosmo = @sqrt(hbar * H_0 / c);
    const ratio = m_cosmo / m_e;

    print("m_cosmo = √(ℏH₀/c) = {e:.6} кг\n", .{m_cosmo});
    print("m_e = {e:.6} кг\n", .{m_e});
    print("\nОТНОШЕНИЕ: m_cosmo / m_e = {d:.6}\n\n", .{ratio});

    print("ЭТО ПОЧТИ ЕДИНИЦА!\n\n", .{});

    // ========================================
    // ПРОВЕРКА РАЗМЕРНОСТИ
    // ========================================
    print("ПРОВЕРКА РАЗМЕРНОСТИ:\n", .{});
    print("-" ** 50 ++ "\n", .{});
    print("[ℏ] = кг·м²/с\n", .{});
    print("[H₀] = 1/с\n", .{});
    print("[c] = м/с\n", .{});
    print("[ℏH₀/c] = кг·м²/с × 1/с × с/м = кг·м/с² × с/м = кг\n", .{});
    print("√[кг] = √кг — НЕ МАССА!\n\n", .{});

    print("ОШИБКА: Размерность не сходится!\n", .{});
    print("Правильная формула должна быть:\n", .{});
    print("m = ℏH₀/c² (размерность массы)\n\n", .{});

    const m_correct = hbar * H_0 / (c * c);
    print("m_correct = ℏH₀/c² = {e:.6} кг\n", .{m_correct});
    print("m_correct / m_e = {e:.6}\n\n", .{m_correct / m_e});

    // ========================================
    // ДРУГИЕ ИНТЕРЕСНЫЕ СООТНОШЕНИЯ
    // ========================================
    print("=" ** 70 ++ "\n", .{});
    print("  ДРУГИЕ ИНТЕРЕСНЫЕ СООТНОШЕНИЯ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    // 1. Близкое к 1/2
    const r1 = c * c * c * c * c / (G * G * hbar * m_e * m_p * m_p * H_0);
    print("1. c⁵/(G²ℏ me mp² H₀) = {d:.6}\n", .{r1});

    // 2. Проверка найденного 0.48
    const r2 = hbar * hbar * H_0 / (c * G * m_e * m_p * m_p);
    print("2. ℏ²H₀/(cG me mp²) = {d:.6}\n", .{r2});

    // 3. Близкое к 2
    const r3 = c * G * m_e * m_p * m_p / (hbar * hbar * H_0);
    print("3. cG me mp²/(ℏ²H₀) = {d:.6}\n\n", .{r3});

    // ========================================
    // ФИЗИЧЕСКАЯ ИНТЕРПРЕТАЦИЯ
    // ========================================
    print("=" ** 70 ++ "\n", .{});
    print("  ФИЗИЧЕСКАЯ ИНТЕРПРЕТАЦИЯ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    print("Соотношение ℏ²H₀/(cG me mp²) ≈ 0.48 ≈ 1/2\n\n", .{});

    print("Это можно переписать как:\n", .{});
    print("  ℏ²H₀ ≈ (1/2) × cG me mp²\n\n", .{});

    print("Или:\n", .{});
    print("  H₀ ≈ cG me mp² / (2ℏ²)\n\n", .{});

    // Вычисляем H₀ из этой формулы
    const H_0_calc = c * G * m_e * m_p * m_p / (2 * hbar * hbar);
    print("H₀ (расчётное) = {e:.3} 1/с\n", .{H_0_calc});
    print("H₀ (наблюдаемое) = {e:.3} 1/с\n", .{H_0});
    print("Отношение: {d:.2}\n\n", .{H_0_calc / H_0});

    // В км/с/Мпк
    const Mpc = 3.086e22;  // метров
    const H_0_kms = H_0_calc * Mpc / 1000;
    print("H₀ (расчётное) = {d:.1} км/с/Мпк\n", .{H_0_kms});
    print("H₀ (наблюдаемое) ≈ 70 км/с/Мпк\n\n", .{});

    // ========================================
    // ПРОВЕРКА ДРУГИХ КОМБИНАЦИЙ
    // ========================================
    print("=" ** 70 ++ "\n", .{});
    print("  СИСТЕМАТИЧЕСКИЙ ПОИСК БЛИЗКИХ К ЦЕЛЫМ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    // Ищем комбинации близкие к простым числам
    const simple = [_]f64{ 0.5, 1.0, 2.0, 3.0, 4.0, 0.25, 0.333, 0.667, 1.5 };

    print("Комбинации близкие к простым числам:\n\n", .{});

    // Тест разных комбинаций
    const tests = [_]struct { name: []const u8, val: f64 }{
        .{ .name = "ℏ²H₀/(cG me mp²)", .val = hbar * hbar * H_0 / (c * G * m_e * m_p * m_p) },
        .{ .name = "cG me mp²/(ℏ²H₀)", .val = c * G * m_e * m_p * m_p / (hbar * hbar * H_0) },
        .{ .name = "G mp²/(ℏc) × me/mp", .val = G * m_p * m_p / (hbar * c) * m_e / m_p },
        .{ .name = "ℏH₀/(me c²)", .val = hbar * H_0 / (m_e * c * c) },
        .{ .name = "ℏH₀/(mp c²)", .val = hbar * H_0 / (m_p * c * c) },
        .{ .name = "√(me/mp) × α", .val = @sqrt(m_e / m_p) * (1.0 / 137.036) },
        .{ .name = "G me mp/(ℏc)", .val = G * m_e * m_p / (hbar * c) },
    };

    for (tests) |t| {
        for (simple) |s| {
            const diff = @abs(t.val / s - 1.0);
            if (diff < 0.1) {
                print("{s} ≈ {d:.3} (отклонение {d:.1}%)\n", .{ t.name, s, diff * 100 });
            }
        }
    }

    // ========================================
    // ВЫВОДЫ
    // ========================================
    print("\n" ++ "=" ** 70 ++ "\n", .{});
    print("  ВЫВОДЫ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    print("1. Соотношение ℏ²H₀/(cG me mp²) ≈ 0.48 ИНТЕРЕСНО,\n", .{});
    print("   но не точно равно 1/2.\n\n", .{});

    print("2. Неопределённость H₀ (~5%) не объясняет расхождение.\n\n", .{});

    print("3. Возможные интерпретации:\n", .{});
    print("   a) Случайное совпадение\n", .{});
    print("   b) Приближённое соотношение с поправками\n", .{});
    print("   c) Указание на более глубокую связь\n\n", .{});

    print("4. Для РЕАЛЬНОГО открытия нужно:\n", .{});
    print("   • Точное значение H₀ (проблема Хаббла!)\n", .{});
    print("   • Теоретическое обоснование\n", .{});
    print("   • Независимые предсказания\n\n", .{});

    print("СТАТУС: Интересное наблюдение, но НЕ открытие.\n", .{});
    print("=" ** 70 ++ "\n", .{});
}

test "mass_ratio" {
    try std.testing.expectApproxEqRel(m_p / m_e, 1836.15, 0.001);
}
