// ПОИСК СООТНОШЕНИЙ МЕЖДУ ФИЗИЧЕСКИМИ ВЕЛИЧИНАМИ
// Не просто комбинации констант, а связи между разными масштабами

const std = @import("std");
const math = std.math;
const print = std.debug.print;

// Константы
const c: f64 = 299792458;
const G: f64 = 6.67430e-11;
const hbar: f64 = 1.054571817e-34;
const k_B: f64 = 1.380649e-23;
const m_e: f64 = 9.1093837015e-31;
const m_p: f64 = 1.67262192369e-27;
const alpha: f64 = 7.2973525693e-3;
const H_0: f64 = 2.2e-18;

// Производные величины
const l_P: f64 = 1.616255e-35;      // Планковская длина
const t_P: f64 = 5.391247e-44;      // Планковское время
const m_P: f64 = 2.176434e-8;       // Планковская масса
const T_P: f64 = 1.416784e32;       // Планковская температура
const a_0: f64 = 5.29177210903e-11; // Боровский радиус
const lambda_C: f64 = 2.42631023867e-12; // Комптоновская длина электрона
const r_e: f64 = 2.8179403262e-15;  // Классический радиус электрона

// Космологические
const t_H: f64 = 4.55e17;           // Время Хаббла
const l_H: f64 = 1.36e26;           // Радиус Хаббла
const M_H: f64 = 1.84e53;           // Масса Хаббла

pub fn main() !void {
    print("\n" ++ "=" ** 70 ++ "\n", .{});
    print("  ПОИСК СООТНОШЕНИЙ МЕЖДУ МАСШТАБАМИ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    // ========================================
    // 1. СООТНОШЕНИЯ ДЛИН
    // ========================================
    print("1. СООТНОШЕНИЯ ДЛИН:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    print("l_H / l_P = {e:.3} (Хаббл/Планк)\n", .{l_H / l_P});
    print("a_0 / l_P = {e:.3} (Бор/Планк)\n", .{a_0 / l_P});
    print("λ_C / l_P = {e:.3} (Комптон/Планк)\n", .{lambda_C / l_P});
    print("r_e / l_P = {e:.3} (класс.радиус/Планк)\n\n", .{r_e / l_P});

    print("a_0 / λ_C = {d:.3} = 1/α\n", .{a_0 / lambda_C});
    print("λ_C / r_e = {d:.3} = 1/α\n", .{lambda_C / r_e});
    print("a_0 / r_e = {d:.3} = 1/α²\n\n", .{a_0 / r_e});

    // Геометрические средние
    print("√(l_P × l_H) = {e:.3} м\n", .{@sqrt(l_P * l_H)});
    print("√(l_P × a_0) = {e:.3} м\n", .{@sqrt(l_P * a_0)});
    print("√(a_0 × l_H) = {e:.3} м\n\n", .{@sqrt(a_0 * l_H)});

    // ========================================
    // 2. СООТНОШЕНИЯ ВРЕМЁН
    // ========================================
    print("2. СООТНОШЕНИЯ ВРЕМЁН:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    const t_atomic = hbar / (m_e * c * c);  // атомное время
    const t_nuclear = hbar / (m_p * c * c); // ядерное время

    print("t_H / t_P = {e:.3}\n", .{t_H / t_P});
    print("t_atomic / t_P = {e:.3}\n", .{t_atomic / t_P});
    print("t_nuclear / t_P = {e:.3}\n\n", .{t_nuclear / t_P});

    print("t_H / t_atomic = {e:.3}\n", .{t_H / t_atomic});
    print("√(t_P × t_H) = {e:.3} с = {d:.1} лет\n\n", .{ @sqrt(t_P * t_H), @sqrt(t_P * t_H) / (365.25 * 24 * 3600) });

    // ========================================
    // 3. СООТНОШЕНИЯ МАСС
    // ========================================
    print("3. СООТНОШЕНИЯ МАСС:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    print("m_P / m_p = {e:.3}\n", .{m_P / m_p});
    print("m_P / m_e = {e:.3}\n", .{m_P / m_e});
    print("m_p / m_e = {d:.3}\n", .{m_p / m_e});
    print("M_H / m_P = {e:.3}\n", .{M_H / m_P});
    print("M_H / m_p = {e:.3}\n\n", .{M_H / m_p});

    print("√(m_e × m_p) = {e:.3} кг\n", .{@sqrt(m_e * m_p)});
    print("√(m_P × m_e) = {e:.3} кг\n", .{@sqrt(m_P * m_e)});
    print("√(m_P × m_p) = {e:.3} кг\n\n", .{@sqrt(m_P * m_p)});

    // ========================================
    // 4. БЕЗРАЗМЕРНЫЕ ОТНОШЕНИЯ
    // ========================================
    print("4. БЕЗРАЗМЕРНЫЕ ОТНОШЕНИЯ:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    const alpha_G = G * m_p * m_p / (hbar * c);
    const alpha_e = G * m_e * m_e / (hbar * c);

    print("α (тонкая структура) = {e:.6} = 1/{d:.3}\n", .{ alpha, 1 / alpha });
    print("α_G (гравитационная, протон) = {e:.6}\n", .{alpha_G});
    print("α_G (гравитационная, электрон) = {e:.6}\n\n", .{alpha_e});

    print("α / α_G = {e:.3}\n", .{alpha / alpha_G});
    print("(m_P/m_p)² = {e:.3}\n", .{math.pow(f64, m_P / m_p, 2)});
    print("Отношение: {d:.3}\n\n", .{alpha / alpha_G / math.pow(f64, m_P / m_p, 2)});

    // ========================================
    // 5. КОСМОЛОГИЧЕСКИЕ СООТНОШЕНИЯ
    // ========================================
    print("5. КОСМОЛОГИЧЕСКИЕ СООТНОШЕНИЯ:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    // Числа Дирака
    const N1 = l_H / r_e;
    const N2 = t_H / t_atomic;
    const N3 = M_H / m_p;

    print("N1 = l_H/r_e = {e:.3}\n", .{N1});
    print("N2 = t_H/t_atomic = {e:.3}\n", .{N2});
    print("N3 = M_H/m_p = {e:.3}\n\n", .{N3});

    print("√N1 = {e:.3}\n", .{@sqrt(N1)});
    print("√N3 = {e:.3}\n", .{@sqrt(N3)});
    print("N1/N3 = {d:.3}\n\n", .{N1 / N3});

    // ========================================
    // 6. НАЙДЕННОЕ СООТНОШЕНИЕ H₀
    // ========================================
    print("6. НАЙДЕННОЕ СООТНОШЕНИЕ (H₀):\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    const ratio = hbar * hbar * H_0 / (c * G * m_e * m_p * m_p);
    print("ℏ²H₀/(cG me mp²) = {d:.6}\n", .{ratio});
    print("Близко к 1/2!\n\n", .{});

    // Если точно 1/2, то H₀ =
    const H_0_pred = c * G * m_e * m_p * m_p / (2 * hbar * hbar);
    const Mpc = 3.086e22;
    print("Если = 1/2, то H₀ = {d:.1} км/с/Мпк\n", .{H_0_pred * Mpc / 1000});
    print("Наблюдаемое: ~70 км/с/Мпк\n\n", .{});

    // Переформулировка
    print("Эквивалентные формы:\n", .{});
    print("  H₀ ≈ cG me mp² / (2ℏ²)\n", .{});
    print("  H₀ ≈ (c/2) × (G me mp²/ℏ²)\n", .{});
    print("  H₀ ≈ (c/2) × α_G × (m_e/m_p) × (m_p c/ℏ)\n\n", .{});

    // ========================================
    // 7. ПОИСК ДРУГИХ СООТНОШЕНИЙ
    // ========================================
    print("7. ПОИСК ДРУГИХ СООТНОШЕНИЙ:\n", .{});
    print("-" ** 50 ++ "\n\n", .{});

    // Проверяем разные комбинации на близость к простым числам
    const combos = [_]struct { name: []const u8, val: f64 }{
        .{ .name = "l_H/(l_P × N1^(1/3))", .val = l_H / (l_P * math.pow(f64, N1, 1.0 / 3.0)) },
        .{ .name = "t_H × t_P / t_atomic²", .val = t_H * t_P / (t_atomic * t_atomic) },
        .{ .name = "M_H × m_e / (m_P × m_p)", .val = M_H * m_e / (m_P * m_p) },
        .{ .name = "α × (m_P/m_p)²", .val = alpha * math.pow(f64, m_P / m_p, 2) },
        .{ .name = "α² × (m_p/m_e)", .val = alpha * alpha * m_p / m_e },
        .{ .name = "√(α_G/α)", .val = @sqrt(alpha_G / alpha) },
        .{ .name = "l_P × l_H / a_0²", .val = l_P * l_H / (a_0 * a_0) },
    };

    for (combos) |combo| {
        const log_val = @log10(combo.val);
        const frac = log_val - @floor(log_val);
        if (frac < 0.1 or frac > 0.9) {
            print("{s} = {e:.3} (близко к 10^{d:.0})\n", .{ combo.name, combo.val, @round(log_val) });
        }
    }

    // ========================================
    // 8. ВЫВОДЫ
    // ========================================
    print("\n" ++ "=" ** 70 ++ "\n", .{});
    print("  ВЫВОДЫ\n", .{});
    print("=" ** 70 ++ "\n\n", .{});

    print("ПОДТВЕРЖДЁННЫЕ СООТНОШЕНИЯ:\n", .{});
    print("  • a_0/λ_C = λ_C/r_e = 1/α (известно)\n", .{});
    print("  • α/α_G ≈ (m_P/m_p)² (известно)\n\n", .{});

    print("НОВОЕ СООТНОШЕНИЕ:\n", .{});
    print("  • ℏ²H₀/(cG me mp²) ≈ 1/2\n", .{});
    print("  • Предсказывает H₀ ≈ 70.7 км/с/Мпк\n", .{});
    print("  • Точность: ~4%\n\n", .{});

    print("ИНТЕРПРЕТАЦИЯ:\n", .{});
    print("  Если это не случайность, то постоянная Хаббла\n", .{});
    print("  определяется микрофизикой (me, mp, ℏ, G, c)!\n\n", .{});

    print("ПРОБЛЕМЫ:\n", .{});
    print("  • Неопределённость H₀ (проблема Хаббла: 67 vs 73)\n", .{});
    print("  • Нет теоретического обоснования\n", .{});
    print("  • Возможно случайное совпадение\n\n", .{});

    print("=" ** 70 ++ "\n", .{});
}

test "hubble_relation" {
    const ratio = hbar * hbar * H_0 / (c * G * m_e * m_p * m_p);
    // Проверяем что близко к 0.5
    try std.testing.expect(ratio > 0.4 and ratio < 0.6);
}
