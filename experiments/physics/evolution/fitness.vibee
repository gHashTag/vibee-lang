name: fitness
version: "1.0.0"
language: zig
module: fitness
description: |
  Фитнес-функция для оценки физических законов
  
  Критерии:
  1. Безразмерность (+100)
  2. Близость к простым числам (+80)
  3. Новизна (+20, -80 за известные)
  4. Простота формулы (+40)
  5. Связь квантов и гравитации (+60)
  6. Космологическая связь (+50)

creation_pattern:
  source: LawGenome
  transformer: evaluate
  result: FitnessScore
  iteration: single

behaviors:
  - name: dimensionless_bonus
    given: Безразмерный закон
    when: Оценивается фитнес
    then: Добавляется бонус 100
    test_cases:
      - name: alpha_dimensionless
        input: {powers: [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]}
        expected: {includes_bonus: 100}
      - name: mass_not_dimensionless
        input: {powers: [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]}
        expected: {includes_bonus: 0}

  - name: simple_value_bonus
    given: Значение близко к простому числу
    when: Оценивается фитнес
    then: Добавляется бонус пропорционально близости
    test_cases:
      - name: near_half
        input: {value: 0.48}
        expected: {bonus_for: "1/2", bonus: 80}
      - name: near_one
        input: {value: 0.98}
        expected: {bonus_for: "1", bonus: 90}
      - name: near_pi
        input: {value: 3.14}
        expected: {bonus_for: "π", bonus: 95}

  - name: novelty_check
    given: Значение закона
    when: Проверяется на известность
    then: Штраф за известные, бонус за новые
    test_cases:
      - name: known_alpha_inverse
        input: {value: 137.036}
        expected: {penalty: -80}
      - name: known_mass_ratio
        input: {value: 1836.15}
        expected: {penalty: -80}
      - name: novel_value
        input: {value: 42.123}
        expected: {bonus: 20}

  - name: quantum_gravity_bonus
    given: Закон использует ℏ и G
    when: Оценивается фитнес
    then: Добавляется бонус за связь квантов и гравитации
    test_cases:
      - name: has_both
        input: {powers: [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
        expected: {bonus: 60}
      - name: only_hbar
        input: {powers: [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]}
        expected: {bonus: 0}

  - name: cosmological_bonus
    given: Закон использует H₀
    when: Оценивается фитнес
    then: Добавляется бонус за космологическую связь
    test_cases:
      - name: has_hubble
        input: {powers: [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]}
        expected: {bonus: 50}

  - name: hubble_relation_special
    given: Комбинация ℏ²H₀/(cG·mₑ·mₚ²)
    when: Оценивается фитнес
    then: Максимальный бонус за наше открытие
    test_cases:
      - name: exact_hubble_relation
        input: {powers: [-1, -1, 2, 0, 0, -1, -2, 0, 0, 1, 0, 0]}
        expected: {total_fitness: 300, min: true}

transformers:
  - name: evaluate
    type: pure
    input: LawGenome
    output: float
    rule: |
      score = 0
      
      # Безразмерность
      if is_dimensionless(genome):
        score += 100
      
      # Близость к простым числам
      value = compute_value(genome)
      score += evaluate_simple_value(value)
      
      # Новизна
      score += evaluate_novelty(value)
      
      # Простота
      score += evaluate_simplicity(genome)
      
      # Квантовая гравитация
      score += evaluate_quantum_gravity(genome)
      
      # Космология
      score += evaluate_cosmological(genome)
      
      return score

  - name: evaluate_simple_value
    type: pure
    input: float
    output: float
    rule: |
      targets = [(0.5, 100), (1.0, 90), (2.0, 85), (3.14159, 95), (2.71828, 90)]
      for (target, bonus) in targets:
        diff = abs(value - target) / target
        if diff < 0.05:
          return bonus * (1 - diff / 0.05)
      return 0

  - name: evaluate_novelty
    type: pure
    input: float
    output: float
    rule: |
      known = [137.036, 1836.15, 1.616e-35, 5.391e-44, 2.176e-8]
      for k in known:
        ratio = value / k
        if 0.99 < ratio < 1.01:
          return -80
      return 20

  - name: evaluate_simplicity
    type: pure
    input: LawGenome
    output: float
    rule: |
      c = complexity(genome)
      if c <= 4: return 40
      if c <= 6: return 30
      if c <= 8: return 20
      if c <= 10: return 10
      return -(c - 10) * 2

  - name: evaluate_quantum_gravity
    type: pure
    input: LawGenome
    output: float
    rule: |
      has_hbar = genome.powers[2] != 0
      has_G = genome.powers[1] != 0
      has_c = genome.powers[0] != 0
      
      score = 0
      if has_hbar and has_G: score += 40
      if has_hbar and has_G and has_c: score += 20
      return score

  - name: evaluate_cosmological
    type: pure
    input: LawGenome
    output: float
    rule: |
      score = 0
      if genome.powers[9] != 0: score += 50  # H₀
      if genome.powers[5] != 0 and genome.powers[6] != 0: score += 30  # me and mp
      return score

types:
  FitnessScore:
    total: float
    breakdown: FitnessBreakdown
    
  FitnessBreakdown:
    dimensionless: float
    simple_value: float
    novelty: float
    simplicity: float
    quantum_gravity: float
    cosmological: float

constants:
  KNOWN_VALUES:
    - 137.036      # 1/α
    - 0.00729735   # α
    - 1836.15      # mp/me
    - 1.616e-35    # l_P
    - 5.391e-44    # t_P
    - 2.176e-8     # m_P
    
  TARGET_VALUES:
    - {value: 0.5, name: "1/2", bonus: 100}
    - {value: 1.0, name: "1", bonus: 90}
    - {value: 2.0, name: "2", bonus: 85}
    - {value: 3.14159, name: "π", bonus: 95}
    - {value: 2.71828, name: "e", bonus: 90}
    - {value: 1.61803, name: "φ", bonus: 90}

functions:
  - name: evaluate
    params: {genome: LawGenome}
    returns: float
    
  - name: evaluate_detailed
    params: {genome: LawGenome}
    returns: FitnessScore
    
  - name: is_known_value
    params: {value: float}
    returns: bool
    
  - name: find_nearest_target
    params: {value: float}
    returns: {name: string, diff: float}

test_generation:
  boundary: true
  property: true
  coverage: 95
