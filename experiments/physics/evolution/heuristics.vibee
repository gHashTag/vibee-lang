name: heuristics
version: "1.0.0"
language: zig
module: heuristics
description: |
  Эволюционирующие эвристики для оценки физических законов
  
  Эвристики сами эволюционируют на основе эффективности:
  - Веса увеличиваются для эвристик, способствующих открытиям
  - Веса уменьшаются для неэффективных эвристик
  
  Мета-эволюция: эволюция самой эволюции

creation_pattern:
  source: HeuristicSet
  transformer: evolve_heuristics
  result: HeuristicSet
  iteration: bounded

behaviors:
  - name: heuristic_application
    given: Эвристика с весом
    when: Применяется к геному
    then: Возвращает score × weight
    test_cases:
      - name: dimensionless_bonus
        input: {heuristic: "dimensionless_bonus", genome: {dimensionless: true}, weight: 1.5}
        expected: {score: 75}  # 50 * 1.5
      - name: disabled_heuristic
        input: {heuristic: "any", enabled: false}
        expected: {score: 0}

  - name: heuristic_mutation
    given: Набор эвристик
    when: Применяется мутация
    then: Веса или пороги изменяются
    test_cases:
      - name: weight_change
        input: {heuristic: {weight: 1.0}}
        expected: {weight_in_range: [0.1, 3.0]}
      - name: threshold_change
        input: {heuristic: {threshold: 0.1}}
        expected: {threshold_changed: true}

  - name: effectiveness_tracking
    given: Эвристика с историей
    when: Анализируется эффективность
    then: effectiveness = discoveries / triggers
    test_cases:
      - name: effective_heuristic
        input: {discoveries: 10, triggers: 100}
        expected: {effectiveness: 0.1}
      - name: ineffective_heuristic
        input: {discoveries: 0, triggers: 1000}
        expected: {effectiveness: 0}

  - name: meta_evolution
    given: Набор эвристик и популяция
    when: Запускается мета-эволюция
    then: Веса адаптируются к эффективности
    test_cases:
      - name: increase_effective
        input: {heuristic: {effectiveness: 0.2, weight: 1.0}}
        expected: {weight_increased: true}
      - name: decrease_ineffective
        input: {heuristic: {effectiveness: 0.001, weight: 1.0, triggers: 1000}}
        expected: {weight_decreased: true}

transformers:
  - name: apply_heuristic
    type: pure
    input: {heuristic: Heuristic, genome: LawGenome}
    output: float
    rule: |
      if not heuristic.enabled:
        return 0
      
      score = switch heuristic.type:
        dimensionless_bonus: eval_dimensionless(genome)
        simplicity_bonus: eval_simplicity(genome)
        near_integer_bonus: eval_near_integer(genome)
        near_simple_fraction: eval_near_fraction(genome)
        known_value_penalty: eval_known_penalty(genome)
        extreme_value_penalty: eval_extreme_penalty(genome)
        physical_dimension_bonus: eval_physical_dim(genome)
        cosmological_bonus: eval_cosmological(genome)
        quantum_gravity_bonus: eval_quantum_gravity(genome)
      
      if score != 0:
        heuristic.times_triggered += 1
      
      return score * heuristic.weight

  - name: evaluate_all
    type: pure
    input: {heuristics: HeuristicSet, genome: LawGenome}
    output: float
    rule: |
      total = 0
      for h in heuristics.heuristics:
        total += apply_heuristic(h, genome)
      heuristics.total_fitness_produced += total
      return total

  - name: mutate_heuristics
    type: stochastic
    input: HeuristicSet
    output: HeuristicSet
    rule: |
      idx = random_int(0, 8)
      h = heuristics.heuristics[idx]
      
      # Мутация веса
      weight_delta = (random() - 0.5) * 0.4
      h.weight = clamp(h.weight + weight_delta, 0.1, 3.0)
      
      # Мутация порога
      if h.threshold > 0:
        thresh_delta = (random() - 0.5) * h.threshold * 0.3
        h.threshold = max(0.01, h.threshold + thresh_delta)
      
      # Иногда вкл/выкл
      if random() < 0.05:
        h.enabled = !h.enabled
      
      heuristics.generation += 1
      return heuristics

  - name: evolve_heuristics
    type: stochastic
    input: {heuristics: HeuristicSet, population: Population}
    output: HeuristicSet
    rule: |
      # Анализ эффективности
      for h in heuristics.heuristics:
        if h.times_triggered > 0:
          effectiveness = h.discoveries_contributed / h.times_triggered
          
          if effectiveness > 0.1:
            h.weight *= 1.1
          elif effectiveness < 0.01 and h.times_triggered > 100:
            h.weight *= 0.9
          
          h.weight = clamp(h.weight, 0.1, 3.0)
      
      # Случайная мутация
      if random() < 0.2:
        heuristics = mutate_heuristics(heuristics)
      
      # Обновление статистики
      for discovery in population.discoveries:
        update_discovery_stats(heuristics, discovery)
      
      heuristics.generation += 1
      return heuristics

types:
  HeuristicType:
    enum:
      - dimensionless_bonus
      - simplicity_bonus
      - near_integer_bonus
      - near_simple_fraction
      - known_value_penalty
      - extreme_value_penalty
      - physical_dimension_bonus
      - cosmological_bonus
      - quantum_gravity_bonus

  Heuristic:
    type: HeuristicType
    weight: float
    threshold: float
    enabled: bool
    times_triggered: uint64
    discoveries_contributed: uint64

  HeuristicSet:
    heuristics: [9]Heuristic
    generation: uint32
    total_fitness_produced: float

constants:
  NUM_HEURISTICS: 9
  
  DEFAULT_HEURISTICS:
    - {type: "dimensionless_bonus", weight: 1.0, threshold: 0, enabled: true}
    - {type: "simplicity_bonus", weight: 1.0, threshold: 10, enabled: true}
    - {type: "near_integer_bonus", weight: 1.0, threshold: 0.1, enabled: true}
    - {type: "near_simple_fraction", weight: 1.0, threshold: 0.1, enabled: true}
    - {type: "known_value_penalty", weight: 1.0, threshold: 0, enabled: true}
    - {type: "extreme_value_penalty", weight: 1.0, threshold: 50, enabled: true}
    - {type: "physical_dimension_bonus", weight: 1.0, threshold: 0, enabled: true}
    - {type: "cosmological_bonus", weight: 1.0, threshold: 0, enabled: true}
    - {type: "quantum_gravity_bonus", weight: 1.0, threshold: 0, enabled: true}

functions:
  - name: init
    params: {}
    returns: HeuristicSet
    
  - name: apply_heuristic
    params: {heuristic: Heuristic, genome: LawGenome}
    returns: float
    
  - name: evaluate_all
    params: {heuristics: HeuristicSet, genome: LawGenome}
    returns: float
    
  - name: mutate_heuristics
    params: {heuristics: HeuristicSet}
    returns: HeuristicSet
    
  - name: evolve_heuristics
    params: {heuristics: HeuristicSet, population: Population}
    returns: HeuristicSet
    
  - name: effectiveness
    params: {heuristics: HeuristicSet}
    returns: float
    
  - name: print
    params: {heuristics: HeuristicSet}
    returns: void

test_generation:
  boundary: true
  property: true
  coverage: 90
