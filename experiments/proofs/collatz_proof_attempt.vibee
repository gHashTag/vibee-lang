name: collatz_proof_attempt
version: "1.0.0"
language: zig
module: collatz_proof
description: |
  PROOF ATTEMPT: Collatz Conjecture via Creation Pattern
  
  Key Insight: The Creation Pattern suggests we need to prove
  that the Transformer ALWAYS reduces "potential" to zero.
  
  Source: n (with some "potential energy")
  Transformer: collatz_step (reduces potential)
  Result: 1 (zero potential)
  
  PROOF STRATEGY:
  Define a "potential function" φ(n) such that:
  1. φ(1) = 0
  2. φ(collatz_step(n)) < φ(n) for all n > 1
  
  If such φ exists, Collatz is proven!

behaviors:
  # ATTEMPT 1: Simple log-based potential
  - name: potential_log_attempt
    given: A potential function φ(n) = log2(n)
    when: We check if φ decreases on each step
    then: It should decrease on average
    test_cases:
      - name: even_decreases
        input: {n: 16}
        expected: {phi_before: 4.0, phi_after: 3.0, decreased: true}
      - name: odd_increases_then_decreases
        input: {n: 3}
        expected: {phi_before: 1.58, phi_after: 3.32, decreased: false}
        # PROBLEM: Odd numbers INCREASE potential!

  # ATTEMPT 2: Weighted potential considering odd/even ratio
  - name: potential_weighted_attempt
    given: A potential function φ(n) = n itself (simplest)
    when: We track the trajectory
    then: The sum of trajectory should be bounded
    test_cases:
      - name: trajectory_7
        input: {n: 7}
        expected: {trajectory_sum: 170, steps: 16, avg: 10.625}
      - name: trajectory_27
        input: {n: 27}
        expected: {steps: 111, max_value: 9232}

  # ATTEMPT 3: Binary representation insight
  - name: binary_structure
    given: Number n in binary representation
    when: We analyze how collatz_step transforms binary
    then: Even removes trailing 0, Odd adds complexity then removes
    test_cases:
      - name: binary_16
        input: {n: 16, binary: "10000"}
        expected: {after_step: 8, binary_after: "1000", trailing_zeros_removed: 1}
      - name: binary_7
        input: {n: 7, binary: "111"}
        expected: {after_step: 22, binary_after: "10110", ones_changed: true}

  # ATTEMPT 4: Modular arithmetic pattern
  - name: modular_cycles
    given: Number n modulo various bases
    when: We track residue classes through iterations
    then: Certain residue classes lead to faster convergence
    test_cases:
      - name: mod_3_analysis
        input: {n: 7, mod: 3}
        expected: {residue_sequence: [1, 1, 2, 1, 0, 2, 1, 1, 2, 1, 0]}
      - name: mod_4_analysis
        input: {n: 7, mod: 4}
        expected: {residue_sequence: [3, 2, 3, 2, 1, 0, 2, 1, 0]}

  # KEY INSIGHT: Creation Pattern decomposition
  - name: creation_decomposition
    given: The Collatz transformer as composition of two operations
    when: We decompose into CREATE_EVEN and CREATE_ODD
    then: We can analyze each separately
    test_cases:
      - name: decompose_even
        input: {n: 16, type: "even"}
        expected: {operation: "divide_by_2", effect: "halve", always_decreases: true}
      - name: decompose_odd
        input: {n: 7, type: "odd"}
        expected: {operation: "3n+1", effect: "make_even", next_is_even: true}

  # CRITICAL OBSERVATION
  - name: odd_to_even_chain
    given: An odd number n
    when: We apply 3n+1 then divide by 2 repeatedly
    then: We get (3n+1)/2^k for some k >= 1
    test_cases:
      - name: chain_3
        input: {n: 3}
        expected: {result: 5, formula: "(3*3+1)/2 = 5", k: 1}
      - name: chain_5
        input: {n: 5}
        expected: {result: 1, formula: "(3*5+1)/8 = 2, then 1", k: 3}
      - name: chain_7
        input: {n: 7}
        expected: {result: 11, formula: "(3*7+1)/2 = 11", k: 1}

  # PROOF STRUCTURE via Creation Pattern
  - name: proof_structure
    given: |
      Creation Pattern: Source → Transformer → Result
      We need: ∀n. ∃k. Transformer^k(n) = 1
    when: We analyze the transformer's effect on number classes
    then: |
      CONJECTURE: The transformer maps:
      - Even numbers to smaller numbers (always)
      - Odd numbers to even numbers (always)
      - The "odd chain" (3n+1)/2^k eventually produces smaller odd
    test_cases:
      - name: even_always_smaller
        input: {n: 1000000}
        expected: {after: 500000, smaller: true}
      - name: odd_to_even
        input: {n: 999999}
        expected: {after: 2999998, is_even: true}

types:
  PotentialResult:
    phi_before: float
    phi_after: float
    decreased: bool

  TrajectoryResult:
    trajectory_sum: int
    steps: int
    max_value: int

  BinaryResult:
    after_step: int
    binary_after: str
    trailing_zeros_removed: int?
    ones_changed: bool?

  ModularResult:
    residue_sequence: [int]

  DecomposeResult:
    operation: str
    effect: str
    always_decreases: bool?
    next_is_even: bool?

  ChainResult:
    result: int
    formula: str
    k: int

functions:
  - name: potential_log
    params: {n: int}
    returns: float

  - name: collatz_trajectory
    params: {n: int}
    returns: TrajectoryResult

  - name: binary_analysis
    params: {n: int}
    returns: BinaryResult

  - name: modular_analysis
    params: {n: int, mod: int}
    returns: ModularResult

  - name: odd_chain
    params: {n: int}
    returns: ChainResult
