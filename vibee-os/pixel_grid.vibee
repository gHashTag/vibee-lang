// ═══════════════════════════════════════════════════════════════════════════
// ПИКСЕЛЬНАЯ СЕТКА ТРИДЕВЯТОГО ЦАРСТВА
// ═══════════════════════════════════════════════════════════════════════════
//
// «Каждый пиксель — живой процесс»
// «2,073,600 живых сущностей на экране»
//
// Написано на языке 999 (Тридевятица)
// ═══════════════════════════════════════════════════════════════════════════

name: pixel_grid
version: "999.0.0"
language: vibee999
module: пиксели

import gorynych.{ТРИДЕВЯТИЦА, ТРОИЦА, ПИ, Трибул, Эмоция, цвет_эмоции}

// ═══════════════════════════════════════════════════════════════════════════
// ТИПЫ ЦВЕТОВ
// ═══════════════════════════════════════════════════════════════════════════

struct RGB {
  r: Ⲏ,  // 0-255
  g: Ⲏ,  // 0-255
  b: Ⲏ   // 0-255
}

struct HSL {
  h: Ⲫ,  // 0-360
  s: Ⲫ,  // 0-1
  l: Ⲫ   // 0-1
}

fn rgb_в_hex(цвет: RGB) -> Слово {
  "#" + цвет.r.в_hex() + цвет.g.в_hex() + цвет.b.в_hex()
}

fn hex_в_rgb(hex: Слово) -> RGB {
  RGB {
    r: hex[1..3].из_hex(),
    g: hex[3..5].из_hex(),
    b: hex[5..7].из_hex()
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// ЦВЕТА ТРЁХ ЦАРСТВ
// ═══════════════════════════════════════════════════════════════════════════

const ЦВЕТ_МЕДНОГО: RGB = RGB { r: 205, g: 127, b: 50 }    // #CD7F32
const ЦВЕТ_СЕРЕБРЯНОГО: RGB = RGB { r: 192, g: 192, b: 192 } // #C0C0C0
const ЦВЕТ_ЗОЛОТОГО: RGB = RGB { r: 255, g: 215, b: 0 }    // #FFD700

const ЦВЕТ_ФОНА: RGB = RGB { r: 26, g: 26, b: 46 }         // #1A1A2E
const ЦВЕТ_СЕТКИ: RGB = RGB { r: 40, g: 40, b: 70 }        // #282846

// ═══════════════════════════════════════════════════════════════════════════
// ПИКСЕЛЬ КАК ЖИВОЙ ПРОЦЕСС
// ═══════════════════════════════════════════════════════════════════════════

type СостояниеПикселя = enum {
  Спит,    // Неактивен, базовый цвет
  Живёт,   // Активен, реагирует на события
  Сияет    // Максимальная активность
}

struct Пиксель {
  // Координаты
  x: Ⲍ,
  y: Ⲍ,
  
  // Визуальное состояние
  цвет: RGB,
  яркость: Ⲫ,  // 0.0 - 1.0
  
  // Состояние процесса
  состояние: СостояниеПикселя,
  эмоция: ?Эмоция,
  
  // Связи с соседями (8 направлений)
  соседи: [?&Пиксель; 8],
  
  // Счётчики
  тиков_жизни: Ⲛ,
  волн_получено: Ⲛ
}

// ═══════════════════════════════════════════════════════════════════════════
// СОЗДАНИЕ ПИКСЕЛЯ
// ═══════════════════════════════════════════════════════════════════════════

fn создать_пиксель(x: Ⲍ, y: Ⲍ) -> Пиксель {
  Пиксель {
    x: x,
    y: y,
    цвет: ЦВЕТ_ФОНА,
    яркость: 0.0,
    состояние: СостояниеПикселя::Спит,
    эмоция: none,
    соседи: [none; 8],
    тиков_жизни: 0,
    волн_получено: 0
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// ОБРАБОТКА СООБЩЕНИЙ ПИКСЕЛЕМ
// ═══════════════════════════════════════════════════════════════════════════

type СообщениеПикселю = enum {
  Волна { цвет: RGB, интенсивность: Ⲫ },
  КурсорРядом { расстояние: Ⲫ },
  Клик,
  Тик { dt: Ⲫ }
}

fn обработать_сообщение(пиксель: &mut Пиксель, сообщение: СообщениеПикселю) {
  match сообщение {
    // Волна цвета проходит через пиксель
    Волна { цвет, интенсивность } => {
      пиксель.цвет = смешать_цвета(пиксель.цвет, цвет, интенсивность)
      пиксель.яркость = мин(1.0, пиксель.яркость + интенсивность * 0.3)
      пиксель.волн_получено += 1
      
      if интенсивность > 0.7 {
        пиксель.состояние = СостояниеПикселя::Сияет
      } else if интенсивность > 0.3 {
        пиксель.состояние = СостояниеПикселя::Живёт
      }
    },
    
    // Курсор рядом — пиксель «чувствует»
    КурсорРядом { расстояние } => {
      let свечение = 1.0 / (расстояние + 1.0)
      пиксель.яркость = мин(1.0, пиксель.яркость + свечение * 0.2)
      пиксель.цвет = осветлить(пиксель.цвет, свечение * 0.1)
    },
    
    // Клик — пиксель «активируется»
    Клик => {
      пиксель.состояние = СостояниеПикселя::Сияет
      пиксель.яркость = 1.0
      уведомить_соседей(пиксель)
    },
    
    // Тик времени — затухание
    Тик { dt } => {
      пиксель.тиков_жизни += 1
      
      // Постепенное затухание
      пиксель.яркость = макс(0.0, пиксель.яркость - dt * 0.1)
      
      if пиксель.яркость < 0.1 {
        пиксель.состояние = СостояниеПикселя::Спит
        пиксель.цвет = приблизить_к(пиксель.цвет, ЦВЕТ_ФОНА, dt * 0.05)
      }
    }
  }
}

fn уведомить_соседей(пиксель: &Пиксель) {
  for сосед in пиксель.соседи {
    match сосед {
      some(с) => {
        let расстояние = 1.0
        обработать_сообщение(с, СообщениеПикселю::КурсорРядом { расстояние })
      },
      none => {}
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// ПИКСЕЛЬНАЯ СЕТКА
// ═══════════════════════════════════════════════════════════════════════════

struct ПиксельнаяСетка {
  ширина: Ⲍ,
  высота: Ⲍ,
  пиксели: [[Пиксель]],
  всего_пикселей: Ⲛ,
  активных_пикселей: Ⲛ
}

fn создать_сетку(ширина: Ⲍ, высота: Ⲍ) -> ПиксельнаяСетка {
  let пиксели: [[Пиксель]] = []
  
  // Создание всех пикселей
  for y in 0..высота {
    пиксели[y] = []
    for x in 0..ширина {
      пиксели[y][x] = создать_пиксель(x, y)
    }
  }
  
  // Связывание соседей
  for y in 0..высота {
    for x in 0..ширина {
      связать_соседей(&mut пиксели, x, y, ширина, высота)
    }
  }
  
  ПиксельнаяСетка {
    ширина: ширина,
    высота: высота,
    пиксели: пиксели,
    всего_пикселей: ширина * высота,
    активных_пикселей: 0
  }
}

fn связать_соседей(пиксели: &mut [[Пиксель]], x: Ⲍ, y: Ⲍ, ш: Ⲍ, в: Ⲍ) {
  // 8 направлений: N, NE, E, SE, S, SW, W, NW
  let смещения = [
    (0, -1),   // N
    (1, -1),   // NE
    (1, 0),    // E
    (1, 1),    // SE
    (0, 1),    // S
    (-1, 1),   // SW
    (-1, 0),   // W
    (-1, -1)   // NW
  ]
  
  for i in 0..8 {
    let (dx, dy) = смещения[i]
    let nx = x + dx
    let ny = y + dy
    
    if nx >= 0 && nx < ш && ny >= 0 && ny < в {
      пиксели[y][x].соседи[i] = some(&пиксели[ny][nx])
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// ВОЛНОВАЯ ДИФФУЗИЯ
// ═══════════════════════════════════════════════════════════════════════════

struct Волна {
  центр: Точка,
  эмоция: Эмоция,
  радиус: Ⲍ,
  скорость: Ⲫ,
  текущий_радиус: Ⲫ
}

struct Точка {
  x: Ⲍ,
  y: Ⲍ
}

fn создать_волну(центр: Точка, эмоция: Эмоция, радиус: Ⲍ) -> Волна {
  Волна {
    центр: центр,
    эмоция: эмоция,
    радиус: радиус,
    скорость: 2.0,
    текущий_радиус: 0.0
  }
}

fn обновить_волну(волна: &mut Волна, сетка: &mut ПиксельнаяСетка, dt: Ⲫ) -> Трибул {
  волна.текущий_радиус += волна.скорость * dt
  
  if волна.текущий_радиус > волна.радиус {
    return Ⲃ  // Волна завершена
  }
  
  let r = округлить(волна.текущий_радиус)
  let цвет = цвет_эмоции(волна.эмоция)
  
  // Интенсивность по синусоиде
  let интенсивность = sin(волна.текущий_радиус * ПИ / волна.радиус)
  
  // Пиксели на текущем радиусе
  for угол in 0..360 {
    let рад = угол * ПИ / 180.0
    let x = округлить(волна.центр.x + r * cos(рад))
    let y = округлить(волна.центр.y + r * sin(рад))
    
    if x >= 0 && x < сетка.ширина && y >= 0 && y < сетка.высота {
      let сообщение = СообщениеПикселю::Волна {
        цвет: цвет,
        интенсивность: интенсивность
      }
      обработать_сообщение(&mut сетка.пиксели[y][x], сообщение)
    }
  }
  
  Ⲁ  // Волна продолжается
}

// ═══════════════════════════════════════════════════════════════════════════
// ЭМОЦИОНАЛЬНЫЕ ПАТТЕРНЫ
// ═══════════════════════════════════════════════════════════════════════════

type ПаттернВолны = enum {
  Круг,       // Обычная круговая волна
  Спираль,    // Спиральная волна
  Звезда,     // Звёздообразная волна
  Троица      // Три волны одновременно
}

fn излучить_паттерн(
  сетка: &mut ПиксельнаяСетка,
  центр: Точка,
  эмоция: Эмоция,
  паттерн: ПаттернВолны
) {
  match паттерн {
    Круг => {
      let волна = создать_волну(центр, эмоция, 100)
      // Запустить волну...
    },
    
    Спираль => {
      // Спиральная волна с золотым углом
      let золотой_угол = 137.5  // градусов
      for i in 0..100 {
        let угол = i * золотой_угол * ПИ / 180.0
        let r = sqrt(i) * 5.0
        let x = округлить(центр.x + r * cos(угол))
        let y = округлить(центр.y + r * sin(угол))
        // Активировать пиксель...
      }
    },
    
    Звезда => {
      // Звезда с тремя лучами
      for луч in 0..ТРОИЦА {
        let угол = луч * 120.0 * ПИ / 180.0
        for r in 0..100 {
          let x = округлить(центр.x + r * cos(угол))
          let y = округлить(центр.y + r * sin(угол))
          // Активировать пиксель...
        }
      }
    },
    
    Троица => {
      // Три волны одновременно (три царства)
      let эмоции = [Эмоция::Энергия, Эмоция::Покой, Эмоция::Радость]
      let смещения = [
        Точка { x: -50, y: -50 },
        Точка { x: 50, y: -50 },
        Точка { x: 0, y: 50 }
      ]
      
      for i in 0..ТРОИЦА {
        let ц = Точка {
          x: центр.x + смещения[i].x,
          y: центр.y + смещения[i].y
        }
        let волна = создать_волну(ц, эмоции[i], 80)
        // Запустить волну...
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// УТИЛИТЫ ЦВЕТОВ
// ═══════════════════════════════════════════════════════════════════════════

fn смешать_цвета(цвет1: RGB, цвет2: RGB, фактор: Ⲫ) -> RGB {
  RGB {
    r: округлить(цвет1.r + (цвет2.r - цвет1.r) * фактор),
    g: округлить(цвет1.g + (цвет2.g - цвет1.g) * фактор),
    b: округлить(цвет1.b + (цвет2.b - цвет1.b) * фактор)
  }
}

fn осветлить(цвет: RGB, фактор: Ⲫ) -> RGB {
  RGB {
    r: мин(255, округлить(цвет.r + (255 - цвет.r) * фактор)),
    g: мин(255, округлить(цвет.g + (255 - цвет.g) * фактор)),
    b: мин(255, округлить(цвет.b + (255 - цвет.b) * фактор))
  }
}

fn затемнить(цвет: RGB, фактор: Ⲫ) -> RGB {
  RGB {
    r: округлить(цвет.r * (1.0 - фактор)),
    g: округлить(цвет.g * (1.0 - фактор)),
    b: округлить(цвет.b * (1.0 - фактор))
  }
}

fn приблизить_к(цвет: RGB, цель: RGB, фактор: Ⲫ) -> RGB {
  смешать_цвета(цвет, цель, фактор)
}

// ═══════════════════════════════════════════════════════════════════════════
// ПОВЕДЕНИЯ
// ═══════════════════════════════════════════════════════════════════════════

behaviors:
  - name: "создание_сетки"
    given: "Заданы ширина и высота"
    when: "Вызвана функция создать_сетку()"
    then: "Создаётся сетка с ширина×высота пикселями"
    test_cases:
      - name: "full_hd"
        input: { ширина: 1920, высота: 1080 }
        expected: { всего_пикселей: 2073600 }
        
  - name: "волновая_диффузия"
    given: "Сетка создана"
    when: "Излучается волна из центра"
    then: "Пиксели на пути волны меняют цвет"
    
  - name: "затухание"
    given: "Пиксель активен"
    when: "Проходит время без новых событий"
    then: "Пиксель постепенно возвращается к фоновому цвету"
