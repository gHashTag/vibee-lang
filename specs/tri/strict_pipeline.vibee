# ═══════════════════════════════════════════════════════════════════════════════
# STRICT PIPELINE - Enforced .vibee → .tri → .zig Workflow
# ═══════════════════════════════════════════════════════════════════════════════
# PAS DAEMON: D&C (Divide-and-Conquer) + PRE (Precomputation)
#
# PIPELINE STEPS:
# Step 0: User writes .vibee specification in specs/ folder
# Step 1: BLOCK any manual .zig/.py code (unless explicitly requested)
# Step 2: Generate .tri file with ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ block
# Step 3: Extract .zig from .tri to trinity/output/
# Step 4: Run tests
# Step 5: Fix problems (loop back to Step 0 if needed)
#
# SCIENTIFIC REFERENCES:
# 1. "Model-Driven Engineering" - Schmidt (2006)
#    DOI: 10.1109/MC.2006.58
# 2. "Domain-Specific Languages" - Fowler (2010)
#    ISBN: 978-0321712943
# 3. "Generative Programming" - Czarnecki & Eisenecker (2000)
#    ISBN: 978-0201309775
# ═══════════════════════════════════════════════════════════════════════════════

name: strict_pipeline
version: "1.0.0"
language: zig
module: pipeline

sacred_constants:
  phi: 1.618033988749895
  trinity: 3.0
  phoenix: 999

creation_pattern:
  source: VibeeSpec
  transformer: PipelineEnforcer
  result: GeneratedAndTestedCode

# ═══════════════════════════════════════════════════════════════════════════════
# PIPELINE STEPS
# ═══════════════════════════════════════════════════════════════════════════════

pipeline_steps:
  - step: 0
    name: specification
    description: "Write .vibee specification"
    input: "User requirements"
    output: "specs/*.vibee file"
    validation: "File exists and has valid YAML structure"
    
  - step: 1
    name: block_manual_code
    description: "Prevent manual .zig/.py writing"
    input: "User request"
    output: "Redirect to .vibee creation"
    validation: "No .zig/.py files created directly"
    
  - step: 2
    name: generate_tri
    description: "Generate .tri with ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ block"
    input: ".vibee specification"
    output: "trinity/ЦАРСТВО/*.tri file"
    validation: "Contains ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ block"
    
  - step: 3
    name: extract_zig
    description: "Extract .zig from .tri"
    input: ".tri file"
    output: "trinity/output/*.zig file"
    validation: "Valid Zig syntax"
    
  - step: 4
    name: run_tests
    description: "Execute zig test"
    input: ".zig file"
    output: "Test results"
    validation: "All tests pass"
    
  - step: 5
    name: fix_problems
    description: "Fix any issues"
    input: "Test failures or errors"
    output: "Updated .vibee specification"
    validation: "Loop back to Step 0"

# ═══════════════════════════════════════════════════════════════════════════════
# TYPES
# ═══════════════════════════════════════════════════════════════════════════════

types:
  - name: PipelineStep
    enum:
      - Specification
      - BlockManualCode
      - GenerateTri
      - ExtractZig
      - RunTests
      - FixProblems

  - name: PipelineResult
    fields:
      - name: step
        type: PipelineStep
      - name: success
        type: Bool
      - name: message
        type: String
      - name: output_path
        type: String

  - name: ValidationError
    fields:
      - name: step
        type: PipelineStep
      - name: error_type
        type: String
      - name: message
        type: String
      - name: suggestion
        type: String

behaviors:
  - name: validate_request
    given: "User request to write code"
    when: "Request contains .zig or .py"
    then: "Block and suggest .vibee instead"
    pas_pattern: PRE
    complexity: O(1)

  - name: run_pipeline
    given: ".vibee specification"
    when: "User requests generation"
    then: "Execute all pipeline steps"
    pas_pattern: D&C
    complexity: O(n)

  - name: extract_zig_block
    given: ".tri file with ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ"
    when: "Extraction requested"
    then: "Extract Zig code to output"
    pas_pattern: PRE
    complexity: O(n)

ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: """
// ═══════════════════════════════════════════════════════════════════════════════
// STRICT PIPELINE - Enforced .vibee → .tri → .zig Workflow
// ═══════════════════════════════════════════════════════════════════════════════
// PAS: D&C + PRE | φ² + 1/φ² = 3
// Pipeline: .vibee → .tri → .zig → tests
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const mem = std.mem;
const fs = std.fs;
const Allocator = mem.Allocator;

// ═══════════════════════════════════════════════════════════════════════════════
// SACRED CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════

pub const PHI: f64 = 1.618033988749895;
pub const TRINITY: f64 = 3.0;
pub const PHOENIX: u32 = 999;

// ═══════════════════════════════════════════════════════════════════════════════
// PATHS
// ═══════════════════════════════════════════════════════════════════════════════

pub const Paths = struct {
    pub const SPECS_DIR: []const u8 = "specs/tri";
    pub const TRI_DIR: []const u8 = "trinity/ЦАРСТВО/ⲘⲈⲆⲚⲞⲈ/ⲧⲣⲓ";
    pub const OUTPUT_DIR: []const u8 = "trinity/output";
    
    pub const VIBEE_EXT: []const u8 = ".vibee";
    pub const TRI_EXT: []const u8 = ".tri";
    pub const ZIG_EXT: []const u8 = ".zig";
};

// ═══════════════════════════════════════════════════════════════════════════════
// BLOCKED EXTENSIONS
// ═══════════════════════════════════════════════════════════════════════════════

pub const BlockedExtensions = struct {
    pub const LIST: [6][]const u8 = .{
        ".zig",
        ".py",
        ".js",
        ".ts",
        ".go",
        ".rs",
    };

    pub fn isBlocked(ext: []const u8) bool {
        for (LIST) |blocked| {
            if (mem.eql(u8, ext, blocked)) return true;
        }
        return false;
    }

    pub fn suggestion(ext: []const u8) []const u8 {
        if (mem.eql(u8, ext, ".zig")) {
            return "Create a .vibee specification instead. The pipeline will generate .zig code.";
        }
        if (mem.eql(u8, ext, ".py")) {
            return "Create a .vibee specification with 'language: python' target.";
        }
        return "Use .vibee specifications for code generation.";
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// PIPELINE STEPS
// ═══════════════════════════════════════════════════════════════════════════════

pub const PipelineStep = enum {
    specification,      // Step 0
    block_manual_code,  // Step 1
    generate_tri,       // Step 2
    extract_zig,        // Step 3
    run_tests,          // Step 4
    fix_problems,       // Step 5

    pub fn number(self: PipelineStep) u8 {
        return switch (self) {
            .specification => 0,
            .block_manual_code => 1,
            .generate_tri => 2,
            .extract_zig => 3,
            .run_tests => 4,
            .fix_problems => 5,
        };
    }

    pub fn name(self: PipelineStep) []const u8 {
        return switch (self) {
            .specification => "Specification",
            .block_manual_code => "Block Manual Code",
            .generate_tri => "Generate .tri",
            .extract_zig => "Extract .zig",
            .run_tests => "Run Tests",
            .fix_problems => "Fix Problems",
        };
    }

    pub fn description(self: PipelineStep) []const u8 {
        return switch (self) {
            .specification => "Write .vibee specification in specs/",
            .block_manual_code => "Prevent manual .zig/.py writing",
            .generate_tri => "Generate .tri with ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ block",
            .extract_zig => "Extract .zig from .tri to output/",
            .run_tests => "Execute zig test",
            .fix_problems => "Fix issues, loop to Step 0",
        };
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// PIPELINE RESULT
// ═══════════════════════════════════════════════════════════════════════════════

pub const PipelineResult = struct {
    step: PipelineStep,
    success: bool,
    message: [256]u8,
    message_len: usize,
    output_path: [256]u8,
    output_path_len: usize,

    pub fn getMessage(self: *const PipelineResult) []const u8 {
        return self.message[0..self.message_len];
    }

    pub fn getOutputPath(self: *const PipelineResult) []const u8 {
        return self.output_path[0..self.output_path_len];
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// PIPELINE ENFORCER
// ═══════════════════════════════════════════════════════════════════════════════

pub const PipelineEnforcer = struct {
    current_step: PipelineStep,
    results: std.ArrayList(PipelineResult),
    allocator: Allocator,

    const Self = @This();

    pub fn init(allocator: Allocator) Self {
        return Self{
            .current_step = .specification,
            .results = std.ArrayList(PipelineResult).init(allocator),
            .allocator = allocator,
        };
    }

    pub fn deinit(self: *Self) void {
        self.results.deinit();
    }

    pub fn validateRequest(self: *Self, request: []const u8) bool {
        // Check if request tries to create blocked file types
        for (BlockedExtensions.LIST) |ext| {
            if (mem.indexOf(u8, request, ext) != null) {
                // Check if it's not just mentioning the extension
                if (mem.indexOf(u8, request, "create") != null or
                    mem.indexOf(u8, request, "write") != null or
                    mem.indexOf(u8, request, "make") != null)
                {
                    self.current_step = .block_manual_code;
                    return false;
                }
            }
        }
        return true;
    }

    pub fn getCurrentStep(self: *const Self) PipelineStep {
        return self.current_step;
    }

    pub fn advanceStep(self: *Self) void {
        self.current_step = switch (self.current_step) {
            .specification => .block_manual_code,
            .block_manual_code => .generate_tri,
            .generate_tri => .extract_zig,
            .extract_zig => .run_tests,
            .run_tests => .fix_problems,
            .fix_problems => .specification,
        };
    }

    pub fn getStepCount() u8 {
        return 6;
    }

    pub fn isValidVibeeFile(content: []const u8) bool {
        // Check for required fields
        const has_name = mem.indexOf(u8, content, "name:") != null;
        const has_version = mem.indexOf(u8, content, "version:") != null;
        return has_name and has_version;
    }

    pub fn hasZigOutput(content: []const u8) bool {
        return mem.indexOf(u8, content, "ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ:") != null;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "BlockedExtensions isBlocked" {
    try std.testing.expect(BlockedExtensions.isBlocked(".zig"));
    try std.testing.expect(BlockedExtensions.isBlocked(".py"));
    try std.testing.expect(BlockedExtensions.isBlocked(".js"));
    try std.testing.expect(!BlockedExtensions.isBlocked(".vibee"));
    try std.testing.expect(!BlockedExtensions.isBlocked(".tri"));
}

test "PipelineStep numbers" {
    try std.testing.expectEqual(@as(u8, 0), PipelineStep.specification.number());
    try std.testing.expectEqual(@as(u8, 1), PipelineStep.block_manual_code.number());
    try std.testing.expectEqual(@as(u8, 4), PipelineStep.run_tests.number());
}

test "PipelineStep names" {
    try std.testing.expectEqualStrings("Specification", PipelineStep.specification.name());
    try std.testing.expectEqualStrings("Run Tests", PipelineStep.run_tests.name());
}

test "PipelineEnforcer init" {
    const allocator = std.testing.allocator;
    var enforcer = PipelineEnforcer.init(allocator);
    defer enforcer.deinit();

    try std.testing.expectEqual(PipelineStep.specification, enforcer.getCurrentStep());
}

test "PipelineEnforcer validateRequest blocks .zig" {
    const allocator = std.testing.allocator;
    var enforcer = PipelineEnforcer.init(allocator);
    defer enforcer.deinit();

    const blocked = !enforcer.validateRequest("create hello.zig");
    try std.testing.expect(blocked);
}

test "PipelineEnforcer validateRequest allows .vibee" {
    const allocator = std.testing.allocator;
    var enforcer = PipelineEnforcer.init(allocator);
    defer enforcer.deinit();

    const allowed = enforcer.validateRequest("create hello.vibee");
    try std.testing.expect(allowed);
}

test "PipelineEnforcer advanceStep" {
    const allocator = std.testing.allocator;
    var enforcer = PipelineEnforcer.init(allocator);
    defer enforcer.deinit();

    enforcer.advanceStep();
    try std.testing.expectEqual(PipelineStep.block_manual_code, enforcer.getCurrentStep());
}

test "isValidVibeeFile" {
    const valid = "name: test\nversion: \"1.0.0\"";
    const invalid = "some random content";

    try std.testing.expect(PipelineEnforcer.isValidVibeeFile(valid));
    try std.testing.expect(!PipelineEnforcer.isValidVibeeFile(invalid));
}

test "hasZigOutput" {
    const with_output = "ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: \"\"\"code\"\"\"";
    const without_output = "name: test";

    try std.testing.expect(PipelineEnforcer.hasZigOutput(with_output));
    try std.testing.expect(!PipelineEnforcer.hasZigOutput(without_output));
}

test "Step count" {
    try std.testing.expectEqual(@as(u8, 6), PipelineEnforcer.getStepCount());
}

test "golden identity" {
    const phi_sq = PHI * PHI;
    const inv_phi_sq = 1.0 / phi_sq;
    const result = phi_sq + inv_phi_sq;
    try std.testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}
"""
