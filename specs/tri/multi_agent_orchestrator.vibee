name: multi_agent_orchestrator
version: "2.0.0"
language: zig
module: multi_agent_orchestrator

# ═══════════════════════════════════════════════════════════════════════════════
# Multi-Agent Orchestrator - Composite Architecture like AskUI/OAgent
# ═══════════════════════════════════════════════════════════════════════════════
# Specialized agents: Vision, DOM, Planning, Action, Verification
# Inspired by: AskUI (66.2% OSWorld), OAgent (71.6% WebArena)
# φ² + 1/φ² = 3 | PHOENIX = 999
# ═══════════════════════════════════════════════════════════════════════════════

types:
  AgentRole:
    fields:
      name: String
      description: String
      capabilities: List<String>
      priority: Int

  AgentMessage:
    fields:
      from_agent: String
      to_agent: String
      message_type: String
      payload: Object
      timestamp: Timestamp

  TaskDecomposition:
    fields:
      original_task: String
      subtasks: List<Object>
      dependencies: List<Object>
      estimated_steps: Int

  AgentState:
    fields:
      agent_name: String
      status: String
      current_task: String
      confidence: Float
      last_action: Object

  OrchestratorConfig:
    fields:
      max_agents: Int
      timeout_ms: Int
      retry_limit: Int
      parallel_execution: Bool

  ExecutionPlan:
    fields:
      steps: List<Object>
      assigned_agents: List<String>
      fallback_strategy: String

  AgentResult:
    fields:
      agent_name: String
      success: Bool
      result: Object
      confidence: Float
      execution_time_ms: Int

behaviors:
  - name: register_agent
    given: Agent implementation available
    when: Orchestrator initializing
    then: Add agent to registry with capabilities

  - name: decompose_task
    given: Complex task received
    when: Planning phase
    then: Break into subtasks with dependencies

  - name: assign_subtask
    given: Subtask ready and agents available
    when: Execution phase
    then: Route to best-suited agent based on capabilities

  - name: coordinate_vision_dom
    given: Element finding needed
    when: Vision and DOM agents available
    then: Try vision first, fall back to DOM if low confidence

  - name: parallel_analysis
    given: Multiple independent subtasks
    when: Parallel execution enabled
    then: Run agents concurrently and merge results

  - name: sequential_execution
    given: Subtasks have dependencies
    when: Order matters
    then: Execute in dependency order

  - name: handle_agent_failure
    given: Agent returns error or timeout
    when: Fault tolerance needed
    then: Retry or route to fallback agent

  - name: aggregate_results
    given: All subtasks completed
    when: Final result needed
    then: Combine agent results into unified response

  - name: verify_action
    given: Action executed by action agent
    when: Verification needed
    then: Use vision agent to confirm state change

  - name: escalate_to_human
    given: All agents fail or low confidence
    when: Human-in-loop enabled
    then: Request human intervention

  - name: learn_from_execution
    given: Task completed successfully or failed
    when: Learning enabled
    then: Update agent routing preferences
