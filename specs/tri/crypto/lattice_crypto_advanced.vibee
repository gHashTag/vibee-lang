# Lattice Cryptography Advanced - NTRU, FrodoKEM, NewHope
# Scientific basis for post-quantum security

name: lattice_crypto_advanced
version: "1.0.0"
language: zig
module: lattice_crypto_advanced

# ═══════════════════════════════════════════════════════════════
# LATTICE PROBLEMS (Security Foundation)
# ═══════════════════════════════════════════════════════════════

lattice_problems:
  lwe:
    name: "Learning With Errors"
    paper: "Regev, STOC 2005"
    hardness: "Worst-case to average-case reduction"
    quantum_security: "Believed secure"
    used_by: ["Kyber", "FrodoKEM", "NewHope"]
    
  ring_lwe:
    name: "Ring-LWE"
    paper: "Lyubashevsky, Peikert, Regev, EUROCRYPT 2010"
    advantage: "Smaller keys, faster operations"
    used_by: ["Kyber", "NewHope"]
    
  module_lwe:
    name: "Module-LWE"
    paper: "Langlois, Stehlé, DCC 2015"
    advantage: "Balance between LWE and Ring-LWE"
    used_by: ["Kyber", "Dilithium"]
    
  ntru:
    name: "NTRU Problem"
    paper: "Hoffstein, Pipher, Silverman, ANTS 1998"
    advantage: "26+ years of cryptanalysis"
    used_by: ["NTRU", "NTRU Prime"]
    
  sis:
    name: "Short Integer Solution"
    paper: "Ajtai, STOC 1996"
    used_by: ["Dilithium", "Falcon"]

# ═══════════════════════════════════════════════════════════════
# LATTICE SCHEMES
# ═══════════════════════════════════════════════════════════════

schemes:
  frodokem:
    name: "FrodoKEM"
    problem: "Plain LWE (conservative)"
    security_level: [1, 3, 5]
    key_sizes:
      level_1:
        public_key: 9616
        secret_key: 19888
        ciphertext: 9720
      level_3:
        public_key: 15632
        secret_key: 31296
        ciphertext: 15744
      level_5:
        public_key: 21520
        secret_key: 43088
        ciphertext: 21632
    performance:
      keygen_ms: 3.2
      encaps_ms: 3.8
      decaps_ms: 3.5
    paper: "NIST Round 3 Alternate"
    
  ntru:
    name: "NTRU"
    problem: "NTRU lattice"
    security_level: [1, 3, 5]
    key_sizes:
      hps2048509:
        public_key: 699
        secret_key: 935
        ciphertext: 699
      hps2048677:
        public_key: 930
        secret_key: 1234
        ciphertext: 930
      hps4096821:
        public_key: 1230
        secret_key: 1590
        ciphertext: 1230
    performance:
      keygen_ms: 0.15
      encaps_ms: 0.08
      decaps_ms: 0.12
    paper: "NIST Round 3 Finalist"
    
  newhope:
    name: "NewHope"
    problem: "Ring-LWE"
    security_level: [1, 5]
    key_sizes:
      newhope512:
        public_key: 928
        secret_key: 1888
        ciphertext: 1120
      newhope1024:
        public_key: 1824
        secret_key: 3680
        ciphertext: 2208
    performance:
      keygen_ms: 0.05
      encaps_ms: 0.07
      decaps_ms: 0.06
    paper: "USENIX Security 2016"

types:
  LatticeProblem:
    fields:
      name: String
      paper: String
      hardness: String
      quantum_secure: Bool

  LatticeScheme:
    fields:
      name: String
      problem: String
      pk_size: Int
      sk_size: Int
      ct_size: Int
      keygen_ms: Float
      encaps_ms: Float
      decaps_ms: Float

  SecurityLevel:
    fields:
      level: Int
      classical_bits: Int
      quantum_bits: Int
      description: String

behaviors:
  - name: compare_schemes
    given: "Two lattice schemes"
    when: "Comparison requested"
    then: "Returns size/speed tradeoffs"

  - name: select_scheme
    given: "Security requirements"
    when: "Scheme selection"
    then: "Returns optimal scheme"

ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: """
const std = @import("std");

// ═══════════════════════════════════════════════════════════════
// LATTICE CRYPTOGRAPHY ADVANCED
// NTRU, FrodoKEM, NewHope - Post-Quantum Security
// ═══════════════════════════════════════════════════════════════

pub const LatticeProblem = enum {
    LWE,
    RingLWE,
    ModuleLWE,
    NTRU,
    SIS,
};

pub const SecurityLevel = enum(u8) {
    Level1 = 1, // 128-bit classical, 64-bit quantum
    Level3 = 3, // 192-bit classical, 96-bit quantum
    Level5 = 5, // 256-bit classical, 128-bit quantum
};

pub const LatticeScheme = struct {
    name: []const u8,
    problem: LatticeProblem,
    pk_size: usize,
    sk_size: usize,
    ct_size: usize,
    keygen_ms: f64,
    encaps_ms: f64,
    decaps_ms: f64,
    security_level: SecurityLevel,
};

// Scheme Database
pub const schemes = [_]LatticeScheme{
    // FrodoKEM (Conservative LWE)
    .{ .name = "FrodoKEM-640", .problem = .LWE, .pk_size = 9616, .sk_size = 19888, .ct_size = 9720, .keygen_ms = 3.2, .encaps_ms = 3.8, .decaps_ms = 3.5, .security_level = .Level1 },
    .{ .name = "FrodoKEM-976", .problem = .LWE, .pk_size = 15632, .sk_size = 31296, .ct_size = 15744, .keygen_ms = 7.5, .encaps_ms = 8.2, .decaps_ms = 7.8, .security_level = .Level3 },
    .{ .name = "FrodoKEM-1344", .problem = .LWE, .pk_size = 21520, .sk_size = 43088, .ct_size = 21632, .keygen_ms = 14.0, .encaps_ms = 15.2, .decaps_ms = 14.5, .security_level = .Level5 },
    
    // NTRU (26+ years of cryptanalysis)
    .{ .name = "NTRU-HPS-2048-509", .problem = .NTRU, .pk_size = 699, .sk_size = 935, .ct_size = 699, .keygen_ms = 0.15, .encaps_ms = 0.08, .decaps_ms = 0.12, .security_level = .Level1 },
    .{ .name = "NTRU-HPS-2048-677", .problem = .NTRU, .pk_size = 930, .sk_size = 1234, .ct_size = 930, .keygen_ms = 0.20, .encaps_ms = 0.10, .decaps_ms = 0.15, .security_level = .Level3 },
    .{ .name = "NTRU-HPS-4096-821", .problem = .NTRU, .pk_size = 1230, .sk_size = 1590, .ct_size = 1230, .keygen_ms = 0.35, .encaps_ms = 0.15, .decaps_ms = 0.22, .security_level = .Level5 },
    
    // NewHope (Ring-LWE)
    .{ .name = "NewHope-512", .problem = .RingLWE, .pk_size = 928, .sk_size = 1888, .ct_size = 1120, .keygen_ms = 0.05, .encaps_ms = 0.07, .decaps_ms = 0.06, .security_level = .Level1 },
    .{ .name = "NewHope-1024", .problem = .RingLWE, .pk_size = 1824, .sk_size = 3680, .ct_size = 2208, .keygen_ms = 0.10, .encaps_ms = 0.14, .decaps_ms = 0.12, .security_level = .Level5 },
    
    // ML-KEM (Module-LWE, NIST Standard)
    .{ .name = "ML-KEM-512", .problem = .ModuleLWE, .pk_size = 800, .sk_size = 1632, .ct_size = 768, .keygen_ms = 0.025, .encaps_ms = 0.030, .decaps_ms = 0.028, .security_level = .Level1 },
    .{ .name = "ML-KEM-768", .problem = .ModuleLWE, .pk_size = 1184, .sk_size = 2400, .ct_size = 1088, .keygen_ms = 0.035, .encaps_ms = 0.042, .decaps_ms = 0.040, .security_level = .Level3 },
    .{ .name = "ML-KEM-1024", .problem = .ModuleLWE, .pk_size = 1568, .sk_size = 3168, .ct_size = 1568, .keygen_ms = 0.045, .encaps_ms = 0.052, .decaps_ms = 0.048, .security_level = .Level5 },
};

pub fn getSchemeByName(name: []const u8) ?LatticeScheme {
    for (schemes) |s| {
        if (std.mem.eql(u8, s.name, name)) return s;
    }
    return null;
}

pub fn getSchemesByProblem(problem: LatticeProblem) []const LatticeScheme {
    // Return count for testing
    var count: usize = 0;
    for (schemes) |s| {
        if (s.problem == problem) count += 1;
    }
    _ = count;
    return &schemes; // Simplified
}

pub fn getSmallestKeyScheme() LatticeScheme {
    var min_size: usize = std.math.maxInt(usize);
    var min_scheme: LatticeScheme = schemes[0];
    for (schemes) |s| {
        if (s.pk_size < min_size) {
            min_size = s.pk_size;
            min_scheme = s;
        }
    }
    return min_scheme;
}

pub fn getFastestScheme() LatticeScheme {
    var min_time: f64 = std.math.floatMax(f64);
    var fastest: LatticeScheme = schemes[0];
    for (schemes) |s| {
        const total = s.keygen_ms + s.encaps_ms + s.decaps_ms;
        if (total < min_time) {
            min_time = total;
            fastest = s;
        }
    }
    return fastest;
}

pub fn getAverageKeySize() f64 {
    var total: f64 = 0.0;
    for (schemes) |s| {
        total += @as(f64, @floatFromInt(s.pk_size));
    }
    return total / @as(f64, @floatFromInt(schemes.len));
}

// ═══════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════

test "11 lattice schemes defined" {
    try std.testing.expectEqual(@as(usize, 11), schemes.len);
}

test "FrodoKEM-640 exists" {
    const frodo = getSchemeByName("FrodoKEM-640");
    try std.testing.expect(frodo != null);
    try std.testing.expectEqual(@as(usize, 9616), frodo.?.pk_size);
}

test "NTRU has smallest keys" {
    const smallest = getSmallestKeyScheme();
    try std.testing.expect(std.mem.eql(u8, smallest.name, "NTRU-HPS-2048-509"));
}

test "ML-KEM-512 is fastest" {
    const fastest = getFastestScheme();
    try std.testing.expect(std.mem.eql(u8, fastest.name, "ML-KEM-512"));
}

test "FrodoKEM uses plain LWE" {
    const frodo = getSchemeByName("FrodoKEM-640");
    try std.testing.expect(frodo != null);
    try std.testing.expectEqual(LatticeProblem.LWE, frodo.?.problem);
}

test "ML-KEM uses Module-LWE" {
    const mlkem = getSchemeByName("ML-KEM-1024");
    try std.testing.expect(mlkem != null);
    try std.testing.expectEqual(LatticeProblem.ModuleLWE, mlkem.?.problem);
}

test "NewHope uses Ring-LWE" {
    const nh = getSchemeByName("NewHope-512");
    try std.testing.expect(nh != null);
    try std.testing.expectEqual(LatticeProblem.RingLWE, nh.?.problem);
}

test "Average key size > 3000" {
    const avg = getAverageKeySize();
    try std.testing.expect(avg > 3000.0);
}

test "FrodoKEM-1344 is Level 5" {
    const frodo = getSchemeByName("FrodoKEM-1344");
    try std.testing.expect(frodo != null);
    try std.testing.expectEqual(SecurityLevel.Level5, frodo.?.security_level);
}

test "NTRU keygen < 1ms" {
    const ntru = getSchemeByName("NTRU-HPS-2048-509");
    try std.testing.expect(ntru != null);
    try std.testing.expect(ntru.?.keygen_ms < 1.0);
}

test "FrodoKEM keygen > 3ms" {
    const frodo = getSchemeByName("FrodoKEM-640");
    try std.testing.expect(frodo != null);
    try std.testing.expect(frodo.?.keygen_ms > 3.0);
}

test "ML-KEM-1024 pk_size 1568" {
    const mlkem = getSchemeByName("ML-KEM-1024");
    try std.testing.expect(mlkem != null);
    try std.testing.expectEqual(@as(usize, 1568), mlkem.?.pk_size);
}
"""
