# VIBEE v69 Agent Orchestrator Specification
# Unified Agent Coordination & Task Management
# φ² + 1/φ² = 3 | PHOENIX = 999

name: agent_orchestrator_v69
version: "69.0.0"
language: zig
module: agent_orchestrator_v69

constants:
  PHI: 1.618033988749895
  TRINITY: 3
  PHOENIX: 999
  MAX_CONCURRENT_TASKS: 10
  MAX_TASK_DEPTH: 5

types:
  AgentRole:
    values:
      - planner       # Task decomposition
      - executor      # Tool execution
      - reviewer      # Code review
      - debugger      # Error analysis
      - documenter    # Documentation
      - tester        # Test generation
      - refactorer    # Code improvement

  TaskStatus:
    values:
      - queued
      - planning
      - executing
      - reviewing
      - completed
      - failed
      - blocked

  TaskPriority:
    values: [critical, high, normal, low, background]

  Task:
    fields:
      id: String
      description: String
      role: String
      status: String
      priority: String
      parent_id: Option<String>
      subtasks: List<String>
      dependencies: List<String>
      created_at: Int
      started_at: Option<Int>
      completed_at: Option<Int>
      result: Option<String>
      error: Option<String>

  AgentState:
    fields:
      role: String
      current_task: Option<String>
      tasks_completed: Int
      tasks_failed: Int
      is_busy: Bool

  OrchestratorConfig:
    fields:
      max_concurrent: Int
      max_depth: Int
      auto_retry: Bool
      max_retries: Int
      timeout_ms: Int

  ExecutionPlan:
    fields:
      task_id: String
      steps: List<String>
      estimated_duration_ms: Int
      required_tools: List<String>
      required_context: List<String>

# === ORCHESTRATION PATTERNS ===
patterns:
  sequential:
    description: "Execute tasks one after another"
    use_when: "Tasks have dependencies"

  parallel:
    description: "Execute independent tasks concurrently"
    use_when: "Tasks are independent"

  pipeline:
    description: "Chain task outputs to inputs"
    use_when: "Data flows through stages"

  scatter_gather:
    description: "Split work, then combine results"
    use_when: "Parallelizable with aggregation"

  saga:
    description: "Long-running with compensation"
    use_when: "Need rollback on failure"

# === AGENT COORDINATION ===
coordination:
  handoff:
    description: "Transfer task between agents"
    triggers:
      - role_mismatch
      - expertise_needed
      - load_balancing

  escalation:
    description: "Escalate to higher capability"
    triggers:
      - repeated_failure
      - complexity_threshold
      - user_request

  delegation:
    description: "Delegate subtasks to specialists"
    triggers:
      - task_decomposition
      - parallel_opportunity

# === BEHAVIORS ===
behaviors:
  - name: plan_task
    given: "User request"
    when: "New task received"
    then: "Decompose into subtasks with dependencies"

  - name: assign_agent
    given: "Task and available agents"
    when: "Task ready for execution"
    then: "Assign best-fit agent"

  - name: execute_task
    given: "Assigned task"
    when: "Agent available"
    then: "Execute and report result"

  - name: handle_failure
    given: "Failed task"
    when: "Execution failed"
    then: "Retry, escalate, or mark failed"

  - name: aggregate_results
    given: "Completed subtasks"
    when: "All subtasks done"
    then: "Combine results for parent task"

test_cases:
  - name: simple_task
    input: {description: "Read file", role: "executor"}
    expected: {status: "completed"}

  - name: decomposed_task
    input: {description: "Refactor module", role: "planner"}
    expected: {subtasks_count: ">1"}

  - name: parallel_execution
    input: {tasks: 3, pattern: "parallel"}
    expected: {concurrent: true}
