# ═══════════════════════════════════════════════════════════════════════════════
# TYPE INFERENCE v212 - Bidirectional Type Inference
# ═══════════════════════════════════════════════════════════════════════════════
# Based on: Hindley-Milner, Bidirectional Typing
# Scientific: ICFP 2023, POPL 2024 (Algebraic Subtyping)
# PAS Pattern: PRE + ALG
# φ² + 1/φ² = 3 | PHOENIX = 999
# ═══════════════════════════════════════════════════════════════════════════════

name: type_inference
version: "2.1.2"
language: zig
module: type_inference

sacred_constants:
  phi: 1.618033988749895
  phi_inv: 0.618033988749895
  phi_sq: 2.618033988749895
  trinity: 3.0
  phoenix: 999

creation_pattern:
  source: UntypedAST
  transformer: TypeInferrer
  result: TypedAST

types:
  TypeKind:
    enum:
      - primitive
      - function
      - generic
      - union
      - intersection
      - unknown

  Type:
    fields:
      kind: TypeKind
      name: String
      params: List<Type>?

  TypeVar:
    fields:
      id: Int
      bound: Type?
      constraints: List<String>

  Constraint:
    fields:
      left: Type
      right: Type
      kind: String

  Substitution:
    fields:
      var_id: Int
      resolved: Type

  TypeEnv:
    fields:
      bindings: Map<String, Type>
      parent: TypeEnv?

  InferenceResult:
    fields:
      typed_ast: String
      substitutions: List<Substitution>
      errors: List<String>

behaviors:
  - name: infer_type
    given: "Expression and environment"
    when: "Inference requested"
    then: "Infer expression type"
    pas_pattern: PRE
    complexity: O(n)
    test_cases:
      - name: test_infer
        input: '{"expr": "x + 1", "env": {"x": "Int"}}'
        expected: '{"type": "Int"}'

  - name: check_type
    given: "Expression and expected type"
    when: "Type checking"
    then: "Verify type matches"
    pas_pattern: ALG
    complexity: O(n)
    test_cases:
      - name: test_check
        input: '{"expr": "42", "expected": "Int"}'
        expected: '{"valid": true}'

  - name: unify_types
    given: "Two types"
    when: "Unification requested"
    then: "Find most general unifier"
    pas_pattern: ALG
    complexity: O(n)
    test_cases:
      - name: test_unify
        input: '{"t1": "List<a>", "t2": "List<Int>"}'
        expected: '{"subst": {"a": "Int"}}'

  - name: generalize
    given: "Type and environment"
    when: "Generalization requested"
    then: "Create polymorphic type"
    pas_pattern: PRE
    complexity: O(n)
    test_cases:
      - name: test_generalize
        input: '{"type": "a -> a"}'
        expected: '{"scheme": "forall a. a -> a"}'

  - name: instantiate
    given: "Type scheme"
    when: "Instantiation requested"
    then: "Create fresh type variables"
    pas_pattern: PRE
    complexity: O(1)
    test_cases:
      - name: test_instantiate
        input: '{"scheme": "forall a. a -> a"}'
        expected: '{"type": "t1 -> t1"}'

  - name: solve_constraints
    given: "Constraint set"
    when: "Solving requested"
    then: "Find satisfying substitution"
    pas_pattern: ALG
    complexity: O(n^2)
    test_cases:
      - name: test_solve
        input: '{"constraints": [...]}'
        expected: '{"solution": {...}}'

# ═══════════════════════════════════════════════════════════════════════════════
# φ² + 1/φ² = 3 | PHOENIX = 999
# ═══════════════════════════════════════════════════════════════════════════════
