# CDP + WebArena Integration
# Real E2E system for WebArena benchmark
# φ² + 1/φ² = 3

name: cdp_webarena_integration
version: "1.0.0"
language: zig
module: cdp_webarena_integration

sacred_formula:
  phi: 1.618033988749895
  identity: "φ² + 1/φ² = 3"
  phoenix: 999

creation_pattern:
  source: WebArenaTask + CDPClient
  transformer: ReActAgent
  result: WebArenaRunner

types:
  WebArenaRunnerConfig:
    description: "Configuration for WebArena runner"
    fields:
      cdp_host: String
      cdp_port: Int
      webarena_path: String
      task_filter: Option<String>
      max_steps: Int
      timeout_ms: Int
      verbose: Bool

  AgentStep:
    description: "Single agent execution step"
    fields:
      step_number: Int
      observation: String
      thought: String
      action: String
      action_result: String

  WebArenaResult:
    description: "Result of running a WebArena task"
    fields:
      task_id: Int
      task_name: String
      success: Bool
      steps_taken: Int
      elapsed_ms: Int
      cdp_latency_ms: Int
      final_answer: Option<String>

  BenchmarkResults:
    description: "Aggregated benchmark statistics"
    fields:
      total_tasks: Int
      completed_tasks: Int
      successful_tasks: Int
      failed_tasks: Int
      avg_steps: Float
      avg_latency_ms: Float
      throughput_per_hour: Float

behaviors:
  - name: initialize_runner
    given: "Runner configuration"
    when: "init called"
    then: "CDP connected, WebArena tasks loaded"
    implementation: |
      const cdp_config = CDPConfig{
        .host = config.cdp_host,
        .port = config.cdp_port,
        .timeout_ms = config.timeout_ms,
      };
      
      self.cdp = try CDPBrowserController.init(self.allocator, cdp_config);
      try self.cdp.connect();
      
      self.parser = try WebArenaTaskParser.init(self.allocator, WebArenaConfig{
        .webarena_path = config.webarena_path,
        .task_filter = config.task_filter,
      });
      
      self.tasks = try self.parser.loadTasks();
      
      if (config.verbose) {
        std.debug.print("Loaded {d} WebArena tasks\n", .{self.tasks.len});
      }
    test_cases:
      - name: test_init_default_config
        input: { config: { cdp_host: "localhost", cdp_port: 9222 }}
        expected: { initialized: true, tasks_loaded: true }

  - name: run_webarena_task
    given: "Task ID"
    when: "run called"
    then: "Task executed via ReAct loop"
    implementation: |
      const task = try self.parser.getTaskById(task_id);
      const start_time = std.time.milliTimestamp();
      
      var steps_taken: u32 = 0;
      var success = false;
      var final_answer: ?[]const u8 = null;
      
      try self.cdp.navigate(task.start_url);
      
      while (steps_taken < config.max_steps) : (steps_taken += 1) {
        const observation = try self.getObservation();
        const thought = try self.generateThought(observation, task);
        const action = try self.generateAction(thought);
        
        try self.executeAction(action);
        
        if (action.is_stop) {
          success = true;
          final_answer = action.answer;
          break;
        }
      }
      
      const elapsed = std.time.milliTimestamp() - start_time;
      
      return WebArenaResult{
        .task_id = task.task_id,
        .task_name = task.task_name,
        .success = success,
        .steps_taken = steps_taken,
        .elapsed_ms = elapsed,
        .cdp_latency_ms = elapsed / steps_taken,
        .final_answer = final_answer,
      };
    test_cases:
      - name: test_run_simple_task
        input: { task_id: 1 }
        expected: { completed: true }
      - name: test_run_timeout_task
        input: { task_id: 999, max_steps: 5 }
        expected: { completed: false, timeout: true }

  - name: get_observation
    given: "Current page"
    when: "observation needed"
    then: "Returns page snapshot"
    implementation: |
      const snapshot = try self.cdp.getPageSnapshot();
      const observation = try std.fmt.allocPrint(self.allocator,
        \\Page: {s}
        \\URL: {s}
        \\Visible text: {s}
      , .{ snapshot.title, snapshot.url, snapshot.visible_text });
      
      return observation;
    test_cases:
      - name: test_observation_format
        input: {}
        expected: { has_url: true, has_text: true }

  - name: generate_thought
    given: "Observation and task"
    when: "reasoning needed"
    then: "Returns thought about next action"
    implementation: |
      const thought = try std.fmt.allocPrint(self.allocator,
        "I am on page {s}. The task is: {s}. What should I do next?",
        .{observation, task.intent });
      
      return thought;
    test_cases:
      - name: test_generate_simple_thought
        input: { observation: "Page: Example", task_intent: "Find button" }
        expected: { thought_length: 50 }

  - name: generate_action
    given: "Thought"
    when: "action needed"
    then: "Returns parsed action"
    implementation: |
      if (std.mem.indexOf(u8, thought, "click")) |_| {
        return Action{ .action_type = .click, .target = "#button" };
      }
      if (std.mem.indexOf(u8, thought, "type")) |_| {
        return Action{ .action_type = .type, .text = "test" };
      }
      if (std.mem.indexOf(u8, thought, "answer")) |_| {
        return Action{ .action_type = .stop, .answer = "Final answer" };
      }
      
      return Action{ .action_type = .wait, .target = "" };
    test_cases:
      - name: test_parse_click_action
        input: { thought: "I should click the button" }
        expected: { action: "click" }

  - name: execute_action
    given: "Action"
    when: "execution needed"
    then: "Action performed via CDP"
    implementation: |
      switch (action.action_type) {
        .click => {
          try self.cdp.click(100.0, 200.0);
        },
        .type => {
          try self.cdp.typeText(action.text);
        },
        .navigate => {
          try self.cdp.navigate(action.url);
        },
        .wait => {
          std.Thread.sleep(1000 * std.time.ns_per_ms);
        },
        .stop => {
          return;
        },
      }
    test_cases:
      - name: test_execute_click
        input: { action: { action_type: "click", x: 100.0, y: 200.0 }}
        expected: { executed: true }
      - name: test_execute_type
        input: { action: { action_type: "type", text: "hello" }}
        expected: { executed: true }

  - name: run_benchmark
    given: "Task list"
    when: "benchmark called"
    then: "All tasks executed with statistics"
    implementation: |
      var results = std.ArrayList(WebArenaResult).init(self.allocator);
      
      for (self.tasks) |task| {
        const result = try self.runTask(task.task_id);
        try results.append(result);
      }
      
      return try self.calculateStatistics(results);
    test_cases:
      - name: test_run_3_tasks
        input: { tasks: [1, 2, 3] }
        expected: { completed: 3 }

  - name: calculate_statistics
    given: "Task results"
    when: "stats needed"
    then: "Returns aggregated metrics"
    implementation: |
      var stats = BenchmarkResults{};
      
      for (results) |result| {
        stats.total_tasks += 1;
        if (result.success) stats.successful_tasks += 1 else stats.failed_tasks += 1;
        stats.avg_steps = (stats.avg_steps + result.steps_taken) / 2;
        stats.avg_latency_ms = (stats.avg_latency_ms + result.cdp_latency_ms) / 2;
      }
      
      stats.throughput_per_hour = 3600000.0 / stats.avg_latency_ms;
      
      return stats;
    test_cases:
      - name: test_calculate_simple_stats
        input: { results: [{ success: true, elapsed_ms: 1000 }, { success: false, elapsed_ms: 2000 }] }
        expected: { success_rate: 0.5, avg_latency: 1500.0 }

pas_analysis:
  current_complexity: "O(n) sequential task execution"
  theoretical_lower_bound: "O(1) with parallel tasks"
  applicable_patterns: [D&C, MLS]
  predicted_improvement: "10x with 10 parallel tasks"
  confidence: 0.90
  reasoning: "WebArena tasks can run in parallel on separate browser instances"

self_evolution:
  enabled: true
  mutation_rate: 0.0382
  fitness_function: "task_throughput"
  generation: 1
