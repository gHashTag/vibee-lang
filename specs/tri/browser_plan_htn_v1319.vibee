# VIBEE Specification: HTN Planning v1319
# YOLO XV - Production Ascension
# Based on: Hierarchical Task Network Planning

name: browser_plan_htn
version: "1319"
language: zig
module: browser_plan_htn

types:
  HTNDomain:
    fields:
      name: String
      operators: Map
      methods: Map
      axioms: List

  HTNOperator:
    fields:
      name: String
      parameters: List
      preconditions: List
      effects: List
      cost: Float

  HTNMethod:
    fields:
      name: String
      task: String
      parameters: List
      preconditions: List
      subtasks: List

  HTNTask:
    fields:
      name: String
      parameters: List
      primitive: Bool

  HTNPlan:
    fields:
      actions: List
      total_cost: Float
      depth: Int

  HTNState:
    fields:
      facts: Map
      objects: Map

  HTNProblem:
    fields:
      domain: HTNDomain
      initial_state: HTNState
      tasks: List

behaviors:
  - name: create_domain
    given: "Domain name"
    when: "Creating HTN domain"
    then: "Returns empty domain"

  - name: add_operator
    given: "Domain, operator"
    when: "Adding primitive operator"
    then: "Registers operator"

  - name: add_method
    given: "Domain, method"
    when: "Adding decomposition method"
    then: "Registers method"

  - name: create_problem
    given: "Domain, initial state, tasks"
    when: "Creating planning problem"
    then: "Returns problem instance"

  - name: plan
    given: "Problem"
    when: "Finding plan"
    then: "Returns action sequence"

  - name: decompose_task
    given: "Domain, state, task"
    when: "Decomposing compound task"
    then: "Returns subtasks"

  - name: apply_operator
    given: "State, operator, bindings"
    when: "Applying primitive action"
    then: "Returns new state"

  - name: check_preconditions
    given: "State, conditions"
    when: "Checking preconditions"
    then: "Returns true if satisfied"

  - name: unify
    given: "Pattern, fact"
    when: "Unifying terms"
    then: "Returns bindings or failure"

  - name: get_applicable_methods
    given: "Domain, state, task"
    when: "Finding applicable methods"
    then: "Returns matching methods"

creation_pattern:
  source: HTNProblem
  transformer: HTNPlanner
  result: ActionPlan

scientific_references:
  - author: "Erol, Hendler, Nau"
    title: "HTN Planning: Complexity and Expressivity"
    venue: "AAAI"
    year: 1994

test_cases:
  - name: test_simple_decomposition
    input:
      task: "travel(A, B)"
      methods: ["drive", "fly"]
    expected:
      decomposed: true

  - name: test_operator_application
    input:
      operator: "move"
      preconditions: ["at(A)"]
      state: {at: "A"}
    expected:
      applicable: true

  - name: test_plan_finding
    input:
      initial: {at: "home"}
      goal_task: "be_at(work)"
    expected:
      plan_found: true

  - name: test_method_ordering
    input:
      methods: ["fast", "cheap"]
      preference: "cost"
    expected:
      cheap_first: true

  - name: test_recursive_decomposition
    input:
      task: "build_house"
      depth: 5
    expected:
      fully_decomposed: true

  - name: test_no_plan
    input:
      impossible_task: true
    expected:
      plan_found: false

  - name: test_plan_cost
    input:
      operators: [{cost: 10}, {cost: 5}]
    expected:
      total_cost: 15

  - name: test_backtracking
    input:
      dead_end_method: true
    expected:
      alternative_found: true
