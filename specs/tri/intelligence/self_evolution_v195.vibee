# ═══════════════════════════════════════════════════════════════════════════════
# SELF-EVOLUTION v195 - Specifications That Improve Themselves
# ═══════════════════════════════════════════════════════════════════════════════
# Scientific: Genetic programming, evolutionary algorithms
# Unique to VIBEE: Specs that generate better specs
# PAS Pattern: MLS + ALG + D&C
# φ² + 1/φ² = 3 | PHOENIX = 999
# ═══════════════════════════════════════════════════════════════════════════════

name: self_evolution
version: "1.9.5"
language: zig
module: self_evolution

sacred_constants:
  phi: 1.618033988749895
  phi_inv: 0.618033988749895
  phi_sq: 2.618033988749895
  trinity: 3.0
  phoenix: 999

creation_pattern:
  source: SpecPopulation
  transformer: EvolutionEngine
  result: EvolvedSpec

# ═══════════════════════════════════════════════════════════════════════════════
# TYPES
# ═══════════════════════════════════════════════════════════════════════════════

types:
  EvolutionStrategy:
    enum:
      - genetic_algorithm
      - evolutionary_strategy
      - genetic_programming
      - neuroevolution

  FitnessMetric:
    enum:
      - code_quality
      - test_coverage
      - performance
      - readability
      - maintainability

  Mutation:
    enum:
      - add_type
      - remove_type
      - modify_type
      - add_behavior
      - remove_behavior
      - modify_behavior
      - add_test
      - optimize_pattern

  SpecIndividual:
    fields:
      id: String
      spec: String
      generation: Int
      fitness: Float
      parent_ids: List<String>
      mutations: List<Mutation>

  SpecPopulation:
    fields:
      individuals: List<SpecIndividual>
      generation: Int
      best_fitness: Float
      avg_fitness: Float

  EvolutionConfig:
    fields:
      population_size: Int = 50
      generations: Int = 100
      mutation_rate: Float = 0.1
      crossover_rate: Float = 0.7
      elitism: Int = 5
      fitness_metrics: List<FitnessMetric>

  EvolvedSpec:
    fields:
      spec: String
      fitness: Float
      improvements: List<String>
      generation: Int
      lineage: List<String>

  EvolutionStats:
    fields:
      generations_run: Int
      best_fitness: Float
      improvement_rate: Float
      convergence_generation: Int?

# ═══════════════════════════════════════════════════════════════════════════════
# BEHAVIORS
# ═══════════════════════════════════════════════════════════════════════════════

behaviors:
  - name: initialize_population
    given: "Base spec and config"
    when: "Evolution starts"
    then: "Create initial population"
    pas_pattern: D&C
    complexity: O(n)
    test_cases:
      - name: test_init
        input: '{"base_spec": "...", "population_size": 50}'
        expected: '{"population": 50}'

  - name: evaluate_fitness
    given: "Spec individual"
    when: "Fitness evaluation needed"
    then: "Return fitness score"
    pas_pattern: ALG
    complexity: O(n)
    test_cases:
      - name: test_fitness
        input: '{"spec": "..."}'
        expected: '{"fitness": ">0"}'

  - name: select_parents
    given: "Population"
    when: "Selection needed"
    then: "Return selected parents"
    pas_pattern: ALG
    complexity: O(n)
    test_cases:
      - name: test_select
        input: '{"population": [...]}'
        expected: '{"parents": 2}'

  - name: crossover
    given: "Two parent specs"
    when: "Crossover needed"
    then: "Return child spec"
    pas_pattern: D&C
    complexity: O(n)
    test_cases:
      - name: test_crossover
        input: '{"parent1": "...", "parent2": "..."}'
        expected: '{"child": "..."}'

  - name: mutate
    given: "Spec individual"
    when: "Mutation needed"
    then: "Return mutated spec"
    pas_pattern: ALG
    complexity: O(n)
    test_cases:
      - name: test_mutate
        input: '{"spec": "...", "mutation_rate": 0.1}'
        expected: '{"mutated": true}'

  - name: evolve_generation
    given: "Current population"
    when: "Next generation needed"
    then: "Return evolved population"
    pas_pattern: D&C
    complexity: O(n^2)
    test_cases:
      - name: test_evolve
        input: '{"population": [...], "generation": 1}'
        expected: '{"generation": 2}'

  - name: check_convergence
    given: "Evolution history"
    when: "Convergence check needed"
    then: "Return convergence status"
    pas_pattern: ALG
    complexity: O(n)
    test_cases:
      - name: test_converge
        input: '{"history": [0.5, 0.6, 0.7, 0.7, 0.7]}'
        expected: '{"converged": true}'

# ═══════════════════════════════════════════════════════════════════════════════
# MUTATION OPERATORS
# ═══════════════════════════════════════════════════════════════════════════════

mutation_operators:
  add_type:
    probability: 0.15
    description: "Add a new type definition"
    constraints:
      - "Type name must be unique"
      - "Fields must have valid types"

  modify_type:
    probability: 0.20
    description: "Modify existing type"
    operations:
      - "Add field"
      - "Remove field"
      - "Change field type"

  add_behavior:
    probability: 0.15
    description: "Add a new behavior"
    constraints:
      - "Behavior name must be unique"
      - "Must have given/when/then"

  modify_behavior:
    probability: 0.20
    description: "Modify existing behavior"
    operations:
      - "Add test case"
      - "Change PAS pattern"
      - "Optimize complexity"

  optimize_pattern:
    probability: 0.10
    description: "Apply PAS optimization"
    patterns:
      - "D&C for recursive problems"
      - "PRE for repeated computations"
      - "HSH for lookups"

# ═══════════════════════════════════════════════════════════════════════════════
# FITNESS FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

fitness_functions:
  code_quality:
    weight: 0.25
    metrics:
      - "Compiles without errors"
      - "No warnings"
      - "Follows conventions"

  test_coverage:
    weight: 0.25
    metrics:
      - "All behaviors have tests"
      - "Edge cases covered"
      - "Tests pass"

  performance:
    weight: 0.20
    metrics:
      - "Optimal complexity"
      - "Efficient patterns"
      - "No redundant operations"

  readability:
    weight: 0.15
    metrics:
      - "Clear naming"
      - "Good documentation"
      - "Logical structure"

  maintainability:
    weight: 0.15
    metrics:
      - "Low coupling"
      - "High cohesion"
      - "Modular design"

# ═══════════════════════════════════════════════════════════════════════════════
# EVOLUTION EXAMPLES
# ═══════════════════════════════════════════════════════════════════════════════

evolution_examples:
  - name: "Optimize sorting spec"
    initial_fitness: 0.6
    final_fitness: 0.95
    generations: 50
    improvements:
      - "Added D&C pattern"
      - "Added edge case tests"
      - "Optimized complexity O(n²) → O(n log n)"

  - name: "Improve parser spec"
    initial_fitness: 0.7
    final_fitness: 0.92
    generations: 30
    improvements:
      - "Added PRE pattern for tokenization"
      - "Added error handling behaviors"
      - "Improved test coverage"

# ═══════════════════════════════════════════════════════════════════════════════
# SCIENTIFIC REFERENCES
# ═══════════════════════════════════════════════════════════════════════════════

references:
  - title: "Genetic Programming"
    authors: "Koza, J.R."
    year: 1992
    description: "Foundation of program evolution"

  - title: "Neuroevolution"
    authors: "Stanley, K.O."
    year: 2002
    description: "NEAT algorithm"

  - title: "AutoML"
    authors: "Hutter et al."
    year: 2019
    description: "Automated machine learning"

# ═══════════════════════════════════════════════════════════════════════════════
# φ² + 1/φ² = 3 | PHOENIX = 999
# ═══════════════════════════════════════════════════════════════════════════════
