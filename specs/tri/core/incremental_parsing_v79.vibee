# Incremental Parsing V79 - O(Δn) Complexity
# Parse only changed portions of VIBEE specifications

name: incremental_parsing_v79
version: "79.0.0"
language: zig
module: incremental_parsing

creation_pattern:
  source: EditedSpec
  transformer: IncrementalParser
  result: UpdatedAST

# PAS Analysis
pas_patterns:
  - pattern: D&C
    application: "Tree-based incremental updates"
    speedup: "10-100x for small edits"
  - pattern: PRE
    application: "Cached parse trees"
    speedup: "5x"
  - pattern: HSH
    application: "Content-addressable AST nodes"
    speedup: "3x"

types:
  Edit:
    description: "A single edit operation"
    fields:
      start_byte: Int
      end_byte: Int
      new_text: String
      
  EditSequence:
    description: "Sequence of edits"
    fields:
      edits: List<Edit>
      base_version: Int
      new_version: Int

  ASTNode:
    description: "AST node with hash"
    fields:
      kind: NodeKind
      start: Int
      end: Int
      hash: Int
      children: List<ASTNode>
      
  NodeKind:
    description: "Types of AST nodes"
    variants:
      - Spec
      - Name
      - Version
      - Types
      - TypeDef
      - Field
      - Behaviors
      - Behavior
      - TestCase

  ParseTree:
    description: "Complete parse tree with metadata"
    fields:
      root: ASTNode
      version: Int
      source_hash: Int
      node_count: Int

  IncrementalState:
    description: "State for incremental parsing"
    fields:
      tree: ParseTree
      dirty_ranges: List<Range>
      reparse_queue: List<ASTNode>

  Range:
    description: "Byte range in source"
    fields:
      start: Int
      end: Int

  DiffResult:
    description: "Result of tree diff"
    fields:
      added_nodes: List<ASTNode>
      removed_nodes: List<ASTNode>
      modified_nodes: List<ASTNode>

  CacheEntry:
    description: "Cached parse result"
    fields:
      hash: Int
      node: ASTNode
      hit_count: Int
      last_access: Timestamp

  ParseCache:
    description: "LRU cache for parsed nodes"
    fields:
      entries: Map<Int, CacheEntry>
      max_size: Int
      hit_rate: Float

  IncrementalConfig:
    description: "Configuration for incremental parsing"
    fields:
      cache_size: Int
      reparse_threshold: Int
      enable_hashing: Bool

behaviors:
  - name: apply_edit
    given: "Parse tree and edit"
    when: "Edit applied"
    then: "Updated tree with minimal reparse"
    complexity: "O(Δn + log n)"
    test_cases:
      - name: single_char_edit
        input: "Change 'name: test' to 'name: test2'"
        expected: "Only Value node reparsed"
      - name: add_field
        input: "Add new field to type"
        expected: "Only TypeDef subtree reparsed"

  - name: compute_dirty_ranges
    given: "Edit sequence"
    when: "Dirty range computation"
    then: "Minimal ranges needing reparse"
    complexity: "O(edits)"
    test_cases:
      - name: adjacent_edits
        input: "Two adjacent edits"
        expected: "Merged into single range"
      - name: disjoint_edits
        input: "Edits at start and end"
        expected: "Two separate ranges"

  - name: find_reparse_root
    given: "Dirty range and tree"
    when: "Finding minimal reparse subtree"
    then: "Smallest subtree containing range"
    complexity: "O(log n)"
    test_cases:
      - name: field_change
        input: "Edit within field"
        expected: "Field node as root"
      - name: type_change
        input: "Edit spans multiple fields"
        expected: "TypeDef node as root"

  - name: hash_node
    given: "AST node"
    when: "Computing content hash"
    then: "Deterministic hash for caching"
    complexity: "O(node_size)"
    test_cases:
      - name: leaf_hash
        input: "Leaf node 'name'"
        expected: "hash(kind + content)"
      - name: tree_hash
        input: "Node with children"
        expected: "hash(kind + children_hashes)"

  - name: lookup_cache
    given: "Node hash"
    when: "Cache lookup"
    then: "Cached node or miss"
    complexity: "O(1)"
    test_cases:
      - name: cache_hit
        input: "Previously parsed node"
        expected: "Return cached, hit_count++"
      - name: cache_miss
        input: "New node"
        expected: "Return null"

  - name: reparse_subtree
    given: "Dirty subtree root"
    when: "Incremental reparse"
    then: "New subtree with cache reuse"
    complexity: "O(Δn)"
    test_cases:
      - name: small_change
        input: "Single field edit"
        expected: "Reparse ~10 nodes"
      - name: large_change
        input: "New type added"
        expected: "Reparse ~50 nodes"

  - name: merge_trees
    given: "Old tree and new subtree"
    when: "Tree merge"
    then: "Updated tree with new subtree"
    complexity: "O(log n)"
    test_cases:
      - name: replace_leaf
        input: "New leaf node"
        expected: "Path to root updated"
      - name: replace_subtree
        input: "New TypeDef"
        expected: "Parent references updated"

  - name: diff_trees
    given: "Old and new trees"
    when: "Computing diff"
    then: "Added, removed, modified nodes"
    complexity: "O(changed nodes)"
    test_cases:
      - name: no_change
        input: "Identical trees"
        expected: "Empty diff"
      - name: field_added
        input: "New field in type"
        expected: "added=[Field], modified=[TypeDef]"

  - name: validate_incremental
    given: "Incrementally parsed tree"
    when: "Validation against full reparse"
    then: "Trees are equivalent"
    complexity: "O(n) for validation"
    test_cases:
      - name: correctness_check
        input: "Random edit sequence"
        expected: "Incremental == Full reparse"

  - name: estimate_reparse_cost
    given: "Edit and current tree"
    when: "Cost estimation"
    then: "Estimated nodes to reparse"
    complexity: "O(log n)"
    test_cases:
      - name: cheap_edit
        input: "Single char in value"
        expected: "cost < 10"
      - name: expensive_edit
        input: "Delete entire type"
        expected: "cost > 100"

  - name: batch_edits
    given: "Multiple edits"
    when: "Batch processing"
    then: "Single optimized reparse"
    complexity: "O(Δn) not O(edits * Δn)"
    test_cases:
      - name: typing_burst
        input: "10 character insertions"
        expected: "Single reparse, not 10"

performance_targets:
  single_char_edit: "<1ms"
  line_edit: "<5ms"
  block_edit: "<20ms"
  full_reparse_fallback: "<100ms"

cache_config:
  default_size: 10000
  eviction: "LRU"
  hash_algorithm: "xxhash64"

complexity_comparison:
  full_reparse: "O(n)"
  incremental: "O(Δn + log n)"
  speedup_small_edit: "100x"
  speedup_medium_edit: "10x"
  speedup_large_edit: "2x"

# φ² + 1/φ² = 3 | PHOENIX = 999
output: trinity/output/incremental_parsing_v79.zig
