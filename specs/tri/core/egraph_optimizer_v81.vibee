# E-graph Optimizer V81 - Equality Saturation
name: egraph_optimizer_v81
version: "81.0.0"
language: zig
module: egraph_optimizer

creation_pattern:
  source: Expression
  transformer: EqualitySaturation
  result: OptimizedExpression

pas_patterns:
  - pattern: ALG
    application: "Algebraic rewrite rules"
    speedup: "10x"
  - pattern: D&C
    application: "E-class partitioning"
    speedup: "3x"

types:
  ENode:
    fields:
      op: String
      children: List<EClassId>
      
  EClass:
    fields:
      id: EClassId
      nodes: List<ENode>
      
  EClassId:
    fields:
      value: Int

  EGraph:
    fields:
      classes: Map<Int, EClass>
      union_find: List<Int>
      memo: Map<String, EClassId>

  RewriteRule:
    fields:
      name: String
      lhs: Pattern
      rhs: Pattern
      condition: String

  Pattern:
    fields:
      op: String
      children: List<Pattern>
      is_var: Bool
      var_name: String

  CostModel:
    fields:
      op_costs: Map<String, Int>
      
  ExtractionResult:
    fields:
      expr: String
      cost: Int
      rewrites_applied: Int

behaviors:
  - name: add_expression
    given: "Expression to add"
    when: "Adding to e-graph"
    then: "E-class ID returned"
    test_cases:
      - name: add_simple
        input: "a + b"
        expected: "EClassId for sum"

  - name: union_classes
    given: "Two equivalent e-classes"
    when: "Union operation"
    then: "Classes merged"
    test_cases:
      - name: merge_equivalent
        input: "a+b == b+a"
        expected: "single e-class"

  - name: apply_rewrite
    given: "Rewrite rule and e-graph"
    when: "Rule application"
    then: "New nodes added"
    test_cases:
      - name: commutativity
        input: "a + b"
        expected: "b + a added to same class"

  - name: saturate
    given: "E-graph and rules"
    when: "Saturation loop"
    then: "Fixed point reached"
    test_cases:
      - name: full_saturation
        input: "arithmetic rules"
        expected: "no new nodes added"

  - name: extract_optimal
    given: "Saturated e-graph"
    when: "Cost-based extraction"
    then: "Minimum cost expression"
    test_cases:
      - name: extract_best
        input: "x * 2 vs x + x vs x << 1"
        expected: "x << 1 (lowest cost)"

  - name: rebuild
    given: "E-graph after unions"
    when: "Rebuild for invariants"
    then: "Canonical form restored"
    test_cases:
      - name: rebuild_after_merge
        input: "merged classes"
        expected: "invariants maintained"

# φ² + 1/φ² = 3 | PHOENIX = 999
