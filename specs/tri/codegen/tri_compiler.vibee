# ═══════════════════════════════════════════════════════════════════════════════
# TRI COMPILER SPECIFICATION
# .tri → Zig Transpilation
# Sacred Formula: V = n × 3^k × π^m × φ^p × e^q
# Golden Identity: φ² + 1/φ² = 3
# ═══════════════════════════════════════════════════════════════════════════════

name: tri_compiler
version: "1.0.0"
language: tri
module: compiler

sacred_constants:
  phi: 1.618033988749895
  trinity: 3.0
  phoenix: 999

creation_pattern:
  source: TriSourceFile
  transformer: TriCompiler
  result: ZigSourceFile

# ═══════════════════════════════════════════════════════════════════════════════
# TYPES
# ═══════════════════════════════════════════════════════════════════════════════

types:
  Token:
    enum:
      - keyword      # module, fn, struct, enum, const, etc.
      - identifier   # names
      - literal      # strings, numbers
      - operator     # +, -, *, /, ==, etc.
      - punctuation  # :, {, }, (, ), etc.
      - comment      # # comments
      - newline
      - eof

  TokenInfo:
    fields:
      type: Token
      value: String
      line: Int
      column: Int

  ASTNode:
    enum:
      - module
      - import
      - const_decl
      - enum_decl
      - struct_decl
      - class_decl
      - fn_decl
      - command_decl
      - test_decl
      - expression
      - statement
      - block

  ModuleAST:
    fields:
      name: String
      version: String
      imports: List<ImportNode>
      constants: List<ConstNode>
      enums: List<EnumNode>
      structs: List<StructNode>
      classes: List<ClassNode>
      functions: List<FunctionNode>
      commands: List<CommandNode>
      tests: List<TestNode>

  CompileResult:
    fields:
      success: Bool
      zig_code: String
      errors: List<CompileError>
      warnings: List<CompileWarning>
      stats: CompileStats

  CompileError:
    fields:
      message: String
      file: String
      line: Int
      column: Int

  CompileWarning:
    fields:
      message: String
      file: String
      line: Int

  CompileStats:
    fields:
      input_lines: Int
      output_lines: Int
      functions: Int
      structs: Int
      enums: Int
      compile_time_ms: Int

# ═══════════════════════════════════════════════════════════════════════════════
# LEXER
# ═══════════════════════════════════════════════════════════════════════════════

lexer:
  keywords:
    - module
    - version
    - import
    - const
    - enum
    - struct
    - class
    - fn
    - command
    - test
    - if
    - else
    - elif
    - match
    - for
    - while
    - return
    - break
    - continue
    - true
    - false
    - null
    - self
    - in
    - not
    - and
    - or

  operators:
    - "+"
    - "-"
    - "*"
    - "/"
    - "%"
    - "=="
    - "!="
    - "<"
    - ">"
    - "<="
    - ">="
    - "="
    - "+="
    - "-="
    - "->"
    - "=>"
    - ":"
    - "::"
    - "."
    - ".."
    - "..."
    - "?"
    - "??"

  string_delimiters:
    - '"'
    - "'"
    - '"""'

  comment_prefix: "#"

# ═══════════════════════════════════════════════════════════════════════════════
# PARSER
# ═══════════════════════════════════════════════════════════════════════════════

parser:
  grammar:
    module: |
      "module" ":" IDENTIFIER NEWLINE
      ("version" ":" STRING NEWLINE)?
      (import | const_decl | enum_decl | struct_decl | class_decl | fn_decl | command_decl | test_decl)*

    import: |
      "import" IDENTIFIER ("from" STRING)?

    const_decl: |
      "const" IDENTIFIER "=" expression

    enum_decl: |
      "enum" IDENTIFIER ":" NEWLINE
      INDENT (IDENTIFIER (":" expression)? NEWLINE)+ DEDENT

    struct_decl: |
      "struct" IDENTIFIER ":" NEWLINE
      INDENT (IDENTIFIER ":" type_expr NEWLINE)+ DEDENT

    class_decl: |
      "class" IDENTIFIER ":" NEWLINE
      INDENT (field_decl | method_decl)+ DEDENT

    fn_decl: |
      "fn" IDENTIFIER "(" params? ")" ("->" type_expr)? ":" NEWLINE
      INDENT statement+ DEDENT

    command_decl: |
      "command" STRING ":" NEWLINE
      INDENT ("usage" ":" STRING NEWLINE)?
             ("fn" "execute" "(" params? ")" ":" NEWLINE INDENT statement+ DEDENT)?
      DEDENT

    test_decl: |
      "test" STRING ":" NEWLINE
      INDENT test_statement+ DEDENT

# ═══════════════════════════════════════════════════════════════════════════════
# CODE GENERATOR
# ═══════════════════════════════════════════════════════════════════════════════

codegen:
  templates:
    module_header: |
      // {module_name}.zig - Generated from {source_file}
      // Sacred Formula: V = n × 3^k × π^m × φ^p × e^q
      // Golden Identity: φ² + 1/φ² = 3
      
      const std = @import("std");
      
      pub const PHI: f64 = 1.618033988749895;
      pub const TRINITY: f64 = 3.0;
      pub const PHOENIX: u32 = 999;

    enum_template: |
      pub const {name} = enum {
          {variants}
          
          pub fn toString(self: {name}) []const u8 {
              return switch (self) {
                  {to_string_cases}
              };
          }
      };

    struct_template: |
      pub const {name} = struct {
          {fields}
      };

    function_template: |
      pub fn {name}({params}) {return_type} {
          {body}
      }

    test_template: |
      test "{name}" {
          {body}
      }

  type_mapping:
    String: "[]const u8"
    Int: "i64"
    Float: "f64"
    Bool: "bool"
    "List<T>": "std.ArrayList(T)"
    "Option<T>": "?T"
    "Map<K,V>": "std.StringHashMap(V)"

# ═══════════════════════════════════════════════════════════════════════════════
# BEHAVIORS
# ═══════════════════════════════════════════════════════════════════════════════

behaviors:
  - name: tokenize
    given: TRI source code
    when: Lexer processes input
    then: Return list of tokens
    test_cases:
      - name: tokenize_module
        input: |
          module: test
          version: "1.0.0"
        expected:
          tokens: [keyword, punctuation, identifier, newline, keyword, punctuation, literal]

  - name: parse
    given: Token stream
    when: Parser processes tokens
    then: Return AST
    test_cases:
      - name: parse_function
        input: |
          fn add(a: Int, b: Int) -> Int:
            return a + b
        expected:
          ast_type: fn_decl
          name: "add"
          params: 2

  - name: generate_zig
    given: AST
    when: Code generator processes AST
    then: Return valid Zig code
    test_cases:
      - name: generate_enum
        input:
          type: enum_decl
          name: "Color"
          variants: ["red", "green", "blue"]
        expected:
          contains: "pub const Color = enum"

  - name: compile_file
    given: TRI file path
    when: Compiler runs
    then: Generate Zig file
    test_cases:
      - name: compile_simple
        input:
          file: "test.tri"
        expected:
          success: true
          output_file: "test.zig"

# ═══════════════════════════════════════════════════════════════════════════════
# COMMANDS
# ═══════════════════════════════════════════════════════════════════════════════

commands:
  - name: "tri compile"
    usage: "tri compile <file.tri> [--output <file.zig>] [--check]"
    description: "Compile .tri file to Zig"
    examples:
      - "tri compile module.tri"
      - "tri compile module.tri --output src/module.zig"
      - "tri compile module.tri --check"

  - name: "tri build"
    usage: "tri build [--release] [--target <target>]"
    description: "Compile and build executable"
    examples:
      - "tri build"
      - "tri build --release"
      - "tri build --target x86_64-linux"

  - name: "tri run"
    usage: "tri run <file.tri> [args...]"
    description: "Compile and run .tri file"
    examples:
      - "tri run main.tri"
      - "tri run script.tri --verbose"

  - name: "tri check"
    usage: "tri check <file.tri>"
    description: "Type check without compiling"
    examples:
      - "tri check module.tri"

# ═══════════════════════════════════════════════════════════════════════════════
# OPTIMIZATION
# ═══════════════════════════════════════════════════════════════════════════════

optimization:
  passes:
    - name: "constant_folding"
      description: "Evaluate constant expressions at compile time"
      example:
        before: "const X = 2 + 3"
        after: "const X = 5"

    - name: "dead_code_elimination"
      description: "Remove unreachable code"

    - name: "inline_small_functions"
      description: "Inline functions with < 5 statements"

    - name: "phi_optimization"
      description: "Optimize φ-related calculations"
      example:
        before: "PHI * PHI + 1/(PHI * PHI)"
        after: "3.0  // TRINITY"

# ═══════════════════════════════════════════════════════════════════════════════
# PAS PREDICTIONS
# ═══════════════════════════════════════════════════════════════════════════════

pas_predictions:
  - target: "Compile Time"
    current: "100ms for 1000 lines"
    predicted: "10ms with incremental"
    confidence: 0.85
    patterns: [PRE, D&C]
    timeline: "2026"

  - target: "Code Size"
    current: "1:1 line ratio"
    predicted: "0.8:1 with optimization"
    confidence: 0.70
    patterns: [ALG]
    timeline: "2026"

# ═══════════════════════════════════════════════════════════════════════════════
# φ² + 1/φ² = 3
# ═══════════════════════════════════════════════════════════════════════════════
