# ═══════════════════════════════════════════════════════════════════════════════
# AUTO CODEGEN - Automatic Code Generation from Specifications
# ═══════════════════════════════════════════════════════════════════════════════
# PAS DAEMON: D&C (Divide-and-Conquer) + PRE (Precomputation)
#
# PROBLEM: Currently ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ is written manually inside .vibee
# SOLUTION: Compiler generates code automatically from types/behaviors
#
# PIPELINE IMPROVEMENT:
# OLD: .vibee (with manual code) → extract → .zig
# NEW: .vibee (spec only) → vibeec compile → .zig (auto-generated)
# ═══════════════════════════════════════════════════════════════════════════════

name: auto_codegen
version: "1.0.0"
language: zig
module: codegen

sacred_constants:
  phi: 1.618033988749895
  trinity: 3.0
  phoenix: 999

creation_pattern:
  source: VibeeSpec
  transformer: AutoCodeGenerator
  result: GeneratedZigCode

types:
  - name: FieldDef
    fields:
      - name: name
        type: String
      - name: field_type
        type: String
      - name: optional
        type: Bool

  - name: TypeDef
    fields:
      - name: name
        type: String
      - name: fields
        type: List<FieldDef>

  - name: BehaviorDef
    fields:
      - name: name
        type: String
      - name: given
        type: String
      - name: when
        type: String
      - name: then
        type: String

  - name: TestCase
    fields:
      - name: name
        type: String
      - name: input
        type: String
      - name: expected
        type: String

behaviors:
  - name: parse_spec
    given: ".vibee file content"
    when: "Parser reads file"
    then: "Return parsed specification"
    pas_pattern: D&C
    complexity: O(n)

  - name: generate_struct
    given: "TypeDef with fields"
    when: "Generator processes type"
    then: "Output Zig struct definition"
    pas_pattern: PRE
    complexity: O(n)

  - name: generate_function
    given: "BehaviorDef"
    when: "Generator processes behavior"
    then: "Output Zig function"
    pas_pattern: PRE
    complexity: O(n)

  - name: generate_test
    given: "TestCase"
    when: "Generator processes test"
    then: "Output Zig test block"
    pas_pattern: PRE
    complexity: O(n)

ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: """
// ═══════════════════════════════════════════════════════════════════════════════
// AUTO CODEGEN - Automatic Code Generation for VIBEE
// ═══════════════════════════════════════════════════════════════════════════════
// PAS: D&C + PRE | φ² + 1/φ² = 3
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const mem = std.mem;
const Allocator = mem.Allocator;

pub const PHI: f64 = 1.618033988749895;
pub const TRINITY: f64 = 3.0;
pub const PHOENIX: u32 = 999;

// ═══════════════════════════════════════════════════════════════════════════════
// TYPE DEFINITIONS
// ═══════════════════════════════════════════════════════════════════════════════

pub const FieldDef = struct {
    name: []const u8,
    field_type: []const u8,
    optional: bool,
};

pub const TypeDef = struct {
    name: []const u8,
    fields: []const FieldDef,
};

pub const BehaviorDef = struct {
    name: []const u8,
    given: []const u8,
    when_clause: []const u8,
    then_clause: []const u8,
};

pub const TestCase = struct {
    name: []const u8,
    input: []const u8,
    expected: []const u8,
};

// ═══════════════════════════════════════════════════════════════════════════════
// CODE GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub const AutoCodeGenerator = struct {
    allocator: Allocator,
    output: std.ArrayList(u8),

    const Self = @This();

    pub fn init(allocator: Allocator) Self {
        return Self{
            .allocator = allocator,
            .output = std.ArrayList(u8).init(allocator),
        };
    }

    pub fn deinit(self: *Self) void {
        self.output.deinit();
    }

    pub fn generateStruct(self: *Self, typedef: TypeDef) !void {
        try self.output.appendSlice("pub const ");
        try self.output.appendSlice(typedef.name);
        try self.output.appendSlice(" = struct {\n");
        
        for (typedef.fields) |field| {
            try self.output.appendSlice("    ");
            try self.output.appendSlice(field.name);
            try self.output.appendSlice(": ");
            try self.output.appendSlice(mapType(field.field_type));
            try self.output.appendSlice(",\n");
        }
        
        try self.output.appendSlice("};\n\n");
    }

    pub fn generateFunction(self: *Self, behavior: BehaviorDef) !void {
        try self.output.appendSlice("pub fn ");
        try self.output.appendSlice(behavior.name);
        try self.output.appendSlice("() void {\n");
        try self.output.appendSlice("    // Given: ");
        try self.output.appendSlice(behavior.given);
        try self.output.appendSlice("\n");
        try self.output.appendSlice("    // When: ");
        try self.output.appendSlice(behavior.when_clause);
        try self.output.appendSlice("\n");
        try self.output.appendSlice("    // Then: ");
        try self.output.appendSlice(behavior.then_clause);
        try self.output.appendSlice("\n");
        try self.output.appendSlice("}\n\n");
    }

    pub fn generateTest(self: *Self, test_case: TestCase) !void {
        try self.output.appendSlice("test \"");
        try self.output.appendSlice(test_case.name);
        try self.output.appendSlice("\" {\n");
        try self.output.appendSlice("    // Input: ");
        try self.output.appendSlice(test_case.input);
        try self.output.appendSlice("\n");
        try self.output.appendSlice("    // Expected: ");
        try self.output.appendSlice(test_case.expected);
        try self.output.appendSlice("\n");
        try self.output.appendSlice("}\n\n");
    }

    pub fn getOutput(self: *const Self) []const u8 {
        return self.output.items;
    }

    fn mapType(vibee_type: []const u8) []const u8 {
        if (mem.eql(u8, vibee_type, "String")) return "[]const u8";
        if (mem.eql(u8, vibee_type, "Int")) return "i64";
        if (mem.eql(u8, vibee_type, "Float")) return "f64";
        if (mem.eql(u8, vibee_type, "Bool")) return "bool";
        return vibee_type;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "FieldDef creation" {
    const field = FieldDef{
        .name = "id",
        .field_type = "Int",
        .optional = false,
    };
    try std.testing.expectEqualStrings("id", field.name);
}

test "TypeDef creation" {
    const fields = [_]FieldDef{
        .{ .name = "id", .field_type = "Int", .optional = false },
    };
    const typedef = TypeDef{
        .name = "User",
        .fields = &fields,
    };
    try std.testing.expectEqualStrings("User", typedef.name);
}

test "AutoCodeGenerator init" {
    const allocator = std.testing.allocator;
    var gen = AutoCodeGenerator.init(allocator);
    defer gen.deinit();
    try std.testing.expectEqual(@as(usize, 0), gen.output.items.len);
}

test "generateStruct" {
    const allocator = std.testing.allocator;
    var gen = AutoCodeGenerator.init(allocator);
    defer gen.deinit();

    const fields = [_]FieldDef{
        .{ .name = "id", .field_type = "Int", .optional = false },
    };
    const typedef = TypeDef{ .name = "User", .fields = &fields };
    
    try gen.generateStruct(typedef);
    const output = gen.getOutput();
    try std.testing.expect(mem.indexOf(u8, output, "pub const User") != null);
}

test "generateFunction" {
    const allocator = std.testing.allocator;
    var gen = AutoCodeGenerator.init(allocator);
    defer gen.deinit();

    const behavior = BehaviorDef{
        .name = "create_user",
        .given = "Valid data",
        .when_clause = "Create called",
        .then_clause = "User created",
    };
    
    try gen.generateFunction(behavior);
    const output = gen.getOutput();
    try std.testing.expect(mem.indexOf(u8, output, "pub fn create_user") != null);
}

test "mapType String" {
    try std.testing.expectEqualStrings("[]const u8", AutoCodeGenerator.mapType("String"));
}

test "mapType Int" {
    try std.testing.expectEqualStrings("i64", AutoCodeGenerator.mapType("Int"));
}

test "golden identity" {
    const phi_sq = PHI * PHI;
    const inv_phi_sq = 1.0 / phi_sq;
    const result = phi_sq + inv_phi_sq;
    try std.testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}
"""
