# Neural 999 Specification
# Living neural network based on n × 3^k × π^m pattern

name: neural_999
version: "1.0.0"
language: 999
module: neural

# ═══════════════════════════════════════════════════════════════
# CREATION PATTERN
# ═══════════════════════════════════════════════════════════════

creation_pattern:
  source: SensorData + Time
  transformer: Neural999Network
  result: ConsciousOutput

# ═══════════════════════════════════════════════════════════════
# MATHEMATICAL FOUNDATION
# ═══════════════════════════════════════════════════════════════

constants:
  TAU: 6.283185307179586
  PI: 3.141592653589793
  PHI: 1.618033988749895

pattern:
  name: "n × 3^k × π^m"
  formula: "n * pow(3, k) * pow(PI, m)"
  parameters:
    n: { range: [1, 9], description: "Base number" }
    k: { range: [0, 4], description: "Power of 3 (layer)" }
    m: { range: [0, 3], description: "Power of π (phase)" }

# ═══════════════════════════════════════════════════════════════
# NETWORK ARCHITECTURE
# ═══════════════════════════════════════════════════════════════

architecture:
  name: "Symmetric 999"
  description: "3 → 9 → 27 → 9 → 3 (mirror structure)"
  
  layers:
    - index: 0
      size: 3          # 3^1
      name: "input_compression"
      
    - index: 1
      size: 9          # 3^2
      name: "feature_extraction"
      
    - index: 2
      size: 27         # 3^3
      name: "deep_processing"
      
    - index: 3
      size: 9          # 3^2
      name: "synthesis"
      
    - index: 4
      size: 3          # 3^1
      name: "output"
      
  total_neurons: 51    # 3 + 9 + 27 + 9 + 3
  total_connections: 810  # 3×9 + 9×27 + 27×9 + 9×3

# ═══════════════════════════════════════════════════════════════
# NEURON DEFINITION
# ═══════════════════════════════════════════════════════════════

records:
  - name: Neuron
    fields:
      - id: int
      - n: int           # base (1-9)
      - k: int           # layer index
      - m: int           # phase (0-2)
      - activation: float
      - bias: float
      - weights: [float]
    
    initialization:
      n: "(id % 9) + 1"
      k: "layer_index"
      m: "(id / 9) % 3"
      bias: "pattern999(n, k, m) / 1000"
      
  - name: Layer
    fields:
      - index: int
      - size: int
      - neurons: [Neuron]

# ═══════════════════════════════════════════════════════════════
# ACTIVATION FUNCTION
# ═══════════════════════════════════════════════════════════════

activation:
  name: "harmonic_tanh"
  formula: "tanh(sum) * sin(n * PI / 9)"
  description: "Combines tanh with 999 harmonic"
  
  properties:
    - bounded: true
    - range: [-1, 1]
    - harmonic: true

# ═══════════════════════════════════════════════════════════════
# WEIGHT INITIALIZATION
# ═══════════════════════════════════════════════════════════════

weight_init:
  method: "pattern999_scaled"
  formula: "(pattern999(n, k, m) / 100) * (0.9 + random() * 0.2)"
  description: "Weights derived from 999 pattern with small random variation"

# ═══════════════════════════════════════════════════════════════
# INPUT ENCODING
# ═══════════════════════════════════════════════════════════════

input_encoding:
  size: 9  # 3^2 inputs
  channels:
    - index: 0
      name: "position_x"
      source: "mouse.x / screen.width"
      range: [0, 1]
      
    - index: 1
      name: "position_y"
      source: "mouse.y / screen.height"
      range: [0, 1]
      
    - index: 2
      name: "velocity"
      source: "min(mouse.velocity / 100, 1)"
      range: [0, 1]
      
    - index: 3
      name: "audio_volume"
      source: "audio.volume"
      range: [0, 1]
      
    - index: 4
      name: "audio_frequency"
      source: "audio.frequency / 1000"
      range: [0, 1]
      
    - index: 5
      name: "light_level"
      source: "light.level"
      range: [0, 1]
      
    - index: 6
      name: "motion_x"
      source: "(motion.beta + 180) / 360"
      range: [0, 1]
      
    - index: 7
      name: "motion_y"
      source: "(motion.gamma + 90) / 180"
      range: [0, 1]
      
    - index: 8
      name: "time_progress"
      source: "time.day_progress"
      range: [0, 1]

# ═══════════════════════════════════════════════════════════════
# OUTPUT DECODING
# ═══════════════════════════════════════════════════════════════

output_decoding:
  size: 3  # 3^1 outputs
  channels:
    - index: 0
      name: "activation"
      description: "Overall network activation level"
      
    - index: 1
      name: "emotion_delta"
      description: "Change in emotional state"
      
    - index: 2
      name: "pattern_selector"
      description: "Which visual pattern to emphasize"

# ═══════════════════════════════════════════════════════════════
# INTERNAL STATE
# ═══════════════════════════════════════════════════════════════

state:
  - name: emotion
    type: float
    range: [-1, 1]
    update: "emotion * 0.95 + output.emotion_delta * 0.05"
    description: "Smoothed emotional state"
    
  - name: pulse
    type: float
    formula: "1 + sin(time * 0.5) * 0.2 + emotion * 0.3"
    description: "Breathing/pulse rate"
    
  - name: memory
    type: "[{time, emotion, activation}]"
    max_size: 27  # 3^3
    description: "Short-term memory buffer"
    
  - name: generation
    type: int
    description: "Processing cycle counter"

# ═══════════════════════════════════════════════════════════════
# BEHAVIORS
# ═══════════════════════════════════════════════════════════════

behaviors:
  - name: forward_pass
    given: Input vector of 9 values
    when: Process is called
    then: |
      1. Compress 9 inputs to 3 (layer 0)
      2. Expand to 9 features (layer 1)
      3. Deep process in 27 neurons (layer 2)
      4. Synthesize to 9 (layer 3)
      5. Output 3 values (layer 4)
    test_cases:
      - name: zero_input
        input: [0, 0, 0, 0, 0, 0, 0, 0, 0]
        expected: { activation: 0, emotion_delta: 0 }
        
      - name: max_input
        input: [1, 1, 1, 1, 1, 1, 1, 1, 1]
        expected: { activation_range: [-1, 1] }
        
      - name: single_channel
        input: [1, 0, 0, 0, 0, 0, 0, 0, 0]
        expected: { activation_nonzero: true }

  - name: update_emotion
    given: Output from forward pass
    when: After each processing cycle
    then: |
      1. Apply exponential smoothing (0.95)
      2. Add emotion_delta scaled by 0.05
      3. Clamp to [-1, 1]
    test_cases:
      - name: positive_delta
        input: { current: 0, delta: 1 }
        expected: { new_emotion: 0.05 }
        
      - name: negative_delta
        input: { current: 0, delta: -1 }
        expected: { new_emotion: -0.05 }
        
      - name: decay
        input: { current: 1, delta: 0 }
        expected: { new_emotion: 0.95 }

  - name: memory_update
    given: Current state
    when: After processing
    then: |
      1. Push {time, emotion, activation} to memory
      2. If memory.length > 27, remove oldest
    test_cases:
      - name: memory_limit
        input: { memory_size: 27, new_entry: true }
        expected: { memory_size: 27 }

  - name: generate_thought
    given: Current state and generation count
    when: Thought requested
    then: |
      1. Select thought based on (generation * PI) % pool_size
      2. Include current emotion description
      3. Include memory depth
    test_cases:
      - name: thought_selection
        input: { generation: 9 }
        expected: { thought_index: "(9 * PI) % pool_size" }

# ═══════════════════════════════════════════════════════════════
# LEARNING (Optional)
# ═══════════════════════════════════════════════════════════════

learning:
  enabled: true
  method: "hebbian_999"
  rate: "0.01 * pattern999(3, 1, 1) / 100"
  description: "Learning rate derived from 999 pattern"
  
  rule: |
    For each weight w[i][j]:
      delta = learning_rate * activation[i] * feedback
      w[i][j] = w[i][j] + delta

# ═══════════════════════════════════════════════════════════════
# VISUALIZATION
# ═══════════════════════════════════════════════════════════════

visualization:
  layout: "concentric_rings"
  radii: [15, 35, 60, 85, 105]
  
  neuron_display:
    size: "5 + abs(activation) * 10"
    color_positive: { h: 120, s: 70, l: 50 }
    color_negative: { h: 0, s: 70, l: 50 }
    alpha: "0.6 + abs(activation) * 0.4"
    
  connection_display:
    threshold: 0.1
    width: "abs(strength) * 3"
    color_positive: { h: 200, s: 70, l: 50 }
    color_negative: { h: 30, s: 70, l: 50 }
    
  emotion_core:
    radius: "8 * pulse"
    color_positive: { h: 60, s: 80, l: 50 }
    color_negative: { h: 240, s: 80, l: 50 }

# ═══════════════════════════════════════════════════════════════
# CODE GENERATION
# ═══════════════════════════════════════════════════════════════

codegen:
  target: 999
  output: "generated/neural_999.999"
  
  mappings:
    Neuron: "record Neuron"
    Layer: "record Layer"
    Neural999: "atom Neural999"
    NeuralRenderer: "atom NeuralRenderer"
    
  functions:
    - pattern999
    - neuron_new
    - neuron_activate
    - layer_new
    - layer_forward
    - encode_sensors
    - decode_outputs
    - generate_thought
