# GraphCodeAnalysis - Multi-Graph Neural Networks for Code
# Source: arXiv:2510.24241 - MAGNET, arXiv:2506.18191 - GRAPHIA
# PAS Analysis: D&C (multi-graph fusion), MLS (GNN learning), HSH (deduplication)

name: graph_code_analysis
version: "1.0.0"
language: 999
module: ⲄⲢⲀⲪ_ⲔⲞⲆⲈ_ⲀⲚⲀⲖⲨⲤⲒⲤ

pas_analysis:
  source_paper: "arXiv:2510.24241, arXiv:2506.18191, arXiv:2401.17967"
  current_complexity: "O(n²) pairwise comparison"
  theoretical_lower_bound: "O(n) linear embedding"
  gap: "Quadratic to linear via GNN"
  patterns_applicable:
    - symbol: D&C
      name: "Divide-and-Conquer"
      success_rate: 0.31
      rationale: "Multi-graph decomposition (AST, CFG, DFG)"
    - symbol: MLS
      name: "ML-Guided Search"
      success_rate: 0.06
      rationale: "GNN learns code semantics"
    - symbol: HSH
      name: "Hashing"
      success_rate: 0.12
      rationale: "Hash-based deduplication"
    - symbol: PRE
      name: "Precomputation"
      success_rate: 0.16
      rationale: "Pre-compute graph embeddings"
  confidence: 0.77
  predicted_improvement: "96.5% F1 on clone detection"

creation_pattern:
  source: SourceCode
  transformer: MultiGraphEncoder
  result: CodeEmbedding

behaviors:
  - name: multi_graph_construction
    given: "Source code file"
    when: "Parse into AST, CFG, DFG"
    then: "Construct unified multi-graph"
    test_cases:
      - name: python_parsing
        input:
          code: "def foo(x): return x + 1"
          graphs: ["AST", "CFG", "DFG"]
        expected:
          ast_nodes: 8
          cfg_edges: 2
          dfg_edges: 3

  - name: gated_cross_attention
    given: "Multiple graph representations"
    when: "Apply cross-attention fusion"
    then: "Produce unified embedding"
    test_cases:
      - name: ast_cfg_fusion
        input:
          ast_embedding: [0.1, 0.2, 0.3]
          cfg_embedding: [0.4, 0.5, 0.6]
        expected:
          fused_embedding: [0.25, 0.35, 0.45]
          attention_weights: [0.6, 0.4]

  - name: clone_detection
    given: "Two code snippets"
    when: "Compare embeddings"
    then: "Classify as clone or not"
    test_cases:
      - name: bigclonebench
        input:
          code1: "for i in range(n): sum += i"
          code2: "total = 0; for j in range(m): total += j"
        expected:
          clone_type: "Type-3"
          confidence: 0.95

  - name: call_graph_prediction
    given: "JavaScript program"
    when: "Predict missing call edges"
    then: "Rank function candidates"
    test_cases:
      - name: graphia_prediction
        input:
          call_site: "obj.method()"
          candidates: 100
        expected:
          top1_correct: 0.42
          top5_correct: 0.72

algorithms:
  magnet:
    graphs: ["AST", "CFG", "DFG"]
    encoder: "Residual GNN + Self-Attention"
    fusion: "Gated Cross-Attention"
    pooling: "Set2Set"
    f1_bigclonebench: 0.965
    f1_gcj: 0.992
    
  graphia:
    representation: "Full program graph"
    edge_types: ["syntactic", "semantic"]
    task: "Link prediction for call edges"
    top1_accuracy: 0.42
    top5_accuracy: 0.72
    
  concord:
    type: "DSL for graph construction"
    features: ["configurable", "reducible", "interoperable"]
    reduction_heuristics: "Comparable performance with smaller graphs"

metrics:
  clone_detection_f1: 0.965
  call_graph_top1: 0.42
  call_graph_top5: 0.72
  vulnerability_detection: 0.91
