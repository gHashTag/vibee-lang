# ProgramRepair - Automated Program Repair via LLM + SBFL
# Source: arXiv:2509.01947 - Automated Repair of C Programs Using LLMs
# PAS Analysis: MLS (44.93% accuracy), PRE (fault localization cache)

name: program_repair
version: "1.0.0"
language: 999
module: ⲠⲢⲞⲄⲢⲀⲘ_ⲢⲈⲠⲀⲒⲢ

pas_analysis:
  source_paper: "arXiv:2509.01947"
  current_complexity: "O(n * m) where n=tests, m=statements"
  theoretical_lower_bound: "Ω(n)"
  gap: "Factor of m (statement count)"
  patterns_applicable:
    - symbol: MLS
      name: "ML-Guided Search"
      success_rate: 0.06
      rationale: "LLM reasoning over suspicious code regions"
    - symbol: PRE
      name: "Precomputation"
      success_rate: 0.16
      rationale: "Cache SBFL scores, reuse across iterations"
    - symbol: HSH
      name: "Hashing"
      success_rate: 0.12
      rationale: "Hash patch signatures to avoid duplicates"
  confidence: 0.68
  predicted_improvement: "2x repair accuracy via iterative CoT"

creation_pattern:
  source: BuggyCode
  transformer: SBFLLocalizer
  result: PatchedCode

behaviors:
  - name: spectrum_based_fault_localization
    given: "Buggy code with failing tests"
    when: "Execute SBFL analysis"
    then: "Return ranked suspicious statements"
    test_cases:
      - name: ochiai_ranking
        input:
          code: "fn add(a, b) { return a - b; }"
          failing_test: "assert add(2, 3) == 5"
        expected:
          suspicious_line: 1
          score: 0.95

  - name: chain_of_thought_repair
    given: "Suspicious code region identified"
    when: "Apply CoT prompting"
    then: "Generate candidate patch with reasoning"
    test_cases:
      - name: arithmetic_fix
        input:
          suspicious: "return a - b"
          context: "Function should add two numbers"
        expected:
          patch: "return a + b"
          reasoning: "Operator should be + not -"

  - name: iterative_refinement
    given: "Patch fails validation"
    when: "Incorporate failure feedback"
    then: "Generate improved patch"
    test_cases:
      - name: second_attempt
        input:
          previous_patch: "return a * b"
          failure_reason: "Still fails for add(2, 3)"
        expected:
          new_patch: "return a + b"

algorithms:
  sbfl_ochiai:
    formula: "score = failed(s) / sqrt(total_failed * (failed(s) + passed(s)))"
    complexity: "O(n * m)"
    
  cot_prompting:
    steps:
      - "Analyze failing test"
      - "Identify suspicious region"
      - "Reason about expected behavior"
      - "Generate patch"
      - "Validate and iterate"

metrics:
  repair_accuracy: 0.4493
  top1_localization: 0.506
  iterations_avg: 3.2
