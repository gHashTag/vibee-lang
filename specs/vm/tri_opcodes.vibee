# ═══════════════════════════════════════════════════════════════════════════════
# TRINITY OPCODES - COMPLETE INSTRUCTION SET
# ═══════════════════════════════════════════════════════════════════════════════
# All opcodes used in .tri files
# Sacred Formula: V = n × 3^k × π^m × φ^p × e^q
# Golden Identity: φ² + 1/φ² = 3
# ═══════════════════════════════════════════════════════════════════════════════

name: tri_opcodes
version: "26.φ"
author: "PAS DAEMON V43"
license: "MIT"

# ═══════════════════════════════════════════════════════════════════════════════
# OPCODE CATEGORIES
# ═══════════════════════════════════════════════════════════════════════════════

opcodes:

  # ─────────────────────────────────────────────────────────────────────────────
  # CORE (0x00-0x0F)
  # ─────────────────────────────────────────────────────────────────────────────
  core:
    - NOP:          { code: 0x00, args: 0, desc: "No operation" }
    - HALT:         { code: 0x01, args: 0, desc: "Stop execution" }
    - MOV:          { code: 0x02, args: 2, desc: "Move: dst = src" }
    - LOAD_CONST:   { code: 0x03, args: 2, desc: "Load constant: dst = imm" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # ARITHMETIC (0x10-0x1F)
  # ─────────────────────────────────────────────────────────────────────────────
  arithmetic:
    - ADD:          { code: 0x10, args: 3, desc: "Add: dst = src1 + src2" }
    - SUB:          { code: 0x11, args: 3, desc: "Subtract: dst = src1 - src2" }
    - MUL:          { code: 0x12, args: 3, desc: "Multiply: dst = src1 * src2" }
    - DIV:          { code: 0x13, args: 3, desc: "Divide: dst = src1 / src2" }
    - MOD:          { code: 0x14, args: 3, desc: "Modulo: dst = src1 % src2" }
    - NEG:          { code: 0x15, args: 2, desc: "Negate: dst = -src" }
    - ABS:          { code: 0x16, args: 2, desc: "Absolute: dst = |src|" }
    - SHL:          { code: 0x17, args: 3, desc: "Shift left: dst = src1 << src2" }
    - SHR:          { code: 0x18, args: 3, desc: "Shift right: dst = src1 >> src2" }
    - AND:          { code: 0x19, args: 3, desc: "Bitwise AND" }
    - OR:           { code: 0x1A, args: 3, desc: "Bitwise OR" }
    - XOR:          { code: 0x1B, args: 3, desc: "Bitwise XOR" }
    - NOT:          { code: 0x1C, args: 2, desc: "Bitwise NOT" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # PHI OPERATIONS (0x20-0x2F)
  # ─────────────────────────────────────────────────────────────────────────────
  phi:
    - PHI_MUL:      { code: 0x20, args: 2, desc: "Multiply by φ: dst = src * φ" }
    - PHI_DIV:      { code: 0x21, args: 2, desc: "Divide by φ: dst = src / φ" }
    - PHI_POW:      { code: 0x22, args: 2, desc: "Phi power: dst = φ^src" }
    - FIB:          { code: 0x23, args: 2, desc: "Fibonacci: dst = F(src)" }
    - LUCAS:        { code: 0x24, args: 2, desc: "Lucas: dst = L(src)" }
    - TRINITY_CHECK:{ code: 0x25, args: 1, desc: "Verify φ² + 1/φ² = 3" }
    - GOLDEN_RATIO: { code: 0x26, args: 1, desc: "Load φ into dst" }
    - PHI_LERP:     { code: 0x27, args: 4, desc: "φ-weighted lerp" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # MEMORY (0x30-0x3F)
  # ─────────────────────────────────────────────────────────────────────────────
  memory:
    - LOAD:         { code: 0x30, args: 3, desc: "Load: dst = mem[base + offset]" }
    - STORE:        { code: 0x31, args: 3, desc: "Store: mem[base + offset] = src" }
    - LOAD_BYTE:    { code: 0x32, args: 3, desc: "Load byte" }
    - STORE_BYTE:   { code: 0x33, args: 3, desc: "Store byte" }
    - LOAD_HALF:    { code: 0x34, args: 3, desc: "Load 16-bit" }
    - STORE_HALF:   { code: 0x35, args: 3, desc: "Store 16-bit" }
    - LOAD_WORD:    { code: 0x36, args: 3, desc: "Load 32-bit" }
    - STORE_WORD:   { code: 0x37, args: 3, desc: "Store 32-bit" }
    - LOAD_QUAD:    { code: 0x38, args: 3, desc: "Load 64-bit" }
    - STORE_QUAD:   { code: 0x39, args: 3, desc: "Store 64-bit" }
    - LEA:          { code: 0x3A, args: 2, desc: "Load effective address" }
    - ALLOC:        { code: 0x3B, args: 2, desc: "Allocate memory" }
    - FREE:         { code: 0x3C, args: 1, desc: "Free memory" }
    - MEMSET:       { code: 0x3D, args: 3, desc: "Set memory" }
    - MEMCPY:       { code: 0x3E, args: 3, desc: "Copy memory" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # CONTROL FLOW (0x40-0x4F)
  # ─────────────────────────────────────────────────────────────────────────────
  control:
    - JMP:          { code: 0x40, args: 1, desc: "Unconditional jump" }
    - JZ:           { code: 0x41, args: 1, desc: "Jump if zero" }
    - JNZ:          { code: 0x42, args: 1, desc: "Jump if not zero" }
    - JE:           { code: 0x43, args: 1, desc: "Jump if equal" }
    - JNE:          { code: 0x44, args: 1, desc: "Jump if not equal" }
    - JL:           { code: 0x45, args: 1, desc: "Jump if less" }
    - JLE:          { code: 0x46, args: 1, desc: "Jump if less or equal" }
    - JG:           { code: 0x47, args: 1, desc: "Jump if greater" }
    - JGE:          { code: 0x48, args: 1, desc: "Jump if greater or equal" }
    - CALL:         { code: 0x49, args: 1, desc: "Call subroutine" }
    - RET:          { code: 0x4A, args: 0, desc: "Return from subroutine" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # STACK (0x50-0x5F)
  # ─────────────────────────────────────────────────────────────────────────────
  stack:
    - PUSH:         { code: 0x50, args: 1, desc: "Push to stack" }
    - POP:          { code: 0x51, args: 1, desc: "Pop from stack" }
    - PUSH_ALL:     { code: 0x52, args: 0, desc: "Push all registers" }
    - POP_ALL:      { code: 0x53, args: 0, desc: "Pop all registers" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # COMPARISON (0x60-0x6F)
  # ─────────────────────────────────────────────────────────────────────────────
  comparison:
    - CMP:          { code: 0x60, args: 2, desc: "Compare: set flags" }
    - CMP_APPROX:   { code: 0x61, args: 3, desc: "Compare with tolerance" }
    - TEST:         { code: 0x62, args: 2, desc: "Test bits" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # I/O (0x70-0x7F)
  # ─────────────────────────────────────────────────────────────────────────────
  io:
    - PRINT:        { code: 0x70, args: 1, desc: "Print integer" }
    - PRINT_F64:    { code: 0x71, args: 1, desc: "Print float" }
    - PRINT_STR:    { code: 0x72, args: 1, desc: "Print string" }
    - RDTSC:        { code: 0x73, args: 1, desc: "Read timestamp counter" }
    - INPUT:        { code: 0x74, args: 1, desc: "Read input" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # TESTING (0x80-0x8F)
  # ─────────────────────────────────────────────────────────────────────────────
  testing:
    - ASSERT_EQ:    { code: 0x80, args: 0, desc: "Assert equal (uses flags)" }
    - ASSERT_NE:    { code: 0x81, args: 0, desc: "Assert not equal" }
    - ASSERT_TRUE:  { code: 0x82, args: 0, desc: "Assert true" }
    - ASSERT_FALSE: { code: 0x83, args: 0, desc: "Assert false" }
    - ASSERT_APPROX:{ code: 0x84, args: 0, desc: "Assert approximately equal" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # SIMD (0x90-0x9F)
  # ─────────────────────────────────────────────────────────────────────────────
  simd:
    - V128_LOAD:    { code: 0x90, args: 3, desc: "Load 128-bit vector" }
    - V128_STORE:   { code: 0x91, args: 3, desc: "Store 128-bit vector" }
    - V128_SPLAT_I8:{ code: 0x92, args: 2, desc: "Splat i8 to vector" }
    - V128_EQ_I8:   { code: 0x93, args: 3, desc: "Vector i8 equality" }
    - V128_OR:      { code: 0x94, args: 3, desc: "Vector OR" }
    - V128_AND:     { code: 0x95, args: 3, desc: "Vector AND" }
    - V128_BITMASK: { code: 0x96, args: 2, desc: "Extract bitmask" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # GC (0xA0-0xAF)
  # ─────────────────────────────────────────────────────────────────────────────
  gc:
    - GC_ALLOC:     { code: 0xA0, args: 2, desc: "GC-managed allocation" }
    - GC_COLLECT:   { code: 0xA1, args: 0, desc: "Trigger collection" }
    - GC_MARK:      { code: 0xA2, args: 1, desc: "Mark object" }
    - GC_ROOT_ADD:  { code: 0xA3, args: 1, desc: "Add GC root" }
    - GC_ROOT_REM:  { code: 0xA4, args: 1, desc: "Remove GC root" }
    
  # ─────────────────────────────────────────────────────────────────────────────
  # JIT (0xB0-0xBF)
  # ─────────────────────────────────────────────────────────────────────────────
  jit:
    - JIT_COMPILE:  { code: 0xB0, args: 2, desc: "JIT compile function" }
    - JIT_CALL:     { code: 0xB1, args: 1, desc: "Call JIT-compiled code" }
    - JIT_INVALIDATE:{ code: 0xB2, args: 1, desc: "Invalidate JIT code" }
    - STENCIL_COPY: { code: 0xB3, args: 3, desc: "Copy stencil" }
    - HOLE_PATCH:   { code: 0xB4, args: 3, desc: "Patch hole" }

# ═══════════════════════════════════════════════════════════════════════════════
# OPCODE COUNT
# ═══════════════════════════════════════════════════════════════════════════════

summary:
  total_opcodes: 85
  categories: 11
  phi_specific: 8
  simd_opcodes: 7
  gc_opcodes: 5
  jit_opcodes: 5
