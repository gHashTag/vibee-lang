# ═══════════════════════════════════════════════════════════════════════════════
# TRINITY φ-Layout Specification
# ═══════════════════════════════════════════════════════════════════════════════
#
# Алгоритмы размещения с φ-оптимизацией
# Золотая идентичность: φ² + 1/φ² = 3
#
# ═══════════════════════════════════════════════════════════════════════════════

name: phi_layout
version: "24.φ"
author: "TRINITY"
license: "MIT"

imports:
  - phi_core
  - phi_structures

targets:
  - zig
  - rust

# ═══════════════════════════════════════════════════════════════════════════════
# ТИПЫ
# ═══════════════════════════════════════════════════════════════════════════════

types:

  Vec2:
    fields:
      x: f64
      y: f64
    operations:
      - add
      - sub
      - mul_scalar
      - magnitude
      - normalize
      
  Bounds:
    fields:
      min_x: f64
      min_y: f64
      max_x: f64
      max_y: f64
    derived:
      width: "max_x - min_x"
      height: "max_y - min_y"
      phi_ratio: "width / height"
      
  LayoutNode:
    fields:
      id: u64
      position: Vec2
      velocity: Vec2
      force: Vec2
      mass: f64
      phi_weight: f64
      fixed: bool
      
  LayoutEdge:
    fields:
      source: u64
      target: u64
      ideal_length: f64
      strength: f64
      phi_factor: f64
      
  LayoutConfig:
    fields:
      bounds: Bounds
      iterations: u32
      damping: f64
      repulsion_strength: f64
      attraction_strength: f64
      phi_factor: f64
      convergence_threshold: f64
      
  LayoutResult:
    fields:
      positions: "Array<Vec2>"
      iterations_used: u32
      energy: f64
      converged: bool

# ═══════════════════════════════════════════════════════════════════════════════
# CREATION PATTERNS
# ═══════════════════════════════════════════════════════════════════════════════

creation_patterns:

  force_directed_layout:
    source: "(nodes: Array<LayoutNode>, edges: Array<LayoutEdge>, config: LayoutConfig)"
    transformer: "Итеративное применение сил с φ-весами"
    result: LayoutResult
    
  phi_spiral_layout:
    source: "(n: u32, bounds: Bounds)"
    transformer: "Размещение по золотому углу"
    result: "Array<Vec2>"
    
  hierarchical_layout:
    source: "(tree: PhiTree, bounds: Bounds)"
    transformer: "Иерархическое размещение с φ-пропорциями"
    result: "Array<Vec2>"
    
  radial_layout:
    source: "(graph: PhiGraph, center: Vec2, radius: f64)"
    transformer: "Радиальное размещение с φ-секторами"
    result: "Array<Vec2>"

# ═══════════════════════════════════════════════════════════════════════════════
# BEHAVIORS
# ═══════════════════════════════════════════════════════════════════════════════

behaviors:

  # ─────────────────────────────────────────────────────────────────────────────
  # Force-Directed Layout
  # ─────────────────────────────────────────────────────────────────────────────
  
  - name: force_repulsion
    given: "два узла на расстоянии d"
    when: "вычисляем силу отталкивания"
    then: "F = φ × k² / d, направлена от другого узла"
    formula: "F_repulsion = PHI * k * k / distance"
    test_cases:
      - input: { distance: 100, k: 50 }
        expected: 40.45  # φ × 50² / 100
        
  - name: force_attraction
    given: "ребро между узлами на расстоянии d"
    when: "вычисляем силу притяжения"
    then: "F = d² / (k × φ), направлена к другому узлу"
    formula: "F_attraction = distance * distance / (k * PHI)"
    test_cases:
      - input: { distance: 100, k: 50 }
        expected: 123.6  # 100² / (50 × φ)
        
  - name: force_equilibrium
    given: "оптимальное расстояние k"
    when: "F_repulsion = F_attraction"
    then: "d = k × φ^(2/3)"
    test_cases:
      - input: { k: 50 }
        expected: 68.5  # 50 × φ^(2/3)
        tolerance: 0.5
        
  - name: phi_damping
    given: "итерация i из n"
    when: "применяем демпфирование"
    then: "damping = φ^(-1) × φ^(-i/n)"
    test_cases:
      - input: { i: 0, n: 100 }
        expected: 0.618
      - input: { i: 50, n: 100 }
        expected: 0.486
        tolerance: 0.01

  # ─────────────────────────────────────────────────────────────────────────────
  # φ-Spiral Layout
  # ─────────────────────────────────────────────────────────────────────────────
  
  - name: golden_angle
    given: "индекс i"
    when: "вычисляем угол"
    then: "angle = i × τ × (1/φ)"
    formula: "angle = i * TAU * PHI_INV"
    test_cases:
      - input: { i: 0 }
        expected: 0.0
      - input: { i: 1 }
        expected: 3.883  # τ/φ
        tolerance: 0.001
        
  - name: spiral_radius
    given: "индекс i, масштаб s"
    when: "вычисляем радиус"
    then: "radius = s × φ^(i × 0.1)"
    test_cases:
      - input: { i: 10, scale: 10 }
        expected: 16.18  # 10 × φ
        tolerance: 0.01

  # ─────────────────────────────────────────────────────────────────────────────
  # Hierarchical Layout
  # ─────────────────────────────────────────────────────────────────────────────
  
  - name: level_height
    given: "уровень l, общая высота h"
    when: "вычисляем высоту уровня"
    then: "y = h × (1 - φ^(-l))"
    test_cases:
      - input: { level: 0, height: 100 }
        expected: 0.0
      - input: { level: 1, height: 100 }
        expected: 38.2  # 100 × (1 - 1/φ)
        tolerance: 0.1
        
  - name: node_spacing
    given: "n узлов на уровне l, ширина w"
    when: "вычисляем расстояние между узлами"
    then: "spacing = w × φ^(-l) / n"
    test_cases:
      - input: { n: 5, level: 1, width: 100 }
        expected: 12.36  # 100 × (1/φ) / 5
        tolerance: 0.1

  # ─────────────────────────────────────────────────────────────────────────────
  # Radial Layout
  # ─────────────────────────────────────────────────────────────────────────────
  
  - name: sector_angle
    given: "n секторов"
    when: "вычисляем угол сектора"
    then: "angle = τ / n, но с φ-коррекцией для важных узлов"
    test_cases:
      - input: { n: 5 }
        expected: 1.257  # τ/5
        tolerance: 0.001
        
  - name: ring_radius
    given: "кольцо r, базовый радиус R"
    when: "вычисляем радиус кольца"
    then: "radius = R × φ^r"
    test_cases:
      - input: { ring: 2, base_radius: 50 }
        expected: 130.9  # 50 × φ²
        tolerance: 0.1

# ═══════════════════════════════════════════════════════════════════════════════
# ALGORITHMS
# ═══════════════════════════════════════════════════════════════════════════════

algorithms:

  force_directed_phi:
    description: "Force-directed layout с φ-оптимизацией"
    complexity: "O(n² × iterations)"
    pattern: "Iterative"
    steps:
      - "Инициализация:"
      - "  Разместить узлы по φ-спирали"
      - "  k = sqrt(area / n) × φ"
      - ""
      - "Для каждой итерации:"
      - "  # Отталкивание (все пары)"
      - "  Для каждой пары (u, v):"
      - "    d = distance(u, v)"
      - "    F = PHI × k² / d"
      - "    u.force -= F × direction(u, v)"
      - "    v.force += F × direction(u, v)"
      - ""
      - "  # Притяжение (рёбра)"
      - "  Для каждого ребра (u, v):"
      - "    d = distance(u, v)"
      - "    F = d² / (k × PHI)"
      - "    u.force += F × direction(u, v)"
      - "    v.force -= F × direction(u, v)"
      - ""
      - "  # Применение сил"
      - "  damping = PHI_INV × PHI^(-iter/max_iter)"
      - "  Для каждого узла u:"
      - "    u.velocity = u.velocity × 0.9 + u.force × damping"
      - "    u.position += u.velocity"
      - "    u.force = (0, 0)"
      - ""
      - "  # Проверка сходимости"
      - "  energy = sum(|velocity|²)"
      - "  Если energy < threshold: break"
      
  barnes_hut_phi:
    description: "Barnes-Hut с φ-оптимизацией"
    complexity: "O(n log n × iterations)"
    pattern: "D&C"
    steps:
      - "Построить quadtree с φ-разбиением"
      - "Для каждого узла:"
      - "  Обойти quadtree"
      - "  Если s/d < θ (θ = 1/φ): использовать центр масс"
      - "  Иначе: рекурсивно обойти детей"
      - "Применить силы с φ-демпфированием"
      
  phi_spiral_layout:
    description: "Размещение по φ-спирали"
    complexity: "O(n)"
    pattern: "Direct"
    steps:
      - "golden_angle = TAU × PHI_INV"
      - "Для i от 0 до n-1:"
      - "  angle = i × golden_angle"
      - "  radius = scale × PHI^(i × 0.1)"
      - "  x = center_x + radius × cos(angle)"
      - "  y = center_y + radius × sin(angle)"
      
  hierarchical_phi:
    description: "Иерархическое размещение с φ-пропорциями"
    complexity: "O(n)"
    pattern: "Recursive"
    steps:
      - "Определить уровни (BFS от корня)"
      - "Для каждого уровня l:"
      - "  y = height × (1 - PHI^(-l))"
      - "  spacing = width × PHI^(-l) / nodes_at_level"
      - "  Разместить узлы равномерно по x"
      - "Центрировать поддеревья под родителями"

# ═══════════════════════════════════════════════════════════════════════════════
# WASM EXPORTS
# ═══════════════════════════════════════════════════════════════════════════════

wasm_exports:
  functions:
    - force_directed_layout
    - force_directed_step
    - phi_spiral_layout
    - hierarchical_layout
    - radial_layout
    - compute_repulsion
    - compute_attraction
    - apply_forces
    - compute_energy
    
  memory:
    - name: nodes_buffer
      size: 4096
      type: LayoutNode
      description: "Буфер для узлов (до 4096 узлов)"
    - name: edges_buffer
      size: 16384
      type: LayoutEdge
      description: "Буфер для рёбер"
    - name: positions_buffer
      size: 8192
      type: Vec2
      description: "Буфер для позиций"

# ═══════════════════════════════════════════════════════════════════════════════
# PAS PREDICTIONS
# ═══════════════════════════════════════════════════════════════════════════════

pas_predictions:

  - target: force_directed
    current: "O(n²)"
    predicted: "O(n log n)"
    confidence: 0.90
    pattern: "D&C"
    method: "Barnes-Hut quadtree"
    status: "known_improvement"
    
  - target: convergence
    current: "~100 iterations"
    predicted: "~62 iterations (100/φ)"
    confidence: 0.75
    pattern: "ALG"
    method: "φ-adaptive damping"
    
  - target: gpu_acceleration
    current: "CPU O(n²)"
    predicted: "GPU O(n) parallel"
    confidence: 0.85
    pattern: "PRE"
    timeline: "2026"
