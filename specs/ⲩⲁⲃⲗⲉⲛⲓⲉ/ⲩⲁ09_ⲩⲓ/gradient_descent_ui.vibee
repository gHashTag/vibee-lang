# Gradient Descent UI - Layout Optimization via Gradient Descent
# Эволюция GEN UI: Оптимизация layout через дифференцируемые функции
# Author: Dmitrii Vasilev
# Version: 1.0.0

name: gradient_descent_ui
version: "1.0.0"
language: 999
module: ⲅⲉⲛ_ui.ⲅⲣⲁⲇⲓⲉⲛⲧ_ⲟⲡⲧⲓⲙⲓⲍⲁⲥⲓⲁ

# =============================================================================
# CREATION PATTERN
# =============================================================================

creation_pattern:
  source: InitialLayout | Constraints | DesignGoals
  transformer: DifferentiableLayoutOptimizer
  result: OptimizedLayout

# =============================================================================
# ТЕОРЕТИЧЕСКАЯ ОСНОВА
# =============================================================================

theory:
  name: "Differentiable Layout Optimization"
  description: |
    Gradient Descent UI формулирует задачу оптимизации layout как 
    минимизацию дифференцируемой функции потерь:
    
    L(layout) = Σ w_i * L_i(layout)
    
    где L_i - различные компоненты потерь:
    - Overlap loss: штраф за перекрытия
    - Alignment loss: штраф за несовпадение выравнивания
    - Spacing loss: штраф за неравномерные отступы
    - Aesthetic loss: штраф за нарушение эстетических правил
    - Constraint loss: штраф за нарушение заданных ограничений
    
    Оптимизация через градиентный спуск позволяет:
    - Находить локальные оптимумы
    - Учитывать множество критериев одновременно
    - Интерактивно корректировать веса
    
  mathematical_foundation:
    layout_representation: |
      Layout L = {e_1, e_2, ..., e_n}
      e_i = (x_i, y_i, w_i, h_i) ∈ ℝ⁴
      
      Параметры для оптимизации: θ = flatten([e_1, ..., e_n]) ∈ ℝ^{4n}
      
    loss_functions:
      overlap_loss: |
        L_overlap = Σ_{i<j} max(0, IoU(e_i, e_j))²
        
        Дифференцируемая аппроксимация IoU:
        IoU_soft(a, b) = Area(a ∩ b) / Area(a ∪ b)
        
        где Area вычисляется через soft-min/max:
        x_inter = softmax(x_a2, x_b2) - softmin(x_a1, x_b1)
        
      alignment_loss: |
        L_align = Σ_groups Σ_{i,j ∈ group} (
          w_left * |x_i - x_j|² +
          w_center * |center_x_i - center_x_j|² +
          w_right * |right_i - right_j|²
        )
        
      spacing_loss: |
        L_spacing = Σ_pairs |gap(e_i, e_j) - target_gap|²
        
        gap(a, b) = min(|x_a2 - x_b1|, |x_b2 - x_a1|, 
                        |y_a2 - y_b1|, |y_b2 - y_a1|)
        
      aesthetic_loss: |
        L_aesthetic = w_golden * L_golden_ratio +
                      w_grid * L_grid_alignment +
                      w_balance * L_visual_balance
                      
        L_golden_ratio = Σ_i |aspect(e_i) - φ|² where φ = 1.618
        L_grid_alignment = Σ_i min_g |x_i - g|² + |y_i - g|²
        L_visual_balance = |center_of_mass - screen_center|²
        
      constraint_loss: |
        L_constraint = Σ_c max(0, violation(c))²
        
        Типы ограничений:
        - Fixed position: |pos - target_pos|²
        - Min/max size: max(0, min_w - w)² + max(0, w - max_w)²
        - Containment: max(0, child_outside_parent)²
        - Ordering: max(0, x_i - x_j)² if i should be left of j
        
    optimization: |
      θ* = argmin_θ L(θ)
      
      Методы оптимизации:
      - SGD с momentum
      - Adam
      - L-BFGS для финальной полировки
      
      θ_{t+1} = θ_t - η * ∇L(θ_t)

# =============================================================================
# АРХИТЕКТУРА
# =============================================================================

architecture:
  name: "Gradient Descent UI Optimizer"
  
  components:
    # Представление layout
    layout_representation:
      element_params:
        - name: "position"
          params: ["x", "y"]
          range: [0, 1]
          
        - name: "size"
          params: ["w", "h"]
          range: [0.01, 1]
          
        - name: "rotation"
          params: ["angle"]
          range: [0, 360]
          optional: true
          
      parameterization:
        type: "normalized"
        description: "Все координаты в диапазоне [0, 1]"
        
    # Функции потерь
    loss_modules:
      - name: "OverlapLoss"
        differentiable: true
        weight_default: 10.0
        implementation: |
          def overlap_loss(layout):
            loss = 0
            for i, j in combinations(layout, 2):
              iou = soft_iou(layout[i], layout[j])
              loss += iou ** 2
            return loss
            
      - name: "AlignmentLoss"
        differentiable: true
        weight_default: 5.0
        alignment_types: ["left", "center", "right", "top", "middle", "bottom"]
        
      - name: "SpacingLoss"
        differentiable: true
        weight_default: 3.0
        spacing_modes: ["equal", "golden", "custom"]
        
      - name: "GridLoss"
        differentiable: true
        weight_default: 2.0
        grid_types: ["8-column", "12-column", "custom"]
        
      - name: "AestheticLoss"
        differentiable: true
        weight_default: 1.0
        components: ["golden_ratio", "visual_balance", "whitespace"]
        
      - name: "ConstraintLoss"
        differentiable: true
        weight_default: 100.0
        constraint_types: ["fixed", "relative", "containment", "ordering"]
        
    # Оптимизатор
    optimizer:
      primary:
        type: "Adam"
        learning_rate: 0.01
        betas: [0.9, 0.999]
        
      refinement:
        type: "L-BFGS"
        max_iter: 100
        tolerance: 1e-6
        
      scheduling:
        type: "cosine_annealing"
        T_max: 1000
        eta_min: 1e-5
        
    # Constraint solver
    constraint_solver:
      method: "projected_gradient"
      projection_types:
        - "bbox_bounds"
        - "containment"
        - "non_overlap"
        
      hard_constraints:
        description: "Ограничения которые нельзя нарушать"
        handling: "projection after each step"
        
      soft_constraints:
        description: "Ограничения с штрафом"
        handling: "loss term"

# =============================================================================
# CONSTRAINT TYPES
# =============================================================================

constraints:
  positional:
    - name: "ⲪⲒⲔⲤⲒⲢⲞⲂⲀⲚⲚⲀⲀ_ⲠⲞⲌⲒⲤⲒⲀ"
      type: "fixed_position"
      params: ["element_id", "x", "y"]
      description: "Элемент должен быть в заданной позиции"
      
    - name: "ⲞⲦⲚⲞⲤⲒⲦⲈⲖⲒⲚⲀⲀ_ⲠⲞⲌⲒⲤⲒⲀ"
      type: "relative_position"
      params: ["element_id", "anchor_id", "offset_x", "offset_y"]
      description: "Элемент относительно другого"
      
  sizing:
    - name: "ⲪⲒⲔⲤⲒⲢⲞⲂⲀⲚⲚⲨⲒ_ⲢⲀⲌⲘⲈⲢ"
      type: "fixed_size"
      params: ["element_id", "width", "height"]
      
    - name: "ⲘⲒⲚⲒⲘⲀⲖⲒⲚⲨⲒ_ⲢⲀⲌⲘⲈⲢ"
      type: "min_size"
      params: ["element_id", "min_width", "min_height"]
      
    - name: "ⲘⲀⲔⲤⲒⲘⲀⲖⲒⲚⲨⲒ_ⲢⲀⲌⲘⲈⲢ"
      type: "max_size"
      params: ["element_id", "max_width", "max_height"]
      
    - name: "ⲤⲞⲞⲦⲚⲞⲰⲈⲚⲒⲈ_ⲤⲦⲞⲢⲞⲚ"
      type: "aspect_ratio"
      params: ["element_id", "ratio"]
      
  alignment:
    - name: "ⲂⲨⲢⲀⲂⲚⲒⲂⲀⲚⲒⲈ_ⲖⲈⲂⲞ"
      type: "align_left"
      params: ["element_ids"]
      
    - name: "ⲂⲨⲢⲀⲂⲚⲒⲂⲀⲚⲒⲈ_ⲤⲈⲚⲦⲢ"
      type: "align_center"
      params: ["element_ids"]
      
    - name: "ⲂⲨⲢⲀⲂⲚⲒⲂⲀⲚⲒⲈ_ⲠⲢⲀⲂⲞ"
      type: "align_right"
      params: ["element_ids"]
      
    - name: "ⲢⲀⲤⲠⲢⲈⲆⲈⲖⲈⲚⲒⲈ"
      type: "distribute"
      params: ["element_ids", "direction", "spacing"]
      
  hierarchy:
    - name: "ⲤⲞⲆⲈⲢⲌⲀⲚⲒⲈ"
      type: "containment"
      params: ["child_id", "parent_id", "padding"]
      description: "Дочерний элемент внутри родителя"
      
    - name: "ⲠⲞⲢⲀⲆⲞⲔ"
      type: "ordering"
      params: ["element_ids", "direction"]
      description: "Порядок элементов слева-направо или сверху-вниз"

# =============================================================================
# BEHAVIORS
# =============================================================================

behaviors:
  - name: overlap_elimination
    given: "Layout с перекрывающимися элементами"
    when: "Запуск оптимизации с overlap_loss"
    then: "Все перекрытия устранены"
    
    test_cases:
      - name: "two_overlapping_buttons"
        input:
          elements:
            - {id: "btn1", bbox: [0.1, 0.1, 0.3, 0.1]}
            - {id: "btn2", bbox: [0.2, 0.1, 0.3, 0.1]}  # overlaps btn1
          weights: {overlap: 10.0}
          max_iterations: 500
        expected:
          overlap_iou: 0.0
          elements_moved: true
          
      - name: "multiple_overlaps"
        input:
          elements:
            - {id: "e1", bbox: [0.3, 0.3, 0.2, 0.2]}
            - {id: "e2", bbox: [0.35, 0.35, 0.2, 0.2]}
            - {id: "e3", bbox: [0.4, 0.4, 0.2, 0.2]}
          weights: {overlap: 10.0}
        expected:
          total_overlap: 0.0
          
  - name: alignment_optimization
    given: "Layout с неровным выравниванием"
    when: "Запуск оптимизации с alignment_loss"
    then: "Элементы выровнены по заданным осям"
    
    test_cases:
      - name: "left_align_buttons"
        input:
          elements:
            - {id: "btn1", bbox: [0.1, 0.1, 0.2, 0.05]}
            - {id: "btn2", bbox: [0.12, 0.2, 0.2, 0.05]}  # slightly off
            - {id: "btn3", bbox: [0.09, 0.3, 0.2, 0.05]}  # slightly off
          constraints:
            - {type: "align_left", elements: ["btn1", "btn2", "btn3"]}
        expected:
          left_edges_equal: true
          tolerance: 0.001
          
  - name: spacing_optimization
    given: "Layout с неравномерными отступами"
    when: "Запуск оптимизации с spacing_loss"
    then: "Отступы между элементами равномерны"
    
    test_cases:
      - name: "equal_spacing"
        input:
          elements:
            - {id: "e1", bbox: [0.1, 0.1, 0.15, 0.1]}
            - {id: "e2", bbox: [0.3, 0.1, 0.15, 0.1]}
            - {id: "e3", bbox: [0.6, 0.1, 0.15, 0.1]}  # unequal gap
          constraints:
            - {type: "distribute", elements: ["e1", "e2", "e3"], direction: "horizontal"}
        expected:
          gaps_equal: true
          gap_variance: "<0.01"
          
  - name: constraint_satisfaction
    given: "Layout с набором ограничений"
    when: "Запуск оптимизации"
    then: "Все ограничения удовлетворены"
    
    test_cases:
      - name: "containment_constraint"
        input:
          elements:
            - {id: "container", bbox: [0.1, 0.1, 0.5, 0.5]}
            - {id: "child", bbox: [0.05, 0.05, 0.2, 0.2]}  # outside
          constraints:
            - {type: "containment", child: "child", parent: "container", padding: 0.02}
        expected:
          child_inside_parent: true
          padding_respected: true

# =============================================================================
# OPTIMIZATION STRATEGIES
# =============================================================================

optimization_strategies:
  - name: "coarse_to_fine"
    description: "Сначала грубая оптимизация, потом точная"
    stages:
      - {name: "coarse", lr: 0.1, iterations: 100, losses: ["overlap"]}
      - {name: "medium", lr: 0.01, iterations: 300, losses: ["overlap", "alignment"]}
      - {name: "fine", lr: 0.001, iterations: 500, losses: "all"}
      
  - name: "constraint_first"
    description: "Сначала удовлетворить ограничения, потом эстетика"
    stages:
      - {name: "constraints", weight_constraint: 100, weight_aesthetic: 0}
      - {name: "aesthetic", weight_constraint: 10, weight_aesthetic: 1}
      
  - name: "hierarchical"
    description: "Оптимизация по уровням иерархии"
    stages:
      - {name: "root_level", elements: "root_children"}
      - {name: "nested", elements: "all", freeze: "root_children"}

# =============================================================================
# INTERACTIVE MODE
# =============================================================================

interactive_mode:
  features:
    - name: "live_preview"
      description: "Обновление layout в реальном времени"
      update_rate: "60fps"
      
    - name: "weight_sliders"
      description: "Интерактивные слайдеры для весов потерь"
      weights: ["overlap", "alignment", "spacing", "aesthetic"]
      
    - name: "constraint_editor"
      description: "Визуальное добавление ограничений"
      tools: ["align", "distribute", "fix_position", "set_size"]
      
    - name: "gradient_visualization"
      description: "Визуализация градиентов для отладки"
      show: ["direction", "magnitude"]

# =============================================================================
# PAS ANALYSIS
# =============================================================================

pas_analysis:
  current_state:
    algorithm: "Constraint-based Layout (CSS Flexbox/Grid)"
    complexity: "O(n) but limited expressiveness"
    limitations:
      - "Discrete constraints only"
      - "No global optimization"
      - "Manual tuning required"
      
  improvement:
    algorithm: "Gradient Descent Layout Optimization"
    complexity: "O(n²·k) where k = iterations"
    patterns_applied:
      - symbol: "ALG"
        name: "Algebraic Reorganization"
        application: "Differentiable loss formulation"
      - symbol: "PRB"
        name: "Probabilistic"
        application: "Stochastic gradient descent"
      - symbol: "MLS"
        name: "ML-Guided Search"
        application: "Learned loss weights"
        
  prediction:
    quality_improvement: "40%"
    automation_level: "High"
    confidence: 0.75
    timeline: "2025"

# =============================================================================
# API
# =============================================================================

api:
  functions:
    - name: "ⲞⲠⲦⲒⲘⲒⲌⲒⲢⲞⲂⲀⲦⲒ_LAYOUT"
      description: "Оптимизация layout через градиентный спуск"
      input:
        - name: "layout"
          type: "Layout"
        - name: "constraints"
          type: "List[Constraint]"
          default: []
        - name: "weights"
          type: "Dict[str, float]"
          default: {overlap: 10, alignment: 5, spacing: 3, aesthetic: 1}
        - name: "max_iterations"
          type: "int"
          default: 1000
        - name: "tolerance"
          type: "float"
          default: 1e-6
      output: "OptimizedLayout"
      
    - name: "ⲨⲤⲦⲢⲀⲚⲒⲦⲒ_ⲠⲈⲢⲈⲔⲢⲨⲦⲒⲀ"
      description: "Устранение перекрытий"
      input:
        - name: "layout"
          type: "Layout"
        - name: "method"
          type: "string"
          default: "gradient"
          options: ["gradient", "force_directed", "greedy"]
      output: "Layout"
      
    - name: "ⲂⲨⲢⲞⲂⲚⲀⲦⲒ_ⲈⲖⲈⲘⲈⲚⲦⲨ"
      description: "Выравнивание элементов"
      input:
        - name: "elements"
          type: "List[Element]"
        - name: "alignment"
          type: "string"
          options: ["left", "center", "right", "top", "middle", "bottom"]
      output: "List[Element]"
      
    - name: "ⲢⲀⲤⲠⲢⲈⲆⲈⲖⲒⲦⲒ_ⲈⲖⲈⲘⲈⲚⲦⲨ"
      description: "Равномерное распределение элементов"
      input:
        - name: "elements"
          type: "List[Element]"
        - name: "direction"
          type: "string"
          options: ["horizontal", "vertical"]
        - name: "spacing"
          type: "float"
          default: "auto"
      output: "List[Element]"
      
    - name: "ⲂⲒⲌⲨⲀⲖⲒⲌⲒⲢⲞⲂⲀⲦⲒ_ⲄⲢⲀⲆⲒⲈⲚⲦⲨ"
      description: "Визуализация градиентов для отладки"
      input:
        - name: "layout"
          type: "Layout"
        - name: "loss_type"
          type: "string"
      output: "GradientVisualization"

# =============================================================================
# INTEGRATION
# =============================================================================

vibee_integration:
  input_sources:
    - "UniLayDiff output"
    - "ULDGNN detected layout"
    - "Manual layout specification"
    
  output_targets:
    - "Optimized .999 UI code"
    - "Constraint-satisfied layout"
    
  workflow:
    1: "Receive initial layout"
    2: "Parse constraints from .vibee spec"
    3: "Run gradient descent optimization"
    4: "Validate constraints satisfied"
    5: "Generate optimized .999 code"
