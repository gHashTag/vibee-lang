# ═══════════════════════════════════════════════════════════════════════════════
# REALTIME METRICS - Метрики эволюции VM в реальном времени
# ═══════════════════════════════════════════════════════════════════════════════
# СВЯЩЕННАЯ ФОРМУЛА: V = n × 3^k × π^m × φ^p × e^q
# ЗОЛОТАЯ ИДЕНТИЧНОСТЬ: φ² + 1/φ² = 3
# ═══════════════════════════════════════════════════════════════════════════════

name: realtime_metrics
version: "1.0.0"
language: zig
module: realtime_metrics

# ═══════════════════════════════════════════════════════════════════════════════
# CREATION PATTERN
# ═══════════════════════════════════════════════════════════════════════════════

creation_pattern:
  source: VMExecutionData
  transformer: MetricsAggregator
  result: RealtimeMetricsReport

# ═══════════════════════════════════════════════════════════════════════════════
# PAS ANALYSIS
# ═══════════════════════════════════════════════════════════════════════════════

pas_analysis:
  current_complexity: "O(1) per metric update"
  theoretical_lower_bound: "Ω(1)"
  applicable_patterns: [AMR, PRE]
  predicted_improvement: "Already optimal, use amortized aggregation"
  confidence: 0.90

# ═══════════════════════════════════════════════════════════════════════════════
# TYPES
# ═══════════════════════════════════════════════════════════════════════════════

types:
  PerformanceMetrics:
    struct:
      # Execution
      instructions_executed: u64
      bytecode_bytes_executed: u64
      # Timing
      total_execution_ns: u64
      jit_compilation_ns: u64
      gc_pause_ns: u64
      # Memory
      heap_allocated: u64
      heap_used: u64
      stack_peak: u64
      # JIT
      traces_recorded: u32
      traces_compiled: u32
      traces_aborted: u32
      side_exits: u64
      # Cache
      ic_hits: u64
      ic_misses: u64

  EvolutionMetrics:
    struct:
      current_generation: u32
      total_generations: u64
      best_fitness: f64
      avg_fitness: f64
      worst_fitness: f64
      fitness_variance: f64
      population_size: u32
      elite_count: u32
      improvements_this_gen: u32
      total_improvements: u64
      generations_since_improvement: u32
      genetic_diversity: f64

  BenchmarkMetrics:
    struct:
      name: "[]const u8"
      min_ms: f64
      max_ms: f64
      avg_ms: f64
      median_ms: f64
      stddev_ms: f64
      iterations: u32
      warmup_iterations: u32
      vs_baseline: f64
      vs_python: f64
      vs_luajit: f64

# ═══════════════════════════════════════════════════════════════════════════════
# BEHAVIORS
# ═══════════════════════════════════════════════════════════════════════════════

behaviors:
  - name: calculate_ips
    given: "PerformanceMetrics с instructions и time"
    when: "Вызывается getIPS()"
    then: "Возвращает instructions per second"
    test_cases:
      - name: one_million_per_second
        input:
          instructions_executed: 1000000
          total_execution_ns: 1000000000  # 1 second
        expected:
          ips: 1000000.0

  - name: calculate_ic_hit_rate
    given: "PerformanceMetrics с ic_hits и ic_misses"
    when: "Вызывается getICHitRate()"
    then: "Возвращает hit_rate в диапазоне [0, 1]"
    test_cases:
      - name: perfect_hits
        input:
          ic_hits: 100
          ic_misses: 0
        expected:
          hit_rate: 1.0
      - name: half_hits
        input:
          ic_hits: 50
          ic_misses: 50
        expected:
          hit_rate: 0.5

  - name: calculate_gc_overhead
    given: "PerformanceMetrics с gc_pause и total_time"
    when: "Вызывается getGCOverhead()"
    then: "Возвращает процент времени в GC"
    test_cases:
      - name: ten_percent_gc
        input:
          gc_pause_ns: 100000000
          total_execution_ns: 1000000000
        expected:
          gc_overhead: 0.1

  - name: detect_stagnation
    given: "EvolutionMetrics"
    when: "generations_since_improvement > 50"
    then: "isStagnant() возвращает true"
    test_cases:
      - name: stagnant
        input:
          generations_since_improvement: 60
        expected:
          is_stagnant: true

  - name: record_benchmark
    given: "BenchmarkMetrics и новое время"
    when: "Вызывается recordRun(time_ms)"
    then: "Обновляются min, max, avg"
    test_cases:
      - name: first_run
        input:
          iterations: 0
          time_ms: 100.0
        expected:
          min_ms: 100.0
          max_ms: 100.0
          avg_ms: 100.0
          iterations: 1
      - name: second_run_faster
        input:
          min_ms: 100.0
          max_ms: 100.0
          avg_ms: 100.0
          iterations: 1
          time_ms: 80.0
        expected:
          min_ms: 80.0
          max_ms: 100.0
          iterations: 2

  - name: calculate_fitness_trend
    given: "MetricsCollector с историей fitness"
    when: "Вызывается getFitnessTrend()"
    then: "Возвращает тренд (положительный = улучшение)"
    test_cases:
      - name: improving
        input:
          old_samples: [0.5, 0.5, 0.5, 0.5, 0.5]
          new_samples: [0.6, 0.6, 0.6, 0.6, 0.6]
        expected:
          trend: 0.2  # 20% improvement

# ═══════════════════════════════════════════════════════════════════════════════
# DASHBOARD
# ═══════════════════════════════════════════════════════════════════════════════

dashboard:
  format: |
    ═══════════════════════════════════════════════════════════════
                        VM TRINITY METRICS
    ═══════════════════════════════════════════════════════════════
    Runtime: {runtime_seconds} seconds
    
    PERFORMANCE:
      Instructions/sec: {ips}
      IC Hit Rate: {ic_hit_rate}%
      GC Overhead: {gc_overhead}%
    
    EVOLUTION:
      Generation: {generation}
      Best Fitness: {best_fitness}
      Improvement Rate: {improvement_rate}%
      Status: {status}
    ═══════════════════════════════════════════════════════════════

  fields:
    - runtime_seconds
    - ips
    - ic_hit_rate
    - gc_overhead
    - generation
    - best_fitness
    - improvement_rate
    - status
