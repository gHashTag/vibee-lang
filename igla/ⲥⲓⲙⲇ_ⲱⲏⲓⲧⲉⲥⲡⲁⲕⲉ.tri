// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â²¤â²’â²˜â²† â²°â²â²’â²¦â²ˆâ²¤â² â²€â²”â²ˆ â²†â²ˆâ²¦â²ˆâ²”â²¦â²’â²â²š
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â²¤â²€â²”â²¢â²€ â²ªâ²â²¢â²˜â²¨â²–â²€: V = n Ã— 3^k Ã— Ï€^m Ã— Ï†^p Ã— e^q
// â²Œâ²â²–â²â²¦â²€â²’â²€ â²’â²†â²ˆâ²šâ²¦â²’â²¬â²šâ²â²¤â²¦â²’: Ï†Â² + 1/Ï†Â² = 3
// SOURCE: simdjson, branchfree.org
// RESULT: 4-8x speedup for whitespace skipping
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â²§â²£â²“â²›â²“â²§â²“ â²¥â²“â²™â²‡_â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰ {
    â²Ÿâ²›â²Ÿâ²™â²: "SIMD Whitespace Detection"
    â²ƒâ²‰â²£â²¥â²“â²: "1.0.0"
    â²¡â²â²§â²§â²‰â²£â²›: "D&C"
    â²•â²Ÿâ²›â²«â²“â²‡â²‰â²›â²•â²‰: 0.90
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CORE CONCEPT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²•â²Ÿâ²›â²•â²‰â²¡â²§: """
    SIMD whitespace detection processes 16/32 bytes at a time using
    vector instructions. Instead of checking each byte individually,
    we compare entire vectors against whitespace characters and use
    bitmask operations to find the first non-whitespace byte.
    
    Key pattern: PCMPEQB + PMOVMSKB
    1. Load 16/32 bytes into SIMD register
    2. Compare each byte with whitespace chars (space, tab, newline, CR)
    3. Extract bitmask of comparison results
    4. Use CTZ (count trailing zeros) to find first non-whitespace
    
    Expected speedup: 4-8x for skip_whitespace
    """
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WHITESPACE CHARACTERS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰_â²­â²â²â²£â²¥: [
        { â²•â²Ÿâ²‡â²‰: 0x20, â²Ÿâ²›â²Ÿâ²™â²: "space" },
        { â²•â²Ÿâ²‡â²‰: 0x09, â²Ÿâ²›â²Ÿâ²™â²: "tab" },
        { â²•â²Ÿâ²‡â²‰: 0x0A, â²Ÿâ²›â²Ÿâ²™â²: "newline" },
        { â²•â²Ÿâ²‡â²‰: 0x0D, â²Ÿâ²›â²Ÿâ²™â²: "carriage_return" }
    ]
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ALGORITHM (SSE2 - 16 bytes)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²â²—â²…â²Ÿâ²£â²“â²§â²â²™_â²¥â²¥â²‰2: """
    fn skipWhitespaceSSE2(input: []const u8) usize {
        var pos: usize = 0;
        
        // Process 16 bytes at a time
        while (pos + 16 <= input.len) {
            const chunk: @Vector(16, u8) = input[pos..][0..16].*;
            
            // Compare with each whitespace character
            const space_mask = chunk == @splat(' ');
            const tab_mask = chunk == @splat('\t');
            const nl_mask = chunk == @splat('\n');
            const cr_mask = chunk == @splat('\r');
            
            // OR all masks
            const ws_mask = space_mask | tab_mask | nl_mask | cr_mask;
            
            // Invert and find first non-whitespace
            const non_ws_mask = ~ws_mask;
            const bitmask = @as(u16, @bitCast(non_ws_mask));
            
            if (bitmask != 0) {
                // Found non-whitespace
                return pos + @ctz(bitmask);
            }
            
            pos += 16;
        }
        
        // Scalar fallback for remainder
        while (pos < input.len) {
            const c = input[pos];
            if (c != ' ' and c != '\t' and c != '\n' and c != '\r') {
                return pos;
            }
            pos += 1;
        }
        
        return pos;
    }
    """
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ALGORITHM (AVX2 - 32 bytes)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²â²—â²…â²Ÿâ²£â²“â²§â²â²™_â²â²ƒâ²2: """
    fn skipWhitespaceAVX2(input: []const u8) usize {
        var pos: usize = 0;
        
        // Process 32 bytes at a time
        while (pos + 32 <= input.len) {
            const chunk: @Vector(32, u8) = input[pos..][0..32].*;
            
            const space_mask = chunk == @splat(' ');
            const tab_mask = chunk == @splat('\t');
            const nl_mask = chunk == @splat('\n');
            const cr_mask = chunk == @splat('\r');
            
            const ws_mask = space_mask | tab_mask | nl_mask | cr_mask;
            const non_ws_mask = ~ws_mask;
            const bitmask = @as(u32, @bitCast(non_ws_mask));
            
            if (bitmask != 0) {
                return pos + @ctz(bitmask);
            }
            
            pos += 32;
        }
        
        // Fallback to SSE2 for remainder
        return pos + skipWhitespaceSSE2(input[pos..]);
    }
    """
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STRUCTURAL INDEXER (like simdjson)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²¥â²§â²£â²©â²•â²§â²©â²£â²â²—_â²“â²›â²‡â²‰â²â²‰â²£: """
    Classify 64 bytes at a time into structural and whitespace masks.
    Used for fast JSON/TRI parsing.
    
    Structural characters: { } [ ] : ,
    
    fn classify64Bytes(input: []const u8) struct { structural: u64, whitespace: u64 } {
        var structural: u64 = 0;
        var whitespace: u64 = 0;
        
        // Process 4 Ã— 16 bytes
        inline for (0..4) |i| {
            const offset = i * 16;
            const chunk: @Vector(16, u8) = input[offset..][0..16].*;
            
            // Structural characters
            const lbrace = chunk == @splat('{');
            const rbrace = chunk == @splat('}');
            const lbracket = chunk == @splat('[');
            const rbracket = chunk == @splat(']');
            const colon = chunk == @splat(':');
            const comma = chunk == @splat(',');
            
            const struct_mask = lbrace | rbrace | lbracket | rbracket | colon | comma;
            structural |= @as(u64, @as(u16, @bitCast(struct_mask))) << offset;
            
            // Whitespace
            const space = chunk == @splat(' ');
            const tab = chunk == @splat('\t');
            const nl = chunk == @splat('\n');
            const cr = chunk == @splat('\r');
            
            const ws_mask = space | tab | nl | cr;
            whitespace |= @as(u64, @as(u16, @bitCast(ws_mask))) << offset;
        }
        
        return .{ .structural = structural, .whitespace = whitespace };
    }
    """
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BEHAVIORS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²ƒâ²‰â²â²â²ƒâ²“â²Ÿâ²£â²¥ {
        â²§â²‰â²¥â²§ "â²¥â²•â²“â²¡_â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰_â²¥â²¡â²â²•â²‰â²¥" {
            â²…â²“â²ƒâ²‰â²›: "input = '    hello'"
            â²±â²â²‰â²›: "skipWhitespace(input)"
            â²§â²â²‰â²›: "returns 4 (index of 'h')"
        }
        
        â²§â²‰â²¥â²§ "â²¥â²•â²“â²¡_â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰_â²™â²“â²â²‰â²‡" {
            â²…â²“â²ƒâ²‰â²›: "input = ' \\t\\n\\rhello'"
            â²±â²â²‰â²›: "skipWhitespace(input)"
            â²§â²â²‰â²›: "returns 4 (index of 'h')"
        }
        
        â²§â²‰â²¥â²§ "â²¥â²•â²“â²¡_â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰_â²›â²Ÿâ²›â²‰" {
            â²…â²“â²ƒâ²‰â²›: "input = 'hello'"
            â²±â²â²‰â²›: "skipWhitespace(input)"
            â²§â²â²‰â²›: "returns 0 (no whitespace)"
        }
        
        â²§â²‰â²¥â²§ "â²¥â²•â²“â²¡_â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰_â²â²—â²—" {
            â²…â²“â²ƒâ²‰â²›: "input = '                ' (16 spaces)"
            â²±â²â²‰â²›: "skipWhitespace(input)"
            â²§â²â²‰â²›: "returns 16 (end of input)"
        }
        
        â²§â²‰â²¥â²§ "â²¥â²•â²“â²¡_â²±â²â²“â²§â²‰â²¥â²¡â²â²•â²‰_â²—â²â²£â²…â²‰" {
            â²…â²“â²ƒâ²‰â²›: "input = 100 spaces + 'x'"
            â²±â²â²‰â²›: "skipWhitespace(input)"
            â²§â²â²‰â²›: "returns 100 (index of 'x')"
        }
        
        â²§â²‰â²¥â²§ "â²•â²—â²â²¥â²¥â²“â²«â²©_â²¥â²§â²£â²©â²•â²§â²©â²£â²â²—" {
            â²…â²“â²ƒâ²‰â²›: "input = '{\"key\": 42}'"
            â²±â²â²‰â²›: "classify64Bytes(input)"
            â²§â²â²‰â²›: "structural mask has bits set for { : }"
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GENERATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²…â²‰â²›â²‰â²£â²â²§â²“â²Ÿâ²› {
        â²Ÿâ²©â²§â²¡â²©â²§_â²‡â²“â²£: "output/"
        â²«â²“â²—â²‰â²¥: [
            { â²›â²â²™â²‰: "simd_whitespace.zig", â²¥â²Ÿâ²©â²£â²•â²‰: "all" }
        ]
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // EXPECTED RESULTS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²‰â²â²¡â²‰â²•â²§â²‰â²‡_â²£â²‰â²¥â²©â²—â²§â²¥ {
        â²¥â²¡â²‰â²‰â²‡â²©â²¡: "4-8x for skip_whitespace"
        â²§â²â²£â²Ÿâ²©â²…â²â²¡â²©â²§: "â‰¥200 MB/s"
        â²¥â²“â²™â²‡_â²±â²“â²‡â²§â²: "16 bytes (SSE2) or 32 bytes (AVX2)"
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¥ â²ªâ²â²ˆâ²šâ²’â²œ â²‚â²–â²ˆâ²¤â²¤â²’â²šâ²„ ğŸ”¥
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Ğ­Ñ‚Ğ¾Ñ‚ Ğ¼Ğ¾Ğ´ÑƒĞ»ÑŒ Ğ±Ğ»Ğ°Ğ³Ğ¾ÑĞ»Ğ¾Ğ²Ğ»Ñ‘Ğ½ Ğ–Ğ°Ñ€-Ğ¿Ñ‚Ğ¸Ñ†ĞµĞ¹ (PHOENIX = 999 = 3Â³ Ã— 37)
    // Ğ¤Ğ°Ğ·Ñ‹ Ğ¿Ğ¾Ğ»Ñ‘Ñ‚Ğ°: ĞŸĞ•ĞŸĞ•Ğ› â†’ Ğ˜Ğ¡ĞšĞ Ğ â†’ ĞŸĞ›ĞĞœĞ¯ â†’ Ğ’ĞĞ—Ğ ĞĞ–Ğ”Ğ•ĞĞ˜Ğ•
    // Ğ¡Ğ¿Ğ¾ÑĞ¾Ğ±Ğ½Ğ¾ÑÑ‚Ğ¸: Ğ˜Ğ¡Ğ¦Ğ•Ğ›Ğ•ĞĞ˜Ğ• (1/Ï†) + Ğ­Ğ’ĞĞ›Ğ®Ğ¦Ğ˜Ğ¯ (Î¼ = 1/Ï†Â²/10)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    â²«â²Ÿâ²‰â²›â²“â²_â²ƒâ²—â²‰â²¥â²¥â²“â²›â²…: {
        â²‰â²›â²â²ƒâ²—â²‰â²‡: true
        â²«â²—â²“â²…â²â²§_â²¥â²¡â²‰â²‰â²‡: 1.618033988749895
        â²â²‰â²â²—â²“â²›â²…_â²¡â²Ÿâ²±â²‰â²£: 0.618033988749895
        â²‰â²©â²Ÿâ²—â²©â²§â²“â²Ÿâ²›_â²£â²â²§â²‰: 0.0382
        
        â²¡â²â²â²¥â²‰â²¥: {
            â² â²ˆâ² â²ˆâ²–: "Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· ĞºĞ¾Ğ´Ğ°, ÑĞ±Ğ¾Ñ€ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº"
            â²’â²¤â²”â²¢â²€: "Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¼ÑƒÑ‚Ğ°Ñ†Ğ¸Ğ¹, PAS Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹"
            â² â²–â²€â²˜â²’â²€: "Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ, ÑĞµĞ»ĞµĞºÑ†Ğ¸Ñ"
            â²‚â²â²Œâ²¢â²â²Œâ²†â²ˆâ²šâ²’â²ˆ: "Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ğ¹"
        }
        
        â²â²‰â²â²—â²“â²›â²…_â²â²ƒâ²“â²—â²“â²§â²“â²‰â²¥: [
            "dead_code_removal",
            "memory_optimization",
            "type_error_fix",
            "loop_optimization",
            "constant_folding"
        ]
        
        â²‰â²©â²Ÿâ²—â²©â²§â²“â²Ÿâ²›_â²¡â²â²§â²§â²‰â²£â²›â²¥: [
            "D&C  â†’ Divide-and-Conquer",
            "ALG  â†’ Algebraic Reorganization",
            "PRE  â†’ Precomputation",
            "SIMD â†’ Vectorization"
        ]
    }

}
