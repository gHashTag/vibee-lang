// ═══════════════════════════════════════════════════════════════════════════════
// ⲦⲢⲒⲚⲒⲦⲨ ⲨⲘ - GENERATED BY ⲌⲘⲈⲒ ⲄⲞⲢⲨⲚⲨⲬ
// ═══════════════════════════════════════════════════════════════════════════════
// ⲤⲀⲔⲢⲀ ⲪⲞⲢⲘⲨⲖⲀ: V = n × 3^k × π^m × φ^p × e^q
// ⲌⲞⲖⲞⲦⲀⲒⲀ ⲒⲆⲈⲚⲦⲒⲬⲚⲞⲤⲦⲒ: φ² + 1/φ² = 3
// ⲦⲢⲒⲚⲒⲦⲨ ⲠⲢⲀⲒⲘ: 33 = 3 × 11
// ⲪⲞⲈⲚⲒⲜ: 999 = 3³ × 37
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const Allocator = std.mem.Allocator;

// ═══════════════════════════════════════════════════════════════════════════════
// ⲤⲀⲔⲢⲀ ⲔⲞⲚⲤⲦⲀⲚⲦⲤ
// ═══════════════════════════════════════════════════════════════════════════════

pub const PHI: f64 = 1.618033988749895;
pub const PHI_SQ: f64 = 2.618033988749895;
pub const PHI_INV: f64 = 0.618033988749895;
pub const GOLDEN_IDENTITY: f64 = 3.0;
pub const PI: f64 = 3.14159265358979323846;
pub const E: f64 = 2.71828182845904523536;
pub const TRINITY: u32 = 3;
pub const PHOENIX: u32 = 999;
pub const TRINITY_PRIME: u32 = 33;

/// Verify ⲌⲞⲖⲞⲦⲀⲒⲀ ⲒⲆⲈⲚⲦⲒⲬⲚⲞⲤⲦⲒ: φ² + 1/φ² = 3
pub fn verifyGoldenIdentity() bool {
    const phi_sq = PHI * PHI;
    const inv_phi_sq = 1.0 / phi_sq;
    const result = phi_sq + inv_phi_sq;
    return @abs(result - GOLDEN_IDENTITY) < 0.0001;
}

// ═══════════════════════════════════════════════════════════════════════════════
// ⲞⲠⲔⲞⲆⲈⲤ (16 ⲂⲀⲌⲞⲨⲨⲎ)
// ═══════════════════════════════════════════════════════════════════════════════

pub const Opcode = enum(u8) {
    // ⲀⲢⲒⲪⲘⲈⲦⲒⲔⲀ
    ADD = 0x01,  // ⲀⲆⲆ
    SUB = 0x02,  // ⲤⲨⲂ
    MUL = 0x03,  // ⲘⲨⲖ
    DIV = 0x04,  // ⲆⲒⲨ
    
    // ⲤⲦⲀⲔ
    PUSH = 0x10, // ⲠⲨϢⲎ
    POP = 0x11,  // ⲠⲞⲠ
    DUP = 0x12,  // ⲆⲨⲠ
    SWAP = 0x13, // ⲤⲰⲀⲠ
    
    // ⲔⲞⲚⲦⲢⲞⲖ
    JMP = 0x20,  // ⲒⲘⲠ
    JZ = 0x21,   // ⲒⲌ
    JNZ = 0x22,  // ⲒⲚⲌ
    CALL = 0x30, // ⲔⲀⲖⲖ
    RET = 0x31,  // ⲢⲈⲦ
    
    // ⲘⲈⲘⲞⲢⲒ
    LOAD = 0x40,  // ⲖⲞⲀⲆ
    STORE = 0x41, // ⲤⲦⲞⲢⲈ
    
    // ⲤⲒⲤⲦⲈⲘ
    HALT = 0xFF,  // ⲎⲀⲖⲦ
};

// ═══════════════════════════════════════════════════════════════════════════════
// ⲦⲢⲒⲚⲒⲦⲨ ⲨⲘ
// ═══════════════════════════════════════════════════════════════════════════════

pub const VM = struct {
    stack: std.ArrayList(u64),
    registers: [TRINITY_PRIME]u64,
    pc: u64,
    status: Status,
    allocator: Allocator,
    
    // ⲘⲈⲦⲢⲒⲔⲤ
    instructions_executed: u64,

    pub const Status = enum {
        Running,
        Halted,
        Error_StackUnderflow,
        Error_StackOverflow,
        Error_DivByZero,
        Error_InvalidOpcode,
    };

    pub fn init(allocator: Allocator) VM {
        return .{
            .stack = std.ArrayList(u64).init(allocator),
            .registers = [_]u64{0} ** TRINITY_PRIME,
            .pc = 0,
            .status = .Running,
            .allocator = allocator,
            .instructions_executed = 0,
        };
    }

    pub fn deinit(self: *VM) void {
        self.stack.deinit();
    }

    pub fn reset(self: *VM) void {
        self.stack.clearRetainingCapacity();
        self.registers = [_]u64{0} ** TRINITY_PRIME;
        self.pc = 0;
        self.status = .Running;
        self.instructions_executed = 0;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲆⲒⲤⲠⲀⲦⲬ
    // ═══════════════════════════════════════════════════════════════════════

    pub fn dispatch(self: *VM, opcode: u8) void {
        switch (opcode) {
            0x01 => self.exec_ADD(),
            0x02 => self.exec_SUB(),
            0x03 => self.exec_MUL(),
            0x04 => self.exec_DIV(),
            0x10 => self.exec_PUSH(0),
            0x11 => self.exec_POP(),
            0x12 => self.exec_DUP(),
            0x13 => self.exec_SWAP(),
            0xFF => self.exec_HALT(),
            else => self.status = .Error_InvalidOpcode,
        }
        self.instructions_executed += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲀⲆⲆ (0x01) - v₁::v₂::s ↪ (v₁+v₂)::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_ADD(self: *VM) void {
        if (self.stack.items.len < 2) {
            self.status = .Error_StackUnderflow;
            return;
        }
        const v1 = self.stack.pop();
        const v2 = self.stack.pop();
        const result = v1 +% v2;
        self.stack.append(result) catch {
            self.status = .Error_StackOverflow;
            return;
        };
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲤⲨⲂ (0x02) - v₁::v₂::s ↪ (v₂-v₁)::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_SUB(self: *VM) void {
        if (self.stack.items.len < 2) {
            self.status = .Error_StackUnderflow;
            return;
        }
        const v1 = self.stack.pop();
        const v2 = self.stack.pop();
        const result = v2 -% v1;
        self.stack.append(result) catch {
            self.status = .Error_StackOverflow;
            return;
        };
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲘⲨⲖ (0x03) - v₁::v₂::s ↪ (v₁×v₂)::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_MUL(self: *VM) void {
        if (self.stack.items.len < 2) {
            self.status = .Error_StackUnderflow;
            return;
        }
        const v1 = self.stack.pop();
        const v2 = self.stack.pop();
        const result = v1 *% v2;
        self.stack.append(result) catch {
            self.status = .Error_StackOverflow;
            return;
        };
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲆⲒⲨ (0x04) - v₁::v₂::s, v₁≠0 ↪ (v₂÷v₁)::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_DIV(self: *VM) void {
        if (self.stack.items.len < 2) {
            self.status = .Error_StackUnderflow;
            return;
        }
        const v1 = self.stack.pop();
        const v2 = self.stack.pop();
        if (v1 == 0) {
            self.status = .Error_DivByZero;
            return;
        }
        const result = v2 / v1;
        self.stack.append(result) catch {
            self.status = .Error_StackOverflow;
            return;
        };
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲠⲨϢⲎ (0x10) - s ↪ v::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_PUSH(self: *VM, value: u64) void {
        self.stack.append(value) catch {
            self.status = .Error_StackOverflow;
            return;
        };
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲠⲞⲠ (0x11) - v::s ↪ s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_POP(self: *VM) void {
        if (self.stack.items.len < 1) {
            self.status = .Error_StackUnderflow;
            return;
        }
        _ = self.stack.pop();
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲆⲨⲠ (0x12) - v::s ↪ v::v::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_DUP(self: *VM) void {
        if (self.stack.items.len < 1) {
            self.status = .Error_StackUnderflow;
            return;
        }
        const v = self.stack.items[self.stack.items.len - 1];
        self.stack.append(v) catch {
            self.status = .Error_StackOverflow;
            return;
        };
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲤⲰⲀⲠ (0x13) - v₁::v₂::s ↪ v₂::v₁::s
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_SWAP(self: *VM) void {
        if (self.stack.items.len < 2) {
            self.status = .Error_StackUnderflow;
            return;
        }
        const len = self.stack.items.len;
        const tmp = self.stack.items[len - 1];
        self.stack.items[len - 1] = self.stack.items[len - 2];
        self.stack.items[len - 2] = tmp;
        self.pc += 1;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ⲎⲀⲖⲦ (0xFF) - status=Halted
    // ═══════════════════════════════════════════════════════════════════════

    fn exec_HALT(self: *VM) void {
        self.status = .Halted;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// ⲦⲈⲤⲦⲤ
// ═══════════════════════════════════════════════════════════════════════════════

test "ⲌⲞⲖⲞⲦⲀⲒⲀ_ⲒⲆⲈⲚⲦⲒⲬⲚⲞⲤⲦⲒ" {
    try std.testing.expect(verifyGoldenIdentity());
}

test "ⲀⲆⲆ_ⲧⲱⲟ_ⲛⲩⲙⲃⲉⲣⲥ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(3);
    try vm.stack.append(5);
    vm.dispatch(0x01);

    try std.testing.expectEqual(@as(usize, 1), vm.stack.items.len);
    try std.testing.expectEqual(@as(u64, 8), vm.stack.items[0]);
    try std.testing.expectEqual(@as(u64, 1), vm.pc);
    try std.testing.expectEqual(VM.Status.Running, vm.status);
}

test "ⲤⲨⲂ_ⲧⲱⲟ_ⲛⲩⲙⲃⲉⲣⲥ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(10);
    try vm.stack.append(3);
    vm.dispatch(0x02);

    try std.testing.expectEqual(@as(u64, 7), vm.stack.items[0]);
}

test "ⲘⲨⲖ_ⲧⲱⲟ_ⲛⲩⲙⲃⲉⲣⲥ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(4);
    try vm.stack.append(7);
    vm.dispatch(0x03);

    try std.testing.expectEqual(@as(u64, 28), vm.stack.items[0]);
}

test "ⲆⲒⲨ_ⲧⲱⲟ_ⲛⲩⲙⲃⲉⲣⲥ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(20);
    try vm.stack.append(4);
    vm.dispatch(0x04);

    try std.testing.expectEqual(@as(u64, 5), vm.stack.items[0]);
}

test "ⲆⲒⲨ_ⲃⲩ_ⲍⲉⲣⲟ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(10);
    try vm.stack.append(0);
    vm.dispatch(0x04);

    try std.testing.expectEqual(VM.Status.Error_DivByZero, vm.status);
}

test "ⲆⲨⲠ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(42);
    vm.dispatch(0x12);

    try std.testing.expectEqual(@as(usize, 2), vm.stack.items.len);
    try std.testing.expectEqual(@as(u64, 42), vm.stack.items[0]);
    try std.testing.expectEqual(@as(u64, 42), vm.stack.items[1]);
}

test "ⲤⲰⲀⲠ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(1);
    try vm.stack.append(2);
    vm.dispatch(0x13);

    try std.testing.expectEqual(@as(u64, 2), vm.stack.items[0]);
    try std.testing.expectEqual(@as(u64, 1), vm.stack.items[1]);
}

test "ⲎⲀⲖⲦ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    vm.dispatch(0xFF);

    try std.testing.expectEqual(VM.Status.Halted, vm.status);
}

test "ⲥⲧⲁⲕ_ⲩⲛⲇⲉⲣⲫⲗⲟⲱ" {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var vm = VM.init(gpa.allocator());
    defer vm.deinit();

    try vm.stack.append(5);
    vm.dispatch(0x01);

    try std.testing.expectEqual(VM.Status.Error_StackUnderflow, vm.status);
}
