// ═══════════════════════════════════════════════════════════════════════════════
// ⲂⲈⲚⲬⲘⲀⲢⲔ ⲤⲨⲒⲦⲈ - GENERATED BY ⲌⲘⲈⲒ ⲄⲞⲢⲨⲚⲨⲬ
// ═══════════════════════════════════════════════════════════════════════════════
// ⲤⲀⲔⲢⲀ ⲪⲞⲢⲘⲨⲖⲀ: V = n × 3^k × π^m × φ^p × e^q
// ⲌⲞⲖⲞⲦⲀⲒⲀ ⲒⲆⲈⲚⲦⲒⲬⲚⲞⲤⲦⲒ: φ² + 1/φ² = 3
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const time = std.time;
const VM = @import("trinity_vm.zig").VM;

// ═══════════════════════════════════════════════════════════════════════════════
// ⲤⲀⲔⲢⲀ ⲔⲞⲚⲤⲦⲀⲚⲦⲤ
// ═══════════════════════════════════════════════════════════════════════════════

pub const PHI: f64 = 1.618033988749895;
pub const GOLDEN_IDENTITY: f64 = 3.0;
pub const TRINITY_PRIME: u32 = 33;
pub const PHOENIX: u32 = 999;

// ═══════════════════════════════════════════════════════════════════════════════
// ⲂⲈⲚⲬⲘⲀⲢⲔ ⲢⲈⲤⲨⲖⲦ
// ═══════════════════════════════════════════════════════════════════════════════

pub const BenchmarkResult = struct {
    name: []const u8,
    iterations: u64,
    total_ns: u64,
    avg_ns: u64,
    ops_per_sec: f64,
    
    pub fn print(self: BenchmarkResult, writer: anytype) !void {
        try writer.print("  {s}: {d} ns/op, {d:.2} Mops/s\n", .{
            self.name,
            self.avg_ns,
            self.ops_per_sec / 1_000_000.0,
        });
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// ⲂⲈⲚⲬⲘⲀⲢⲔ ⲪⲨⲚⲔⲦⲒⲞⲚⲤ
// ═══════════════════════════════════════════════════════════════════════════════

pub fn benchmarkArithmetic(allocator: std.mem.Allocator, iterations: u64) !BenchmarkResult {
    var vm = VM.init(allocator);
    defer vm.deinit();
    
    const start = time.nanoTimestamp();
    
    var i: u64 = 0;
    while (i < iterations) : (i += 1) {
        try vm.stack.append(i);
        try vm.stack.append(i + 1);
        vm.dispatch(0x01); // ADD
        _ = vm.stack.pop();
        vm.reset();
    }
    
    const end = time.nanoTimestamp();
    const total_ns: u64 = @intCast(end - start);
    const avg_ns = total_ns / iterations;
    const ops_per_sec = @as(f64, @floatFromInt(iterations)) / (@as(f64, @floatFromInt(total_ns)) / 1_000_000_000.0);
    
    return BenchmarkResult{
        .name = "arithmetic_ops",
        .iterations = iterations,
        .total_ns = total_ns,
        .avg_ns = avg_ns,
        .ops_per_sec = ops_per_sec,
    };
}

pub fn benchmarkStackOps(allocator: std.mem.Allocator, iterations: u64) !BenchmarkResult {
    var vm = VM.init(allocator);
    defer vm.deinit();
    
    const start = time.nanoTimestamp();
    
    var i: u64 = 0;
    while (i < iterations) : (i += 1) {
        try vm.stack.append(i);
        vm.dispatch(0x12); // DUP
        vm.dispatch(0x13); // SWAP
        vm.dispatch(0x11); // POP
        vm.dispatch(0x11); // POP
    }
    
    const end = time.nanoTimestamp();
    const total_ns: u64 = @intCast(end - start);
    const avg_ns = total_ns / iterations;
    const ops_per_sec = @as(f64, @floatFromInt(iterations * 4)) / (@as(f64, @floatFromInt(total_ns)) / 1_000_000_000.0);
    
    return BenchmarkResult{
        .name = "stack_ops",
        .iterations = iterations,
        .total_ns = total_ns,
        .avg_ns = avg_ns,
        .ops_per_sec = ops_per_sec,
    };
}

pub fn benchmarkDispatch(allocator: std.mem.Allocator, iterations: u64) !BenchmarkResult {
    var vm = VM.init(allocator);
    defer vm.deinit();
    
    // Pre-fill stack
    try vm.stack.append(1);
    try vm.stack.append(1);
    
    const opcodes = [_]u8{ 0x01, 0x02, 0x03, 0x12, 0x13 };
    
    const start = time.nanoTimestamp();
    
    var i: u64 = 0;
    while (i < iterations) : (i += 1) {
        const opcode = opcodes[i % opcodes.len];
        vm.dispatch(opcode);
        
        // Maintain stack
        if (vm.stack.items.len < 2) {
            try vm.stack.append(1);
            try vm.stack.append(1);
        }
        if (vm.stack.items.len > 100) {
            vm.stack.shrinkRetainingCapacity(2);
        }
    }
    
    const end = time.nanoTimestamp();
    const total_ns: u64 = @intCast(end - start);
    const avg_ns = total_ns / iterations;
    const ops_per_sec = @as(f64, @floatFromInt(iterations)) / (@as(f64, @floatFromInt(total_ns)) / 1_000_000_000.0);
    
    return BenchmarkResult{
        .name = "dispatch",
        .iterations = iterations,
        .total_ns = total_ns,
        .avg_ns = avg_ns,
        .ops_per_sec = ops_per_sec,
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// ⲪⲒⲂⲞⲚⲀⲬⲬⲒ ⲂⲈⲚⲬⲘⲀⲢⲔ
// ═══════════════════════════════════════════════════════════════════════════════

fn fibNative(n: u64) u64 {
    if (n <= 1) return n;
    return fibNative(n - 1) + fibNative(n - 2);
}

pub fn benchmarkFibonacci(n: u64) !BenchmarkResult {
    const start = time.nanoTimestamp();
    
    const result = fibNative(n);
    _ = result;
    
    const end = time.nanoTimestamp();
    const total_ns: u64 = @intCast(end - start);
    
    return BenchmarkResult{
        .name = "fibonacci",
        .iterations = 1,
        .total_ns = total_ns,
        .avg_ns = total_ns,
        .ops_per_sec = 1_000_000_000.0 / @as(f64, @floatFromInt(total_ns)),
    };
}

// ═══════════════════════════════════════════════════════════════════════════════
// ⲘⲀⲒⲚ ⲂⲈⲚⲬⲘⲀⲢⲔ ⲢⲨⲚⲚⲈⲢ
// ═══════════════════════════════════════════════════════════════════════════════

pub fn runAllBenchmarks(allocator: std.mem.Allocator) !void {
    const stdout = std.io.getStdOut().writer();
    
    try stdout.writeAll(
        \\═══════════════════════════════════════════════════════════════════════════════
        \\ⲒⲄⲖⲀ ⲂⲈⲚⲬⲘⲀⲢⲔⲤ
        \\═══════════════════════════════════════════════════════════════════════════════
        \\ⲤⲀⲔⲢⲀ ⲪⲞⲢⲘⲨⲖⲀ: V = n × 3^k × π^m × φ^p × e^q
        \\ⲌⲞⲖⲞⲦⲀⲒⲀ ⲒⲆⲈⲚⲦⲒⲬⲚⲞⲤⲦⲒ: φ² + 1/φ² = 3
        \\═══════════════════════════════════════════════════════════════════════════════
        \\
    );
    
    const iterations: u64 = 1_000_000;
    
    try stdout.print("\nRunning {d} iterations per benchmark...\n\n", .{iterations});
    
    // Arithmetic
    const arith = try benchmarkArithmetic(allocator, iterations);
    try arith.print(stdout);
    
    // Stack
    const stack = try benchmarkStackOps(allocator, iterations);
    try stack.print(stdout);
    
    // Dispatch
    const dispatch = try benchmarkDispatch(allocator, iterations);
    try dispatch.print(stdout);
    
    // Fibonacci
    try stdout.writeAll("\nFibonacci(35):\n");
    const fib = try benchmarkFibonacci(35);
    try fib.print(stdout);
    
    try stdout.writeAll(
        \\
        \\═══════════════════════════════════════════════════════════════════════════════
        \\φ² + 1/φ² = 3
        \\═══════════════════════════════════════════════════════════════════════════════
        \\
    );
}

// ═══════════════════════════════════════════════════════════════════════════════
// ⲦⲈⲤⲦⲤ
// ═══════════════════════════════════════════════════════════════════════════════

test "ⲌⲞⲖⲞⲦⲀⲒⲀ_ⲒⲆⲈⲚⲦⲒⲬⲚⲞⲤⲦⲒ" {
    const phi_sq = PHI * PHI;
    const inv_phi_sq = 1.0 / phi_sq;
    const result = phi_sq + inv_phi_sq;
    try std.testing.expectApproxEqAbs(GOLDEN_IDENTITY, result, 0.0001);
}

test "ⲫⲓⲃⲟⲛⲁⲭⲭⲓ_ⲕⲟⲣⲣⲉⲕⲧⲛⲟⲥⲧⲓ" {
    try std.testing.expectEqual(@as(u64, 0), fibNative(0));
    try std.testing.expectEqual(@as(u64, 1), fibNative(1));
    try std.testing.expectEqual(@as(u64, 1), fibNative(2));
    try std.testing.expectEqual(@as(u64, 55), fibNative(10));
}

test "ⲃⲉⲛⲭⲙⲁⲣⲕ_ⲁⲣⲓⲧⲏⲙⲉⲧⲓⲕ" {
    const result = try benchmarkArithmetic(std.testing.allocator, 1000);
    try std.testing.expect(result.ops_per_sec > 0);
}

test "ⲃⲉⲛⲭⲙⲁⲣⲕ_ⲥⲧⲁⲕ" {
    const result = try benchmarkStackOps(std.testing.allocator, 1000);
    try std.testing.expect(result.ops_per_sec > 0);
}

test "ⲃⲉⲛⲭⲙⲁⲣⲕ_ⲇⲓⲥⲡⲁⲧⲭ" {
    const result = try benchmarkDispatch(std.testing.allocator, 1000);
    try std.testing.expect(result.ops_per_sec > 0);
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    try runAllBenchmarks(gpa.allocator());
}
