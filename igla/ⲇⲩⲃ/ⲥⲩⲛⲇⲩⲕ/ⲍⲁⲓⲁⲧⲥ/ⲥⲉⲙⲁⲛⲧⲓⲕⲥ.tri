# ═══════════════════════════════════════════════════════════════════════════════
# ⲤⲈⲘⲀⲚⲦⲒⲔⲤ - ФОРМАЛЬНАЯ СЕМАНТИКА (ЗАЯЦ)
# ═══════════════════════════════════════════════════════════════════════════════

ⲥⲉⲙⲁⲛⲧⲓⲕⲥ:
  # Арифметика: v₁::v₂::s означает v₁ на вершине, v₂ под ним
  ADD: |
    v₁::v₂::s ↪ (v₁+v₂)::s
    
  SUB: |
    v₁::v₂::s ↪ (v₂-v₁)::s
    
  MUL: |
    v₁::v₂::s ↪ (v₁×v₂)::s
    
  DIV: |
    v₁::v₂::s, v₁≠0 ↪ (v₂÷v₁)::s
    v₁::v₂::s, v₁=0 ↪ Error(DivByZero)
    
  # Память
  LD: |
    σ, LD r ↪ σ[stack := σ.registers[r]::σ.stack]
    
  ST: |
    v::s, ST r ↪ σ[registers[r] := v, stack := s]
    
  # Управление
  JMP: |
    σ, JMP addr ↪ σ[pc := addr]
    
  JE: |
    v₁::v₂::s, JE addr, v₁=v₂ ↪ σ[pc := addr, stack := s]
    v₁::v₂::s, JE addr, v₁≠v₂ ↪ σ[pc := pc+1, stack := s]
    
  JNE: |
    v₁::v₂::s, JNE addr, v₁≠v₂ ↪ σ[pc := addr, stack := s]
    v₁::v₂::s, JNE addr, v₁=v₂ ↪ σ[pc := pc+1, stack := s]
    
  CALL: |
    σ, CALL addr ↪ σ[pc := addr, stack := (pc+1)::σ.stack]
    
  RET: |
    ret_addr::s ↪ σ[pc := ret_addr, stack := s]
    
  # PAS
  PRED: |
    σ, PRED d ↪ σ[stack := Θ_d(σ)::σ.stack]
    где Θ_d - функция предсказания демона d
    
  AKT: |
    v::s, AKT a ↪ σ[stack := Ι_a(v)::s]
    где Ι_a - функция действия a
    
  SEL: |
    predictions::s ↪ σ[stack := Κ(predictions)::s]
    где Κ - функция отбора лучшего предсказания
    
  # Священные
  PHI: |
    s ↪ φ::s
    где φ = 1.618033988749895
    
  SAKRA: |
    v::s ↪ (v² + 1/v² = 3)::s
    Проверка золотой идентичности
