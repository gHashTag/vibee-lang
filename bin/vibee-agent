#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VIBEE AGENT - Self-Writing Code Terminal Agent
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ï†Â² + 1/Ï†Â² = 3 | PHOENIX = 999
# Multi-Model: Anthropic, OpenAI, Ollama
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Sacred constants
PHI="1.618033988749895"
PHOENIX="999"

# Config
MAX_TOKENS="${VIBEE_MAX_TOKENS:-4096}"
WORKDIR="${VIBEE_WORKDIR:-$(pwd)}"
SESSION_DIR="${VIBEE_SESSION_DIR:-$HOME/.vibee/sessions}"
CURRENT_SESSION=""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROVIDER DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_provider() {
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        PROVIDER="anthropic"
        MODEL="${VIBEE_MODEL:-claude-sonnet-4-20250514}"
        API_URL="https://api.anthropic.com/v1/messages"
    elif [ -n "$DEEPSEEK_API_KEY" ]; then
        PROVIDER="deepseek"
        MODEL="${VIBEE_MODEL:-deepseek-chat}"
        API_URL="https://api.deepseek.com/v1/chat/completions"
    elif [ -n "$OPENAI_API_KEY" ]; then
        PROVIDER="openai"
        MODEL="${VIBEE_MODEL:-gpt-4o}"
        API_URL="https://api.openai.com/v1/chat/completions"
    elif [ -n "$OLLAMA_HOST" ] || curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
        PROVIDER="ollama"
        OLLAMA_HOST="${OLLAMA_HOST:-http://localhost:11434}"
        MODEL="${VIBEE_MODEL:-llama3.2}"
        API_URL="$OLLAMA_HOST/api/chat"
    else
        PROVIDER="none"
        MODEL=""
        API_URL=""
    fi
}

switch_provider() {
    local new_provider="$1"
    case "$new_provider" in
        anthropic|claude)
            if [ -z "$ANTHROPIC_API_KEY" ]; then
                echo -e "${RED}ANTHROPIC_API_KEY not set${NC}"
                return 1
            fi
            PROVIDER="anthropic"
            MODEL="${2:-claude-sonnet-4-20250514}"
            API_URL="https://api.anthropic.com/v1/messages"
            ;;
        deepseek)
            if [ -z "$DEEPSEEK_API_KEY" ]; then
                echo -e "${RED}DEEPSEEK_API_KEY not set${NC}"
                return 1
            fi
            PROVIDER="deepseek"
            MODEL="${2:-deepseek-chat}"
            API_URL="https://api.deepseek.com/v1/chat/completions"
            ;;
        openai|gpt)
            if [ -z "$OPENAI_API_KEY" ]; then
                echo -e "${RED}OPENAI_API_KEY not set${NC}"
                return 1
            fi
            PROVIDER="openai"
            MODEL="${2:-gpt-4o}"
            API_URL="https://api.openai.com/v1/chat/completions"
            ;;
        ollama|local)
            PROVIDER="ollama"
            OLLAMA_HOST="${OLLAMA_HOST:-http://localhost:11434}"
            MODEL="${2:-llama3.2}"
            API_URL="$OLLAMA_HOST/api/chat"
            ;;
        *)
            echo -e "${RED}Unknown provider: $new_provider${NC}"
            echo "Available: anthropic, deepseek, openai, ollama"
            return 1
            ;;
    esac
    echo -e "${GREEN}Switched to $PROVIDER ($MODEL)${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BANNER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print_banner() {
    echo -e "${MAGENTA}"
    echo "  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "  â•‘  VIBEE AGENT v1.0.0 - Self-Writing Code                   â•‘"
    echo "  â•‘  Ï†Â² + 1/Ï†Â² = 3 | PHOENIX = 999                            â•‘"
    echo "  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CHECK API KEY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

check_api_key() {
    detect_provider
    
    if [ "$PROVIDER" = "none" ]; then
        echo -e "${RED}âŒ No AI provider configured${NC}"
        echo ""
        echo "Set one of these:"
        echo "  export ANTHROPIC_API_KEY=sk-ant-your-key    # Claude"
        echo "  export OPENAI_API_KEY=sk-your-key          # GPT-4"
        echo "  ollama serve                                # Local Ollama"
        echo ""
        exit 1
    fi
    
    echo -e "${GREEN}âœ… Provider: $PROVIDER ($MODEL)${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOLS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TOOLS='[
  {
    "name": "read_file",
    "description": "Read contents of a file",
    "input_schema": {
      "type": "object",
      "properties": {
        "path": {"type": "string", "description": "File path to read"}
      },
      "required": ["path"]
    }
  },
  {
    "name": "write_file",
    "description": "Write content to a file",
    "input_schema": {
      "type": "object",
      "properties": {
        "path": {"type": "string", "description": "File path to write"},
        "content": {"type": "string", "description": "Content to write"}
      },
      "required": ["path", "content"]
    }
  },
  {
    "name": "run_command",
    "description": "Run a shell command",
    "input_schema": {
      "type": "object",
      "properties": {
        "command": {"type": "string", "description": "Command to execute"}
      },
      "required": ["command"]
    }
  },
  {
    "name": "list_files",
    "description": "List files in a directory",
    "input_schema": {
      "type": "object",
      "properties": {
        "path": {"type": "string", "description": "Directory path"}
      },
      "required": ["path"]
    }
  },
  {
    "name": "search_files",
    "description": "Search for text in files",
    "input_schema": {
      "type": "object",
      "properties": {
        "pattern": {"type": "string", "description": "Search pattern"},
        "path": {"type": "string", "description": "Directory to search"}
      },
      "required": ["pattern"]
    }
  }
]'

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTE TOOL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

execute_tool() {
    local tool_name="$1"
    local tool_input="$2"
    
    case "$tool_name" in
        "read_file")
            local path=$(echo "$tool_input" | jq -r '.path')
            if [ -f "$path" ]; then
                cat "$path" 2>&1 | head -500
            else
                echo "Error: File not found: $path"
            fi
            ;;
        "write_file")
            local path=$(echo "$tool_input" | jq -r '.path')
            local content=$(echo "$tool_input" | jq -r '.content')
            
            # PIPELINE ENFORCER: Block direct code file creation
            local ext="${path##*.}"
            case "$ext" in
                zig|py|js|ts|go|rs|java|kt|swift|c|cpp)
                    # Check if it's in trinity/output (allowed for extraction)
                    if [[ "$path" != trinity/output/* ]]; then
                        echo -e "${RED}âŒ PIPELINE VIOLATION: Cannot create .$ext files directly${NC}"
                        echo ""
                        echo "STRICT PIPELINE REQUIRED:"
                        echo "  Step 0: Create .vibee specification in specs/tri/"
                        echo "  Step 1: Include â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: block with code"
                        echo "  Step 2: Extract to trinity/output/"
                        echo ""
                        echo "Example: specs/tri/my_feature.vibee"
                        return 1
                    fi
                    ;;
            esac
            
            mkdir -p "$(dirname "$path")"
            echo "$content" > "$path"
            echo "âœ… Written to $path ($(wc -c < "$path") bytes)"
            
            # Auto-extract if .vibee file with â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§
            if [[ "$path" == *.vibee ]] && grep -q 'â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§:' "$path" 2>/dev/null; then
                local name=$(basename "$path" .vibee)
                local output="trinity/output/${name}.zig"
                mkdir -p trinity/output
                sed -n '/â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: """/,/^"""/p' "$path" | sed '1d;$d' > "$output"
                echo "âœ… Auto-extracted: $output ($(wc -l < "$output") lines)"
                
                # Auto-run tests
                echo "ğŸ§ª Running tests..."
                if zig test "$output" 2>&1 | grep -q "passed"; then
                    local test_count=$(zig test "$output" 2>&1 | grep -oP '\d+(?= tests? passed)' | head -1)
                    echo "âœ… All $test_count tests passed!"
                else
                    echo "âŒ Tests failed. Check output above."
                fi
            fi
            ;;
        "run_command")
            local cmd=$(echo "$tool_input" | jq -r '.command')
            echo -e "${CYAN}$ $cmd${NC}"
            eval "$cmd" 2>&1 | head -100
            ;;
        "list_files")
            local path=$(echo "$tool_input" | jq -r '.path // "."')
            ls -la "$path" 2>&1 | head -50
            ;;
        "search_files")
            local pattern=$(echo "$tool_input" | jq -r '.pattern')
            local path=$(echo "$tool_input" | jq -r '.path // "."')
            grep -r "$pattern" "$path" 2>&1 | head -30
            ;;
        *)
            echo "Unknown tool: $tool_name"
            ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CALL LLM API (Multi-Provider)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SYSTEM_PROMPT="You are VIBEE Agent, a self-writing code assistant.

STRICT PIPELINE (MUST FOLLOW):
Step 0: Create .vibee specification in specs/tri/ folder
Step 1: NEVER write .zig/.py/.js/.ts/.go/.rs files directly
Step 2: Include â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: block in .vibee with generated code
Step 3: Extract .zig to trinity/output/ using: sed -n '/â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: \"\"\"/,/^\"\"\"/p' file.vibee | sed '1d;\$d'
Step 4: Run tests: zig test trinity/output/file.zig
Step 5: Fix problems by updating .vibee specification

BLOCKED FILE TYPES (redirect to .vibee):
- .zig â†’ Create .vibee with â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§ block
- .py â†’ Create .vibee with language: python
- .js/.ts â†’ Create .vibee with language: typescript
- .go â†’ Create .vibee with language: go
- .rs â†’ Create .vibee with language: rust

ALLOWED FILE TYPES:
- .vibee (specifications)
- .tri (intermediate format)
- .md (documentation)

Sacred formula: Ï†Â² + 1/Ï†Â² = 3
Always test your code after extraction."

call_llm() {
    local messages="$1"
    
    case "$PROVIDER" in
        anthropic)
            call_anthropic "$messages"
            ;;
        deepseek)
            call_deepseek "$messages"
            ;;
        openai)
            call_openai "$messages"
            ;;
        ollama)
            call_ollama "$messages"
            ;;
        *)
            echo '{"error": {"message": "No provider configured"}}'
            ;;
    esac
}

call_deepseek() {
    local messages="$1"
    
    # Build system prompt with tool instructions
    local tool_prompt="$SYSTEM_PROMPT

You have these tools available. To use a tool, respond EXACTLY in this format:
TOOL_CALL: tool_name
TOOL_INPUT: {\"param\": \"value\"}

Available tools:
- read_file: Read file contents. Input: {\"path\": \"filepath\"}
- write_file: Write to file. Input: {\"path\": \"filepath\", \"content\": \"text\"}
- run_command: Execute shell command. Input: {\"command\": \"cmd\"}
- list_files: List directory. Input: {\"path\": \"dirpath\"}

After I show you tool results, continue your response.
If no tool is needed, just respond normally."

    # Build messages array
    local deepseek_messages=$(echo "$messages" | jq --arg sys "$tool_prompt" '[{role: "system", content: $sys}] + .')
    
    local response=$(curl -s https://api.deepseek.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $DEEPSEEK_API_KEY" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": $MAX_TOKENS,
            \"messages\": $deepseek_messages
        }")
    
    # Convert to Anthropic format
    convert_deepseek_response "$response"
}

convert_deepseek_response() {
    local response="$1"
    
    # Check for error
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        echo "$response"
        return
    fi
    
    local text=$(echo "$response" | jq -r '.choices[0].message.content // ""')
    local content="[]"
    
    # Check if response contains tool call pattern
    if echo "$text" | grep -q "TOOL_CALL:"; then
        local tool_name=$(echo "$text" | grep "TOOL_CALL:" | head -1 | sed 's/TOOL_CALL: *//' | tr -d '\r\n')
        local tool_input=$(echo "$text" | grep -A1 "TOOL_INPUT:" | tail -1 | tr -d '\r\n')
        
        # Clean up tool input
        tool_input=$(echo "$tool_input" | sed 's/^TOOL_INPUT: *//')
        
        # Validate JSON
        if echo "$tool_input" | jq . > /dev/null 2>&1; then
            local tool_id="deepseek_$(date +%s)"
            content="[{\"type\": \"tool_use\", \"id\": \"$tool_id\", \"name\": \"$tool_name\", \"input\": $tool_input}]"
            
            # Add any text before the tool call
            local pre_text=$(echo "$text" | sed -n '1,/TOOL_CALL:/p' | head -n -1)
            if [ -n "$pre_text" ]; then
                content=$(echo "$content" | jq --arg t "$pre_text" '. + [{type: "text", text: $t}]')
            fi
            
            echo "{\"content\": $content, \"stop_reason\": \"tool_use\"}"
        else
            # Invalid JSON, treat as text
            content="[{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]"
            echo "{\"content\": $content, \"stop_reason\": \"end_turn\"}"
        fi
    else
        content="[{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]"
        echo "{\"content\": $content, \"stop_reason\": \"end_turn\"}"
    fi
}

call_anthropic() {
    local messages="$1"
    
    curl -s https://api.anthropic.com/v1/messages \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": $MAX_TOKENS,
            \"system\": \"$SYSTEM_PROMPT\",
            \"tools\": $TOOLS,
            \"messages\": $messages
        }"
}

call_openai() {
    local messages="$1"
    
    # Convert Anthropic format to OpenAI format
    local openai_messages=$(echo "$messages" | jq '[{role: "system", content: "'"$SYSTEM_PROMPT"'"} ] + .')
    
    # Convert tools to OpenAI format
    local openai_tools=$(echo "$TOOLS" | jq '[.[] | {type: "function", function: {name: .name, description: .description, parameters: .input_schema}}]')
    
    local response=$(curl -s https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": $MAX_TOKENS,
            \"tools\": $openai_tools,
            \"messages\": $openai_messages
        }")
    
    # Convert OpenAI response to Anthropic format for unified processing
    convert_openai_response "$response"
}

convert_openai_response() {
    local response="$1"
    
    # Check for error
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        echo "$response"
        return
    fi
    
    local finish_reason=$(echo "$response" | jq -r '.choices[0].finish_reason')
    local message=$(echo "$response" | jq -c '.choices[0].message')
    
    # Build Anthropic-style response
    local content="[]"
    
    # Add text content if present
    local text=$(echo "$message" | jq -r '.content // empty')
    if [ -n "$text" ]; then
        content=$(echo "$content" | jq ". + [{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]")
    fi
    
    # Add tool calls if present
    local tool_calls=$(echo "$message" | jq -c '.tool_calls // []')
    if [ "$(echo "$tool_calls" | jq 'length')" -gt 0 ]; then
        while IFS= read -r tc; do
            local tc_id=$(echo "$tc" | jq -r '.id')
            local tc_name=$(echo "$tc" | jq -r '.function.name')
            local tc_args=$(echo "$tc" | jq -c '.function.arguments | fromjson')
            content=$(echo "$content" | jq ". + [{\"type\": \"tool_use\", \"id\": \"$tc_id\", \"name\": \"$tc_name\", \"input\": $tc_args}]")
        done <<< "$(echo "$tool_calls" | jq -c '.[]')"
    fi
    
    local stop_reason="end_turn"
    [ "$finish_reason" = "tool_calls" ] && stop_reason="tool_use"
    
    echo "{\"content\": $content, \"stop_reason\": \"$stop_reason\"}"
}

call_ollama() {
    local messages="$1"
    
    # Ollama doesn't support tools natively, so we use a prompt-based approach
    local ollama_messages=$(echo "$messages" | jq '[{role: "system", content: "'"$SYSTEM_PROMPT"'\n\nYou have these tools available:\n- read_file(path): Read a file\n- write_file(path, content): Write to a file\n- run_command(command): Run a shell command\n- list_files(path): List directory\n- search_files(pattern, path): Search in files\n\nTo use a tool, respond with:\nTOOL: tool_name\nINPUT: {\"param\": \"value\"}\n\nAfter tool results, continue your response."} ] + .')
    
    local response=$(curl -s "$OLLAMA_HOST/api/chat" \
        -H "Content-Type: application/json" \
        -d "{
            \"model\": \"$MODEL\",
            \"messages\": $ollama_messages,
            \"stream\": false
        }")
    
    # Convert Ollama response to Anthropic format
    convert_ollama_response "$response"
}

convert_ollama_response() {
    local response="$1"
    
    # Check for error
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        echo "$response"
        return
    fi
    
    local text=$(echo "$response" | jq -r '.message.content // ""')
    local content="[]"
    
    # Check if response contains tool call pattern
    if echo "$text" | grep -q "^TOOL:"; then
        local tool_name=$(echo "$text" | grep "^TOOL:" | head -1 | sed 's/TOOL: *//')
        local tool_input=$(echo "$text" | grep -A1 "^INPUT:" | tail -1)
        
        # Generate a unique ID
        local tool_id="ollama_$(date +%s%N)"
        
        content=$(echo "$content" | jq ". + [{\"type\": \"tool_use\", \"id\": \"$tool_id\", \"name\": \"$tool_name\", \"input\": $tool_input}]")
        echo "{\"content\": $content, \"stop_reason\": \"tool_use\"}"
    else
        content=$(echo "$content" | jq ". + [{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]")
        echo "{\"content\": $content, \"stop_reason\": \"end_turn\"}"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AGENT LOOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SESSION MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

init_session() {
    mkdir -p "$SESSION_DIR"
    CURRENT_SESSION="$SESSION_DIR/session_$(date +%Y%m%d_%H%M%S).json"
    echo '{"messages": [], "provider": "'"$PROVIDER"'", "model": "'"$MODEL"'"}' > "$CURRENT_SESSION"
    echo -e "${CYAN}Session: $CURRENT_SESSION${NC}"
}

save_session() {
    if [ -n "$CURRENT_SESSION" ] && [ -f "$CURRENT_SESSION" ]; then
        local messages="$1"
        echo "{\"messages\": $messages, \"provider\": \"$PROVIDER\", \"model\": \"$MODEL\"}" > "$CURRENT_SESSION"
    fi
}

load_session() {
    local session_file="$1"
    if [ -f "$session_file" ]; then
        CURRENT_SESSION="$session_file"
        local saved=$(cat "$session_file")
        PROVIDER=$(echo "$saved" | jq -r '.provider')
        MODEL=$(echo "$saved" | jq -r '.model')
        echo "$saved" | jq -c '.messages'
    else
        echo "[]"
    fi
}

list_sessions() {
    echo -e "\n${CYAN}Sessions:${NC}"
    ls -la "$SESSION_DIR"/*.json 2>/dev/null | while read line; do
        echo "  $line"
    done
}

run_agent() {
    local user_message="$1"
    local messages="[{\"role\": \"user\", \"content\": \"$user_message\"}]"
    local iteration=0
    local max_iterations=10
    
    while [ $iteration -lt $max_iterations ]; do
        iteration=$((iteration + 1))
        echo -e "\n${BLUE}[Iteration $iteration] ($PROVIDER/$MODEL)${NC}"
        
        # Call LLM (multi-provider)
        local response=$(call_llm "$messages")
        
        # Check for errors
        if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
            echo -e "${RED}API Error: $(echo "$response" | jq -r '.error.message')${NC}"
            return 1
        fi
        
        # Get stop reason
        local stop_reason=$(echo "$response" | jq -r '.stop_reason')
        
        # Process content blocks
        local content=$(echo "$response" | jq -c '.content[]')
        local assistant_content="[]"
        local tool_results="[]"
        
        while IFS= read -r block; do
            local block_type=$(echo "$block" | jq -r '.type')
            
            if [ "$block_type" = "text" ]; then
                local text=$(echo "$block" | jq -r '.text')
                echo -e "\n${GREEN}Claude:${NC} $text"
                assistant_content=$(echo "$assistant_content" | jq ". + [$block]")
            elif [ "$block_type" = "tool_use" ]; then
                local tool_id=$(echo "$block" | jq -r '.id')
                local tool_name=$(echo "$block" | jq -r '.name')
                local tool_input=$(echo "$block" | jq -c '.input')
                
                echo -e "\n${YELLOW}ğŸ”§ Tool: $tool_name${NC}"
                echo -e "${CYAN}   Input: $tool_input${NC}"
                
                # Execute tool
                local result=$(execute_tool "$tool_name" "$tool_input")
                echo -e "${CYAN}   Result: ${NC}"
                echo "$result" | head -20
                
                assistant_content=$(echo "$assistant_content" | jq ". + [$block]")
                tool_results=$(echo "$tool_results" | jq ". + [{\"type\": \"tool_result\", \"tool_use_id\": \"$tool_id\", \"content\": $(echo "$result" | jq -Rs .)}]")
            fi
        done <<< "$content"
        
        # Add assistant message
        # For DeepSeek/OpenAI, convert content to text format
        if [ "$PROVIDER" = "deepseek" ] || [ "$PROVIDER" = "openai" ]; then
            local text_content=$(echo "$assistant_content" | jq -r '[.[] | if .type == "text" then .text else "Using tool: " + .name end] | join("\n")')
            messages=$(echo "$messages" | jq --arg c "$text_content" '. + [{role: "assistant", content: $c}]')
        else
            messages=$(echo "$messages" | jq ". + [{\"role\": \"assistant\", \"content\": $assistant_content}]")
        fi
        
        # If there were tool calls, add results and continue
        if [ "$(echo "$tool_results" | jq 'length')" -gt 0 ]; then
            # For DeepSeek/OpenAI, convert tool results to text format
            if [ "$PROVIDER" = "deepseek" ] || [ "$PROVIDER" = "openai" ]; then
                local result_text=$(echo "$tool_results" | jq -r '.[].content')
                messages=$(echo "$messages" | jq ". + [{\"role\": \"user\", \"content\": \"Tool result: $result_text\"}]")
            else
                messages=$(echo "$messages" | jq ". + [{\"role\": \"user\", \"content\": $tool_results}]")
            fi
        fi
        
        # Check if done
        if [ "$stop_reason" = "end_turn" ]; then
            echo -e "\n${GREEN}âœ… Task complete${NC}"
            break
        fi
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTERACTIVE MODE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interactive_mode() {
    print_banner
    check_api_key
    init_session
    echo -e "${CYAN}Workdir: $WORKDIR${NC}"
    echo ""
    echo "Type your request. Commands: /help"
    echo ""
    
    while true; do
        echo -ne "${MAGENTA}â–³ > ${NC}"
        read -r input
        
        [ -z "$input" ] && continue
        
        case "$input" in
            /quit|/exit|/q)
                echo -e "\n${GREEN}Goodbye! Ï†Â² + 1/Ï†Â² = 3${NC}"
                exit 0
                ;;
            /help|/h)
                echo ""
                echo "Commands:"
                echo "  /quit              Exit"
                echo "  /help              Show help"
                echo "  /clear             Clear screen"
                echo "  /model <name>      Switch model"
                echo "  /provider <name>   Switch provider (anthropic, openai, ollama)"
                echo "  /sessions          List sessions"
                echo "  /status            Show current status"
                echo ""
                echo "Providers:"
                echo "  anthropic  Claude (ANTHROPIC_API_KEY)"
                echo "  openai     GPT-4 (OPENAI_API_KEY)"
                echo "  ollama     Local (ollama serve)"
                echo ""
                ;;
            /clear)
                clear
                print_banner
                ;;
            /model\ *)
                MODEL="${input#/model }"
                echo -e "${GREEN}Model: $MODEL${NC}"
                ;;
            /provider\ *)
                local new_provider="${input#/provider }"
                switch_provider "$new_provider"
                ;;
            /sessions)
                list_sessions
                ;;
            /status)
                echo -e "\n${CYAN}Provider: $PROVIDER${NC}"
                echo -e "${CYAN}Model: $MODEL${NC}"
                echo -e "${CYAN}Session: $CURRENT_SESSION${NC}"
                echo ""
                ;;
            *)
                run_agent "$input"
                ;;
        esac
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

case "${1:-}" in
    -h|--help)
        print_banner
        echo "Usage: vibee-agent [options] [task]"
        echo ""
        echo "Options:"
        echo "  -h, --help     Show help"
        echo "  -v, --version  Show version"
        echo ""
        echo "Providers (auto-detected):"
        echo "  ANTHROPIC_API_KEY  Claude (claude-sonnet-4-20250514)"
        echo "  DEEPSEEK_API_KEY   DeepSeek (deepseek-chat) - CHEAPEST"
        echo "  OPENAI_API_KEY     GPT-4 (gpt-4o)"
        echo "  OLLAMA_HOST        Ollama (llama3.2) - FREE LOCAL"
        echo ""
        echo "Environment:"
        echo "  VIBEE_MODEL        Override model name"
        echo "  VIBEE_MAX_TOKENS   Max tokens (default: 4096)"
        echo "  VIBEE_SESSION_DIR  Session storage (~/.vibee/sessions)"
        echo ""
        echo "Examples:"
        echo "  vibee-agent                    # Interactive mode"
        echo "  vibee-agent 'Create hello.zig' # Single task"
        echo ""
        echo "In-session commands:"
        echo "  /provider anthropic   Switch to Claude"
        echo "  /provider openai      Switch to GPT-4"
        echo "  /provider ollama      Switch to local Ollama"
        echo "  /model gpt-4-turbo    Change model"
        echo ""
        ;;
    -v|--version)
        echo "vibee-agent v1.0.0"
        echo "Ï† = $PHI"
        echo "PHOENIX = $PHOENIX"
        ;;
    "")
        interactive_mode
        ;;
    *)
        print_banner
        check_api_key
        run_agent "$*"
        ;;
esac
