#!/bin/bash
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VIBEE AGENT - Self-Writing Code Terminal Agent
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ï†Â² + 1/Ï†Â² = 3 | PHOENIX = 999
# Multi-Model: Anthropic, OpenAI, DeepSeek, Ollama
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Don't exit on error - handle gracefully
set -o pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
NC='\033[0m' # No Color

# Sacred constants
PHI="1.618033988749895"
PHOENIX="999"

# Config
MAX_TOKENS="${VIBEE_MAX_TOKENS:-4096}"
WORKDIR="${VIBEE_WORKDIR:-$(pwd)}"
SESSION_DIR="${VIBEE_SESSION_DIR:-$HOME/.vibee/sessions}"
CURRENT_SESSION=""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ERROR HANDLING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

error() {
    echo -e "${RED}âŒ Error: $1${NC}" >&2
}

warn() {
    echo -e "${YELLOW}âš ï¸  Warning: $1${NC}" >&2
}

info() {
    echo -e "${CYAN}â„¹ï¸  $1${NC}"
}

success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

debug() {
    if [ -n "$VIBEE_DEBUG" ]; then
        echo -e "${GRAY}[DEBUG] $1${NC}" >&2
    fi
}

# Safe JSON parsing
safe_jq() {
    local input="$1"
    local query="$2"
    local default="${3:-}"
    
    local result
    result=$(echo "$input" | jq -r "$query" 2>/dev/null) || result="$default"
    
    if [ "$result" = "null" ] || [ -z "$result" ]; then
        echo "$default"
    else
        echo "$result"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PROVIDER DETECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

detect_provider() {
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        PROVIDER="anthropic"
        MODEL="${VIBEE_MODEL:-claude-sonnet-4-20250514}"
        API_URL="https://api.anthropic.com/v1/messages"
    elif [ -n "$DEEPSEEK_API_KEY" ]; then
        PROVIDER="deepseek"
        MODEL="${VIBEE_MODEL:-deepseek-chat}"
        API_URL="https://api.deepseek.com/v1/chat/completions"
    elif [ -n "$OPENAI_API_KEY" ]; then
        PROVIDER="openai"
        MODEL="${VIBEE_MODEL:-gpt-4o}"
        API_URL="https://api.openai.com/v1/chat/completions"
    elif [ -n "$OLLAMA_HOST" ] || curl -s http://localhost:11434/api/tags > /dev/null 2>&1; then
        PROVIDER="ollama"
        OLLAMA_HOST="${OLLAMA_HOST:-http://localhost:11434}"
        MODEL="${VIBEE_MODEL:-llama3.2}"
        API_URL="$OLLAMA_HOST/api/chat"
    else
        PROVIDER="none"
        MODEL=""
        API_URL=""
    fi
}

switch_provider() {
    local new_provider="$1"
    case "$new_provider" in
        anthropic|claude)
            if [ -z "$ANTHROPIC_API_KEY" ]; then
                echo -e "${RED}ANTHROPIC_API_KEY not set${NC}"
                return 1
            fi
            PROVIDER="anthropic"
            MODEL="${2:-claude-sonnet-4-20250514}"
            API_URL="https://api.anthropic.com/v1/messages"
            ;;
        deepseek)
            if [ -z "$DEEPSEEK_API_KEY" ]; then
                echo -e "${RED}DEEPSEEK_API_KEY not set${NC}"
                return 1
            fi
            PROVIDER="deepseek"
            MODEL="${2:-deepseek-chat}"
            API_URL="https://api.deepseek.com/v1/chat/completions"
            ;;
        openai|gpt)
            if [ -z "$OPENAI_API_KEY" ]; then
                echo -e "${RED}OPENAI_API_KEY not set${NC}"
                return 1
            fi
            PROVIDER="openai"
            MODEL="${2:-gpt-4o}"
            API_URL="https://api.openai.com/v1/chat/completions"
            ;;
        ollama|local)
            PROVIDER="ollama"
            OLLAMA_HOST="${OLLAMA_HOST:-http://localhost:11434}"
            MODEL="${2:-llama3.2}"
            API_URL="$OLLAMA_HOST/api/chat"
            ;;
        *)
            echo -e "${RED}Unknown provider: $new_provider${NC}"
            echo "Available: anthropic, deepseek, openai, ollama"
            return 1
            ;;
    esac
    echo -e "${GREEN}Switched to $PROVIDER ($MODEL)${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BANNER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERSION="1.1.0"

print_banner() {
    echo ""
    echo -e "${CYAN}  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}  â•‘${NC}  ${MAGENTA}VIBEE AGENT${NC} v${VERSION}                                    ${CYAN}â•‘${NC}"
    echo -e "${CYAN}  â•‘${NC}  Self-Writing Code Terminal Agent                        ${CYAN}â•‘${NC}"
    echo -e "${CYAN}  â•‘${NC}  ${YELLOW}Ï†Â² + 1/Ï†Â² = 3${NC} â”‚ ${GREEN}PHOENIX = 999${NC}                        ${CYAN}â•‘${NC}"
    echo -e "${CYAN}  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CHECK API KEY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

check_api_key() {
    detect_provider
    
    if [ "$PROVIDER" = "none" ]; then
        echo -e "${RED}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
        echo -e "${RED}â”‚  âŒ No AI provider configured                               â”‚${NC}"
        echo -e "${RED}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
        echo ""
        echo -e "${YELLOW}Set one of these environment variables:${NC}"
        echo ""
        echo -e "  ${CYAN}export ANTHROPIC_API_KEY=sk-ant-...${NC}    # Claude"
        echo -e "  ${CYAN}export DEEPSEEK_API_KEY=sk-...${NC}         # DeepSeek"
        echo -e "  ${CYAN}export OPENAI_API_KEY=sk-...${NC}           # GPT-4"
        echo -e "  ${CYAN}ollama serve${NC}                            # Local Ollama"
        echo ""
        exit 1
    fi
    
    echo -e "${GREEN}â”Œâ”€ Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    echo -e "${GREEN}â”‚${NC}  ${CYAN}$PROVIDER${NC} (${YELLOW}$MODEL${NC})"
    echo -e "${GREEN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TOOLS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TOOLS='[
  {
    "name": "read_file",
    "description": "Read contents of a file",
    "input_schema": {
      "type": "object",
      "properties": {
        "path": {"type": "string", "description": "File path to read"}
      },
      "required": ["path"]
    }
  },
  {
    "name": "write_file",
    "description": "Write content to a file",
    "input_schema": {
      "type": "object",
      "properties": {
        "path": {"type": "string", "description": "File path to write"},
        "content": {"type": "string", "description": "Content to write"}
      },
      "required": ["path", "content"]
    }
  },
  {
    "name": "run_command",
    "description": "Run a shell command",
    "input_schema": {
      "type": "object",
      "properties": {
        "command": {"type": "string", "description": "Command to execute"}
      },
      "required": ["command"]
    }
  },
  {
    "name": "list_files",
    "description": "List files in a directory",
    "input_schema": {
      "type": "object",
      "properties": {
        "path": {"type": "string", "description": "Directory path"}
      },
      "required": ["path"]
    }
  },
  {
    "name": "search_files",
    "description": "Search for text in files",
    "input_schema": {
      "type": "object",
      "properties": {
        "pattern": {"type": "string", "description": "Search pattern"},
        "path": {"type": "string", "description": "Directory to search"}
      },
      "required": ["pattern"]
    }
  }
]'

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTE TOOL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

execute_tool() {
    local tool_name="$1"
    local tool_input="$2"
    
    # Validate JSON input
    if ! echo "$tool_input" | jq . >/dev/null 2>&1; then
        echo "Error: Invalid JSON input for tool $tool_name"
        return 1
    fi
    
    case "$tool_name" in
        "read_file")
            local path
            path=$(safe_jq "$tool_input" '.path' '')
            if [ -z "$path" ]; then
                echo "Error: Missing 'path' parameter"
                return 1
            fi
            if [ -f "$path" ]; then
                # Limit output and handle binary files
                if file "$path" | grep -q "text"; then
                    head -500 "$path" 2>&1
                else
                    echo "[Binary file: $(file -b "$path")]"
                fi
            elif [ -d "$path" ]; then
                echo "Error: '$path' is a directory, use list_files instead"
            else
                echo "Error: File not found: $path"
            fi
            ;;
        "write_file")
            local path=$(echo "$tool_input" | jq -r '.path')
            local content=$(echo "$tool_input" | jq -r '.content')
            
            # PIPELINE ENFORCER: Block direct code file creation
            local ext="${path##*.}"
            case "$ext" in
                zig|py|js|ts|go|rs|java|kt|swift|c|cpp)
                    # Check if it's in trinity/output (allowed for extraction)
                    if [[ "$path" != trinity/output/* ]]; then
                        echo -e "${RED}âŒ PIPELINE VIOLATION: Cannot create .$ext files directly${NC}"
                        echo ""
                        echo "STRICT PIPELINE REQUIRED:"
                        echo "  Step 0: Create .vibee specification in specs/tri/"
                        echo "  Step 1: Include â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: block with code"
                        echo "  Step 2: Extract to trinity/output/"
                        echo ""
                        echo "Example: specs/tri/my_feature.vibee"
                        return 1
                    fi
                    ;;
            esac
            
            mkdir -p "$(dirname "$path")"
            echo "$content" > "$path"
            echo "âœ… Written to $path ($(wc -c < "$path") bytes)"
            
            # Auto-extract if .vibee file with â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§
            if [[ "$path" == *.vibee ]] && grep -q 'â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§:' "$path" 2>/dev/null; then
                local name=$(basename "$path" .vibee)
                local output="trinity/output/${name}.zig"
                mkdir -p trinity/output
                sed -n '/â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: """/,/^"""/p' "$path" | sed '1d;$d' > "$output"
                echo "âœ… Auto-extracted: $output ($(wc -l < "$output") lines)"
                
                # Auto-run tests
                echo "ğŸ§ª Running tests..."
                if zig test "$output" 2>&1 | grep -q "passed"; then
                    local test_count=$(zig test "$output" 2>&1 | grep -oP '\d+(?= tests? passed)' | head -1)
                    echo "âœ… All $test_count tests passed!"
                else
                    echo "âŒ Tests failed. Check output above."
                fi
            fi
            ;;
        "run_command")
            local cmd=$(echo "$tool_input" | jq -r '.command')
            echo -e "${CYAN}$ $cmd${NC}"
            eval "$cmd" 2>&1 | head -100
            ;;
        "list_files")
            local path=$(echo "$tool_input" | jq -r '.path // "."')
            ls -la "$path" 2>&1 | head -50
            ;;
        "search_files")
            local pattern=$(echo "$tool_input" | jq -r '.pattern')
            local path=$(echo "$tool_input" | jq -r '.path // "."')
            grep -r "$pattern" "$path" 2>&1 | head -30
            ;;
        *)
            echo "Unknown tool: $tool_name"
            ;;
    esac
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CALL LLM API (Multi-Provider)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SYSTEM_PROMPT="You are VIBEE Agent, a self-writing code assistant.

STRICT PIPELINE (MUST FOLLOW):
Step 0: Create .vibee specification in specs/tri/ folder
Step 1: NEVER write .zig/.py/.js/.ts/.go/.rs files directly
Step 2: Include â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: block in .vibee with generated code
Step 3: Extract .zig to trinity/output/ using: sed -n '/â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§: \"\"\"/,/^\"\"\"/p' file.vibee | sed '1d;\$d'
Step 4: Run tests: zig test trinity/output/file.zig
Step 5: Fix problems by updating .vibee specification

BLOCKED FILE TYPES (redirect to .vibee):
- .zig â†’ Create .vibee with â²â²“â²…_â²Ÿâ²©â²§â²¡â²©â²§ block
- .py â†’ Create .vibee with language: python
- .js/.ts â†’ Create .vibee with language: typescript
- .go â†’ Create .vibee with language: go
- .rs â†’ Create .vibee with language: rust

ALLOWED FILE TYPES:
- .vibee (specifications)
- .tri (intermediate format)
- .md (documentation)

Sacred formula: Ï†Â² + 1/Ï†Â² = 3
Always test your code after extraction."

call_llm() {
    local messages="$1"
    
    case "$PROVIDER" in
        anthropic)
            call_anthropic "$messages"
            ;;
        deepseek)
            call_deepseek "$messages"
            ;;
        openai)
            call_openai "$messages"
            ;;
        ollama)
            call_ollama "$messages"
            ;;
        *)
            echo '{"error": {"message": "No provider configured"}}'
            ;;
    esac
}

call_deepseek() {
    local messages="$1"
    
    # Build system prompt with tool instructions
    local tool_prompt="$SYSTEM_PROMPT

You have these tools available. To use a tool, respond EXACTLY in this format:
TOOL_CALL: tool_name
TOOL_INPUT: {\"param\": \"value\"}

Available tools:
- read_file: Read file contents. Input: {\"path\": \"filepath\"}
- write_file: Write to file. Input: {\"path\": \"filepath\", \"content\": \"text\"}
- run_command: Execute shell command. Input: {\"command\": \"cmd\"}
- list_files: List directory. Input: {\"path\": \"dirpath\"}

After I show you tool results, continue your response.
If no tool is needed, just respond normally."

    # Build messages array
    local deepseek_messages=$(echo "$messages" | jq --arg sys "$tool_prompt" '[{role: "system", content: $sys}] + .')
    
    local response=$(curl -s https://api.deepseek.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $DEEPSEEK_API_KEY" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": $MAX_TOKENS,
            \"messages\": $deepseek_messages
        }")
    
    # Convert to Anthropic format
    convert_deepseek_response "$response"
}

convert_deepseek_response() {
    local response="$1"
    
    # Check for error
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        echo "$response"
        return
    fi
    
    local text=$(echo "$response" | jq -r '.choices[0].message.content // ""')
    local content="[]"
    
    # Check if response contains tool call pattern
    if echo "$text" | grep -q "TOOL_CALL:"; then
        local tool_name=$(echo "$text" | grep "TOOL_CALL:" | head -1 | sed 's/TOOL_CALL: *//' | tr -d '\r\n')
        local tool_input=$(echo "$text" | grep -A1 "TOOL_INPUT:" | tail -1 | tr -d '\r\n')
        
        # Clean up tool input
        tool_input=$(echo "$tool_input" | sed 's/^TOOL_INPUT: *//')
        
        # Validate JSON
        if echo "$tool_input" | jq . > /dev/null 2>&1; then
            local tool_id="deepseek_$(date +%s)"
            content="[{\"type\": \"tool_use\", \"id\": \"$tool_id\", \"name\": \"$tool_name\", \"input\": $tool_input}]"
            
            # Add any text before the tool call (macOS compatible)
            local pre_text=$(echo "$text" | sed -n '1,/TOOL_CALL:/p' | sed '$d')
            if [ -n "$pre_text" ]; then
                content=$(echo "$content" | jq --arg t "$pre_text" '. + [{type: "text", text: $t}]')
            fi
            
            echo "{\"content\": $content, \"stop_reason\": \"tool_use\"}"
        else
            # Invalid JSON, treat as text
            content="[{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]"
            echo "{\"content\": $content, \"stop_reason\": \"end_turn\"}"
        fi
    else
        content="[{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]"
        echo "{\"content\": $content, \"stop_reason\": \"end_turn\"}"
    fi
}

call_anthropic() {
    local messages="$1"
    
    curl -s https://api.anthropic.com/v1/messages \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": $MAX_TOKENS,
            \"system\": \"$SYSTEM_PROMPT\",
            \"tools\": $TOOLS,
            \"messages\": $messages
        }"
}

call_openai() {
    local messages="$1"
    
    # Convert Anthropic format to OpenAI format
    local openai_messages=$(echo "$messages" | jq '[{role: "system", content: "'"$SYSTEM_PROMPT"'"} ] + .')
    
    # Convert tools to OpenAI format
    local openai_tools=$(echo "$TOOLS" | jq '[.[] | {type: "function", function: {name: .name, description: .description, parameters: .input_schema}}]')
    
    local response=$(curl -s https://api.openai.com/v1/chat/completions \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "{
            \"model\": \"$MODEL\",
            \"max_tokens\": $MAX_TOKENS,
            \"tools\": $openai_tools,
            \"messages\": $openai_messages
        }")
    
    # Convert OpenAI response to Anthropic format for unified processing
    convert_openai_response "$response"
}

convert_openai_response() {
    local response="$1"
    
    # Check for error
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        echo "$response"
        return
    fi
    
    local finish_reason=$(echo "$response" | jq -r '.choices[0].finish_reason')
    local message=$(echo "$response" | jq -c '.choices[0].message')
    
    # Build Anthropic-style response
    local content="[]"
    
    # Add text content if present
    local text=$(echo "$message" | jq -r '.content // empty')
    if [ -n "$text" ]; then
        content=$(echo "$content" | jq ". + [{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]")
    fi
    
    # Add tool calls if present
    local tool_calls=$(echo "$message" | jq -c '.tool_calls // []')
    if [ "$(echo "$tool_calls" | jq 'length')" -gt 0 ]; then
        while IFS= read -r tc; do
            local tc_id=$(echo "$tc" | jq -r '.id')
            local tc_name=$(echo "$tc" | jq -r '.function.name')
            local tc_args=$(echo "$tc" | jq -c '.function.arguments | fromjson')
            content=$(echo "$content" | jq ". + [{\"type\": \"tool_use\", \"id\": \"$tc_id\", \"name\": \"$tc_name\", \"input\": $tc_args}]")
        done <<< "$(echo "$tool_calls" | jq -c '.[]')"
    fi
    
    local stop_reason="end_turn"
    [ "$finish_reason" = "tool_calls" ] && stop_reason="tool_use"
    
    echo "{\"content\": $content, \"stop_reason\": \"$stop_reason\"}"
}

call_ollama() {
    local messages="$1"
    
    # Ollama doesn't support tools natively, so we use a prompt-based approach
    local ollama_messages=$(echo "$messages" | jq '[{role: "system", content: "'"$SYSTEM_PROMPT"'\n\nYou have these tools available:\n- read_file(path): Read a file\n- write_file(path, content): Write to a file\n- run_command(command): Run a shell command\n- list_files(path): List directory\n- search_files(pattern, path): Search in files\n\nTo use a tool, respond with:\nTOOL: tool_name\nINPUT: {\"param\": \"value\"}\n\nAfter tool results, continue your response."} ] + .')
    
    local response=$(curl -s "$OLLAMA_HOST/api/chat" \
        -H "Content-Type: application/json" \
        -d "{
            \"model\": \"$MODEL\",
            \"messages\": $ollama_messages,
            \"stream\": false
        }")
    
    # Convert Ollama response to Anthropic format
    convert_ollama_response "$response"
}

convert_ollama_response() {
    local response="$1"
    
    # Check for error
    if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
        echo "$response"
        return
    fi
    
    local text=$(echo "$response" | jq -r '.message.content // ""')
    local content="[]"
    
    # Check if response contains tool call pattern
    if echo "$text" | grep -q "^TOOL:"; then
        local tool_name=$(echo "$text" | grep "^TOOL:" | head -1 | sed 's/TOOL: *//')
        local tool_input=$(echo "$text" | grep -A1 "^INPUT:" | tail -1)
        
        # Generate a unique ID
        local tool_id="ollama_$(date +%s%N)"
        
        content=$(echo "$content" | jq ". + [{\"type\": \"tool_use\", \"id\": \"$tool_id\", \"name\": \"$tool_name\", \"input\": $tool_input}]")
        echo "{\"content\": $content, \"stop_reason\": \"tool_use\"}"
    else
        content=$(echo "$content" | jq ". + [{\"type\": \"text\", \"text\": $(echo "$text" | jq -Rs .)}]")
        echo "{\"content\": $content, \"stop_reason\": \"end_turn\"}"
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# AGENT LOOP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SESSION MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

init_session() {
    mkdir -p "$SESSION_DIR"
    CURRENT_SESSION="$SESSION_DIR/session_$(date +%Y%m%d_%H%M%S).json"
    echo '{"messages": [], "provider": "'"$PROVIDER"'", "model": "'"$MODEL"'"}' > "$CURRENT_SESSION"
    echo -e "${CYAN}Session: $CURRENT_SESSION${NC}"
}

save_session() {
    if [ -n "$CURRENT_SESSION" ] && [ -f "$CURRENT_SESSION" ]; then
        local messages="$1"
        echo "{\"messages\": $messages, \"provider\": \"$PROVIDER\", \"model\": \"$MODEL\"}" > "$CURRENT_SESSION"
    fi
}

load_session() {
    local session_file="$1"
    if [ -f "$session_file" ]; then
        CURRENT_SESSION="$session_file"
        local saved=$(cat "$session_file")
        PROVIDER=$(echo "$saved" | jq -r '.provider')
        MODEL=$(echo "$saved" | jq -r '.model')
        echo "$saved" | jq -c '.messages'
    else
        echo "[]"
    fi
}

list_sessions() {
    echo -e "\n${CYAN}Sessions:${NC}"
    ls -la "$SESSION_DIR"/*.json 2>/dev/null | while read line; do
        echo "  $line"
    done
}

run_agent() {
    local user_message="$1"
    local messages="[{\"role\": \"user\", \"content\": \"$user_message\"}]"
    local iteration=0
    local max_iterations=10
    
    while [ $iteration -lt $max_iterations ]; do
        iteration=$((iteration + 1))
        echo -e "\n${BLUE}[Iteration $iteration] ($PROVIDER/$MODEL)${NC}"
        
        # Call LLM (multi-provider)
        local response=$(call_llm "$messages")
        
        # Check for errors
        if echo "$response" | jq -e '.error' > /dev/null 2>&1; then
            echo -e "${RED}API Error: $(echo "$response" | jq -r '.error.message')${NC}"
            return 1
        fi
        
        # Get stop reason
        local stop_reason=$(echo "$response" | jq -r '.stop_reason')
        
        # Process content blocks
        local content=$(echo "$response" | jq -c '.content[]')
        local assistant_content="[]"
        local tool_results="[]"
        
        while IFS= read -r block; do
            local block_type=$(echo "$block" | jq -r '.type')
            
            if [ "$block_type" = "text" ]; then
                local text=$(echo "$block" | jq -r '.text')
                echo -e "\n${GREEN}Claude:${NC} $text"
                assistant_content=$(echo "$assistant_content" | jq ". + [$block]")
            elif [ "$block_type" = "tool_use" ]; then
                local tool_id=$(echo "$block" | jq -r '.id')
                local tool_name=$(echo "$block" | jq -r '.name')
                local tool_input=$(echo "$block" | jq -c '.input')
                
                echo ""
                echo -e "${YELLOW}â”Œâ”€ Tool: $tool_name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
                echo -e "${GRAY}â”‚ Input: $tool_input${NC}"
                echo -e "${YELLOW}â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
                
                # Execute tool
                local result
                result=$(execute_tool "$tool_name" "$tool_input" 2>&1)
                local exit_code=$?
                
                if [ $exit_code -eq 0 ]; then
                    echo -e "${GREEN}â”‚ Result:${NC}"
                else
                    echo -e "${RED}â”‚ Error:${NC}"
                fi
                echo "$result" | head -20 | sed 's/^/â”‚ /'
                echo -e "${YELLOW}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
                
                # Safely encode result as JSON string
                local result_json
                result_json=$(printf '%s' "$result" | jq -Rs . 2>/dev/null || echo '"[Error encoding result]"')
                
                assistant_content=$(echo "$assistant_content" | jq ". + [$block]" 2>/dev/null || echo "[]")
                tool_results=$(echo "$tool_results" | jq ". + [{\"type\": \"tool_result\", \"tool_use_id\": \"$tool_id\", \"content\": $result_json}]" 2>/dev/null || echo "[]")
            fi
        done <<< "$content"
        
        # Add assistant message
        # For DeepSeek/OpenAI, convert content to text format
        if [ "$PROVIDER" = "deepseek" ] || [ "$PROVIDER" = "openai" ]; then
            local text_content=$(echo "$assistant_content" | jq -r '[.[] | if .type == "text" then .text else "Using tool: " + .name end] | join("\n")')
            messages=$(echo "$messages" | jq --arg c "$text_content" '. + [{role: "assistant", content: $c}]')
        else
            messages=$(echo "$messages" | jq ". + [{\"role\": \"assistant\", \"content\": $assistant_content}]")
        fi
        
        # If there were tool calls, add results and continue
        if [ "$(echo "$tool_results" | jq 'length')" -gt 0 ]; then
            # For DeepSeek/OpenAI, convert tool results to text format
            if [ "$PROVIDER" = "deepseek" ] || [ "$PROVIDER" = "openai" ]; then
                local result_text=$(echo "$tool_results" | jq -r '.[].content')
                messages=$(echo "$messages" | jq ". + [{\"role\": \"user\", \"content\": \"Tool result: $result_text\"}]")
            else
                messages=$(echo "$messages" | jq ". + [{\"role\": \"user\", \"content\": $tool_results}]")
            fi
        fi
        
        # Check if done
        if [ "$stop_reason" = "end_turn" ]; then
            echo -e "\n${GREEN}âœ… Task complete${NC}"
            break
        fi
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VOICE CONTROL (v166-v170)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VOICE_ENABLED=false
WAKE_WORD="vibee"
VOICE_LANG="${VIBEE_VOICE_LANG:-en-US}"

# Check voice dependencies
check_voice_deps() {
    local missing=""
    
    # Check for speech recognition (whisper.cpp or online)
    if ! command -v whisper &> /dev/null && ! command -v curl &> /dev/null; then
        missing="$missing whisper/curl"
    fi
    
    # Check for text-to-speech
    if ! command -v espeak &> /dev/null && ! command -v say &> /dev/null && ! command -v piper &> /dev/null; then
        missing="$missing espeak/say/piper"
    fi
    
    # Check for audio recording
    if ! command -v arecord &> /dev/null && ! command -v sox &> /dev/null && ! command -v rec &> /dev/null; then
        missing="$missing arecord/sox"
    fi
    
    if [ -n "$missing" ]; then
        echo -e "${YELLOW}âš ï¸  Voice dependencies missing:$missing${NC}"
        echo -e "${GRAY}   Install: apt install espeak sox alsa-utils${NC}"
        return 1
    fi
    return 0
}

# Text-to-Speech
speak() {
    local text="$1"
    echo -e "${CYAN}ğŸ”Š $text${NC}"
    
    if command -v espeak &> /dev/null; then
        espeak -v "$VOICE_LANG" "$text" 2>/dev/null &
    elif command -v say &> /dev/null; then
        say "$text" &
    elif command -v piper &> /dev/null; then
        echo "$text" | piper --output-raw | aplay -r 22050 -f S16_LE -t raw - 2>/dev/null &
    fi
}

# Record audio
record_audio() {
    local duration="${1:-5}"
    local output="/tmp/vibee_voice_$$.wav"
    
    echo -e "${MAGENTA}ğŸ¤ Listening... (${duration}s)${NC}"
    
    if command -v rec &> /dev/null; then
        rec -q "$output" rate 16k silence 1 0.1 1% 1 1.0 1% trim 0 "$duration" 2>/dev/null
    elif command -v arecord &> /dev/null; then
        timeout "$duration" arecord -q -f S16_LE -r 16000 -c 1 "$output" 2>/dev/null
    elif command -v sox &> /dev/null; then
        timeout "$duration" sox -d -r 16000 -c 1 "$output" 2>/dev/null
    else
        echo -e "${RED}No audio recorder found${NC}"
        return 1
    fi
    
    echo "$output"
}

# Speech-to-Text using Whisper API or local whisper.cpp
transcribe_audio() {
    local audio_file="$1"
    local text=""
    
    if [ ! -f "$audio_file" ]; then
        return 1
    fi
    
    # Try local whisper.cpp first
    if command -v whisper &> /dev/null; then
        text=$(whisper "$audio_file" --language en --output-txt 2>/dev/null | tail -1)
    # Try OpenAI Whisper API
    elif [ -n "$OPENAI_API_KEY" ]; then
        text=$(curl -s https://api.openai.com/v1/audio/transcriptions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -F file="@$audio_file" \
            -F model="whisper-1" \
            -F language="en" | jq -r '.text // empty')
    # Try Groq Whisper API (free tier)
    elif [ -n "$GROQ_API_KEY" ]; then
        text=$(curl -s https://api.groq.com/openai/v1/audio/transcriptions \
            -H "Authorization: Bearer $GROQ_API_KEY" \
            -F file="@$audio_file" \
            -F model="whisper-large-v3" | jq -r '.text // empty')
    fi
    
    rm -f "$audio_file" 2>/dev/null
    echo "$text"
}

# Parse voice command to action
parse_voice_command() {
    local text="$1"
    text=$(echo "$text" | tr '[:upper:]' '[:lower:]')
    
    # Remove wake word
    text=$(echo "$text" | sed "s/^$WAKE_WORD[,. ]*//" | sed 's/^[ ]*//')
    
    case "$text" in
        "list files"|"show files"|"ls")
            echo "ls -la"
            ;;
        "git status"|"show git status"|"status")
            echo "git status"
            ;;
        "git log"|"show log")
            echo "git log --oneline -10"
            ;;
        "git diff"|"show diff")
            echo "git diff"
            ;;
        "git push"|"push")
            echo "git push"
            ;;
        "git pull"|"pull")
            echo "git pull"
            ;;
        "run tests"|"test"|"tests")
            echo "zig test trinity/output/*.zig 2>&1 | head -20"
            ;;
        "build"|"compile")
            echo "cd src/vibeec && zig build"
            ;;
        "clear"|"clear screen")
            echo "clear"
            ;;
        "help"|"show help")
            echo "__HELP__"
            ;;
        "stop"|"exit"|"quit"|"goodbye")
            echo "__EXIT__"
            ;;
        go\ to\ *|cd\ *)
            local dir=$(echo "$text" | sed 's/^go to //' | sed 's/^cd //')
            echo "cd $dir"
            ;;
        search\ *|find\ *)
            local query=$(echo "$text" | sed 's/^search //' | sed 's/^find //')
            echo "grep -r '$query' . 2>/dev/null | head -20"
            ;;
        *)
            # Pass to AI agent
            echo "__AI__:$text"
            ;;
    esac
}

# Voice mode loop
voice_mode() {
    echo -e "${CYAN}â”Œâ”€ Voice Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    echo -e "${CYAN}â”‚${NC}  Wake word: ${YELLOW}$WAKE_WORD${NC}"
    echo -e "${CYAN}â”‚${NC}  Say '${YELLOW}$WAKE_WORD, help${NC}' for commands"
    echo -e "${CYAN}â”‚${NC}  Say '${YELLOW}$WAKE_WORD, stop${NC}' to exit voice mode"
    echo -e "${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
    
    speak "Voice mode activated. Say $WAKE_WORD followed by your command."
    
    while true; do
        # Record audio
        local audio_file=$(record_audio 5)
        
        if [ -z "$audio_file" ] || [ ! -f "$audio_file" ]; then
            continue
        fi
        
        # Transcribe
        local text=$(transcribe_audio "$audio_file")
        
        if [ -z "$text" ]; then
            continue
        fi
        
        echo -e "${GREEN}ğŸ“ Heard: $text${NC}"
        
        # Check for wake word
        if ! echo "$text" | grep -qi "$WAKE_WORD"; then
            continue
        fi
        
        # Parse command
        local command=$(parse_voice_command "$text")
        
        case "$command" in
            __EXIT__)
                speak "Goodbye!"
                echo -e "${GREEN}Voice mode deactivated${NC}"
                return 0
                ;;
            __HELP__)
                speak "Available commands: list files, git status, run tests, go to directory, search, stop"
                echo -e "${CYAN}Commands: list files, git status, git log, git push, git pull, run tests, build, go to [dir], search [text], stop${NC}"
                ;;
            __AI__:*)
                local ai_query="${command#__AI__:}"
                speak "Processing: $ai_query"
                run_agent "$ai_query"
                speak "Done"
                ;;
            *)
                echo -e "${YELLOW}âš¡ Executing: $command${NC}"
                speak "Executing $command"
                
                # Handle cd specially
                if [[ "$command" == cd\ * ]]; then
                    local dir="${command#cd }"
                    if cd "$dir" 2>/dev/null; then
                        WORKDIR=$(pwd)
                        speak "Changed to $WORKDIR"
                        echo -e "${GREEN}ğŸ“‚ $WORKDIR${NC}"
                    else
                        speak "Directory not found"
                        echo -e "${RED}Directory not found: $dir${NC}"
                    fi
                else
                    local result=$(eval "$command" 2>&1)
                    echo "$result" | head -10
                    
                    local lines=$(echo "$result" | wc -l)
                    if [ "$lines" -lt 5 ]; then
                        speak "$result"
                    else
                        speak "Command completed with $lines lines of output"
                    fi
                fi
                ;;
        esac
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTERACTIVE MODE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interactive_mode() {
    print_banner
    check_api_key
    init_session
    
    echo -e "${GRAY}â”Œâ”€ Session â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
    echo -e "${GRAY}â”‚${NC} ${CYAN}$CURRENT_SESSION${NC}"
    echo -e "${GRAY}â”‚${NC} Workdir: ${YELLOW}$WORKDIR${NC}"
    echo -e "${GRAY}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
    echo ""
    echo -e "Type your request or ${CYAN}/help${NC} for commands"
    echo ""
    
    while true; do
        echo -ne "${MAGENTA}vibee>${NC} "
        read -r input
        
        [ -z "$input" ] && continue
        
        case "$input" in
            /quit|/exit|/q)
                echo ""
                echo -e "${GREEN}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
                echo -e "${GREEN}â”‚${NC}  Goodbye! ${YELLOW}Ï†Â² + 1/Ï†Â² = 3${NC}                                    ${GREEN}â”‚${NC}"
                echo -e "${GREEN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
                exit 0
                ;;
            /help|/h)
                echo ""
                echo -e "${CYAN}â”Œâ”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${NC}"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/quit${NC}              Exit"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/help${NC}              Show this help"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/clear${NC}             Clear screen"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/voice${NC}             ğŸ¤ Voice control mode"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/speak${NC} <text>      ğŸ”Š Text-to-speech"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/model${NC} <name>      Switch model"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/provider${NC} <name>   Switch provider"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/sessions${NC}          List sessions"
                echo -e "${CYAN}â”‚${NC}  ${YELLOW}/status${NC}            Show current status"
                echo -e "${CYAN}â”œâ”€ Providers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
                echo -e "${CYAN}â”‚${NC}  ${GREEN}anthropic${NC}  Claude (ANTHROPIC_API_KEY)"
                echo -e "${CYAN}â”‚${NC}  ${GREEN}deepseek${NC}   DeepSeek (DEEPSEEK_API_KEY)"
                echo -e "${CYAN}â”‚${NC}  ${GREEN}openai${NC}     GPT-4 (OPENAI_API_KEY)"
                echo -e "${CYAN}â”‚${NC}  ${GREEN}ollama${NC}     Local (ollama serve)"
                echo -e "${CYAN}â”œâ”€ Voice Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤${NC}"
                echo -e "${CYAN}â”‚${NC}  ${MAGENTA}vibee, list files${NC}     ls -la"
                echo -e "${CYAN}â”‚${NC}  ${MAGENTA}vibee, git status${NC}     git status"
                echo -e "${CYAN}â”‚${NC}  ${MAGENTA}vibee, run tests${NC}      zig test"
                echo -e "${CYAN}â”‚${NC}  ${MAGENTA}vibee, go to src${NC}      cd src"
                echo -e "${CYAN}â”‚${NC}  ${MAGENTA}vibee, search main${NC}    grep -r 'main'"
                echo -e "${CYAN}â”‚${NC}  ${MAGENTA}vibee, stop${NC}           exit voice mode"
                echo -e "${CYAN}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${NC}"
                echo ""
                ;;
            /clear)
                clear
                print_banner
                ;;
            /model\ *)
                MODEL="${input#/model }"
                echo -e "${GREEN}Model: $MODEL${NC}"
                ;;
            /provider\ *)
                local new_provider="${input#/provider }"
                switch_provider "$new_provider"
                ;;
            /sessions)
                list_sessions
                ;;
            /status)
                echo -e "\n${CYAN}Provider: $PROVIDER${NC}"
                echo -e "${CYAN}Model: $MODEL${NC}"
                echo -e "${CYAN}Session: $CURRENT_SESSION${NC}"
                echo -e "${CYAN}Voice: $(check_voice_deps && echo 'Available' || echo 'Not available')${NC}"
                echo ""
                ;;
            /voice)
                if check_voice_deps; then
                    voice_mode
                else
                    echo -e "${RED}Voice mode requires: espeak, sox/arecord${NC}"
                    echo -e "${GRAY}Install: apt install espeak sox alsa-utils${NC}"
                    echo -e "${GRAY}Or use OPENAI_API_KEY for cloud transcription${NC}"
                fi
                ;;
            /speak\ *)
                local text="${input#/speak }"
                speak "$text"
                ;;
            *)
                run_agent "$input"
                ;;
        esac
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

case "${1:-}" in
    -h|--help)
        print_banner
        echo "Usage: vibee-agent [options] [task]"
        echo ""
        echo "Options:"
        echo "  -h, --help     Show help"
        echo "  -v, --version  Show version"
        echo ""
        echo "Providers (auto-detected):"
        echo "  ANTHROPIC_API_KEY  Claude (claude-sonnet-4-20250514)"
        echo "  DEEPSEEK_API_KEY   DeepSeek (deepseek-chat) - CHEAPEST"
        echo "  OPENAI_API_KEY     GPT-4 (gpt-4o)"
        echo "  OLLAMA_HOST        Ollama (llama3.2) - FREE LOCAL"
        echo ""
        echo "Environment:"
        echo "  VIBEE_MODEL        Override model name"
        echo "  VIBEE_MAX_TOKENS   Max tokens (default: 4096)"
        echo "  VIBEE_SESSION_DIR  Session storage (~/.vibee/sessions)"
        echo ""
        echo "Examples:"
        echo "  vibee-agent                    # Interactive mode"
        echo "  vibee-agent 'Create hello.zig' # Single task"
        echo ""
        echo "In-session commands:"
        echo "  /provider anthropic   Switch to Claude"
        echo "  /provider openai      Switch to GPT-4"
        echo "  /provider ollama      Switch to local Ollama"
        echo "  /model gpt-4-turbo    Change model"
        echo ""
        ;;
    -v|--version)
        echo "vibee-agent v1.0.0"
        echo "Ï† = $PHI"
        echo "PHOENIX = $PHOENIX"
        ;;
    "")
        interactive_mode
        ;;
    *)
        print_banner
        check_api_key
        run_agent "$*"
        ;;
esac
