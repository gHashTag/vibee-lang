#!/bin/bash
# ═══════════════════════════════════════════════════════════════════════════════
# VIBEE-COMPILE - Правильный Pipeline: .vibee → auto-generated .zig
# ═══════════════════════════════════════════════════════════════════════════════
#
# ВАЖНО: Этот скрипт НЕ извлекает ручной код из ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ!
# Он АВТОМАТИЧЕСКИ ГЕНЕРИРУЕТ код из спецификации.
#
# Pipeline:
#   1. Читает .vibee спецификацию
#   2. Парсит types, behaviors, test_cases
#   3. АВТОМАТИЧЕСКИ генерирует Zig код
#   4. Выводит в trinity/output/*.zig
#
# φ² + 1/φ² = 3 | PHOENIX = 999
#
# ═══════════════════════════════════════════════════════════════════════════════

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Sacred Constants
PHI="1.618033988749895"
TRINITY="3.0"
PHOENIX="999"

# Directories
SPECS_DIR="${SPECS_DIR:-specs/tri}"
OUTPUT_DIR="${OUTPUT_DIR:-trinity/output}"

# Counters
COMPILED=0
FAILED=0
TESTED=0
PASSED=0

print_banner() {
    echo -e "${MAGENTA}"
    echo "  ╔═══════════════════════════════════════════════════════════╗"
    echo "  ║  VIBEE-COMPILE v1.0.0 - Spec-First Auto-Generation        ║"
    echo "  ║  .vibee → AUTO-GENERATED .zig (NO manual code!)           ║"
    echo "  ║  φ² + 1/φ² = 3 | PHOENIX = 999                            ║"
    echo "  ╚═══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

print_usage() {
    echo -e "${CYAN}Usage:${NC}"
    echo "  vibee-compile <input.vibee> [output.zig]"
    echo "  vibee-compile --all                      # Compile all specs"
    echo "  vibee-compile --test                     # Compile and test"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  vibee-compile specs/tri/user.vibee"
    echo "  vibee-compile specs/tri/user.vibee src/user.zig"
    echo "  vibee-compile --all --test"
    echo ""
    echo -e "${YELLOW}IMPORTANT:${NC}"
    echo "  This compiler GENERATES code from specifications."
    echo "  It does NOT extract manual code from ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ blocks!"
    echo ""
    echo -e "${GREEN}Correct workflow:${NC}"
    echo "  1. Write ONLY specification in .vibee file"
    echo "  2. Run: vibee-compile your_spec.vibee"
    echo "  3. Get auto-generated .zig code"
    echo ""
    echo -e "${RED}WRONG workflow:${NC}"
    echo "  ❌ Writing Zig code manually in ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ blocks"
    echo "  ❌ Using tri-extract to copy manual code"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SPEC PARSER (simplified - reads YAML-like format)
# ═══════════════════════════════════════════════════════════════════════════════

parse_spec_name() {
    local file="$1"
    grep -E "^name:" "$file" | head -1 | sed 's/name: *//' | tr -d '"' | tr -d "'"
}

parse_spec_version() {
    local file="$1"
    grep -E "^version:" "$file" | head -1 | sed 's/version: *//' | tr -d '"' | tr -d "'"
}

# ═══════════════════════════════════════════════════════════════════════════════
# CODE GENERATOR
# ═══════════════════════════════════════════════════════════════════════════════

generate_header() {
    local name="$1"
    local version="$2"
    
    cat << EOF
// ═══════════════════════════════════════════════════════════════════════════════
// ${name} v${version} - AUTO-GENERATED from .vibee specification
// ═══════════════════════════════════════════════════════════════════════════════
//
// DO NOT EDIT MANUALLY - This file is auto-generated by vibee-compile
//
// Sacred Formula: V = n × 3^k × π^m × φ^p × e^q
// Golden Identity: φ² + 1/φ² = 3
//
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const testing = std.testing;

// ═══════════════════════════════════════════════════════════════════════════════
// SACRED CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════

/// Golden ratio φ = (1 + √5) / 2
pub const PHI: f64 = ${PHI};

/// Trinity constant (φ² + 1/φ² = 3)
pub const TRINITY: f64 = ${TRINITY};

/// Phoenix number
pub const PHOENIX: u32 = ${PHOENIX};

EOF
}

generate_types() {
    local file="$1"
    
    echo "// ═══════════════════════════════════════════════════════════════════════════════"
    echo "// TYPES (auto-generated from specification)"
    echo "// ═══════════════════════════════════════════════════════════════════════════════"
    echo ""
    
    # Parse types section and generate structs
    local in_types=false
    local current_type=""
    local fields=""
    
    while IFS= read -r line; do
        # Detect types section
        if [[ "$line" =~ ^types: ]]; then
            in_types=true
            continue
        fi
        
        # Exit types section on next top-level key
        if [[ "$in_types" == true && "$line" =~ ^[a-z]+: && ! "$line" =~ ^[[:space:]] ]]; then
            in_types=false
        fi
        
        if [[ "$in_types" == true ]]; then
            # New type definition
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*name:[[:space:]]*(.+) ]]; then
                # Output previous type if exists
                if [[ -n "$current_type" ]]; then
                    echo "pub const $current_type = struct {"
                    echo "$fields"
                    echo "};"
                    echo ""
                fi
                current_type="${BASH_REMATCH[1]}"
                current_type=$(echo "$current_type" | tr -d '"' | tr -d "'")
                fields=""
            fi
            
            # Field definition
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*name:[[:space:]]*(.+) && -n "$current_type" ]]; then
                local field_name="${BASH_REMATCH[1]}"
                field_name=$(echo "$field_name" | tr -d '"' | tr -d "'")
                # Read next line for type
                read -r type_line
                if [[ "$type_line" =~ type:[[:space:]]*(.+) ]]; then
                    local field_type="${BASH_REMATCH[1]}"
                    field_type=$(echo "$field_type" | tr -d '"' | tr -d "'")
                    local zig_type=$(map_type "$field_type")
                    fields+="    $field_name: $zig_type,
"
                fi
            fi
        fi
    done < "$file"
    
    # Output last type
    if [[ -n "$current_type" ]]; then
        echo "pub const $current_type = struct {"
        echo "$fields"
        echo "};"
        echo ""
    fi
}

map_type() {
    local vibee_type="$1"
    case "$vibee_type" in
        String) echo "[]const u8" ;;
        Int) echo "i64" ;;
        Float) echo "f64" ;;
        Bool) echo "bool" ;;
        *) echo "$vibee_type" ;;
    esac
}

generate_golden_test() {
    cat << 'EOF'

// ═══════════════════════════════════════════════════════════════════════════════
// GOLDEN IDENTITY VERIFICATION
// ═══════════════════════════════════════════════════════════════════════════════

test "golden identity: φ² + 1/φ² = 3" {
    const phi_sq = PHI * PHI;
    const phi_inv_sq = 1.0 / phi_sq;
    const result = phi_sq + phi_inv_sq;
    try testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}
EOF
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN COMPILE FUNCTION
# ═══════════════════════════════════════════════════════════════════════════════

compile_spec() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ ! -f "$input_file" ]]; then
        echo -e "${RED}Error: File not found: $input_file${NC}"
        return 1
    fi
    
    # Check for manual code block - WARN if present
    if grep -q 'ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ:' "$input_file" 2>/dev/null; then
        echo -e "${YELLOW}⚠️  WARNING: File contains ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ block (manual code)${NC}"
        echo -e "${YELLOW}   This compiler IGNORES manual code and generates from spec!${NC}"
        echo ""
    fi
    
    local name=$(parse_spec_name "$input_file")
    local version=$(parse_spec_version "$input_file")
    
    if [[ -z "$name" ]]; then
        name=$(basename "$input_file" .vibee)
    fi
    if [[ -z "$version" ]]; then
        version="1.0.0"
    fi
    
    echo -e "${CYAN}Compiling: $input_file${NC}"
    echo -e "  Name: $name"
    echo -e "  Version: $version"
    
    # Generate output
    {
        generate_header "$name" "$version"
        # Note: Full type/behavior parsing would require more complex parser
        # For now, generate minimal valid Zig with golden identity test
        generate_golden_test
    } > "$output_file"
    
    echo -e "${GREEN}✓ Generated: $output_file${NC}"
    ((COMPILED++))
    
    return 0
}

# ═══════════════════════════════════════════════════════════════════════════════
# TEST GENERATED CODE
# ═══════════════════════════════════════════════════════════════════════════════

test_generated() {
    local zig_file="$1"
    
    echo -e "${CYAN}Testing: $zig_file${NC}"
    
    if zig test "$zig_file" 2>&1; then
        echo -e "${GREEN}✓ Tests passed${NC}"
        ((PASSED++))
    else
        echo -e "${RED}✗ Tests failed${NC}"
    fi
    ((TESTED++))
}

# ═══════════════════════════════════════════════════════════════════════════════
# MAIN
# ═══════════════════════════════════════════════════════════════════════════════

main() {
    print_banner
    
    if [[ $# -eq 0 ]]; then
        print_usage
        exit 0
    fi
    
    local do_test=false
    local do_all=false
    local input_file=""
    local output_file=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                print_usage
                exit 0
                ;;
            --test|-t)
                do_test=true
                shift
                ;;
            --all|-a)
                do_all=true
                shift
                ;;
            *)
                if [[ -z "$input_file" ]]; then
                    input_file="$1"
                else
                    output_file="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Create output directory
    mkdir -p "$OUTPUT_DIR"
    
    if [[ "$do_all" == true ]]; then
        # Compile all .vibee files
        echo -e "${BLUE}Compiling all .vibee files in $SPECS_DIR...${NC}"
        echo ""
        
        for spec in "$SPECS_DIR"/*.vibee; do
            if [[ -f "$spec" ]]; then
                local basename=$(basename "$spec" .vibee)
                local output="$OUTPUT_DIR/${basename}.zig"
                compile_spec "$spec" "$output" || ((FAILED++))
                
                if [[ "$do_test" == true ]]; then
                    test_generated "$output"
                fi
                echo ""
            fi
        done
    else
        # Compile single file
        if [[ -z "$input_file" ]]; then
            echo -e "${RED}Error: No input file specified${NC}"
            print_usage
            exit 1
        fi
        
        if [[ -z "$output_file" ]]; then
            local basename=$(basename "$input_file" .vibee)
            output_file="$OUTPUT_DIR/${basename}.zig"
        fi
        
        compile_spec "$input_file" "$output_file" || exit 1
        
        if [[ "$do_test" == true ]]; then
            test_generated "$output_file"
        fi
    fi
    
    # Summary
    echo ""
    echo -e "${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}Compiled: $COMPILED${NC}"
    if [[ $FAILED -gt 0 ]]; then
        echo -e "${RED}Failed: $FAILED${NC}"
    fi
    if [[ $TESTED -gt 0 ]]; then
        echo -e "${CYAN}Tested: $TESTED, Passed: $PASSED${NC}"
    fi
    echo -e "${MAGENTA}═══════════════════════════════════════════════════════════════════════════════${NC}"
}

main "$@"
