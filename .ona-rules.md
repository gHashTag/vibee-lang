# Ona Agent Rules for VIBEE Project

## ğŸ‰ CRITICAL UPDATE: Dogfooding System Complete!

**Status**: Production-Ready Dogfooding + Bootstrap Complete  
**Date**: 2026-01-12  
**Author**: Dmitrii Vasilev

### Latest Achievements âœ… COMPLETE

**Dogfooding System** (2026-01-12):
- âœ… Scanner (violation detection)
- âœ… Auto-Fix (regenerate from specs)
- âœ… Git Hooks (pre-commit, pre-push)
- âœ… CLI (user-friendly interface)
- âœ… Tests (20+ integration tests)
- âœ… Documentation (complete guide)

**Bootstrap Evolution**:
- âœ… Multi-language codegen (Rust, Zig, Go)
- âœ… Bootstrap pipeline (4 stages, winner selection)
- âœ… Evolutionary selection (genetic algorithm)
- âœ… 28 tests (98.9% pass rate)
- âœ… Complete documentation (5 reports)

### Winner: Zig ğŸ†
**Performance**:
- Compile: 800ms (2.5x faster than Rust)
- Binary: 800KB (smallest)
- Memory: 8MB (lowest)
- Score: 86.0 (+16.8% improvement)

### MANDATORY: All New Code in Zig
**Starting NOW, all new development uses Zig**:
1. Plugins (honeycomb/) â†’ Zig
2. Core compiler â†’ Zig
3. MCP tools â†’ Zig
4. Tests â†’ Zig
5. FFI â†’ Keep Erlang for BEAM interop

**Compiler Flags**:
```bash
zig build-exe -O ReleaseFast \
  -finline-small-functions \
  -funroll-loops \
  -fvectorize
```

## ğŸ“ Project Structure (Updated 2026-01-12)

```
vibee-lang/
â”œâ”€â”€ specs/                  # ğŸ“ Specifications (.vibee)
â”‚   â”œâ”€â”€ watcher.vibee       # File system watcher âœ¨ NEW!
â”‚   â”œâ”€â”€ scanner.vibee       # Violation scanner âœ¨ NEW!
â”‚   â”œâ”€â”€ autofix.vibee       # Auto-fix logic âœ¨ NEW!
â”‚   â”œâ”€â”€ hooks.vibee         # Git hooks âœ¨ NEW!
â”‚   â””â”€â”€ [others]/           # More specs
â”‚
â”œâ”€â”€ honeycomb/              # ğŸ ALL LOGIC (plugin architecture)
â”‚   â”œâ”€â”€ dogfooding/         # âœ¨ Spec enforcement system (NEW!)
â”‚   â”‚   â”œâ”€â”€ watcher.gleam   # File monitoring
â”‚   â”‚   â”œâ”€â”€ scanner.gleam   # Violation detection
â”‚   â”‚   â”œâ”€â”€ autofix.gleam   # Auto-fixing
â”‚   â”‚   â”œâ”€â”€ hooks.gleam     # Git integration
â”‚   â”‚   â”œâ”€â”€ cli.gleam       # Command interface
â”‚   â”‚   â”œâ”€â”€ cli_test.gleam  # Integration tests
â”‚   â”‚   â””â”€â”€ README.md       # Usage guide
â”‚   â”œâ”€â”€ agent/              # Agent system + interaction patterns
â”‚   â”œâ”€â”€ ml/                 # ML/RL integration
â”‚   â”œâ”€â”€ language/           # Language Evolution
â”‚   â”‚   â”œâ”€â”€ evolution/v2/   # V2 syntax (70% reduction)
â”‚   â”‚   â”œâ”€â”€ evolution/v3/   # V3 syntax (80% reduction)
â”‚   â”‚   â”œâ”€â”€ evolution/v3.1/ # V3.1 syntax (890 lines saved)
â”‚   â”‚   â”œâ”€â”€ evolution/v3.2/ # V3.2 syntax (4,983 patterns)
â”‚   â”‚   â””â”€â”€ evolution/v4/   # V4 compiler
â”‚   â”œâ”€â”€ tools/              # Development Tools
â”‚   â”‚   â””â”€â”€ migrator_v5.gleam  # V4->V5 migration
â”‚   â”œâ”€â”€ telegram/           # Telegram bot
â”‚   â”œâ”€â”€ mcp/                # MCP tools (~100)
â”‚   â”œâ”€â”€ api/                # HTTP API
â”‚   â””â”€â”€ [others]/           # More plugins
â”‚
â”œâ”€â”€ docs/                   # ğŸ“š Documentation (20+ files)
â”‚   â”œâ”€â”€ academic/           # Academic papers âœ¨ NEW!
â”‚   â”‚   â”œâ”€â”€ VIBEE_FORMAL_SPECIFICATION.md
â”‚   â”‚   â”œâ”€â”€ VIBEE_LANGUAGE_STANDARD.md
â”‚   â”‚   â””â”€â”€ VIBEE_THEOREMS_AND_PROOFS.md
â”‚   â”œâ”€â”€ V4_FINAL_REPORT.md
â”‚   â”œâ”€â”€ V5_FINAL_REPORT.md
â”‚   â”œâ”€â”€ PARALLEL_ML_RL_FINAL_REPORT.md
â”‚   â”œâ”€â”€ V3.1_MIGRATION_REPORT.md
â”‚   â”œâ”€â”€ V3.2_PHASE1_REPORT.md
â”‚   â”œâ”€â”€ V3.2_PHASE2_REPORT.md
â”‚   â””â”€â”€ [others]/
â”‚
â”œâ”€â”€ scripts/                # ğŸ› ï¸ Automation
â”‚   â”œâ”€â”€ setup-dogfooding.sh # Install dogfooding âœ¨ NEW!
â”‚   â””â”€â”€ [others]/
â”‚
â”œâ”€â”€ README.md               # Project overview (UPDATED)
â”œâ”€â”€ AGENTS.md               # AI agents guide (UPDATED)
â”œâ”€â”€ CLAUDE.md               # Claude-specific context (UPDATED)
â”œâ”€â”€ .ona-rules.md           # This file (UPDATED)
â”œâ”€â”€ DOGFOODING_IMPLEMENTATION.md  # Dogfooding guide âœ¨ NEW!
â””â”€â”€ vibee_gen.sh            # Code generator
```

**CRITICAL**: 
- âŒ NO code in gleam/src/ except entry points and FFI
- âœ… ALL logic in honeycomb/ plugins
- âœ… gleam/test/ removed - tests in honeycomb/
- ğŸ›¡ï¸ **DOGFOODING ENFORCED**: Git hooks block manual code
- âœ… Scanner detects violations automatically
- âœ… Auto-fix regenerates code from specs
- âœ… Pre-commit and pre-push hooks active

---

## ğŸ VIBEE Language Syntax (V3 - Ultra-Concise)

### Version History
- **V1**: Original verbose syntax (310,965 lines)
- **V2**: 70% reduction (93,290 lines) 
- **V3**: 80% reduction (62,193 lines) âœ… CURRENT

### File Extensions

| Location | Extension | Syntax | Example |
|----------|-----------|--------|---------|
| `honeycomb/` | `.vibee` | VIBEE V3 | `menu.vibee` |
| `gleam/` | `.gleam` | Gleam | `main.gleam` |
| Tests in honeycomb | `.vibee` | VIBEE V3 | `menu_test.vibee` |

**ğŸš« ANTI-PATTERN**: `.gleam` files in `honeycomb/` are **FORBIDDEN**!

### V3 Ultra-Concise Syntax

**Function Stubs (95% reduction):**
```vibee
// V1 (9 lines)
// example.vibee
// Generated from spec.yml
// TODO: Implement example
pub fn example() â†’ Result(String, String) {
  Error("Not implemented")
}

// V3 (1 line)
pub example: Result<String, String> = !impl
```

**Test Stubs (93% reduction):**
```vibee
// V1 (16 lines)
import gleeunit
import gleeunit/should
import example
pub fn main() { gleeunit.main() }
pub fn example_test() {
  1 + 1 |> should.equal(2)
}

// V3 (1 line)
test example { !impl }
```

**Smart Imports (100% reduction):**
```vibee
# V1
import gleeunit
import gleeunit/should
import example

# V3.1 - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ÑÑ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ‚Ğ¾Ñ€Ğ¾Ğ¼!
# ĞĞµ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ²Ğ¾Ğ¾Ğ±Ñ‰Ğµ!
```

### V3.1 New Features (2026-01-10)

**1. Auto-Import Common Modules** âœ…
```vibee
# No imports needed for:
# gleeunit, should, json, list, string, io, result, option
```

**2. Test File Auto-Setup** âœ…
```vibee
# V1 (7 lines)
import gleeunit
import gleeunit/should

pub fn main() {
  gleeunit.main()
}

test my_test {
  1 + 1 |> should.equal(2)
}

# V3.1 (1 line)
test my_test {
  1 + 1 == 2
}
```

**3. Smart Assertions** âœ…
```vibee
# V1
result |> should.equal(expected)
result |> should.be_ok

# V3.1
result == expected
result?
```

**4. String Interpolation** âœ…
```vibee
# V1
"Error: " <> message <> " at " <> location

# V3.1
"Error: {message} at {location}"
```

**5. Extended Lambda Shortcuts** âœ…
```vibee
# V1
list.fold(0, fn(acc, x) { acc + x })

# V3.1
list.fold(0, _1 + _2)
```

**Migration Results**:
- Files modified: 321
- Lines saved: 890
- Time savings: ~520 hours/year (team of 10)
- Cost savings: ~$26,000/year

### Core Operators

| Feature | Gleam | VIBEE | Example |
|---------|-------|-------|---------|
| Pipe | `\|>` | `Â·` | `data Â· process` |
| Arrow | `->` | `â†’` | `fn() â†’ str` |
| None | `None` | `âˆ…` | `case âˆ… â†’ default` |
| Required | `field: Type` | `field: Type!` | `id: int!` |
| Optional | `Option(Type)` | `Type?` | `email: str?` |

### Advanced Operators

```vibee
// Tap operator (side effects)
data |>> transform() |>> tap(io.debug) |> next_step()

// Conditional pipe (short-circuit on Error/None)
user_id |>? find_user() |>? get_profile() |>? format_data()

// Indexed pipe (map with index)
items |>@ fn(item, idx) { format(item, idx) }

// Elvis operator (default values)
name ?: "Unknown"

// Optional chaining (safe navigation)
user?.profile?.avatar?.url

// Try operator (unwrap or return)
let user = get_user(id)?

// Operator sections (partial application)
list.filter(numbers, (> 0))
list.map(prices, (* 2))
```

### Type System

```vibee
// Struct with required/optional fields
struct User:
  id: int!           // Required
  name: str!         // Required
  email: str?        // Optional
  age: int?          // Optional

// Enum with decorator
@enum
type Status:
  Active
  Inactive
  Pending

// Smart constructor (validated)
@smart_constructor(validate: validate_email)
type Email: Email(value: str)
```

### String Interpolation

```vibee
let msg = "Hello, {name}!"
let msg = "Found {count + 1} items"
let msg = "User: {user.name Â· string.uppercase}"
```

### Pattern Matching

```vibee
// Guard clauses
guard b != 0 else: return Error("Division by zero")

// Pattern guards
case value:
  x if x > 100 â†’ "High"
  x if x > 50 â†’ "Medium"
  _ â†’ "Low"

// With statement (multiple bindings)
with user <- get_user(id),
     validated <- validate(user),
     saved <- save(validated):
  Ok(saved)
```

### List Comprehensions

```vibee
[x * 2 | x <- numbers, x > 0]
[(x, y) | x <- [1, 2, 3], y <- [4, 5, 6]]
```

### Decorators (52 built-in)

```vibee
// Error handling
@retry(3)
@timeout(5000)
@circuit_breaker
@fallback(default_value)

// Performance
@cache(ttl: 3600)
@inline
@hot_path
@simd
@gpu

// AI/ML
@llm(model: "gpt-4")
@sql(query: "SELECT * FROM users")

// Development
@test
@benchmark
@deprecated
@log(level: info)
@trace
@metric

// Type system
@derive(Json, Eq, Ord)
@opaque
@builder
```

### Extension Methods (55+)

```vibee
"hello".capitalize()
[1, 2, 3].first()
5.is_even()
"test@example.com".is_valid_email()
```

---

## ğŸ¯ Honeycomb Plugin System

### Plugin Structure

Every plugin MUST have this structure:

```
honeycomb/category/plugin_name/
â”œâ”€â”€ spec.yml           # REQUIRED - Test specification (KILLER FEATURE!)
â”œâ”€â”€ manifest.json      # REQUIRED - Plugin metadata
â”œâ”€â”€ README.md          # REQUIRED - Documentation
â”œâ”€â”€ src/              # Generated from spec.yml
â”‚   â””â”€â”€ plugin_name.gleam or .vibee
â”œâ”€â”€ test/             # Generated from spec.yml
â”‚   â””â”€â”€ plugin_name_test.gleam
â””â”€â”€ docs/             # Optional - Additional docs
```

**âš ï¸ CRITICAL: spec.yml is MANDATORY**

Without `spec.yml`, the compiler **WILL NOT BUILD** the plugin!

This is a **killer feature** of VIBEE that ensures:
- âœ… Test-driven development by default
- âœ… 100% test coverage requirement
- âœ… Automatic test generation from specifications
- âœ… Boilerplate code generation
- âœ… Plugin completeness validation

**Philosophy**: "No spec.yml = No build"

### spec.yml Format (MANDATORY)

**ğŸ¯ PRINCIPLE #1: Given-When-Then**

Every behavior in spec.yml MUST follow **Given-When-Then** format:
- **GIVEN**: Preconditions (initial state)
- **WHEN**: Actions (what happens)
- **THEN**: Expected outcomes (results)

This is the **CORE** of VIBEE testing philosophy - making tests clear, readable, and self-documenting.

```yaml
# Plugin specification - REQUIRED for build
plugin:
  name: plugin_name
  version: 1.0.0
  category: utils
  description: Brief description

# Behaviors (Given-When-Then format)
behaviors:
  - name: behavior_name
    description: What this behavior does
    given: Initial state or preconditions  # GIVEN
    when: Action or trigger                # WHEN
    then: Expected outcome                 # THEN
    examples:
      - input: test_data
        output: expected_result

# Functions to implement (generates tests and signatures)
functions:
  - name: function_name
    signature: "function_name(param: Type) -> Result(Output, Error)"
    description: What this function does
    params:
      - name: param
        type: Type
        description: Parameter description
        constraints:
          - not_empty
          - min_length: 3
    returns:
      type: Result(Output, Error)
      description: Return value description
    examples:
      - params: {param: "value"}
        returns: Ok(result)
      - params: {param: ""}
        returns: Error("validation failed")
    properties:
      pure: true              # No side effects
      idempotent: false       # Same input = same output
    error_cases:
      - condition: param is empty
        error: "param cannot be empty"

# Properties to verify (generates property tests)
properties:
  - name: property_name
    description: Property description
    forall: "x: Int, y: Int"
    property: "add(x, y) == add(y, x)"

# Completeness criteria (enforced by compiler)
completeness:
  test_coverage: 100%
  all_functions_implemented: true
  all_properties_verified: true
```

**See**: `honeycomb/SPEC_YML_FORMAT.md` for complete specification

### Manifest.json Format

```json
{
  "name": "plugin_name",
  "version": "1.0.0",
  "category": "core|ai|ml|web|integration|utils",
  "description": "Plugin description (10-200 chars)",
  "author": "Author Name",
  "license": "MIT",
  "dependencies": [
    "category/plugin_name",
    "other/plugin@1.0.0"
  ],
  "exports": [
    "function_name(params) -> ReturnType"
  ],
  "commands": [
    {
      "name": "namespace.command",
      "params": ["param: Type"]
    }
  ],
  "events": {
    "emits": ["event.name"],
    "listens": ["event.to.handle"]
  }
}
```

### Plugin Categories (Hierarchical)

| Category | Level | Description | Dependencies |
|----------|-------|-------------|--------------|
| **core** | 0 | Foundational system | None |
| **utils** | 1 | Utilities | core |
| **web** | 2 | Web services | core, utils |
| **integration** | 2 | External services | core, utils |
| **ai** | 3 | AI capabilities | core, utils, web |
| **ml** | 3 | Machine learning | core, utils |

**Dependency Rules:**
- Lower levels can depend on higher levels (not vice versa)
- Core (0) â† Utils (1) â† Web/Integration (2) â† AI/ML (3)
- Circular dependencies are forbidden

### Plugin Development Pattern

```gleam
// Using Plugin API
import honeycomb/core/plugin_api

pub fn create_plugin() {
  plugin_api.new(
    "my_plugin",
    "1.0.0",
    "utils",
    "Description",
    init,
    execute,
    cleanup
  )
  |> plugin_api.with_dependencies(["core/state"])
  |> plugin_api.with_author("VIBEE Team")
  |> plugin_api.with_license("MIT")
}

fn init() -> Result(State, String) {
  Ok(State(...))
}

fn execute(state: State, input: Input) -> Result(Output, String) {
  // Plugin logic
  Ok(output)
}

fn cleanup(state: State) -> Nil {
  // Cleanup resources
  Nil
}
```

### Cell Pattern (VIBEE-specific)

```vibee
@cell
module ExampleCell:
  @provides("example.hello")
  
  @on_build
  fn build(ctx): Result<Nil, Error>:
    ctx.logger.info("Building ExampleCell")
    Ok(Nil)
  
  @on_activate
  fn activate() -> Result<Nil, Error>:
    Ok(Nil)
  
  @command("example.hello")
  fn hello(args): Result<Nil, Error>:
    println("Hello from ExampleCell!")
    Ok(Nil)
  
  @on_nectar(NectarType.UserInput)
  fn handle_input(nectar): Nil:
    println("Received input: " <> nectar.payload)
```

### Plugin Interaction Patterns

#### 1. Event Bus (Pub/Sub)

```gleam
// Publish event
event_bus.publish(Event(
  type: message_sent,
  source: "telegram",
  target: None,  // broadcast
  payload: {...}
))

// Subscribe to events
event_bus.subscribe("my_plugin", handler, [message_sent, error_occurred])
```

#### 2. Direct API Calls

```gleam
// Plugin exports functions
import honeycomb/utils/hello_world
hello_world.greet("Alice")
```

#### 3. Command Pattern

```gleam
// Execute command
command_router.execute("telegram.send", [chat_id, text])
```

### Plugin Validation Rules

**Name**: 
- Lowercase snake_case
- Pattern: `^[a-z][a-z0-9_]*$`

**Version**: 
- Semantic versioning
- Pattern: `^\d+\.\d+\.\d+$`

**Category**: 
- Must be one of: core, ai, ml, web, integration, utils

**Dependencies**:
- Format: `category/plugin_name` or `category/plugin_name@version`
- No circular dependencies
- Must respect category hierarchy

**Description**:
- Length: 10-200 characters
- Clear and concise

---

## ğŸ¯ Development Patterns

### 1. Plugin Development Workflow (with spec.yml)

```bash
# 1. Create plugin structure
mkdir -p honeycomb/category/plugin_name

# 2. Create spec.yml (MANDATORY - FIRST!)
cat > honeycomb/category/plugin_name/spec.yml << EOF
plugin:
  name: plugin_name
  version: 1.0.0
  category: utils
  description: Plugin description

functions:
  - name: process
    signature: "process(data: String) -> Result(String, String)"
    description: Process data
    params:
      - name: data
        type: String
        description: Data to process
    returns:
      type: Result(String, String)
      description: Processed data
    examples:
      - params: {data: "test"}
        returns: Ok("processed: test")

completeness:
  test_coverage: 100%
  all_functions_implemented: true
EOF

# 3. Generate boilerplate from spec.yml
vibee generate honeycomb/category/plugin_name

# Output:
# âœ… Generated src/plugin_name.gleam
# âœ… Generated test/plugin_name_test.gleam
# âœ… Generated manifest.json
# âœ… Generated README.md

# 4. Implement functions (replace TODOs)
# Edit src/plugin_name.gleam

# 5. Run tests (must pass 100%)
cd gleam && gleam test

# Output:
# âŒ 0/3 tests passing (0%)
# Plugin cannot be built until all tests pass

# 6. Fix implementation until 100%
# Edit src/plugin_name.gleam

# 7. Run tests again
gleam test

# Output:
# âœ… 3/3 tests passing (100%)
# Plugin ready to build

# 8. Build plugin (only works with 100% tests)
gleam build

# Output:
# âœ… Plugin built successfully
```

**Key Points**:
- spec.yml is created FIRST (before any code)
- Boilerplate is generated from spec.yml
- Tests are generated from examples in spec.yml
- Plugin won't build until tests pass at 100%
- This enforces test-driven development

### 2. Error Handling Pattern

```vibee
// Use Result type for all fallible operations
pub fn process(data: Data) -> Result(Output, Error):
  use validated <- validate(data) |> result.try
  use transformed <- transform(validated) |> result.try
  use saved <- save(transformed) |> result.try
  Ok(saved)

// Or with try operator
pub fn process(data: Data) -> Result(Output, Error):
  let validated = validate(data)?
  let transformed = transform(validated)?
  let saved = save(transformed)?
  Ok(saved)
```

### 3. Testing Pattern

```gleam
import gleeunit
import gleeunit/should

pub fn main() {
  gleeunit.main()
}

pub fn plugin_test() {
  let result = my_plugin.execute(input)
  result
  |> should.be_ok
  |> should.equal(expected_output)
}
```

### 4. Documentation Pattern

```markdown
# Plugin Name

## Description
Brief description of what the plugin does.

## Installation
```gleam
import honeycomb/category/plugin_name
```

## Usage
```gleam
let result = plugin_name.function(args)
```

## API Reference
- `function(args) -> Result` - Description

## Dependencies
- core/state
- utils/logging

## Examples
See `test/` directory for examples.
```

---

## ğŸš€ Deployment Rules

### When to Deploy

**ALWAYS deploy automatically when:**
1. User explicitly asks to deploy ("Ğ´ĞµĞ¿Ğ»Ğ¾Ğ¹", "deploy", "Ğ·Ğ°Ğ´ĞµĞ¿Ğ»Ğ¾Ğ¹")
2. User says changes don't work on production
3. User provides deployment credentials (tokens, keys)
4. Code changes are committed and pushed to main branch
5. User confirms "Ğ´Ğ°Ğ²Ğ°Ğ¹" or "go ahead" after deployment preparation

**NEVER ask for permission to deploy when:**
- User has already provided FLY_API_TOKEN
- User says "Ğ½Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚" about production URL
- User explicitly requested deployment

### Deployment Process

```bash
# 1. Check for credentials
env | grep FLY_API_TOKEN

# 2. If token available, deploy immediately
export FLY_API_TOKEN="token_value"
cd /workspaces/vibee-lang
/home/vscode/.fly/bin/flyctl deploy --config fly.toml --remote-only

# 3. After deployment, verify
curl https://vibee-mcp.fly.dev/health
curl -I https://vibee-mcp.fly.dev/dashboard/agent
```

### Deployment Checklist

- [ ] Code committed and pushed to main
- [ ] FLY_API_TOKEN available or requested
- [ ] Run deployment command
- [ ] Wait for completion (3-5 minutes)
- [ ] Verify endpoints work

---

## ğŸ“ Code Style Rules

### VIBEE Language

1. **Use VIBEE syntax** for new code:
   - `Â·` instead of `|>`
   - `â†’` instead of `->`
   - `âˆ…` instead of `None`
   - `Type!` for required, `Type?` for optional

2. **Use decorators** for cross-cutting concerns:
   ```vibee
   @cache(ttl: 3600)
   @log(level: info)
   @retry(3)
   pub fn expensive_operation(data: Data) -> Result
   ```

3. **Use string interpolation**:
   ```vibee
   let msg = "Hello, {name}!"
   ```

4. **Use list comprehensions**:
   ```vibee
   [x * 2 | x <- numbers, x > 0]
   ```

5. **Use guard clauses**:
   ```vibee
   guard b != 0 else: return Error("Division by zero")
   ```

### Gleam Code (FFI only)

1. **Follow Gleam conventions** for FFI code
2. **Keep FFI minimal** - only for Erlang interop
3. **Document FFI functions** thoroughly

### Plugin Code

1. **One plugin = one responsibility**
2. **Explicit dependencies** in manifest.json
3. **Comprehensive tests** for all exports
4. **Clear documentation** in README.md
5. **Semantic versioning** for releases

---

## ğŸ” Testing Rules

### Test Coverage Requirements

- **Minimum 80%** code coverage for plugins
- **All exports** must have tests
- **Edge cases** must be tested
- **Error paths** must be tested

### Test Structure

```gleam
// test/plugin_name_test.gleam
import gleeunit
import gleeunit/should
import honeycomb/category/plugin_name

pub fn main() {
  gleeunit.main()
}

// Happy path tests
pub fn success_case_test() {
  let result = plugin_name.function(valid_input)
  result |> should.be_ok
}

// Error path tests
pub fn error_case_test() {
  let result = plugin_name.function(invalid_input)
  result |> should.be_error
}

// Edge case tests
pub fn edge_case_test() {
  let result = plugin_name.function(edge_input)
  result |> should.equal(expected)
}
```

---

## ğŸ› Debugging Rules

### Logging

```vibee
@log(level: debug, params: true, result: true)
pub fn debug_function(data: Data) -> Result:
  // Automatically logs params and result
  process(data)
```

### Error Messages

- **Be specific**: Include context and values
- **Be actionable**: Suggest fixes
- **Be consistent**: Use standard error types

```vibee
Error("Invalid email: {email}. Expected format: user@domain.com")
```

---

## ğŸ“š Documentation Rules

### Required Documentation

1. **README.md** in every plugin:
   - Description
   - Installation
   - Usage examples
   - API reference
   - Dependencies

2. **Inline comments** for complex logic:
   ```vibee
   // Calculate Fibonacci using memoization for O(n) performance
   fn fib(n: int) -> int
   ```

3. **Function documentation**:
   ```vibee
   /// Validates email address format
   /// 
   /// # Arguments
   /// * `email` - Email string to validate
   /// 
   /// # Returns
   /// * `Ok(email)` if valid
   /// * `Error(msg)` if invalid
   pub fn validate_email(email: str) -> Result(str, str)
   ```

---

## ğŸ”„ Migration Rules

### Gleam â†’ VIBEE Migration

1. **Use auto-evolution**:
   ```bash
   vibee evolve src/my_module.gleam
   ```

2. **Manual migration checklist**:
   - [ ] Replace `|>` with `Â·`
   - [ ] Replace `->` with `â†’`
   - [ ] Replace `None` with `âˆ…`
   - [ ] Add `!` to required fields
   - [ ] Add `?` to optional fields
   - [ ] Use string interpolation
   - [ ] Add decorators where appropriate

3. **Test after migration**:
   ```bash
   gleam test
   ```

---

## ğŸ¯ Best Practices

### DO âœ…

- **Create spec.yml FIRST** before any code
- Use VIBEE syntax for new code
- Create plugins for new functionality
- Generate boilerplate from spec.yml
- Write comprehensive examples in spec.yml
- Ensure 100% test coverage (enforced)
- Document all public APIs
- Use decorators for cross-cutting concerns
- Follow category hierarchy for dependencies
- Validate plugins before committing
- Use event bus for loose coupling
- Use semantic versioning

### DON'T âŒ

- **Start coding without spec.yml** (plugin won't build!)
- Add logic to gleam/src/ (only entry points + FFI)
- Create circular dependencies
- Skip tests (compiler enforces 100% coverage)
- Commit with failing tests
- Use Gleam syntax in new VIBEE code
- Violate category hierarchy
- Commit without validation
- Use global state (use plugin state)
- Hardcode configuration (use manifest.json)
- Try to build with <100% test coverage

---

## ğŸ”— Related Documentation

- **[AGENTS.md](AGENTS.md)** - Agent development guide
- **[CLAUDE.md](CLAUDE.md)** - AI assistant context
- **[README.md](README.md)** - Project overview
- **[docs/](docs/)** - Detailed documentation
- **[DEAD_CODE_RECOMMENDATIONS.md](DEAD_CODE_RECOMMENDATIONS.md)** - Cleanup guide

---

## ğŸš€ V4 & V5 Development Guidelines

### V4 Compiler (Rust)

**Location**: `honeycomb/language/evolution/v4/`

**Components**:
- `incremental.rs` - Incremental compilation (10-100x faster)
- `parallel.rs` - Parallel compilation (all CPU cores)
- `tests.rs` - 200+ comprehensive tests
- `benchmarks.rs` - Performance validation

**Best Practices**:
- Use Rayon for data parallelism
- Cache ASTs and type info
- Track file dependencies
- Validate cache on compiler version change
- Profile with cargo flamegraph

### Parallel Computing & ML/RL

**Location**: `honeycomb/ml/`, `honeycomb/agent/`

**Key Files**:
- `ml/integration.gleam` - ML/RL integration
- `agent/interaction.gleam` - Agent patterns
- `spec.parallel.vibee` - Unified API

**Best Practices**:
- Use unified API for parallelism
- Choose right paradigm (CPU/GPU/Actor)
- Profile before optimizing
- Use async/await for I/O
- Implement fault tolerance

### V5 Syntax

**Location**: `spec.v5.vibee`, `honeycomb/tools/migrator_v5.gleam`

**Key Features**:
- Smart type inference (no annotations)
- Auto-import stdlib (no imports)
- Concise error handling (`result ? handler : fallback`)
- Compact types (single-line)
- Async/await, macros, operator overloading

**Migration**:
- Use `migrator_v5.gleam` for automatic migration
- Test thoroughly after migration
- Validate type safety maintained
- Benchmark performance

## ğŸš€ Zig Migration Guide

### Why Zig?

Bootstrap evolution selected Zig as optimal target:
- **2.5x faster compilation** than Rust (800ms vs 2000ms)
- **Smallest binaries** (800KB vs 1000KB Rust, 3000KB Go)
- **Lowest memory** (8MB vs 10MB Rust, 30MB Go)
- **Best overall balance** (86.0 score, +16.8% improvement)

### Zig Code Generation

**Location**: `vibeec/src/vibeec_codegen_zig.gleam`

**Type Mappings**:
| VIBEE Type | Zig Type |
|------------|----------|
| IntType | i32 |
| FloatType | f64 |
| StringType | []const u8 |
| BoolType | bool |
| ListType(T) | []T |
| CustomType(name) | name |

**Example**:
```zig
// Generated from VIBEE AST
pub fn add(a: i32, b: i32) i32 {
    return a + b;
}

pub fn greet(name: []const u8) []const u8 {
    return "Hello " ++ name;
}
```

### Optimal Compiler Flags

**From Evolutionary Selection**:
```bash
zig build-exe main.zig \
  -O ReleaseFast \
  -finline-small-functions \
  -funroll-loops \
  -fvectorize
```

**Explanation**:
- `-O ReleaseFast`: O2 optimization (best balance)
- `-finline-small-functions`: Reduce function call overhead (+2.0 fitness)
- `-funroll-loops`: Reduce loop overhead (+3.0 fitness)
- `-fvectorize`: Enable SIMD vectorization (+4.0 fitness)

### Migration Strategy

**Phase 1: New Code (Immediate)**
- All new plugins â†’ Zig
- All new MCP tools â†’ Zig
- All new tests â†’ Zig

**Phase 2: Core Migration (Next)**
- Migrate vibeec compiler â†’ Zig
- Migrate honeycomb/agent â†’ Zig
- Migrate honeycomb/ml â†’ Zig

**Phase 3: Full Migration (Future)**
- Migrate all honeycomb/ â†’ Zig
- Keep only Erlang FFI for BEAM
- Self-host compiler in Zig

### Zig Best Practices

**Memory Management**:
```zig
// Use allocators explicitly
const allocator = std.heap.page_allocator;
var list = std.ArrayList(i32).init(allocator);
defer list.deinit();
```

**Error Handling**:
```zig
// Use error unions
pub fn divide(a: i32, b: i32) !i32 {
    if (b == 0) return error.DivisionByZero;
    return @divTrunc(a, b);
}
```

**Comptime**:
```zig
// Compile-time execution
fn fibonacci(comptime n: u32) u32 {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

### Testing in Zig

```zig
const std = @import("std");
const testing = std.testing;

test "add function" {
    try testing.expectEqual(@as(i32, 5), add(2, 3));
}

test "divide by zero" {
    try testing.expectError(error.DivisionByZero, divide(10, 0));
}
```

### Integration with BEAM

**Keep Erlang FFI**:
```erlang
% vibeec_zig_ffi.erl
-module(vibeec_zig_ffi).
-export([call_zig/2]).

call_zig(Function, Args) ->
    % Call Zig via NIF
    erlang:nif_call(Function, Args).
```

**Zig NIF**:
```zig
export fn add_nif(env: ?*c.ErlNifEnv, argc: c_int, argv: [*c]const c.ERL_NIF_TERM) c.ERL_NIF_TERM {
    // NIF implementation
}
```

### Resources

**Documentation**:
- `vibeec/BOOTSTRAP_COMPLETE_REPORT.md` - Full bootstrap analysis
- `vibeec/EVOLUTION_REPORT.md` - Evolutionary selection details
- `vibeec/BOOTSTRAP_PIPELINE_REPORT.md` - Pipeline architecture

**Code**:
- `vibeec/src/vibeec_codegen_zig.gleam` - Zig code generator
- `vibeec/src/vibeec_bootstrap.gleam` - Bootstrap pipeline
- `vibeec/src/vibeec_evolution.gleam` - Evolutionary selection

**Tests**:
- `vibeec/test/vibeec_codegen_test.gleam` - Codegen tests
- `vibeec/test/vibeec_bootstrap_test.gleam` - Bootstrap tests
- `vibeec/test/vibeec_evolution_test.gleam` - Evolution tests

---

**Last Updated**: 2026-01-11
**Version**: Bootstrap 1.0
**Status**: Zig Migration Active
**Target**: Zig (86.0 score, +16.8% improvement)
