// =============================================================================
// Vibee OS â€” Notification Center Module
// Centralized notification management and distribution system
// =============================================================================

use json.{JsonValue, Serialize, Deserialize}
use datetime.{DateTime, Duration}

// =============================================================================
// Notification Types & Enums
// =============================================================================

enum NotificationType {
    Alert,
    Banner,
    Badge,
    Sound,
    Silent,
    Critical,
    Provisional
    
    fn requires_permission() -> Bool {
        match self {
            .Critical => true,
            .Provisional => false,
            _ => true
        }
    }
    
    fn is_visible() -> Bool {
        match self {
            .Silent | .Badge => false,
            _ => true
        }
    }
}

enum NotificationCategory {
    System,
    Social,
    Message,
    Email,
    Calendar,
    Reminder,
    News,
    Promo,
    Transaction,
    Update,
    Custom(String)
    
    fn default_priority() -> NotificationPriority {
        match self {
            .System | .Transaction => NotificationPriority.High,
            .Message | .Email => NotificationPriority.Normal,
            .Promo | .News => NotificationPriority.Low,
            _ => NotificationPriority.Normal
        }
    }
}

enum NotificationPriority {
    Min,
    Low,
    Normal,
    High,
    Max,
    Critical
    
    fn to_int() -> Int {
        match self {
            .Min => 0,
            .Low => 1,
            .Normal => 2,
            .High => 3,
            .Max => 4,
            .Critical => 5
        }
    }
}

enum NotificationStatus {
    Pending,
    Delivered,
    Displayed,
    Interacted,
    Dismissed,
    Expired,
    Failed(String)
}

enum DeliveryChannel {
    InApp,
    Push,
    Email,
    SMS,
    WebSocket,
    All
}

// =============================================================================
// Core Notification Struct
// =============================================================================

struct Notification {
    id: String
    title: String
    body: String
    subtitle: Option<String>
    icon: Option<String>
    image: Option<String>
    category: NotificationCategory
    priority: NotificationPriority
    notification_type: NotificationType
    status: NotificationStatus
    data: Map<String, JsonValue>
    actions: [NotificationActionItem]
    group_id: Option<String>
    thread_id: Option<String>
    channel: DeliveryChannel
    sender_id: Option<String>
    recipient_id: String
    created_at: DateTime
    scheduled_at: Option<DateTime>
    delivered_at: Option<DateTime>
    expires_at: Option<DateTime>
    read_at: Option<DateTime>
    metadata: NotificationMetadata
}

impl Notification {
    fn new(recipient_id: String, title: String, body: String) -> Self {
        Notification {
            id: UUID.v4(),
            title: title,
            body: body,
            subtitle: None,
            icon: None,
            image: None,
            category: NotificationCategory.System,
            priority: NotificationPriority.Normal,
            notification_type: NotificationType.Banner,
            status: NotificationStatus.Pending,
            data: Map.empty(),
            actions: [],
            group_id: None,
            thread_id: None,
            channel: DeliveryChannel.InApp,
            sender_id: None,
            recipient_id: recipient_id,
            created_at: DateTime.now(),
            scheduled_at: None,
            delivered_at: None,
            expires_at: None,
            read_at: None,
            metadata: NotificationMetadata.default()
        }
    }
    
    fn subtitle(text: String) -> Self { self.subtitle = Some(text); self }
    fn icon(url: String) -> Self { self.icon = Some(url); self }
    fn image(url: String) -> Self { self.image = Some(url); self }
    fn category(cat: NotificationCategory) -> Self { self.category = cat; self }
    fn priority(p: NotificationPriority) -> Self { self.priority = p; self }
    fn notification_type(t: NotificationType) -> Self { self.notification_type = t; self }
    fn channel(ch: DeliveryChannel) -> Self { self.channel = ch; self }
    fn sender(id: String) -> Self { self.sender_id = Some(id); self }
    fn group(id: String) -> Self { self.group_id = Some(id); self }
    fn thread(id: String) -> Self { self.thread_id = Some(id); self }
    fn expires_in(duration: Duration) -> Self { self.expires_at = Some(DateTime.now().add(duration)); self }
    fn schedule_at(time: DateTime) -> Self { self.scheduled_at = Some(time); self }
    
    fn data(key: String, value: JsonValue) -> Self {
        self.data.set(key, value); self
    }
    
    fn add_action(action: NotificationActionItem) -> Self {
        self.actions.push(action); self
    }
    
    fn is_expired() -> Bool {
        match self.expires_at {
            Some(exp) => DateTime.now() > exp,
            None => false
        }
    }
    
    fn is_read() -> Bool { self.read_at.is_some() }
    fn is_delivered() -> Bool { self.delivered_at.is_some() }
    
    fn mark_delivered() -> Self {
        self.status = NotificationStatus.Delivered;
        self.delivered_at = Some(DateTime.now());
        self
    }
    
    fn mark_read() -> Self {
        self.status = NotificationStatus.Interacted;
        self.read_at = Some(DateTime.now());
        self
    }
    
    fn mark_dismissed() -> Self {
        self.status = NotificationStatus.Dismissed;
        self
    }
}

struct NotificationActionItem {
    id: String
    title: String
    icon: Option<String>
    destructive: Bool
    auth_required: Bool
    foreground: Bool
}

impl NotificationActionItem {
    fn new(id: String, title: String) -> Self {
        NotificationActionItem {
            id: id,
            title: title,
            icon: None,
            destructive: false,
            auth_required: false,
            foreground: true
        }
    }
    
    fn icon(url: String) -> Self { self.icon = Some(url); self }
    fn destructive() -> Self { self.destructive = true; self }
    fn auth_required() -> Self { self.auth_required = true; self }
    fn background() -> Self { self.foreground = false; self }
}

struct NotificationMetadata {
    source: String
    version: String
    platform: Option<String>
    locale: Option<String>
    tags: [String]
    custom: Map<String, String>
}

impl NotificationMetadata {
    fn default() -> Self {
        NotificationMetadata {
            source: "vibee-notification-center",
            version: "1.0.0",
            platform: None,
            locale: None,
            tags: [],
            custom: Map.empty()
        }
    }
    
    fn tag(t: String) -> Self { self.tags.push(t); self }
    fn platform(p: String) -> Self { self.platform = Some(p); self }
    fn locale(l: String) -> Self { self.locale = Some(l); self }
}

// =============================================================================
// Notification Center Actor
// =============================================================================

actor NotificationCenter {
    state notifications: Map<String, Notification>
    state user_notifications: Map<String, [String]>
    state group_notifications: Map<String, [String]>
    state handlers: [Box<dyn NotificationHandler>]
    state settings: NotificationCenterSettings
    state stats: NotificationStats
    
    fn new() -> Self {
        NotificationCenter {
            notifications: Map.empty(),
            user_notifications: Map.empty(),
            group_notifications: Map.empty(),
            handlers: [],
            settings: NotificationCenterSettings.default(),
            stats: NotificationStats.new()
        }
    }
    
    fn with_settings(settings: NotificationCenterSettings) -> Self {
        let mut center = NotificationCenter.new();
        center.settings = settings;
        center
    }
    
    on register_handler(handler: Box<dyn NotificationHandler>) {
        self.handlers.push(handler)
    }
    
    on post(notification: Notification) -> Result<String, NotificationError> {
        // Check if notifications are enabled for this category
        if !self.settings.is_category_enabled(notification.category.clone()) {
            return Err(NotificationError.CategoryDisabled(notification.category))
        }
        
        // Check rate limiting
        if self.is_rate_limited(notification.recipient_id.clone()) {
            return Err(NotificationError.RateLimited)
        }
        
        // Check if expired
        if notification.is_expired() {
            return Err(NotificationError.Expired)
        }
        
        let id = notification.id.clone();
        let recipient = notification.recipient_id.clone();
        let group = notification.group_id.clone();
        
        // Store notification
        self.notifications.set(id.clone(), notification.clone());
        
        // Index by user
        let mut user_notifs = self.user_notifications.get(recipient.clone()).unwrap_or([]);
        user_notifs.push(id.clone());
        self.user_notifications.set(recipient, user_notifs);
        
        // Index by group
        if let Some(gid) = group {
            let mut group_notifs = self.group_notifications.get(gid.clone()).unwrap_or([]);
            group_notifs.push(id.clone());
            self.group_notifications.set(gid, group_notifs);
        }
        
        // Update stats
        self.stats.total_posted += 1;
        
        // Dispatch to handlers
        for handler in self.handlers.iter() {
            handler.handle(notification.clone());
        }
        
        Ok(id)
    }
    
    on post_batch(notifications: [Notification]) -> BatchPostResult {
        let mut success = 0;
        let mut failed = 0;
        let mut results: [PostResult] = [];
        
        for notif in notifications {
            match self.post(notif.clone()) {
                Ok(id) => {
                    success += 1;
                    results.push(PostResult.success(id));
                },
                Err(e) => {
                    failed += 1;
                    results.push(PostResult.failure(notif.id, e));
                }
            }
        }
        
        BatchPostResult { results: results, success_count: success, failure_count: failed }
    }
    
    fn get(id: String) -> Option<Notification> {
        self.notifications.get(id)
    }
    
    fn get_for_user(user_id: String) -> [Notification] {
        self.user_notifications.get(user_id).unwrap_or([])
            .iter()
            .filter_map(|id| self.notifications.get(id.clone()))
            .collect()
    }
    
    fn get_unread_for_user(user_id: String) -> [Notification] {
        self.get_for_user(user_id)
            .iter()
            .filter(|n| !n.is_read())
            .collect()
    }
    
    fn get_by_group(group_id: String) -> [Notification] {
        self.group_notifications.get(group_id).unwrap_or([])
            .iter()
            .filter_map(|id| self.notifications.get(id.clone()))
            .collect()
    }
    
    fn count_unread(user_id: String) -> Int {
        self.get_unread_for_user(user_id).len()
    }
    
    on mark_read(id: String) -> Result<(), NotificationError> {
        match self.notifications.get_mut(id.clone()) {
            Some(notif) => {
                notif.mark_read();
                self.stats.total_read += 1;
                Ok(())
            },
            None => Err(NotificationError.NotFound(id))
        }
    }
    
    on mark_all_read(user_id: String) -> Int {
        let mut count = 0;
        for notif in self.get_unread_for_user(user_id) {
            if let Some(n) = self.notifications.get_mut(notif.id.clone()) {
                n.mark_read();
                count += 1;
            }
        }
        self.stats.total_read += count;
        count
    }
    
    on dismiss(id: String) -> Result<(), NotificationError> {
        match self.notifications.get_mut(id.clone()) {
            Some(notif) => {
                notif.mark_dismissed();
                self.stats.total_dismissed += 1;
                Ok(())
            },
            None => Err(NotificationError.NotFound(id))
        }
    }
    
    on dismiss_all(user_id: String) -> Int {
        let mut count = 0;
        for notif in self.get_for_user(user_id) {
            if let Some(n) = self.notifications.get_mut(notif.id.clone()) {
                n.mark_dismissed();
                count += 1;
            }
        }
        self.stats.total_dismissed += count;
        count
    }
    
    on delete(id: String) -> Result<(), NotificationError> {
        match self.notifications.remove(id.clone()) {
            Some(notif) => {
                // Remove from user index
                if let Some(user_notifs) = self.user_notifications.get_mut(notif.recipient_id.clone()) {
                    user_notifs.retain(|nid| *nid != id);
                }
                // Remove from group index
                if let Some(gid) = notif.group_id {
                    if let Some(group_notifs) = self.group_notifications.get_mut(gid) {
                        group_notifs.retain(|nid| *nid != id);
                    }
                }
                Ok(())
            },
            None => Err(NotificationError.NotFound(id))
        }
    }
    
    on clear_expired() -> Int {
        let mut removed = 0;
        let expired_ids: [String] = self.notifications.iter()
            .filter(|(_, n)| n.is_expired())
            .map(|(id, _)| id.clone())
            .collect();
        
        for id in expired_ids {
            if self.delete(id).is_ok() {
                removed += 1;
            }
        }
        removed
    }
    
    fn query(q: NotificationQuery) -> [Notification] {
        let mut results: [Notification] = self.notifications.values().collect();
        
        if let Some(user_id) = q.user_id {
            results = results.iter().filter(|n| n.recipient_id == user_id).collect();
        }
        
        if let Some(category) = q.category {
            results = results.iter().filter(|n| n.category == category).collect();
        }
        
        if let Some(priority) = q.min_priority {
            results = results.iter().filter(|n| n.priority.to_int() >= priority.to_int()).collect();
        }
        
        if q.unread_only {
            results = results.iter().filter(|n| !n.is_read()).collect();
        }
        
        if let Some(since) = q.since {
            results = results.iter().filter(|n| n.created_at >= since).collect();
        }
        
        // Sort by priority and created_at
        results.sort_by(|a, b| {
            let priority_cmp = b.priority.to_int().cmp(a.priority.to_int());
            if priority_cmp != 0 { priority_cmp } else { b.created_at.cmp(a.created_at) }
        });
        
        // Apply limit
        if let Some(limit) = q.limit {
            results = results.iter().take(limit).collect();
        }
        
        results
    }
    
    fn stats() -> NotificationStats { self.stats.clone() }
    
    fn is_rate_limited(user_id: String) -> Bool {
        if !self.settings.rate_limiting_enabled { return false }
        
        let recent = self.get_for_user(user_id)
            .iter()
            .filter(|n| n.created_at > DateTime.now().subtract(self.settings.rate_limit_window))
            .count();
        
        recent >= self.settings.rate_limit_max
    }
}

// =============================================================================
// Notification Query
// =============================================================================

struct NotificationQuery {
    user_id: Option<String>
    category: Option<NotificationCategory>
    min_priority: Option<NotificationPriority>
    unread_only: Bool
    since: Option<DateTime>
    limit: Option<Int>
}

impl NotificationQuery {
    fn new() -> Self {
        NotificationQuery {
            user_id: None,
            category: None,
            min_priority: None,
            unread_only: false,
            since: None,
            limit: None
        }
    }
    
    fn for_user(id: String) -> Self { self.user_id = Some(id); self }
    fn category(cat: NotificationCategory) -> Self { self.category = Some(cat); self }
    fn min_priority(p: NotificationPriority) -> Self { self.min_priority = Some(p); self }
    fn unread_only() -> Self { self.unread_only = true; self }
    fn since(dt: DateTime) -> Self { self.since = Some(dt); self }
    fn limit(n: Int) -> Self { self.limit = Some(n); self }
}

// =============================================================================
// Notification Handler Trait
// =============================================================================

trait NotificationHandler {
    fn name() -> String
    fn handle(notification: Notification) -> Result<(), NotificationError>
    fn supports_channel(channel: DeliveryChannel) -> Bool
}

// =============================================================================
// Settings
// =============================================================================

struct NotificationCenterSettings {
    enabled: Bool
    max_notifications_per_user: Int
    auto_expire_after: Duration
    rate_limiting_enabled: Bool
    rate_limit_window: Duration
    rate_limit_max: Int
    disabled_categories: [NotificationCategory]
    quiet_hours: Option<QuietHours>
}

impl NotificationCenterSettings {
    fn default() -> Self {
        NotificationCenterSettings {
            enabled: true,
            max_notifications_per_user: 1000,
            auto_expire_after: Duration.from_days(30),
            rate_limiting_enabled: true,
            rate_limit_window: Duration.from_minutes(1),
            rate_limit_max: 10,
            disabled_categories: [],
            quiet_hours: None
        }
    }
    
    fn is_category_enabled(category: NotificationCategory) -> Bool {
        !self.disabled_categories.contains(category)
    }
    
    fn disable_category(cat: NotificationCategory) -> Self {
        self.disabled_categories.push(cat); self
    }
    
    fn enable_quiet_hours(start: Int, end: Int) -> Self {
        self.quiet_hours = Some(QuietHours { start_hour: start, end_hour: end });
        self
    }
    
    fn is_quiet_time() -> Bool {
        match self.quiet_hours {
            Some(qh) => qh.is_active(),
            None => false
        }
    }
}

struct QuietHours {
    start_hour: Int
    end_hour: Int
}

impl QuietHours {
    fn is_active() -> Bool {
        let current_hour = DateTime.now().hour();
        if self.start_hour <= self.end_hour {
            current_hour >= self.start_hour && current_hour < self.end_hour
        } else {
            current_hour >= self.start_hour || current_hour < self.end_hour
        }
    }
}

// =============================================================================
// Results & Stats
// =============================================================================

struct PostResult {
    id: String
    success: Bool
    error: Option<NotificationError>
}

impl PostResult {
    fn success(id: String) -> Self {
        PostResult { id: id, success: true, error: None }
    }
    
    fn failure(id: String, error: NotificationError) -> Self {
        PostResult { id: id, success: false, error: Some(error) }
    }
}

struct BatchPostResult {
    results: [PostResult]
    success_count: Int
    failure_count: Int
}

impl BatchPostResult {
    fn success_rate() -> Float {
        let total = self.success_count + self.failure_count;
        if total == 0 { 0.0 } else { self.success_count as Float / total as Float }
    }
}

struct NotificationStats {
    total_posted: Int
    total_delivered: Int
    total_read: Int
    total_dismissed: Int
    total_expired: Int
    created_at: DateTime
}

impl NotificationStats {
    fn new() -> Self {
        NotificationStats {
            total_posted: 0,
            total_delivered: 0,
            total_read: 0,
            total_dismissed: 0,
            total_expired: 0,
            created_at: DateTime.now()
        }
    }
    
    fn read_rate() -> Float {
        if self.total_delivered == 0 { 0.0 }
        else { self.total_read as Float / self.total_delivered as Float }
    }
    
    fn engagement_rate() -> Float {
        if self.total_posted == 0 { 0.0 }
        else { (self.total_read + self.total_dismissed) as Float / self.total_posted as Float }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum NotificationError {
    NotFound(String)
    CategoryDisabled(NotificationCategory)
    RateLimited
    Expired
    InvalidRecipient
    DeliveryFailed(String)
    HandlerError(String)
    QuietHoursActive
    StorageFull
    Unknown(String)
}

impl NotificationError {
    fn is_retryable() -> Bool {
        match self {
            .RateLimited | .DeliveryFailed(_) | .QuietHoursActive => true,
            _ => false
        }
    }
    
    fn message() -> String {
        match self {
            .NotFound(id) => format!("Notification not found: {}", id),
            .CategoryDisabled(cat) => format!("Category disabled: {:?}", cat),
            .RateLimited => "Rate limit exceeded",
            .Expired => "Notification has expired",
            .InvalidRecipient => "Invalid recipient",
            .DeliveryFailed(msg) => format!("Delivery failed: {}", msg),
            .HandlerError(msg) => format!("Handler error: {}", msg),
            .QuietHoursActive => "Quiet hours are active",
            .StorageFull => "Notification storage is full",
            .Unknown(msg) => format!("Unknown error: {}", msg)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "notification creation" {
    let notif = Notification.new("user123", "Hello", "World")
        .subtitle("Subtitle")
        .category(NotificationCategory.Message)
        .priority(NotificationPriority.High)
        .icon("/icon.png");
    
    assert_eq(notif.title, "Hello")?
    assert_eq(notif.recipient_id, "user123")?
    assert_eq(notif.priority, NotificationPriority.High)?
    assert_eq(notif.subtitle, Some("Subtitle"))?
}

test "notification center post and retrieve" {
    let center = NotificationCenter.new();
    
    let notif = Notification.new("user1", "Test", "Body");
    let id = center.post(notif).unwrap();
    
    let retrieved = center.get(id.clone()).unwrap();
    assert_eq(retrieved.title, "Test")?
    
    let user_notifs = center.get_for_user("user1");
    assert_eq(user_notifs.len(), 1)?
}

test "notification center mark read" {
    let center = NotificationCenter.new();
    
    let notif = Notification.new("user1", "Test", "Body");
    let id = center.post(notif).unwrap();
    
    assert_eq(center.count_unread("user1"), 1)?
    
    center.mark_read(id).unwrap();
    
    assert_eq(center.count_unread("user1"), 0)?
}

test "notification query" {
    let center = NotificationCenter.new();
    
    center.post(Notification.new("user1", "Low", "Body").priority(NotificationPriority.Low)).unwrap();
    center.post(Notification.new("user1", "High", "Body").priority(NotificationPriority.High)).unwrap();
    center.post(Notification.new("user2", "Normal", "Body")).unwrap();
    
    let high_priority = center.query(
        NotificationQuery.new()
            .for_user("user1")
            .min_priority(NotificationPriority.High)
    );
    
    assert_eq(high_priority.len(), 1)?
    assert_eq(high_priority[0].title, "High")?
}

test "notification expiration" {
    let notif = Notification.new("user1", "Test", "Body")
        .expires_in(Duration.from_seconds(-1));
    
    assert(notif.is_expired())?
}

test "quiet hours" {
    let settings = NotificationCenterSettings.default()
        .enable_quiet_hours(22, 7);
    
    // Just test that it compiles and runs
    let _ = settings.is_quiet_time();
}
