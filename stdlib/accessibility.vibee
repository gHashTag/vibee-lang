// =============================================================================
// Vibee OS â€” Accessibility Module
// Accessibility (a11y) support for UI components
// =============================================================================

use component::{Component, Size}
use color::RGBA

// -----------------------------------------------------------------------------
// Semantic Roles
// -----------------------------------------------------------------------------

enum Role {
    // Document structure
    Article,
    Banner,
    Complementary,
    ContentInfo,
    Main,
    Navigation,
    Region,
    Search,
    
    // Widget roles
    Button,
    Checkbox,
    Dialog,
    GridCell,
    Link,
    ListItem,
    Menu,
    MenuItem,
    MenuItemCheckbox,
    MenuItemRadio,
    Option,
    ProgressBar,
    Radio,
    ScrollBar,
    SearchBox,
    Slider,
    SpinButton,
    Switch,
    Tab,
    TabPanel,
    TextBox,
    TreeItem,
    
    // Composite roles
    ComboBox,
    Grid,
    ListBox,
    MenuBar,
    RadioGroup,
    TabList,
    Tree,
    TreeGrid,
    
    // Live region roles
    Alert,
    Log,
    Marquee,
    Status,
    Timer,
    
    // Landmark roles
    Application,
    Document,
    Feed,
    Figure,
    Group,
    Heading,
    Image,
    List,
    Math,
    Note,
    Presentation,
    Row,
    RowGroup,
    RowHeader,
    Separator,
    Table,
    Term,
    ToolBar,
    Tooltip
}

// -----------------------------------------------------------------------------
// Accessibility Properties
// -----------------------------------------------------------------------------

struct Semantics {
    role: Option<Role>
    label: Option<String>
    hint: Option<String>
    value: Option<String>
    
    // States
    enabled: Bool
    selected: Bool
    checked: Option<CheckedState>
    expanded: Option<Bool>
    hidden: Bool
    focused: Bool
    
    // Properties
    live_region: Option<LiveRegion>
    heading_level: Option<Int>
    sort_direction: Option<SortDirection>
    
    // Relationships
    labelled_by: Option<String>
    described_by: Option<String>
    controls: Option<String>
    owns: Option<String>
    
    // Actions
    on_tap: Option<fn()>
    on_long_press: Option<fn()>
    on_scroll_left: Option<fn()>
    on_scroll_right: Option<fn()>
    on_scroll_up: Option<fn()>
    on_scroll_down: Option<fn()>
    on_increase: Option<fn()>
    on_decrease: Option<fn()>
    on_dismiss: Option<fn()>
    
    fn new() -> Self {
        Semantics {
            role: None, label: None, hint: None, value: None,
            enabled: true, selected: false, checked: None, expanded: None, hidden: false, focused: false,
            live_region: None, heading_level: None, sort_direction: None,
            labelled_by: None, described_by: None, controls: None, owns: None,
            on_tap: None, on_long_press: None, on_scroll_left: None, on_scroll_right: None,
            on_scroll_up: None, on_scroll_down: None, on_increase: None, on_decrease: None, on_dismiss: None
        }
    }
    
    fn button(label: String) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.Button)
        s.label = Some(label)
        s
    }
    
    fn checkbox(label: String, checked: Bool) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.Checkbox)
        s.label = Some(label)
        s.checked = Some(if checked { CheckedState.Checked } else { CheckedState.Unchecked })
        s
    }
    
    fn heading(text: String, level: Int) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.Heading)
        s.label = Some(text)
        s.heading_level = Some(level.clamp(1, 6))
        s
    }
    
    fn image(description: String) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.Image)
        s.label = Some(description)
        s
    }
    
    fn link(text: String) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.Link)
        s.label = Some(text)
        s
    }
    
    fn slider(label: String, value: Float64, min: Float64, max: Float64) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.Slider)
        s.label = Some(label)
        s.value = Some(format!("{:.0}%", (value - min) / (max - min) * 100.0))
        s
    }
    
    fn text_field(label: String, value: String) -> Self {
        var s = Semantics.new()
        s.role = Some(Role.TextBox)
        s.label = Some(label)
        s.value = Some(value)
        s
    }
    
    fn label(l: String) -> Self { self.label = Some(l); self }
    fn hint(h: String) -> Self { self.hint = Some(h); self }
    fn value(v: String) -> Self { self.value = Some(v); self }
    fn disabled() -> Self { self.enabled = false; self }
    fn selected() -> Self { self.selected = true; self }
    fn hidden() -> Self { self.hidden = true; self }
}

enum CheckedState { Unchecked, Checked, Mixed }
enum SortDirection { Ascending, Descending, None, Other }

// -----------------------------------------------------------------------------
// Live Regions
// -----------------------------------------------------------------------------

struct LiveRegion {
    politeness: Politeness
    atomic: Bool
    relevant: [Relevance]
    
    fn polite() -> Self { LiveRegion { politeness: Politeness.Polite, atomic: false, relevant: [Relevance.Additions, Relevance.Text] } }
    fn assertive() -> Self { LiveRegion { politeness: Politeness.Assertive, atomic: false, relevant: [Relevance.Additions, Relevance.Text] } }
    fn off() -> Self { LiveRegion { politeness: Politeness.Off, atomic: false, relevant: [] } }
    fn atomic() -> Self { self.atomic = true; self }
}

enum Politeness { Off, Polite, Assertive }
enum Relevance { Additions, Removals, Text, All }

// -----------------------------------------------------------------------------
// Focus Management
// -----------------------------------------------------------------------------

struct FocusNode {
    id: String
    can_request_focus: Bool
    skip_traversal: Bool
    descendants_focusable: Bool
    on_focus_change: Option<fn(Bool)>
    
    fn new(id: String) -> Self {
        FocusNode { id: id, can_request_focus: true, skip_traversal: false, descendants_focusable: true, on_focus_change: None }
    }
    
    fn request_focus() { @native("focus_request", self.id) }
    fn unfocus() { @native("focus_unfocus", self.id) }
    fn next_focus() { @native("focus_next", self.id) }
    fn previous_focus() { @native("focus_previous", self.id) }
    fn has_focus() -> Bool { @native("focus_has", self.id) }
}

struct FocusScope {
    nodes: [FocusNode]
    autofocus: Bool
    
    fn new() -> Self { FocusScope { nodes: [], autofocus: false } }
    fn add(node: FocusNode) -> Self { self.nodes.push(node); self }
    fn autofocus() -> Self { self.autofocus = true; self }
}

struct FocusTrap {
    child: Box<dyn Component>
    active: Bool
    
    fn new(child: Box<dyn Component>) -> Self { FocusTrap { child: child, active: true } }
    fn deactivate() -> Self { self.active = false; self }
}

// -----------------------------------------------------------------------------
// Screen Reader Support
// -----------------------------------------------------------------------------

struct ScreenReaderAnnouncement {
    message: String
    politeness: Politeness
    
    fn polite(message: String) -> Self {
        ScreenReaderAnnouncement { message: message, politeness: Politeness.Polite }
    }
    
    fn assertive(message: String) -> Self {
        ScreenReaderAnnouncement { message: message, politeness: Politeness.Assertive }
    }
    
    fn announce() { @native("screen_reader_announce", self.message, self.politeness) }
}

fn announce(message: String) { ScreenReaderAnnouncement.polite(message).announce() }
fn announce_urgent(message: String) { ScreenReaderAnnouncement.assertive(message).announce() }

// -----------------------------------------------------------------------------
// Color Contrast
// -----------------------------------------------------------------------------

struct ContrastChecker {
    fn ratio(foreground: RGBA, background: RGBA) -> Float64 {
        let l1 = luminance(foreground)
        let l2 = luminance(background)
        let lighter = l1.max(l2)
        let darker = l1.min(l2)
        (lighter + 0.05) / (darker + 0.05)
    }
    
    fn meets_aa(foreground: RGBA, background: RGBA, large_text: Bool) -> Bool {
        let ratio = ContrastChecker.ratio(foreground, background)
        if large_text { ratio >= 3.0 } else { ratio >= 4.5 }
    }
    
    fn meets_aaa(foreground: RGBA, background: RGBA, large_text: Bool) -> Bool {
        let ratio = ContrastChecker.ratio(foreground, background)
        if large_text { ratio >= 4.5 } else { ratio >= 7.0 }
    }
    
    fn suggest_foreground(background: RGBA) -> RGBA {
        let bg_lum = luminance(background)
        if bg_lum > 0.5 { RGBA.new(0, 0, 0, 1.0) } else { RGBA.new(255, 255, 255, 1.0) }
    }
}

fn luminance(color: RGBA) -> Float64 {
    let r = gamma_correct(color.r as Float64 / 255.0)
    let g = gamma_correct(color.g as Float64 / 255.0)
    let b = gamma_correct(color.b as Float64 / 255.0)
    0.2126 * r + 0.7152 * g + 0.0722 * b
}

fn gamma_correct(value: Float64) -> Float64 {
    if value <= 0.03928 { value / 12.92 } else { ((value + 0.055) / 1.055).pow(2.4) }
}

// -----------------------------------------------------------------------------
// Touch Target Size
// -----------------------------------------------------------------------------

struct TouchTarget {
    min_size: Size
    
    fn default() -> Self { TouchTarget { min_size: Size.new(48.0, 48.0) } }
    fn large() -> Self { TouchTarget { min_size: Size.new(56.0, 56.0) } }
    
    fn is_adequate(actual: Size) -> Bool {
        actual.width >= self.min_size.width && actual.height >= self.min_size.height
    }
}

// -----------------------------------------------------------------------------
// Reduced Motion
// -----------------------------------------------------------------------------

struct MotionPreferences {
    fn prefers_reduced_motion() -> Bool { @native("prefers_reduced_motion") }
    fn animation_duration(normal: Float64) -> Float64 {
        if MotionPreferences.prefers_reduced_motion() { 0.0 } else { normal }
    }
}

// -----------------------------------------------------------------------------
// High Contrast Mode
// -----------------------------------------------------------------------------

struct HighContrastMode {
    fn is_enabled() -> Bool { @native("high_contrast_enabled") }
    fn adjust_color(color: RGBA) -> RGBA {
        if !HighContrastMode.is_enabled() { return color }
        let lum = luminance(color)
        if lum > 0.5 { RGBA.new(255, 255, 255, color.a) } else { RGBA.new(0, 0, 0, color.a) }
    }
}

// -----------------------------------------------------------------------------
// Accessible Widgets
// -----------------------------------------------------------------------------

struct AccessibleButton {
    child: Box<dyn Component>
    semantics: Semantics
    
    fn new(label: String, on_press: fn()) -> Self {
        var sem = Semantics.button(label)
        sem.on_tap = Some(on_press)
        AccessibleButton { child: Box.new(Text.new(label)), semantics: sem }
    }
    
    fn with_child(child: Box<dyn Component>, label: String, on_press: fn()) -> Self {
        var sem = Semantics.button(label)
        sem.on_tap = Some(on_press)
        AccessibleButton { child: child, semantics: sem }
    }
}

struct AccessibleImage {
    source: String
    alt_text: String
    decorative: Bool
    
    fn new(source: String, alt_text: String) -> Self {
        AccessibleImage { source: source, alt_text: alt_text, decorative: false }
    }
    
    fn decorative(source: String) -> Self {
        AccessibleImage { source: source, alt_text: "", decorative: true }
    }
    
    fn semantics() -> Semantics {
        if self.decorative {
            var s = Semantics.new()
            s.hidden = true
            s
        } else {
            Semantics.image(self.alt_text)
        }
    }
}

struct AccessibleTextField {
    label: String
    value: String
    hint: Option<String>
    error: Option<String>
    
    fn new(label: String) -> Self {
        AccessibleTextField { label: label, value: "", hint: None, error: None }
    }
    
    fn value(v: String) -> Self { self.value = v; self }
    fn hint(h: String) -> Self { self.hint = Some(h); self }
    fn error(e: String) -> Self { self.error = Some(e); self }
    
    fn semantics() -> Semantics {
        var s = Semantics.text_field(self.label, self.value)
        if let Some(h) = &self.hint { s.hint = Some(h.clone()) }
        if let Some(e) = &self.error { s.hint = Some(format!("Error: {}", e)) }
        s
    }
}

// -----------------------------------------------------------------------------
// Skip Links
// -----------------------------------------------------------------------------

struct SkipLink {
    target_id: String
    label: String
    
    fn new(target_id: String, label: String) -> Self {
        SkipLink { target_id: target_id, label: label }
    }
    
    fn to_main_content() -> Self {
        SkipLink { target_id: "main-content", label: "Skip to main content" }
    }
    
    fn to_navigation() -> Self {
        SkipLink { target_id: "navigation", label: "Skip to navigation" }
    }
}

// -----------------------------------------------------------------------------
// Accessibility Tree
// -----------------------------------------------------------------------------

struct AccessibilityNode {
    id: String
    semantics: Semantics
    children: [AccessibilityNode]
    rect: Rect
    
    fn new(id: String, semantics: Semantics) -> Self {
        AccessibilityNode { id: id, semantics: semantics, children: [], rect: Rect.zero() }
    }
    
    fn add_child(child: AccessibilityNode) -> Self { self.children.push(child); self }
}

actor AccessibilityService {
    root: Option<AccessibilityNode>
    focus_order: [String]
    
    fn new() -> Self { AccessibilityService { root: None, focus_order: [] } }
    fn set_root(node: AccessibilityNode) { self.root = Some(node) }
    fn get_node(id: String) -> Option<&AccessibilityNode> { @native("a11y_get_node", id) }
    fn traverse(visitor: fn(&AccessibilityNode)) {
        if let Some(root) = &self.root { traverse_node(root, visitor) }
    }
}

fn traverse_node(node: &AccessibilityNode, visitor: fn(&AccessibilityNode)) {
    visitor(node)
    for child in &node.children { traverse_node(child, visitor) }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "contrast ratio" {
    let white = RGBA.new(255, 255, 255, 1.0)
    let black = RGBA.new(0, 0, 0, 1.0)
    let ratio = ContrastChecker.ratio(white, black)
    assert(ratio > 20.0)?
}

test "meets aa" {
    let white = RGBA.new(255, 255, 255, 1.0)
    let dark_gray = RGBA.new(85, 85, 85, 1.0)
    assert(ContrastChecker.meets_aa(white, dark_gray, false))?
}

test "semantics button" {
    let sem = Semantics.button("Submit")
    assert_eq(sem.role, Some(Role.Button))?
    assert_eq(sem.label, Some("Submit"))?
}

test "semantics heading" {
    let sem = Semantics.heading("Title", 1)
    assert_eq(sem.heading_level, Some(1))?
}

test "touch target" {
    let target = TouchTarget.default()
    assert(target.is_adequate(Size.new(48.0, 48.0)))?
    assert(!target.is_adequate(Size.new(30.0, 30.0)))?
}

test "live region" {
    let live = LiveRegion.assertive().atomic()
    assert_eq(live.politeness, Politeness.Assertive)?
    assert(live.atomic)?
}
