// =============================================================================
// Vibee OS â€” Rules Module
// Validation rules and rule engine
// =============================================================================

use validator::{ValidationResult, ValidationError}

// =============================================================================
// Rule Trait
// =============================================================================

/// A validation rule that can be applied to a value
trait Rule<T> {
    fn check(value: T) -> RuleResult
    fn name() -> String
    fn message() -> String
}

/// Result of a rule check
enum RuleResult {
    Pass
    Fail(String)
    Skip
}

impl RuleResult {
    fn is_pass() -> Bool { match self { Pass => true, _ => false } }
    fn is_fail() -> Bool { match self { Fail(_) => true, _ => false } }
    fn is_skip() -> Bool { match self { Skip => true, _ => false } }
    
    fn to_validation_result(rule_name: String) -> ValidationResult {
        match self {
            Pass | Skip => ValidationResult.ok()
            Fail(msg) => ValidationResult.error(
                ValidationError.with_code(rule_name, msg)
            )
        }
    }
}

// =============================================================================
// Built-in Rules
// =============================================================================

/// Required rule - value must not be empty
struct RequiredRule {
    message: String
}

impl RequiredRule {
    fn new() -> Self { RequiredRule { message: "This field is required" } }
    fn with_message(msg: String) -> Self { RequiredRule { message: msg } }
}

impl Rule<String> for RequiredRule {
    fn check(value: String) -> RuleResult {
        if value.trim().is_empty() { RuleResult.Fail(self.message.clone()) }
        else { RuleResult.Pass }
    }
    fn name() -> String { "required" }
    fn message() -> String { self.message.clone() }
}

impl<T> Rule<Option<T>> for RequiredRule {
    fn check(value: Option<T>) -> RuleResult {
        match value {
            Some(_) => RuleResult.Pass
            None => RuleResult.Fail(self.message.clone())
        }
    }
    fn name() -> String { "required" }
    fn message() -> String { self.message.clone() }
}

/// Min length rule
struct MinLengthRule {
    min: Int
    message: String
}

impl MinLengthRule {
    fn new(min: Int) -> Self {
        MinLengthRule { min: min, message: format!("Must be at least {} characters", min) }
    }
    fn with_message(min: Int, msg: String) -> Self {
        MinLengthRule { min: min, message: msg }
    }
}

impl Rule<String> for MinLengthRule {
    fn check(value: String) -> RuleResult {
        if value.len() >= self.min { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "min_length" }
    fn message() -> String { self.message.clone() }
}

/// Max length rule
struct MaxLengthRule {
    max: Int
    message: String
}

impl MaxLengthRule {
    fn new(max: Int) -> Self {
        MaxLengthRule { max: max, message: format!("Must be at most {} characters", max) }
    }
}

impl Rule<String> for MaxLengthRule {
    fn check(value: String) -> RuleResult {
        if value.len() <= self.max { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "max_length" }
    fn message() -> String { self.message.clone() }
}

/// Exact length rule
struct LengthRule {
    length: Int
    message: String
}

impl LengthRule {
    fn new(length: Int) -> Self {
        LengthRule { length: length, message: format!("Must be exactly {} characters", length) }
    }
}

impl Rule<String> for LengthRule {
    fn check(value: String) -> RuleResult {
        if value.len() == self.length { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "length" }
    fn message() -> String { self.message.clone() }
}

/// Pattern rule (regex)
struct PatternRule {
    pattern: Regex
    message: String
}

impl PatternRule {
    fn new(pattern: String, message: String) -> Result<Self, RegexError> {
        let regex = Regex.new(pattern)?
        Ok(PatternRule { pattern: regex, message: message })
    }
}

impl Rule<String> for PatternRule {
    fn check(value: String) -> RuleResult {
        if self.pattern.is_match(value) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "pattern" }
    fn message() -> String { self.message.clone() }
}

/// Email rule
struct EmailRule {
    message: String
}

impl EmailRule {
    fn new() -> Self { EmailRule { message: "Invalid email address" } }
}

impl Rule<String> for EmailRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        
        let pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
        if regex.is_match(pattern, value) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "email" }
    fn message() -> String { self.message.clone() }
}

/// URL rule
struct UrlRule {
    message: String
    require_https: Bool
}

impl UrlRule {
    fn new() -> Self { UrlRule { message: "Invalid URL", require_https: false } }
    fn https_only() -> Self { UrlRule { message: "URL must use HTTPS", require_https: true } }
}

impl Rule<String> for UrlRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        
        if self.require_https {
            if !value.starts_with("https://") {
                return RuleResult.Fail(self.message.clone())
            }
        } else {
            if !value.starts_with("http://") && !value.starts_with("https://") {
                return RuleResult.Fail(self.message.clone())
            }
        }
        RuleResult.Pass
    }
    fn name() -> String { "url" }
    fn message() -> String { self.message.clone() }
}

/// Numeric range rule
struct RangeRule<T: Ord> {
    min: Option<T>
    max: Option<T>
    message: String
}

impl<T: Ord + Display> RangeRule<T> {
    fn new(min: Option<T>, max: Option<T>) -> Self {
        let msg = match (min, max) {
            (Some(mn), Some(mx)) => format!("Must be between {} and {}", mn, mx)
            (Some(mn), None) => format!("Must be at least {}", mn)
            (None, Some(mx)) => format!("Must be at most {}", mx)
            (None, None) => "Invalid value"
        }
        RangeRule { min: min, max: max, message: msg }
    }
    
    fn min(value: T) -> Self { Self.new(Some(value), None) }
    fn max(value: T) -> Self { Self.new(None, Some(value)) }
    fn between(min: T, max: T) -> Self { Self.new(Some(min), Some(max)) }
}

impl<T: Ord + Clone> Rule<T> for RangeRule<T> {
    fn check(value: T) -> RuleResult {
        if let Some(min) = self.min {
            if value < min { return RuleResult.Fail(self.message.clone()) }
        }
        if let Some(max) = self.max {
            if value > max { return RuleResult.Fail(self.message.clone()) }
        }
        RuleResult.Pass
    }
    fn name() -> String { "range" }
    fn message() -> String { self.message.clone() }
}

/// In list rule
struct InRule<T: Eq> {
    values: [T]
    message: String
}

impl<T: Eq + Display> InRule<T> {
    fn new(values: [T]) -> Self {
        let msg = format!("Must be one of: {}", values.iter().map(|v| v.to_string()).join(", "))
        InRule { values: values, message: msg }
    }
}

impl<T: Eq + Clone> Rule<T> for InRule<T> {
    fn check(value: T) -> RuleResult {
        if self.values.contains(value) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "in" }
    fn message() -> String { self.message.clone() }
}

/// Not in list rule
struct NotInRule<T: Eq> {
    values: [T]
    message: String
}

impl<T: Eq> NotInRule<T> {
    fn new(values: [T]) -> Self {
        NotInRule { values: values, message: "This value is not allowed" }
    }
}

impl<T: Eq + Clone> Rule<T> for NotInRule<T> {
    fn check(value: T) -> RuleResult {
        if !self.values.contains(value) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "not_in" }
    fn message() -> String { self.message.clone() }
}

/// Confirmed rule (two fields must match)
struct ConfirmedRule {
    confirmation_value: String
    message: String
}

impl ConfirmedRule {
    fn new(confirmation: String) -> Self {
        ConfirmedRule { confirmation_value: confirmation, message: "Values do not match" }
    }
}

impl Rule<String> for ConfirmedRule {
    fn check(value: String) -> RuleResult {
        if value == self.confirmation_value { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "confirmed" }
    fn message() -> String { self.message.clone() }
}

/// Different rule (two fields must be different)
struct DifferentRule {
    other_value: String
    message: String
}

impl DifferentRule {
    fn new(other: String) -> Self {
        DifferentRule { other_value: other, message: "Values must be different" }
    }
}

impl Rule<String> for DifferentRule {
    fn check(value: String) -> RuleResult {
        if value != self.other_value { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "different" }
    fn message() -> String { self.message.clone() }
}

/// Alpha rule (letters only)
struct AlphaRule {
    message: String
}

impl AlphaRule {
    fn new() -> Self { AlphaRule { message: "Must contain only letters" } }
}

impl Rule<String> for AlphaRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        if value.chars().all(|c| c.is_alphabetic()) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "alpha" }
    fn message() -> String { self.message.clone() }
}

/// Alphanumeric rule
struct AlphanumericRule {
    message: String
}

impl AlphanumericRule {
    fn new() -> Self { AlphanumericRule { message: "Must contain only letters and numbers" } }
}

impl Rule<String> for AlphanumericRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        if value.chars().all(|c| c.is_alphanumeric()) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "alphanumeric" }
    fn message() -> String { self.message.clone() }
}

/// Numeric rule
struct NumericRule {
    message: String
}

impl NumericRule {
    fn new() -> Self { NumericRule { message: "Must be a number" } }
}

impl Rule<String> for NumericRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        if Float.parse(value).is_ok() { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "numeric" }
    fn message() -> String { self.message.clone() }
}

/// Integer rule
struct IntegerRule {
    message: String
}

impl IntegerRule {
    fn new() -> Self { IntegerRule { message: "Must be an integer" } }
}

impl Rule<String> for IntegerRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        if Int.parse(value).is_ok() { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "integer" }
    fn message() -> String { self.message.clone() }
}

/// Date rule
struct DateRule {
    format: String
    message: String
}

impl DateRule {
    fn new() -> Self { DateRule { format: "%Y-%m-%d", message: "Invalid date" } }
    fn with_format(format: String) -> Self { DateRule { format: format, message: "Invalid date format" } }
}

impl Rule<String> for DateRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        if DateTime.parse(value, self.format).is_ok() { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "date" }
    fn message() -> String { self.message.clone() }
}

/// Before date rule
struct BeforeDateRule {
    date: DateTime
    message: String
}

impl BeforeDateRule {
    fn new(date: DateTime) -> Self {
        BeforeDateRule { date: date, message: format!("Must be before {}", date) }
    }
}

impl Rule<DateTime> for BeforeDateRule {
    fn check(value: DateTime) -> RuleResult {
        if value < self.date { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "before" }
    fn message() -> String { self.message.clone() }
}

/// After date rule
struct AfterDateRule {
    date: DateTime
    message: String
}

impl AfterDateRule {
    fn new(date: DateTime) -> Self {
        AfterDateRule { date: date, message: format!("Must be after {}", date) }
    }
}

impl Rule<DateTime> for AfterDateRule {
    fn check(value: DateTime) -> RuleResult {
        if value > self.date { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "after" }
    fn message() -> String { self.message.clone() }
}

/// UUID rule
struct UuidRule {
    message: String
}

impl UuidRule {
    fn new() -> Self { UuidRule { message: "Invalid UUID" } }
}

impl Rule<String> for UuidRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        let pattern = r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"
        if regex.is_match(pattern, value) { RuleResult.Pass }
        else { RuleResult.Fail(self.message.clone()) }
    }
    fn name() -> String { "uuid" }
    fn message() -> String { self.message.clone() }
}

/// IP address rule
struct IpRule {
    version: Option<Int>  // 4 or 6
    message: String
}

impl IpRule {
    fn new() -> Self { IpRule { version: None, message: "Invalid IP address" } }
    fn v4() -> Self { IpRule { version: Some(4), message: "Invalid IPv4 address" } }
    fn v6() -> Self { IpRule { version: Some(6), message: "Invalid IPv6 address" } }
}

impl Rule<String> for IpRule {
    fn check(value: String) -> RuleResult {
        if value.is_empty() { return RuleResult.Skip }
        
        let is_v4 = is_valid_ipv4(value.clone())
        let is_v6 = is_valid_ipv6(value.clone())
        
        match self.version {
            Some(4) => if is_v4 { RuleResult.Pass } else { RuleResult.Fail(self.message.clone()) }
            Some(6) => if is_v6 { RuleResult.Pass } else { RuleResult.Fail(self.message.clone()) }
            None => if is_v4 || is_v6 { RuleResult.Pass } else { RuleResult.Fail(self.message.clone()) }
        }
    }
    fn name() -> String { "ip" }
    fn message() -> String { self.message.clone() }
}

fn is_valid_ipv4(s: String) -> Bool {
    let parts = s.split(".")
    if parts.len() != 4 { return false }
    for part in parts {
        match Int.parse(part) {
            Ok(n) if n >= 0 && n <= 255 => {}
            _ => return false
        }
    }
    true
}

fn is_valid_ipv6(s: String) -> Bool {
    let pattern = r"^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$"
    regex.is_match(pattern, s)
}

/// Password strength rule
struct PasswordRule {
    min_length: Int
    require_uppercase: Bool
    require_lowercase: Bool
    require_digit: Bool
    require_special: Bool
    message: String
}

impl PasswordRule {
    fn new() -> Self {
        PasswordRule {
            min_length: 8,
            require_uppercase: true,
            require_lowercase: true,
            require_digit: true,
            require_special: false,
            message: "Password does not meet requirements"
        }
    }
    
    fn strong() -> Self {
        PasswordRule {
            min_length: 12,
            require_uppercase: true,
            require_lowercase: true,
            require_digit: true,
            require_special: true,
            message: "Password must be at least 12 characters with uppercase, lowercase, digit, and special character"
        }
    }
    
    fn min_length(len: Int) -> Self { self.min_length = len; self }
    fn require_uppercase() -> Self { self.require_uppercase = true; self }
    fn require_lowercase() -> Self { self.require_lowercase = true; self }
    fn require_digit() -> Self { self.require_digit = true; self }
    fn require_special() -> Self { self.require_special = true; self }
}

impl Rule<String> for PasswordRule {
    fn check(value: String) -> RuleResult {
        if value.len() < self.min_length {
            return RuleResult.Fail(format!("Password must be at least {} characters", self.min_length))
        }
        
        if self.require_uppercase && !value.chars().any(|c| c.is_uppercase()) {
            return RuleResult.Fail("Password must contain an uppercase letter")
        }
        
        if self.require_lowercase && !value.chars().any(|c| c.is_lowercase()) {
            return RuleResult.Fail("Password must contain a lowercase letter")
        }
        
        if self.require_digit && !value.chars().any(|c| c.is_digit()) {
            return RuleResult.Fail("Password must contain a digit")
        }
        
        if self.require_special && !value.chars().any(|c| !c.is_alphanumeric()) {
            return RuleResult.Fail("Password must contain a special character")
        }
        
        RuleResult.Pass
    }
    fn name() -> String { "password" }
    fn message() -> String { self.message.clone() }
}

// =============================================================================
// Rule Engine
// =============================================================================

/// Rule engine for applying multiple rules
struct RuleEngine<T> {
    rules: [Box<dyn Rule<T>>]
    stop_on_first_failure: Bool
}

impl<T: Clone> RuleEngine<T> {
    fn new() -> Self {
        RuleEngine { rules: [], stop_on_first_failure: false }
    }
    
    fn add(rule: impl Rule<T>) -> Self {
        self.rules.push(Box.new(rule))
        self
    }
    
    fn stop_on_first() -> Self {
        self.stop_on_first_failure = true
        self
    }
    
    fn validate(value: T) -> ValidationResult {
        var errors = []
        
        for rule in self.rules {
            match rule.check(value.clone()) {
                RuleResult.Pass | RuleResult.Skip => {}
                RuleResult.Fail(msg) => {
                    errors.push(ValidationError.with_code(rule.name(), msg))
                    if self.stop_on_first_failure {
                        break
                    }
                }
            }
        }
        
        ValidationResult { errors: errors }
    }
    
    fn is_valid(value: T) -> Bool {
        self.validate(value).is_ok()
    }
}

// =============================================================================
// Rule Builder
// =============================================================================

/// Fluent rule builder
struct RuleBuilder<T> {
    engine: RuleEngine<T>
}

impl RuleBuilder<String> {
    fn new() -> Self { RuleBuilder { engine: RuleEngine.new() } }
    
    fn required() -> Self { self.engine = self.engine.add(RequiredRule.new()); self }
    fn min_length(min: Int) -> Self { self.engine = self.engine.add(MinLengthRule.new(min)); self }
    fn max_length(max: Int) -> Self { self.engine = self.engine.add(MaxLengthRule.new(max)); self }
    fn length(len: Int) -> Self { self.engine = self.engine.add(LengthRule.new(len)); self }
    fn email() -> Self { self.engine = self.engine.add(EmailRule.new()); self }
    fn url() -> Self { self.engine = self.engine.add(UrlRule.new()); self }
    fn alpha() -> Self { self.engine = self.engine.add(AlphaRule.new()); self }
    fn alphanumeric() -> Self { self.engine = self.engine.add(AlphanumericRule.new()); self }
    fn numeric() -> Self { self.engine = self.engine.add(NumericRule.new()); self }
    fn uuid() -> Self { self.engine = self.engine.add(UuidRule.new()); self }
    fn ip() -> Self { self.engine = self.engine.add(IpRule.new()); self }
    fn password() -> Self { self.engine = self.engine.add(PasswordRule.new()); self }
    fn strong_password() -> Self { self.engine = self.engine.add(PasswordRule.strong()); self }
    
    fn pattern(regex: String, message: String) -> Self {
        if let Ok(rule) = PatternRule.new(regex, message) {
            self.engine = self.engine.add(rule)
        }
        self
    }
    
    fn one_of(values: [String]) -> Self {
        self.engine = self.engine.add(InRule.new(values))
        self
    }
    
    fn custom(rule: impl Rule<String>) -> Self {
        self.engine = self.engine.add(rule)
        self
    }
    
    fn build() -> RuleEngine<String> { self.engine }
    fn validate(value: String) -> ValidationResult { self.engine.validate(value) }
    fn is_valid(value: String) -> Bool { self.engine.is_valid(value) }
}

// =============================================================================
// Conditional Rules
// =============================================================================

/// Rule that only applies when condition is met
struct WhenRule<T> {
    condition: fn(T) -> Bool
    rule: Box<dyn Rule<T>>
}

impl<T: Clone> WhenRule<T> {
    fn new(condition: fn(T) -> Bool, rule: impl Rule<T>) -> Self {
        WhenRule { condition: condition, rule: Box.new(rule) }
    }
}

impl<T: Clone> Rule<T> for WhenRule<T> {
    fn check(value: T) -> RuleResult {
        if (self.condition)(value.clone()) {
            self.rule.check(value)
        } else {
            RuleResult.Skip
        }
    }
    fn name() -> String { self.rule.name() }
    fn message() -> String { self.rule.message() }
}

/// Rule that applies unless condition is met
struct UnlessRule<T> {
    condition: fn(T) -> Bool
    rule: Box<dyn Rule<T>>
}

impl<T: Clone> UnlessRule<T> {
    fn new(condition: fn(T) -> Bool, rule: impl Rule<T>) -> Self {
        UnlessRule { condition: condition, rule: Box.new(rule) }
    }
}

impl<T: Clone> Rule<T> for UnlessRule<T> {
    fn check(value: T) -> RuleResult {
        if !(self.condition)(value.clone()) {
            self.rule.check(value)
        } else {
            RuleResult.Skip
        }
    }
    fn name() -> String { self.rule.name() }
    fn message() -> String { self.rule.message() }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Create a required rule
fn required() -> RequiredRule { RequiredRule.new() }

/// Create a min length rule
fn min_length(min: Int) -> MinLengthRule { MinLengthRule.new(min) }

/// Create a max length rule
fn max_length(max: Int) -> MaxLengthRule { MaxLengthRule.new(max) }

/// Create an email rule
fn email() -> EmailRule { EmailRule.new() }

/// Create a URL rule
fn url() -> UrlRule { UrlRule.new() }

/// Create a UUID rule
fn uuid() -> UuidRule { UuidRule.new() }

/// Create an IP rule
fn ip() -> IpRule { IpRule.new() }

/// Create a password rule
fn password() -> PasswordRule { PasswordRule.new() }

// =============================================================================
// Tests
// =============================================================================

test "required rule" {
    let rule = RequiredRule.new()
    assert(rule.check("hello").is_pass())?
    assert(rule.check("").is_fail())?
    assert(rule.check("   ").is_fail())?
}

test "min length rule" {
    let rule = MinLengthRule.new(5)
    assert(rule.check("hello").is_pass())?
    assert(rule.check("hi").is_fail())?
}

test "email rule" {
    let rule = EmailRule.new()
    assert(rule.check("test@example.com").is_pass())?
    assert(rule.check("invalid").is_fail())?
}

test "password rule" {
    let rule = PasswordRule.new()
    assert(rule.check("Password1").is_pass())?
    assert(rule.check("weak").is_fail())?
}

test "rule engine" {
    let engine = RuleEngine.new()
        .add(RequiredRule.new())
        .add(MinLengthRule.new(3))
        .add(MaxLengthRule.new(20))
    
    assert(engine.is_valid("hello"))?
    assert(!engine.is_valid(""))?
    assert(!engine.is_valid("hi"))?
}

test "rule builder" {
    let rules = RuleBuilder.new()
        .required()
        .min_length(3)
        .max_length(20)
        .alphanumeric()
    
    assert(rules.is_valid("hello123"))?
    assert(!rules.is_valid("hello world"))?  // space not alphanumeric
}

test "conditional rule" {
    let rule = WhenRule.new(
        |s| s.len() > 0,
        MinLengthRule.new(5)
    )
    
    assert(rule.check("").is_skip())?
    assert(rule.check("hello").is_pass())?
    assert(rule.check("hi").is_fail())?
}

test "range rule" {
    let rule = RangeRule.between(1, 100)
    assert(rule.check(50).is_pass())?
    assert(rule.check(0).is_fail())?
    assert(rule.check(101).is_fail())?
}
