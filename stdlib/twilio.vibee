// =============================================================================
// Vibee OS â€” Twilio Module
// Twilio SMS, Voice, and Messaging API integration
// =============================================================================

use http.{HttpClient, Request, Response, HttpMethod}
use json.{JsonValue, Serialize, Deserialize}
use sms_sender.{SmsProvider, SmsMessage, SmsResult, SmsStatus, SmsError, DeliveryReport, IncomingSms}
use base64.{encode as base64_encode}

// =============================================================================
// Twilio Client
// =============================================================================

/// Twilio API client
struct TwilioClient {
    account_sid: String
    auth_token: String
    from_number: Option<String>
    messaging_service_sid: Option<String>
    base_url: String
    http: HttpClient
    timeout_ms: Int64
}

impl TwilioClient {
    fn new(account_sid: String, auth_token: String) -> Self {
        TwilioClient {
            account_sid: account_sid.clone(),
            auth_token: auth_token,
            from_number: None,
            messaging_service_sid: None,
            base_url: format!("https://api.twilio.com/2010-04-01/Accounts/{}", account_sid),
            http: HttpClient.new(),
            timeout_ms: 30000
        }
    }
    
    fn from_env() -> Result<Self, TwilioError> {
        let sid = @native("env_get", "TWILIO_ACCOUNT_SID").ok_or(TwilioError.ConfigError("TWILIO_ACCOUNT_SID not set"))?
        let token = @native("env_get", "TWILIO_AUTH_TOKEN").ok_or(TwilioError.ConfigError("TWILIO_AUTH_TOKEN not set"))?
        var client = Self.new(sid, token)
        if let Some(from) = @native("env_get", "TWILIO_FROM_NUMBER") {
            client = client.from(from)
        }
        if let Some(msid) = @native("env_get", "TWILIO_MESSAGING_SERVICE_SID") {
            client = client.messaging_service(msid)
        }
        Ok(client)
    }
    
    fn from(number: String) -> Self { self.from_number = Some(number); self }
    fn messaging_service(sid: String) -> Self { self.messaging_service_sid = Some(sid); self }
    fn timeout(ms: Int64) -> Self { self.timeout_ms = ms; self }
    
    fn auth_header() -> String {
        let credentials = format!("{}:{}", self.account_sid, self.auth_token)
        format!("Basic {}", base64_encode(credentials.as_bytes()))
    }
    
    // SMS Methods
    fn send_sms(to: String, body: String) -> Result<TwilioMessage, TwilioError> {
        let from = self.from_number.clone().or(self.messaging_service_sid.clone())
            .ok_or(TwilioError.ConfigError("No from number or messaging service configured"))?
        
        var params = Map.empty()
        params.set("To", to)
        params.set("Body", body)
        
        if let Some(num) = self.from_number.clone() {
            params.set("From", num)
        } else if let Some(msid) = self.messaging_service_sid.clone() {
            params.set("MessagingServiceSid", msid)
        }
        
        self.post_form("/Messages.json", params)
    }
    
    fn send_mms(to: String, body: String, media_url: String) -> Result<TwilioMessage, TwilioError> {
        let from = self.from_number.clone().ok_or(TwilioError.ConfigError("From number required for MMS"))?
        
        var params = Map.empty()
        params.set("To", to)
        params.set("From", from)
        params.set("Body", body)
        params.set("MediaUrl", media_url)
        
        self.post_form("/Messages.json", params)
    }
    
    fn send_scheduled(to: String, body: String, send_at: Instant) -> Result<TwilioMessage, TwilioError> {
        let msid = self.messaging_service_sid.clone()
            .ok_or(TwilioError.ConfigError("Messaging Service SID required for scheduled messages"))?
        
        var params = Map.empty()
        params.set("To", to)
        params.set("Body", body)
        params.set("MessagingServiceSid", msid)
        params.set("ScheduleType", "fixed")
        params.set("SendAt", send_at.to_iso8601())
        
        self.post_form("/Messages.json", params)
    }
    
    fn get_message(sid: String) -> Result<TwilioMessage, TwilioError> {
        self.get(format!("/Messages/{}.json", sid))
    }
    
    fn cancel_message(sid: String) -> Result<TwilioMessage, TwilioError> {
        var params = Map.empty()
        params.set("Status", "canceled")
        self.post_form(format!("/Messages/{}.json", sid), params)
    }
    
    fn list_messages(options: MessageListOptions) -> Result<TwilioMessageList, TwilioError> {
        var query = Vec.new()
        if let Some(to) = options.to { query.push(format!("To={}", to)) }
        if let Some(from) = options.from { query.push(format!("From={}", from)) }
        if let Some(date) = options.date_sent { query.push(format!("DateSent={}", date)) }
        if let Some(limit) = options.page_size { query.push(format!("PageSize={}", limit)) }
        
        let path = if query.is_empty() { "/Messages.json".to_string() } 
                   else { format!("/Messages.json?{}", query.join("&")) }
        self.get(path)
    }
    
    // Phone Number Methods
    fn lookup(phone: String) -> Result<TwilioLookup, TwilioError> {
        let url = format!("https://lookups.twilio.com/v1/PhoneNumbers/{}", phone)
        self.get_url(url)
    }
    
    fn lookup_with_carrier(phone: String) -> Result<TwilioLookup, TwilioError> {
        let url = format!("https://lookups.twilio.com/v1/PhoneNumbers/{}?Type=carrier", phone)
        self.get_url(url)
    }
    
    fn list_phone_numbers() -> Result<[TwilioPhoneNumber], TwilioError> {
        let result: TwilioPhoneNumberList = self.get("/IncomingPhoneNumbers.json")?
        Ok(result.incoming_phone_numbers)
    }
    
    fn buy_phone_number(phone: String) -> Result<TwilioPhoneNumber, TwilioError> {
        var params = Map.empty()
        params.set("PhoneNumber", phone)
        self.post_form("/IncomingPhoneNumbers.json", params)
    }
    
    fn search_available_numbers(country: String, options: NumberSearchOptions) -> Result<[AvailableNumber], TwilioError> {
        var query = Vec.new()
        if let Some(area) = options.area_code { query.push(format!("AreaCode={}", area)) }
        if let Some(contains) = options.contains { query.push(format!("Contains={}", contains)) }
        if options.sms_enabled { query.push("SmsEnabled=true") }
        if options.mms_enabled { query.push("MmsEnabled=true") }
        if options.voice_enabled { query.push("VoiceEnabled=true") }
        
        let path = format!("/AvailablePhoneNumbers/{}/Local.json?{}", country, query.join("&"))
        let result: AvailableNumberList = self.get(path)?
        Ok(result.available_phone_numbers)
    }
    
    // Account Methods
    fn get_balance() -> Result<TwilioBalance, TwilioError> {
        self.get("/Balance.json")
    }
    
    fn get_usage(category: String) -> Result<[TwilioUsageRecord], TwilioError> {
        let result: TwilioUsageList = self.get(format!("/Usage/Records.json?Category={}", category))?
        Ok(result.usage_records)
    }
    
    // HTTP Helpers
    fn get<T: Deserialize>(path: String) -> Result<T, TwilioError> {
        self.get_url(format!("{}{}", self.base_url, path))
    }
    
    fn get_url<T: Deserialize>(url: String) -> Result<T, TwilioError> {
        let response = self.http.get(url)
            .header("Authorization", self.auth_header())
            .timeout(self.timeout_ms)
            .send()
            .map_err(|e| TwilioError.NetworkError(e.to_string()))?
        
        self.handle_response(response)
    }
    
    fn post_form<T: Deserialize>(path: String, params: Map<String, String>) -> Result<T, TwilioError> {
        let body = params.iter().map(|(k, v)| format!("{}={}", k, url_encode(v))).collect::<Vec<_>>().join("&")
        
        let response = self.http.post(format!("{}{}", self.base_url, path))
            .header("Authorization", self.auth_header())
            .header("Content-Type", "application/x-www-form-urlencoded")
            .body(body)
            .timeout(self.timeout_ms)
            .send()
            .map_err(|e| TwilioError.NetworkError(e.to_string()))?
        
        self.handle_response(response)
    }
    
    fn handle_response<T: Deserialize>(response: Response) -> Result<T, TwilioError> {
        if response.status >= 200 && response.status < 300 {
            response.json().map_err(|e| TwilioError.ParseError(e.to_string()))
        } else {
            let error: TwilioApiError = response.json().unwrap_or(TwilioApiError { code: response.status, message: "Unknown error", more_info: None })
            Err(TwilioError.ApiError(error))
        }
    }
}

fn url_encode(s: &String) -> String {
    @native("url_encode", s)
}

// =============================================================================
// Twilio Types
// =============================================================================

struct TwilioMessage {
    sid: String
    account_sid: String
    from: Option<String>
    to: String
    body: String
    status: String
    direction: String
    date_created: String
    date_sent: Option<String>
    date_updated: String
    price: Option<String>
    price_unit: Option<String>
    num_segments: String
    num_media: String
    error_code: Option<Int>
    error_message: Option<String>
    messaging_service_sid: Option<String>
}

impl TwilioMessage {
    fn to_sms_status() -> SmsStatus {
        match self.status.as_str() {
            "queued" => SmsStatus.Queued,
            "sending" => SmsStatus.Sending,
            "sent" => SmsStatus.Sent,
            "delivered" => SmsStatus.Delivered,
            "failed" => SmsStatus.Failed,
            "undelivered" => SmsStatus.Undelivered,
            "canceled" => SmsStatus.Cancelled,
            _ => SmsStatus.Pending
        }
    }
    
    fn to_sms_result() -> SmsResult {
        var result = SmsResult.new(self.sid.clone(), self.sid.clone())
            .with_status(self.to_sms_status())
            .with_segments(self.num_segments.parse().unwrap_or(1))
        
        if let (Some(price), Some(unit)) = (self.price.clone(), self.price_unit.clone()) {
            if let Ok(amount) = price.parse::<Float>() {
                result = result.with_cost(amount.abs(), unit)
            }
        }
        
        if let (Some(code), Some(msg)) = (self.error_code, self.error_message.clone()) {
            result = result.with_error(code.to_string(), msg)
        }
        
        result
    }
}

struct TwilioMessageList {
    messages: [TwilioMessage]
    page: Int
    page_size: Int
    first_page_uri: String
    next_page_uri: Option<String>
    previous_page_uri: Option<String>
}

struct MessageListOptions {
    to: Option<String>
    from: Option<String>
    date_sent: Option<String>
    page_size: Option<Int>
}

impl MessageListOptions {
    fn new() -> Self { MessageListOptions { to: None, from: None, date_sent: None, page_size: None } }
    fn to(number: String) -> Self { self.to = Some(number); self }
    fn from(number: String) -> Self { self.from = Some(number); self }
    fn date(date: String) -> Self { self.date_sent = Some(date); self }
    fn limit(size: Int) -> Self { self.page_size = Some(size); self }
}

struct TwilioLookup {
    phone_number: String
    national_format: String
    country_code: String
    carrier: Option<CarrierInfo>
    caller_name: Option<CallerNameInfo>
}

struct CarrierInfo {
    name: String
    type_: String
    mobile_country_code: Option<String>
    mobile_network_code: Option<String>
}

struct CallerNameInfo {
    caller_name: String
    caller_type: String
}

struct TwilioPhoneNumber {
    sid: String
    phone_number: String
    friendly_name: String
    capabilities: PhoneCapabilities
    sms_url: Option<String>
    voice_url: Option<String>
}

struct TwilioPhoneNumberList {
    incoming_phone_numbers: [TwilioPhoneNumber]
}

struct PhoneCapabilities {
    sms: Bool
    mms: Bool
    voice: Bool
    fax: Bool
}

struct AvailableNumber {
    phone_number: String
    friendly_name: String
    locality: Option<String>
    region: Option<String>
    postal_code: Option<String>
    capabilities: PhoneCapabilities
}

struct AvailableNumberList {
    available_phone_numbers: [AvailableNumber]
}

struct NumberSearchOptions {
    area_code: Option<String>
    contains: Option<String>
    sms_enabled: Bool
    mms_enabled: Bool
    voice_enabled: Bool
}

impl NumberSearchOptions {
    fn new() -> Self { NumberSearchOptions { area_code: None, contains: None, sms_enabled: true, mms_enabled: false, voice_enabled: false } }
    fn area_code(code: String) -> Self { self.area_code = Some(code); self }
    fn contains(pattern: String) -> Self { self.contains = Some(pattern); self }
    fn with_mms() -> Self { self.mms_enabled = true; self }
    fn with_voice() -> Self { self.voice_enabled = true; self }
}

struct TwilioBalance {
    account_sid: String
    balance: String
    currency: String
}

struct TwilioUsageRecord {
    category: String
    description: String
    count: String
    count_unit: String
    usage: String
    usage_unit: String
    price: String
    price_unit: String
}

struct TwilioUsageList {
    usage_records: [TwilioUsageRecord]
}

struct TwilioApiError {
    code: Int
    message: String
    more_info: Option<String>
}

// =============================================================================
// SMS Provider Implementation
// =============================================================================

impl SmsProvider for TwilioClient {
    fn name() -> String { "twilio" }
    
    fn send(message: SmsMessage) -> Result<SmsResult, SmsError> {
        let from = if message.from.is_empty() {
            self.from_number.clone().or(self.messaging_service_sid.clone())
                .ok_or(SmsError.InvalidSender("No sender configured"))?
        } else {
            message.from.clone()
        }
        
        var params = Map.empty()
        params.set("To", message.to.clone())
        params.set("Body", message.body.clone())
        
        if self.messaging_service_sid.is_some() && message.from.is_empty() {
            params.set("MessagingServiceSid", self.messaging_service_sid.clone().unwrap())
        } else {
            params.set("From", from)
        }
        
        for url in message.media_urls.iter() {
            params.set("MediaUrl", url.clone())
        }
        
        if let Some(callback) = message.callback_url.clone() {
            params.set("StatusCallback", callback)
        }
        
        if let Some(scheduled) = message.scheduled_at {
            if let Some(msid) = self.messaging_service_sid.clone() {
                params.set("MessagingServiceSid", msid)
                params.set("ScheduleType", "fixed")
                params.set("SendAt", scheduled.to_iso8601())
            }
        }
        
        let result: TwilioMessage = self.post_form("/Messages.json", params)
            .map_err(|e| SmsError.ProviderError(e.to_string()))?
        
        Ok(result.to_sms_result())
    }
    
    fn send_batch(messages: [SmsMessage]) -> [Result<SmsResult, SmsError>] {
        messages.iter().map(|m| self.send(m.clone())).collect()
    }
    
    fn get_status(message_id: String) -> Result<SmsStatus, SmsError> {
        let msg = self.get_message(message_id).map_err(|e| SmsError.ProviderError(e.to_string()))?
        Ok(msg.to_sms_status())
    }
    
    fn cancel(message_id: String) -> Result<(), SmsError> {
        self.cancel_message(message_id).map_err(|e| SmsError.ProviderError(e.to_string()))?
        Ok(())
    }
    
    fn get_balance() -> Result<Float, SmsError> {
        let balance = self.get_balance().map_err(|e| SmsError.ProviderError(e.to_string()))?
        balance.balance.parse().map_err(|_| SmsError.ProviderError("Invalid balance format"))
    }
}

// =============================================================================
// Webhook Parsing
// =============================================================================

struct TwilioWebhook {
    message_sid: String
    account_sid: String
    from: String
    to: String
    body: String
    status: Option<String>
    error_code: Option<String>
    num_media: Option<Int>
    media_urls: [String]
}

impl TwilioWebhook {
    fn from_request(params: Map<String, String>) -> Result<Self, TwilioError> {
        let message_sid = params.get("MessageSid").ok_or(TwilioError.ParseError("Missing MessageSid"))?
        let account_sid = params.get("AccountSid").ok_or(TwilioError.ParseError("Missing AccountSid"))?
        let from = params.get("From").ok_or(TwilioError.ParseError("Missing From"))?
        let to = params.get("To").ok_or(TwilioError.ParseError("Missing To"))?
        
        let num_media = params.get("NumMedia").and_then(|s| s.parse().ok()).unwrap_or(0)
        var media_urls = Vec.new()
        for i in 0..num_media {
            if let Some(url) = params.get(format!("MediaUrl{}", i)) {
                media_urls.push(url.clone())
            }
        }
        
        Ok(TwilioWebhook {
            message_sid: message_sid.clone(),
            account_sid: account_sid.clone(),
            from: from.clone(),
            to: to.clone(),
            body: params.get("Body").cloned().unwrap_or_default(),
            status: params.get("MessageStatus").cloned(),
            error_code: params.get("ErrorCode").cloned(),
            num_media: Some(num_media),
            media_urls: media_urls
        })
    }
    
    fn is_incoming() -> Bool { self.status.is_none() }
    fn is_status_callback() -> Bool { self.status.is_some() }
    
    fn to_incoming_sms() -> IncomingSms {
        var sms = IncomingSms.new(self.from.clone(), self.to.clone(), self.body.clone())
        sms.media_urls = self.media_urls.clone()
        sms
    }
    
    fn to_delivery_report() -> DeliveryReport {
        let status = match self.status.as_ref().map(|s| s.as_str()) {
            Some("sent") => SmsStatus.Sent,
            Some("delivered") => SmsStatus.Delivered,
            Some("failed") => SmsStatus.Failed,
            Some("undelivered") => SmsStatus.Undelivered,
            _ => SmsStatus.Pending
        }
        
        var report = DeliveryReport.new(self.message_sid.clone(), status)
        if let Some(code) = self.error_code.clone() {
            report = report.with_error(code)
        }
        report
    }
}

/// Validate Twilio webhook signature
fn validate_webhook_signature(url: String, params: Map<String, String>, signature: String, auth_token: String) -> Bool {
    @native("twilio_validate_signature", url, params, signature, auth_token)
}

// =============================================================================
// TwiML Builder
// =============================================================================

struct TwiML {
    content: String
}

impl TwiML {
    fn new() -> Self { TwiML { content: "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Response>" } }
    
    fn message(body: String) -> Self {
        self.content.push_str(format!("<Message>{}</Message>", escape_xml(body)))
        self
    }
    
    fn message_to(to: String, body: String) -> Self {
        self.content.push_str(format!("<Message to=\"{}\">{}</Message>", to, escape_xml(body)))
        self
    }
    
    fn redirect(url: String) -> Self {
        self.content.push_str(format!("<Redirect>{}</Redirect>", url))
        self
    }
    
    fn build() -> String {
        format!("{}</Response>", self.content)
    }
}

fn escape_xml(s: String) -> String {
    s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;")
}

// =============================================================================
// Errors
// =============================================================================

enum TwilioError {
    ConfigError(String)
    ApiError(TwilioApiError)
    NetworkError(String)
    ParseError(String)
    AuthError
    RateLimited
    InvalidNumber
}

impl Display for TwilioError {
    fn fmt(f: Formatter) {
        match self {
            ConfigError(msg) => f.write(format!("Config error: {}", msg)),
            ApiError(e) => f.write(format!("Twilio API error {}: {}", e.code, e.message)),
            NetworkError(msg) => f.write(format!("Network error: {}", msg)),
            ParseError(msg) => f.write(format!("Parse error: {}", msg)),
            AuthError => f.write("Authentication failed"),
            RateLimited => f.write("Rate limited"),
            InvalidNumber => f.write("Invalid phone number")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "twilio client creation" {
    let client = TwilioClient.new("AC123", "token123").from("+15551234567")
    assert_eq(client.account_sid, "AC123")?
    assert_eq(client.from_number, Some("+15551234567"))?
}

test "message list options" {
    let opts = MessageListOptions.new().to("+1234").from("+5678").limit(10)
    assert_eq(opts.to, Some("+1234"))?
    assert_eq(opts.page_size, Some(10))?
}

test "number search options" {
    let opts = NumberSearchOptions.new().area_code("415").with_mms()
    assert_eq(opts.area_code, Some("415"))?
    assert(opts.mms_enabled)?
}

test "twiml builder" {
    let twiml = TwiML.new().message("Hello").build()
    assert(twiml.contains("<Message>Hello</Message>"))?
    assert(twiml.starts_with("<?xml"))?
}

test "webhook parsing" {
    var params = Map.empty()
    params.set("MessageSid", "SM123")
    params.set("AccountSid", "AC123")
    params.set("From", "+1234")
    params.set("To", "+5678")
    params.set("Body", "Test")
    
    let webhook = TwilioWebhook.from_request(params)?
    assert_eq(webhook.message_sid, "SM123")?
    assert(webhook.is_incoming())?
}
