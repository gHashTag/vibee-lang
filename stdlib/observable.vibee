// =============================================================================
// Vibee OS â€” Observable Module
// Reactive streams with push-based data flow
// =============================================================================

/// Observer trait - receives values from Observable
trait Observer<T> {
    fn on_next(value: T)
    fn on_error(err: Error)
    fn on_complete()
}

/// Observable trait - push-based reactive stream
trait Observable {
    type Item
    fn subscribe(observer: impl Observer<Self.Item>) -> Subscription
}

/// Core Observable implementation
struct ObservableCore<T> {
    subscribe_fn: fn(impl Observer<T>) -> Subscription
}

impl<T> Observable for ObservableCore<T> {
    type Item = T
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        (self.subscribe_fn)(observer)
    }
}

/// Create observable from subscribe function
fn create<T>(subscribe_fn: fn(impl Observer<T>) -> Subscription) -> ObservableCore<T> {
    ObservableCore { subscribe_fn: subscribe_fn }
}

/// Observable from single value
fn of<T>(value: T) -> ObservableCore<T> {
    create(|observer| {
        observer.on_next(value)
        observer.on_complete()
        Subscription.empty()
    })
}

/// Observable from multiple values
fn from_values<T>(values: [T]) -> ObservableCore<T> {
    create(|observer| {
        for v in values {
            observer.on_next(v)
        }
        observer.on_complete()
        Subscription.empty()
    })
}

/// Observable from iterator
fn from_iter<I: Iterator>(iter: I) -> ObservableCore<I.Item> {
    create(|observer| {
        for item in iter {
            observer.on_next(item)
        }
        observer.on_complete()
        Subscription.empty()
    })
}

/// Observable from Future
fn from_future<T>(future: Future<T>) -> ObservableCore<T> {
    create(|observer| {
        future.on_complete(|result| {
            match result {
                Ok(v) => { observer.on_next(v); observer.on_complete() }
                Err(e) => observer.on_error(e)
            }
        })
        Subscription.empty()
    })
}

/// Observable from channel
fn from_channel<T>(rx: Receiver<T>) -> ObservableCore<T> {
    create(|observer| {
        spawn {
            while let Some(v) = rx.recv() {
                observer.on_next(v)
            }
            observer.on_complete()
        }
        Subscription.new(|| rx.close())
    })
}

/// Empty observable - completes immediately
fn empty<T>() -> ObservableCore<T> {
    create(|observer| {
        observer.on_complete()
        Subscription.empty()
    })
}

/// Never observable - never emits or completes
fn never<T>() -> ObservableCore<T> {
    create(|_| Subscription.empty())
}

/// Error observable - emits error immediately
fn throw<T>(err: Error) -> ObservableCore<T> {
    create(|observer| {
        observer.on_error(err)
        Subscription.empty()
    })
}

/// Interval observable - emits sequential numbers at interval
fn interval(period_ms: Int64) -> ObservableCore<Int64> {
    create(|observer| {
        var count: Int64 = 0
        var cancelled = false
        let timer_id = @native("set_interval", period_ms, || {
            if !cancelled {
                observer.on_next(count)
                count += 1
            }
        })
        Subscription.new(|| {
            cancelled = true
            @native("clear_interval", timer_id)
        })
    })
}

/// Timer observable - emits once after delay
fn timer(delay_ms: Int64) -> ObservableCore<Int64> {
    create(|observer| {
        var cancelled = false
        let timer_id = @native("set_timeout", delay_ms, || {
            if !cancelled {
                observer.on_next(0)
                observer.on_complete()
            }
        })
        Subscription.new(|| {
            cancelled = true
            @native("clear_timeout", timer_id)
        })
    })
}

/// Range observable - emits range of integers
fn range(start: Int, count: Int) -> ObservableCore<Int> {
    create(|observer| {
        for i in start..(start + count) {
            observer.on_next(i)
        }
        observer.on_complete()
        Subscription.empty()
    })
}

/// Defer observable - creates new observable for each subscriber
fn defer<T>(factory: fn() -> impl Observable<Item = T>) -> ObservableCore<T> {
    create(|observer| {
        factory().subscribe(observer)
    })
}

/// Generate observable - generates values using accumulator
fn generate<T>(
    initial: T,
    condition: fn(T) -> Bool,
    iterate: fn(T) -> T
) -> ObservableCore<T> {
    create(|observer| {
        var state = initial
        while condition(state) {
            observer.on_next(state.clone())
            state = iterate(state)
        }
        observer.on_complete()
        Subscription.empty()
    })
}

/// Repeat observable - repeats value n times
fn repeat<T: Clone>(value: T, count: Int) -> ObservableCore<T> {
    create(|observer| {
        for _ in 0..count {
            observer.on_next(value.clone())
        }
        observer.on_complete()
        Subscription.empty()
    })
}

/// Hot observable wrapper - shares single subscription
actor HotObservable<T> {
    state source: impl Observable<Item = T>
    state observers: [impl Observer<T>]
    state subscription: Option<Subscription>
    state completed: Bool
    state error: Option<Error>
    
    fn new(source: impl Observable<Item = T>) -> Self {
        HotObservable {
            source: source,
            observers: [],
            subscription: None,
            completed: false,
            error: None
        }
    }
    
    fn connect() -> Subscription {
        if self.subscription.is_some() {
            return Subscription.empty()
        }
        
        let shared_observer = SharedObserver { hot: self }
        self.subscription = Some(self.source.subscribe(shared_observer))
        
        Subscription.new(|| {
            if let Some(sub) = self.subscription.take() {
                sub.unsubscribe()
            }
        })
    }
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        if self.completed {
            observer.on_complete()
            return Subscription.empty()
        }
        if let Some(err) = self.error {
            observer.on_error(err)
            return Subscription.empty()
        }
        
        self.observers.push(observer)
        let idx = self.observers.len() - 1
        
        Subscription.new(|| {
            self.observers.remove(idx)
        })
    }
    
    fn notify_next(value: T) {
        for obs in self.observers.iter() {
            obs.on_next(value.clone())
        }
    }
    
    fn notify_error(err: Error) {
        self.error = Some(err)
        for obs in self.observers.iter() {
            obs.on_error(err)
        }
        self.observers.clear()
    }
    
    fn notify_complete() {
        self.completed = true
        for obs in self.observers.iter() {
            obs.on_complete()
        }
        self.observers.clear()
    }
}

struct SharedObserver<T> {
    hot: HotObservable<T>
}

impl<T> Observer<T> for SharedObserver<T> {
    fn on_next(value: T) { self.hot.notify_next(value) }
    fn on_error(err: Error) { self.hot.notify_error(err) }
    fn on_complete() { self.hot.notify_complete() }
}

/// Connectable observable - multicast with manual connect
struct ConnectableObservable<T> {
    hot: HotObservable<T>
}

impl<T> ConnectableObservable<T> {
    fn new(source: impl Observable<Item = T>) -> Self {
        ConnectableObservable { hot: HotObservable.new(source) }
    }
    
    fn connect() -> Subscription {
        self.hot.connect()
    }
    
    fn ref_count() -> RefCountObservable<T> {
        RefCountObservable { hot: self.hot, ref_count: 0, connection: None }
    }
}

impl<T> Observable for ConnectableObservable<T> {
    type Item = T
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        self.hot.subscribe(observer)
    }
}

/// RefCount observable - auto-connect on first subscriber
struct RefCountObservable<T> {
    hot: HotObservable<T>
    ref_count: Int
    connection: Option<Subscription>
}

impl<T> Observable for RefCountObservable<T> {
    type Item = T
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        self.ref_count += 1
        if self.ref_count == 1 {
            self.connection = Some(self.hot.connect())
        }
        
        let sub = self.hot.subscribe(observer)
        
        Subscription.new(|| {
            sub.unsubscribe()
            self.ref_count -= 1
            if self.ref_count == 0 {
                if let Some(conn) = self.connection.take() {
                    conn.unsubscribe()
                }
            }
        })
    }
}

/// Simple observer implementation
struct SimpleObserver<T> {
    on_next_fn: fn(T)
    on_error_fn: fn(Error)
    on_complete_fn: fn()
}

impl<T> Observer<T> for SimpleObserver<T> {
    fn on_next(value: T) { (self.on_next_fn)(value) }
    fn on_error(err: Error) { (self.on_error_fn)(err) }
    fn on_complete() { (self.on_complete_fn)() }
}

fn observer<T>(
    on_next: fn(T),
    on_error: fn(Error),
    on_complete: fn()
) -> SimpleObserver<T> {
    SimpleObserver {
        on_next_fn: on_next,
        on_error_fn: on_error,
        on_complete_fn: on_complete
    }
}

/// Partial observer - only handles next
fn next_observer<T>(on_next: fn(T)) -> SimpleObserver<T> {
    observer(on_next, |_| {}, || {})
}

// Tests
test "of" {
    var result = []
    of(42).subscribe(next_observer(|v| result.push(v)))
    assert_eq(result, [42])?
}

test "from_values" {
    var result = []
    from_values([1, 2, 3]).subscribe(next_observer(|v| result.push(v)))
    assert_eq(result, [1, 2, 3])?
}

test "range" {
    var result = []
    range(1, 5).subscribe(next_observer(|v| result.push(v)))
    assert_eq(result, [1, 2, 3, 4, 5])?
}

test "empty completes" {
    var completed = false
    empty::<Int>().subscribe(observer(|_| {}, |_| {}, || completed = true))
    assert(completed)?
}

test "repeat" {
    var result = []
    repeat("x", 3).subscribe(next_observer(|v| result.push(v)))
    assert_eq(result, ["x", "x", "x"])?
}
