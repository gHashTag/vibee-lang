// =============================================================================
// Vibee OS â€” Runtime Debugger Module
// Runtime debugging, inspection, and diagnostics
// =============================================================================

// -----------------------------------------------------------------------------
// Debugger Configuration
// -----------------------------------------------------------------------------

/// Debugger configuration
struct DebuggerConfig {
    break_on_panic: Bool
    break_on_error: Bool
    log_level: LogLevel
    capture_stack: Bool
    max_stack_depth: Int
    watch_memory: Bool
    
    fn default() -> Self {
        DebuggerConfig {
            break_on_panic: true,
            break_on_error: false,
            log_level: LogLevel.Debug,
            capture_stack: true,
            max_stack_depth: 64,
            watch_memory: false
        }
    }
}

enum LogLevel {
    Trace
    Debug
    Info
    Warn
    Error
    
    fn priority() -> Int {
        match self {
            Trace => 0
            Debug => 1
            Info => 2
            Warn => 3
            Error => 4
        }
    }
}

// -----------------------------------------------------------------------------
// Runtime Debugger
// -----------------------------------------------------------------------------

/// Main runtime debugger
actor RuntimeDebugger {
    state config: DebuggerConfig
    state breakpoints: [Breakpoint]
    state watchpoints: [Watchpoint]
    state variables: Map<String, WatchedVariable>
    state call_stack: [CallFrame]
    state paused: Bool
    state step_mode: StepMode
    state history: [DebugEvent]
    state listeners: [(DebugEvent) -> ()]
    
    fn new() -> Self {
        Self.with_config(DebuggerConfig.default())
    }
    
    fn with_config(config: DebuggerConfig) -> Self {
        RuntimeDebugger {
            config: config,
            breakpoints: [],
            watchpoints: [],
            variables: Map.new(),
            call_stack: [],
            paused: false,
            step_mode: StepMode.Continue,
            history: [],
            listeners: []
        }
    }
    
    // -------------------------------------------------------------------------
    // Breakpoints
    // -------------------------------------------------------------------------
    
    /// Add breakpoint at file:line
    on add_breakpoint(file: String, line: Int) -> Int {
        let id = self.breakpoints.len()
        self.breakpoints.push(Breakpoint {
            id: id,
            file: file,
            line: line,
            condition: None,
            hit_count: 0,
            enabled: true
        })
        
        @native("debugger_set_breakpoint", file, line, id)
        id
    }
    
    /// Add conditional breakpoint
    on add_conditional_breakpoint(file: String, line: Int, condition: String) -> Int {
        let id = self.add_breakpoint(file, line)
        self.breakpoints[id].condition = Some(condition)
        id
    }
    
    /// Remove breakpoint
    on remove_breakpoint(id: Int) {
        if id < self.breakpoints.len() {
            let bp = self.breakpoints[id]
            @native("debugger_remove_breakpoint", bp.file, bp.line)
            self.breakpoints.remove(id)
        }
    }
    
    /// Enable/disable breakpoint
    on toggle_breakpoint(id: Int) {
        if id < self.breakpoints.len() {
            self.breakpoints[id].enabled = !self.breakpoints[id].enabled
        }
    }
    
    /// List all breakpoints
    fn list_breakpoints() -> [Breakpoint] {
        self.breakpoints.clone()
    }
    
    // -------------------------------------------------------------------------
    // Watchpoints
    // -------------------------------------------------------------------------
    
    /// Watch variable for changes
    on watch(name: String) -> Int {
        let id = self.watchpoints.len()
        self.watchpoints.push(Watchpoint {
            id: id,
            name: name,
            condition: WatchCondition.OnChange,
            last_value: None,
            enabled: true
        })
        
        @native("debugger_watch_variable", name, id)
        id
    }
    
    /// Watch with condition
    on watch_condition(name: String, condition: WatchCondition) -> Int {
        let id = self.watch(name)
        self.watchpoints[id].condition = condition
        id
    }
    
    /// Remove watchpoint
    on unwatch(id: Int) {
        if id < self.watchpoints.len() {
            let wp = self.watchpoints[id]
            @native("debugger_unwatch_variable", wp.name)
            self.watchpoints.remove(id)
        }
    }
    
    // -------------------------------------------------------------------------
    // Execution Control
    // -------------------------------------------------------------------------
    
    /// Continue execution
    on continue() {
        self.paused = false
        self.step_mode = StepMode.Continue
        @native("debugger_continue")
    }
    
    /// Step into next instruction
    on step_into() {
        self.step_mode = StepMode.StepInto
        @native("debugger_step_into")
    }
    
    /// Step over current instruction
    on step_over() {
        self.step_mode = StepMode.StepOver
        @native("debugger_step_over")
    }
    
    /// Step out of current function
    on step_out() {
        self.step_mode = StepMode.StepOut
        @native("debugger_step_out")
    }
    
    /// Pause execution
    on pause() {
        self.paused = true
        @native("debugger_pause")
        self.emit_event(DebugEvent.Paused(self.current_location()))
    }
    
    /// Check if paused
    fn is_paused() -> Bool { self.paused }
    
    // -------------------------------------------------------------------------
    // Inspection
    // -------------------------------------------------------------------------
    
    /// Get current call stack
    fn call_stack() -> [CallFrame] {
        if self.config.capture_stack {
            @native("debugger_get_call_stack", self.config.max_stack_depth)
        } else {
            self.call_stack.clone()
        }
    }
    
    /// Get local variables in current frame
    fn locals() -> Map<String, VariableInfo> {
        @native("debugger_get_locals")
    }
    
    /// Get variable value
    fn get_variable(name: String) -> Option<VariableInfo> {
        @native("debugger_get_variable", name)
    }
    
    /// Set variable value
    on set_variable(name: String, value: String) -> Result<(), String> {
        @native("debugger_set_variable", name, value)
    }
    
    /// Evaluate expression
    fn eval(expr: String) -> Result<String, String> {
        @native("debugger_eval", expr)
    }
    
    /// Get current source location
    fn current_location() -> SourceLocation {
        @native("debugger_current_location")
    }
    
    /// Get source code around location
    fn get_source(file: String, line: Int, context: Int) -> [SourceLine] {
        @native("debugger_get_source", file, line, context)
    }
    
    // -------------------------------------------------------------------------
    // Memory Inspection
    // -------------------------------------------------------------------------
    
    /// Read memory at address
    fn read_memory(address: Int, size: Int) -> [UInt8] {
        @native("debugger_read_memory", address, size)
    }
    
    /// Write memory at address
    on write_memory(address: Int, data: [UInt8]) {
        @native("debugger_write_memory", address, data)
    }
    
    /// Get memory map
    fn memory_map() -> [MemoryRegion] {
        @native("debugger_memory_map")
    }
    
    /// Find value in memory
    fn search_memory(pattern: [UInt8]) -> [Int] {
        @native("debugger_search_memory", pattern)
    }
    
    // -------------------------------------------------------------------------
    // Object Inspection
    // -------------------------------------------------------------------------
    
    /// Inspect object
    fn inspect<T>(obj: T) -> ObjectInfo {
        ObjectInfo {
            type_name: @native("type_name", obj),
            size: @native("size_of", obj),
            address: @native("address_of", obj),
            fields: @native("debugger_get_fields", obj),
            methods: @native("debugger_get_methods", obj)
        }
    }
    
    /// Get object graph
    fn object_graph<T>(root: T, depth: Int) -> ObjectGraph {
        var graph = ObjectGraph.new()
        self.build_object_graph(root, depth, graph)
        graph
    }
    
    fn build_object_graph<T>(obj: T, depth: Int, graph: ObjectGraph) {
        if depth <= 0 { return }
        
        let info = self.inspect(obj)
        let node = ObjectNode {
            id: info.address,
            type_name: info.type_name,
            size: info.size,
            fields: info.fields
        }
        
        graph.add_node(node)
        
        for field in info.fields {
            if field.is_reference {
                let child_addr = field.value as Int
                if child_addr != 0 {
                    graph.add_edge(info.address, child_addr)
                    // Recursively inspect child
                    let child = @native("debugger_deref", child_addr)
                    self.build_object_graph(child, depth - 1, graph)
                }
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // Event Handling
    // -------------------------------------------------------------------------
    
    /// Called when breakpoint is hit
    on on_breakpoint_hit(id: Int) {
        if id >= self.breakpoints.len() { return }
        
        let bp = self.breakpoints[id]
        if !bp.enabled { return }
        
        bp.hit_count += 1
        
        // Check condition
        if let Some(cond) = bp.condition {
            match self.eval(cond) {
                Ok(result) => {
                    if result != "true" { return }
                }
                Err(_) => { return }
            }
        }
        
        self.paused = true
        self.emit_event(DebugEvent.BreakpointHit(bp.clone()))
    }
    
    /// Called when watchpoint triggers
    on on_watchpoint_trigger(id: Int, old_value: String, new_value: String) {
        if id >= self.watchpoints.len() { return }
        
        let wp = self.watchpoints[id]
        if !wp.enabled { return }
        
        let should_break = match wp.condition {
            WatchCondition.OnChange => old_value != new_value
            WatchCondition.OnRead => true
            WatchCondition.OnWrite => true
            WatchCondition.Equals(v) => new_value == v
            WatchCondition.NotEquals(v) => new_value != v
        }
        
        if should_break {
            self.paused = true
            self.emit_event(DebugEvent.WatchpointTriggered(wp.name.clone(), old_value, new_value))
        }
        
        wp.last_value = Some(new_value)
    }
    
    /// Called on exception
    on on_exception(error: String, stack: [CallFrame]) {
        self.emit_event(DebugEvent.Exception(error, stack.clone()))
        
        if self.config.break_on_error {
            self.paused = true
            self.call_stack = stack
        }
    }
    
    /// Called on panic
    on on_panic(message: String, stack: [CallFrame]) {
        self.emit_event(DebugEvent.Panic(message, stack.clone()))
        
        if self.config.break_on_panic {
            self.paused = true
            self.call_stack = stack
        }
    }
    
    /// Register event listener
    on on_event(listener: (DebugEvent) -> ()) {
        self.listeners.push(listener)
    }
    
    fn emit_event(event: DebugEvent) {
        self.history.push(event.clone())
        for listener in self.listeners {
            listener(event.clone())
        }
    }
    
    // -------------------------------------------------------------------------
    // REPL
    // -------------------------------------------------------------------------
    
    /// Start interactive debug REPL
    on repl() {
        println("Vibee Runtime Debugger")
        println("Type 'help' for commands")
        println()
        
        loop {
            let input = @native("read_line", "dbg> ")
            let parts = input.trim().split(" ")
            let cmd = parts.first().unwrap_or("")
            let args = parts.skip(1).collect::<Vec<_>>()
            
            match cmd {
                "help" | "h" => self.print_help()
                "continue" | "c" => { self.continue(); break }
                "step" | "s" => { self.step_into(); break }
                "next" | "n" => { self.step_over(); break }
                "finish" | "f" => { self.step_out(); break }
                "break" | "b" => {
                    if args.len() >= 2 {
                        let file = args[0]
                        let line = args[1].parse::<Int>().unwrap_or(0)
                        let id = self.add_breakpoint(file, line)
                        println("Breakpoint \(id) set at \(file):\(line)")
                    }
                }
                "delete" | "d" => {
                    if let Some(id) = args.first().and_then(|s| s.parse::<Int>().ok()) {
                        self.remove_breakpoint(id)
                        println("Breakpoint \(id) deleted")
                    }
                }
                "list" | "l" => {
                    let loc = self.current_location()
                    let lines = self.get_source(loc.file, loc.line, 5)
                    for line in lines {
                        let marker = if line.line == loc.line { ">" } else { " " }
                        println("\(marker) \(line.line): \(line.text)")
                    }
                }
                "print" | "p" => {
                    let expr = args.join(" ")
                    match self.eval(expr) {
                        Ok(result) => println(result)
                        Err(e) => println("Error: \(e)")
                    }
                }
                "locals" => {
                    for (name, info) in self.locals() {
                        println("  \(name): \(info.type_name) = \(info.value)")
                    }
                }
                "stack" | "bt" => {
                    for (i, frame) in self.call_stack().enumerate() {
                        println("  #\(i) \(frame.function) at \(frame.file):\(frame.line)")
                    }
                }
                "watch" | "w" => {
                    if let Some(name) = args.first() {
                        let id = self.watch(name)
                        println("Watchpoint \(id) set on \(name)")
                    }
                }
                "info" => {
                    match args.first().map(|s| s.as_str()) {
                        Some("breakpoints") => {
                            for bp in self.list_breakpoints() {
                                let status = if bp.enabled { "enabled" } else { "disabled" }
                                println("  \(bp.id): \(bp.file):\(bp.line) [\(status)] hits=\(bp.hit_count)")
                            }
                        }
                        Some("watchpoints") => {
                            for wp in self.watchpoints {
                                let status = if wp.enabled { "enabled" } else { "disabled" }
                                println("  \(wp.id): \(wp.name) [\(status)]")
                            }
                        }
                        _ => println("Usage: info breakpoints|watchpoints")
                    }
                }
                "quit" | "q" => {
                    println("Exiting debugger")
                    @native("exit", 0)
                }
                "" => {}
                _ => println("Unknown command: \(cmd). Type 'help' for commands.")
            }
        }
    }
    
    fn print_help() {
        println("Commands:")
        println("  help (h)           - Show this help")
        println("  continue (c)       - Continue execution")
        println("  step (s)           - Step into")
        println("  next (n)           - Step over")
        println("  finish (f)         - Step out")
        println("  break (b) FILE LINE - Set breakpoint")
        println("  delete (d) ID      - Delete breakpoint")
        println("  list (l)           - Show source")
        println("  print (p) EXPR     - Evaluate expression")
        println("  locals             - Show local variables")
        println("  stack (bt)         - Show call stack")
        println("  watch (w) VAR      - Watch variable")
        println("  info breakpoints   - List breakpoints")
        println("  info watchpoints   - List watchpoints")
        println("  quit (q)           - Exit debugger")
    }
}

// -----------------------------------------------------------------------------
// Data Structures
// -----------------------------------------------------------------------------

struct Breakpoint {
    id: Int
    file: String
    line: Int
    condition: Option<String>
    hit_count: Int
    enabled: Bool
}

struct Watchpoint {
    id: Int
    name: String
    condition: WatchCondition
    last_value: Option<String>
    enabled: Bool
}

enum WatchCondition {
    OnChange
    OnRead
    OnWrite
    Equals(String)
    NotEquals(String)
}

enum StepMode {
    Continue
    StepInto
    StepOver
    StepOut
}

struct CallFrame {
    function: String
    file: String
    line: Int
    column: Int
    locals: Map<String, VariableInfo>
}

struct VariableInfo {
    name: String
    type_name: String
    value: String
    address: Int
    is_reference: Bool
}

struct SourceLocation {
    file: String
    line: Int
    column: Int
    function: String
}

struct SourceLine {
    line: Int
    text: String
}

struct MemoryRegion {
    start: Int
    end: Int
    permissions: String
    name: String
}

struct ObjectInfo {
    type_name: String
    size: Int
    address: Int
    fields: [FieldInfo]
    methods: [String]
}

struct FieldInfo {
    name: String
    type_name: String
    value: String
    offset: Int
    is_reference: Bool
}

struct ObjectGraph {
    nodes: Map<Int, ObjectNode>
    edges: [(Int, Int)]
    
    fn new() -> Self {
        ObjectGraph { nodes: Map.new(), edges: [] }
    }
    
    fn add_node(node: ObjectNode) {
        self.nodes.insert(node.id, node)
    }
    
    fn add_edge(from: Int, to: Int) {
        self.edges.push((from, to))
    }
    
    fn to_dot() -> String {
        var lines = ["digraph ObjectGraph {"]
        
        for (id, node) in self.nodes {
            lines.push("  n\(id) [label=\"\(node.type_name)\\n\(node.size) bytes\"];")
        }
        
        for (from, to) in self.edges {
            lines.push("  n\(from) -> n\(to);")
        }
        
        lines.push("}")
        lines.join("\n")
    }
}

struct ObjectNode {
    id: Int
    type_name: String
    size: Int
    fields: [FieldInfo]
}

enum DebugEvent {
    BreakpointHit(Breakpoint)
    WatchpointTriggered(String, String, String)
    Exception(String, [CallFrame])
    Panic(String, [CallFrame])
    Paused(SourceLocation)
    Resumed
    StepCompleted(SourceLocation)
}

// -----------------------------------------------------------------------------
// Watched Variable
// -----------------------------------------------------------------------------

struct WatchedVariable {
    name: String
    value: String
    history: [(Instant, String)]
    
    fn new(name: String, value: String) -> Self {
        WatchedVariable {
            name: name,
            value: value,
            history: [(Instant.now(), value)]
        }
    }
    
    fn update(new_value: String) {
        if new_value != self.value {
            self.value = new_value
            self.history.push((Instant.now(), new_value))
        }
    }
}

// -----------------------------------------------------------------------------
// Debug Assertions
// -----------------------------------------------------------------------------

/// Assert with debug break
macro debug_assert(condition, message = "Assertion failed") {
    if @debug_mode() && !condition {
        eprintln("DEBUG ASSERT: \(message)")
        eprintln("  Condition: \(stringify!(condition))")
        eprintln("  Location: \(@file()):\(@line())")
        RUNTIME_DEBUGGER.pause()
    }
}

/// Breakpoint macro
macro breakpoint() {
    if @debug_mode() {
        RUNTIME_DEBUGGER.pause()
        RUNTIME_DEBUGGER.repl()
    }
}

/// Conditional breakpoint
macro break_if(condition) {
    if @debug_mode() && condition {
        RUNTIME_DEBUGGER.pause()
        RUNTIME_DEBUGGER.repl()
    }
}

// -----------------------------------------------------------------------------
// Global Instance
// -----------------------------------------------------------------------------

var RUNTIME_DEBUGGER = RuntimeDebugger.new()

fn debugger() -> RuntimeDebugger {
    RUNTIME_DEBUGGER
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Quick inspect
fn dbg_inspect<T>(value: T) -> T {
    let info = RUNTIME_DEBUGGER.inspect(value)
    eprintln("[\(@file()):\(@line())] \(info.type_name) @ 0x\(info.address.to_hex())")
    for field in info.fields {
        eprintln("  .\(field.name): \(field.type_name) = \(field.value)")
    }
    value
}

/// Print call stack
fn print_stack() {
    let stack = RUNTIME_DEBUGGER.call_stack()
    eprintln("Call stack:")
    for (i, frame) in stack.enumerate() {
        eprintln("  #\(i) \(frame.function) at \(frame.file):\(frame.line)")
    }
}

/// Dump memory
fn dump_memory(address: Int, size: Int) {
    let data = RUNTIME_DEBUGGER.read_memory(address, size)
    eprintln("Memory at 0x\(address.to_hex()):")
    
    for (i, chunk) in data.chunks(16).enumerate() {
        var hex = ""
        var ascii = ""
        
        for byte in chunk {
            hex += format!("{:02x} ", byte)
            ascii += if byte >= 32 && byte < 127 { byte as Char } else { '.' }
        }
        
        eprintln("  \(format!("{:08x}", address + i * 16))  \(hex.pad_right(48))  |\(ascii)|")
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "breakpoint management" {
    let dbg = RuntimeDebugger.new()
    
    let id1 = dbg.add_breakpoint("test.vibee", 10)
    let id2 = dbg.add_breakpoint("test.vibee", 20)
    
    assert_eq(dbg.list_breakpoints().len(), 2)?
    
    dbg.remove_breakpoint(id1)
    assert_eq(dbg.list_breakpoints().len(), 1)?
}

test "watchpoint" {
    let dbg = RuntimeDebugger.new()
    
    let id = dbg.watch("my_var")
    assert_eq(dbg.watchpoints.len(), 1)?
    
    dbg.unwatch(id)
    assert_eq(dbg.watchpoints.len(), 0)?
}

test "object graph" {
    struct Node { value: Int, next: Option<Box<Node>> }
    
    let node = Node { value: 1, next: Some(Box.new(Node { value: 2, next: None })) }
    let dbg = RuntimeDebugger.new()
    
    let graph = dbg.object_graph(node, 3)
    assert(graph.nodes.len() >= 1)?
}

test "eval" {
    let dbg = RuntimeDebugger.new()
    
    // Note: eval depends on runtime support
    // This test just verifies the API exists
    let _ = dbg.eval("1 + 1")
}
