// =============================================================================
// Vibee OS â€” Object Detection Module
// Object detection, classification, and segmentation
// =============================================================================

use image::{Image, Pixel}
use tensor::{Tensor, Shape}

// -----------------------------------------------------------------------------
// Bounding Box
// -----------------------------------------------------------------------------

/// Bounding box for detected object
struct BoundingBox {
    x: Int
    y: Int
    width: Int
    height: Int
    
    fn new(x: Int, y: Int, width: Int, height: Int) -> Self {
        BoundingBox { x: x, y: y, width: width, height: height }
    }
    
    fn from_xyxy(x1: Int, y1: Int, x2: Int, y2: Int) -> Self {
        BoundingBox { x: x1, y: y1, width: x2 - x1, height: y2 - y1 }
    }
    
    fn from_center(cx: Int, cy: Int, width: Int, height: Int) -> Self {
        BoundingBox { x: cx - width / 2, y: cy - height / 2, width: width, height: height }
    }
    
    fn x1() -> Int { self.x }
    fn y1() -> Int { self.y }
    fn x2() -> Int { self.x + self.width }
    fn y2() -> Int { self.y + self.height }
    fn center() -> (Int, Int) { (self.x + self.width / 2, self.y + self.height / 2) }
    fn area() -> Int { self.width * self.height }
    
    fn contains(px: Int, py: Int) -> Bool {
        px >= self.x && px < self.x + self.width &&
        py >= self.y && py < self.y + self.height
    }
    
    fn intersects(other: BoundingBox) -> Bool {
        !(self.x2() < other.x1() || other.x2() < self.x1() ||
          self.y2() < other.y1() || other.y2() < self.y1())
    }
    
    fn intersection(other: BoundingBox) -> Option<BoundingBox> {
        let x1 = self.x.max(other.x)
        let y1 = self.y.max(other.y)
        let x2 = self.x2().min(other.x2())
        let y2 = self.y2().min(other.y2())
        
        if x2 > x1 && y2 > y1 {
            Some(BoundingBox.from_xyxy(x1, y1, x2, y2))
        } else { None }
    }
    
    fn union(other: BoundingBox) -> BoundingBox {
        let x1 = self.x.min(other.x)
        let y1 = self.y.min(other.y)
        let x2 = self.x2().max(other.x2())
        let y2 = self.y2().max(other.y2())
        BoundingBox.from_xyxy(x1, y1, x2, y2)
    }
    
    fn iou(other: BoundingBox) -> Float {
        if let Some(inter) = self.intersection(other) {
            let inter_area = inter.area()
            let union_area = self.area() + other.area() - inter_area
            inter_area as Float / union_area as Float
        } else { 0.0 }
    }
    
    fn scale(factor: Float) -> Self {
        let cx = self.x + self.width / 2
        let cy = self.y + self.height / 2
        let new_w = (self.width as Float * factor) as Int
        let new_h = (self.height as Float * factor) as Int
        BoundingBox.from_center(cx, cy, new_w, new_h)
    }
    
    fn pad(padding: Int) -> Self {
        BoundingBox.new(self.x - padding, self.y - padding,
                        self.width + 2 * padding, self.height + 2 * padding)
    }
    
    fn clip(img_width: Int, img_height: Int) -> Self {
        let x1 = self.x.max(0)
        let y1 = self.y.max(0)
        let x2 = self.x2().min(img_width)
        let y2 = self.y2().min(img_height)
        BoundingBox.from_xyxy(x1, y1, x2, y2)
    }
    
    fn to_normalized(img_width: Int, img_height: Int) -> NormalizedBox {
        NormalizedBox {
            x: self.x as Float / img_width as Float,
            y: self.y as Float / img_height as Float,
            width: self.width as Float / img_width as Float,
            height: self.height as Float / img_height as Float
        }
    }
}

/// Normalized bounding box (0-1 range)
struct NormalizedBox {
    x: Float
    y: Float
    width: Float
    height: Float
    
    fn to_absolute(img_width: Int, img_height: Int) -> BoundingBox {
        BoundingBox.new(
            (self.x * img_width as Float) as Int,
            (self.y * img_height as Float) as Int,
            (self.width * img_width as Float) as Int,
            (self.height * img_height as Float) as Int
        )
    }
}

// -----------------------------------------------------------------------------
// Object Classes
// -----------------------------------------------------------------------------

/// COCO dataset classes
enum CocoClass {
    Person, Bicycle, Car, Motorcycle, Airplane, Bus, Train, Truck, Boat,
    TrafficLight, FireHydrant, StopSign, ParkingMeter, Bench, Bird, Cat,
    Dog, Horse, Sheep, Cow, Elephant, Bear, Zebra, Giraffe, Backpack,
    Umbrella, Handbag, Tie, Suitcase, Frisbee, Skis, Snowboard, SportsBall,
    Kite, BaseballBat, BaseballGlove, Skateboard, Surfboard, TennisRacket,
    Bottle, WineGlass, Cup, Fork, Knife, Spoon, Bowl, Banana, Apple,
    Sandwich, Orange, Broccoli, Carrot, HotDog, Pizza, Donut, Cake, Chair,
    Couch, PottedPlant, Bed, DiningTable, Toilet, Tv, Laptop, Mouse,
    Remote, Keyboard, CellPhone, Microwave, Oven, Toaster, Sink,
    Refrigerator, Book, Clock, Vase, Scissors, TeddyBear, HairDrier, Toothbrush
    
    fn id() -> Int {
        match self {
            Person => 0, Bicycle => 1, Car => 2, Motorcycle => 3, Airplane => 4,
            Bus => 5, Train => 6, Truck => 7, Boat => 8, TrafficLight => 9,
            _ => 0
        }
    }
    
    fn name() -> String {
        match self {
            Person => "person", Bicycle => "bicycle", Car => "car",
            Motorcycle => "motorcycle", Airplane => "airplane", Bus => "bus",
            Train => "train", Truck => "truck", Boat => "boat",
            TrafficLight => "traffic light", Dog => "dog", Cat => "cat",
            _ => "unknown"
        }
    }
    
    fn from_id(id: Int) -> Self {
        match id {
            0 => CocoClass.Person, 1 => CocoClass.Bicycle, 2 => CocoClass.Car,
            3 => CocoClass.Motorcycle, 4 => CocoClass.Airplane, 5 => CocoClass.Bus,
            _ => CocoClass.Person
        }
    }
}

/// Object class with custom labels
struct ObjectClass {
    id: Int
    name: String
    supercategory: Option<String>
    
    fn new(id: Int, name: String) -> Self {
        ObjectClass { id: id, name: name, supercategory: None }
    }
    
    fn with_supercategory(id: Int, name: String, super_cat: String) -> Self {
        ObjectClass { id: id, name: name, supercategory: Some(super_cat) }
    }
}

// -----------------------------------------------------------------------------
// Detection Result
// -----------------------------------------------------------------------------

/// Detected object
struct Detection {
    bbox: BoundingBox
    class_id: Int
    class_name: String
    confidence: Float
    mask: Option<Tensor>
    keypoints: Option<[(Int, Int, Float)]>
    
    fn new(bbox: BoundingBox, class_id: Int, class_name: String, confidence: Float) -> Self {
        Detection {
            bbox: bbox, class_id: class_id, class_name: class_name,
            confidence: confidence, mask: None, keypoints: None
        }
    }
    
    fn with_mask(bbox: BoundingBox, class_id: Int, class_name: String, 
                 confidence: Float, mask: Tensor) -> Self {
        var det = Detection.new(bbox, class_id, class_name, confidence)
        det.mask = Some(mask)
        det
    }
    
    fn crop(image: Image) -> Image {
        image.crop(self.bbox.x, self.bbox.y, self.bbox.width, self.bbox.height)
    }
    
    fn area() -> Int { self.bbox.area() }
    fn center() -> (Int, Int) { self.bbox.center() }
    
    fn is_class(name: String) -> Bool {
        self.class_name.to_lowercase() == name.to_lowercase()
    }
}

/// Detection results container
struct Detections {
    items: [Detection]
    image_width: Int
    image_height: Int
    
    fn new(items: [Detection], width: Int, height: Int) -> Self {
        Detections { items: items, image_width: width, image_height: height }
    }
    
    fn empty(width: Int, height: Int) -> Self {
        Detections { items: [], image_width: width, image_height: height }
    }
    
    fn len() -> Int { self.items.len() }
    fn is_empty() -> Bool { self.items.is_empty() }
    
    fn filter_by_class(class_name: String) -> Self {
        let filtered = self.items.iter()
            .filter(|d| d.is_class(class_name))
            .cloned()
            .collect()
        Detections.new(filtered, self.image_width, self.image_height)
    }
    
    fn filter_by_confidence(threshold: Float) -> Self {
        let filtered = self.items.iter()
            .filter(|d| d.confidence >= threshold)
            .cloned()
            .collect()
        Detections.new(filtered, self.image_width, self.image_height)
    }
    
    fn filter_by_area(min_area: Int, max_area: Int) -> Self {
        let filtered = self.items.iter()
            .filter(|d| d.area() >= min_area && d.area() <= max_area)
            .cloned()
            .collect()
        Detections.new(filtered, self.image_width, self.image_height)
    }
    
    fn sort_by_confidence() -> Self {
        var sorted = self.items.clone()
        sorted.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap())
        Detections.new(sorted, self.image_width, self.image_height)
    }
    
    fn top_k(k: Int) -> Self {
        let sorted = self.sort_by_confidence()
        Detections.new(sorted.items.into_iter().take(k).collect(), 
                       self.image_width, self.image_height)
    }
    
    fn get_class_counts() -> Map<String, Int> {
        var counts = Map.new()
        for det in self.items {
            let count = counts.get(&det.class_name).unwrap_or(&0) + 1
            counts.insert(det.class_name.clone(), count)
        }
        counts
    }
    
    fn contains_class(class_name: String) -> Bool {
        self.items.iter().any(|d| d.is_class(class_name))
    }
    
    fn count_class(class_name: String) -> Int {
        self.items.iter().filter(|d| d.is_class(class_name)).count()
    }
}

// -----------------------------------------------------------------------------
// Object Detector Models
// -----------------------------------------------------------------------------

/// Detection model architecture
enum DetectorModel {
    YOLOv5,
    YOLOv8,
    YOLOv9,
    YOLOX,
    SSD,
    FasterRCNN,
    MaskRCNN,
    RetinaNet,
    EfficientDet,
    DETR,
    RTDetr
    
    fn name() -> String {
        match self {
            YOLOv5 => "yolov5", YOLOv8 => "yolov8", YOLOv9 => "yolov9",
            YOLOX => "yolox", SSD => "ssd", FasterRCNN => "faster_rcnn",
            MaskRCNN => "mask_rcnn", RetinaNet => "retinanet",
            EfficientDet => "efficientdet", DETR => "detr", RTDetr => "rt_detr"
        }
    }
    
    fn supports_segmentation() -> Bool {
        match self {
            MaskRCNN => true,
            YOLOv8 => true,
            _ => false
        }
    }
}

/// Model size variant
enum ModelSize { Nano, Small, Medium, Large, XLarge }

/// Detector configuration
struct DetectorConfig {
    model: DetectorModel
    size: ModelSize
    confidence_threshold: Float
    nms_threshold: Float
    max_detections: Int
    classes: Option<[String]>
    input_size: (Int, Int)
    
    fn new() -> Self {
        DetectorConfig {
            model: DetectorModel.YOLOv8,
            size: ModelSize.Medium,
            confidence_threshold: 0.25,
            nms_threshold: 0.45,
            max_detections: 300,
            classes: None,
            input_size: (640, 640)
        }
    }
    
    fn with_model(model: DetectorModel) -> Self { self.model = model; self }
    fn with_size(size: ModelSize) -> Self { self.size = size; self }
    fn with_confidence(conf: Float) -> Self { self.confidence_threshold = conf; self }
    fn with_nms(nms: Float) -> Self { self.nms_threshold = nms; self }
    fn with_classes(classes: [String]) -> Self { self.classes = Some(classes); self }
    fn with_input_size(w: Int, h: Int) -> Self { self.input_size = (w, h); self }
}

// -----------------------------------------------------------------------------
// Object Detector
// -----------------------------------------------------------------------------

/// Main object detector
struct ObjectDetector {
    config: DetectorConfig
    model_path: Option<String>
    class_names: [String]
    
    fn new() -> Self {
        ObjectDetector {
            config: DetectorConfig.new(),
            model_path: None,
            class_names: []
        }
    }
    
    fn with_config(config: DetectorConfig) -> Self {
        ObjectDetector { config: config, model_path: None, class_names: [] }
    }
    
    fn load(path: String) -> Result<Self, DetectionError> {
        var detector = ObjectDetector.new()
        detector.model_path = Some(path)
        detector.class_names = @native("detector_load", path)?
        Ok(detector)
    }
    
    fn load_pretrained(model: DetectorModel, size: ModelSize) -> Result<Self, DetectionError> {
        var config = DetectorConfig.new()
        config.model = model
        config.size = size
        var detector = ObjectDetector.with_config(config)
        detector.class_names = @native("detector_load_pretrained", model, size)?
        Ok(detector)
    }
    
    fn detect(image: Image) -> Result<Detections, DetectionError> {
        let raw_detections = @native("object_detect", image, self.config)?
        Ok(Detections.new(raw_detections, image.width, image.height))
    }
    
    fn detect_batch(images: [Image]) -> Result<[Detections], DetectionError> {
        images.iter().map(|img| self.detect(img.clone())).collect()
    }
    
    fn detect_with_segmentation(image: Image) -> Result<Detections, DetectionError> {
        if !self.config.model.supports_segmentation() {
            return Err(DetectionError.UnsupportedOperation("Segmentation not supported"))
        }
        @native("object_detect_segment", image, self.config)
    }
}

// -----------------------------------------------------------------------------
// Specialized Detectors
// -----------------------------------------------------------------------------

/// Person detector
struct PersonDetector {
    detector: ObjectDetector
    
    fn new() -> Self {
        var config = DetectorConfig.new()
        config.classes = Some(["person"])
        PersonDetector { detector: ObjectDetector.with_config(config) }
    }
    
    fn detect(image: Image) -> Result<Detections, DetectionError> {
        self.detector.detect(image)
    }
    
    fn count(image: Image) -> Result<Int, DetectionError> {
        Ok(self.detect(image)?.len())
    }
}

/// Vehicle detector
struct VehicleDetector {
    detector: ObjectDetector
    
    fn new() -> Self {
        var config = DetectorConfig.new()
        config.classes = Some(["car", "truck", "bus", "motorcycle", "bicycle"])
        VehicleDetector { detector: ObjectDetector.with_config(config) }
    }
    
    fn detect(image: Image) -> Result<Detections, DetectionError> {
        self.detector.detect(image)
    }
    
    fn count_by_type(image: Image) -> Result<Map<String, Int>, DetectionError> {
        Ok(self.detect(image)?.get_class_counts())
    }
}

/// Animal detector
struct AnimalDetector {
    detector: ObjectDetector
    
    fn new() -> Self {
        var config = DetectorConfig.new()
        config.classes = Some(["dog", "cat", "bird", "horse", "cow", "sheep", "elephant", "bear", "zebra", "giraffe"])
        AnimalDetector { detector: ObjectDetector.with_config(config) }
    }
    
    fn detect(image: Image) -> Result<Detections, DetectionError> {
        self.detector.detect(image)
    }
}

// -----------------------------------------------------------------------------
// Non-Maximum Suppression
// -----------------------------------------------------------------------------

/// NMS algorithm
fn nms(detections: [Detection], iou_threshold: Float) -> [Detection] {
    var sorted = detections.clone()
    sorted.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap())
    
    var keep = []
    var suppressed = [false; sorted.len()]
    
    for i in 0..sorted.len() {
        if suppressed[i] { continue }
        keep.push(sorted[i].clone())
        
        for j in (i + 1)..sorted.len() {
            if suppressed[j] { continue }
            if sorted[i].bbox.iou(sorted[j].bbox) > iou_threshold {
                suppressed[j] = true
            }
        }
    }
    
    keep
}

/// Soft-NMS algorithm
fn soft_nms(detections: [Detection], sigma: Float = 0.5, threshold: Float = 0.001) -> [Detection] {
    var dets = detections.clone()
    var keep = []
    
    while !dets.is_empty() {
        // Find max confidence
        let max_idx = dets.iter().enumerate()
            .max_by(|(_, a), (_, b)| a.confidence.partial_cmp(&b.confidence).unwrap())
            .map(|(i, _)| i)
            .unwrap_or(0)
        
        let max_det = dets.remove(max_idx)
        keep.push(max_det.clone())
        
        // Decay overlapping detections
        for det in dets.iter_mut() {
            let iou = max_det.bbox.iou(det.bbox)
            let weight = (-iou * iou / sigma).exp()
            det.confidence *= weight
        }
        
        // Remove low confidence
        dets.retain(|d| d.confidence > threshold)
    }
    
    keep
}

// -----------------------------------------------------------------------------
// Object Tracking
// -----------------------------------------------------------------------------

/// Tracked object
struct TrackedObject {
    id: Int
    detection: Detection
    track_id: Int
    age: Int
    hits: Int
    time_since_update: Int
    
    fn new(id: Int, detection: Detection) -> Self {
        TrackedObject {
            id: id, detection: detection, track_id: id,
            age: 1, hits: 1, time_since_update: 0
        }
    }
    
    fn update(detection: Detection) {
        self.detection = detection
        self.hits += 1
        self.time_since_update = 0
        self.age += 1
    }
    
    fn predict() {
        self.time_since_update += 1
        self.age += 1
    }
    
    fn is_confirmed() -> Bool { self.hits >= 3 }
    fn is_deleted() -> Bool { self.time_since_update > 30 }
}

/// Simple object tracker (SORT-like)
struct ObjectTracker {
    tracks: [TrackedObject]
    next_id: Int
    max_age: Int
    min_hits: Int
    iou_threshold: Float
    
    fn new() -> Self {
        ObjectTracker {
            tracks: [], next_id: 0, max_age: 30, min_hits: 3, iou_threshold: 0.3
        }
    }
    
    fn update(detections: Detections) -> [TrackedObject] {
        // Predict existing tracks
        for track in self.tracks.iter_mut() {
            track.predict()
        }
        
        // Match detections to tracks
        var matched_tracks = []
        var unmatched_dets = detections.items.clone()
        
        for track in self.tracks.iter_mut() {
            var best_iou = self.iou_threshold
            var best_idx: Option<Int> = None
            
            for (i, det) in unmatched_dets.iter().enumerate() {
                let iou = track.detection.bbox.iou(det.bbox)
                if iou > best_iou {
                    best_iou = iou
                    best_idx = Some(i)
                }
            }
            
            if let Some(idx) = best_idx {
                track.update(unmatched_dets.remove(idx))
                matched_tracks.push(track.clone())
            }
        }
        
        // Create new tracks for unmatched detections
        for det in unmatched_dets {
            let track = TrackedObject.new(self.next_id, det)
            self.next_id += 1
            self.tracks.push(track)
        }
        
        // Remove old tracks
        self.tracks.retain(|t| !t.is_deleted())
        
        // Return confirmed tracks
        self.tracks.iter().filter(|t| t.is_confirmed()).cloned().collect()
    }
    
    fn reset() {
        self.tracks.clear()
        self.next_id = 0
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

/// Detection errors
enum DetectionError {
    ModelNotLoaded,
    InvalidImage,
    ProcessingError(String),
    UnsupportedOperation(String),
    IoError(String)
}

impl Display for DetectionError {
    fn fmt(f: Formatter) {
        match self {
            ModelNotLoaded => f.write("Detection model not loaded"),
            InvalidImage => f.write("Invalid image format"),
            ProcessingError(msg) => f.write(format!("Processing error: {}", msg)),
            UnsupportedOperation(msg) => f.write(format!("Unsupported: {}", msg)),
            IoError(msg) => f.write(format!("IO error: {}", msg))
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Detect objects in an image
fn detect_objects(image: Image) -> Result<Detections, DetectionError> {
    ObjectDetector.new().detect(image)
}

/// Detect specific class
fn detect_class(image: Image, class_name: String) -> Result<Detections, DetectionError> {
    let dets = detect_objects(image)?
    Ok(dets.filter_by_class(class_name))
}

/// Count objects in image
fn count_objects(image: Image) -> Result<Int, DetectionError> {
    Ok(detect_objects(image)?.len())
}

/// Count specific class
fn count_class(image: Image, class_name: String) -> Result<Int, DetectionError> {
    Ok(detect_class(image, class_name)?.len())
}

/// Check if image contains object
fn contains_object(image: Image, class_name: String) -> Result<Bool, DetectionError> {
    Ok(detect_objects(image)?.contains_class(class_name))
}

/// Detect people in image
fn detect_people(image: Image) -> Result<Detections, DetectionError> {
    PersonDetector.new().detect(image)
}

/// Count people in image
fn count_people(image: Image) -> Result<Int, DetectionError> {
    PersonDetector.new().count(image)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "bounding_box_iou" {
    let box1 = BoundingBox.new(0, 0, 100, 100)
    let box2 = BoundingBox.new(50, 50, 100, 100)
    let iou = box1.iou(box2)
    assert(iou > 0.0 && iou < 1.0)?
}

test "bounding_box_center" {
    let box = BoundingBox.new(100, 100, 50, 50)
    assert_eq(box.center(), (125, 125))?
}

test "bounding_box_from_xyxy" {
    let box = BoundingBox.from_xyxy(10, 20, 110, 120)
    assert_eq(box.x, 10)?
    assert_eq(box.y, 20)?
    assert_eq(box.width, 100)?
    assert_eq(box.height, 100)?
}

test "detection_filter" {
    let det1 = Detection.new(BoundingBox.new(0, 0, 50, 50), 0, "person", 0.9)
    let det2 = Detection.new(BoundingBox.new(100, 100, 50, 50), 2, "car", 0.8)
    let dets = Detections.new([det1, det2], 640, 480)
    
    let people = dets.filter_by_class("person")
    assert_eq(people.len(), 1)?
}

test "nms_basic" {
    let det1 = Detection.new(BoundingBox.new(0, 0, 100, 100), 0, "person", 0.9)
    let det2 = Detection.new(BoundingBox.new(10, 10, 100, 100), 0, "person", 0.8)
    let det3 = Detection.new(BoundingBox.new(200, 200, 100, 100), 0, "person", 0.7)
    
    let result = nms([det1, det2, det3], 0.5)
    assert_eq(result.len(), 2)?
}

test "tracker_basic" {
    var tracker = ObjectTracker.new()
    let det = Detection.new(BoundingBox.new(100, 100, 50, 50), 0, "person", 0.9)
    let dets = Detections.new([det], 640, 480)
    
    let tracks = tracker.update(dets)
    assert(tracks.len() >= 0)?
}
