// =============================================================================
// Vibee OS â€” Stream Module
// Reactive data streams
// =============================================================================

/// Stream trait
trait Stream {
    type Item
    fn poll_next() -> Poll<Option<Self.Item>>
    
    fn next() -> Option<Self.Item> { loop { match self.poll_next() { Poll.Ready(v) => return v, Poll.Pending => @native("yield") } } }
    fn map<U>(f: fn(Self.Item) -> U) -> Map<Self, U> { Map { stream: self, f: f } }
    fn filter(pred: fn(Self.Item) -> Bool) -> Filter<Self> { Filter { stream: self, pred: pred } }
    fn filter_map<U>(f: fn(Self.Item) -> Option<U>) -> FilterMap<Self, U> { FilterMap { stream: self, f: f } }
    fn take(n: Int) -> Take<Self> { Take { stream: self, remaining: n } }
    fn skip(n: Int) -> Skip<Self> { Skip { stream: self, remaining: n } }
    fn take_while(pred: fn(Self.Item) -> Bool) -> TakeWhile<Self> { TakeWhile { stream: self, pred: pred, done: false } }
    fn chain<S: Stream<Item = Self.Item>>(other: S) -> Chain<Self, S> { Chain { first: self, second: other, first_done: false } }
    fn zip<S: Stream>(other: S) -> Zip<Self, S> { Zip { a: self, b: other } }
    fn enumerate() -> Enumerate<Self> { Enumerate { stream: self, index: 0 } }
    fn flatten() -> Flatten<Self> where Self.Item: Stream { Flatten { stream: self, current: None } }
    fn flat_map<U, S: Stream<Item = U>>(f: fn(Self.Item) -> S) -> FlatMap<Self, U, S> { FlatMap { stream: self, f: f, current: None } }
    fn buffer(size: Int) -> Buffered<Self> { Buffered { stream: self, buffer: [], size: size } }
    fn throttle(ms: Int64) -> Throttle<Self> { Throttle { stream: self, interval_ms: ms, last: 0 } }
    fn debounce(ms: Int64) -> Debounce<Self> { Debounce { stream: self, delay_ms: ms, pending: None, deadline: 0 } }
    
    fn collect() -> [Self.Item] { var result = []; while let Some(item) = self.next() { result.push(item) } result }
    fn for_each(f: fn(Self.Item)) { while let Some(item) = self.next() { f(item) } }
    fn fold<A>(init: A, f: fn(A, Self.Item) -> A) -> A { var acc = init; while let Some(item) = self.next() { acc = f(acc, item) } acc }
    fn count() -> Int { var n = 0; while self.next().is_some() { n += 1 } n }
    fn any(pred: fn(Self.Item) -> Bool) -> Bool { while let Some(item) = self.next() { if pred(item) { return true } } false }
    fn all(pred: fn(Self.Item) -> Bool) -> Bool { while let Some(item) = self.next() { if !pred(item) { return false } } true }
}

enum Poll<T> { Ready(T), Pending }

/// Stream adapters
struct Map<S, U> { stream: S, f: fn(S.Item) -> U }
impl<S: Stream, U> Stream for Map<S, U> { type Item = U; fn poll_next() -> Poll<Option<U>> { match self.stream.poll_next() { Poll.Ready(Some(v)) => Poll.Ready(Some((self.f)(v))), Poll.Ready(None) => Poll.Ready(None), Poll.Pending => Poll.Pending } } }

struct Filter<S> { stream: S, pred: fn(S.Item) -> Bool }
impl<S: Stream> Stream for Filter<S> { type Item = S.Item; fn poll_next() -> Poll<Option<S.Item>> { loop { match self.stream.poll_next() { Poll.Ready(Some(v)) if (self.pred)(v) => return Poll.Ready(Some(v)), Poll.Ready(Some(_)) => continue, Poll.Ready(None) => return Poll.Ready(None), Poll.Pending => return Poll.Pending } } } }

struct FilterMap<S, U> { stream: S, f: fn(S.Item) -> Option<U> }
impl<S: Stream, U> Stream for FilterMap<S, U> { type Item = U; fn poll_next() -> Poll<Option<U>> { loop { match self.stream.poll_next() { Poll.Ready(Some(v)) => if let Some(u) = (self.f)(v) { return Poll.Ready(Some(u)) }, Poll.Ready(None) => return Poll.Ready(None), Poll.Pending => return Poll.Pending } } } }

struct Take<S> { stream: S, remaining: Int }
impl<S: Stream> Stream for Take<S> { type Item = S.Item; fn poll_next() -> Poll<Option<S.Item>> { if self.remaining == 0 { return Poll.Ready(None) } match self.stream.poll_next() { Poll.Ready(Some(v)) => { self.remaining -= 1; Poll.Ready(Some(v)) }, other => other } } }

struct Skip<S> { stream: S, remaining: Int }
impl<S: Stream> Stream for Skip<S> { type Item = S.Item; fn poll_next() -> Poll<Option<S.Item>> { while self.remaining > 0 { match self.stream.poll_next() { Poll.Ready(Some(_)) => self.remaining -= 1, other => return other } } self.stream.poll_next() } }

struct TakeWhile<S> { stream: S, pred: fn(S.Item) -> Bool, done: Bool }
impl<S: Stream> Stream for TakeWhile<S> { type Item = S.Item; fn poll_next() -> Poll<Option<S.Item>> { if self.done { return Poll.Ready(None) } match self.stream.poll_next() { Poll.Ready(Some(v)) if (self.pred)(v) => Poll.Ready(Some(v)), Poll.Ready(Some(_)) => { self.done = true; Poll.Ready(None) }, other => other } } }

struct Chain<A, B> { first: A, second: B, first_done: Bool }
impl<A: Stream, B: Stream<Item = A.Item>> Stream for Chain<A, B> { type Item = A.Item; fn poll_next() -> Poll<Option<A.Item>> { if !self.first_done { match self.first.poll_next() { Poll.Ready(None) => self.first_done = true, other => return other } } self.second.poll_next() } }

struct Zip<A, B> { a: A, b: B }
impl<A: Stream, B: Stream> Stream for Zip<A, B> { type Item = (A.Item, B.Item); fn poll_next() -> Poll<Option<Self.Item>> { match (self.a.poll_next(), self.b.poll_next()) { (Poll.Ready(Some(a)), Poll.Ready(Some(b))) => Poll.Ready(Some((a, b))), (Poll.Ready(None), _) | (_, Poll.Ready(None)) => Poll.Ready(None), _ => Poll.Pending } } }

struct Enumerate<S> { stream: S, index: Int }
impl<S: Stream> Stream for Enumerate<S> { type Item = (Int, S.Item); fn poll_next() -> Poll<Option<Self.Item>> { match self.stream.poll_next() { Poll.Ready(Some(v)) => { let i = self.index; self.index += 1; Poll.Ready(Some((i, v))) }, Poll.Ready(None) => Poll.Ready(None), Poll.Pending => Poll.Pending } } }

struct Flatten<S> where S.Item: Stream { stream: S, current: Option<S.Item> }
impl<S: Stream> Stream for Flatten<S> where S.Item: Stream { type Item = <S.Item as Stream>.Item; fn poll_next() -> Poll<Option<Self.Item>> { loop { if let Some(ref mut cur) = self.current { match cur.poll_next() { Poll.Ready(Some(v)) => return Poll.Ready(Some(v)), Poll.Ready(None) => self.current = None, Poll.Pending => return Poll.Pending } } match self.stream.poll_next() { Poll.Ready(Some(s)) => self.current = Some(s), Poll.Ready(None) => return Poll.Ready(None), Poll.Pending => return Poll.Pending } } } }

struct FlatMap<S, U, T> { stream: S, f: fn(S.Item) -> T, current: Option<T> }
impl<S: Stream, U, T: Stream<Item = U>> Stream for FlatMap<S, U, T> { type Item = U; fn poll_next() -> Poll<Option<U>> { loop { if let Some(ref mut cur) = self.current { match cur.poll_next() { Poll.Ready(Some(v)) => return Poll.Ready(Some(v)), Poll.Ready(None) => self.current = None, Poll.Pending => return Poll.Pending } } match self.stream.poll_next() { Poll.Ready(Some(v)) => self.current = Some((self.f)(v)), Poll.Ready(None) => return Poll.Ready(None), Poll.Pending => return Poll.Pending } } } }

struct Buffered<S> { stream: S, buffer: [S.Item], size: Int }
impl<S: Stream> Stream for Buffered<S> { type Item = [S.Item]; fn poll_next() -> Poll<Option<Self.Item>> { while self.buffer.len() < self.size { match self.stream.poll_next() { Poll.Ready(Some(v)) => self.buffer.push(v), Poll.Ready(None) => { if self.buffer.is_empty() { return Poll.Ready(None) } let buf = self.buffer.clone(); self.buffer.clear(); return Poll.Ready(Some(buf)) }, Poll.Pending => return Poll.Pending } } let buf = self.buffer.clone(); self.buffer.clear(); Poll.Ready(Some(buf)) } }

struct Throttle<S> { stream: S, interval_ms: Int64, last: Int64 }
impl<S: Stream> Stream for Throttle<S> { type Item = S.Item; fn poll_next() -> Poll<Option<S.Item>> { let now = @native("timestamp_ms"); if now - self.last < self.interval_ms { return Poll.Pending } match self.stream.poll_next() { Poll.Ready(Some(v)) => { self.last = now; Poll.Ready(Some(v)) }, other => other } } }

struct Debounce<S> { stream: S, delay_ms: Int64, pending: Option<S.Item>, deadline: Int64 }
impl<S: Stream> Stream for Debounce<S> { type Item = S.Item; fn poll_next() -> Poll<Option<S.Item>> { loop { match self.stream.poll_next() { Poll.Ready(Some(v)) => { self.pending = Some(v); self.deadline = @native("timestamp_ms") + self.delay_ms }, Poll.Ready(None) => return Poll.Ready(self.pending.take()), Poll.Pending => { if self.pending.is_some() && @native("timestamp_ms") >= self.deadline { return Poll.Ready(self.pending.take()) } return Poll.Pending } } } } }

/// Create stream from iterator
fn from_iter<I: Iterator>(iter: I) -> IterStream<I> { IterStream { iter: iter } }
struct IterStream<I> { iter: I }
impl<I: Iterator> Stream for IterStream<I> { type Item = I.Item; fn poll_next() -> Poll<Option<I.Item>> { Poll.Ready(self.iter.next()) } }

/// Create stream from channel
fn from_channel<T>(rx: Receiver<T>) -> ChannelStream<T> { ChannelStream { rx: rx } }
struct ChannelStream<T> { rx: Receiver<T> }
impl<T> Stream for ChannelStream<T> { type Item = T; fn poll_next() -> Poll<Option<T>> { match self.rx.try_recv() { Some(v) => Poll.Ready(Some(v)), None if self.rx.is_closed() => Poll.Ready(None), None => Poll.Pending } } }

/// Interval stream
fn interval(ms: Int64) -> Interval { Interval { interval_ms: ms, next: @native("timestamp_ms") + ms } }
struct Interval { interval_ms: Int64, next: Int64 }
impl Stream for Interval { type Item = Int64; fn poll_next() -> Poll<Option<Int64>> { let now = @native("timestamp_ms"); if now >= self.next { self.next = now + self.interval_ms; Poll.Ready(Some(now)) } else { Poll.Pending } } }

/// Empty stream
fn empty<T>() -> Empty<T> { Empty {} }
struct Empty<T> {}
impl<T> Stream for Empty<T> { type Item = T; fn poll_next() -> Poll<Option<T>> { Poll.Ready(None) } }

/// Once stream
fn once<T>(value: T) -> Once<T> { Once { value: Some(value) } }
struct Once<T> { value: Option<T> }
impl<T> Stream for Once<T> { type Item = T; fn poll_next() -> Poll<Option<T>> { Poll.Ready(self.value.take()) } }

/// Repeat stream
fn repeat<T: Clone>(value: T) -> Repeat<T> { Repeat { value: value } }
struct Repeat<T: Clone> { value: T }
impl<T: Clone> Stream for Repeat<T> { type Item = T; fn poll_next() -> Poll<Option<T>> { Poll.Ready(Some(self.value.clone())) } }

// Tests
test "map filter" {
    let s = from_iter([1, 2, 3, 4, 5].iter()).map(|x| x * 2).filter(|x| x > 4)
    assert_eq(s.collect(), [6, 8, 10])?
}

test "take" {
    let s = from_iter([1, 2, 3, 4, 5].iter()).take(3)
    assert_eq(s.collect(), [1, 2, 3])?
}

test "enumerate" {
    let s = from_iter(["a", "b", "c"].iter()).enumerate()
    assert_eq(s.collect(), [(0, "a"), (1, "b"), (2, "c")])?
}
