// =============================================================================
// Vibee OS â€” Game Loop Module
// Core game loop with fixed timestep and frame management
// =============================================================================

use time_timer::Timer
use instant::Instant

// -----------------------------------------------------------------------------
// Game Loop Configuration
// -----------------------------------------------------------------------------

/// Configuration for the game loop
struct GameLoopConfig {
    target_fps: Int
    fixed_timestep: Float64
    max_frame_skip: Int
    vsync: Bool
    uncapped: Bool
    
    fn new() -> Self {
        GameLoopConfig {
            target_fps: 60,
            fixed_timestep: 1.0 / 60.0,
            max_frame_skip: 5,
            vsync: true,
            uncapped: false
        }
    }
    
    fn with_fps(fps: Int) -> Self { self.target_fps = fps; self.fixed_timestep = 1.0 / fps as Float64; self }
    fn with_fixed_timestep(dt: Float64) -> Self { self.fixed_timestep = dt; self }
    fn with_max_frame_skip(skip: Int) -> Self { self.max_frame_skip = skip; self }
    fn with_vsync(enabled: Bool) -> Self { self.vsync = enabled; self }
    fn uncapped() -> Self { self.uncapped = true; self }
}

// -----------------------------------------------------------------------------
// Frame Time
// -----------------------------------------------------------------------------

/// Frame timing information
struct FrameTime {
    delta: Float64
    total: Float64
    frame_count: UInt64
    fps: Float64
    fixed_delta: Float64
    alpha: Float64
    
    fn new(fixed_dt: Float64) -> Self {
        FrameTime {
            delta: 0.0, total: 0.0, frame_count: 0,
            fps: 0.0, fixed_delta: fixed_dt, alpha: 0.0
        }
    }
    
    fn delta_f32() -> Float { self.delta as Float }
    fn total_f32() -> Float { self.total as Float }
}

// -----------------------------------------------------------------------------
// Game Loop State
// -----------------------------------------------------------------------------

enum GameLoopState {
    Running,
    Paused,
    Stopped
}

// -----------------------------------------------------------------------------
// Game Trait
// -----------------------------------------------------------------------------

/// Trait that games must implement
trait Game {
    /// Called once at startup
    fn init()
    
    /// Called at fixed timestep for physics/logic
    fn fixed_update(dt: Float64)
    
    /// Called every frame for rendering
    fn update(dt: Float64)
    
    /// Called for rendering
    fn render(alpha: Float64)
    
    /// Called on shutdown
    fn shutdown()
    
    /// Handle window/input events
    fn on_event(event: GameEvent) -> Bool { false }
}

// -----------------------------------------------------------------------------
// Game Events
// -----------------------------------------------------------------------------

enum GameEvent {
    WindowClose,
    WindowResize(Int, Int),
    WindowFocus(Bool),
    KeyDown(Int),
    KeyUp(Int),
    MouseMove(Float, Float),
    MouseDown(Int),
    MouseUp(Int),
    MouseScroll(Float, Float),
    GamepadConnect(Int),
    GamepadDisconnect(Int),
    Custom(String, Any)
}

// -----------------------------------------------------------------------------
// Game Loop
// -----------------------------------------------------------------------------

/// Main game loop with fixed timestep
struct GameLoop {
    config: GameLoopConfig
    state: GameLoopState
    frame_time: FrameTime
    accumulator: Float64
    last_time: Instant
    fps_timer: Float64
    fps_counter: Int
    current_fps: Float64
    
    fn new(config: GameLoopConfig) -> Self {
        GameLoop {
            config: config,
            state: GameLoopState.Stopped,
            frame_time: FrameTime.new(config.fixed_timestep),
            accumulator: 0.0,
            last_time: Instant.now(),
            fps_timer: 0.0,
            fps_counter: 0,
            current_fps: 0.0
        }
    }
    
    fn default() -> Self {
        GameLoop.new(GameLoopConfig.new())
    }
    
    /// Run the game loop
    fn run<G: Game>(game: &mut G) {
        game.init()
        self.state = GameLoopState.Running
        self.last_time = Instant.now()
        
        while self.state == GameLoopState.Running {
            self.tick(game)
        }
        
        game.shutdown()
    }
    
    /// Single tick of the game loop
    fn tick<G: Game>(game: &mut G) {
        let now = Instant.now()
        var frame_delta = now.duration_since(self.last_time).as_secs_f64()
        self.last_time = now
        
        // Cap frame delta to prevent spiral of death
        if frame_delta > 0.25 { frame_delta = 0.25 }
        
        self.frame_time.delta = frame_delta
        self.frame_time.total += frame_delta
        self.frame_time.frame_count += 1
        
        // FPS calculation
        self.fps_timer += frame_delta
        self.fps_counter += 1
        if self.fps_timer >= 1.0 {
            self.current_fps = self.fps_counter as Float64 / self.fps_timer
            self.frame_time.fps = self.current_fps
            self.fps_timer = 0.0
            self.fps_counter = 0
        }
        
        // Process events
        self.process_events(game)
        
        if self.state == GameLoopState.Paused { return }
        
        // Fixed timestep updates
        self.accumulator += frame_delta
        var updates = 0
        
        while self.accumulator >= self.config.fixed_timestep && updates < self.config.max_frame_skip {
            game.fixed_update(self.config.fixed_timestep)
            self.accumulator -= self.config.fixed_timestep
            updates += 1
        }
        
        // Variable update
        game.update(frame_delta)
        
        // Render with interpolation alpha
        self.frame_time.alpha = self.accumulator / self.config.fixed_timestep
        game.render(self.frame_time.alpha)
        
        // Frame limiting
        if !self.config.uncapped && !self.config.vsync {
            let target_frame_time = 1.0 / self.config.target_fps as Float64
            let elapsed = Instant.now().duration_since(now).as_secs_f64()
            if elapsed < target_frame_time {
                @native("sleep_secs", target_frame_time - elapsed)
            }
        }
    }
    
    fn process_events<G: Game>(game: &mut G) {
        while let Some(event) = @native("poll_event") as Option<GameEvent> {
            match event {
                WindowClose => self.stop(),
                _ => { game.on_event(event); }
            }
        }
    }
    
    /// Pause the game loop
    fn pause() { self.state = GameLoopState.Paused }
    
    /// Resume the game loop
    fn resume() { self.state = GameLoopState.Running }
    
    /// Stop the game loop
    fn stop() { self.state = GameLoopState.Stopped }
    
    /// Check if running
    fn is_running() -> Bool { self.state == GameLoopState.Running }
    
    /// Check if paused
    fn is_paused() -> Bool { self.state == GameLoopState.Paused }
    
    /// Get current FPS
    fn fps() -> Float64 { self.current_fps }
    
    /// Get frame time info
    fn time() -> &FrameTime { &self.frame_time }
}

// -----------------------------------------------------------------------------
// Async Game Loop (Actor-based)
// -----------------------------------------------------------------------------

actor GameLoopActor {
    game_loop: GameLoop
    game: Box<dyn Game>
    
    fn new(config: GameLoopConfig, game: Box<dyn Game>) -> Self {
        GameLoopActor {
            game_loop: GameLoop.new(config),
            game: game
        }
    }
    
    async fn start() {
        self.game.init()
        self.game_loop.state = GameLoopState.Running
        self.game_loop.last_time = Instant.now()
        self.run_loop().await
    }
    
    async fn run_loop() {
        while self.game_loop.state == GameLoopState.Running {
            self.game_loop.tick(&mut *self.game)
            @native("yield_now").await
        }
        self.game.shutdown()
    }
    
    fn pause() { self.game_loop.pause() }
    fn resume() { self.game_loop.resume() }
    fn stop() { self.game_loop.stop() }
}

// -----------------------------------------------------------------------------
// Time Scaling
// -----------------------------------------------------------------------------

/// Time scale for slow-motion or fast-forward effects
struct TimeScale {
    scale: Float64
    target_scale: Float64
    transition_speed: Float64
    
    fn new() -> Self {
        TimeScale { scale: 1.0, target_scale: 1.0, transition_speed: 5.0 }
    }
    
    fn set(s: Float64) { self.scale = s; self.target_scale = s }
    fn set_target(s: Float64) { self.target_scale = s }
    fn set_transition_speed(speed: Float64) { self.transition_speed = speed }
    
    fn update(dt: Float64) {
        if self.scale != self.target_scale {
            let diff = self.target_scale - self.scale
            let change = diff.signum() * self.transition_speed * dt
            if change.abs() >= diff.abs() {
                self.scale = self.target_scale
            } else {
                self.scale += change
            }
        }
    }
    
    fn apply(dt: Float64) -> Float64 { dt * self.scale }
    fn is_paused() -> Bool { self.scale == 0.0 }
    fn is_slow_motion() -> Bool { self.scale > 0.0 && self.scale < 1.0 }
}

// -----------------------------------------------------------------------------
// Frame Rate Limiter
// -----------------------------------------------------------------------------

struct FrameRateLimiter {
    target_fps: Int
    frame_time: Float64
    last_frame: Instant
    
    fn new(fps: Int) -> Self {
        FrameRateLimiter {
            target_fps: fps,
            frame_time: 1.0 / fps as Float64,
            last_frame: Instant.now()
        }
    }
    
    fn wait() {
        let now = Instant.now()
        let elapsed = now.duration_since(self.last_frame).as_secs_f64()
        if elapsed < self.frame_time {
            @native("sleep_secs", self.frame_time - elapsed)
        }
        self.last_frame = Instant.now()
    }
    
    fn set_fps(fps: Int) {
        self.target_fps = fps
        self.frame_time = 1.0 / fps as Float64
    }
}

// -----------------------------------------------------------------------------
// Delta Time Smoother
// -----------------------------------------------------------------------------

struct DeltaTimeSmoother {
    samples: [Float64]
    max_samples: Int
    index: Int
    
    fn new(sample_count: Int) -> Self {
        DeltaTimeSmoother {
            samples: [0.0; sample_count],
            max_samples: sample_count,
            index: 0
        }
    }
    
    fn add(dt: Float64) {
        self.samples[self.index] = dt
        self.index = (self.index + 1) % self.max_samples
    }
    
    fn smoothed() -> Float64 {
        let sum: Float64 = self.samples.iter().sum()
        sum / self.max_samples as Float64
    }
}

// -----------------------------------------------------------------------------
// Performance Stats
// -----------------------------------------------------------------------------

struct PerformanceStats {
    frame_times: [Float64]
    update_times: [Float64]
    render_times: [Float64]
    max_samples: Int
    index: Int
    
    fn new(sample_count: Int) -> Self {
        PerformanceStats {
            frame_times: [],
            update_times: [],
            render_times: [],
            max_samples: sample_count,
            index: 0
        }
    }
    
    fn record_frame(time: Float64) { self.add_sample(&mut self.frame_times, time) }
    fn record_update(time: Float64) { self.add_sample(&mut self.update_times, time) }
    fn record_render(time: Float64) { self.add_sample(&mut self.render_times, time) }
    
    fn add_sample(samples: &mut [Float64], value: Float64) {
        if samples.len() < self.max_samples {
            samples.push(value)
        } else {
            samples[self.index % self.max_samples] = value
        }
        self.index += 1
    }
    
    fn avg_frame_time() -> Float64 { self.average(&self.frame_times) }
    fn avg_update_time() -> Float64 { self.average(&self.update_times) }
    fn avg_render_time() -> Float64 { self.average(&self.render_times) }
    
    fn average(samples: &[Float64]) -> Float64 {
        if samples.is_empty() { return 0.0 }
        samples.iter().sum::<Float64>() / samples.len() as Float64
    }
    
    fn max_frame_time() -> Float64 { self.frame_times.iter().max().unwrap_or(0.0) }
    fn min_frame_time() -> Float64 { self.frame_times.iter().min().unwrap_or(0.0) }
    
    fn percentile_frame_time(p: Float64) -> Float64 {
        if self.frame_times.is_empty() { return 0.0 }
        var sorted = self.frame_times.clone()
        sorted.sort()
        let idx = ((sorted.len() - 1) as Float64 * p) as Int
        sorted[idx]
    }
}

// -----------------------------------------------------------------------------
// Simple Runner
// -----------------------------------------------------------------------------

/// Simple function to run a game
fn run<G: Game>(game: &mut G) {
    GameLoop.default().run(game)
}

/// Run with custom config
fn run_with_config<G: Game>(game: &mut G, config: GameLoopConfig) {
    GameLoop.new(config).run(game)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "game loop config" {
    let config = GameLoopConfig.new().with_fps(120)
    assert_eq(config.target_fps, 120)?
    assert_eq(config.fixed_timestep, 1.0 / 120.0)?
}

test "frame time" {
    var ft = FrameTime.new(1.0 / 60.0)
    ft.delta = 0.016
    ft.total = 1.0
    assert_eq(ft.delta_f32(), 0.016 as Float)?
}

test "time scale" {
    var ts = TimeScale.new()
    ts.set(0.5)
    assert_eq(ts.apply(1.0), 0.5)?
    assert(ts.is_slow_motion())?
}

test "delta time smoother" {
    var smoother = DeltaTimeSmoother.new(4)
    smoother.add(0.016)
    smoother.add(0.017)
    smoother.add(0.015)
    smoother.add(0.016)
    let avg = smoother.smoothed()
    assert(avg > 0.015 && avg < 0.017)?
}

test "frame rate limiter" {
    let limiter = FrameRateLimiter.new(60)
    assert_eq(limiter.target_fps, 60)?
    assert_eq(limiter.frame_time, 1.0 / 60.0)?
}
