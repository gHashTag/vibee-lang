// =============================================================================
// Vibee OS â€” UDP Module
// UDP datagram socket operations
// =============================================================================

use net.{IpAddr, SocketAddr, UdpSocket, NetError}

/// UDP Datagram socket with advanced features
struct UdpDatagram {
    socket: UdpSocket
    broadcast: Bool
    multicast_loop: Bool
    ttl: Option<Int>
}

impl UdpDatagram {
    /// Bind to a local address
    fn bind(addr: String) -> Result<Self, UdpError> {
        let socket_addr = SocketAddr.parse(addr)?
        let socket = UdpSocket.bind(socket_addr)?
        Ok(UdpDatagram {
            socket: socket,
            broadcast: false,
            multicast_loop: true,
            ttl: None
        })
    }
    
    /// Bind to any available port
    fn bind_any() -> Result<Self, UdpError> {
        Self.bind("0.0.0.0:0")
    }
    
    /// Bind to any available port on IPv6
    fn bind_any_v6() -> Result<Self, UdpError> {
        Self.bind("[::]:0")
    }
    
    /// Connect to a remote address (for send/recv)
    fn connect(addr: String) -> Result<(), UdpError> {
        let socket_addr = SocketAddr.parse(addr)?
        self.socket.connect(socket_addr).map_err(UdpError.from_net)
    }
    
    /// Send data to connected address
    fn send(data: [UInt8]) -> Result<Int, UdpError> {
        self.socket.send(data).map_err(UdpError.from_net)
    }
    
    /// Receive data from connected address
    fn recv(buf: [UInt8]) -> Result<Int, UdpError> {
        self.socket.recv(buf).map_err(UdpError.from_net)
    }
    
    /// Send data to a specific address
    fn send_to(data: [UInt8], addr: String) -> Result<Int, UdpError> {
        let socket_addr = SocketAddr.parse(addr)?
        self.socket.send_to(data, socket_addr).map_err(UdpError.from_net)
    }
    
    /// Receive data and get sender address
    fn recv_from(buf: [UInt8]) -> Result<(Int, SocketAddr), UdpError> {
        self.socket.recv_from(buf).map_err(UdpError.from_net)
    }
    
    /// Enable broadcast
    fn broadcast(enabled: Bool) -> Self {
        self.broadcast = enabled
        self.socket.set_broadcast(enabled)
        self
    }
    
    /// Set TTL (Time To Live)
    fn ttl(ttl: Int) -> Self {
        self.ttl = Some(ttl)
        @native("udp_set_ttl", self.socket, ttl)
        self
    }
    
    /// Set multicast TTL
    fn multicast_ttl(ttl: Int) -> Self {
        @native("udp_set_multicast_ttl", self.socket, ttl)
        self
    }
    
    /// Enable/disable multicast loopback
    fn multicast_loop(enabled: Bool) -> Self {
        self.multicast_loop = enabled
        self.socket.set_multicast_loop(enabled)
        self
    }
    
    /// Join a multicast group
    fn join_multicast(group: String) -> Result<(), UdpError> {
        let ip = IpAddr.parse(group)?
        self.socket.join_multicast(ip).map_err(UdpError.from_net)
    }
    
    /// Join multicast group on specific interface
    fn join_multicast_interface(group: String, interface: String) -> Result<(), UdpError> {
        let group_ip = IpAddr.parse(group)?
        let iface_ip = IpAddr.parse(interface)?
        @native("udp_join_multicast_iface", self.socket, group_ip, iface_ip)
    }
    
    /// Leave a multicast group
    fn leave_multicast(group: String) -> Result<(), UdpError> {
        let ip = IpAddr.parse(group)?
        self.socket.leave_multicast(ip).map_err(UdpError.from_net)
    }
    
    /// Get local address
    fn local_addr() -> Result<SocketAddr, UdpError> {
        self.socket.local_addr().map_err(UdpError.from_net)
    }
    
    /// Set receive buffer size
    fn recv_buffer_size(size: Int) -> Self {
        @native("udp_set_recv_buffer", self.socket, size)
        self
    }
    
    /// Set send buffer size
    fn send_buffer_size(size: Int) -> Self {
        @native("udp_set_send_buffer", self.socket, size)
        self
    }
    
    /// Set non-blocking mode
    fn nonblocking(enabled: Bool) -> Self {
        @native("udp_set_nonblocking", self.socket, enabled)
        self
    }
    
    /// Set receive timeout
    fn recv_timeout(ms: Int64) -> Self {
        @native("udp_set_recv_timeout", self.socket, ms)
        self
    }
    
    /// Set send timeout
    fn send_timeout(ms: Int64) -> Self {
        @native("udp_set_send_timeout", self.socket, ms)
        self
    }
}

/// UDP Message with metadata
struct UdpMessage {
    data: [UInt8]
    source: SocketAddr
    timestamp: Int64
}

impl UdpMessage {
    fn new(data: [UInt8], source: SocketAddr) -> Self {
        UdpMessage {
            data: data,
            source: source,
            timestamp: @native("timestamp_ms")
        }
    }
    
    fn as_string() -> Result<String, UdpError> {
        String.from_utf8(self.data).map_err(|_| UdpError.InvalidData)
    }
    
    fn len() -> Int {
        self.data.len()
    }
}

/// UDP Server for receiving datagrams
actor UdpServer {
    state socket: UdpDatagram
    state running: Bool
    state buffer_size: Int
    state on_message: Option<fn(UdpMessage)>
    state on_error: Option<fn(UdpError)>
}

impl UdpServer {
    /// Create a new UDP server
    fn new(addr: String) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind(addr)?
        Ok(UdpServer {
            socket: socket,
            running: false,
            buffer_size: 65535,
            on_message: None,
            on_error: None
        })
    }
    
    /// Set buffer size for receiving
    fn buffer_size(size: Int) -> Self {
        self.buffer_size = size
        self
    }
    
    /// Set message handler
    fn on_message(handler: fn(UdpMessage)) -> Self {
        self.on_message = Some(handler)
        self
    }
    
    /// Set error handler
    fn on_error(handler: fn(UdpError)) -> Self {
        self.on_error = Some(handler)
        self
    }
    
    /// Start receiving messages
    fn run() -> Result<(), UdpError> {
        self.running = true
        var buf = [0u8; self.buffer_size]
        
        while self.running {
            match self.socket.recv_from(buf) {
                Ok((n, addr)) => {
                    let msg = UdpMessage.new(buf[0..n].to_vec(), addr)
                    if let Some(handler) = self.on_message {
                        spawn { handler(msg) }
                    }
                }
                Err(e) => {
                    if let Some(handler) = self.on_error {
                        handler(e)
                    }
                }
            }
        }
        Ok(())
    }
    
    /// Stop the server
    fn stop() {
        self.running = false
    }
    
    /// Send a response
    fn reply(msg: UdpMessage, data: [UInt8]) -> Result<Int, UdpError> {
        self.socket.send_to(data, msg.source.to_string())
    }
    
    /// Get local address
    fn local_addr() -> Result<SocketAddr, UdpError> {
        self.socket.local_addr()
    }
}

/// UDP Client for sending datagrams
struct UdpClient {
    socket: UdpDatagram
    target: String
}

impl UdpClient {
    /// Create a new UDP client
    fn new(target: String) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind_any()?
        socket.connect(target)?
        Ok(UdpClient {
            socket: socket,
            target: target
        })
    }
    
    /// Create with specific local address
    fn with_local(local: String, target: String) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind(local)?
        socket.connect(target)?
        Ok(UdpClient {
            socket: socket,
            target: target
        })
    }
    
    /// Send data
    fn send(data: [UInt8]) -> Result<Int, UdpError> {
        self.socket.send(data)
    }
    
    /// Send string
    fn send_str(s: String) -> Result<Int, UdpError> {
        self.send(s.as_bytes())
    }
    
    /// Receive data
    fn recv(buf: [UInt8]) -> Result<Int, UdpError> {
        self.socket.recv(buf)
    }
    
    /// Receive with timeout
    fn recv_timeout(buf: [UInt8], timeout_ms: Int64) -> Result<Int, UdpError> {
        self.socket.recv_timeout(timeout_ms)
        self.socket.recv(buf)
    }
    
    /// Send and receive (request-response pattern)
    fn request(data: [UInt8], timeout_ms: Int64) -> Result<[UInt8], UdpError> {
        self.send(data)?
        var buf = [0u8; 65535]
        self.socket.recv_timeout(timeout_ms)
        let n = self.socket.recv(buf)?
        Ok(buf[0..n].to_vec())
    }
}

/// Multicast group manager
struct MulticastGroup {
    socket: UdpDatagram
    group: String
    port: Int
}

impl MulticastGroup {
    /// Join a multicast group
    fn join(group: String, port: Int) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind(format!("0.0.0.0:{}", port))?
        socket.join_multicast(group)?
        Ok(MulticastGroup {
            socket: socket,
            group: group,
            port: port
        })
    }
    
    /// Join with specific interface
    fn join_on(group: String, port: Int, interface: String) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind(format!("{}:{}", interface, port))?
        socket.join_multicast_interface(group, interface)?
        Ok(MulticastGroup {
            socket: socket,
            group: group,
            port: port
        })
    }
    
    /// Send to the multicast group
    fn send(data: [UInt8]) -> Result<Int, UdpError> {
        self.socket.send_to(data, format!("{}:{}", self.group, self.port))
    }
    
    /// Receive from the multicast group
    fn recv(buf: [UInt8]) -> Result<(Int, SocketAddr), UdpError> {
        self.socket.recv_from(buf)
    }
    
    /// Set multicast TTL
    fn ttl(ttl: Int) -> Self {
        self.socket.multicast_ttl(ttl)
        self
    }
    
    /// Enable/disable loopback
    fn loopback(enabled: Bool) -> Self {
        self.socket.multicast_loop(enabled)
        self
    }
    
    /// Leave the group
    fn leave() -> Result<(), UdpError> {
        self.socket.leave_multicast(self.group)
    }
}

/// Broadcast sender
struct Broadcast {
    socket: UdpDatagram
    port: Int
}

impl Broadcast {
    /// Create a broadcast sender
    fn new(port: Int) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind_any()?
        socket.broadcast(true)
        Ok(Broadcast {
            socket: socket,
            port: port
        })
    }
    
    /// Send broadcast message
    fn send(data: [UInt8]) -> Result<Int, UdpError> {
        self.socket.send_to(data, format!("255.255.255.255:{}", self.port))
    }
    
    /// Send to specific subnet broadcast
    fn send_to_subnet(data: [UInt8], subnet: String) -> Result<Int, UdpError> {
        self.socket.send_to(data, format!("{}:{}", subnet, self.port))
    }
}

/// Broadcast receiver
struct BroadcastReceiver {
    socket: UdpDatagram
}

impl BroadcastReceiver {
    /// Create a broadcast receiver
    fn new(port: Int) -> Result<Self, UdpError> {
        let socket = UdpDatagram.bind(format!("0.0.0.0:{}", port))?
        socket.broadcast(true)
        Ok(BroadcastReceiver { socket: socket })
    }
    
    /// Receive broadcast message
    fn recv(buf: [UInt8]) -> Result<(Int, SocketAddr), UdpError> {
        self.socket.recv_from(buf)
    }
}

/// UDP packet builder
struct UdpPacket {
    data: [UInt8]
}

impl UdpPacket {
    fn new() -> Self {
        UdpPacket { data: [] }
    }
    
    fn from_bytes(data: [UInt8]) -> Self {
        UdpPacket { data: data }
    }
    
    fn write_u8(value: UInt8) -> Self {
        self.data.push(value)
        self
    }
    
    fn write_u16_be(value: UInt16) -> Self {
        self.data.push((value >> 8) as UInt8)
        self.data.push(value as UInt8)
        self
    }
    
    fn write_u16_le(value: UInt16) -> Self {
        self.data.push(value as UInt8)
        self.data.push((value >> 8) as UInt8)
        self
    }
    
    fn write_u32_be(value: UInt32) -> Self {
        self.data.push((value >> 24) as UInt8)
        self.data.push((value >> 16) as UInt8)
        self.data.push((value >> 8) as UInt8)
        self.data.push(value as UInt8)
        self
    }
    
    fn write_u32_le(value: UInt32) -> Self {
        self.data.push(value as UInt8)
        self.data.push((value >> 8) as UInt8)
        self.data.push((value >> 16) as UInt8)
        self.data.push((value >> 24) as UInt8)
        self
    }
    
    fn write_bytes(bytes: [UInt8]) -> Self {
        self.data.extend(bytes)
        self
    }
    
    fn write_string(s: String) -> Self {
        self.data.extend(s.as_bytes())
        self
    }
    
    fn write_length_prefixed(bytes: [UInt8]) -> Self {
        self.write_u16_be(bytes.len() as UInt16)
        self.write_bytes(bytes)
    }
    
    fn build() -> [UInt8] {
        self.data.clone()
    }
    
    fn len() -> Int {
        self.data.len()
    }
}

/// UDP packet reader
struct UdpPacketReader {
    data: [UInt8]
    pos: Int
}

impl UdpPacketReader {
    fn new(data: [UInt8]) -> Self {
        UdpPacketReader { data: data, pos: 0 }
    }
    
    fn read_u8() -> Result<UInt8, UdpError> {
        if self.pos >= self.data.len() { return Err(UdpError.InvalidData) }
        let value = self.data[self.pos]
        self.pos += 1
        Ok(value)
    }
    
    fn read_u16_be() -> Result<UInt16, UdpError> {
        if self.pos + 2 > self.data.len() { return Err(UdpError.InvalidData) }
        let value = ((self.data[self.pos] as UInt16) << 8) | (self.data[self.pos + 1] as UInt16)
        self.pos += 2
        Ok(value)
    }
    
    fn read_u16_le() -> Result<UInt16, UdpError> {
        if self.pos + 2 > self.data.len() { return Err(UdpError.InvalidData) }
        let value = (self.data[self.pos] as UInt16) | ((self.data[self.pos + 1] as UInt16) << 8)
        self.pos += 2
        Ok(value)
    }
    
    fn read_u32_be() -> Result<UInt32, UdpError> {
        if self.pos + 4 > self.data.len() { return Err(UdpError.InvalidData) }
        let value = ((self.data[self.pos] as UInt32) << 24) |
                    ((self.data[self.pos + 1] as UInt32) << 16) |
                    ((self.data[self.pos + 2] as UInt32) << 8) |
                    (self.data[self.pos + 3] as UInt32)
        self.pos += 4
        Ok(value)
    }
    
    fn read_u32_le() -> Result<UInt32, UdpError> {
        if self.pos + 4 > self.data.len() { return Err(UdpError.InvalidData) }
        let value = (self.data[self.pos] as UInt32) |
                    ((self.data[self.pos + 1] as UInt32) << 8) |
                    ((self.data[self.pos + 2] as UInt32) << 16) |
                    ((self.data[self.pos + 3] as UInt32) << 24)
        self.pos += 4
        Ok(value)
    }
    
    fn read_bytes(n: Int) -> Result<[UInt8], UdpError> {
        if self.pos + n > self.data.len() { return Err(UdpError.InvalidData) }
        let bytes = self.data[self.pos..(self.pos + n)].to_vec()
        self.pos += n
        Ok(bytes)
    }
    
    fn read_string(n: Int) -> Result<String, UdpError> {
        let bytes = self.read_bytes(n)?
        String.from_utf8(bytes).map_err(|_| UdpError.InvalidData)
    }
    
    fn read_length_prefixed() -> Result<[UInt8], UdpError> {
        let len = self.read_u16_be()? as Int
        self.read_bytes(len)
    }
    
    fn remaining() -> Int {
        self.data.len() - self.pos
    }
    
    fn is_empty() -> Bool {
        self.pos >= self.data.len()
    }
}

/// UDP Error types
enum UdpError {
    BindFailed
    SendFailed
    RecvFailed
    Timeout
    InvalidAddress
    InvalidData
    MulticastError
    Other(String)
}

impl UdpError {
    fn from_net(e: NetError) -> Self {
        match e {
            NetError.AddrInUse => UdpError.BindFailed
            NetError.Timeout => UdpError.Timeout
            NetError.InvalidAddress => UdpError.InvalidAddress
            NetError.Other(s) => UdpError.Other(s)
            _ => UdpError.Other(e.to_string())
        }
    }
}

impl Display for UdpError {
    fn fmt(f: Formatter) {
        match self {
            BindFailed => f.write("Failed to bind UDP socket")
            SendFailed => f.write("Failed to send UDP datagram")
            RecvFailed => f.write("Failed to receive UDP datagram")
            Timeout => f.write("UDP operation timed out")
            InvalidAddress => f.write("Invalid address")
            InvalidData => f.write("Invalid data")
            MulticastError => f.write("Multicast error")
            Other(s) => f.write(s)
        }
    }
}

/// Quick bind function
fn bind(addr: String) -> Result<UdpDatagram, UdpError> {
    UdpDatagram.bind(addr)
}

/// Quick client function
fn client(target: String) -> Result<UdpClient, UdpError> {
    UdpClient.new(target)
}

/// Quick server function
fn server(addr: String) -> Result<UdpServer, UdpError> {
    UdpServer.new(addr)
}

// Tests
test "udp bind" {
    let socket = UdpDatagram.bind_any()?
    let addr = socket.local_addr()?
    assert(addr.port > 0)?
}

test "udp packet builder" {
    let packet = UdpPacket.new()
        .write_u8(0x01)
        .write_u16_be(0x1234)
        .write_string("hello")
        .build()
    assert_eq(packet.len(), 8)?
}

test "udp packet reader" {
    let data = [0x01, 0x12, 0x34, 0x68, 0x65, 0x6c, 0x6c, 0x6f]
    let reader = UdpPacketReader.new(data)
    assert_eq(reader.read_u8()?, 0x01)?
    assert_eq(reader.read_u16_be()?, 0x1234)?
    assert_eq(reader.read_string(5)?, "hello")?
}

test "multicast group" {
    // Would need actual network for full test
    let group = "224.0.0.1"
    assert(IpAddr.parse(group)?.is_multicast())?
}
