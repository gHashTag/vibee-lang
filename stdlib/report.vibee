// =============================================================================
// Vibee OS — Report Module
// Report generation and formatting
// =============================================================================

use result::{Result, Ok, Err}

// =============================================================================
// Report Builder
// =============================================================================

/// Report builder actor
actor Report {
    state title: String
    state sections: [Section]
    state metadata: Map<String, String>
    state format: ReportFormat
    state style: ReportStyle
    
    init(title: String) {
        self.title = title
        self.sections = []
        self.metadata = Map.empty()
        self.format = ReportFormat.Text
        self.style = ReportStyle.default()
    }
    
    on section(title: String) -> SectionBuilder { SectionBuilder.new(self, title) }
    on add_section(section: Section) -> Self { self.sections.push(section); self }
    on metadata(key: String, value: String) -> Self { self.metadata.insert(key, value); self }
    on format(f: ReportFormat) -> Self { self.format = f; self }
    on style(s: ReportStyle) -> Self { self.style = s; self }
    
    on render() -> String {
        match self.format {
            ReportFormat.Text => self.render_text()
            ReportFormat.Markdown => self.render_markdown()
            ReportFormat.HTML => self.render_html()
            ReportFormat.JSON => self.render_json()
        }
    }
    
    fn render_text() -> String {
        var out = String.new()
        out.push_str(format!("{}\n{}\n\n", self.title, "=".repeat(self.title.len())))
        for (k, v) in self.metadata.iter() { out.push_str(format!("{}: {}\n", k, v)) }
        if !self.metadata.is_empty() { out.push('\n') }
        for section in self.sections.iter() { out.push_str(section.render_text()); out.push('\n') }
        out
    }
    
    fn render_markdown() -> String {
        var out = format!("# {}\n\n", self.title)
        for (k, v) in self.metadata.iter() { out.push_str(format!("**{}**: {}\n", k, v)) }
        if !self.metadata.is_empty() { out.push('\n') }
        for section in self.sections.iter() { out.push_str(section.render_markdown()); out.push('\n') }
        out
    }
    
    fn render_html() -> String {
        var out = format!("<html><head><title>{}</title></head><body>\n<h1>{}</h1>\n", self.title, self.title)
        if !self.metadata.is_empty() {
            out.push_str("<dl>\n")
            for (k, v) in self.metadata.iter() { out.push_str(format!("<dt>{}</dt><dd>{}</dd>\n", k, v)) }
            out.push_str("</dl>\n")
        }
        for section in self.sections.iter() { out.push_str(section.render_html()) }
        out.push_str("</body></html>")
        out
    }
    
    fn render_json() -> String { @native("json_stringify", self.to_json()) }
    
    fn to_json() -> Map<String, Value> {
        var json = Map.empty()
        json.insert("title", Value.String(self.title.clone()))
        json.insert("metadata", Value.Object(self.metadata.iter().map(|(k, v)| (k.clone(), Value.String(v.clone()))).collect()))
        json.insert("sections", Value.Array(self.sections.iter().map(|s| s.to_json()).collect()))
        json
    }
    
    on save(path: String) -> Result<(), String> { @native("file_write", path, self.render()) }
}

/// Report format
enum ReportFormat { Text, Markdown, HTML, JSON }

/// Report style
struct ReportStyle {
    header_style: String
    section_style: String
    table_border: Bool
    
    fn default() -> Self { ReportStyle { header_style: "bold", section_style: "normal", table_border: true } }
}

// =============================================================================
// Section
// =============================================================================

struct Section {
    title: String
    content: [ContentBlock]
    level: Int
}

impl Section {
    fn new(title: String) -> Self { Section { title: title, content: [], level: 2 } }
    
    fn render_text() -> String {
        var out = format!("{}\n{}\n", self.title, "-".repeat(self.title.len()))
        for block in self.content.iter() { out.push_str(block.render_text()); out.push('\n') }
        out
    }
    
    fn render_markdown() -> String {
        var out = format!("{} {}\n\n", "#".repeat(self.level), self.title)
        for block in self.content.iter() { out.push_str(block.render_markdown()); out.push('\n') }
        out
    }
    
    fn render_html() -> String {
        var out = format!("<h{}>{}</h{}>\n", self.level, self.title, self.level)
        for block in self.content.iter() { out.push_str(block.render_html()) }
        out
    }
    
    fn to_json() -> Value {
        var json = Map.empty()
        json.insert("title", Value.String(self.title.clone()))
        json.insert("content", Value.Array(self.content.iter().map(|b| b.to_json()).collect()))
        Value.Object(json)
    }
}

/// Section builder
struct SectionBuilder { report: Report, section: Section }

impl SectionBuilder {
    fn new(report: Report, title: String) -> Self { SectionBuilder { report: report, section: Section.new(title) } }
    fn level(l: Int) -> Self { self.section.level = l; self }
    fn text(t: String) -> Self { self.section.content.push(ContentBlock.Text(t)); self }
    fn paragraph(t: String) -> Self { self.section.content.push(ContentBlock.Paragraph(t)); self }
    fn list(items: [String]) -> Self { self.section.content.push(ContentBlock.List(items)); self }
    fn table(t: DataTable) -> Self { self.section.content.push(ContentBlock.Table(t)); self }
    fn chart(c: Chart) -> Self { self.section.content.push(ContentBlock.Chart(c)); self }
    fn kv(pairs: [(String, String)]) -> Self { self.section.content.push(ContentBlock.KeyValue(pairs)); self }
    fn code(lang: String, code: String) -> Self { self.section.content.push(ContentBlock.Code { lang: lang, code: code }); self }
    fn end() -> Report { self.report.add_section(self.section) }
}

// =============================================================================
// Content Blocks
// =============================================================================

enum ContentBlock {
    Text(String)
    Paragraph(String)
    List([String])
    Table(DataTable)
    Chart(Chart)
    KeyValue([(String, String)])
    Code { lang: String, code: String }
    
    fn render_text() -> String {
        match self {
            .Text(t) => t.clone()
            .Paragraph(t) => format!("{}\n", t)
            .List(items) => items.iter().map(|i| format!("  • {}", i)).collect::<Vec<_>>().join("\n")
            .Table(t) => t.render_text()
            .Chart(c) => c.render_text()
            .KeyValue(pairs) => pairs.iter().map(|(k, v)| format!("{}: {}", k, v)).collect::<Vec<_>>().join("\n")
            .Code { code, .. } => format!("```\n{}\n```", code)
        }
    }
    
    fn render_markdown() -> String {
        match self {
            .Text(t) => t.clone()
            .Paragraph(t) => format!("{}\n", t)
            .List(items) => items.iter().map(|i| format!("- {}", i)).collect::<Vec<_>>().join("\n")
            .Table(t) => t.render_markdown()
            .Chart(c) => c.render_markdown()
            .KeyValue(pairs) => pairs.iter().map(|(k, v)| format!("**{}**: {}", k, v)).collect::<Vec<_>>().join("\n")
            .Code { lang, code } => format!("```{}\n{}\n```", lang, code)
        }
    }
    
    fn render_html() -> String {
        match self {
            .Text(t) => format!("<span>{}</span>", t)
            .Paragraph(t) => format!("<p>{}</p>\n", t)
            .List(items) => format!("<ul>\n{}</ul>\n", items.iter().map(|i| format!("<li>{}</li>", i)).collect::<Vec<_>>().join("\n"))
            .Table(t) => t.render_html()
            .Chart(c) => c.render_html()
            .KeyValue(pairs) => format!("<dl>\n{}</dl>\n", pairs.iter().map(|(k, v)| format!("<dt>{}</dt><dd>{}</dd>", k, v)).collect::<Vec<_>>().join("\n"))
            .Code { lang, code } => format!("<pre><code class=\"{}\">{}</code></pre>\n", lang, code)
        }
    }
    
    fn to_json() -> Value {
        match self {
            .Text(t) => Value.Object([("type", Value.String("text")), ("content", Value.String(t.clone()))].into_iter().collect())
            .Paragraph(t) => Value.Object([("type", Value.String("paragraph")), ("content", Value.String(t.clone()))].into_iter().collect())
            .List(items) => Value.Object([("type", Value.String("list")), ("items", Value.Array(items.iter().map(|i| Value.String(i.clone())).collect()))].into_iter().collect())
            .Table(t) => t.to_json()
            .Chart(c) => c.to_json()
            .KeyValue(pairs) => Value.Object([("type", Value.String("key_value")), ("pairs", Value.Array(pairs.iter().map(|(k, v)| Value.Array([Value.String(k.clone()), Value.String(v.clone())])).collect()))].into_iter().collect())
            .Code { lang, code } => Value.Object([("type", Value.String("code")), ("lang", Value.String(lang.clone())), ("code", Value.String(code.clone()))].into_iter().collect())
        }
    }
}

// =============================================================================
// Data Table
// =============================================================================

struct DataTable {
    headers: [String]
    rows: [[String]]
    alignments: [Alignment]
}

enum Alignment { Left, Center, Right }

impl DataTable {
    fn new(headers: [String]) -> Self {
        let alignments = headers.iter().map(|_| Alignment.Left).collect()
        DataTable { headers: headers, rows: [], alignments: alignments }
    }
    
    fn row(cells: [String]) -> Self { self.rows.push(cells); self }
    fn rows(rows: [[String]]) -> Self { self.rows.extend(rows); self }
    fn align(col: Int, a: Alignment) -> Self { if col < self.alignments.len() { self.alignments[col] = a } self }
    
    fn render_text() -> String {
        let widths = self.calculate_widths()
        var out = String.new()
        out.push_str(self.render_row_text(self.headers.clone(), widths.clone()))
        out.push_str(widths.iter().map(|w| "-".repeat(*w + 2)).collect::<Vec<_>>().join("+"))
        out.push('\n')
        for row in self.rows.iter() { out.push_str(self.render_row_text(row.clone(), widths.clone())) }
        out
    }
    
    fn render_row_text(cells: [String], widths: [Int]) -> String {
        var parts = []
        for (i, cell) in cells.iter().enumerate() {
            let w = widths.get(i).cloned().unwrap_or(10)
            parts.push(format!(" {:width$} ", cell, width = w))
        }
        format!("{}\n", parts.join("|"))
    }
    
    fn render_markdown() -> String {
        var out = format!("| {} |\n", self.headers.join(" | "))
        out.push_str(format!("| {} |\n", self.alignments.iter().map(|a| match a { Alignment.Left => ":---", Alignment.Center => ":---:", Alignment.Right => "---:" }).collect::<Vec<_>>().join(" | ")))
        for row in self.rows.iter() { out.push_str(format!("| {} |\n", row.join(" | "))) }
        out
    }
    
    fn render_html() -> String {
        var out = "<table>\n<thead><tr>"
        for h in self.headers.iter() { out.push_str(format!("<th>{}</th>", h)) }
        out.push_str("</tr></thead>\n<tbody>\n")
        for row in self.rows.iter() {
            out.push_str("<tr>")
            for cell in row.iter() { out.push_str(format!("<td>{}</td>", cell)) }
            out.push_str("</tr>\n")
        }
        out.push_str("</tbody></table>\n")
        out
    }
    
    fn calculate_widths() -> [Int] {
        var widths: [Int] = self.headers.iter().map(|h| h.len()).collect()
        for row in self.rows.iter() {
            for (i, cell) in row.iter().enumerate() {
                if i < widths.len() { widths[i] = widths[i].max(cell.len()) }
            }
        }
        widths
    }
    
    fn to_json() -> Value {
        var json = Map.empty()
        json.insert("type", Value.String("table"))
        json.insert("headers", Value.Array(self.headers.iter().map(|h| Value.String(h.clone())).collect()))
        json.insert("rows", Value.Array(self.rows.iter().map(|r| Value.Array(r.iter().map(|c| Value.String(c.clone())).collect())).collect()))
        Value.Object(json)
    }
}

// =============================================================================
// Charts
// =============================================================================

enum Chart {
    Bar { title: String, data: [(String, Float)] }
    Line { title: String, data: [(String, Float)] }
    Pie { title: String, data: [(String, Float)] }
    
    fn render_text() -> String {
        match self {
            .Bar { title, data } => {
                let max = data.iter().map(|(_, v)| *v).max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap_or(1.0)
                var out = format!("{}\n", title)
                for (label, value) in data.iter() {
                    let bar_len = ((value / max) * 40.0) as Int
                    out.push_str(format!("{:>10} | {} {:.1}\n", label, "█".repeat(bar_len), value))
                }
                out
            }
            .Line { title, data } => format!("[Line Chart: {}]\n", title)
            .Pie { title, data } => {
                let total: Float = data.iter().map(|(_, v)| *v).sum()
                var out = format!("{}\n", title)
                for (label, value) in data.iter() {
                    let pct = (value / total) * 100.0
                    out.push_str(format!("  {} - {:.1}%\n", label, pct))
                }
                out
            }
        }
    }
    
    fn render_markdown() -> String { self.render_text() }
    fn render_html() -> String { format!("<div class=\"chart\">{}</div>", self.render_text().replace("\n", "<br>")) }
    fn to_json() -> Value {
        match self {
            .Bar { title, data } | .Line { title, data } | .Pie { title, data } => {
                var json = Map.empty()
                json.insert("type", Value.String(match self { .Bar { .. } => "bar", .Line { .. } => "line", .Pie { .. } => "pie" }))
                json.insert("title", Value.String(title.clone()))
                json.insert("data", Value.Array(data.iter().map(|(l, v)| Value.Array([Value.String(l.clone()), Value.Float(*v)])).collect()))
                Value.Object(json)
            }
        }
    }
}

// =============================================================================
// Report Templates
// =============================================================================

/// Summary report template
fn summary_report(title: String, data: Map<String, Value>) -> Report {
    var report = Report.new(title)
    report.section("Summary")
        .kv(data.iter().map(|(k, v)| (k.clone(), v.to_string())).collect())
        .end()
}

/// Table report template
fn table_report(title: String, headers: [String], rows: [[String]]) -> Report {
    var report = Report.new(title)
    report.section("Data")
        .table(DataTable.new(headers).rows(rows))
        .end()
}

// =============================================================================
// Builder Functions
// =============================================================================

fn report(title: String) -> Report { Report.new(title) }
fn table(headers: [String]) -> DataTable { DataTable.new(headers) }
fn bar_chart(title: String, data: [(String, Float)]) -> Chart { Chart.Bar { title: title, data: data } }
fn line_chart(title: String, data: [(String, Float)]) -> Chart { Chart.Line { title: title, data: data } }
fn pie_chart(title: String, data: [(String, Float)]) -> Chart { Chart.Pie { title: title, data: data } }

// =============================================================================
// Tests
// =============================================================================

test "report_text" {
    let r = Report.new("Test Report")
        .metadata("Author", "Test")
        .section("Section 1").text("Hello").end()
    let output = r.render()
    assert(output.contains("Test Report"))?
    assert(output.contains("Section 1"))?
}

test "table_render" {
    let t = DataTable.new(["Name", "Age"]).row(["Alice", "30"]).row(["Bob", "25"])
    let output = t.render_markdown()
    assert(output.contains("Name"))?
    assert(output.contains("Alice"))?
}

test "bar_chart" {
    let c = Chart.Bar { title: "Sales", data: [("Q1", 100.0), ("Q2", 150.0)] }
    let output = c.render_text()
    assert(output.contains("Sales"))?
    assert(output.contains("Q1"))?
}
