// =============================================================================
// Vibee OS â€” Calendar Event Module
// Calendar event management with full lifecycle support
// =============================================================================

use datetime::{DateTime, Duration}
use uuid::{UUID}

// =============================================================================
// Event Types & Enums
// =============================================================================

enum EventType { Meeting, Appointment, Task, Reminder, AllDay, Birthday, Holiday }
enum EventStatus { Tentative, Confirmed, Cancelled }
enum EventVisibility { Public, Private, Confidential }
enum EventPriority { Low, Normal, High, Urgent }
enum ResponseStatus { NeedsAction, Accepted, Declined, Tentative }

// =============================================================================
// Event Attendee
// =============================================================================

struct EventAttendee {
    id: String
    email: String
    name: Option<String>
    response_status: ResponseStatus
    is_organizer: Bool
    is_optional: Bool
    comment: Option<String>
    responded_at: Option<DateTime>
}

impl EventAttendee {
    fn new(email: String) -> Self {
        EventAttendee {
            id: UUID.v4().to_string(),
            email: email,
            name: None,
            response_status: ResponseStatus.NeedsAction,
            is_organizer: false,
            is_optional: false,
            comment: None,
            responded_at: None
        }
    }
    
    fn with_name(n: String) -> Self { self.name = Some(n); self }
    fn as_organizer() -> Self { self.is_organizer = true; self }
    fn as_optional() -> Self { self.is_optional = true; self }
    
    fn accept(comment: Option<String>) -> Self {
        self.response_status = ResponseStatus.Accepted
        self.comment = comment
        self.responded_at = Some(DateTime.now())
        self
    }
    
    fn decline(comment: Option<String>) -> Self {
        self.response_status = ResponseStatus.Declined
        self.comment = comment
        self.responded_at = Some(DateTime.now())
        self
    }
    
    fn tentative(comment: Option<String>) -> Self {
        self.response_status = ResponseStatus.Tentative
        self.comment = comment
        self.responded_at = Some(DateTime.now())
        self
    }
    
    fn display_name() -> String {
        self.name.clone().unwrap_or(self.email.clone())
    }
    
    fn has_responded() -> Bool {
        self.response_status != ResponseStatus.NeedsAction
    }
}

// =============================================================================
// Event Location
// =============================================================================

struct EventLocation {
    name: String
    address: Option<String>
    room: Option<String>
    latitude: Option<Float>
    longitude: Option<Float>
    conference_url: Option<String>
    conference_type: Option<String>
}

impl EventLocation {
    fn physical(name: String) -> Self {
        EventLocation {
            name: name,
            address: None,
            room: None,
            latitude: None,
            longitude: None,
            conference_url: None,
            conference_type: None
        }
    }
    
    fn virtual_meeting(url: String, provider: String) -> Self {
        EventLocation {
            name: "Online Meeting",
            address: None,
            room: None,
            latitude: None,
            longitude: None,
            conference_url: Some(url),
            conference_type: Some(provider)
        }
    }
    
    fn with_address(addr: String) -> Self { self.address = Some(addr); self }
    fn with_room(r: String) -> Self { self.room = Some(r); self }
    fn with_coordinates(lat: Float, lng: Float) -> Self {
        self.latitude = Some(lat)
        self.longitude = Some(lng)
        self
    }
    
    fn is_virtual() -> Bool { self.conference_url.is_some() }
    
    fn full_location() -> String {
        var parts = [self.name.clone()]
        if let Some(room) = self.room.clone() { parts.push(room) }
        if let Some(addr) = self.address.clone() { parts.push(addr) }
        parts.join(", ")
    }
}

// =============================================================================
// Event Attachment
// =============================================================================

struct EventAttachment {
    id: String
    filename: String
    mime_type: String
    url: Option<String>
    size_bytes: Option<Int64>
    created_at: DateTime
}

impl EventAttachment {
    fn new(filename: String, mime_type: String) -> Self {
        EventAttachment {
            id: UUID.v4().to_string(),
            filename: filename,
            mime_type: mime_type,
            url: None,
            size_bytes: None,
            created_at: DateTime.now()
        }
    }
    
    fn with_url(u: String) -> Self { self.url = Some(u); self }
    fn with_size(s: Int64) -> Self { self.size_bytes = Some(s); self }
}

// =============================================================================
// Calendar Event
// =============================================================================

struct CalendarEvent {
    id: String
    calendar_id: String
    title: String
    description: Option<String>
    event_type: EventType
    status: EventStatus
    visibility: EventVisibility
    priority: EventPriority
    start_time: DateTime
    end_time: DateTime
    is_all_day: Bool
    timezone: String
    location: Option<EventLocation>
    organizer_id: String
    attendees: [EventAttendee]
    attachments: [EventAttachment]
    recurrence_rule: Option<String>
    recurrence_id: Option<String>
    parent_event_id: Option<String>
    color: Option<String>
    tags: [String]
    custom_fields: Map<String, String>
    reminders: [Int]  // Minutes before event
    created_at: DateTime
    updated_at: DateTime
    sequence: Int
}

impl CalendarEvent {
    fn new(title: String, start: DateTime, end: DateTime) -> Self {
        let now = DateTime.now()
        CalendarEvent {
            id: UUID.v4().to_string(),
            calendar_id: "default",
            title: title,
            description: None,
            event_type: EventType.Meeting,
            status: EventStatus.Confirmed,
            visibility: EventVisibility.Public,
            priority: EventPriority.Normal,
            start_time: start,
            end_time: end,
            is_all_day: false,
            timezone: "UTC",
            location: None,
            organizer_id: "",
            attendees: [],
            attachments: [],
            recurrence_rule: None,
            recurrence_id: None,
            parent_event_id: None,
            color: None,
            tags: [],
            custom_fields: Map.empty(),
            reminders: [15],
            created_at: now,
            updated_at: now,
            sequence: 0
        }
    }
    
    fn all_day(title: String, date: DateTime) -> Self {
        let start = date.start_of_day()
        let end = date.end_of_day()
        var event = CalendarEvent.new(title, start, end)
        event.is_all_day = true
        event.event_type = EventType.AllDay
        event
    }
    
    fn meeting(title: String, start: DateTime, duration: Duration) -> Self {
        let end = start.add(duration)
        var event = CalendarEvent.new(title, start, end)
        event.event_type = EventType.Meeting
        event
    }
    
    fn appointment(title: String, start: DateTime, duration: Duration) -> Self {
        let end = start.add(duration)
        var event = CalendarEvent.new(title, start, end)
        event.event_type = EventType.Appointment
        event
    }
    
    // Builder methods
    fn with_calendar(id: String) -> Self { self.calendar_id = id; self }
    fn with_description(d: String) -> Self { self.description = Some(d); self }
    fn with_location(loc: EventLocation) -> Self { self.location = Some(loc); self }
    fn with_organizer(id: String) -> Self { self.organizer_id = id; self }
    fn with_timezone(tz: String) -> Self { self.timezone = tz; self }
    fn with_color(c: String) -> Self { self.color = Some(c); self }
    fn with_priority(p: EventPriority) -> Self { self.priority = p; self }
    fn with_visibility(v: EventVisibility) -> Self { self.visibility = v; self }
    fn with_recurrence(rule: String) -> Self { self.recurrence_rule = Some(rule); self }
    
    fn add_attendee(attendee: EventAttendee) -> Self {
        self.attendees.push(attendee)
        self
    }
    
    fn add_attachment(attachment: EventAttachment) -> Self {
        self.attachments.push(attachment)
        self
    }
    
    fn add_reminder(minutes_before: Int) -> Self {
        if !self.reminders.contains(minutes_before) {
            self.reminders.push(minutes_before)
        }
        self
    }
    
    fn add_tag(tag: String) -> Self {
        if !self.tags.contains(tag) {
            self.tags.push(tag)
        }
        self
    }
    
    fn remove_tag(tag: String) -> Self {
        self.tags.retain(|t| t != tag)
        self
    }
    
    // Status methods
    fn confirm() -> Self {
        self.status = EventStatus.Confirmed
        self.updated_at = DateTime.now()
        self.sequence += 1
        self
    }
    
    fn cancel() -> Self {
        self.status = EventStatus.Cancelled
        self.updated_at = DateTime.now()
        self.sequence += 1
        self
    }
    
    fn mark_tentative() -> Self {
        self.status = EventStatus.Tentative
        self.updated_at = DateTime.now()
        self
    }
    
    // Time manipulation
    fn reschedule(new_start: DateTime, new_end: DateTime) -> Self {
        self.start_time = new_start
        self.end_time = new_end
        self.updated_at = DateTime.now()
        self.sequence += 1
        self
    }
    
    fn extend(duration: Duration) -> Self {
        self.end_time = self.end_time.add(duration)
        self.updated_at = DateTime.now()
        self
    }
    
    fn shorten(duration: Duration) -> Self {
        let new_end = self.end_time.sub(duration)
        if new_end.is_after(self.start_time) {
            self.end_time = new_end
            self.updated_at = DateTime.now()
        }
        self
    }
    
    // Query methods
    fn duration() -> Duration {
        self.end_time.diff(self.start_time)
    }
    
    fn is_happening_now() -> Bool {
        let now = DateTime.now()
        now.is_after(self.start_time) && now.is_before(self.end_time)
    }
    
    fn is_upcoming() -> Bool {
        DateTime.now().is_before(self.start_time)
    }
    
    fn is_past() -> Bool {
        DateTime.now().is_after(self.end_time)
    }
    
    fn is_cancelled() -> Bool {
        self.status == EventStatus.Cancelled
    }
    
    fn is_recurring() -> Bool {
        self.recurrence_rule.is_some()
    }
    
    fn has_attendees() -> Bool {
        !self.attendees.is_empty()
    }
    
    fn attendee_count() -> Int {
        self.attendees.len()
    }
    
    fn accepted_count() -> Int {
        self.attendees.iter().filter(|a| a.response_status == ResponseStatus.Accepted).count()
    }
    
    fn declined_count() -> Int {
        self.attendees.iter().filter(|a| a.response_status == ResponseStatus.Declined).count()
    }
    
    fn pending_count() -> Int {
        self.attendees.iter().filter(|a| a.response_status == ResponseStatus.NeedsAction).count()
    }
    
    fn conflicts_with(other: CalendarEvent) -> Bool {
        if self.id == other.id { return false }
        if self.is_cancelled() || other.is_cancelled() { return false }
        self.start_time.is_before(other.end_time) && self.end_time.is_after(other.start_time)
    }
    
    fn overlaps_time_range(start: DateTime, end: DateTime) -> Bool {
        self.start_time.is_before(end) && self.end_time.is_after(start)
    }
    
    fn has_tag(tag: String) -> Bool {
        self.tags.contains(tag)
    }
    
    fn get_organizer() -> Option<EventAttendee> {
        self.attendees.iter().find(|a| a.is_organizer).cloned()
    }
    
    fn get_attendee(email: String) -> Option<EventAttendee> {
        self.attendees.iter().find(|a| a.email == email).cloned()
    }
}

// =============================================================================
// Event Query
// =============================================================================

struct EventQuery {
    calendar_ids: [String]
    start_after: Option<DateTime>
    start_before: Option<DateTime>
    event_types: [EventType]
    statuses: [EventStatus]
    organizer_id: Option<String>
    attendee_email: Option<String>
    search_text: Option<String>
    tags: [String]
    include_cancelled: Bool
    include_recurring: Bool
    limit: Int
    offset: Int
}

impl EventQuery {
    fn new() -> Self {
        EventQuery {
            calendar_ids: [],
            start_after: None,
            start_before: None,
            event_types: [],
            statuses: [],
            organizer_id: None,
            attendee_email: None,
            search_text: None,
            tags: [],
            include_cancelled: false,
            include_recurring: true,
            limit: 100,
            offset: 0
        }
    }
    
    fn for_calendar(id: String) -> Self { self.calendar_ids.push(id); self }
    fn in_range(start: DateTime, end: DateTime) -> Self {
        self.start_after = Some(start)
        self.start_before = Some(end)
        self
    }
    fn today() -> Self {
        let now = DateTime.now()
        self.in_range(now.start_of_day(), now.end_of_day())
    }
    fn this_week() -> Self {
        let now = DateTime.now()
        let start = now.start_of_day()
        let end = start.add(Duration.days(7))
        self.in_range(start, end)
    }
    fn this_month() -> Self {
        let now = DateTime.now()
        self.in_range(now.start_of_month(), now.end_of_month())
    }
    fn upcoming() -> Self {
        self.start_after = Some(DateTime.now())
        self
    }
    fn with_type(t: EventType) -> Self { self.event_types.push(t); self }
    fn with_status(s: EventStatus) -> Self { self.statuses.push(s); self }
    fn by_organizer(id: String) -> Self { self.organizer_id = Some(id); self }
    fn with_attendee(email: String) -> Self { self.attendee_email = Some(email); self }
    fn search(text: String) -> Self { self.search_text = Some(text); self }
    fn with_tag(tag: String) -> Self { self.tags.push(tag); self }
    fn include_cancelled() -> Self { self.include_cancelled = true; self }
    fn limit(n: Int) -> Self { self.limit = n; self }
    fn page(p: Int, per: Int) -> Self {
        self.limit = per
        self.offset = (p - 1) * per
        self
    }
}

// =============================================================================
// Calendar Event Service
// =============================================================================

actor CalendarEventService {
    state events: Map<String, CalendarEvent>
    state by_calendar: Map<String, [String]>
    state by_organizer: Map<String, [String]>
    
    fn new() -> Self {
        CalendarEventService {
            events: Map.empty(),
            by_calendar: Map.empty(),
            by_organizer: Map.empty()
        }
    }
    
    fn create(event: CalendarEvent) -> Result<CalendarEvent, EventError> {
        if event.title.is_empty() {
            return Err(EventError.ValidationError("Title is required"))
        }
        if event.end_time.is_before(event.start_time) {
            return Err(EventError.ValidationError("End time must be after start time"))
        }
        
        self.events.insert(event.id.clone(), event.clone())
        
        // Index by calendar
        let cal_events = self.by_calendar.get(event.calendar_id.clone()).unwrap_or([])
        cal_events.push(event.id.clone())
        self.by_calendar.insert(event.calendar_id.clone(), cal_events)
        
        // Index by organizer
        if !event.organizer_id.is_empty() {
            let org_events = self.by_organizer.get(event.organizer_id.clone()).unwrap_or([])
            org_events.push(event.id.clone())
            self.by_organizer.insert(event.organizer_id.clone(), org_events)
        }
        
        Ok(event)
    }
    
    fn get(id: String) -> Option<CalendarEvent> {
        self.events.get(id)
    }
    
    fn update(event: CalendarEvent) -> Result<CalendarEvent, EventError> {
        if !self.events.contains_key(event.id.clone()) {
            return Err(EventError.NotFound)
        }
        
        var updated = event.clone()
        updated.updated_at = DateTime.now()
        updated.sequence += 1
        
        self.events.insert(updated.id.clone(), updated.clone())
        Ok(updated)
    }
    
    fn delete(id: String) -> Result<(), EventError> {
        let event = self.events.remove(id.clone()).ok_or(EventError.NotFound)?
        
        // Remove from calendar index
        if let Some(cal_events) = self.by_calendar.get_mut(event.calendar_id.clone()) {
            cal_events.retain(|e| e != id)
        }
        
        // Remove from organizer index
        if let Some(org_events) = self.by_organizer.get_mut(event.organizer_id.clone()) {
            org_events.retain(|e| e != id)
        }
        
        Ok(())
    }
    
    fn query(q: EventQuery) -> [CalendarEvent] {
        self.events.values().filter(|e| {
            // Filter by calendar
            if !q.calendar_ids.is_empty() && !q.calendar_ids.contains(e.calendar_id.clone()) {
                return false
            }
            
            // Filter by time range
            if let Some(start) = q.start_after {
                if e.start_time.is_before(start) { return false }
            }
            if let Some(end) = q.start_before {
                if e.start_time.is_after(end) { return false }
            }
            
            // Filter by status
            if !q.include_cancelled && e.is_cancelled() { return false }
            if !q.statuses.is_empty() && !q.statuses.contains(e.status) { return false }
            
            // Filter by type
            if !q.event_types.is_empty() && !q.event_types.contains(e.event_type) { return false }
            
            // Filter by organizer
            if let Some(org) = q.organizer_id.clone() {
                if e.organizer_id != org { return false }
            }
            
            // Filter by attendee
            if let Some(email) = q.attendee_email.clone() {
                if !e.attendees.iter().any(|a| a.email == email) { return false }
            }
            
            // Filter by tags
            if !q.tags.is_empty() {
                if !q.tags.iter().all(|t| e.has_tag(t.clone())) { return false }
            }
            
            // Search text
            if let Some(text) = q.search_text.clone() {
                let lower = text.to_lower()
                if !e.title.to_lower().contains(lower.clone()) &&
                   !e.description.clone().unwrap_or("").to_lower().contains(lower) {
                    return false
                }
            }
            
            true
        })
        .skip(q.offset)
        .take(q.limit)
        .collect()
    }
    
    fn get_by_calendar(calendar_id: String) -> [CalendarEvent] {
        self.by_calendar.get(calendar_id)
            .unwrap_or([])
            .iter()
            .filter_map(|id| self.events.get(id.clone()))
            .collect()
    }
    
    fn get_conflicts(event: CalendarEvent) -> [CalendarEvent] {
        self.get_by_calendar(event.calendar_id.clone())
            .iter()
            .filter(|e| event.conflicts_with(e.clone()))
            .collect()
    }
    
    fn count() -> Int {
        self.events.len()
    }
}

// =============================================================================
// Errors
// =============================================================================

enum EventError {
    NotFound
    ValidationError(String)
    ConflictError(String)
    PermissionDenied
}

impl Display for EventError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("Event not found")
            ValidationError(msg) => f.write("Validation error: \(msg)")
            ConflictError(msg) => f.write("Conflict: \(msg)")
            PermissionDenied => f.write("Permission denied")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "event creation" {
    let start = DateTime.now()
    let end = start.add(Duration.hours(1))
    let event = CalendarEvent.new("Team Meeting", start, end)
        .with_description("Weekly sync")
        .add_reminder(15)
        .add_reminder(5)
    
    assert_eq(event.title, "Team Meeting")?
    assert_eq(event.duration().as_hours(), 1)?
    assert(event.is_upcoming())?
}

test "event with attendees" {
    let start = DateTime.now().add(Duration.hours(1))
    let end = start.add(Duration.hours(1))
    let event = CalendarEvent.meeting("Project Review", start, Duration.hours(1))
        .add_attendee(EventAttendee.new("alice@example.com").with_name("Alice").as_organizer())
        .add_attendee(EventAttendee.new("bob@example.com").with_name("Bob"))
    
    assert_eq(event.attendee_count(), 2)?
    assert(event.get_organizer().is_some())?
}

test "event conflict detection" {
    let start = DateTime.now()
    let event1 = CalendarEvent.new("Meeting 1", start, start.add(Duration.hours(2)))
    let event2 = CalendarEvent.new("Meeting 2", start.add(Duration.hours(1)), start.add(Duration.hours(3)))
    let event3 = CalendarEvent.new("Meeting 3", start.add(Duration.hours(3)), start.add(Duration.hours(4)))
    
    assert(event1.conflicts_with(event2))?
    assert(!event1.conflicts_with(event3))?
}

test "event service" {
    let svc = CalendarEventService.new()
    let start = DateTime.now()
    let event = svc.create(CalendarEvent.new("Test Event", start, start.add(Duration.hours(1)))).unwrap()
    
    assert(svc.get(event.id.clone()).is_some())?
    assert_eq(svc.count(), 1)?
}
