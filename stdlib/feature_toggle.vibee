// =============================================================================
// Vibee OS â€” Feature Toggle Module
// Feature toggles for controlled feature rollout
// =============================================================================

// -----------------------------------------------------------------------------
// Feature Toggle Types
// -----------------------------------------------------------------------------

struct FeatureToggle {
    key: String
    name: String
    description: String?
    enabled: Bool
    strategy: ToggleStrategy
    variants: [Variant]?
    metadata: Map<String, String>
    created_at: DateTime
    updated_at: DateTime
    expires_at: DateTime?
}

impl FeatureToggle {
    fn simple(key: String, enabled: Bool) -> Self {
        FeatureToggle {
            key: key,
            name: key,
            description: None,
            enabled: enabled,
            strategy: ToggleStrategy.Boolean,
            variants: None,
            metadata: Map.empty(),
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            expires_at: None
        }
    }
    
    fn with_percentage(key: String, percentage: Int) -> Self {
        FeatureToggle {
            key: key,
            name: key,
            description: None,
            enabled: true,
            strategy: ToggleStrategy.Percentage(percentage),
            variants: None,
            metadata: Map.empty(),
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            expires_at: None
        }
    }
    
    fn with_users(key: String, user_ids: [String]) -> Self {
        FeatureToggle {
            key: key,
            name: key,
            description: None,
            enabled: true,
            strategy: ToggleStrategy.UserList(user_ids),
            variants: None,
            metadata: Map.empty(),
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            expires_at: None
        }
    }
}

enum ToggleStrategy {
    Boolean                                      // Simple on/off
    Percentage(Int)                              // Percentage rollout
    UserList([String])                           // Specific users
    UserAttribute { attribute: String, values: [String] }  // User attribute match
    Gradual { start: Int, end: Int, duration: Duration }   // Gradual rollout
    Schedule { start: DateTime, end: DateTime? }           // Time-based
    Environment([String])                        // Environment-based
    Custom(fn(ToggleContext) -> Bool)            // Custom logic
}

struct Variant {
    name: String
    weight: Int
    payload: Map<String, Value>?
}

struct ToggleContext {
    user_id: String?
    session_id: String?
    attributes: Map<String, String>
    environment: String
    timestamp: DateTime
}

impl ToggleContext {
    fn empty() -> Self {
        ToggleContext {
            user_id: None,
            session_id: None,
            attributes: Map.empty(),
            environment: "development",
            timestamp: DateTime.now()
        }
    }
    
    fn for_user(user_id: String) -> Self {
        ToggleContext {
            user_id: Some(user_id),
            session_id: None,
            attributes: Map.empty(),
            environment: "development",
            timestamp: DateTime.now()
        }
    }
}

// -----------------------------------------------------------------------------
// Feature Toggle Builder
// -----------------------------------------------------------------------------

actor ToggleBuilder {
    state toggle: FeatureToggle
    
    init(key: String) {
        self.toggle = FeatureToggle.simple(key, false)
    }
    
    on name(n: String) -> Self { self.toggle.name = n; self }
    on description(d: String) -> Self { self.toggle.description = Some(d); self }
    on enabled(e: Bool) -> Self { self.toggle.enabled = e; self }
    on strategy(s: ToggleStrategy) -> Self { self.toggle.strategy = s; self }
    on variant(name: String, weight: Int, payload: Map<String, Value>? = None) -> Self {
        if self.toggle.variants.is_none() { self.toggle.variants = Some([]) }
        self.toggle.variants.as_mut().unwrap().append(Variant { name: name, weight: weight, payload: payload })
        self
    }
    on metadata(key: String, value: String) -> Self { self.toggle.metadata.set(key, value); self }
    on expires_at(dt: DateTime) -> Self { self.toggle.expires_at = Some(dt); self }
    
    on build() -> FeatureToggle { self.toggle.clone() }
}

// -----------------------------------------------------------------------------
// Feature Toggle Manager
// -----------------------------------------------------------------------------

actor FeatureToggleManager {
    state store: ToggleStore
    state cache: Map<String, CachedToggle>
    state cache_ttl: Duration
    state default_context: ToggleContext
    state listeners: [fn(ToggleEvent) -> ()]
    
    init(store: ToggleStore) {
        self.store = store
        self.cache = Map.empty()
        self.cache_ttl = 60.seconds()
        self.default_context = ToggleContext.empty()
        self.listeners = []
    }
    
    on with_cache_ttl(ttl: Duration) -> Self { self.cache_ttl = ttl; self }
    on with_default_context(ctx: ToggleContext) -> Self { self.default_context = ctx; self }
    on add_listener(listener: fn(ToggleEvent) -> ()) -> Self { self.listeners.append(listener); self }
    
    on is_enabled(key: String, context: ToggleContext? = None) -> Result<Bool, ToggleError> {
        let ctx = context.unwrap_or(self.default_context.clone())
        let toggle = self.get_toggle(key)?
        
        if !toggle.enabled { return Ok(false) }
        
        // Check expiration
        if let Some(expires) = toggle.expires_at {
            if DateTime.now() > expires { return Ok(false) }
        }
        
        // Evaluate strategy
        self.evaluate_strategy(toggle, ctx)
    }
    
    fn evaluate_strategy(toggle: FeatureToggle, ctx: ToggleContext) -> Result<Bool, ToggleError> {
        match toggle.strategy {
            ToggleStrategy.Boolean => Ok(toggle.enabled)
            
            ToggleStrategy.Percentage(pct) => {
                let hash = self.hash_context(toggle.key, ctx)
                Ok((hash % 100) < pct as UInt)
            }
            
            ToggleStrategy.UserList(users) => {
                match ctx.user_id {
                    Some(uid) => Ok(users.contains(uid))
                    None => Ok(false)
                }
            }
            
            ToggleStrategy.UserAttribute { attribute, values } => {
                match ctx.attributes.get(attribute) {
                    Some(value) => Ok(values.contains(value))
                    None => Ok(false)
                }
            }
            
            ToggleStrategy.Gradual { start, end, duration } => {
                let elapsed = DateTime.now().since(toggle.created_at)
                let progress = (elapsed.as_seconds() / duration.as_seconds()).min(1.0)
                let current_pct = start + ((end - start) as Float * progress) as Int
                let hash = self.hash_context(toggle.key, ctx)
                Ok((hash % 100) < current_pct as UInt)
            }
            
            ToggleStrategy.Schedule { start, end } => {
                let now = DateTime.now()
                if now < start { return Ok(false) }
                if let Some(e) = end {
                    if now > e { return Ok(false) }
                }
                Ok(true)
            }
            
            ToggleStrategy.Environment(envs) => {
                Ok(envs.contains(ctx.environment))
            }
            
            ToggleStrategy.Custom(eval_fn) => {
                Ok(eval_fn(ctx))
            }
        }
    }
    
    fn hash_context(key: String, ctx: ToggleContext) -> UInt {
        let seed = key + ctx.user_id.unwrap_or("") + ctx.session_id.unwrap_or("")
        hash::fnv1a(seed.as_bytes()) as UInt
    }
    
    on get_variant(key: String, context: ToggleContext? = None) -> Result<Variant?, ToggleError> {
        let ctx = context.unwrap_or(self.default_context.clone())
        let toggle = self.get_toggle(key)?
        
        if !self.is_enabled(key, Some(ctx.clone()))? { return Ok(None) }
        
        match toggle.variants {
            None => Ok(None)
            Some(variants) => {
                if variants.is_empty() { return Ok(None) }
                
                let hash = self.hash_context(key, ctx)
                let total_weight = variants.iter().map(|v| v.weight).sum()
                let target = (hash % total_weight as UInt) as Int
                
                var cumulative = 0
                for variant in variants {
                    cumulative += variant.weight
                    if target < cumulative {
                        return Ok(Some(variant))
                    }
                }
                
                Ok(Some(variants.last().unwrap()))
            }
        }
    }
    
    on get_toggle(key: String) -> Result<FeatureToggle, ToggleError> {
        // Check cache
        if let Some(cached) = self.cache.get(key) {
            if DateTime.now() < cached.expires_at {
                return Ok(cached.toggle.clone())
            }
        }
        
        // Fetch from store
        let toggle = self.store.get(key)?
        
        // Update cache
        self.cache.set(key, CachedToggle {
            toggle: toggle.clone(),
            expires_at: DateTime.now() + self.cache_ttl
        })
        
        Ok(toggle)
    }
    
    on create(toggle: FeatureToggle) -> Result<(), ToggleError> {
        self.store.create(toggle.clone())?
        self.cache.remove(toggle.key)
        self.emit_event(ToggleEvent.Created(toggle.key))
        Ok(())
    }
    
    on update(toggle: FeatureToggle) -> Result<(), ToggleError> {
        self.store.update(toggle.clone())?
        self.cache.remove(toggle.key)
        self.emit_event(ToggleEvent.Updated(toggle.key))
        Ok(())
    }
    
    on delete(key: String) -> Result<(), ToggleError> {
        self.store.delete(key)?
        self.cache.remove(key)
        self.emit_event(ToggleEvent.Deleted(key))
        Ok(())
    }
    
    on enable(key: String) -> Result<(), ToggleError> {
        let toggle = self.get_toggle(key)?
        var updated = toggle.clone()
        updated.enabled = true
        updated.updated_at = DateTime.now()
        self.update(updated)
    }
    
    on disable(key: String) -> Result<(), ToggleError> {
        let toggle = self.get_toggle(key)?
        var updated = toggle.clone()
        updated.enabled = false
        updated.updated_at = DateTime.now()
        self.update(updated)
    }
    
    on set_percentage(key: String, percentage: Int) -> Result<(), ToggleError> {
        let toggle = self.get_toggle(key)?
        var updated = toggle.clone()
        updated.strategy = ToggleStrategy.Percentage(percentage)
        updated.updated_at = DateTime.now()
        self.update(updated)
    }
    
    on list() -> Result<[FeatureToggle], ToggleError> {
        self.store.list()
    }
    
    on list_enabled(context: ToggleContext? = None) -> Result<[String], ToggleError> {
        let ctx = context.unwrap_or(self.default_context.clone())
        let toggles = self.store.list()?
        
        var enabled: [String] = []
        for toggle in toggles {
            if self.is_enabled(toggle.key, Some(ctx.clone()))? {
                enabled.append(toggle.key)
            }
        }
        
        Ok(enabled)
    }
    
    on clear_cache() { self.cache.clear() }
    
    fn emit_event(event: ToggleEvent) {
        for listener in self.listeners {
            listener(event)
        }
    }
}

struct CachedToggle { toggle: FeatureToggle, expires_at: DateTime }

enum ToggleEvent { Created(String), Updated(String), Deleted(String), Evaluated(String, Bool) }

// -----------------------------------------------------------------------------
// Toggle Store Trait
// -----------------------------------------------------------------------------

trait ToggleStore {
    fn get(key: String) -> Result<FeatureToggle, ToggleError>
    fn create(toggle: FeatureToggle) -> Result<(), ToggleError>
    fn update(toggle: FeatureToggle) -> Result<(), ToggleError>
    fn delete(key: String) -> Result<(), ToggleError>
    fn list() -> Result<[FeatureToggle], ToggleError>
}

// -----------------------------------------------------------------------------
// In-Memory Store
// -----------------------------------------------------------------------------

actor InMemoryToggleStore {
    state toggles: Map<String, FeatureToggle>
    
    init() { self.toggles = Map.empty() }
}

impl ToggleStore for InMemoryToggleStore {
    fn get(key: String) -> Result<FeatureToggle, ToggleError> {
        self.toggles.get(key)
            .ok_or(ToggleError.NotFound(key))
            .map(|t| t.clone())
    }
    
    fn create(toggle: FeatureToggle) -> Result<(), ToggleError> {
        if self.toggles.contains_key(toggle.key) {
            return Err(ToggleError.AlreadyExists(toggle.key))
        }
        self.toggles.set(toggle.key.clone(), toggle)
        Ok(())
    }
    
    fn update(toggle: FeatureToggle) -> Result<(), ToggleError> {
        if !self.toggles.contains_key(toggle.key) {
            return Err(ToggleError.NotFound(toggle.key))
        }
        self.toggles.set(toggle.key.clone(), toggle)
        Ok(())
    }
    
    fn delete(key: String) -> Result<(), ToggleError> {
        self.toggles.remove(key)
            .ok_or(ToggleError.NotFound(key))
            .map(|_| ())
    }
    
    fn list() -> Result<[FeatureToggle], ToggleError> {
        Ok(self.toggles.values().collect())
    }
}

// -----------------------------------------------------------------------------
// Redis Store
// -----------------------------------------------------------------------------

actor RedisToggleStore {
    state client: RedisClient
    state prefix: String
    
    init(client: RedisClient, prefix: String = "feature_toggle:") {
        self.client = client
        self.prefix = prefix
    }
}

impl ToggleStore for RedisToggleStore {
    fn get(key: String) -> Result<FeatureToggle, ToggleError> {
        let data = self.client.get(self.prefix + key)?
        json::parse(data).map_err(|e| ToggleError.ParseError(e.to_string()))
    }
    
    fn create(toggle: FeatureToggle) -> Result<(), ToggleError> {
        let key = self.prefix + toggle.key
        let data = json::stringify(toggle)?
        self.client.set_nx(key, data)
            .map_err(|_| ToggleError.AlreadyExists(toggle.key))
    }
    
    fn update(toggle: FeatureToggle) -> Result<(), ToggleError> {
        let key = self.prefix + toggle.key
        let data = json::stringify(toggle)?
        self.client.set(key, data)
            .map_err(|e| ToggleError.StoreError(e.to_string()))
    }
    
    fn delete(key: String) -> Result<(), ToggleError> {
        self.client.del(self.prefix + key)
            .map_err(|e| ToggleError.StoreError(e.to_string()))
    }
    
    fn list() -> Result<[FeatureToggle], ToggleError> {
        let keys = self.client.keys(self.prefix + "*")?
        var toggles: [FeatureToggle] = []
        for key in keys {
            let data = self.client.get(key)?
            let toggle = json::parse(data)?
            toggles.append(toggle)
        }
        Ok(toggles)
    }
}

// -----------------------------------------------------------------------------
// Database Store
// -----------------------------------------------------------------------------

actor DatabaseToggleStore {
    state db: Database
    state table: String
    
    init(db: Database, table: String = "feature_toggles") {
        self.db = db
        self.table = table
    }
}

impl ToggleStore for DatabaseToggleStore {
    fn get(key: String) -> Result<FeatureToggle, ToggleError> {
        @native("db_get_toggle", self.db, self.table, key)
    }
    
    fn create(toggle: FeatureToggle) -> Result<(), ToggleError> {
        @native("db_create_toggle", self.db, self.table, toggle)
    }
    
    fn update(toggle: FeatureToggle) -> Result<(), ToggleError> {
        @native("db_update_toggle", self.db, self.table, toggle)
    }
    
    fn delete(key: String) -> Result<(), ToggleError> {
        @native("db_delete_toggle", self.db, self.table, key)
    }
    
    fn list() -> Result<[FeatureToggle], ToggleError> {
        @native("db_list_toggles", self.db, self.table)
    }
}

// -----------------------------------------------------------------------------
// Feature Toggle Decorator
// -----------------------------------------------------------------------------

struct FeatureGuard {
    manager: FeatureToggleManager
    key: String
    context: ToggleContext?
    fallback: fn() -> Any
}

impl FeatureGuard {
    fn new(manager: FeatureToggleManager, key: String) -> Self {
        FeatureGuard {
            manager: manager,
            key: key,
            context: None,
            fallback: || None
        }
    }
    
    fn with_context(ctx: ToggleContext) -> Self {
        self.context = Some(ctx)
        self
    }
    
    fn with_fallback(f: fn() -> Any) -> Self {
        self.fallback = f
        self
    }
    
    fn run<T>(action: fn() -> T) -> T {
        if self.manager.is_enabled(self.key, self.context).unwrap_or(false) {
            action()
        } else {
            self.fallback() as T
        }
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ToggleError {
    NotFound(String)
    AlreadyExists(String)
    ParseError(String)
    StoreError(String)
    InvalidStrategy(String)
    
    fn message() -> String {
        match self {
            .NotFound(key) => "Feature toggle not found: \(key)"
            .AlreadyExists(key) => "Feature toggle already exists: \(key)"
            .ParseError(m) => "Parse error: \(m)"
            .StoreError(m) => "Store error: \(m)"
            .InvalidStrategy(m) => "Invalid strategy: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn toggle(key: String) -> ToggleBuilder {
    ToggleBuilder.new(key)
}

fn simple_toggle(key: String, enabled: Bool) -> FeatureToggle {
    FeatureToggle.simple(key, enabled)
}

fn percentage_toggle(key: String, percentage: Int) -> FeatureToggle {
    FeatureToggle.with_percentage(key, percentage)
}

fn user_toggle(key: String, user_ids: [String]) -> FeatureToggle {
    FeatureToggle.with_users(key, user_ids)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "simple toggle" {
    let toggle = FeatureToggle.simple("new_feature", true)
    assert(toggle.key == "new_feature")
    assert(toggle.enabled == true)
}

test "percentage toggle" {
    let toggle = FeatureToggle.with_percentage("gradual_rollout", 50)
    assert(toggle.key == "gradual_rollout")
    match toggle.strategy {
        ToggleStrategy.Percentage(pct) => assert(pct == 50)
        _ => assert(false)
    }
}

test "toggle builder" {
    let toggle = ToggleBuilder.new("experiment")
        .name("New Experiment")
        .description("Testing new feature")
        .enabled(true)
        .strategy(ToggleStrategy.Percentage(25))
        .variant("control", 50, None)
        .variant("treatment", 50, None)
        .build()
    
    assert(toggle.key == "experiment")
    assert(toggle.name == "New Experiment")
    assert(toggle.variants.is_some())
    assert(toggle.variants.unwrap().len() == 2)
}

test "toggle context" {
    let ctx = ToggleContext.for_user("user123")
    assert(ctx.user_id == Some("user123"))
    
    let empty = ToggleContext.empty()
    assert(empty.user_id == None)
}

test "in memory store" {
    let store = InMemoryToggleStore.new()
    let toggle = FeatureToggle.simple("test", true)
    
    store.create(toggle)?
    let retrieved = store.get("test")?
    assert(retrieved.key == "test")
    assert(retrieved.enabled == true)
    
    store.delete("test")?
    assert(store.get("test").is_err())
}

test "feature toggle manager" {
    let store = InMemoryToggleStore.new()
    let manager = FeatureToggleManager.new(store)
    
    let toggle = FeatureToggle.simple("feature_x", true)
    manager.create(toggle)?
    
    assert(manager.is_enabled("feature_x", None)?)
    
    manager.disable("feature_x")?
    assert(!manager.is_enabled("feature_x", None)?)
}

test "percentage strategy evaluation" {
    let store = InMemoryToggleStore.new()
    let manager = FeatureToggleManager.new(store)
    
    let toggle = FeatureToggle.with_percentage("rollout", 100)
    manager.create(toggle)?
    
    // 100% should always be enabled
    assert(manager.is_enabled("rollout", None)?)
    
    let toggle_zero = FeatureToggle.with_percentage("rollout_zero", 0)
    manager.create(toggle_zero)?
    
    // 0% should always be disabled
    assert(!manager.is_enabled("rollout_zero", None)?)
}

test "user list strategy" {
    let store = InMemoryToggleStore.new()
    let manager = FeatureToggleManager.new(store)
    
    let toggle = FeatureToggle.with_users("beta", ["user1", "user2"])
    manager.create(toggle)?
    
    let ctx_allowed = ToggleContext.for_user("user1")
    assert(manager.is_enabled("beta", Some(ctx_allowed))?)
    
    let ctx_denied = ToggleContext.for_user("user3")
    assert(!manager.is_enabled("beta", Some(ctx_denied))?)
}
