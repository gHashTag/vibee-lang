// =============================================================================
// Vibee OS â€” Ring Buffer Module
// Circular/ring buffer implementation
// =============================================================================

/// Ring buffer (circular buffer)
struct RingBuffer<T> {
    data: [Option<T>]
    head: Int
    tail: Int
    len: Int
    capacity: Int
    
    /// Create with capacity
    fn new(capacity: Int) -> Self {
        RingBuffer {
            data: [None; capacity],
            head: 0,
            tail: 0,
            len: 0,
            capacity: capacity
        }
    }
    
    /// Push item (overwrites oldest if full)
    fn push(item: T) {
        self.data[self.tail] = Some(item)
        self.tail = (self.tail + 1) % self.capacity
        if self.len == self.capacity {
            self.head = (self.head + 1) % self.capacity
        } else {
            self.len += 1
        }
    }
    
    /// Push without overwrite (returns false if full)
    fn try_push(item: T) -> Bool {
        if self.is_full() { return false }
        self.data[self.tail] = Some(item)
        self.tail = (self.tail + 1) % self.capacity
        self.len += 1
        true
    }
    
    /// Pop oldest item
    fn pop() -> Option<T> {
        if self.is_empty() { return None }
        let item = self.data[self.head].take()
        self.head = (self.head + 1) % self.capacity
        self.len -= 1
        item
    }
    
    /// Peek oldest item
    fn peek() -> Option<T> {
        self.data[self.head].clone()
    }
    
    /// Peek newest item
    fn peek_back() -> Option<T> {
        if self.is_empty() { return None }
        let idx = if self.tail == 0 { self.capacity - 1 } else { self.tail - 1 }
        self.data[idx].clone()
    }
    
    /// Get by index (0 = oldest)
    fn get(index: Int) -> Option<T> {
        if index >= self.len { return None }
        let idx = (self.head + index) % self.capacity
        self.data[idx].clone()
    }
    
    /// Clear buffer
    fn clear() {
        for i in 0..self.capacity { self.data[i] = None }
        self.head = 0
        self.tail = 0
        self.len = 0
    }
    
    fn len() -> Int { self.len }
    fn capacity() -> Int { self.capacity }
    fn is_empty() -> Bool { self.len == 0 }
    fn is_full() -> Bool { self.len == self.capacity }
    
    /// Iterate from oldest to newest
    fn iter() -> RingIterator<T> {
        RingIterator { ring: self, index: 0 }
    }
    
    /// To vector
    fn to_vec() -> [T] {
        self.iter().collect()
    }
}

struct RingIterator<T> {
    ring: RingBuffer<T>
    index: Int
}

impl<T> Iterator for RingIterator<T> {
    type Item = T
    fn next() -> Option<T> {
        if self.index >= self.ring.len { return None }
        let item = self.ring.get(self.index)
        self.index += 1
        item
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "push pop" {
    var ring = RingBuffer::<Int>.new(3)
    ring.push(1)
    ring.push(2)
    assert_eq(ring.pop(), Some(1))?
    assert_eq(ring.pop(), Some(2))?
    assert_eq(ring.pop(), None)?
}

test "overwrite" {
    var ring = RingBuffer::<Int>.new(3)
    ring.push(1)
    ring.push(2)
    ring.push(3)
    ring.push(4)  // Overwrites 1
    assert_eq(ring.pop(), Some(2))?
}

test "peek" {
    var ring = RingBuffer::<Int>.new(3)
    ring.push(1)
    ring.push(2)
    assert_eq(ring.peek(), Some(1))?
    assert_eq(ring.peek_back(), Some(2))?
}
