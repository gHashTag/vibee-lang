// =============================================================================
// Vibee OS â€” Boundary Module
// Error boundaries for isolating failures and managing error propagation
// =============================================================================

use error_chain.{ChainedError, ErrorKind}
use panic_handler.{PanicInfo, catch_panic}
use recovery.{RecoveryResult, RecoveryStrategy, CircuitBreaker}
use backtrace.{Backtrace}
use logger.{Logger, Level, LogRecord}
use datetime.{DateTime, Duration, Instant}

// -----------------------------------------------------------------------------
// Error Boundary
// -----------------------------------------------------------------------------

/// Error boundary that catches and handles errors within a scope
struct ErrorBoundary<T> {
    name: String
    operation: fn() -> Result<T, ChainedError>
    fallback: Option<fn(ChainedError) -> T>
    on_error: Option<fn(ChainedError)>
    on_panic: Option<fn(PanicInfo)>
    catch_panics: Bool
    propagate: Bool
    logger: Option<Logger>
}

impl<T> ErrorBoundary<T> {
    fn new(name: String, operation: fn() -> Result<T, ChainedError>) -> Self {
        ErrorBoundary {
            name: name,
            operation: operation,
            fallback: None,
            on_error: None,
            on_panic: None,
            catch_panics: true,
            propagate: false,
            logger: None
        }
    }
    
    /// Set fallback value provider
    fn with_fallback(f: fn(ChainedError) -> T) -> Self {
        self.fallback = Some(f)
        self
    }
    
    /// Set error handler
    fn on_error(handler: fn(ChainedError)) -> Self {
        self.on_error = Some(handler)
        self
    }
    
    /// Set panic handler
    fn on_panic(handler: fn(PanicInfo)) -> Self {
        self.on_panic = Some(handler)
        self
    }
    
    /// Enable/disable panic catching
    fn catch_panics(enabled: Bool) -> Self {
        self.catch_panics = enabled
        self
    }
    
    /// Enable error propagation after handling
    fn propagate(enabled: Bool) -> Self {
        self.propagate = enabled
        self
    }
    
    /// Set logger
    fn with_logger(logger: Logger) -> Self {
        self.logger = Some(logger)
        self
    }
    
    /// Execute within boundary
    fn execute() -> Result<T, ChainedError> {
        let result = if self.catch_panics {
            // Catch both errors and panics
            match catch_panic(|| (self.operation)()) {
                Ok(inner_result) => inner_result
                Err(panic_info) => {
                    self.handle_panic(panic_info.clone())
                    Err(ChainedError.new(format!("Panic in boundary '{}': {}", 
                        self.name, panic_info.message))
                        .kind(ErrorKind.Internal)
                        .with_stack())
                }
            }
        } else {
            (self.operation)()
        }
        
        match result {
            Ok(value) => Ok(value)
            Err(error) => {
                self.handle_error(error.clone())
                
                // Try fallback
                if let Some(fb) = self.fallback.as_ref() {
                    return Ok(fb(error))
                }
                
                // Propagate or suppress
                if self.propagate {
                    Err(error)
                } else {
                    Err(ChainedError.new(format!("Error in boundary '{}' (suppressed)", self.name))
                        .caused_by(error))
                }
            }
        }
    }
    
    fn handle_error(error: ChainedError) {
        // Log error
        if let Some(logger) = self.logger.as_ref() {
            logger.error_with(
                format!("Error in boundary '{}'", self.name),
                Map.from([
                    ("boundary", self.name.clone()),
                    ("error", error.message()),
                    ("kind", error.error_kind().name())
                ])
            )
        }
        
        // Call error handler
        if let Some(handler) = self.on_error.as_ref() {
            handler(error)
        }
    }
    
    fn handle_panic(info: PanicInfo) {
        // Log panic
        if let Some(logger) = self.logger.as_ref() {
            logger.fatal_with(
                format!("Panic in boundary '{}'", self.name),
                Map.from([
                    ("boundary", self.name.clone()),
                    ("message", info.message.clone()),
                    ("thread_id", info.thread_id)
                ])
            )
        }
        
        // Call panic handler
        if let Some(handler) = self.on_panic.as_ref() {
            handler(info)
        }
    }
}

/// Create error boundary
fn boundary<T>(name: String, operation: fn() -> Result<T, ChainedError>) -> ErrorBoundary<T> {
    ErrorBoundary.new(name, operation)
}

// -----------------------------------------------------------------------------
// Isolation Boundary
// -----------------------------------------------------------------------------

/// Boundary that isolates failures and provides degraded functionality
actor IsolationBoundary<T> {
    name: String
    state: BoundaryState
    circuit_breaker: CircuitBreaker
    fallback_value: Option<T>
    error_count: Int
    success_count: Int
    last_error: Option<ChainedError>
    last_success: Option<Instant>
    health_check: Option<fn() -> Bool>
    on_state_change: Option<fn(BoundaryState, BoundaryState)>
    
    fn new(name: String) -> Self {
        IsolationBoundary {
            name: name,
            state: BoundaryState.Healthy,
            circuit_breaker: CircuitBreaker.new(name.clone()),
            fallback_value: None,
            error_count: 0,
            success_count: 0,
            last_error: None,
            last_success: None,
            health_check: None,
            on_state_change: None
        }
    }
    
    fn with_fallback(value: T) -> Self {
        self.fallback_value = Some(value)
        self
    }
    
    fn with_circuit_breaker(cb: CircuitBreaker) -> Self {
        self.circuit_breaker = cb
        self
    }
    
    fn with_health_check(check: fn() -> Bool) -> Self {
        self.health_check = Some(check)
        self
    }
    
    fn on_state_change(callback: fn(BoundaryState, BoundaryState)) -> Self {
        self.on_state_change = Some(callback)
        self
    }
    
    /// Execute operation within isolation boundary
    fn execute(operation: fn() -> Result<T, ChainedError>) -> Result<T, ChainedError> {
        // Check if boundary is degraded
        if self.state == BoundaryState.Degraded {
            if let Some(fallback) = self.fallback_value.as_ref() {
                return Ok(fallback.clone())
            }
        }
        
        // Check circuit breaker
        if !self.circuit_breaker.allow_request() {
            self.transition_to(BoundaryState.Degraded)
            if let Some(fallback) = self.fallback_value.as_ref() {
                return Ok(fallback.clone())
            }
            return Err(ChainedError.new(format!("Boundary '{}' is degraded", self.name))
                .kind(ErrorKind.Cancelled))
        }
        
        // Execute operation
        match operation() {
            Ok(value) => {
                self.record_success()
                Ok(value)
            }
            Err(error) => {
                self.record_error(error.clone())
                
                // Try fallback
                if let Some(fallback) = self.fallback_value.as_ref() {
                    return Ok(fallback.clone())
                }
                
                Err(error)
            }
        }
    }
    
    on record_success() {
        self.success_count += 1
        self.last_success = Some(Instant.now())
        self.circuit_breaker.record_success()
        
        // Check if we can recover from degraded state
        if self.state == BoundaryState.Degraded && self.success_count >= 3 {
            self.transition_to(BoundaryState.Recovering)
        } else if self.state == BoundaryState.Recovering && self.success_count >= 5 {
            self.transition_to(BoundaryState.Healthy)
        }
    }
    
    on record_error(error: ChainedError) {
        self.error_count += 1
        self.last_error = Some(error)
        self.success_count = 0
        self.circuit_breaker.record_failure()
    }
    
    fn transition_to(new_state: BoundaryState) {
        let old_state = self.state
        if old_state != new_state {
            self.state = new_state
            
            if let Some(cb) = self.on_state_change.as_ref() {
                cb(old_state, new_state)
            }
        }
    }
    
    /// Get current state
    fn state() -> BoundaryState { self.state }
    
    /// Check health
    fn is_healthy() -> Bool {
        if let Some(check) = self.health_check.as_ref() {
            return check()
        }
        self.state == BoundaryState.Healthy
    }
    
    /// Force recovery
    on recover() {
        self.transition_to(BoundaryState.Healthy)
        self.error_count = 0
        self.circuit_breaker.reset()
    }
    
    /// Get statistics
    fn stats() -> BoundaryStats {
        BoundaryStats {
            name: self.name.clone(),
            state: self.state,
            error_count: self.error_count,
            success_count: self.success_count,
            last_error: self.last_error.clone(),
            last_success: self.last_success
        }
    }
}

/// Boundary health state
enum BoundaryState {
    /// Operating normally
    Healthy
    /// Experiencing issues, using fallbacks
    Degraded
    /// Attempting to recover
    Recovering
    /// Completely failed
    Failed
}

impl Eq for BoundaryState {
    fn eq(other: BoundaryState) -> Bool {
        match (self, other) {
            (Healthy, Healthy) => true
            (Degraded, Degraded) => true
            (Recovering, Recovering) => true
            (Failed, Failed) => true
            _ => false
        }
    }
}

/// Boundary statistics
struct BoundaryStats {
    name: String
    state: BoundaryState
    error_count: Int
    success_count: Int
    last_error: Option<ChainedError>
    last_success: Option<Instant>
}

// -----------------------------------------------------------------------------
// Nested Boundaries
// -----------------------------------------------------------------------------

/// Manager for nested error boundaries
struct BoundaryManager {
    boundaries: Map<String, Box<dyn BoundaryTrait>>
    parent_child: Map<String, [String]>
    error_handlers: Map<String, fn(ChainedError)>
}

trait BoundaryTrait {
    fn name() -> String
    fn state() -> BoundaryState
    fn is_healthy() -> Bool
}

impl BoundaryManager {
    fn new() -> Self {
        BoundaryManager {
            boundaries: Map.new(),
            parent_child: Map.new(),
            error_handlers: Map.new()
        }
    }
    
    /// Register a boundary
    fn register<B: BoundaryTrait>(boundary: B) -> Self {
        self.boundaries.insert(boundary.name(), Box.new(boundary))
        self
    }
    
    /// Set parent-child relationship
    fn set_parent(child: String, parent: String) -> Self {
        let children = self.parent_child.entry(parent).or_insert([])
        children.push(child)
        self
    }
    
    /// Register error handler for boundary
    fn on_error(boundary: String, handler: fn(ChainedError)) -> Self {
        self.error_handlers.insert(boundary, handler)
        self
    }
    
    /// Get boundary by name
    fn get(name: String) -> Option<Box<dyn BoundaryTrait>> {
        self.boundaries.get(name).cloned()
    }
    
    /// Check if all boundaries are healthy
    fn all_healthy() -> Bool {
        for (_, boundary) in self.boundaries.iter() {
            if !boundary.is_healthy() {
                return false
            }
        }
        true
    }
    
    /// Get unhealthy boundaries
    fn unhealthy() -> [String] {
        var result = []
        for (name, boundary) in self.boundaries.iter() {
            if !boundary.is_healthy() {
                result.push(name.clone())
            }
        }
        result
    }
    
    /// Propagate error to parent boundaries
    fn propagate_error(boundary: String, error: ChainedError) {
        // Handle in current boundary
        if let Some(handler) = self.error_handlers.get(boundary.clone()) {
            handler(error.clone())
        }
        
        // Find parent and propagate
        for (parent, children) in self.parent_child.iter() {
            if children.contains(boundary.clone()) {
                self.propagate_error(parent.clone(), error.clone())
            }
        }
    }
    
    /// Get health report
    fn health_report() -> BoundaryHealthReport {
        var statuses = Map.new()
        
        for (name, boundary) in self.boundaries.iter() {
            statuses.insert(name.clone(), boundary.state())
        }
        
        BoundaryHealthReport {
            timestamp: DateTime.now(),
            statuses: statuses,
            all_healthy: self.all_healthy()
        }
    }
}

struct BoundaryHealthReport {
    timestamp: DateTime
    statuses: Map<String, BoundaryState>
    all_healthy: Bool
}

impl BoundaryHealthReport {
    fn to_json() -> String {
        var obj = Map.new()
        obj.insert("timestamp", self.timestamp.to_iso8601())
        obj.insert("all_healthy", self.all_healthy)
        
        var status_map = Map.new()
        for (name, state) in self.statuses.iter() {
            status_map.insert(name.clone(), match state {
                Healthy => "healthy"
                Degraded => "degraded"
                Recovering => "recovering"
                Failed => "failed"
            })
        }
        obj.insert("boundaries", status_map)
        
        Json.stringify_pretty(obj)
    }
}

// -----------------------------------------------------------------------------
// Error Propagation Control
// -----------------------------------------------------------------------------

/// Control how errors propagate across boundaries
enum PropagationPolicy {
    /// Stop at boundary, use fallback
    Stop
    /// Propagate to parent boundary
    Propagate
    /// Transform error before propagating
    Transform(fn(ChainedError) -> ChainedError)
    /// Retry before propagating
    Retry(Int)
}

/// Error filter for boundaries
struct ErrorFilter {
    allow_kinds: Option<[ErrorKind]>
    deny_kinds: Option<[ErrorKind]>
    custom_filter: Option<fn(ChainedError) -> Bool>
}

impl ErrorFilter {
    fn new() -> Self {
        ErrorFilter {
            allow_kinds: None,
            deny_kinds: None,
            custom_filter: None
        }
    }
    
    fn allow(kinds: [ErrorKind]) -> Self {
        self.allow_kinds = Some(kinds)
        self
    }
    
    fn deny(kinds: [ErrorKind]) -> Self {
        self.deny_kinds = Some(kinds)
        self
    }
    
    fn custom(filter: fn(ChainedError) -> Bool) -> Self {
        self.custom_filter = Some(filter)
        self
    }
    
    /// Check if error should pass through
    fn should_pass(error: ChainedError) -> Bool {
        // Check deny list first
        if let Some(deny) = self.deny_kinds.as_ref() {
            if deny.contains(error.error_kind()) {
                return false
            }
        }
        
        // Check allow list
        if let Some(allow) = self.allow_kinds.as_ref() {
            if !allow.contains(error.error_kind()) {
                return false
            }
        }
        
        // Check custom filter
        if let Some(filter) = self.custom_filter.as_ref() {
            return filter(error)
        }
        
        true
    }
}

// -----------------------------------------------------------------------------
// Scoped Boundary
// -----------------------------------------------------------------------------

/// RAII-style boundary that automatically handles cleanup
struct ScopedBoundary<T> {
    name: String
    cleanup: Option<fn()>
    on_success: Option<fn(T)>
    on_error: Option<fn(ChainedError)>
    logger: Option<Logger>
}

impl<T> ScopedBoundary<T> {
    fn new(name: String) -> Self {
        ScopedBoundary {
            name: name,
            cleanup: None,
            on_success: None,
            on_error: None,
            logger: None
        }
    }
    
    fn with_cleanup(f: fn()) -> Self {
        self.cleanup = Some(f)
        self
    }
    
    fn on_success(f: fn(T)) -> Self {
        self.on_success = Some(f)
        self
    }
    
    fn on_error(f: fn(ChainedError)) -> Self {
        self.on_error = Some(f)
        self
    }
    
    fn with_logger(logger: Logger) -> Self {
        self.logger = Some(logger)
        self
    }
    
    /// Execute within scoped boundary
    fn execute(operation: fn() -> Result<T, ChainedError>) -> Result<T, ChainedError> {
        let start = Instant.now()
        
        if let Some(logger) = self.logger.as_ref() {
            logger.debug(format!("Entering boundary '{}'", self.name))
        }
        
        let result = operation()
        
        // Always run cleanup
        if let Some(cleanup) = self.cleanup.as_ref() {
            cleanup()
        }
        
        let elapsed = start.elapsed()
        
        match result {
            Ok(value) => {
                if let Some(logger) = self.logger.as_ref() {
                    logger.debug(format!("Boundary '{}' completed in {:?}", self.name, elapsed))
                }
                
                if let Some(handler) = self.on_success.as_ref() {
                    handler(value.clone())
                }
                
                Ok(value)
            }
            Err(error) => {
                if let Some(logger) = self.logger.as_ref() {
                    logger.error(format!("Boundary '{}' failed after {:?}: {}", 
                        self.name, elapsed, error.message()))
                }
                
                if let Some(handler) = self.on_error.as_ref() {
                    handler(error.clone())
                }
                
                Err(error)
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Transaction Boundary
// -----------------------------------------------------------------------------

/// Boundary with transaction-like semantics (commit/rollback)
struct TransactionBoundary<T> {
    name: String
    operations: [fn() -> Result<(), ChainedError>]
    rollback_ops: [fn()]
    committed: Bool
}

impl<T> TransactionBoundary<T> {
    fn new(name: String) -> Self {
        TransactionBoundary {
            name: name,
            operations: [],
            rollback_ops: [],
            committed: false
        }
    }
    
    /// Add operation with rollback
    fn add(operation: fn() -> Result<(), ChainedError>, rollback: fn()) -> Self {
        self.operations.push(operation)
        self.rollback_ops.push(rollback)
        self
    }
    
    /// Execute all operations
    fn execute() -> Result<(), ChainedError> {
        var completed = 0
        
        for (i, op) in self.operations.enumerate() {
            match op() {
                Ok(_) => {
                    completed = i + 1
                }
                Err(error) => {
                    // Rollback completed operations in reverse order
                    for j in (0..completed).rev() {
                        (self.rollback_ops[j])()
                    }
                    
                    return Err(ChainedError.new(format!(
                        "Transaction '{}' failed at step {}", self.name, i + 1))
                        .caused_by(error))
                }
            }
        }
        
        self.committed = true
        Ok(())
    }
    
    /// Check if transaction was committed
    fn is_committed() -> Bool { self.committed }
}

// -----------------------------------------------------------------------------
// Macros
// -----------------------------------------------------------------------------

/// Create and execute error boundary
macro with_boundary!(name, operation) {
    ErrorBoundary.new(name, || operation).execute()
}

/// Create boundary with fallback
macro with_fallback_boundary!(name, operation, fallback) {
    ErrorBoundary.new(name, || operation)
        .with_fallback(|_| fallback)
        .execute()
}

/// Scoped boundary with cleanup
macro scoped!(name, cleanup, operation) {
    ScopedBoundary.new(name)
        .with_cleanup(|| cleanup)
        .execute(|| operation)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "error boundary catches errors" {
    let result = ErrorBoundary.new("test", || {
        Err(ChainedError.new("Test error"))
    })
    .with_fallback(|_| 42)
    .execute()
    
    assert_eq(result, Ok(42))?
}

test "error boundary catches panics" {
    let result = ErrorBoundary.new("test", || {
        panic!("Test panic")
        Ok(0)
    })
    .with_fallback(|_| -1)
    .execute()
    
    assert_eq(result, Ok(-1))?
}

test "isolation boundary degraded mode" {
    let boundary = IsolationBoundary.new("test")
        .with_fallback(0)
    
    // Simulate failures
    for _ in 0..10 {
        let _ = boundary.execute(|| Err(ChainedError.new("fail")))
    }
    
    // Should be degraded and return fallback
    let result = boundary.execute(|| Ok(42))
    assert_eq(result, Ok(0))?  // Fallback value
}

test "boundary manager health check" {
    var manager = BoundaryManager.new()
    
    // All healthy initially
    assert(manager.all_healthy())?
    assert(manager.unhealthy().is_empty())?
}

test "error filter" {
    let filter = ErrorFilter.new()
        .deny([ErrorKind.Validation])
    
    let validation_err = ChainedError.new("bad input").kind(ErrorKind.Validation)
    let network_err = ChainedError.new("timeout").kind(ErrorKind.Network)
    
    assert(!filter.should_pass(validation_err))?
    assert(filter.should_pass(network_err))?
}

test "scoped boundary cleanup" {
    var cleaned_up = false
    
    let result = ScopedBoundary.new("test")
        .with_cleanup(|| { cleaned_up = true })
        .execute(|| Ok(42))
    
    assert_eq(result, Ok(42))?
    assert(cleaned_up)?
}

test "transaction boundary rollback" {
    var state = 0
    
    let result = TransactionBoundary.new("test")
        .add(
            || { state = 1; Ok(()) },
            || { state = 0 }
        )
        .add(
            || { state = 2; Ok(()) },
            || { state = 1 }
        )
        .add(
            || Err(ChainedError.new("fail")),
            || {}
        )
        .execute()
    
    assert(result.is_err())?
    assert_eq(state, 0)?  // Rolled back to initial state
}

test "boundary state transitions" {
    let boundary = IsolationBoundary.new("test")
    
    assert_eq(boundary.state(), BoundaryState.Healthy)?
    
    // Record failures to trigger degradation
    for _ in 0..5 {
        boundary.record_error(ChainedError.new("error"))
    }
    
    // Should transition to degraded
    assert_eq(boundary.state(), BoundaryState.Degraded)?
    
    // Recover
    boundary.recover()
    assert_eq(boundary.state(), BoundaryState.Healthy)?
}
