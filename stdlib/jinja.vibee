// =============================================================================
// Vibee OS â€” Jinja Module
// Jinja2-style templating engine
// =============================================================================

struct Template {
    source: String
    nodes: [Node]
    
    fn parse(source: String) -> Result<Self, JinjaError> {
        Ok(Template { source: source, nodes: Parser.new(source).parse()? })
    }
    
    fn render(context: Value) -> Result<String, JinjaError> {
        Renderer.new(Context.new(context)).render(self.nodes)
    }
}

enum Node {
    Text(String)
    Output(Expr, [Filter])
    If(Expr, [Node], Option<[Node]>)
    For(String, Expr, [Node], Option<[Node]>)
    Block(String, [Node])
    Extends(String)
    Include(String)
    Macro(String, [String], [Node])
    Call(String, [Expr])
    Set(String, Expr)
    Comment(String)
}

enum Expr {
    Var(String)
    Literal(Value)
    Binary(Box<Expr>, BinOp, Box<Expr>)
    Unary(UnaryOp, Box<Expr>)
    Call(String, [Expr])
    Attr(Box<Expr>, String)
    Index(Box<Expr>, Box<Expr>)
    Ternary(Box<Expr>, Box<Expr>, Box<Expr>)
}

enum BinOp { Add, Sub, Mul, Div, Mod, Eq, Ne, Lt, Gt, Le, Ge, And, Or, In, Is }
enum UnaryOp { Not, Neg }

struct Filter { name: String, args: [Expr] }

enum Value {
    Null
    Bool(Bool)
    Int(Int)
    Float(Float)
    String(String)
    Array([Value])
    Object(Map<String, Value>)
    
    fn is_truthy() -> Bool {
        match self { Null => false, Bool(b) => b, Array(a) => !a.is_empty(), String(s) => !s.is_empty(), _ => true }
    }
    
    fn as_string() -> String {
        match self { String(s) => s, Int(i) => i.to_string(), Float(f) => f.to_string(), Bool(b) => b.to_string(), _ => "" }
    }
    
    fn get(k: String) -> Option<Value> { match self { Object(m) => m.get(k), _ => None } }
    fn index(i: Int) -> Option<Value> { match self { Array(a) => a.get(i), _ => None } }
}

struct Context {
    stack: [Map<String, Value>]
    
    fn new(root: Value) -> Self {
        let m = match root { Value.Object(o) => o, _ => Map.new() }
        Context { stack: [m] }
    }
    
    fn get(name: String) -> Option<Value> {
        for scope in self.stack.iter().rev() { if let Some(v) = scope.get(name) { return Some(v) } }
        None
    }
    
    fn set(name: String, value: Value) { self.stack.last_mut().map(|s| s.insert(name, value)); }
    fn push() { self.stack.push(Map.new()) }
    fn pop() { if self.stack.len() > 1 { self.stack.pop(); } }
}

struct Parser {
    src: String
    pos: Int
    
    fn new(src: String) -> Self { Parser { src: src, pos: 0 } }
    
    fn parse() -> Result<[Node], JinjaError> {
        var nodes: [Node] = []
        while self.pos < self.src.len() {
            if self.at("{{") { nodes.push(self.parse_output()?) }
            else if self.at("{%") { nodes.push(self.parse_tag()?) }
            else if self.at("{#") { self.skip_comment() }
            else { let t = self.text(); if !t.is_empty() { nodes.push(Node.Text(t)) } }
        }
        Ok(nodes)
    }
    
    fn text() -> String {
        let s = self.pos
        while self.pos < self.src.len() && !self.at("{{") && !self.at("{%") && !self.at("{#") { self.pos += 1 }
        self.src[s..self.pos]
    }
    
    fn parse_output() -> Result<Node, JinjaError> {
        self.pos += 2; self.ws()
        let expr = self.expr()?
        let filters = self.filters()?
        self.ws(); self.pos += 2
        Ok(Node.Output(expr, filters))
    }
    
    fn parse_tag() -> Result<Node, JinjaError> {
        self.pos += 2; self.ws()
        let kw = self.id()
        self.ws()
        let node = match kw.as_str() {
            "if" => self.parse_if()?
            "for" => self.parse_for()?
            "set" => self.parse_set()?
            "block" => self.parse_block()?
            "extends" => { let n = self.str_lit(); self.end_tag(); Node.Extends(n) }
            "include" => { let n = self.str_lit(); self.end_tag(); Node.Include(n) }
            _ => { self.end_tag(); Node.Text("") }
        }
        Ok(node)
    }
    
    fn parse_if() -> Result<Node, JinjaError> {
        let cond = self.expr()?
        self.end_tag()
        let body = self.until_end("if", "else", "endif")?
        let els = if self.last_was("else") { Some(self.until_end("if", "", "endif")?) } else { None }
        Ok(Node.If(cond, body, els))
    }
    
    fn parse_for() -> Result<Node, JinjaError> {
        let var = self.id()
        self.ws(); self.expect("in"); self.ws()
        let iter = self.expr()?
        self.end_tag()
        let body = self.until_end("for", "else", "endfor")?
        let els = if self.last_was("else") { Some(self.until_end("for", "", "endfor")?) } else { None }
        Ok(Node.For(var, iter, body, els))
    }
    
    fn parse_set() -> Result<Node, JinjaError> {
        let name = self.id()
        self.ws(); self.expect("="); self.ws()
        let val = self.expr()?
        self.end_tag()
        Ok(Node.Set(name, val))
    }
    
    fn parse_block() -> Result<Node, JinjaError> {
        let name = self.id()
        self.end_tag()
        let body = self.until_end("block", "", "endblock")?
        Ok(Node.Block(name, body))
    }
    
    fn until_end(tag: String, alt: String, end: String) -> Result<[Node], JinjaError> {
        var nodes: [Node] = []
        while self.pos < self.src.len() {
            if self.at("{%") {
                let saved = self.pos
                self.pos += 2; self.ws()
                let kw = self.id()
                if kw == end || (!alt.is_empty() && kw == alt) { self.end_tag(); self.last_kw = kw; return Ok(nodes) }
                self.pos = saved
                nodes.push(self.parse_tag()?)
            } else if self.at("{{") { nodes.push(self.parse_output()?) }
            else if self.at("{#") { self.skip_comment() }
            else { let t = self.text(); if !t.is_empty() { nodes.push(Node.Text(t)) } }
        }
        Ok(nodes)
    }
    
    var last_kw: String = ""
    fn last_was(kw: String) -> Bool { self.last_kw == kw }
    
    fn expr() -> Result<Expr, JinjaError> { self.or_expr() }
    
    fn or_expr() -> Result<Expr, JinjaError> {
        var left = self.and_expr()?
        while self.kw("or") { left = Expr.Binary(Box.new(left), BinOp.Or, Box.new(self.and_expr()?)) }
        Ok(left)
    }
    
    fn and_expr() -> Result<Expr, JinjaError> {
        var left = self.cmp_expr()?
        while self.kw("and") { left = Expr.Binary(Box.new(left), BinOp.And, Box.new(self.cmp_expr()?)) }
        Ok(left)
    }
    
    fn cmp_expr() -> Result<Expr, JinjaError> {
        var left = self.add_expr()?
        self.ws()
        let op = if self.at("==") { self.pos += 2; Some(BinOp.Eq) }
            else if self.at("!=") { self.pos += 2; Some(BinOp.Ne) }
            else if self.at("<=") { self.pos += 2; Some(BinOp.Le) }
            else if self.at(">=") { self.pos += 2; Some(BinOp.Ge) }
            else if self.at("<") { self.pos += 1; Some(BinOp.Lt) }
            else if self.at(">") { self.pos += 1; Some(BinOp.Gt) }
            else { None }
        match op { Some(o) => { self.ws(); Ok(Expr.Binary(Box.new(left), o, Box.new(self.add_expr()?))) }, None => Ok(left) }
    }
    
    fn add_expr() -> Result<Expr, JinjaError> {
        var left = self.primary()?
        loop {
            self.ws()
            if self.at("+") { self.pos += 1; self.ws(); left = Expr.Binary(Box.new(left), BinOp.Add, Box.new(self.primary()?)) }
            else if self.at("-") { self.pos += 1; self.ws(); left = Expr.Binary(Box.new(left), BinOp.Sub, Box.new(self.primary()?)) }
            else { break }
        }
        Ok(left)
    }
    
    fn primary() -> Result<Expr, JinjaError> {
        self.ws()
        let c = self.peek()
        if c == '"' || c == '\'' { return Ok(Expr.Literal(Value.String(self.str_lit()))) }
        if c.is_digit() { return Ok(Expr.Literal(Value.Int(self.num()))) }
        if c == '(' { self.pos += 1; let e = self.expr()?; self.ws(); self.pos += 1; return Ok(e) }
        if self.kw("true") { return Ok(Expr.Literal(Value.Bool(true))) }
        if self.kw("false") { return Ok(Expr.Literal(Value.Bool(false))) }
        if self.kw("none") { return Ok(Expr.Literal(Value.Null)) }
        if self.kw("not") { self.ws(); return Ok(Expr.Unary(UnaryOp.Not, Box.new(self.primary()?))) }
        
        var e = Expr.Var(self.id())
        loop {
            self.ws()
            if self.at(".") { self.pos += 1; e = Expr.Attr(Box.new(e), self.id()) }
            else if self.at("[") { self.pos += 1; let i = self.expr()?; self.ws(); self.pos += 1; e = Expr.Index(Box.new(e), Box.new(i)) }
            else { break }
        }
        Ok(e)
    }
    
    fn filters() -> Result<[Filter], JinjaError> {
        var fs: [Filter] = []
        while self.at("|") {
            self.pos += 1; self.ws()
            let name = self.id()
            var args: [Expr] = []
            if self.at("(") { self.pos += 1; args = self.args()?; self.pos += 1 }
            fs.push(Filter { name: name, args: args })
        }
        Ok(fs)
    }
    
    fn args() -> Result<[Expr], JinjaError> {
        var a: [Expr] = []
        while !self.at(")") { a.push(self.expr()?); self.ws(); if self.at(",") { self.pos += 1; self.ws() } }
        Ok(a)
    }
    
    fn id() -> String {
        let s = self.pos
        while self.pos < self.src.len() && (self.peek().is_alphanumeric() || self.peek() == '_') { self.pos += 1 }
        self.src[s..self.pos]
    }
    
    fn str_lit() -> String {
        let q = self.peek(); self.pos += 1
        let s = self.pos
        while self.peek() != q { self.pos += 1 }
        let r = self.src[s..self.pos]; self.pos += 1; r
    }
    
    fn num() -> Int {
        let s = self.pos
        while self.peek().is_digit() { self.pos += 1 }
        self.src[s..self.pos].parse().unwrap_or(0)
    }
    
    fn skip_comment() { self.pos += 2; while !self.at("#}") { self.pos += 1 }; self.pos += 2 }
    fn end_tag() { self.ws(); self.pos += 2 }
    fn expect(s: String) { self.pos += s.len() }
    fn kw(k: String) -> Bool { if self.src[self.pos..].starts_with(k) { self.pos += k.len(); true } else { false } }
    fn ws() { while self.pos < self.src.len() && self.peek().is_whitespace() { self.pos += 1 } }
    fn peek() -> Char { self.src[self.pos] }
    fn at(s: String) -> Bool { self.src[self.pos..].starts_with(s) }
}

struct Renderer {
    ctx: Context
    
    fn new(ctx: Context) -> Self { Renderer { ctx: ctx } }
    
    fn render(nodes: [Node]) -> Result<String, JinjaError> {
        var out = ""
        for node in nodes {
            match node {
                Text(s) => out.push_str(s)
                Output(e, fs) => out.push_str(self.apply_filters(self.eval(e)?, fs)?.as_string())
                If(c, body, els) => out.push_str(if self.eval(c)?.is_truthy() { self.render(body)? } else { els.map(|e| self.render(e)).unwrap_or(Ok(""))? })
                For(v, iter, body, els) => {
                    match self.eval(iter)? {
                        Value.Array(items) if !items.is_empty() => {
                            for (i, item) in items.iter().enumerate() {
                                self.ctx.push()
                                self.ctx.set(v, item)
                                self.ctx.set("loop", loop_vars(i, items.len()))
                                out.push_str(self.render(body)?)
                                self.ctx.pop()
                            }
                        }
                        _ => out.push_str(els.map(|e| self.render(e)).unwrap_or(Ok(""))?)
                    }
                }
                Set(n, e) => { let v = self.eval(e)?; self.ctx.set(n, v) }
                _ => {}
            }
        }
        Ok(out)
    }
    
    fn eval(e: Expr) -> Result<Value, JinjaError> {
        match e {
            Var(n) => Ok(self.ctx.get(n).unwrap_or(Value.Null))
            Literal(v) => Ok(v)
            Attr(obj, attr) => Ok(self.eval(*obj)?.get(attr).unwrap_or(Value.Null))
            Index(obj, idx) => {
                let i = match self.eval(*idx)? { Value.Int(n) => n, _ => 0 }
                Ok(self.eval(*obj)?.index(i).unwrap_or(Value.Null))
            }
            Binary(l, op, r) => self.eval_binary(*l, op, *r)
            Unary(UnaryOp.Not, e) => Ok(Value.Bool(!self.eval(*e)?.is_truthy()))
            Unary(UnaryOp.Neg, e) => match self.eval(*e)? { Value.Int(i) => Ok(Value.Int(-i)), _ => Ok(Value.Null) }
            _ => Ok(Value.Null)
        }
    }
    
    fn eval_binary(l: Expr, op: BinOp, r: Expr) -> Result<Value, JinjaError> {
        let lv = self.eval(l)?
        let rv = self.eval(r)?
        match op {
            BinOp.Add => match (lv, rv) { (Value.Int(a), Value.Int(b)) => Ok(Value.Int(a + b)), (Value.String(a), Value.String(b)) => Ok(Value.String(a + b)), _ => Ok(Value.Null) }
            BinOp.Sub => match (lv, rv) { (Value.Int(a), Value.Int(b)) => Ok(Value.Int(a - b)), _ => Ok(Value.Null) }
            BinOp.Eq => Ok(Value.Bool(values_eq(lv, rv)))
            BinOp.Ne => Ok(Value.Bool(!values_eq(lv, rv)))
            BinOp.And => Ok(Value.Bool(lv.is_truthy() && rv.is_truthy()))
            BinOp.Or => Ok(Value.Bool(lv.is_truthy() || rv.is_truthy()))
            _ => Ok(Value.Null)
        }
    }
    
    fn apply_filters(v: Value, filters: [Filter]) -> Result<Value, JinjaError> {
        var val = v
        for f in filters {
            val = match f.name.as_str() {
                "upper" => Value.String(val.as_string().to_uppercase())
                "lower" => Value.String(val.as_string().to_lowercase())
                "trim" => Value.String(val.as_string().trim())
                "length" => match val { Value.String(s) => Value.Int(s.len()), Value.Array(a) => Value.Int(a.len()), _ => Value.Int(0) }
                "default" => if val.is_truthy() { val } else { f.args.get(0).map(|e| self.eval(e)).unwrap_or(Ok(Value.Null))? }
                "escape" => Value.String(html_escape(val.as_string()))
                "join" => {
                    let sep = f.args.get(0).map(|e| self.eval(e)?.as_string()).unwrap_or(",")
                    match val { Value.Array(a) => Value.String(a.iter().map(|v| v.as_string()).join(sep)), _ => val }
                }
                "first" => match val { Value.Array(a) => a.first().cloned().unwrap_or(Value.Null), _ => Value.Null }
                "last" => match val { Value.Array(a) => a.last().cloned().unwrap_or(Value.Null), _ => Value.Null }
                "reverse" => match val { Value.Array(a) => Value.Array(a.iter().rev().collect()), Value.String(s) => Value.String(s.chars().rev().collect()), _ => val }
                _ => val
            }
        }
        Ok(val)
    }
}

fn loop_vars(i: Int, len: Int) -> Value {
    Value.Object(Map.from([
        ("index", Value.Int(i + 1)), ("index0", Value.Int(i)),
        ("first", Value.Bool(i == 0)), ("last", Value.Bool(i == len - 1)),
        ("length", Value.Int(len))
    ]))
}

fn values_eq(a: Value, b: Value) -> Bool {
    match (a, b) {
        (Value.Int(x), Value.Int(y)) => x == y
        (Value.String(x), Value.String(y)) => x == y
        (Value.Bool(x), Value.Bool(y)) => x == y
        (Value.Null, Value.Null) => true
        _ => false
    }
}

fn html_escape(s: String) -> String {
    s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;")
}

enum JinjaError { ParseError(String), RenderError(String) }
impl Display for JinjaError {
    fn fmt(f: Formatter) { match self { ParseError(s) => f.write(s), RenderError(s) => f.write(s) } }
}
impl Error for JinjaError {}

fn render(tmpl: String, ctx: Value) -> Result<String, JinjaError> { Template.parse(tmpl)?.render(ctx) }

test "variable" {
    let r = render("Hello {{ name }}!", Value.Object(Map.from([("name", Value.String("World"))])))?
    assert_eq(r, "Hello World!")?
}

test "if" {
    let r = render("{% if show %}yes{% endif %}", Value.Object(Map.from([("show", Value.Bool(true))])))?
    assert_eq(r, "yes")?
}

test "for" {
    let r = render("{% for x in items %}{{ x }}{% endfor %}", Value.Object(Map.from([("items", Value.Array([Value.String("a"), Value.String("b")]))])))?
    assert_eq(r, "ab")?
}

test "filter" {
    let r = render("{{ name|upper }}", Value.Object(Map.from([("name", Value.String("hello"))])))?
    assert_eq(r, "HELLO")?
}
