// =============================================================================
// Vibee OS â€” Vulnerability Scanner Module
// Security vulnerability detection and assessment
// =============================================================================

use net.{IpAddr, SocketAddr, TcpStream}
use http.{Request, Response}
use datetime.{DateTime}

// =============================================================================
// Core Types
// =============================================================================

enum VulnSeverity { Critical, High, Medium, Low, Info }
enum VulnStatus { Open, Fixed, FalsePositive, Accepted, InProgress }
enum ScanType { Full, Quick, Custom, Compliance }

/// Vulnerability finding
struct Vulnerability {
    id: String
    cve_id: Option<String>
    name: String
    description: String
    severity: VulnSeverity
    cvss_score: Float
    affected_component: String
    affected_version: Option<String>
    remediation: String
    references: [String]
    status: VulnStatus
    discovered_at: DateTime
    evidence: String
}

impl Vulnerability {
    fn new(name: String, severity: VulnSeverity) -> Self {
        Vulnerability {
            id: @native("uuid_v4"), cve_id: None, name: name, description: "",
            severity: severity, cvss_score: 0.0, affected_component: "",
            affected_version: None, remediation: "", references: [],
            status: VulnStatus.Open, discovered_at: DateTime.now(), evidence: ""
        }
    }
    
    fn with_cve(cve: String) -> Self { self.cve_id = Some(cve); self }
    fn with_cvss(score: Float) -> Self { self.cvss_score = score; self }
    fn with_component(comp: String) -> Self { self.affected_component = comp; self }
    fn with_remediation(rem: String) -> Self { self.remediation = rem; self }
    fn with_evidence(ev: String) -> Self { self.evidence = ev; self }
}

// =============================================================================
// Scan Target
// =============================================================================

struct ScanTarget {
    host: String
    ip: Option<IpAddr>
    ports: [UInt16]
    protocols: [String]
}

impl ScanTarget {
    fn new(host: String) -> Self {
        ScanTarget { host: host, ip: None, ports: [80, 443, 22, 21, 25, 3306, 5432], protocols: ["http", "https", "ssh"] }
    }
    
    fn with_ports(ports: [UInt16]) -> Self { self.ports = ports; self }
    fn web_only() -> Self { self.ports = [80, 443]; self.protocols = ["http", "https"]; self }
}

// =============================================================================
// Scan Result
// =============================================================================

struct ScanResult {
    id: String
    target: ScanTarget
    started_at: DateTime
    completed_at: Option<DateTime>
    vulnerabilities: [Vulnerability]
    open_ports: [PortInfo]
    services: [ServiceInfo]
    scan_type: ScanType
    status: ScanStatus
}

enum ScanStatus { Running, Completed, Failed, Cancelled }

struct PortInfo { port: UInt16, state: String, service: String }
struct ServiceInfo { name: String, version: String, port: UInt16 }

impl ScanResult {
    fn new(target: ScanTarget, scan_type: ScanType) -> Self {
        ScanResult {
            id: @native("uuid_v4"), target: target, started_at: DateTime.now(),
            completed_at: None, vulnerabilities: [], open_ports: [],
            services: [], scan_type: scan_type, status: ScanStatus.Running
        }
    }
    
    fn critical_count() -> Int { self.vulnerabilities.iter().filter(|v| matches!(v.severity, VulnSeverity.Critical)).count() }
    fn high_count() -> Int { self.vulnerabilities.iter().filter(|v| matches!(v.severity, VulnSeverity.High)).count() }
    fn risk_score() -> Float {
        self.vulnerabilities.iter().map(|v| v.cvss_score).sum() / self.vulnerabilities.len().max(1) as Float
    }
}

// =============================================================================
// Vulnerability Scanner
// =============================================================================

actor VulnerabilityScanner {
    state checks: [VulnCheck]
    state results: Map<String, ScanResult>
    state config: ScanConfig
    
    fn new() -> Self {
        VulnerabilityScanner { checks: [], results: Map.new(), config: ScanConfig.default() }
    }
    
    fn load_checks(checks: [VulnCheck]) { self.checks.extend(checks) }
    fn load_default_checks() { self.checks.extend(default_vuln_checks()) }
    
    fn scan(target: ScanTarget) -> ScanResult {
        let mut result = ScanResult.new(target.clone(), ScanType.Full)
        
        // Port scan
        result.open_ports = self.scan_ports(target.clone())
        
        // Service detection
        result.services = self.detect_services(target.clone(), result.open_ports.clone())
        
        // Run vulnerability checks
        for check in self.checks.iter() {
            if let Some(vuln) = check.run(target.clone(), result.services.clone()) {
                result.vulnerabilities.push(vuln)
            }
        }
        
        result.status = ScanStatus.Completed
        result.completed_at = Some(DateTime.now())
        self.results.insert(result.id.clone(), result.clone())
        result
    }
    
    fn scan_ports(target: ScanTarget) -> [PortInfo] {
        let mut open_ports: [PortInfo] = []
        for port in target.ports.iter() {
            if self.is_port_open(target.host.clone(), *port) {
                open_ports.push(PortInfo { port: *port, state: "open", service: "" })
            }
        }
        open_ports
    }
    
    fn is_port_open(host: String, port: UInt16) -> Bool {
        let addr = SocketAddr.parse(format!("{}:{}", host, port)).ok()?
        TcpStream.connect_timeout(addr, self.config.timeout_ms).is_ok()
    }
    
    fn detect_services(target: ScanTarget, ports: [PortInfo]) -> [ServiceInfo] {
        let mut services: [ServiceInfo] = []
        for port in ports.iter() {
            if let Some(service) = self.probe_service(target.host.clone(), port.port) {
                services.push(service)
            }
        }
        services
    }
    
    fn probe_service(host: String, port: UInt16) -> Option<ServiceInfo> {
        @native("probe_service", host, port)
    }
    
    fn get_result(id: String) -> Option<ScanResult> { self.results.get(id).cloned() }
    fn list_results() -> [ScanResult] { self.results.values().cloned().collect() }
}

struct ScanConfig {
    timeout_ms: Int64
    max_threads: Int
    follow_redirects: Bool
}

impl ScanConfig {
    fn default() -> Self { ScanConfig { timeout_ms: 5000, max_threads: 10, follow_redirects: true } }
}

// =============================================================================
// Vulnerability Check
// =============================================================================

trait VulnCheck {
    fn name() -> String
    fn run(target: ScanTarget, services: [ServiceInfo]) -> Option<Vulnerability>
}

struct HttpHeaderCheck {}
impl VulnCheck for HttpHeaderCheck {
    fn name() -> String { "HTTP Security Headers" }
    fn run(target: ScanTarget, services: [ServiceInfo]) -> Option<Vulnerability> {
        let response = @native("http_get", format!("http://{}", target.host))?
        let headers = response.headers
        
        let mut missing: [String] = []
        if !headers.contains_key("X-Frame-Options") { missing.push("X-Frame-Options") }
        if !headers.contains_key("X-Content-Type-Options") { missing.push("X-Content-Type-Options") }
        if !headers.contains_key("Content-Security-Policy") { missing.push("Content-Security-Policy") }
        if !headers.contains_key("Strict-Transport-Security") { missing.push("Strict-Transport-Security") }
        
        if !missing.is_empty() {
            Some(Vulnerability.new("Missing Security Headers", VulnSeverity.Medium)
                .with_component("HTTP Server")
                .with_evidence(format!("Missing: {}", missing.join(", ")))
                .with_remediation("Add security headers to HTTP responses"))
        } else { None }
    }
}

struct SslCheck {}
impl VulnCheck for SslCheck {
    fn name() -> String { "SSL/TLS Configuration" }
    fn run(target: ScanTarget, services: [ServiceInfo]) -> Option<Vulnerability> {
        let ssl_info = @native("ssl_probe", target.host, 443)?
        
        if ssl_info.supports_sslv3 || ssl_info.supports_tls10 {
            Some(Vulnerability.new("Weak SSL/TLS Protocols", VulnSeverity.High)
                .with_cve("CVE-2014-3566")
                .with_cvss(7.5)
                .with_component("SSL/TLS")
                .with_remediation("Disable SSLv3 and TLS 1.0"))
        } else { None }
    }
}

struct OpenPortCheck {}
impl VulnCheck for OpenPortCheck {
    fn name() -> String { "Dangerous Open Ports" }
    fn run(target: ScanTarget, services: [ServiceInfo]) -> Option<Vulnerability> {
        let dangerous = [23, 135, 139, 445, 3389]
        for service in services.iter() {
            if dangerous.contains(service.port) {
                return Some(Vulnerability.new("Dangerous Port Open", VulnSeverity.High)
                    .with_component(format!("Port {}", service.port))
                    .with_remediation("Close unnecessary ports"))
            }
        }
        None
    }
}

struct DefaultCredentialsCheck {}
impl VulnCheck for DefaultCredentialsCheck {
    fn name() -> String { "Default Credentials" }
    fn run(target: ScanTarget, services: [ServiceInfo]) -> Option<Vulnerability> {
        let defaults = [("admin", "admin"), ("root", "root"), ("admin", "password")]
        for service in services.iter() {
            for (user, pass) in defaults.iter() {
                if @native("try_login", target.host, service.port, *user, *pass) {
                    return Some(Vulnerability.new("Default Credentials", VulnSeverity.Critical)
                        .with_cvss(9.8)
                        .with_component(service.name.clone())
                        .with_evidence(format!("User: {}", user))
                        .with_remediation("Change default credentials"))
                }
            }
        }
        None
    }
}

fn default_vuln_checks() -> [Box<dyn VulnCheck>] {
    [
        Box.new(HttpHeaderCheck {}),
        Box.new(SslCheck {}),
        Box.new(OpenPortCheck {}),
        Box.new(DefaultCredentialsCheck {})
    ]
}

// =============================================================================
// Report Generator
// =============================================================================

struct VulnReport {
    result: ScanResult
}

impl VulnReport {
    fn new(result: ScanResult) -> Self { VulnReport { result: result } }
    
    fn to_json() -> String { @native("json_serialize", self.result) }
    fn to_html() -> String { @native("vuln_report_html", self.result) }
    fn to_pdf() -> [UInt8] { @native("vuln_report_pdf", self.result) }
    
    fn summary() -> String {
        let r = self.result
        format!("Scan: {} | Critical: {} | High: {} | Medium: {} | Low: {}",
            r.target.host, r.critical_count(), r.high_count(),
            r.vulnerabilities.iter().filter(|v| matches!(v.severity, VulnSeverity.Medium)).count(),
            r.vulnerabilities.iter().filter(|v| matches!(v.severity, VulnSeverity.Low)).count())
    }
}

enum VulnScanError { ConnectionFailed(String), Timeout, InvalidTarget(String) }

test "vulnerability creation" {
    let vuln = Vulnerability.new("Test Vuln", VulnSeverity.High)
        .with_cve("CVE-2024-1234")
        .with_cvss(8.5)
    assert_eq(vuln.cve_id, Some("CVE-2024-1234"))?
    assert_eq(vuln.cvss_score, 8.5)?
}

test "scan target" {
    let target = ScanTarget.new("example.com").web_only()
    assert_eq(target.ports, [80, 443])?
}
