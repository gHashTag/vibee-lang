// =============================================================================
// Vibee OS â€” Optimistic Lock Module
// Optimistic concurrency control primitives
// =============================================================================

// =============================================================================
// Version Types
// =============================================================================

/// Version number for optimistic locking
struct Version {
    value: Int64
    
    fn new() -> Self { Version { value: 0 } }
    fn from(value: Int64) -> Self { Version { value: value } }
    fn increment() -> Self { Version { value: self.value + 1 } }
    fn is_newer_than(other: Version) -> Bool { self.value > other.value }
    fn is_same(other: Version) -> Bool { self.value == other.value }
}

impl Eq for Version {
    fn eq(other: Version) -> Bool { self.value == other.value }
}

impl Ord for Version {
    fn cmp(other: Version) -> Ordering {
        if self.value < other.value { Ordering.Less }
        else if self.value > other.value { Ordering.Greater }
        else { Ordering.Equal }
    }
}

impl Display for Version {
    fn fmt(f: Formatter) -> Result<(), FormatError> {
        f.write(f"v{self.value}")
    }
}

/// Timestamp-based version
struct TimestampVersion {
    timestamp_ms: Int64
    sequence: Int32
    
    fn new() -> Self {
        TimestampVersion { 
            timestamp_ms: @native("timestamp_ms"), 
            sequence: 0 
        }
    }
    
    fn next() -> Self {
        let now = @native("timestamp_ms")
        if now == self.timestamp_ms {
            TimestampVersion { timestamp_ms: now, sequence: self.sequence + 1 }
        } else {
            TimestampVersion { timestamp_ms: now, sequence: 0 }
        }
    }
    
    fn is_newer_than(other: TimestampVersion) -> Bool {
        self.timestamp_ms > other.timestamp_ms ||
        (self.timestamp_ms == other.timestamp_ms && self.sequence > other.sequence)
    }
}

/// Vector clock for distributed versioning
struct VectorClock {
    clocks: Map<String, Int64>
    
    fn new() -> Self { VectorClock { clocks: Map.new() } }
    
    fn increment(node_id: String) -> Self {
        var new_clocks = self.clocks.clone()
        let current = new_clocks.get(node_id).unwrap_or(0)
        new_clocks.insert(node_id, current + 1)
        VectorClock { clocks: new_clocks }
    }
    
    fn merge(other: VectorClock) -> Self {
        var merged = self.clocks.clone()
        for (node, time) in other.clocks.iter() {
            let current = merged.get(node).unwrap_or(0)
            merged.insert(node, current.max(*time))
        }
        VectorClock { clocks: merged }
    }
    
    fn happens_before(other: VectorClock) -> Bool {
        var dominated = false
        for (node, time) in self.clocks.iter() {
            let other_time = other.clocks.get(node).unwrap_or(0)
            if *time > other_time { return false }
            if *time < other_time { dominated = true }
        }
        for (node, time) in other.clocks.iter() {
            if !self.clocks.contains_key(node) && *time > 0 {
                dominated = true
            }
        }
        dominated
    }
    
    fn concurrent_with(other: VectorClock) -> Bool {
        !self.happens_before(other) && !other.happens_before(self)
    }
}

// =============================================================================
// Error Types
// =============================================================================

/// Optimistic lock errors
enum OptimisticLockError {
    VersionConflict { expected: Version, actual: Version }
    StaleData { message: String }
    MaxRetriesExceeded { attempts: Int }
    ConcurrentModification { field: String }
    MergeConflict { conflicts: [String] }
    ValidationFailed { reason: String }
}

impl OptimisticLockError {
    fn is_retryable() -> Bool {
        match self {
            OptimisticLockError.VersionConflict { .. } => true
            OptimisticLockError.StaleData { .. } => true
            OptimisticLockError.ConcurrentModification { .. } => true
            _ => false
        }
    }
    
    fn message() -> String {
        match self {
            OptimisticLockError.VersionConflict { expected, actual } =>
                f"Version conflict: expected {expected}, got {actual}"
            OptimisticLockError.StaleData { message } =>
                f"Stale data: {message}"
            OptimisticLockError.MaxRetriesExceeded { attempts } =>
                f"Max retries exceeded after {attempts} attempts"
            OptimisticLockError.ConcurrentModification { field } =>
                f"Concurrent modification of field: {field}"
            OptimisticLockError.MergeConflict { conflicts } =>
                f"Merge conflicts in fields: {conflicts.join(\", \")}"
            OptimisticLockError.ValidationFailed { reason } =>
                f"Validation failed: {reason}"
        }
    }
}

// =============================================================================
// Versioned Data
// =============================================================================

/// Wrapper for versioned data with optimistic locking
struct Versioned<T> {
    data: T
    version: Version
    modified_at: Int64
    modified_by: Option<String>
    
    fn new(data: T) -> Self {
        Versioned {
            data: data,
            version: Version.new(),
            modified_at: @native("timestamp_ms"),
            modified_by: None
        }
    }
    
    fn with_owner(data: T, owner: String) -> Self {
        Versioned {
            data: data,
            version: Version.new(),
            modified_at: @native("timestamp_ms"),
            modified_by: Some(owner)
        }
    }
    
    /// Get the data (read-only)
    fn get() -> T { self.data }
    
    /// Get current version
    fn get_version() -> Version { self.version }
    
    /// Update data with version check
    fn update(new_data: T, expected_version: Version) -> Result<Self, OptimisticLockError> {
        if !self.version.is_same(expected_version) {
            return Err(OptimisticLockError.VersionConflict {
                expected: expected_version,
                actual: self.version
            })
        }
        
        Ok(Versioned {
            data: new_data,
            version: self.version.increment(),
            modified_at: @native("timestamp_ms"),
            modified_by: self.modified_by
        })
    }
    
    /// Force update (ignores version)
    fn force_update(new_data: T) -> Self {
        Versioned {
            data: new_data,
            version: self.version.increment(),
            modified_at: @native("timestamp_ms"),
            modified_by: self.modified_by
        }
    }
    
    /// Check if data is stale (older than threshold)
    fn is_stale(max_age_ms: Int64) -> Bool {
        @native("timestamp_ms") - self.modified_at > max_age_ms
    }
}

// =============================================================================
// Optimistic Lock Manager
// =============================================================================

/// Configuration for optimistic locking
struct OptimisticLockConfig {
    max_retries: Int
    retry_delay_ms: Int64
    backoff_multiplier: Float64
    max_delay_ms: Int64
    auto_merge: Bool
    
    fn default() -> Self {
        OptimisticLockConfig {
            max_retries: 5,
            retry_delay_ms: 10,
            backoff_multiplier: 2.0,
            max_delay_ms: 1000,
            auto_merge: false
        }
    }
    
    fn aggressive() -> Self {
        OptimisticLockConfig {
            max_retries: 10,
            retry_delay_ms: 5,
            backoff_multiplier: 1.5,
            max_delay_ms: 500,
            auto_merge: true
        }
    }
    
    fn conservative() -> Self {
        OptimisticLockConfig {
            max_retries: 3,
            retry_delay_ms: 50,
            backoff_multiplier: 2.0,
            max_delay_ms: 2000,
            auto_merge: false
        }
    }
}

/// Optimistic lock manager for coordinating updates
actor OptimisticLockManager<T> {
    state data: Versioned<T>
    state config: OptimisticLockConfig
    state pending_updates: Int
    state conflict_count: Int64
    state success_count: Int64
    
    fn new(initial_data: T) -> Self {
        OptimisticLockManager {
            data: Versioned.new(initial_data),
            config: OptimisticLockConfig.default(),
            pending_updates: 0,
            conflict_count: 0,
            success_count: 0
        }
    }
    
    fn with_config(initial_data: T, config: OptimisticLockConfig) -> Self {
        OptimisticLockManager {
            data: Versioned.new(initial_data),
            config: config,
            pending_updates: 0,
            conflict_count: 0,
            success_count: 0
        }
    }
    
    /// Read current data and version
    fn read() -> (T, Version) {
        (self.data.get(), self.data.get_version())
    }
    
    /// Compare and swap update
    fn compare_and_swap(new_data: T, expected_version: Version) -> Result<Version, OptimisticLockError> {
        match self.data.update(new_data, expected_version) {
            Ok(new_versioned) => {
                self.data = new_versioned
                self.success_count += 1
                Ok(self.data.get_version())
            }
            Err(e) => {
                self.conflict_count += 1
                Err(e)
            }
        }
    }
    
    /// Update with automatic retry
    fn update_with_retry(updater: fn(T) -> T) -> Result<Version, OptimisticLockError> {
        var attempts = 0
        var delay = self.config.retry_delay_ms
        
        while attempts < self.config.max_retries {
            let (current_data, version) = self.read()
            let new_data = updater(current_data)
            
            match self.compare_and_swap(new_data, version) {
                Ok(new_version) => return Ok(new_version)
                Err(e) if e.is_retryable() => {
                    attempts += 1
                    if attempts < self.config.max_retries {
                        @native("sleep_ms", delay)
                        delay = ((delay as Float64) * self.config.backoff_multiplier) as Int64
                        delay = delay.min(self.config.max_delay_ms)
                    }
                }
                Err(e) => return Err(e)
            }
        }
        
        Err(OptimisticLockError.MaxRetriesExceeded { attempts: attempts })
    }
    
    /// Get statistics
    fn stats() -> OptimisticLockStats {
        OptimisticLockStats {
            conflict_count: self.conflict_count,
            success_count: self.success_count,
            conflict_rate: if self.success_count + self.conflict_count > 0 {
                (self.conflict_count as Float64) / ((self.success_count + self.conflict_count) as Float64)
            } else { 0.0 },
            current_version: self.data.get_version()
        }
    }
}

struct OptimisticLockStats {
    conflict_count: Int64
    success_count: Int64
    conflict_rate: Float64
    current_version: Version
}

// =============================================================================
// Entity with Optimistic Locking
// =============================================================================

/// Trait for entities that support optimistic locking
trait OptimisticEntity {
    fn get_version() -> Version
    fn set_version(version: Version)
    fn validate() -> Result<(), String>
}

/// Base struct for optimistic entities
struct OptimisticEntityBase<T> {
    entity: T
    version: Version
    created_at: Int64
    updated_at: Int64
    etag: String
    
    fn new(entity: T) -> Self {
        let now = @native("timestamp_ms")
        OptimisticEntityBase {
            entity: entity,
            version: Version.new(),
            created_at: now,
            updated_at: now,
            etag: Self.generate_etag(Version.new(), now)
        }
    }
    
    fn generate_etag(version: Version, timestamp: Int64) -> String {
        let hash = @native("hash_combine", version.value, timestamp)
        f"\"{hash:x}\""
    }
    
    fn get_etag() -> String { self.etag }
    
    fn check_etag(expected_etag: String) -> Bool {
        self.etag == expected_etag
    }
    
    fn update(new_entity: T) -> Self {
        let now = @native("timestamp_ms")
        let new_version = self.version.increment()
        OptimisticEntityBase {
            entity: new_entity,
            version: new_version,
            created_at: self.created_at,
            updated_at: now,
            etag: Self.generate_etag(new_version, now)
        }
    }
}

// =============================================================================
// Compare-And-Swap Operations
// =============================================================================

/// Atomic compare-and-swap for optimistic updates
actor CAS<T> {
    state value: T
    state version: Int64
    
    fn new(initial: T) -> Self {
        CAS { value: initial, version: 0 }
    }
    
    /// Compare and swap atomically
    fn compare_and_swap(expected: T, new_value: T) -> Bool 
    where T: Eq {
        if self.value == expected {
            self.value = new_value
            self.version += 1
            true
        } else {
            false
        }
    }
    
    /// Compare version and swap
    fn compare_version_and_swap(expected_version: Int64, new_value: T) -> Result<Int64, OptimisticLockError> {
        if self.version == expected_version {
            self.value = new_value
            self.version += 1
            Ok(self.version)
        } else {
            Err(OptimisticLockError.VersionConflict {
                expected: Version.from(expected_version),
                actual: Version.from(self.version)
            })
        }
    }
    
    /// Get current value and version
    fn get() -> (T, Int64) {
        (self.value, self.version)
    }
    
    /// Update with function
    fn update(f: fn(T) -> T) -> Int64 {
        self.value = f(self.value)
        self.version += 1
        self.version
    }
}

// =============================================================================
// Optimistic Transaction
// =============================================================================

/// Read set entry for optimistic transaction
struct ReadSetEntry {
    key: String
    version: Version
}

/// Write set entry for optimistic transaction
struct WriteSetEntry<T> {
    key: String
    value: T
    original_version: Version
}

/// Optimistic transaction for multi-key updates
actor OptimisticTransaction<T> {
    state read_set: [ReadSetEntry]
    state write_set: [WriteSetEntry<T>]
    state status: TransactionStatus
    state started_at: Int64
    
    fn new() -> Self {
        OptimisticTransaction {
            read_set: [],
            write_set: [],
            status: TransactionStatus.Active,
            started_at: @native("timestamp_ms")
        }
    }
    
    /// Record a read operation
    fn record_read(key: String, version: Version) {
        self.read_set.push(ReadSetEntry { key: key, version: version })
    }
    
    /// Record a write operation
    fn record_write(key: String, value: T, original_version: Version) {
        self.write_set.push(WriteSetEntry { 
            key: key, 
            value: value, 
            original_version: original_version 
        })
    }
    
    /// Validate read set (check no concurrent modifications)
    fn validate<S: VersionStore<T>>(store: S) -> Result<(), OptimisticLockError> {
        for entry in self.read_set.iter() {
            match store.get_version(entry.key.clone()) {
                Ok(current_version) => {
                    if !current_version.is_same(entry.version) {
                        return Err(OptimisticLockError.VersionConflict {
                            expected: entry.version,
                            actual: current_version
                        })
                    }
                }
                Err(e) => return Err(OptimisticLockError.ValidationFailed { 
                    reason: e.to_string() 
                })
            }
        }
        Ok(())
    }
    
    /// Commit transaction
    fn commit<S: VersionStore<T>>(store: S) -> Result<(), OptimisticLockError> {
        // Validate read set
        self.validate(store)?
        
        // Apply writes
        for entry in self.write_set.iter() {
            match store.compare_and_set(
                entry.key.clone(), 
                entry.value.clone(), 
                entry.original_version
            ) {
                Ok(_) => {}
                Err(e) => {
                    self.status = TransactionStatus.Aborted
                    return Err(e)
                }
            }
        }
        
        self.status = TransactionStatus.Committed
        Ok(())
    }
    
    /// Abort transaction
    fn abort() {
        self.status = TransactionStatus.Aborted
        self.read_set.clear()
        self.write_set.clear()
    }
    
    fn is_active() -> Bool {
        match self.status {
            TransactionStatus.Active => true
            _ => false
        }
    }
}

enum TransactionStatus {
    Active
    Committed
    Aborted
}

/// Trait for version-aware storage
trait VersionStore<T> {
    fn get(key: String) -> Result<(T, Version), String>
    fn get_version(key: String) -> Result<Version, String>
    fn compare_and_set(key: String, value: T, expected_version: Version) -> Result<Version, OptimisticLockError>
}

// =============================================================================
// Conflict Resolution
// =============================================================================

/// Conflict resolution strategy
enum ConflictResolution<T> {
    KeepLocal
    KeepRemote
    Merge { merger: fn(T, T) -> T }
    Custom { resolver: fn(T, T, Version, Version) -> Result<T, OptimisticLockError> }
}

/// Conflict resolver for automatic conflict handling
struct ConflictResolver<T> {
    strategy: ConflictResolution<T>
    
    fn keep_local() -> Self {
        ConflictResolver { strategy: ConflictResolution.KeepLocal }
    }
    
    fn keep_remote() -> Self {
        ConflictResolver { strategy: ConflictResolution.KeepRemote }
    }
    
    fn merge(merger: fn(T, T) -> T) -> Self {
        ConflictResolver { strategy: ConflictResolution.Merge { merger: merger } }
    }
    
    fn resolve(local: T, remote: T, local_version: Version, remote_version: Version) -> Result<T, OptimisticLockError> {
        match self.strategy {
            ConflictResolution.KeepLocal => Ok(local)
            ConflictResolution.KeepRemote => Ok(remote)
            ConflictResolution.Merge { merger } => Ok(merger(local, remote))
            ConflictResolution.Custom { resolver } => resolver(local, remote, local_version, remote_version)
        }
    }
}

/// Three-way merge for conflict resolution
struct ThreeWayMerge<T> {
    fn merge(base: T, local: T, remote: T, field_merger: fn(String, T, T, T) -> Result<T, [String]>) -> Result<T, OptimisticLockError> {
        match field_merger("root".to_string(), base, local, remote) {
            Ok(merged) => Ok(merged)
            Err(conflicts) => Err(OptimisticLockError.MergeConflict { conflicts: conflicts })
        }
    }
}

// =============================================================================
// Retry Strategies
// =============================================================================

/// Retry strategy for optimistic operations
enum RetryStrategy {
    Fixed { delay_ms: Int64, max_retries: Int }
    Exponential { initial_delay_ms: Int64, max_delay_ms: Int64, max_retries: Int }
    Jittered { base_delay_ms: Int64, max_retries: Int }
    Immediate { max_retries: Int }
}

impl RetryStrategy {
    fn fixed(delay_ms: Int64, max_retries: Int) -> Self {
        RetryStrategy.Fixed { delay_ms: delay_ms, max_retries: max_retries }
    }
    
    fn exponential(initial_delay_ms: Int64, max_delay_ms: Int64, max_retries: Int) -> Self {
        RetryStrategy.Exponential { 
            initial_delay_ms: initial_delay_ms, 
            max_delay_ms: max_delay_ms, 
            max_retries: max_retries 
        }
    }
    
    fn get_delay(attempt: Int) -> Int64 {
        match self {
            RetryStrategy.Fixed { delay_ms, .. } => delay_ms
            RetryStrategy.Exponential { initial_delay_ms, max_delay_ms, .. } => {
                let delay = initial_delay_ms * (1 << attempt)
                delay.min(max_delay_ms)
            }
            RetryStrategy.Jittered { base_delay_ms, .. } => {
                let jitter = @native("random_int64", 0, base_delay_ms / 2)
                base_delay_ms + jitter
            }
            RetryStrategy.Immediate { .. } => 0
        }
    }
    
    fn max_retries() -> Int {
        match self {
            RetryStrategy.Fixed { max_retries, .. } => max_retries
            RetryStrategy.Exponential { max_retries, .. } => max_retries
            RetryStrategy.Jittered { max_retries, .. } => max_retries
            RetryStrategy.Immediate { max_retries } => max_retries
        }
    }
}

/// Execute operation with retry strategy
fn with_retry<T, E>(
    strategy: RetryStrategy,
    operation: fn() -> Result<T, E>
) -> Result<T, OptimisticLockError> 
where E: Display {
    var attempt = 0
    let max = strategy.max_retries()
    
    while attempt < max {
        match operation() {
            Ok(result) => return Ok(result)
            Err(e) => {
                attempt += 1
                if attempt < max {
                    let delay = strategy.get_delay(attempt)
                    if delay > 0 {
                        @native("sleep_ms", delay)
                    }
                }
            }
        }
    }
    
    Err(OptimisticLockError.MaxRetriesExceeded { attempts: attempt })
}

// =============================================================================
// Database Integration Helpers
// =============================================================================

/// SQL builder for optimistic locking queries
struct OptimisticSqlBuilder {
    table: String
    version_column: String
    
    fn new(table: String) -> Self {
        OptimisticSqlBuilder { 
            table: table, 
            version_column: "version".to_string() 
        }
    }
    
    fn with_version_column(table: String, version_column: String) -> Self {
        OptimisticSqlBuilder { 
            table: table, 
            version_column: version_column 
        }
    }
    
    /// Generate UPDATE with version check
    fn update_sql(set_clause: String, where_clause: String, expected_version: Int64) -> String {
        f"UPDATE {self.table} SET {set_clause}, {self.version_column} = {self.version_column} + 1 WHERE {where_clause} AND {self.version_column} = {expected_version}"
    }
    
    /// Generate SELECT with version
    fn select_sql(columns: String, where_clause: String) -> String {
        f"SELECT {columns}, {self.version_column} FROM {self.table} WHERE {where_clause}"
    }
    
    /// Check if update affected rows (version matched)
    fn check_affected_rows(affected: Int) -> Result<(), OptimisticLockError> {
        if affected == 0 {
            Err(OptimisticLockError.StaleData { 
                message: "No rows updated - version mismatch".to_string() 
            })
        } else {
            Ok(())
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "version increment" {
    let v1 = Version.new()
    let v2 = v1.increment()
    assert(v2.is_newer_than(v1))?
    assert_eq(v2.value, 1)?
}

test "versioned data update" {
    let versioned = Versioned.new(42)
    let v0 = versioned.get_version()
    
    let updated = versioned.update(100, v0)?
    assert_eq(updated.get(), 100)?
    assert(updated.get_version().is_newer_than(v0))?
}

test "versioned data conflict" {
    let versioned = Versioned.new(42)
    let v0 = versioned.get_version()
    
    let updated = versioned.update(100, v0)?
    let result = updated.update(200, v0)
    
    assert(result.is_err())?
}

test "optimistic lock manager" {
    let manager = OptimisticLockManager.new(0)
    
    let result = manager.update_with_retry(|x| x + 1)
    assert(result.is_ok())?
    
    let (value, _) = manager.read()
    assert_eq(value, 1)?
}

test "compare and swap" {
    let cas = CAS.new(10)
    
    assert(cas.compare_and_swap(10, 20))?
    assert(!cas.compare_and_swap(10, 30))?
    
    let (value, version) = cas.get()
    assert_eq(value, 20)?
    assert_eq(version, 1)?
}

test "vector clock ordering" {
    var vc1 = VectorClock.new()
    vc1 = vc1.increment("node1".to_string())
    
    var vc2 = VectorClock.new()
    vc2 = vc2.increment("node1".to_string())
    vc2 = vc2.increment("node2".to_string())
    
    assert(vc1.happens_before(vc2))?
    assert(!vc2.happens_before(vc1))?
}

test "retry strategy delays" {
    let fixed = RetryStrategy.fixed(100, 3)
    assert_eq(fixed.get_delay(0), 100)?
    assert_eq(fixed.get_delay(2), 100)?
    
    let exp = RetryStrategy.exponential(10, 1000, 5)
    assert_eq(exp.get_delay(0), 10)?
    assert_eq(exp.get_delay(3), 80)?
}

test "conflict resolver" {
    let resolver = ConflictResolver.merge(|a: Int, b: Int| a + b)
    let result = resolver.resolve(10, 20, Version.from(1), Version.from(2))
    assert_eq(result?, 30)?
}

test "timestamp version ordering" {
    let v1 = TimestampVersion.new()
    @native("sleep_ms", 1)
    let v2 = TimestampVersion.new()
    
    assert(v2.is_newer_than(v1))?
}
