// =============================================================================
// Vibee OS â€” Compress Module
// Compression and decompression
// =============================================================================

/// Compression level
enum Level { None, Fast, Default, Best }
impl Level { fn value() -> Int { match self { None => 0, Fast => 1, Default => 6, Best => 9 } } }

// =============================================================================
// GZIP
// =============================================================================

/// Gzip compress
fn gzip_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { gzip_compress_level(data, Level.Default) }
fn gzip_compress_level(data: [UInt8], level: Level) -> Result<[UInt8], CompressError> { @native("gzip_compress", data, level.value()) }

/// Gzip decompress
fn gzip_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("gzip_decompress", data) }

/// Gzip encoder (streaming)
struct GzipEncoder { inner: @native("GzipEncoder") }
impl GzipEncoder {
    fn new() -> Self { Self.with_level(Level.Default) }
    fn with_level(level: Level) -> Self { GzipEncoder { inner: @native("gzip_encoder_new", level.value()) } }
    fn write(data: [UInt8]) -> Result<(), CompressError> { @native("gzip_encoder_write", self.inner, data) }
    fn finish() -> Result<[UInt8], CompressError> { @native("gzip_encoder_finish", self.inner) }
}

/// Gzip decoder (streaming)
struct GzipDecoder { inner: @native("GzipDecoder") }
impl GzipDecoder {
    fn new() -> Self { GzipDecoder { inner: @native("gzip_decoder_new") } }
    fn write(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("gzip_decoder_write", self.inner, data) }
    fn finish() -> Result<[UInt8], CompressError> { @native("gzip_decoder_finish", self.inner) }
}

// =============================================================================
// DEFLATE
// =============================================================================

fn deflate_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { deflate_compress_level(data, Level.Default) }
fn deflate_compress_level(data: [UInt8], level: Level) -> Result<[UInt8], CompressError> { @native("deflate_compress", data, level.value()) }
fn deflate_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("deflate_decompress", data) }

// =============================================================================
// ZLIB
// =============================================================================

fn zlib_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { zlib_compress_level(data, Level.Default) }
fn zlib_compress_level(data: [UInt8], level: Level) -> Result<[UInt8], CompressError> { @native("zlib_compress", data, level.value()) }
fn zlib_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("zlib_decompress", data) }

// =============================================================================
// BROTLI
// =============================================================================

fn brotli_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { brotli_compress_level(data, Level.Default) }
fn brotli_compress_level(data: [UInt8], level: Level) -> Result<[UInt8], CompressError> { @native("brotli_compress", data, level.value()) }
fn brotli_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("brotli_decompress", data) }

// =============================================================================
// ZSTD
// =============================================================================

fn zstd_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { zstd_compress_level(data, 3) }
fn zstd_compress_level(data: [UInt8], level: Int) -> Result<[UInt8], CompressError> { @native("zstd_compress", data, level) }
fn zstd_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("zstd_decompress", data) }

/// Zstd with dictionary
fn zstd_compress_dict(data: [UInt8], dict: [UInt8]) -> Result<[UInt8], CompressError> { @native("zstd_compress_dict", data, dict) }
fn zstd_decompress_dict(data: [UInt8], dict: [UInt8]) -> Result<[UInt8], CompressError> { @native("zstd_decompress_dict", data, dict) }

// =============================================================================
// LZ4
// =============================================================================

fn lz4_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("lz4_compress", data) }
fn lz4_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("lz4_decompress", data) }
fn lz4_compress_hc(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("lz4_compress_hc", data) }

// =============================================================================
// SNAPPY
// =============================================================================

fn snappy_compress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("snappy_compress", data) }
fn snappy_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { @native("snappy_decompress", data) }

// =============================================================================
// Generic Interface
// =============================================================================

enum Algorithm { Gzip, Deflate, Zlib, Brotli, Zstd, Lz4, Snappy }

fn compress(data: [UInt8], algo: Algorithm) -> Result<[UInt8], CompressError> {
    match algo {
        Gzip => gzip_compress(data)
        Deflate => deflate_compress(data)
        Zlib => zlib_compress(data)
        Brotli => brotli_compress(data)
        Zstd => zstd_compress(data)
        Lz4 => lz4_compress(data)
        Snappy => snappy_compress(data)
    }
}

fn decompress(data: [UInt8], algo: Algorithm) -> Result<[UInt8], CompressError> {
    match algo {
        Gzip => gzip_decompress(data)
        Deflate => deflate_decompress(data)
        Zlib => zlib_decompress(data)
        Brotli => brotli_decompress(data)
        Zstd => zstd_decompress(data)
        Lz4 => lz4_decompress(data)
        Snappy => snappy_decompress(data)
    }
}

/// Auto-detect and decompress
fn auto_decompress(data: [UInt8]) -> Result<[UInt8], CompressError> {
    if data.len() < 2 { return Err(CompressError.InvalidData) }
    
    // Gzip magic: 1f 8b
    if data[0] == 0x1f && data[1] == 0x8b { return gzip_decompress(data) }
    
    // Zlib: 78 01/9c/da
    if data[0] == 0x78 && (data[1] == 0x01 || data[1] == 0x9c || data[1] == 0xda) { return zlib_decompress(data) }
    
    // Zstd magic: 28 b5 2f fd
    if data.len() >= 4 && data[0] == 0x28 && data[1] == 0xb5 && data[2] == 0x2f && data[3] == 0xfd { return zstd_decompress(data) }
    
    // LZ4 frame magic: 04 22 4d 18
    if data.len() >= 4 && data[0] == 0x04 && data[1] == 0x22 && data[2] == 0x4d && data[3] == 0x18 { return lz4_decompress(data) }
    
    Err(CompressError.UnknownFormat)
}

/// Compression ratio
fn ratio(original: Int, compressed: Int) -> Float64 {
    if original == 0 { return 0.0 }
    1.0 - (compressed as Float64 / original as Float64)
}

enum CompressError { InvalidData, BufferTooSmall, UnknownFormat, Other(String) }
impl Display for CompressError {
    fn fmt(f: Formatter) { match self { InvalidData => f.write("Invalid compressed data"), BufferTooSmall => f.write("Buffer too small"), UnknownFormat => f.write("Unknown compression format"), Other(s) => f.write(s) } }
}

// =============================================================================
// Compressor/Decompressor Traits
// =============================================================================

trait Compressor {
    fn compress(data: [UInt8]) -> Result<[UInt8], CompressError>
}

trait Decompressor {
    fn decompress(data: [UInt8]) -> Result<[UInt8], CompressError>
}

struct GzipCompressor { level: Level }
impl GzipCompressor { fn new() -> Self { GzipCompressor { level: Level.Default } } fn level(l: Level) -> Self { self.level = l; self } }
impl Compressor for GzipCompressor { fn compress(data: [UInt8]) -> Result<[UInt8], CompressError> { gzip_compress_level(data, self.level) } }

struct GzipDecompressor {}
impl GzipDecompressor { fn new() -> Self { GzipDecompressor {} } }
impl Decompressor for GzipDecompressor { fn decompress(data: [UInt8]) -> Result<[UInt8], CompressError> { gzip_decompress(data) } }

// Tests
test "gzip roundtrip" {
    let original = "Hello, World! This is a test of compression.".as_bytes()
    let compressed = gzip_compress(original)?
    let decompressed = gzip_decompress(compressed)?
    assert_eq(decompressed, original)?
}

test "compression ratio" {
    let data = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa".as_bytes()
    let compressed = gzip_compress(data)?
    assert(compressed.len() < data.len())?
}

test "levels" {
    let data = "test data for compression".as_bytes()
    let fast = gzip_compress_level(data, Level.Fast)?
    let best = gzip_compress_level(data, Level.Best)?
    // Best should be smaller or equal
    assert(best.len() <= fast.len())?
}
