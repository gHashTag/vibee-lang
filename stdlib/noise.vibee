// =============================================================================
// Vibee OS â€” Noise Module
// Procedural noise generation (Perlin, Simplex, etc.)
// =============================================================================

use rng::{Rng, Xoshiro256StarStar}

const PI: Float = 3.141592653589793

// -----------------------------------------------------------------------------
// Perlin Noise
// -----------------------------------------------------------------------------

struct PerlinNoise {
    perm: [Int; 512]
    
    fn new(seed: UInt64) -> Self {
        var rng = Xoshiro256StarStar.new(seed)
        var p: [Int; 256] = (0..256).collect()
        
        // Shuffle
        for i in (1..256).rev() {
            let j = rng.next_range(0, i + 1)
            p.swap(i, j)
        }
        
        var perm = [0; 512]
        for i in 0..512 { perm[i] = p[i & 255] }
        
        PerlinNoise { perm: perm }
    }
    
    fn noise2d(x: Float, y: Float) -> Float {
        let xi = x.floor() as Int & 255
        let yi = y.floor() as Int & 255
        let xf = x - x.floor()
        let yf = y - y.floor()
        
        let u = fade(xf)
        let v = fade(yf)
        
        let aa = self.perm[self.perm[xi] + yi]
        let ab = self.perm[self.perm[xi] + yi + 1]
        let ba = self.perm[self.perm[xi + 1] + yi]
        let bb = self.perm[self.perm[xi + 1] + yi + 1]
        
        lerp(v,
            lerp(u, grad2d(aa, xf, yf), grad2d(ba, xf - 1.0, yf)),
            lerp(u, grad2d(ab, xf, yf - 1.0), grad2d(bb, xf - 1.0, yf - 1.0))
        )
    }
    
    fn noise3d(x: Float, y: Float, z: Float) -> Float {
        let xi = x.floor() as Int & 255
        let yi = y.floor() as Int & 255
        let zi = z.floor() as Int & 255
        let xf = x - x.floor()
        let yf = y - y.floor()
        let zf = z - z.floor()
        
        let u = fade(xf)
        let v = fade(yf)
        let w = fade(zf)
        
        let aaa = self.perm[self.perm[self.perm[xi] + yi] + zi]
        let aba = self.perm[self.perm[self.perm[xi] + yi + 1] + zi]
        let aab = self.perm[self.perm[self.perm[xi] + yi] + zi + 1]
        let abb = self.perm[self.perm[self.perm[xi] + yi + 1] + zi + 1]
        let baa = self.perm[self.perm[self.perm[xi + 1] + yi] + zi]
        let bba = self.perm[self.perm[self.perm[xi + 1] + yi + 1] + zi]
        let bab = self.perm[self.perm[self.perm[xi + 1] + yi] + zi + 1]
        let bbb = self.perm[self.perm[self.perm[xi + 1] + yi + 1] + zi + 1]
        
        lerp(w,
            lerp(v,
                lerp(u, grad3d(aaa, xf, yf, zf), grad3d(baa, xf-1.0, yf, zf)),
                lerp(u, grad3d(aba, xf, yf-1.0, zf), grad3d(bba, xf-1.0, yf-1.0, zf))
            ),
            lerp(v,
                lerp(u, grad3d(aab, xf, yf, zf-1.0), grad3d(bab, xf-1.0, yf, zf-1.0)),
                lerp(u, grad3d(abb, xf, yf-1.0, zf-1.0), grad3d(bbb, xf-1.0, yf-1.0, zf-1.0))
            )
        )
    }
    
    fn fbm2d(x: Float, y: Float, octaves: Int, persistence: Float) -> Float {
        var total = 0.0
        var amplitude = 1.0
        var frequency = 1.0
        var max_value = 0.0
        
        for _ in 0..octaves {
            total += self.noise2d(x * frequency, y * frequency) * amplitude
            max_value += amplitude
            amplitude *= persistence
            frequency *= 2.0
        }
        total / max_value
    }
    
    fn fbm3d(x: Float, y: Float, z: Float, octaves: Int, persistence: Float) -> Float {
        var total = 0.0
        var amplitude = 1.0
        var frequency = 1.0
        var max_value = 0.0
        
        for _ in 0..octaves {
            total += self.noise3d(x * frequency, y * frequency, z * frequency) * amplitude
            max_value += amplitude
            amplitude *= persistence
            frequency *= 2.0
        }
        total / max_value
    }
}

// -----------------------------------------------------------------------------
// Simplex Noise
// -----------------------------------------------------------------------------

struct SimplexNoise {
    perm: [Int; 512]
    
    fn new(seed: UInt64) -> Self {
        var rng = Xoshiro256StarStar.new(seed)
        var p: [Int; 256] = (0..256).collect()
        for i in (1..256).rev() { let j = rng.next_range(0, i + 1); p.swap(i, j) }
        var perm = [0; 512]
        for i in 0..512 { perm[i] = p[i & 255] }
        SimplexNoise { perm: perm }
    }
    
    fn noise2d(x: Float, y: Float) -> Float {
        const F2: Float = 0.5 * (1.7320508075688772 - 1.0)
        const G2: Float = (3.0 - 1.7320508075688772) / 6.0
        
        let s = (x + y) * F2
        let i = (x + s).floor() as Int
        let j = (y + s).floor() as Int
        let t = (i + j) as Float * G2
        
        let x0 = x - (i as Float - t)
        let y0 = y - (j as Float - t)
        
        let (i1, j1) = if x0 > y0 { (1, 0) } else { (0, 1) }
        let x1 = x0 - i1 as Float + G2
        let y1 = y0 - j1 as Float + G2
        let x2 = x0 - 1.0 + 2.0 * G2
        let y2 = y0 - 1.0 + 2.0 * G2
        
        let ii = i & 255
        let jj = j & 255
        
        var n0 = 0.0
        var t0 = 0.5 - x0*x0 - y0*y0
        if t0 >= 0.0 {
            t0 *= t0
            let gi0 = self.perm[ii + self.perm[jj]] % 12
            n0 = t0 * t0 * dot2d(GRAD3[gi0], x0, y0)
        }
        
        var n1 = 0.0
        var t1 = 0.5 - x1*x1 - y1*y1
        if t1 >= 0.0 {
            t1 *= t1
            let gi1 = self.perm[ii + i1 + self.perm[jj + j1]] % 12
            n1 = t1 * t1 * dot2d(GRAD3[gi1], x1, y1)
        }
        
        var n2 = 0.0
        var t2 = 0.5 - x2*x2 - y2*y2
        if t2 >= 0.0 {
            t2 *= t2
            let gi2 = self.perm[ii + 1 + self.perm[jj + 1]] % 12
            n2 = t2 * t2 * dot2d(GRAD3[gi2], x2, y2)
        }
        
        70.0 * (n0 + n1 + n2)
    }
    
    fn noise3d(x: Float, y: Float, z: Float) -> Float {
        const F3: Float = 1.0 / 3.0
        const G3: Float = 1.0 / 6.0
        
        let s = (x + y + z) * F3
        let i = (x + s).floor() as Int
        let j = (y + s).floor() as Int
        let k = (z + s).floor() as Int
        let t = (i + j + k) as Float * G3
        
        let x0 = x - (i as Float - t)
        let y0 = y - (j as Float - t)
        let z0 = z - (k as Float - t)
        
        let (i1, j1, k1, i2, j2, k2) = if x0 >= y0 {
            if y0 >= z0 { (1,0,0,1,1,0) }
            else if x0 >= z0 { (1,0,0,1,0,1) }
            else { (0,0,1,1,0,1) }
        } else {
            if y0 < z0 { (0,0,1,0,1,1) }
            else if x0 < z0 { (0,1,0,0,1,1) }
            else { (0,1,0,1,1,0) }
        }
        
        let x1 = x0 - i1 as Float + G3
        let y1 = y0 - j1 as Float + G3
        let z1 = z0 - k1 as Float + G3
        let x2 = x0 - i2 as Float + 2.0*G3
        let y2 = y0 - j2 as Float + 2.0*G3
        let z2 = z0 - k2 as Float + 2.0*G3
        let x3 = x0 - 1.0 + 3.0*G3
        let y3 = y0 - 1.0 + 3.0*G3
        let z3 = z0 - 1.0 + 3.0*G3
        
        let ii = i & 255
        let jj = j & 255
        let kk = k & 255
        
        var n = 0.0
        for (dx, dy, dz, di, dj, dk) in [
            (x0,y0,z0,0,0,0), (x1,y1,z1,i1,j1,k1),
            (x2,y2,z2,i2,j2,k2), (x3,y3,z3,1,1,1)
        ] {
            var t = 0.6 - dx*dx - dy*dy - dz*dz
            if t > 0.0 {
                let gi = self.perm[ii+di+self.perm[jj+dj+self.perm[kk+dk]]] % 12
                t *= t
                n += t * t * (GRAD3[gi].0*dx + GRAD3[gi].1*dy + GRAD3[gi].2*dz)
            }
        }
        32.0 * n
    }
    
    fn fbm2d(x: Float, y: Float, octaves: Int, persistence: Float) -> Float {
        var total = 0.0; var amp = 1.0; var freq = 1.0; var max = 0.0
        for _ in 0..octaves {
            total += self.noise2d(x*freq, y*freq) * amp
            max += amp; amp *= persistence; freq *= 2.0
        }
        total / max
    }
}

const GRAD3: [(Float, Float, Float); 12] = [
    (1.0,1.0,0.0),(-1.0,1.0,0.0),(1.0,-1.0,0.0),(-1.0,-1.0,0.0),
    (1.0,0.0,1.0),(-1.0,0.0,1.0),(1.0,0.0,-1.0),(-1.0,0.0,-1.0),
    (0.0,1.0,1.0),(0.0,-1.0,1.0),(0.0,1.0,-1.0),(0.0,-1.0,-1.0)
]

// -----------------------------------------------------------------------------
// Value Noise
// -----------------------------------------------------------------------------

struct ValueNoise {
    values: [Float; 256]
    perm: [Int; 512]
    
    fn new(seed: UInt64) -> Self {
        var rng = Xoshiro256StarStar.new(seed)
        var values = [0.0; 256]
        var p: [Int; 256] = (0..256).collect()
        
        for i in 0..256 { values[i] = rng.next_float() * 2.0 - 1.0 }
        for i in (1..256).rev() { let j = rng.next_range(0, i + 1); p.swap(i, j) }
        
        var perm = [0; 512]
        for i in 0..512 { perm[i] = p[i & 255] }
        
        ValueNoise { values: values, perm: perm }
    }
    
    fn noise2d(x: Float, y: Float) -> Float {
        let xi = x.floor() as Int & 255
        let yi = y.floor() as Int & 255
        let xf = x - x.floor()
        let yf = y - y.floor()
        let u = fade(xf)
        let v = fade(yf)
        
        let aa = self.values[self.perm[self.perm[xi] + yi]]
        let ab = self.values[self.perm[self.perm[xi] + yi + 1]]
        let ba = self.values[self.perm[self.perm[xi + 1] + yi]]
        let bb = self.values[self.perm[self.perm[xi + 1] + yi + 1]]
        
        lerp(v, lerp(u, aa, ba), lerp(u, ab, bb))
    }
}

// -----------------------------------------------------------------------------
// Worley (Cellular) Noise
// -----------------------------------------------------------------------------

struct WorleyNoise {
    seed: UInt64
    
    fn new(seed: UInt64) -> Self { WorleyNoise { seed: seed } }
    
    fn noise2d(x: Float, y: Float) -> Float {
        let xi = x.floor() as Int
        let yi = y.floor() as Int
        let xf = x - x.floor()
        let yf = y - y.floor()
        
        var min_dist = 10.0
        
        for di in -1..=1 {
            for dj in -1..=1 {
                let (px, py) = self.cell_point(xi + di, yi + dj)
                let dx = di as Float + px - xf
                let dy = dj as Float + py - yf
                let dist = (dx*dx + dy*dy).sqrt()
                if dist < min_dist { min_dist = dist }
            }
        }
        min_dist
    }
    
    fn cell_point(x: Int, y: Int) -> (Float, Float) {
        var rng = Xoshiro256StarStar.new(self.seed ^ (x as UInt64 * 1299709) ^ (y as UInt64 * 1000003))
        (rng.next_float(), rng.next_float())
    }
}

// -----------------------------------------------------------------------------
// Ridged Noise
// -----------------------------------------------------------------------------

fn ridged_noise<N: Noise2D>(noise: N, x: Float, y: Float, octaves: Int, lacunarity: Float, gain: Float) -> Float {
    var sum = 0.0; var amp = 0.5; var freq = 1.0
    for _ in 0..octaves {
        var n = noise.noise2d(x * freq, y * freq)
        n = 1.0 - n.abs()
        n = n * n
        sum += n * amp
        amp *= gain
        freq *= lacunarity
    }
    sum
}

// -----------------------------------------------------------------------------
// Turbulence
// -----------------------------------------------------------------------------

fn turbulence<N: Noise2D>(noise: N, x: Float, y: Float, octaves: Int) -> Float {
    var sum = 0.0; var freq = 1.0; var amp = 1.0
    for _ in 0..octaves {
        sum += noise.noise2d(x * freq, y * freq).abs() * amp
        freq *= 2.0
        amp *= 0.5
    }
    sum
}

// -----------------------------------------------------------------------------
// Domain Warping
// -----------------------------------------------------------------------------

fn domain_warp<N: Noise2D>(noise: N, x: Float, y: Float, strength: Float) -> Float {
    let qx = noise.noise2d(x, y)
    let qy = noise.noise2d(x + 5.2, y + 1.3)
    noise.noise2d(x + strength * qx, y + strength * qy)
}

// -----------------------------------------------------------------------------
// Noise Trait
// -----------------------------------------------------------------------------

trait Noise2D { fn noise2d(x: Float, y: Float) -> Float }
trait Noise3D { fn noise3d(x: Float, y: Float, z: Float) -> Float }

impl Noise2D for PerlinNoise { fn noise2d(x: Float, y: Float) -> Float { self.noise2d(x, y) } }
impl Noise3D for PerlinNoise { fn noise3d(x: Float, y: Float, z: Float) -> Float { self.noise3d(x, y, z) } }
impl Noise2D for SimplexNoise { fn noise2d(x: Float, y: Float) -> Float { self.noise2d(x, y) } }
impl Noise3D for SimplexNoise { fn noise3d(x: Float, y: Float, z: Float) -> Float { self.noise3d(x, y, z) } }
impl Noise2D for ValueNoise { fn noise2d(x: Float, y: Float) -> Float { self.noise2d(x, y) } }
impl Noise2D for WorleyNoise { fn noise2d(x: Float, y: Float) -> Float { self.noise2d(x, y) } }

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

fn fade(t: Float) -> Float { t * t * t * (t * (t * 6.0 - 15.0) + 10.0) }
fn lerp(t: Float, a: Float, b: Float) -> Float { a + t * (b - a) }
fn grad2d(hash: Int, x: Float, y: Float) -> Float {
    match hash & 3 { 0 => x + y, 1 => -x + y, 2 => x - y, _ => -x - y }
}
fn grad3d(hash: Int, x: Float, y: Float, z: Float) -> Float {
    let h = hash & 15
    let u = if h < 8 { x } else { y }
    let v = if h < 4 { y } else if h == 12 || h == 14 { x } else { z }
    (if h & 1 == 0 { u } else { -u }) + (if h & 2 == 0 { v } else { -v })
}
fn dot2d(g: (Float, Float, Float), x: Float, y: Float) -> Float { g.0 * x + g.1 * y }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "perlin noise range" {
    let noise = PerlinNoise.new(42)
    for i in 0..100 {
        let v = noise.noise2d(i as Float * 0.1, i as Float * 0.1)
        assert(v >= -1.0 && v <= 1.0)?
    }
}

test "simplex noise deterministic" {
    let n1 = SimplexNoise.new(42)
    let n2 = SimplexNoise.new(42)
    assert_eq(n1.noise2d(1.5, 2.5), n2.noise2d(1.5, 2.5))?
}

test "worley noise positive" {
    let noise = WorleyNoise.new(42)
    for i in 0..100 {
        let v = noise.noise2d(i as Float * 0.1, i as Float * 0.1)
        assert(v >= 0.0)?
    }
}
