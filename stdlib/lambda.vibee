// =============================================================================
// Vibee OS â€” Lambda Module
// Serverless Functions (AWS Lambda, GCP Cloud Functions, Azure Functions, etc.)
// =============================================================================

// -----------------------------------------------------------------------------
// Lambda Handler Trait
// -----------------------------------------------------------------------------

/// Trait for Lambda function handlers
trait Handler<Event, Response> {
    fn handle(event: Event, context: Context) -> Result<Response, LambdaError>
}

/// Async handler trait
trait AsyncHandler<Event, Response> {
    async fn handle(event: Event, context: Context) -> Result<Response, LambdaError>
}

// -----------------------------------------------------------------------------
// Lambda Context
// -----------------------------------------------------------------------------

struct Context {
    request_id: String
    function_name: String
    function_version: String
    memory_limit_mb: Int
    log_group_name: String
    log_stream_name: String
    invoked_function_arn: String
    deadline_ms: Int64
    identity: CognitoIdentity?
    client_context: ClientContext?
}

impl Context {
    fn remaining_time_ms() -> Int64 {
        self.deadline_ms - Instant.now().millis()
    }
    
    fn is_timeout_imminent(threshold_ms: Int64 = 1000) -> Bool {
        self.remaining_time_ms() < threshold_ms
    }
}

struct CognitoIdentity { identity_id: String, identity_pool_id: String }
struct ClientContext { client: ClientApplication, custom: Map<String, String>, env: Map<String, String> }
struct ClientApplication { installation_id: String, app_title: String, app_version_name: String, app_version_code: String, app_package_name: String }

// -----------------------------------------------------------------------------
// Lambda Runtime
// -----------------------------------------------------------------------------

actor LambdaRuntime<Event: Deserialize, Response: Serialize> {
    state handler: fn(Event, Context) -> Result<Response, LambdaError>
    state runtime_api: String
    
    init(handler: fn(Event, Context) -> Result<Response, LambdaError>) {
        self.handler = handler
        self.runtime_api = env.get("AWS_LAMBDA_RUNTIME_API").unwrap_or("localhost:9001")
    }
    
    on run() -> Result<(), LambdaError> {
        loop {
            // Get next invocation
            let invocation = self.get_next_invocation()?
            
            // Parse event
            let event: Event = json.decode(invocation.body)?
            
            // Create context
            let context = Context {
                request_id: invocation.request_id,
                function_name: env.get("AWS_LAMBDA_FUNCTION_NAME").unwrap_or(""),
                function_version: env.get("AWS_LAMBDA_FUNCTION_VERSION").unwrap_or("$LATEST"),
                memory_limit_mb: env.get("AWS_LAMBDA_FUNCTION_MEMORY_SIZE").and_then(|s| Int.parse(s).ok()).unwrap_or(128),
                log_group_name: env.get("AWS_LAMBDA_LOG_GROUP_NAME").unwrap_or(""),
                log_stream_name: env.get("AWS_LAMBDA_LOG_STREAM_NAME").unwrap_or(""),
                invoked_function_arn: invocation.invoked_function_arn,
                deadline_ms: invocation.deadline_ms,
                identity: invocation.cognito_identity,
                client_context: invocation.client_context
            }
            
            // Invoke handler
            match (self.handler)(event, context) {
                Ok(response) => {
                    let body = json.encode(response)
                    self.send_response(invocation.request_id, body)?
                }
                Err(error) => {
                    self.send_error(invocation.request_id, error)?
                }
            }
        }
    }
    
    on get_next_invocation() -> Result<Invocation, LambdaError> {
        @native("lambda_runtime_next_invocation", self.runtime_api)
    }
    
    on send_response(request_id: String, body: String) -> Result<(), LambdaError> {
        @native("lambda_runtime_send_response", self.runtime_api, request_id, body)
    }
    
    on send_error(request_id: String, error: LambdaError) -> Result<(), LambdaError> {
        @native("lambda_runtime_send_error", self.runtime_api, request_id, error)
    }
}

struct Invocation {
    request_id: String
    body: String
    deadline_ms: Int64
    invoked_function_arn: String
    trace_id: String?
    cognito_identity: CognitoIdentity?
    client_context: ClientContext?
}

/// Start the Lambda runtime with a handler function
fn start<Event: Deserialize, Response: Serialize>(handler: fn(Event, Context) -> Result<Response, LambdaError>) {
    let runtime = LambdaRuntime.new(handler)
    match runtime.run() {
        Ok(_) => {}
        Err(e) => {
            eprintln("Lambda runtime error: \(e.message())")
            exit(1)
        }
    }
}

// -----------------------------------------------------------------------------
// Common Event Types
// -----------------------------------------------------------------------------

/// API Gateway Proxy Event (REST API)
struct ApiGatewayEvent {
    resource: String
    path: String
    http_method: String
    headers: Map<String, String>
    query_string_parameters: Map<String, String>?
    path_parameters: Map<String, String>?
    stage_variables: Map<String, String>?
    body: String?
    is_base64_encoded: Bool
    request_context: ApiGatewayRequestContext
}

struct ApiGatewayRequestContext {
    account_id: String
    api_id: String
    stage: String
    request_id: String
    identity: RequestIdentity
    resource_path: String
    http_method: String
    domain_name: String
}

struct RequestIdentity {
    source_ip: String
    user_agent: String?
    cognito_identity_id: String?
    cognito_identity_pool_id: String?
}

/// API Gateway Proxy Response
struct ApiGatewayResponse {
    status_code: Int
    headers: Map<String, String>
    body: String
    is_base64_encoded: Bool
}

impl ApiGatewayResponse {
    fn ok(body: String) -> Self {
        ApiGatewayResponse {
            status_code: 200,
            headers: Map.from([("Content-Type", "application/json")]),
            body: body,
            is_base64_encoded: false
        }
    }
    
    fn json<T: Serialize>(data: T) -> Self {
        Self.ok(json.encode(data))
    }
    
    fn html(body: String) -> Self {
        ApiGatewayResponse {
            status_code: 200,
            headers: Map.from([("Content-Type", "text/html")]),
            body: body,
            is_base64_encoded: false
        }
    }
    
    fn redirect(location: String) -> Self {
        ApiGatewayResponse {
            status_code: 302,
            headers: Map.from([("Location", location)]),
            body: "",
            is_base64_encoded: false
        }
    }
    
    fn error(status_code: Int, message: String) -> Self {
        ApiGatewayResponse {
            status_code: status_code,
            headers: Map.from([("Content-Type", "application/json")]),
            body: json.encode({ "error": message }),
            is_base64_encoded: false
        }
    }
    
    fn not_found() -> Self { Self.error(404, "Not Found") }
    fn bad_request(msg: String) -> Self { Self.error(400, msg) }
    fn internal_error() -> Self { Self.error(500, "Internal Server Error") }
    
    fn with_header(key: String, value: String) -> Self {
        self.headers.set(key, value)
        self
    }
    
    fn with_cors() -> Self {
        self.headers.set("Access-Control-Allow-Origin", "*")
        self.headers.set("Access-Control-Allow-Headers", "Content-Type,Authorization")
        self.headers.set("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS")
        self
    }
}

/// API Gateway V2 (HTTP API) Event
struct ApiGatewayV2Event {
    version: String
    route_key: String
    raw_path: String
    raw_query_string: String
    headers: Map<String, String>
    query_string_parameters: Map<String, String>?
    path_parameters: Map<String, String>?
    body: String?
    is_base64_encoded: Bool
    request_context: ApiGatewayV2RequestContext
}

struct ApiGatewayV2RequestContext {
    account_id: String
    api_id: String
    domain_name: String
    http: HttpRequestContext
    request_id: String
    stage: String
    time: String
    time_epoch: Int64
}

struct HttpRequestContext { method: String, path: String, protocol: String, source_ip: String, user_agent: String }

/// S3 Event
struct S3Event {
    records: [S3EventRecord]
}

struct S3EventRecord {
    event_version: String
    event_source: String
    aws_region: String
    event_time: String
    event_name: String
    s3: S3EventData
}

struct S3EventData {
    bucket: S3BucketInfo
    object: S3ObjectInfo
}

struct S3BucketInfo { name: String, arn: String }
struct S3ObjectInfo { key: String, size: Int64, etag: String, version_id: String? }

/// SQS Event
struct SqsEvent {
    records: [SqsRecord]
}

struct SqsRecord {
    message_id: String
    receipt_handle: String
    body: String
    attributes: Map<String, String>
    message_attributes: Map<String, SqsMessageAttribute>
    md5_of_body: String
    event_source: String
    event_source_arn: String
    aws_region: String
}

struct SqsMessageAttribute { string_value: String?, data_type: String }

/// SNS Event
struct SnsEvent {
    records: [SnsRecord]
}

struct SnsRecord {
    event_version: String
    event_source: String
    sns: SnsMessage
}

struct SnsMessage {
    message_id: String
    topic_arn: String
    subject: String?
    message: String
    timestamp: String
    message_attributes: Map<String, SnsMessageAttribute>
}

struct SnsMessageAttribute { type_: String, value: String }

/// DynamoDB Stream Event
struct DynamoDBEvent {
    records: [DynamoDBRecord]
}

struct DynamoDBRecord {
    event_id: String
    event_name: String
    event_version: String
    event_source: String
    aws_region: String
    dynamodb: StreamRecord
}

struct StreamRecord {
    keys: Map<String, AttributeValue>
    new_image: Map<String, AttributeValue>?
    old_image: Map<String, AttributeValue>?
    sequence_number: String
    size_bytes: Int64
    stream_view_type: String
}

enum AttributeValue {
    S(String)
    N(String)
    B([Byte])
    SS([String])
    NS([String])
    BS([[Byte]])
    M(Map<String, AttributeValue>)
    L([AttributeValue])
    NULL(Bool)
    BOOL(Bool)
}

/// Scheduled Event (CloudWatch Events / EventBridge)
struct ScheduledEvent {
    version: String
    id: String
    detail_type: String
    source: String
    account: String
    time: String
    region: String
    resources: [String]
    detail: Map<String, Value>
}

/// Kinesis Event
struct KinesisEvent {
    records: [KinesisRecord]
}

struct KinesisRecord {
    kinesis: KinesisData
    event_source: String
    event_version: String
    event_id: String
    event_name: String
    invoke_identity_arn: String
    aws_region: String
    event_source_arn: String
}

struct KinesisData {
    partition_key: String
    data: String  // Base64 encoded
    kinesis_schema_version: String
    sequence_number: String
    approximate_arrival_timestamp: Float
}

// -----------------------------------------------------------------------------
// Lambda Client (for invoking other functions)
// -----------------------------------------------------------------------------

actor LambdaClient {
    state config: LambdaConfig
    
    init(config: LambdaConfig) { self.config = config }
    
    on invoke(function_name: String, payload: String, invocation_type: InvocationType = InvocationType.RequestResponse) -> Result<InvokeResult, LambdaError> {
        @native("lambda_invoke", self.config, function_name, payload, invocation_type)
    }
    
    on invoke_json<T: Serialize, R: Deserialize>(function_name: String, payload: T) -> Result<R, LambdaError> {
        let result = self.invoke(function_name, json.encode(payload), InvocationType.RequestResponse)?
        json.decode(result.payload).map_err(|e| LambdaError.SerializationError(e.to_string()))
    }
    
    on invoke_async(function_name: String, payload: String) -> Result<(), LambdaError> {
        self.invoke(function_name, payload, InvocationType.Event)?
        Ok(())
    }
    
    on list_functions() -> Result<[FunctionConfiguration], LambdaError> {
        @native("lambda_list_functions", self.config)
    }
    
    on get_function(function_name: String) -> Result<FunctionConfiguration, LambdaError> {
        @native("lambda_get_function", self.config, function_name)
    }
    
    on create_function(params: CreateFunctionParams) -> Result<FunctionConfiguration, LambdaError> {
        @native("lambda_create_function", self.config, params)
    }
    
    on update_function_code(function_name: String, code: FunctionCode) -> Result<FunctionConfiguration, LambdaError> {
        @native("lambda_update_function_code", self.config, function_name, code)
    }
    
    on delete_function(function_name: String) -> Result<(), LambdaError> {
        @native("lambda_delete_function", self.config, function_name)
    }
    
    on add_permission(function_name: String, statement_id: String, action: String, principal: String, source_arn: String?) -> Result<(), LambdaError> {
        @native("lambda_add_permission", self.config, function_name, statement_id, action, principal, source_arn)
    }
}

struct LambdaConfig {
    region: String
    access_key_id: String?
    secret_access_key: String?
    endpoint_url: String?
}

impl LambdaConfig {
    fn new(region: String) -> Self {
        LambdaConfig { region: region, access_key_id: None, secret_access_key: None, endpoint_url: None }
    }
    
    fn from_env() -> Result<Self, LambdaError> {
        @native("lambda_config_from_env")
    }
}

enum InvocationType { RequestResponse, Event, DryRun }

struct InvokeResult {
    status_code: Int
    payload: String
    function_error: String?
    log_result: String?
    executed_version: String
}

struct FunctionConfiguration {
    function_name: String
    function_arn: String
    runtime: String
    role: String
    handler: String
    code_size: Int64
    description: String?
    timeout: Int
    memory_size: Int
    last_modified: String
    version: String
    state: FunctionState
    environment: Map<String, String>
}

enum FunctionState { Pending, Active, Inactive, Failed }

struct CreateFunctionParams {
    function_name: String
    runtime: Runtime
    role: String
    handler: String
    code: FunctionCode
    description: String?
    timeout: Int
    memory_size: Int
    environment: Map<String, String>
    tags: Map<String, String>
}

struct FunctionCode {
    zip_file: [Byte]?
    s3_bucket: String?
    s3_key: String?
    s3_object_version: String?
    image_uri: String?
}

enum Runtime {
    Nodejs18x
    Nodejs20x
    Python39
    Python310
    Python311
    Python312
    Java11
    Java17
    Java21
    Dotnet6
    Dotnet8
    Go1x
    Ruby32
    ProvidedAl2
    ProvidedAl2023
    
    fn to_string() -> String {
        match self {
            .Nodejs18x => "nodejs18.x"
            .Nodejs20x => "nodejs20.x"
            .Python39 => "python3.9"
            .Python310 => "python3.10"
            .Python311 => "python3.11"
            .Python312 => "python3.12"
            .Java11 => "java11"
            .Java17 => "java17"
            .Java21 => "java21"
            .Dotnet6 => "dotnet6"
            .Dotnet8 => "dotnet8"
            .Go1x => "go1.x"
            .Ruby32 => "ruby3.2"
            .ProvidedAl2 => "provided.al2"
            .ProvidedAl2023 => "provided.al2023"
        }
    }
}

// -----------------------------------------------------------------------------
// Serverless Framework Helpers
// -----------------------------------------------------------------------------

/// Router for API Gateway events
actor Router {
    state routes: [Route]
    state not_found_handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse
    
    init() {
        self.routes = []
        self.not_found_handler = |_, _| ApiGatewayResponse.not_found()
    }
    
    on get(path: String, handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse) -> Self {
        self.routes.push(Route { method: "GET", path: path, handler: handler })
        self
    }
    
    on post(path: String, handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse) -> Self {
        self.routes.push(Route { method: "POST", path: path, handler: handler })
        self
    }
    
    on put(path: String, handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse) -> Self {
        self.routes.push(Route { method: "PUT", path: path, handler: handler })
        self
    }
    
    on delete(path: String, handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse) -> Self {
        self.routes.push(Route { method: "DELETE", path: path, handler: handler })
        self
    }
    
    on not_found(handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse) -> Self {
        self.not_found_handler = handler
        self
    }
    
    on handle(event: ApiGatewayEvent, context: Context) -> ApiGatewayResponse {
        // Handle CORS preflight
        if event.http_method == "OPTIONS" {
            return ApiGatewayResponse.ok("").with_cors()
        }
        
        for route in self.routes {
            if route.method == event.http_method && self.match_path(route.path, event.path) {
                return (route.handler)(event, context)
            }
        }
        
        (self.not_found_handler)(event, context)
    }
    
    on match_path(pattern: String, path: String) -> Bool {
        // Simple path matching with :param support
        let pattern_parts = pattern.split("/")
        let path_parts = path.split("/")
        
        if pattern_parts.len() != path_parts.len() { return false }
        
        for (p, a) in pattern_parts.zip(path_parts) {
            if p.starts_with(":") { continue }
            if p != a { return false }
        }
        
        true
    }
}

struct Route {
    method: String
    path: String
    handler: fn(ApiGatewayEvent, Context) -> ApiGatewayResponse
}

// -----------------------------------------------------------------------------
// Middleware
// -----------------------------------------------------------------------------

trait Middleware {
    fn before(event: ApiGatewayEvent, context: Context) -> Result<ApiGatewayEvent, ApiGatewayResponse>
    fn after(response: ApiGatewayResponse) -> ApiGatewayResponse
}

struct CorsMiddleware {}
impl Middleware for CorsMiddleware {
    fn before(event: ApiGatewayEvent, context: Context) -> Result<ApiGatewayEvent, ApiGatewayResponse> {
        Ok(event)
    }
    
    fn after(response: ApiGatewayResponse) -> ApiGatewayResponse {
        response.with_cors()
    }
}

struct LoggingMiddleware {}
impl Middleware for LoggingMiddleware {
    fn before(event: ApiGatewayEvent, context: Context) -> Result<ApiGatewayEvent, ApiGatewayResponse> {
        println("Request: \(event.http_method) \(event.path) - RequestId: \(context.request_id)")
        Ok(event)
    }
    
    fn after(response: ApiGatewayResponse) -> ApiGatewayResponse {
        println("Response: \(response.status_code)")
        response
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum LambdaError {
    RuntimeError(String)
    InvocationError(String)
    SerializationError(String)
    TimeoutError
    ResourceNotFound(String)
    ServiceError(String, Int)
    PermissionDenied(String)
    
    fn message() -> String {
        match self {
            .RuntimeError(m) => "Runtime error: \(m)"
            .InvocationError(m) => "Invocation error: \(m)"
            .SerializationError(m) => "Serialization error: \(m)"
            .TimeoutError => "Function timed out"
            .ResourceNotFound(m) => "Resource not found: \(m)"
            .ServiceError(m, c) => "Service error (\(c)): \(m)"
            .PermissionDenied(m) => "Permission denied: \(m)"
        }
    }
    
    fn to_lambda_response() -> Map<String, String> {
        Map.from([
            ("errorType", self.error_type()),
            ("errorMessage", self.message())
        ])
    }
    
    fn error_type() -> String {
        match self {
            .RuntimeError(_) => "RuntimeError"
            .InvocationError(_) => "InvocationError"
            .SerializationError(_) => "SerializationError"
            .TimeoutError => "TimeoutError"
            .ResourceNotFound(_) => "ResourceNotFoundError"
            .ServiceError(_, _) => "ServiceError"
            .PermissionDenied(_) => "PermissionDeniedError"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "api gateway response" {
    let response = ApiGatewayResponse.json({ "message": "Hello" })
    assert(response.status_code == 200)
    assert(response.headers.get("Content-Type") == Some("application/json"))
}

test "api gateway response with cors" {
    let response = ApiGatewayResponse.ok("test").with_cors()
    assert(response.headers.get("Access-Control-Allow-Origin") == Some("*"))
}

test "context remaining time" {
    let context = Context {
        request_id: "123",
        function_name: "test",
        function_version: "$LATEST",
        memory_limit_mb: 128,
        log_group_name: "",
        log_stream_name: "",
        invoked_function_arn: "",
        deadline_ms: Instant.now().millis() + 5000,
        identity: None,
        client_context: None
    }
    assert(context.remaining_time_ms() > 0)
    assert(context.remaining_time_ms() <= 5000)
}

test "router matching" {
    let router = Router.new()
        .get("/users", |_, _| ApiGatewayResponse.ok("users"))
        .get("/users/:id", |_, _| ApiGatewayResponse.ok("user"))
    
    assert(router.match_path("/users", "/users"))
    assert(router.match_path("/users/:id", "/users/123"))
    assert(!router.match_path("/users", "/posts"))
}

test "runtime enum" {
    assert(Runtime.Python312.to_string() == "python3.12")
    assert(Runtime.Nodejs20x.to_string() == "nodejs20.x")
}
