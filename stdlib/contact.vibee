// =============================================================================
// Vibee OS â€” Contact Module
// CRM contact management with full lifecycle support
// =============================================================================

use datetime::{DateTime}
use uuid::{UUID}

// =============================================================================
// Contact Types & Enums
// =============================================================================

enum ContactType { Person, Company, Partner, Vendor }
enum ContactStatus { Active, Inactive, Archived, Blocked }
enum ContactSource { Manual, Import, WebForm, API, Referral, SocialMedia, Event }
enum AddressType { Home, Work, Billing, Shipping, Other }
enum PhoneType { Mobile, Work, Home, Fax, Other }
enum EmailType { Personal, Work, Other }

// =============================================================================
// Contact Address
// =============================================================================

struct ContactAddress {
    address_type: AddressType
    street: String
    city: String
    state: Option<String>
    postal_code: String
    country: String
    is_primary: Bool
}

impl ContactAddress {
    fn new(street: String, city: String, postal_code: String, country: String) -> Self {
        ContactAddress { address_type: AddressType.Work, street: street, city: city, state: None, postal_code: postal_code, country: country, is_primary: false }
    }
    fn with_type(t: AddressType) -> Self { self.address_type = t; self }
    fn with_state(s: String) -> Self { self.state = Some(s); self }
    fn primary() -> Self { self.is_primary = true; self }
    fn full_address() -> String { "\(self.street), \(self.city) \(self.postal_code), \(self.country)" }
}

// =============================================================================
// Contact Phone & Email
// =============================================================================

struct ContactPhone { phone_type: PhoneType, number: String, is_primary: Bool }
struct ContactEmail { email_type: EmailType, address: String, is_primary: Bool, is_verified: Bool }

impl ContactPhone {
    fn mobile(n: String) -> Self { ContactPhone { phone_type: PhoneType.Mobile, number: n, is_primary: true } }
    fn work(n: String) -> Self { ContactPhone { phone_type: PhoneType.Work, number: n, is_primary: false } }
    fn primary() -> Self { self.is_primary = true; self }
}

impl ContactEmail {
    fn work(addr: String) -> Self { ContactEmail { email_type: EmailType.Work, address: addr, is_primary: true, is_verified: false } }
    fn personal(addr: String) -> Self { ContactEmail { email_type: EmailType.Personal, address: addr, is_primary: false, is_verified: false } }
    fn primary() -> Self { self.is_primary = true; self }
    fn verified() -> Self { self.is_verified = true; self }
}

// =============================================================================
// Contact
// =============================================================================

struct Contact {
    id: String
    contact_type: ContactType
    status: ContactStatus
    source: ContactSource
    first_name: String
    last_name: String
    title: Option<String>
    company: Option<String>
    job_title: Option<String>
    emails: [ContactEmail]
    phones: [ContactPhone]
    addresses: [ContactAddress]
    website: Option<String>
    linkedin: Option<String>
    owner_id: Option<String>
    tags: [String]
    custom_fields: Map<String, String>
    notes: Option<String>
    related_contacts: [String]
    created_at: DateTime
    updated_at: DateTime
    last_contacted_at: Option<DateTime>
    score: Int
    lifetime_value: Float
}

impl Contact {
    fn new(first_name: String, last_name: String) -> Self {
        let now = DateTime.now()
        Contact {
            id: UUID.v4().to_string(), contact_type: ContactType.Person, status: ContactStatus.Active,
            source: ContactSource.Manual, first_name: first_name, last_name: last_name, title: None,
            company: None, job_title: None, emails: [], phones: [], addresses: [], website: None,
            linkedin: None, owner_id: None, tags: [], custom_fields: Map.empty(), notes: None,
            related_contacts: [], created_at: now, updated_at: now, last_contacted_at: None, score: 0, lifetime_value: 0.0
        }
    }
    
    fn company_contact(name: String) -> Self {
        let c = Contact.new(name, "")
        c.contact_type = ContactType.Company
        c.company = Some(name)
        c
    }
    
    fn with_company(c: String) -> Self { self.company = Some(c); self }
    fn with_job_title(j: String) -> Self { self.job_title = Some(j); self }
    fn with_owner(id: String) -> Self { self.owner_id = Some(id); self }
    fn add_email(e: ContactEmail) -> Self { self.emails.push(e); self }
    fn add_phone(p: ContactPhone) -> Self { self.phones.push(p); self }
    fn add_address(a: ContactAddress) -> Self { self.addresses.push(a); self }
    fn add_tag(t: String) -> Self { if !self.tags.contains(t) { self.tags.push(t) }; self }
    fn remove_tag(t: String) -> Self { self.tags.retain(|x| x != t); self }
    
    fn activate() -> Self { self.status = ContactStatus.Active; self }
    fn deactivate() -> Self { self.status = ContactStatus.Inactive; self }
    fn archive() -> Self { self.status = ContactStatus.Archived; self }
    fn add_score(pts: Int) -> Self { self.score += pts; self }
    fn mark_contacted() -> Self { self.last_contacted_at = Some(DateTime.now()); self }
    
    fn full_name() -> String { "\(self.first_name) \(self.last_name)".trim() }
    fn display_name() -> String { if self.contact_type == ContactType.Company { self.company.unwrap_or(self.first_name) } else { self.full_name() } }
    fn primary_email() -> Option<String> { self.emails.iter().find(|e| e.is_primary).map(|e| e.address.clone()).or(self.emails.first().map(|e| e.address.clone())) }
    fn primary_phone() -> Option<String> { self.phones.iter().find(|p| p.is_primary).map(|p| p.number.clone()).or(self.phones.first().map(|p| p.number.clone())) }
    fn is_active() -> Bool { self.status == ContactStatus.Active }
    fn has_tag(t: String) -> Bool { self.tags.contains(t) }
}

// =============================================================================
// Contact Query
// =============================================================================

enum ContactSortField { Name, CreatedAt, Score }
enum SortOrder { Asc, Desc }

struct ContactQuery {
    search: Option<String>
    contact_type: Option<ContactType>
    status: Option<ContactStatus>
    owner_id: Option<String>
    tags: [String]
    min_score: Option<Int>
    sort_by: ContactSortField
    sort_order: SortOrder
    limit: Int
    offset: Int
}

impl ContactQuery {
    fn new() -> Self { ContactQuery { search: None, contact_type: None, status: None, owner_id: None, tags: [], min_score: None, sort_by: ContactSortField.CreatedAt, sort_order: SortOrder.Desc, limit: 50, offset: 0 } }
    fn with_search(s: String) -> Self { self.search = Some(s); self }
    fn with_status(s: ContactStatus) -> Self { self.status = Some(s); self }
    fn with_owner(id: String) -> Self { self.owner_id = Some(id); self }
    fn with_tag(t: String) -> Self { self.tags.push(t); self }
    fn active_only() -> Self { self.status = Some(ContactStatus.Active); self }
    fn limit(n: Int) -> Self { self.limit = n; self }
    fn page(p: Int, per: Int) -> Self { self.limit = per; self.offset = (p - 1) * per; self }
}

// =============================================================================
// Contact Service
// =============================================================================

actor ContactService {
    state contacts: Map<String, Contact>
    state by_email: Map<String, String>
    
    fn new() -> Self { ContactService { contacts: Map.empty(), by_email: Map.empty() } }
    
    fn create(contact: Contact) -> Result<Contact, ContactError> {
        if let Some(email) = contact.primary_email() {
            if self.by_email.contains_key(email) { return Err(ContactError.DuplicateEmail(email)) }
            self.by_email.insert(email, contact.id.clone())
        }
        self.contacts.insert(contact.id.clone(), contact.clone())
        Ok(contact)
    }
    
    fn get(id: String) -> Option<Contact> { self.contacts.get(id) }
    fn get_by_email(email: String) -> Option<Contact> { self.by_email.get(email).and_then(|id| self.contacts.get(id)) }
    
    fn update(contact: Contact) -> Result<Contact, ContactError> {
        if !self.contacts.contains_key(contact.id) { return Err(ContactError.NotFound) }
        self.contacts.insert(contact.id.clone(), contact.clone())
        Ok(contact)
    }
    
    fn delete(id: String) -> Result<(), ContactError> {
        self.contacts.remove(id).ok_or(ContactError.NotFound)?
        Ok(())
    }
    
    fn search(query: ContactQuery) -> [Contact] {
        self.contacts.values().filter(|c| {
            if let Some(s) = query.status { if c.status != s { return false } }
            if let Some(o) = query.owner_id.clone() { if c.owner_id != Some(o) { return false } }
            if !query.tags.is_empty() { if !query.tags.iter().all(|t| c.has_tag(t.clone())) { return false } }
            true
        }).take(query.limit).collect()
    }
    
    fn count() -> Int { self.contacts.len() }
}

// =============================================================================
// Errors
// =============================================================================

enum ContactError { NotFound, DuplicateEmail(String), ValidationError(String) }

impl Display for ContactError {
    fn fmt(f: Formatter) { match self { NotFound => f.write("Contact not found"), DuplicateEmail(e) => f.write("Duplicate: \(e)"), ValidationError(e) => f.write("Error: \(e)") } }
}

// =============================================================================
// Tests
// =============================================================================

test "contact creation" {
    let c = Contact.new("John", "Doe").with_company("Acme").add_email(ContactEmail.work("john@acme.com")).add_tag("vip")
    assert_eq(c.full_name(), "John Doe")?
    assert(c.has_tag("vip"))?
}

test "contact service" {
    let svc = ContactService.new()
    let c = svc.create(Contact.new("Jane", "Smith").add_email(ContactEmail.work("jane@test.com"))).unwrap()
    assert(svc.get(c.id).is_some())?
}
