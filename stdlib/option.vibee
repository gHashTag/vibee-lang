// =============================================================================
// Vibee OS â€” Option Module
// Extended Option type utilities
// =============================================================================

/// Option extensions
impl<T> Option<T> {
    // Transformations
    fn map<U>(f: fn(T) -> U) -> Option<U> { match self { Some(x) => Some(f(x)), None => None } }
    fn map_or<U>(default: U, f: fn(T) -> U) -> U { match self { Some(x) => f(x), None => default } }
    fn map_or_else<U>(default: fn() -> U, f: fn(T) -> U) -> U { match self { Some(x) => f(x), None => default() } }
    fn and_then<U>(f: fn(T) -> Option<U>) -> Option<U> { match self { Some(x) => f(x), None => None } }
    fn or_else(f: fn() -> Option<T>) -> Option<T> { match self { Some(x) => Some(x), None => f() } }
    fn filter(pred: fn(T) -> Bool) -> Option<T> { match self { Some(x) if pred(x) => Some(x), _ => None } }
    fn flatten() -> T where T: Option<U> { match self { Some(inner) => inner, None => None } }
    
    // Unwrapping
    fn unwrap() -> T { match self { Some(x) => x, None => panic("unwrap on None") } }
    fn unwrap_or(default: T) -> T { match self { Some(x) => x, None => default } }
    fn unwrap_or_else(f: fn() -> T) -> T { match self { Some(x) => x, None => f() } }
    fn unwrap_or_default() -> T where T: Default { match self { Some(x) => x, None => T.default() } }
    fn expect(msg: String) -> T { match self { Some(x) => x, None => panic(msg) } }
    
    // Inspection
    fn is_some() -> Bool { match self { Some(_) => true, None => false } }
    fn is_none() -> Bool { match self { Some(_) => false, None => true } }
    fn is_some_and(pred: fn(T) -> Bool) -> Bool { match self { Some(x) => pred(x), None => false } }
    fn inspect(f: fn(T)) -> Option<T> { if let Some(x) = self { f(x) } self }
    
    // Conversion
    fn ok_or<E>(err: E) -> Result<T, E> { match self { Some(x) => Ok(x), None => Err(err) } }
    fn ok_or_else<E>(f: fn() -> E) -> Result<T, E> { match self { Some(x) => Ok(x), None => Err(f()) } }
    fn as_ref() -> Option<T> { self }
    fn take() -> Option<T> { let v = self; self = None; v }
    fn replace(value: T) -> Option<T> { let old = self; self = Some(value); old }
    fn get_or_insert(value: T) -> T { if self.is_none() { self = Some(value) } self.unwrap() }
    fn get_or_insert_with(f: fn() -> T) -> T { if self.is_none() { self = Some(f()) } self.unwrap() }
    
    // Combining
    fn and<U>(other: Option<U>) -> Option<U> { match self { Some(_) => other, None => None } }
    fn or(other: Option<T>) -> Option<T> { match self { Some(x) => Some(x), None => other } }
    fn xor(other: Option<T>) -> Option<T> {
        match (self, other) { (Some(x), None) => Some(x), (None, Some(y)) => Some(y), _ => None }
    }
    fn zip<U>(other: Option<U>) -> Option<(T, U)> {
        match (self, other) { (Some(a), Some(b)) => Some((a, b)), _ => None }
    }
    fn zip_with<U, R>(other: Option<U>, f: fn(T, U) -> R) -> Option<R> {
        match (self, other) { (Some(a), Some(b)) => Some(f(a, b)), _ => None }
    }
    fn unzip() -> (Option<A>, Option<B>) where T = (A, B) {
        match self { Some((a, b)) => (Some(a), Some(b)), None => (None, None) }
    }
    
    // Iterator
    fn iter() -> OptionIterator<T> { OptionIterator { opt: self } }
    fn into_iter() -> OptionIterator<T> { OptionIterator { opt: self } }
}

struct OptionIterator<T> { opt: Option<T> }
impl<T> Iterator for OptionIterator<T> {
    type Item = T
    fn next() -> Option<T> { self.opt.take() }
}

// Utility functions
fn some<T>(value: T) -> Option<T> { Some(value) }
fn none<T>() -> Option<T> { None }

/// Transpose Option<Result> to Result<Option>
fn transpose<T, E>(opt: Option<Result<T, E>>) -> Result<Option<T>, E> {
    match opt { Some(Ok(x)) => Ok(Some(x)), Some(Err(e)) => Err(e), None => Ok(None) }
}

/// Collect Options into Option of collection
fn collect_options<T>(opts: [Option<T>]) -> Option<[T]> {
    var result = []
    for opt in opts { result.push(opt?) }
    Some(result)
}

/// First Some value
fn first_some<T>(opts: [Option<T>]) -> Option<T> {
    for opt in opts { if opt.is_some() { return opt } }
    None
}

// Tests
test "map" { assert_eq(Some(2).map(|x| x * 2), Some(4))? }
test "and_then" { assert_eq(Some(2).and_then(|x| Some(x + 1)), Some(3))? }
test "unwrap_or" { assert_eq(None::<Int>.unwrap_or(5), 5)? }
test "filter" { assert_eq(Some(4).filter(|x| x > 3), Some(4))?; assert_eq(Some(2).filter(|x| x > 3), None)? }
test "zip" { assert_eq(Some(1).zip(Some(2)), Some((1, 2)))? }
test "flatten" { assert_eq(Some(Some(1)).flatten(), Some(1))? }
test "transpose" { assert_eq(transpose(Some(Ok(1))), Ok(Some(1)))? }
