// =============================================================================
// Vibee OS â€” Canvas Module
// 2D drawing and graphics
// =============================================================================

use color::{RGB, RGBA}
use image::{Image, Pixel}

/// 2D Point
struct Point {
    x: Float64
    y: Float64
    
    fn new(x: Float64, y: Float64) -> Self { Point { x: x, y: y } }
    fn zero() -> Self { Point { x: 0.0, y: 0.0 } }
    fn distance(other: Point) -> Float64 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }
    fn lerp(other: Point, t: Float64) -> Self {
        Point { x: self.x + (other.x - self.x) * t, y: self.y + (other.y - self.y) * t }
    }
}

/// Rectangle
struct Rect {
    x: Float64
    y: Float64
    width: Float64
    height: Float64
    
    fn new(x: Float64, y: Float64, w: Float64, h: Float64) -> Self {
        Rect { x: x, y: y, width: w, height: h }
    }
    fn contains(p: Point) -> Bool {
        p.x >= self.x && p.x <= self.x + self.width &&
        p.y >= self.y && p.y <= self.y + self.height
    }
    fn center() -> Point { Point.new(self.x + self.width / 2.0, self.y + self.height / 2.0) }
}

/// Drawing style
struct Style {
    fill: Option<RGBA>
    stroke: Option<RGBA>
    line_width: Float64
    line_cap: LineCap
    line_join: LineJoin
    
    fn new() -> Self {
        Style {
            fill: Some(RGBA.new(0, 0, 0, 1.0)),
            stroke: None,
            line_width: 1.0,
            line_cap: LineCap.Butt,
            line_join: LineJoin.Miter
        }
    }
    
    fn fill_color(color: RGBA) -> Self { self.fill = Some(color); self }
    fn stroke_color(color: RGBA) -> Self { self.stroke = Some(color); self }
    fn no_fill() -> Self { self.fill = None; self }
    fn no_stroke() -> Self { self.stroke = None; self }
    fn line_width(w: Float64) -> Self { self.line_width = w; self }
}

enum LineCap { Butt, Round, Square }
enum LineJoin { Miter, Round, Bevel }

/// 2D Transform matrix
struct Transform {
    a: Float64  b: Float64
    c: Float64  d: Float64
    e: Float64  f: Float64
    
    fn identity() -> Self { Transform { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: 0.0, f: 0.0 } }
    
    fn translate(tx: Float64, ty: Float64) -> Self {
        Transform { a: 1.0, b: 0.0, c: 0.0, d: 1.0, e: tx, f: ty }
    }
    
    fn scale(sx: Float64, sy: Float64) -> Self {
        Transform { a: sx, b: 0.0, c: 0.0, d: sy, e: 0.0, f: 0.0 }
    }
    
    fn rotate(angle: Float64) -> Self {
        let cos = angle.cos()
        let sin = angle.sin()
        Transform { a: cos, b: sin, c: -sin, d: cos, e: 0.0, f: 0.0 }
    }
    
    fn multiply(other: Transform) -> Self {
        Transform {
            a: self.a * other.a + self.c * other.b,
            b: self.b * other.a + self.d * other.b,
            c: self.a * other.c + self.c * other.d,
            d: self.b * other.c + self.d * other.d,
            e: self.a * other.e + self.c * other.f + self.e,
            f: self.b * other.e + self.d * other.f + self.f
        }
    }
    
    fn apply(p: Point) -> Point {
        Point {
            x: self.a * p.x + self.c * p.y + self.e,
            y: self.b * p.x + self.d * p.y + self.f
        }
    }
}

/// Path for complex shapes
struct Path {
    commands: [PathCommand]
    
    fn new() -> Self { Path { commands: [] } }
    fn move_to(x: Float64, y: Float64) -> Self { self.commands.push(PathCommand.MoveTo(x, y)); self }
    fn line_to(x: Float64, y: Float64) -> Self { self.commands.push(PathCommand.LineTo(x, y)); self }
    fn quad_to(cx: Float64, cy: Float64, x: Float64, y: Float64) -> Self {
        self.commands.push(PathCommand.QuadTo(cx, cy, x, y)); self
    }
    fn cubic_to(c1x: Float64, c1y: Float64, c2x: Float64, c2y: Float64, x: Float64, y: Float64) -> Self {
        self.commands.push(PathCommand.CubicTo(c1x, c1y, c2x, c2y, x, y)); self
    }
    fn arc_to(rx: Float64, ry: Float64, angle: Float64, large: Bool, sweep: Bool, x: Float64, y: Float64) -> Self {
        self.commands.push(PathCommand.ArcTo(rx, ry, angle, large, sweep, x, y)); self
    }
    fn close() -> Self { self.commands.push(PathCommand.Close); self }
    
    fn rect(x: Float64, y: Float64, w: Float64, h: Float64) -> Self {
        self.move_to(x, y).line_to(x + w, y).line_to(x + w, y + h).line_to(x, y + h).close()
    }
    
    fn circle(cx: Float64, cy: Float64, r: Float64) -> Self {
        self.move_to(cx + r, cy)
            .arc_to(r, r, 0.0, false, true, cx - r, cy)
            .arc_to(r, r, 0.0, false, true, cx + r, cy)
            .close()
    }
    
    fn rounded_rect(x: Float64, y: Float64, w: Float64, h: Float64, r: Float64) -> Self {
        self.move_to(x + r, y)
            .line_to(x + w - r, y).arc_to(r, r, 0.0, false, true, x + w, y + r)
            .line_to(x + w, y + h - r).arc_to(r, r, 0.0, false, true, x + w - r, y + h)
            .line_to(x + r, y + h).arc_to(r, r, 0.0, false, true, x, y + h - r)
            .line_to(x, y + r).arc_to(r, r, 0.0, false, true, x + r, y)
            .close()
    }
}

enum PathCommand {
    MoveTo(Float64, Float64),
    LineTo(Float64, Float64),
    QuadTo(Float64, Float64, Float64, Float64),
    CubicTo(Float64, Float64, Float64, Float64, Float64, Float64),
    ArcTo(Float64, Float64, Float64, Bool, Bool, Float64, Float64),
    Close
}

/// Gradient
enum Gradient {
    Linear { x1: Float64, y1: Float64, x2: Float64, y2: Float64, stops: [ColorStop] },
    Radial { cx: Float64, cy: Float64, r: Float64, stops: [ColorStop] }
}

struct ColorStop { offset: Float64, color: RGBA }

impl Gradient {
    fn linear(x1: Float64, y1: Float64, x2: Float64, y2: Float64) -> Self {
        Gradient.Linear { x1: x1, y1: y1, x2: x2, y2: y2, stops: [] }
    }
    fn radial(cx: Float64, cy: Float64, r: Float64) -> Self {
        Gradient.Radial { cx: cx, cy: cy, r: r, stops: [] }
    }
    fn add_stop(offset: Float64, color: RGBA) -> Self {
        match self {
            Linear { stops, .. } => stops.push(ColorStop { offset: offset, color: color }),
            Radial { stops, .. } => stops.push(ColorStop { offset: offset, color: color })
        }
        self
    }
}

/// Canvas for 2D drawing
struct Canvas {
    width: Int
    height: Int
    pixels: [Pixel]
    style: Style
    transform: Transform
    state_stack: [CanvasState]
    
    fn new(width: Int, height: Int) -> Self {
        let pixels = [Pixel.new(255, 255, 255, 255); width * height]
        Canvas {
            width: width, height: height, pixels: pixels,
            style: Style.new(), transform: Transform.identity(), state_stack: []
        }
    }
    
    fn clear(color: RGBA) {
        let pixel = Pixel.from_rgba(color)
        for i in 0..self.pixels.len() { self.pixels[i] = pixel }
    }
    
    fn save() { self.state_stack.push(CanvasState { style: self.style.clone(), transform: self.transform }) }
    fn restore() { if let Some(state) = self.state_stack.pop() { self.style = state.style; self.transform = state.transform } }
    
    fn translate(x: Float64, y: Float64) { self.transform = self.transform.multiply(Transform.translate(x, y)) }
    fn scale(sx: Float64, sy: Float64) { self.transform = self.transform.multiply(Transform.scale(sx, sy)) }
    fn rotate(angle: Float64) { self.transform = self.transform.multiply(Transform.rotate(angle)) }
    fn reset_transform() { self.transform = Transform.identity() }
    
    fn set_fill(color: RGBA) { self.style.fill = Some(color) }
    fn set_stroke(color: RGBA) { self.style.stroke = Some(color) }
    fn set_line_width(w: Float64) { self.style.line_width = w }
    
    fn to_image() -> Image {
        Image { width: self.width, height: self.height, pixels: self.pixels.clone(), color_mode: ColorMode.RGBA }
    }
}

struct CanvasState { style: Style, transform: Transform }

/// Drawing primitives
impl Canvas {
    fn fill_rect(x: Float64, y: Float64, w: Float64, h: Float64) {
        if let Some(color) = self.style.fill {
            let pixel = Pixel.from_rgba(color)
            for py in (y as Int)..((y + h) as Int).min(self.height) {
                for px in (x as Int)..((x + w) as Int).min(self.width) {
                    if px >= 0 && py >= 0 { self.blend_pixel(px, py, pixel) }
                }
            }
        }
    }
    
    fn stroke_rect(x: Float64, y: Float64, w: Float64, h: Float64) {
        if self.style.stroke.is_some() {
            self.stroke_line(x, y, x + w, y)
            self.stroke_line(x + w, y, x + w, y + h)
            self.stroke_line(x + w, y + h, x, y + h)
            self.stroke_line(x, y + h, x, y)
        }
    }
    
    fn fill_circle(cx: Float64, cy: Float64, r: Float64) {
        if let Some(color) = self.style.fill {
            let pixel = Pixel.from_rgba(color)
            let ri = r as Int + 1
            for dy in -ri..=ri {
                for dx in -ri..=ri {
                    if dx * dx + dy * dy <= (r * r) as Int {
                        let px = cx as Int + dx
                        let py = cy as Int + dy
                        if px >= 0 && px < self.width && py >= 0 && py < self.height {
                            self.blend_pixel(px, py, pixel)
                        }
                    }
                }
            }
        }
    }
    
    fn stroke_circle(cx: Float64, cy: Float64, r: Float64) {
        if let Some(color) = self.style.stroke {
            let pixel = Pixel.from_rgba(color)
            var x = r as Int
            var y = 0
            var err = 0
            while x >= y {
                self.set_pixel_safe(cx as Int + x, cy as Int + y, pixel)
                self.set_pixel_safe(cx as Int + y, cy as Int + x, pixel)
                self.set_pixel_safe(cx as Int - y, cy as Int + x, pixel)
                self.set_pixel_safe(cx as Int - x, cy as Int + y, pixel)
                self.set_pixel_safe(cx as Int - x, cy as Int - y, pixel)
                self.set_pixel_safe(cx as Int - y, cy as Int - x, pixel)
                self.set_pixel_safe(cx as Int + y, cy as Int - x, pixel)
                self.set_pixel_safe(cx as Int + x, cy as Int - y, pixel)
                y += 1
                err += 1 + 2 * y
                if 2 * (err - x) + 1 > 0 { x -= 1; err += 1 - 2 * x }
            }
        }
    }
    
    fn stroke_line(x1: Float64, y1: Float64, x2: Float64, y2: Float64) {
        if let Some(color) = self.style.stroke {
            let pixel = Pixel.from_rgba(color)
            let dx = (x2 - x1).abs() as Int
            let dy = (y2 - y1).abs() as Int
            let sx = if x1 < x2 { 1 } else { -1 }
            let sy = if y1 < y2 { 1 } else { -1 }
            var err = dx - dy
            var x = x1 as Int
            var y = y1 as Int
            loop {
                self.set_pixel_safe(x, y, pixel)
                if x == x2 as Int && y == y2 as Int { break }
                let e2 = 2 * err
                if e2 > -dy { err -= dy; x += sx }
                if e2 < dx { err += dx; y += sy }
            }
        }
    }
    
    fn fill_path(path: Path) { @native("canvas_fill_path", self, path) }
    fn stroke_path(path: Path) { @native("canvas_stroke_path", self, path) }
    
    fn draw_image(img: Image, x: Float64, y: Float64) {
        for iy in 0..img.height {
            for ix in 0..img.width {
                let px = x as Int + ix
                let py = y as Int + iy
                if let Some(pixel) = img.get_pixel(ix, iy) {
                    self.blend_pixel(px, py, pixel)
                }
            }
        }
    }
    
    fn draw_image_scaled(img: Image, x: Float64, y: Float64, w: Float64, h: Float64) {
        let scaled = img.resize(w as Int, h as Int)
        self.draw_image(scaled, x, y)
    }
    
    fn set_pixel_safe(x: Int, y: Int, pixel: Pixel) {
        if x >= 0 && x < self.width && y >= 0 && y < self.height {
            self.pixels[y * self.width + x] = pixel
        }
    }
    
    fn blend_pixel(x: Int, y: Int, pixel: Pixel) {
        if x >= 0 && x < self.width && y >= 0 && y < self.height {
            let idx = y * self.width + x
            let dst = self.pixels[idx]
            let alpha = pixel.a as Float64 / 255.0
            self.pixels[idx] = dst.blend(pixel, alpha)
        }
    }
}

/// Text drawing
impl Canvas {
    fn fill_text(text: String, x: Float64, y: Float64) {
        @native("canvas_fill_text", self, text, x, y, self.style)
    }
    
    fn stroke_text(text: String, x: Float64, y: Float64) {
        @native("canvas_stroke_text", self, text, x, y, self.style)
    }
    
    fn measure_text(text: String) -> TextMetrics {
        @native("canvas_measure_text", text, self.style)
    }
    
    fn set_font(font: String, size: Float64) {
        @native("canvas_set_font", self, font, size)
    }
}

struct TextMetrics { width: Float64, height: Float64, ascent: Float64, descent: Float64 }

// Tests
test "create canvas" {
    let canvas = Canvas.new(100, 100)
    assert_eq(canvas.width, 100)?
    assert_eq(canvas.height, 100)?
}

test "fill rect" {
    var canvas = Canvas.new(100, 100)
    canvas.set_fill(RGBA.new(255, 0, 0, 1.0))
    canvas.fill_rect(10.0, 10.0, 20.0, 20.0)
    let img = canvas.to_image()
    let p = img.get_pixel(15, 15)?
    assert_eq(p.r, 255)?
}

test "transform" {
    let t = Transform.identity()
    let p = Point.new(10.0, 0.0)
    let rotated = Transform.rotate(3.14159 / 2.0).apply(p)
    assert(rotated.x.abs() < 0.01)?
    assert((rotated.y - 10.0).abs() < 0.01)?
}
