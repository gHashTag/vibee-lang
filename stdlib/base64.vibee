// =============================================================================
// Vibee OS â€” Base64 Module
// Base64 encoding and decoding
// =============================================================================

const STANDARD_ALPHABET: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
const URL_SAFE_ALPHABET: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
const PADDING: Char = '='

/// Base64 encoding configuration
struct Base64Config {
    alphabet: String
    padding: Bool
    line_length: Option<Int>
    
    fn standard() -> Self {
        Base64Config { alphabet: STANDARD_ALPHABET, padding: true, line_length: None }
    }
    
    fn url_safe() -> Self {
        Base64Config { alphabet: URL_SAFE_ALPHABET, padding: false, line_length: None }
    }
    
    fn standard_no_pad() -> Self {
        Base64Config { alphabet: STANDARD_ALPHABET, padding: false, line_length: None }
    }
    
    fn mime() -> Self {
        Base64Config { alphabet: STANDARD_ALPHABET, padding: true, line_length: Some(76) }
    }
}

// -----------------------------------------------------------------------------
// Encoding
// -----------------------------------------------------------------------------

/// Encode bytes to base64 string
fn encode(data: [UInt8]) -> String {
    encode_with(data, Base64Config.standard())
}

/// Encode bytes with configuration
fn encode_with(data: [UInt8], config: Base64Config) -> String {
    if data.is_empty() { return "" }
    
    let alphabet = config.alphabet.chars().collect::<Vec<_>>()
    var result = ""
    var i = 0
    
    while i < data.len() {
        let b0 = data[i]
        let b1 = if i + 1 < data.len() { data[i + 1] } else { 0 }
        let b2 = if i + 2 < data.len() { data[i + 2] } else { 0 }
        
        let c0 = (b0 >> 2) as Int
        let c1 = (((b0 & 0x03) << 4) | (b1 >> 4)) as Int
        let c2 = (((b1 & 0x0f) << 2) | (b2 >> 6)) as Int
        let c3 = (b2 & 0x3f) as Int
        
        result.push(alphabet[c0])
        result.push(alphabet[c1])
        
        if i + 1 < data.len() {
            result.push(alphabet[c2])
        } else if config.padding {
            result.push(PADDING)
        }
        
        if i + 2 < data.len() {
            result.push(alphabet[c3])
        } else if config.padding {
            result.push(PADDING)
        }
        
        i += 3
    }
    
    // Add line breaks for MIME
    if let Some(line_len) = config.line_length {
        result = add_line_breaks(result, line_len)
    }
    
    result
}

/// Encode string to base64
fn encode_string(s: String) -> String {
    encode(s.as_bytes())
}

/// Encode to URL-safe base64
fn encode_url_safe(data: [UInt8]) -> String {
    encode_with(data, Base64Config.url_safe())
}

fn add_line_breaks(s: String, line_len: Int) -> String {
    var result = ""
    var i = 0
    
    while i < s.len() {
        let end = (i + line_len).min(s.len())
        result.push_str(s[i..end])
        if end < s.len() {
            result.push_str("\r\n")
        }
        i = end
    }
    
    result
}

// -----------------------------------------------------------------------------
// Decoding
// -----------------------------------------------------------------------------

/// Decode base64 string to bytes
fn decode(s: String) -> Result<[UInt8], Base64Error> {
    decode_with(s, Base64Config.standard())
}

/// Decode with configuration
fn decode_with(s: String, config: Base64Config) -> Result<[UInt8], Base64Error> {
    // Remove whitespace
    let s = s.chars().filter(|c| !c.is_whitespace()).collect::<String>()
    
    if s.is_empty() { return Ok([]) }
    
    // Build reverse lookup
    let alphabet = config.alphabet
    var lookup = [-1i8; 256]
    for (i, c) in alphabet.chars().enumerate() {
        lookup[c as Int] = i as Int8
    }
    
    var result = []
    var i = 0
    
    while i < s.len() {
        let c0 = s.chars().nth(i).ok_or(Base64Error.InvalidLength)?
        let c1 = s.chars().nth(i + 1).ok_or(Base64Error.InvalidLength)?
        let c2 = s.chars().nth(i + 2).unwrap_or(PADDING)
        let c3 = s.chars().nth(i + 3).unwrap_or(PADDING)
        
        let v0 = if c0 == PADDING { 0 } else {
            let v = lookup[c0 as Int]
            if v < 0 { return Err(Base64Error.InvalidCharacter(c0)) }
            v as UInt8
        }
        
        let v1 = if c1 == PADDING { 0 } else {
            let v = lookup[c1 as Int]
            if v < 0 { return Err(Base64Error.InvalidCharacter(c1)) }
            v as UInt8
        }
        
        let v2 = if c2 == PADDING { 0 } else {
            let v = lookup[c2 as Int]
            if v < 0 { return Err(Base64Error.InvalidCharacter(c2)) }
            v as UInt8
        }
        
        let v3 = if c3 == PADDING { 0 } else {
            let v = lookup[c3 as Int]
            if v < 0 { return Err(Base64Error.InvalidCharacter(c3)) }
            v as UInt8
        }
        
        result.push((v0 << 2) | (v1 >> 4))
        
        if c2 != PADDING {
            result.push(((v1 & 0x0f) << 4) | (v2 >> 2))
        }
        
        if c3 != PADDING {
            result.push(((v2 & 0x03) << 6) | v3)
        }
        
        i += 4
    }
    
    Ok(result)
}

/// Decode base64 to string
fn decode_string(s: String) -> Result<String, Base64Error> {
    let bytes = decode(s)?
    String.from_utf8(bytes).map_err(|_| Base64Error.InvalidUtf8)
}

/// Decode URL-safe base64
fn decode_url_safe(s: String) -> Result<[UInt8], Base64Error> {
    decode_with(s, Base64Config.url_safe())
}

// -----------------------------------------------------------------------------
// Streaming Encoder/Decoder
// -----------------------------------------------------------------------------

/// Streaming base64 encoder
actor Base64Encoder {
    state config: Base64Config
    state buffer: [UInt8]
    state output: String
    
    fn new() -> Self {
        Base64Encoder { config: Base64Config.standard(), buffer: [], output: "" }
    }
    
    fn with_config(config: Base64Config) -> Self {
        Base64Encoder { config: config, buffer: [], output: "" }
    }
    
    /// Write bytes to encoder
    fn write(data: [UInt8]) {
        self.buffer.extend(data)
        
        // Process complete 3-byte chunks
        while self.buffer.len() >= 3 {
            let chunk = [self.buffer[0], self.buffer[1], self.buffer[2]]
            self.output.push_str(encode_with(chunk, self.config))
            self.buffer = self.buffer[3..]
        }
    }
    
    /// Finish encoding and get result
    fn finish() -> String {
        if !self.buffer.is_empty() {
            self.output.push_str(encode_with(self.buffer, self.config))
            self.buffer.clear()
        }
        
        let result = self.output
        self.output = ""
        result
    }
    
    /// Reset encoder
    fn reset() {
        self.buffer.clear()
        self.output = ""
    }
}

/// Streaming base64 decoder
actor Base64Decoder {
    state config: Base64Config
    state buffer: String
    state output: [UInt8]
    
    fn new() -> Self {
        Base64Decoder { config: Base64Config.standard(), buffer: "", output: [] }
    }
    
    fn with_config(config: Base64Config) -> Self {
        Base64Decoder { config: config, buffer: "", output: [] }
    }
    
    /// Write base64 string to decoder
    fn write(s: String) -> Result<(), Base64Error> {
        // Remove whitespace and add to buffer
        let clean = s.chars().filter(|c| !c.is_whitespace()).collect::<String>()
        self.buffer.push_str(clean)
        
        // Process complete 4-character chunks
        while self.buffer.len() >= 4 {
            let chunk = self.buffer[0..4]
            let decoded = decode_with(chunk, self.config)?
            self.output.extend(decoded)
            self.buffer = self.buffer[4..]
        }
        
        Ok(())
    }
    
    /// Finish decoding and get result
    fn finish() -> Result<[UInt8], Base64Error> {
        if !self.buffer.is_empty() {
            // Pad if necessary
            while self.buffer.len() % 4 != 0 {
                self.buffer.push(PADDING)
            }
            let decoded = decode_with(self.buffer, self.config)?
            self.output.extend(decoded)
            self.buffer = ""
        }
        
        let result = self.output
        self.output = []
        Ok(result)
    }
    
    /// Reset decoder
    fn reset() {
        self.buffer = ""
        self.output = []
    }
}

// -----------------------------------------------------------------------------
// Data URL
// -----------------------------------------------------------------------------

/// Parse data URL
fn parse_data_url(url: String) -> Result<(String, [UInt8]), Base64Error> {
    if !url.starts_with("data:") {
        return Err(Base64Error.InvalidDataUrl)
    }
    
    let rest = url[5..]
    let comma_idx = rest.find(",").ok_or(Base64Error.InvalidDataUrl)?
    
    let meta = rest[0..comma_idx]
    let data = rest[(comma_idx + 1)..]
    
    let mime = if meta.contains(";base64") {
        meta.replace(";base64", "")
    } else {
        meta
    }
    
    let bytes = if meta.contains(";base64") {
        decode(data)?
    } else {
        // URL-encoded
        url_decode(data)
    }
    
    Ok((mime, bytes))
}

/// Create data URL
fn to_data_url(mime: String, data: [UInt8]) -> String {
    format!("data:{};base64,{}", mime, encode(data))
}

fn url_decode(s: String) -> [UInt8] {
    var result = []
    var i = 0
    let chars = s.chars().collect::<Vec<_>>()
    
    while i < chars.len() {
        if chars[i] == '%' && i + 2 < chars.len() {
            let hex = format!("{}{}", chars[i + 1], chars[i + 2])
            if let Ok(b) = UInt8.parse_hex(hex) {
                result.push(b)
                i += 3
                continue
            }
        }
        result.push(chars[i] as UInt8)
        i += 1
    }
    
    result
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum Base64Error {
    InvalidCharacter(Char)
    InvalidLength
    InvalidPadding
    InvalidUtf8
    InvalidDataUrl
}

impl Display for Base64Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidCharacter(c) => f.write(format!("Invalid base64 character: '{}'", c))
            InvalidLength => f.write("Invalid base64 length")
            InvalidPadding => f.write("Invalid base64 padding")
            InvalidUtf8 => f.write("Invalid UTF-8 in decoded data")
            InvalidDataUrl => f.write("Invalid data URL format")
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "encode empty" {
    assert_eq(encode([]), "")?
}

test "encode basic" {
    assert_eq(encode_string("Hello"), "SGVsbG8=")?
    assert_eq(encode_string("Hello!"), "SGVsbG8h")?
    assert_eq(encode_string("Hello!!"), "SGVsbG8hIQ==")?
}

test "decode basic" {
    assert_eq(decode_string("SGVsbG8=")?, "Hello")?
    assert_eq(decode_string("SGVsbG8h")?, "Hello!")?
}

test "roundtrip" {
    let original = "The quick brown fox jumps over the lazy dog"
    let encoded = encode_string(original)
    let decoded = decode_string(encoded)?
    assert_eq(decoded, original)?
}

test "url safe" {
    let data = [0xfb, 0xff, 0xfe]  // Would produce +/
    let standard = encode(data)
    let url_safe = encode_url_safe(data)
    
    assert(standard.contains("+") || standard.contains("/"))?
    assert(!url_safe.contains("+"))?
    assert(!url_safe.contains("/"))?
}

test "no padding" {
    let config = Base64Config.standard_no_pad()
    let encoded = encode_with("Hello".as_bytes(), config)
    assert(!encoded.contains("="))?
}

test "decode with whitespace" {
    let encoded = "SGVs\nbG8="
    assert_eq(decode_string(encoded)?, "Hello")?
}

test "data url" {
    let data = "Hello, World!".as_bytes()
    let url = to_data_url("text/plain", data)
    let (mime, decoded) = parse_data_url(url)?
    assert_eq(mime, "text/plain")?
    assert_eq(decoded, data)?
}

test "streaming encoder" {
    var encoder = Base64Encoder.new()
    encoder.write("Hel".as_bytes())
    encoder.write("lo".as_bytes())
    let result = encoder.finish()
    assert_eq(result, "SGVsbG8=")?
}
