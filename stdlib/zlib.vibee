// =============================================================================
// Vibee OS â€” Zlib Module
// Zlib compression and decompression (RFC 1950)
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

const ZLIB_DEFLATE: UInt8 = 8
const ZLIB_MAX_WBITS: Int = 15
const ZLIB_DEFAULT_MEMLEVEL: Int = 8

// Compression method + info byte patterns
const ZLIB_CM_DEFLATE: UInt8 = 0x78
const ZLIB_FLEVEL_FASTEST: UInt8 = 0x01
const ZLIB_FLEVEL_FAST: UInt8 = 0x5e
const ZLIB_FLEVEL_DEFAULT: UInt8 = 0x9c
const ZLIB_FLEVEL_BEST: UInt8 = 0xda

// =============================================================================
// Compression Level
// =============================================================================

/// Zlib compression level
enum ZlibLevel {
    None        // No compression (level 0)
    Fast        // Fast compression (level 1)
    Default     // Default compression (level 6)
    Best        // Best compression (level 9)
    Custom(Int) // Custom level (0-9)
}

impl ZlibLevel {
    fn value() -> Int {
        match self {
            None => 0
            Fast => 1
            Default => 6
            Best => 9
            Custom(n) => n.clamp(0, 9)
        }
    }
    
    fn from_int(level: Int) -> Self {
        match level {
            0 => ZlibLevel.None
            1 => ZlibLevel.Fast
            6 => ZlibLevel.Default
            9 => ZlibLevel.Best
            n => ZlibLevel.Custom(n.clamp(0, 9))
        }
    }
}

// =============================================================================
// Compression Strategy
// =============================================================================

/// Compression strategy
enum ZlibStrategy {
    Default     // Default strategy
    Filtered    // For data with small values and random distribution
    Huffman     // Huffman only (no string matching)
    Rle         // Run-length encoding
    Fixed       // Fixed Huffman codes
}

impl ZlibStrategy {
    fn value() -> Int {
        match self {
            Default => 0
            Filtered => 1
            Huffman => 2
            Rle => 3
            Fixed => 4
        }
    }
}

// =============================================================================
// Flush Mode
// =============================================================================

/// Flush mode for streaming compression
enum ZlibFlush {
    None        // No flush
    Partial     // Partial flush
    Sync        // Sync flush
    Full        // Full flush
    Finish      // Finish compression
    Block       // Block flush
    Trees       // Trees flush
}

impl ZlibFlush {
    fn value() -> Int {
        match self {
            None => 0
            Partial => 1
            Sync => 2
            Full => 3
            Finish => 4
            Block => 5
            Trees => 6
        }
    }
}

// =============================================================================
// Compression Options
// =============================================================================

/// Zlib compression options
struct ZlibOptions {
    level: ZlibLevel
    strategy: ZlibStrategy
    window_bits: Int
    mem_level: Int
}

impl ZlibOptions {
    fn new() -> Self {
        ZlibOptions {
            level: ZlibLevel.Default,
            strategy: ZlibStrategy.Default,
            window_bits: ZLIB_MAX_WBITS,
            mem_level: ZLIB_DEFAULT_MEMLEVEL
        }
    }
    
    fn with_level(level: ZlibLevel) -> Self {
        var opts = Self.new()
        opts.level = level
        opts
    }
    
    fn level(l: ZlibLevel) -> Self {
        self.level = l
        self
    }
    
    fn strategy(s: ZlibStrategy) -> Self {
        self.strategy = s
        self
    }
    
    fn window_bits(bits: Int) -> Self {
        self.window_bits = bits.clamp(8, 15)
        self
    }
    
    fn mem_level(level: Int) -> Self {
        self.mem_level = level.clamp(1, 9)
        self
    }
}

// =============================================================================
// Core Functions
// =============================================================================

/// Compress data using zlib with default level
fn compress(data: [UInt8]) -> Result<[UInt8], ZlibError> {
    compress_level(data, ZlibLevel.Default)
}

/// Compress data using zlib with specified level
fn compress_level(data: [UInt8], level: ZlibLevel) -> Result<[UInt8], ZlibError> {
    @native("zlib_compress", data, level.value())
}

/// Compress data with options
fn compress_with_options(data: [UInt8], options: ZlibOptions) -> Result<[UInt8], ZlibError> {
    @native("zlib_compress_opts", data, options.level.value(), options.strategy.value(), options.window_bits, options.mem_level)
}

/// Decompress zlib data
fn decompress(data: [UInt8]) -> Result<[UInt8], ZlibError> {
    @native("zlib_decompress", data)
}

/// Decompress with size hint
fn decompress_with_hint(data: [UInt8], size_hint: Int) -> Result<[UInt8], ZlibError> {
    @native("zlib_decompress_hint", data, size_hint)
}

/// Check if data is zlib compressed
fn is_zlib(data: [UInt8]) -> Bool {
    if data.len() < 2 { return false }
    
    // Check CMF byte (compression method and info)
    let cmf = data[0]
    let cm = cmf & 0x0f  // Compression method
    let cinfo = (cmf >> 4) & 0x0f  // Window size
    
    if cm != 8 { return false }  // Must be deflate
    if cinfo > 7 { return false }  // Window size too large
    
    // Check FLG byte
    let flg = data[1]
    let check = ((cmf as UInt16) * 256 + (flg as UInt16)) % 31
    
    check == 0
}

/// Get compression level from zlib header
fn get_compression_level(data: [UInt8]) -> Option<ZlibLevel> {
    if data.len() < 2 { return None }
    
    let flg = data[1]
    let flevel = (flg >> 6) & 0x03
    
    Some(match flevel {
        0 => ZlibLevel.Fast
        1 => ZlibLevel.Fast
        2 => ZlibLevel.Default
        3 => ZlibLevel.Best
        _ => ZlibLevel.Default
    })
}

// =============================================================================
// Raw Deflate (no zlib header)
// =============================================================================

/// Compress using raw deflate (no zlib wrapper)
fn deflate(data: [UInt8]) -> Result<[UInt8], ZlibError> {
    deflate_level(data, ZlibLevel.Default)
}

/// Compress using raw deflate with level
fn deflate_level(data: [UInt8], level: ZlibLevel) -> Result<[UInt8], ZlibError> {
    @native("deflate_compress", data, level.value())
}

/// Decompress raw deflate data
fn inflate(data: [UInt8]) -> Result<[UInt8], ZlibError> {
    @native("deflate_decompress", data)
}

/// Decompress raw deflate with size hint
fn inflate_with_hint(data: [UInt8], size_hint: Int) -> Result<[UInt8], ZlibError> {
    @native("deflate_decompress_hint", data, size_hint)
}

// =============================================================================
// Streaming Compressor
// =============================================================================

/// Streaming zlib compressor
struct ZlibCompressor {
    inner: @native("ZlibCompressor")
    options: ZlibOptions
    bytes_in: Int64
    bytes_out: Int64
}

impl ZlibCompressor {
    fn new() -> Self {
        Self.with_options(ZlibOptions.new())
    }
    
    fn with_level(level: ZlibLevel) -> Self {
        Self.with_options(ZlibOptions.with_level(level))
    }
    
    fn with_options(options: ZlibOptions) -> Self {
        ZlibCompressor {
            inner: @native("zlib_compressor_new", options.level.value(), options.strategy.value(), options.window_bits, options.mem_level),
            options: options,
            bytes_in: 0,
            bytes_out: 0
        }
    }
    
    /// Compress data chunk
    fn compress(data: [UInt8]) -> Result<[UInt8], ZlibError> {
        self.compress_flush(data, ZlibFlush.None)
    }
    
    /// Compress data chunk with flush mode
    fn compress_flush(data: [UInt8], flush: ZlibFlush) -> Result<[UInt8], ZlibError> {
        self.bytes_in += data.len() as Int64
        let output = @native("zlib_compressor_compress", self.inner, data, flush.value())?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    /// Flush compressed data
    fn flush() -> Result<[UInt8], ZlibError> {
        let output = @native("zlib_compressor_flush", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    /// Finish compression
    fn finish() -> Result<[UInt8], ZlibError> {
        let output = @native("zlib_compressor_finish", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    /// Reset compressor for reuse
    fn reset() {
        self.inner = @native("zlib_compressor_new", self.options.level.value(), self.options.strategy.value(), self.options.window_bits, self.options.mem_level)
        self.bytes_in = 0
        self.bytes_out = 0
    }
    
    /// Get total bytes input
    fn total_in() -> Int64 { self.bytes_in }
    
    /// Get total bytes output
    fn total_out() -> Int64 { self.bytes_out }
    
    /// Get compression ratio
    fn ratio() -> Float64 {
        if self.bytes_in == 0 { return 0.0 }
        1.0 - (self.bytes_out as Float64 / self.bytes_in as Float64)
    }
}

impl Write for ZlibCompressor {
    fn write(data: [UInt8]) -> Result<Int, IoError> {
        self.compress(data).map_err(|e| IoError.Other(e.to_string()))?
        Ok(data.len())
    }
    
    fn flush() -> Result<(), IoError> {
        self.flush().map_err(|e| IoError.Other(e.to_string()))?
        Ok(())
    }
}

// =============================================================================
// Streaming Decompressor
// =============================================================================

/// Streaming zlib decompressor
struct ZlibDecompressor {
    inner: @native("ZlibDecompressor")
    bytes_in: Int64
    bytes_out: Int64
    finished: Bool
}

impl ZlibDecompressor {
    fn new() -> Self {
        ZlibDecompressor {
            inner: @native("zlib_decompressor_new"),
            bytes_in: 0,
            bytes_out: 0,
            finished: false
        }
    }
    
    fn with_window_bits(window_bits: Int) -> Self {
        ZlibDecompressor {
            inner: @native("zlib_decompressor_new_wbits", window_bits),
            bytes_in: 0,
            bytes_out: 0,
            finished: false
        }
    }
    
    /// Decompress data chunk
    fn decompress(data: [UInt8]) -> Result<[UInt8], ZlibError> {
        if self.finished {
            return Err(ZlibError.StreamEnd)
        }
        
        self.bytes_in += data.len() as Int64
        let output = @native("zlib_decompressor_decompress", self.inner, data)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    /// Finish decompression
    fn finish() -> Result<[UInt8], ZlibError> {
        if self.finished {
            return Ok([])
        }
        
        self.finished = true
        let output = @native("zlib_decompressor_finish", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    /// Check if stream is finished
    fn is_finished() -> Bool { self.finished }
    
    /// Reset decompressor for reuse
    fn reset() {
        self.inner = @native("zlib_decompressor_new")
        self.bytes_in = 0
        self.bytes_out = 0
        self.finished = false
    }
    
    /// Get total bytes input
    fn total_in() -> Int64 { self.bytes_in }
    
    /// Get total bytes output
    fn total_out() -> Int64 { self.bytes_out }
}

// =============================================================================
// Raw Deflate Streaming
// =============================================================================

/// Raw deflate compressor (no zlib header)
struct DeflateCompressor {
    inner: @native("DeflateCompressor")
    level: ZlibLevel
    bytes_in: Int64
    bytes_out: Int64
}

impl DeflateCompressor {
    fn new() -> Self {
        Self.with_level(ZlibLevel.Default)
    }
    
    fn with_level(level: ZlibLevel) -> Self {
        DeflateCompressor {
            inner: @native("deflate_compressor_new", level.value()),
            level: level,
            bytes_in: 0,
            bytes_out: 0
        }
    }
    
    fn compress(data: [UInt8]) -> Result<[UInt8], ZlibError> {
        self.bytes_in += data.len() as Int64
        let output = @native("deflate_compressor_compress", self.inner, data)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn finish() -> Result<[UInt8], ZlibError> {
        let output = @native("deflate_compressor_finish", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn reset() {
        self.inner = @native("deflate_compressor_new", self.level.value())
        self.bytes_in = 0
        self.bytes_out = 0
    }
}

/// Raw deflate decompressor
struct DeflateDecompressor {
    inner: @native("DeflateDecompressor")
    bytes_in: Int64
    bytes_out: Int64
}

impl DeflateDecompressor {
    fn new() -> Self {
        DeflateDecompressor {
            inner: @native("deflate_decompressor_new"),
            bytes_in: 0,
            bytes_out: 0
        }
    }
    
    fn decompress(data: [UInt8]) -> Result<[UInt8], ZlibError> {
        self.bytes_in += data.len() as Int64
        let output = @native("deflate_decompressor_decompress", self.inner, data)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn finish() -> Result<[UInt8], ZlibError> {
        let output = @native("deflate_decompressor_finish", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn reset() {
        self.inner = @native("deflate_decompressor_new")
        self.bytes_in = 0
        self.bytes_out = 0
    }
}

// =============================================================================
// Async Streaming
// =============================================================================

/// Async zlib compressor actor
actor AsyncZlibCompressor {
    state compressor: ZlibCompressor
    state output_buffer: [UInt8]
    state chunk_size: Int
    
    fn new() -> Self {
        AsyncZlibCompressor {
            compressor: ZlibCompressor.new(),
            output_buffer: [],
            chunk_size: 65536
        }
    }
    
    fn with_level(level: ZlibLevel) -> Self {
        AsyncZlibCompressor {
            compressor: ZlibCompressor.with_level(level),
            output_buffer: [],
            chunk_size: 65536
        }
    }
    
    /// Compress data asynchronously
    async fn compress(data: [UInt8]) -> Result<(), ZlibError> {
        let output = self.compressor.compress(data)?
        self.output_buffer.extend(output)
        Ok(())
    }
    
    /// Get compressed output
    async fn take_output() -> [UInt8] {
        let result = self.output_buffer.clone()
        self.output_buffer.clear()
        result
    }
    
    /// Finish compression
    async fn finish() -> Result<[UInt8], ZlibError> {
        let final_output = self.compressor.finish()?
        self.output_buffer.extend(final_output)
        Ok(self.take_output().await)
    }
}

/// Async zlib decompressor actor
actor AsyncZlibDecompressor {
    state decompressor: ZlibDecompressor
    state output_buffer: [UInt8]
    
    fn new() -> Self {
        AsyncZlibDecompressor {
            decompressor: ZlibDecompressor.new(),
            output_buffer: []
        }
    }
    
    /// Decompress data asynchronously
    async fn decompress(data: [UInt8]) -> Result<(), ZlibError> {
        let output = self.decompressor.decompress(data)?
        self.output_buffer.extend(output)
        Ok(())
    }
    
    /// Get decompressed output
    async fn take_output() -> [UInt8] {
        let result = self.output_buffer.clone()
        self.output_buffer.clear()
        result
    }
    
    /// Finish decompression
    async fn finish() -> Result<[UInt8], ZlibError> {
        let final_output = self.decompressor.finish()?
        self.output_buffer.extend(final_output)
        Ok(self.take_output().await)
    }
}

// =============================================================================
// Checksums
// =============================================================================

/// Calculate Adler-32 checksum
fn adler32(data: [UInt8]) -> UInt32 {
    @native("adler32", data)
}

/// Update Adler-32 checksum incrementally
fn adler32_update(checksum: UInt32, data: [UInt8]) -> UInt32 {
    @native("adler32_update", checksum, data)
}

/// Calculate CRC-32 checksum
fn crc32(data: [UInt8]) -> UInt32 {
    @native("crc32", data)
}

/// Update CRC-32 checksum incrementally
fn crc32_update(checksum: UInt32, data: [UInt8]) -> UInt32 {
    @native("crc32_update", checksum, data)
}

/// Combine two Adler-32 checksums
fn adler32_combine(adler1: UInt32, adler2: UInt32, len2: Int64) -> UInt32 {
    @native("adler32_combine", adler1, adler2, len2)
}

/// Combine two CRC-32 checksums
fn crc32_combine(crc1: UInt32, crc2: UInt32, len2: Int64) -> UInt32 {
    @native("crc32_combine", crc1, crc2, len2)
}

// =============================================================================
// Dictionary Compression
// =============================================================================

/// Compress with preset dictionary
fn compress_with_dict(data: [UInt8], dict: [UInt8]) -> Result<[UInt8], ZlibError> {
    compress_with_dict_level(data, dict, ZlibLevel.Default)
}

/// Compress with preset dictionary and level
fn compress_with_dict_level(data: [UInt8], dict: [UInt8], level: ZlibLevel) -> Result<[UInt8], ZlibError> {
    @native("zlib_compress_dict", data, dict, level.value())
}

/// Decompress with preset dictionary
fn decompress_with_dict(data: [UInt8], dict: [UInt8]) -> Result<[UInt8], ZlibError> {
    @native("zlib_decompress_dict", data, dict)
}

/// Get dictionary ID from compressed data
fn get_dict_id(data: [UInt8]) -> Option<UInt32> {
    if data.len() < 6 { return None }
    
    let flg = data[1]
    if (flg & 0x20) == 0 { return None }  // FDICT not set
    
    Some(
        ((data[2] as UInt32) << 24) |
        ((data[3] as UInt32) << 16) |
        ((data[4] as UInt32) << 8) |
        (data[5] as UInt32)
    )
}

// =============================================================================
// Utilities
// =============================================================================

/// Calculate compression bound (maximum compressed size)
fn compress_bound(source_len: Int) -> Int {
    source_len + (source_len >> 12) + (source_len >> 14) + (source_len >> 25) + 13
}

/// Estimate decompressed size (if known from header)
fn estimate_decompressed_size(data: [UInt8]) -> Option<Int> {
    // Zlib doesn't store uncompressed size in header
    // Return None to indicate unknown
    None
}

/// Get zlib version
fn version() -> String {
    @native("zlib_version")
}

// =============================================================================
// Errors
// =============================================================================

enum ZlibError {
    InvalidData
    InvalidHeader
    InvalidChecksum
    BufferTooSmall
    StreamEnd
    NeedDict(UInt32)
    MemoryError
    DataError
    StreamError
    Other(String)
}

impl Display for ZlibError {
    fn fmt(f: Formatter) {
        match self {
            InvalidData => f.write("Invalid compressed data")
            InvalidHeader => f.write("Invalid zlib header")
            InvalidChecksum => f.write("Invalid checksum")
            BufferTooSmall => f.write("Output buffer too small")
            StreamEnd => f.write("Stream already finished")
            NeedDict(id) => f.write(format!("Dictionary needed: {}", id))
            MemoryError => f.write("Memory allocation error")
            DataError => f.write("Data error")
            StreamError => f.write("Stream error")
            Other(s) => f.write(s)
        }
    }
}

impl Error for ZlibError {}

// =============================================================================
// Tests
// =============================================================================

test "compress decompress roundtrip" {
    let original = "Hello, World! This is a test of zlib compression.".as_bytes()
    let compressed = compress(original)?
    let decompressed = decompress(compressed)?
    assert_eq(decompressed, original)?
}

test "compression levels" {
    let data = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa".repeat(100).as_bytes()
    
    let fast = compress_level(data, ZlibLevel.Fast)?
    let default = compress_level(data, ZlibLevel.Default)?
    let best = compress_level(data, ZlibLevel.Best)?
    
    assert_eq(decompress(fast)?, data)?
    assert_eq(decompress(default)?, data)?
    assert_eq(decompress(best)?, data)?
}

test "is_zlib" {
    let compressed = compress("test".as_bytes())?
    assert(is_zlib(compressed))?
    assert(!is_zlib("not zlib".as_bytes()))?
}

test "raw deflate" {
    let original = "Test deflate compression".as_bytes()
    let compressed = deflate(original)?
    let decompressed = inflate(compressed)?
    assert_eq(decompressed, original)?
}

test "streaming compressor" {
    var compressor = ZlibCompressor.new()
    compressor.compress("Hello, ".as_bytes())?
    compressor.compress("World!".as_bytes())?
    let compressed = compressor.finish()?
    
    let decompressed = decompress(compressed)?
    assert_eq(String.from_utf8(decompressed)?, "Hello, World!")?
}

test "streaming decompressor" {
    let original = "Test data for streaming".as_bytes()
    let compressed = compress(original)?
    
    var decompressor = ZlibDecompressor.new()
    let part1 = decompressor.decompress(compressed)?
    let part2 = decompressor.finish()?
    
    var result = []
    result.extend(part1)
    result.extend(part2)
    assert_eq(result, original)?
}

test "adler32" {
    let data = "Hello, World!".as_bytes()
    let checksum = adler32(data)
    assert(checksum != 0)?
    
    // Incremental should match
    var incremental = adler32([])
    incremental = adler32_update(incremental, data)
    assert_eq(incremental, checksum)?
}

test "crc32" {
    let data = "Hello, World!".as_bytes()
    let checksum = crc32(data)
    assert(checksum != 0)?
}

test "empty data" {
    let compressed = compress([])?
    let decompressed = decompress(compressed)?
    assert_eq(decompressed, [])?
}

test "compress bound" {
    let bound = compress_bound(1000)
    assert(bound > 1000)?
}
