// =============================================================================
// Vibee OS â€” Rate Limiting Module
// Rate limiters, throttling, and quota management
// =============================================================================

use duration.{Duration}
use instant.{Instant}

// -----------------------------------------------------------------------------
// Token Bucket Rate Limiter
// -----------------------------------------------------------------------------

/// Token bucket rate limiter
actor TokenBucket {
    state capacity: Int64
    state tokens: Float
    state refill_rate: Float      // tokens per nanosecond
    state last_refill: Instant
    
    /// Create a new token bucket
    fn new(capacity: Int64, refill_rate: Float, refill_unit: Duration) -> Self {
        let rate_per_nano = refill_rate / refill_unit.as_nanos() as Float
        TokenBucket {
            capacity: capacity,
            tokens: capacity as Float,
            refill_rate: rate_per_nano,
            last_refill: Instant.now()
        }
    }
    
    /// Create with requests per second
    fn per_second(requests: Int64) -> Self {
        Self.new(requests, requests as Float, Duration.seconds(1))
    }
    
    /// Create with requests per minute
    fn per_minute(requests: Int64) -> Self {
        Self.new(requests, requests as Float, Duration.minutes(1))
    }
    
    /// Create with requests per hour
    fn per_hour(requests: Int64) -> Self {
        Self.new(requests, requests as Float, Duration.hours(1))
    }
    
    /// Create with burst capacity
    fn with_burst(rate: Int64, rate_unit: Duration, burst: Int64) -> Self {
        let rate_per_nano = rate as Float / rate_unit.as_nanos() as Float
        TokenBucket {
            capacity: burst,
            tokens: burst as Float,
            refill_rate: rate_per_nano,
            last_refill: Instant.now()
        }
    }
    
    /// Try to acquire a token (non-blocking)
    fn try_acquire() -> Bool {
        self.try_acquire_n(1)
    }
    
    /// Try to acquire N tokens (non-blocking)
    fn try_acquire_n(n: Int64) -> Bool {
        self.refill()
        
        if self.tokens >= n as Float {
            self.tokens -= n as Float
            true
        } else {
            false
        }
    }
    
    /// Acquire a token (blocking)
    fn acquire() {
        self.acquire_n(1)
    }
    
    /// Acquire N tokens (blocking)
    fn acquire_n(n: Int64) {
        while !self.try_acquire_n(n) {
            let wait_time = self.time_until_available(n)
            @native("sleep_nanos", wait_time.as_nanos())
        }
    }
    
    /// Try to acquire with timeout
    fn try_acquire_timeout(timeout: Duration) -> Bool {
        self.try_acquire_n_timeout(1, timeout)
    }
    
    /// Try to acquire N tokens with timeout
    fn try_acquire_n_timeout(n: Int64, timeout: Duration) -> Bool {
        let deadline = Instant.now() + timeout
        
        while !self.try_acquire_n(n) {
            if Instant.now() >= deadline {
                return false
            }
            let wait_time = self.time_until_available(n).min(deadline - Instant.now())
            @native("sleep_nanos", wait_time.as_nanos())
        }
        true
    }
    
    /// Get time until N tokens are available
    fn time_until_available(n: Int64) -> Duration {
        self.refill()
        
        if self.tokens >= n as Float {
            Duration.zero()
        } else {
            let needed = n as Float - self.tokens
            let nanos = (needed / self.refill_rate) as Int64
            Duration.nanos(nanos)
        }
    }
    
    /// Get current token count
    fn available() -> Int64 {
        self.refill()
        self.tokens as Int64
    }
    
    /// Get capacity
    fn capacity() -> Int64 { self.capacity }
    
    /// Reset to full capacity
    fn reset() {
        self.tokens = self.capacity as Float
        self.last_refill = Instant.now()
    }
    
    fn refill() {
        let now = Instant.now()
        let elapsed = now - self.last_refill
        let new_tokens = elapsed.as_nanos() as Float * self.refill_rate
        
        self.tokens = (self.tokens + new_tokens).min(self.capacity as Float)
        self.last_refill = now
    }
}

// -----------------------------------------------------------------------------
// Leaky Bucket Rate Limiter
// -----------------------------------------------------------------------------

/// Leaky bucket rate limiter (smooths out bursts)
actor LeakyBucket {
    state capacity: Int64
    state current: Int64
    state leak_rate: Float        // items per nanosecond
    state last_leak: Instant
    
    /// Create a new leaky bucket
    fn new(capacity: Int64, leak_rate: Float, leak_unit: Duration) -> Self {
        let rate_per_nano = leak_rate / leak_unit.as_nanos() as Float
        LeakyBucket {
            capacity: capacity,
            current: 0,
            leak_rate: rate_per_nano,
            last_leak: Instant.now()
        }
    }
    
    /// Create with items per second
    fn per_second(capacity: Int64, rate: Int64) -> Self {
        Self.new(capacity, rate as Float, Duration.seconds(1))
    }
    
    /// Try to add an item to the bucket
    fn try_add() -> Bool {
        self.try_add_n(1)
    }
    
    /// Try to add N items to the bucket
    fn try_add_n(n: Int64) -> Bool {
        self.leak()
        
        if self.current + n <= self.capacity {
            self.current += n
            true
        } else {
            false
        }
    }
    
    /// Add an item (blocking until space available)
    fn add() {
        self.add_n(1)
    }
    
    /// Add N items (blocking)
    fn add_n(n: Int64) {
        while !self.try_add_n(n) {
            let wait_time = self.time_until_space(n)
            @native("sleep_nanos", wait_time.as_nanos())
        }
    }
    
    /// Get time until space for N items
    fn time_until_space(n: Int64) -> Duration {
        self.leak()
        
        let needed = (self.current + n - self.capacity).max(0)
        if needed == 0 {
            Duration.zero()
        } else {
            let nanos = (needed as Float / self.leak_rate) as Int64
            Duration.nanos(nanos)
        }
    }
    
    /// Get current fill level
    fn level() -> Int64 {
        self.leak()
        self.current
    }
    
    /// Get available space
    fn available() -> Int64 {
        self.leak()
        self.capacity - self.current
    }
    
    /// Get capacity
    fn capacity() -> Int64 { self.capacity }
    
    /// Reset to empty
    fn reset() {
        self.current = 0
        self.last_leak = Instant.now()
    }
    
    fn leak() {
        let now = Instant.now()
        let elapsed = now - self.last_leak
        let leaked = (elapsed.as_nanos() as Float * self.leak_rate) as Int64
        
        self.current = (self.current - leaked).max(0)
        self.last_leak = now
    }
}

// -----------------------------------------------------------------------------
// Sliding Window Rate Limiter
// -----------------------------------------------------------------------------

/// Sliding window rate limiter
actor SlidingWindow {
    state window_size: Duration
    state max_requests: Int64
    state requests: [Instant]
    
    /// Create a new sliding window limiter
    fn new(window_size: Duration, max_requests: Int64) -> Self {
        SlidingWindow {
            window_size: window_size,
            max_requests: max_requests,
            requests: []
        }
    }
    
    /// Create with requests per second
    fn per_second(max: Int64) -> Self {
        Self.new(Duration.seconds(1), max)
    }
    
    /// Create with requests per minute
    fn per_minute(max: Int64) -> Self {
        Self.new(Duration.minutes(1), max)
    }
    
    /// Try to make a request
    fn try_acquire() -> Bool {
        self.cleanup()
        
        if self.requests.len() as Int64 < self.max_requests {
            self.requests.push(Instant.now())
            true
        } else {
            false
        }
    }
    
    /// Make a request (blocking)
    fn acquire() {
        while !self.try_acquire() {
            let wait_time = self.time_until_available()
            @native("sleep_nanos", wait_time.as_nanos())
        }
    }
    
    /// Get time until a request can be made
    fn time_until_available() -> Duration {
        self.cleanup()
        
        if self.requests.len() as Int64 < self.max_requests {
            Duration.zero()
        } else {
            // Wait until oldest request expires
            let oldest = self.requests.first().unwrap()
            let expires_at = *oldest + self.window_size
            let now = Instant.now()
            
            if expires_at > now {
                expires_at - now
            } else {
                Duration.zero()
            }
        }
    }
    
    /// Get current request count in window
    fn current_count() -> Int64 {
        self.cleanup()
        self.requests.len() as Int64
    }
    
    /// Get remaining requests in window
    fn remaining() -> Int64 {
        self.cleanup()
        (self.max_requests - self.requests.len() as Int64).max(0)
    }
    
    /// Reset the window
    fn reset() {
        self.requests.clear()
    }
    
    fn cleanup() {
        let cutoff = Instant.now() - self.window_size
        self.requests.retain(|r| *r > cutoff)
    }
}

// -----------------------------------------------------------------------------
// Fixed Window Rate Limiter
// -----------------------------------------------------------------------------

/// Fixed window rate limiter
actor FixedWindow {
    state window_size: Duration
    state max_requests: Int64
    state current_count: Int64
    state window_start: Instant
    
    /// Create a new fixed window limiter
    fn new(window_size: Duration, max_requests: Int64) -> Self {
        FixedWindow {
            window_size: window_size,
            max_requests: max_requests,
            current_count: 0,
            window_start: Instant.now()
        }
    }
    
    /// Create with requests per second
    fn per_second(max: Int64) -> Self {
        Self.new(Duration.seconds(1), max)
    }
    
    /// Create with requests per minute
    fn per_minute(max: Int64) -> Self {
        Self.new(Duration.minutes(1), max)
    }
    
    /// Try to make a request
    fn try_acquire() -> Bool {
        self.check_window()
        
        if self.current_count < self.max_requests {
            self.current_count += 1
            true
        } else {
            false
        }
    }
    
    /// Make a request (blocking)
    fn acquire() {
        while !self.try_acquire() {
            let wait_time = self.time_until_reset()
            @native("sleep_nanos", wait_time.as_nanos())
        }
    }
    
    /// Get time until window resets
    fn time_until_reset() -> Duration {
        let now = Instant.now()
        let window_end = self.window_start + self.window_size
        
        if now >= window_end {
            Duration.zero()
        } else {
            window_end - now
        }
    }
    
    /// Get remaining requests in current window
    fn remaining() -> Int64 {
        self.check_window()
        (self.max_requests - self.current_count).max(0)
    }
    
    /// Reset the window
    fn reset() {
        self.current_count = 0
        self.window_start = Instant.now()
    }
    
    fn check_window() {
        let now = Instant.now()
        if now >= self.window_start + self.window_size {
            self.current_count = 0
            self.window_start = now
        }
    }
}

// -----------------------------------------------------------------------------
// Concurrent Rate Limiter
// -----------------------------------------------------------------------------

/// Limits concurrent operations
actor ConcurrencyLimiter {
    state max_concurrent: Int
    state current: Int
    state waiters: [fn()]
    
    /// Create a new concurrency limiter
    fn new(max_concurrent: Int) -> Self {
        ConcurrencyLimiter {
            max_concurrent: max_concurrent,
            current: 0,
            waiters: []
        }
    }
    
    /// Try to acquire a slot
    fn try_acquire() -> Option<ConcurrencyGuard> {
        if self.current < self.max_concurrent {
            self.current += 1
            Some(ConcurrencyGuard { limiter: self })
        } else {
            None
        }
    }
    
    /// Acquire a slot (blocking)
    fn acquire() -> ConcurrencyGuard {
        while self.current >= self.max_concurrent {
            @native("yield")
        }
        self.current += 1
        ConcurrencyGuard { limiter: self }
    }
    
    /// Execute with concurrency limit
    fn with<T>(f: fn() -> T) -> T {
        let _guard = self.acquire()
        f()
    }
    
    /// Get current count
    fn current() -> Int { self.current }
    
    /// Get available slots
    fn available() -> Int { self.max_concurrent - self.current }
    
    fn release() {
        self.current -= 1
        if !self.waiters.is_empty() {
            let waiter = self.waiters.remove(0)
            waiter()
        }
    }
}

struct ConcurrencyGuard {
    limiter: ConcurrencyLimiter
}

impl Drop for ConcurrencyGuard {
    fn drop() {
        self.limiter.release()
    }
}

// -----------------------------------------------------------------------------
// Quota Manager
// -----------------------------------------------------------------------------

/// Manages quotas with reset periods
actor QuotaManager {
    state quotas: Map<String, Quota>
    
    fn new() -> Self {
        QuotaManager { quotas: Map.new() }
    }
    
    /// Create a quota
    fn create_quota(id: String, limit: Int64, period: Duration) {
        self.quotas.insert(id, Quota {
            limit: limit,
            used: 0,
            period: period,
            reset_at: Instant.now() + period
        })
    }
    
    /// Try to use quota
    fn try_use(id: String, amount: Int64) -> QuotaResult {
        if let Some(quota) = self.quotas.get_mut(id) {
            quota.check_reset()
            
            if quota.used + amount <= quota.limit {
                quota.used += amount
                QuotaResult.Allowed {
                    remaining: quota.limit - quota.used,
                    reset_in: quota.reset_at - Instant.now()
                }
            } else {
                QuotaResult.Exceeded {
                    limit: quota.limit,
                    reset_in: quota.reset_at - Instant.now()
                }
            }
        } else {
            QuotaResult.NotFound
        }
    }
    
    /// Get quota status
    fn status(id: String) -> Option<QuotaStatus> {
        self.quotas.get_mut(id).map(|quota| {
            quota.check_reset()
            QuotaStatus {
                limit: quota.limit,
                used: quota.used,
                remaining: quota.limit - quota.used,
                reset_in: quota.reset_at - Instant.now()
            }
        })
    }
    
    /// Reset a quota
    fn reset(id: String) {
        if let Some(quota) = self.quotas.get_mut(id) {
            quota.used = 0
            quota.reset_at = Instant.now() + quota.period
        }
    }
    
    /// Remove a quota
    fn remove(id: String) {
        self.quotas.remove(id)
    }
}

struct Quota {
    limit: Int64
    used: Int64
    period: Duration
    reset_at: Instant
    
    fn check_reset() {
        let now = Instant.now()
        if now >= self.reset_at {
            self.used = 0
            self.reset_at = now + self.period
        }
    }
}

enum QuotaResult {
    Allowed { remaining: Int64, reset_in: Duration }
    Exceeded { limit: Int64, reset_in: Duration }
    NotFound
}

struct QuotaStatus {
    limit: Int64
    used: Int64
    remaining: Int64
    reset_in: Duration
}

// -----------------------------------------------------------------------------
// Rate Limiter Middleware
// -----------------------------------------------------------------------------

/// HTTP-style rate limiter with headers
actor HttpRateLimiter {
    state limiter: TokenBucket
    state name: String
    
    fn new(name: String, requests_per_second: Int64) -> Self {
        HttpRateLimiter {
            limiter: TokenBucket.per_second(requests_per_second),
            name: name
        }
    }
    
    /// Check rate limit and return headers
    fn check() -> RateLimitResponse {
        let allowed = self.limiter.try_acquire()
        let remaining = self.limiter.available()
        let reset = if allowed {
            Duration.zero()
        } else {
            self.limiter.time_until_available(1)
        }
        
        RateLimitResponse {
            allowed: allowed,
            limit: self.limiter.capacity(),
            remaining: remaining,
            reset: reset,
            retry_after: if allowed { None } else { Some(reset) }
        }
    }
    
    /// Get rate limit headers
    fn headers() -> Map<String, String> {
        let response = self.check()
        var headers = Map.new()
        
        headers.insert("X-RateLimit-Limit", response.limit.to_string())
        headers.insert("X-RateLimit-Remaining", response.remaining.to_string())
        headers.insert("X-RateLimit-Reset", response.reset.as_seconds().to_string())
        
        if let Some(retry) = response.retry_after {
            headers.insert("Retry-After", retry.as_seconds().to_string())
        }
        
        headers
    }
}

struct RateLimitResponse {
    allowed: Bool
    limit: Int64
    remaining: Int64
    reset: Duration
    retry_after: Option<Duration>
}

// -----------------------------------------------------------------------------
// Adaptive Rate Limiter
// -----------------------------------------------------------------------------

/// Rate limiter that adapts based on response times
actor AdaptiveRateLimiter {
    state base_rate: Int64
    state current_rate: Int64
    state min_rate: Int64
    state max_rate: Int64
    state target_latency: Duration
    state limiter: TokenBucket
    state samples: [Duration]
    state sample_size: Int
    
    fn new(base_rate: Int64, target_latency: Duration) -> Self {
        AdaptiveRateLimiter {
            base_rate: base_rate,
            current_rate: base_rate,
            min_rate: base_rate / 10,
            max_rate: base_rate * 10,
            target_latency: target_latency,
            limiter: TokenBucket.per_second(base_rate),
            samples: [],
            sample_size: 100
        }
    }
    
    fn min_rate(rate: Int64) -> Self { self.min_rate = rate; self }
    fn max_rate(rate: Int64) -> Self { self.max_rate = rate; self }
    fn sample_size(size: Int) -> Self { self.sample_size = size; self }
    
    /// Try to acquire with latency feedback
    fn try_acquire() -> Bool {
        self.limiter.try_acquire()
    }
    
    /// Record a response latency
    fn record_latency(latency: Duration) {
        self.samples.push(latency)
        
        if self.samples.len() >= self.sample_size {
            self.adjust_rate()
            self.samples.clear()
        }
    }
    
    fn adjust_rate() {
        let avg_latency = self.average_latency()
        
        if avg_latency > self.target_latency {
            // Slow down
            let ratio = self.target_latency.as_nanos() as Float / avg_latency.as_nanos() as Float
            self.current_rate = ((self.current_rate as Float * ratio) as Int64)
                .max(self.min_rate)
        } else {
            // Speed up
            let ratio = self.target_latency.as_nanos() as Float / avg_latency.as_nanos() as Float
            self.current_rate = ((self.current_rate as Float * ratio.sqrt()) as Int64)
                .min(self.max_rate)
        }
        
        self.limiter = TokenBucket.per_second(self.current_rate)
    }
    
    fn average_latency() -> Duration {
        if self.samples.is_empty() {
            self.target_latency
        } else {
            let total: Int64 = self.samples.iter().map(|d| d.as_nanos()).sum()
            Duration.nanos(total / self.samples.len() as Int64)
        }
    }
    
    /// Get current rate
    fn current_rate() -> Int64 { self.current_rate }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Create a token bucket rate limiter
fn token_bucket(capacity: Int64, rate: Int64, unit: Duration) -> TokenBucket {
    TokenBucket.new(capacity, rate as Float, unit)
}

/// Create a sliding window rate limiter
fn sliding_window(window: Duration, max: Int64) -> SlidingWindow {
    SlidingWindow.new(window, max)
}

/// Create a concurrency limiter
fn concurrency(max: Int) -> ConcurrencyLimiter {
    ConcurrencyLimiter.new(max)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "token bucket basic" {
    let bucket = TokenBucket.per_second(10)
    
    // Should allow initial burst
    for _ in 0..10 {
        assert(bucket.try_acquire())?
    }
    
    // Should be exhausted
    assert(!bucket.try_acquire())?
}

test "token bucket refill" {
    let bucket = TokenBucket.per_second(100)
    
    // Exhaust tokens
    for _ in 0..100 {
        bucket.try_acquire()
    }
    
    // Wait for refill
    @native("sleep_ms", 100)
    
    // Should have some tokens now
    assert(bucket.available() > 0)?
}

test "sliding window" {
    let window = SlidingWindow.new(Duration.millis(100), 5)
    
    // Should allow up to limit
    for _ in 0..5 {
        assert(window.try_acquire())?
    }
    
    // Should be at limit
    assert(!window.try_acquire())?
    
    // Wait for window to slide
    @native("sleep_ms", 150)
    
    // Should allow again
    assert(window.try_acquire())?
}

test "fixed window" {
    let window = FixedWindow.new(Duration.millis(100), 5)
    
    for _ in 0..5 {
        assert(window.try_acquire())?
    }
    
    assert(!window.try_acquire())?
    assert_eq(window.remaining(), 0)?
}

test "concurrency limiter" {
    let limiter = ConcurrencyLimiter.new(2)
    
    let g1 = limiter.try_acquire()
    assert(g1.is_some())?
    
    let g2 = limiter.try_acquire()
    assert(g2.is_some())?
    
    let g3 = limiter.try_acquire()
    assert(g3.is_none())?
    
    drop(g1)
    
    let g4 = limiter.try_acquire()
    assert(g4.is_some())?
}

test "quota manager" {
    let manager = QuotaManager.new()
    manager.create_quota("api", 100, Duration.hours(1))
    
    match manager.try_use("api", 10) {
        QuotaResult.Allowed { remaining, .. } => {
            assert_eq(remaining, 90)?
        }
        _ => assert(false)?
    }
}

test "leaky bucket" {
    let bucket = LeakyBucket.per_second(10, 5)
    
    // Add items
    for _ in 0..10 {
        assert(bucket.try_add())?
    }
    
    // Should be full
    assert(!bucket.try_add())?
    
    // Wait for leak
    @native("sleep_ms", 500)
    
    // Should have space
    assert(bucket.try_add())?
}
