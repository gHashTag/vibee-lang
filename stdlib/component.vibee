// =============================================================================
// Vibee OS â€” Component Module
// UI Components for building user interfaces
// =============================================================================

use color::{RGB, RGBA}
use canvas::{Rect, Point}

// -----------------------------------------------------------------------------
// Core Component Traits
// -----------------------------------------------------------------------------

/// Base trait for all UI components
trait Component {
    fn render(ctx: &mut RenderContext)
    fn measure(constraints: Constraints) -> Size
    fn layout(bounds: Rect)
    fn id() -> Option<String>
}

/// Trait for interactive components
trait Interactive {
    fn on_click(handler: fn())
    fn on_hover(handler: fn(Bool))
    fn on_focus(handler: fn(Bool))
    fn is_enabled() -> Bool
    fn set_enabled(enabled: Bool)
}

/// Trait for components with children
trait Container {
    fn children() -> [&dyn Component]
    fn add_child(child: Box<dyn Component>)
    fn remove_child(id: String) -> Option<Box<dyn Component>>
}

// -----------------------------------------------------------------------------
// Core Types
// -----------------------------------------------------------------------------

/// Size constraint for layout
struct Constraints {
    min_width: Float64
    max_width: Float64
    min_height: Float64
    max_height: Float64
    
    fn new(min_w: Float64, max_w: Float64, min_h: Float64, max_h: Float64) -> Self {
        Constraints { min_width: min_w, max_width: max_w, min_height: min_h, max_height: max_h }
    }
    
    fn tight(width: Float64, height: Float64) -> Self {
        Constraints { min_width: width, max_width: width, min_height: height, max_height: height }
    }
    
    fn loose(width: Float64, height: Float64) -> Self {
        Constraints { min_width: 0.0, max_width: width, min_height: 0.0, max_height: height }
    }
    
    fn unbounded() -> Self {
        Constraints { min_width: 0.0, max_width: Float64.infinity(), min_height: 0.0, max_height: Float64.infinity() }
    }
    
    fn constrain(size: Size) -> Size {
        Size {
            width: size.width.clamp(self.min_width, self.max_width),
            height: size.height.clamp(self.min_height, self.max_height)
        }
    }
}

/// Component size
struct Size {
    width: Float64
    height: Float64
    
    fn new(w: Float64, h: Float64) -> Self { Size { width: w, height: h } }
    fn zero() -> Self { Size { width: 0.0, height: 0.0 } }
}

/// Edge insets (padding/margin)
struct EdgeInsets {
    top: Float64
    right: Float64
    bottom: Float64
    left: Float64
    
    fn all(value: Float64) -> Self {
        EdgeInsets { top: value, right: value, bottom: value, left: value }
    }
    
    fn symmetric(horizontal: Float64, vertical: Float64) -> Self {
        EdgeInsets { top: vertical, right: horizontal, bottom: vertical, left: horizontal }
    }
    
    fn only(top: Float64, right: Float64, bottom: Float64, left: Float64) -> Self {
        EdgeInsets { top: top, right: right, bottom: bottom, left: left }
    }
    
    fn zero() -> Self { EdgeInsets { top: 0.0, right: 0.0, bottom: 0.0, left: 0.0 } }
    
    fn horizontal() -> Float64 { self.left + self.right }
    fn vertical() -> Float64 { self.top + self.bottom }
}

/// Border style
struct Border {
    width: Float64
    color: RGBA
    radius: BorderRadius
    style: BorderStyle
    
    fn new(width: Float64, color: RGBA) -> Self {
        Border { width: width, color: color, radius: BorderRadius.zero(), style: BorderStyle.Solid }
    }
    
    fn with_radius(radius: Float64) -> Self {
        self.radius = BorderRadius.all(radius)
        self
    }
    
    fn with_style(style: BorderStyle) -> Self {
        self.style = style
        self
    }
}

struct BorderRadius {
    top_left: Float64
    top_right: Float64
    bottom_right: Float64
    bottom_left: Float64
    
    fn all(radius: Float64) -> Self {
        BorderRadius { top_left: radius, top_right: radius, bottom_right: radius, bottom_left: radius }
    }
    
    fn zero() -> Self { BorderRadius.all(0.0) }
    
    fn only(tl: Float64, tr: Float64, br: Float64, bl: Float64) -> Self {
        BorderRadius { top_left: tl, top_right: tr, bottom_right: br, bottom_left: bl }
    }
}

enum BorderStyle { Solid, Dashed, Dotted, Double, None }

/// Shadow effect
struct Shadow {
    offset_x: Float64
    offset_y: Float64
    blur: Float64
    spread: Float64
    color: RGBA
    
    fn new(x: Float64, y: Float64, blur: Float64, color: RGBA) -> Self {
        Shadow { offset_x: x, offset_y: y, blur: blur, spread: 0.0, color: color }
    }
    
    fn with_spread(spread: Float64) -> Self { self.spread = spread; self }
}

// -----------------------------------------------------------------------------
// Render Context
// -----------------------------------------------------------------------------

/// Context for rendering components
struct RenderContext {
    canvas: &mut Canvas
    clip_rect: Option<Rect>
    transform: Transform
    opacity: Float64
    
    fn new(canvas: &mut Canvas) -> Self {
        RenderContext { canvas: canvas, clip_rect: None, transform: Transform.identity(), opacity: 1.0 }
    }
    
    fn push_clip(rect: Rect) { self.clip_rect = Some(rect) }
    fn pop_clip() { self.clip_rect = None }
    fn push_opacity(opacity: Float64) { self.opacity *= opacity }
    fn pop_opacity() { self.opacity = 1.0 }
}

// -----------------------------------------------------------------------------
// Basic Components
// -----------------------------------------------------------------------------

/// Text component
struct Text {
    content: String
    style: TextStyle
    max_lines: Option<Int>
    overflow: TextOverflow
    
    fn new(content: String) -> Self {
        Text { content: content, style: TextStyle.default(), max_lines: None, overflow: TextOverflow.Ellipsis }
    }
    
    fn styled(content: String, style: TextStyle) -> Self {
        Text { content: content, style: style, max_lines: None, overflow: TextOverflow.Ellipsis }
    }
    
    fn max_lines(lines: Int) -> Self { self.max_lines = Some(lines); self }
    fn overflow(overflow: TextOverflow) -> Self { self.overflow = overflow; self }
}

struct TextStyle {
    font_family: String
    font_size: Float64
    font_weight: FontWeight
    color: RGBA
    line_height: Float64
    letter_spacing: Float64
    decoration: TextDecoration
    
    fn default() -> Self {
        TextStyle {
            font_family: "system-ui",
            font_size: 14.0,
            font_weight: FontWeight.Normal,
            color: RGBA.new(0, 0, 0, 1.0),
            line_height: 1.5,
            letter_spacing: 0.0,
            decoration: TextDecoration.None
        }
    }
    
    fn font(family: String) -> Self { self.font_family = family; self }
    fn size(size: Float64) -> Self { self.font_size = size; self }
    fn weight(weight: FontWeight) -> Self { self.font_weight = weight; self }
    fn color(color: RGBA) -> Self { self.color = color; self }
}

enum FontWeight { Thin, Light, Normal, Medium, SemiBold, Bold, ExtraBold, Black }
enum TextDecoration { None, Underline, LineThrough, Overline }
enum TextOverflow { Clip, Ellipsis, Fade, Visible }

impl Component for Text {
    fn render(ctx: &mut RenderContext) {
        @native("text_render", ctx, self.content, self.style)
    }
    
    fn measure(constraints: Constraints) -> Size {
        @native("text_measure", self.content, self.style, constraints)
    }
    
    fn layout(bounds: Rect) {}
    fn id() -> Option<String> { None }
}

/// Button component
struct Button {
    child: Box<dyn Component>
    style: ButtonStyle
    on_pressed: Option<fn()>
    enabled: Bool
    loading: Bool
    
    fn new(label: String) -> Self {
        Button {
            child: Box.new(Text.new(label)),
            style: ButtonStyle.default(),
            on_pressed: None,
            enabled: true,
            loading: false
        }
    }
    
    fn with_child(child: Box<dyn Component>) -> Self {
        Button {
            child: child,
            style: ButtonStyle.default(),
            on_pressed: None,
            enabled: true,
            loading: false
        }
    }
    
    fn on_press(handler: fn()) -> Self { self.on_pressed = Some(handler); self }
    fn style(style: ButtonStyle) -> Self { self.style = style; self }
    fn disabled() -> Self { self.enabled = false; self }
    fn loading(is_loading: Bool) -> Self { self.loading = is_loading; self }
}

struct ButtonStyle {
    background: RGBA
    foreground: RGBA
    hover_background: RGBA
    pressed_background: RGBA
    disabled_background: RGBA
    padding: EdgeInsets
    border: Option<Border>
    shadow: Option<Shadow>
    
    fn default() -> Self {
        ButtonStyle {
            background: RGBA.new(59, 130, 246, 1.0),
            foreground: RGBA.new(255, 255, 255, 1.0),
            hover_background: RGBA.new(37, 99, 235, 1.0),
            pressed_background: RGBA.new(29, 78, 216, 1.0),
            disabled_background: RGBA.new(156, 163, 175, 1.0),
            padding: EdgeInsets.symmetric(16.0, 8.0),
            border: None,
            shadow: None
        }
    }
    
    fn outlined() -> Self {
        ButtonStyle {
            background: RGBA.new(255, 255, 255, 0.0),
            foreground: RGBA.new(59, 130, 246, 1.0),
            hover_background: RGBA.new(59, 130, 246, 0.1),
            pressed_background: RGBA.new(59, 130, 246, 0.2),
            disabled_background: RGBA.new(255, 255, 255, 0.0),
            padding: EdgeInsets.symmetric(16.0, 8.0),
            border: Some(Border.new(1.0, RGBA.new(59, 130, 246, 1.0))),
            shadow: None
        }
    }
    
    fn text() -> Self {
        ButtonStyle {
            background: RGBA.new(255, 255, 255, 0.0),
            foreground: RGBA.new(59, 130, 246, 1.0),
            hover_background: RGBA.new(59, 130, 246, 0.1),
            pressed_background: RGBA.new(59, 130, 246, 0.2),
            disabled_background: RGBA.new(255, 255, 255, 0.0),
            padding: EdgeInsets.symmetric(8.0, 4.0),
            border: None,
            shadow: None
        }
    }
}

impl Component for Button {
    fn render(ctx: &mut RenderContext) {
        @native("button_render", ctx, self)
    }
    
    fn measure(constraints: Constraints) -> Size {
        let child_size = self.child.measure(constraints)
        Size {
            width: child_size.width + self.style.padding.horizontal(),
            height: child_size.height + self.style.padding.vertical()
        }
    }
    
    fn layout(bounds: Rect) {}
    fn id() -> Option<String> { None }
}

impl Interactive for Button {
    fn on_click(handler: fn()) { self.on_pressed = Some(handler) }
    fn on_hover(handler: fn(Bool)) { @native("button_on_hover", self, handler) }
    fn on_focus(handler: fn(Bool)) { @native("button_on_focus", self, handler) }
    fn is_enabled() -> Bool { self.enabled }
    fn set_enabled(enabled: Bool) { self.enabled = enabled }
}

/// Image component
struct ImageView {
    source: ImageSource
    fit: BoxFit
    alignment: Alignment
    placeholder: Option<Box<dyn Component>>
    error_widget: Option<Box<dyn Component>>
    
    fn network(url: String) -> Self {
        ImageView {
            source: ImageSource.Network(url),
            fit: BoxFit.Contain,
            alignment: Alignment.center(),
            placeholder: None,
            error_widget: None
        }
    }
    
    fn asset(path: String) -> Self {
        ImageView {
            source: ImageSource.Asset(path),
            fit: BoxFit.Contain,
            alignment: Alignment.center(),
            placeholder: None,
            error_widget: None
        }
    }
    
    fn fit(fit: BoxFit) -> Self { self.fit = fit; self }
    fn align(alignment: Alignment) -> Self { self.alignment = alignment; self }
    fn placeholder(widget: Box<dyn Component>) -> Self { self.placeholder = Some(widget); self }
}

enum ImageSource {
    Network(String),
    Asset(String),
    Memory([UInt8])
}

enum BoxFit { Fill, Contain, Cover, FitWidth, FitHeight, None, ScaleDown }

/// Icon component
struct Icon {
    name: String
    size: Float64
    color: RGBA
    
    fn new(name: String) -> Self {
        Icon { name: name, size: 24.0, color: RGBA.new(0, 0, 0, 1.0) }
    }
    
    fn size(size: Float64) -> Self { self.size = size; self }
    fn color(color: RGBA) -> Self { self.color = color; self }
}

impl Component for Icon {
    fn render(ctx: &mut RenderContext) {
        @native("icon_render", ctx, self.name, self.size, self.color)
    }
    
    fn measure(constraints: Constraints) -> Size {
        constraints.constrain(Size.new(self.size, self.size))
    }
    
    fn layout(bounds: Rect) {}
    fn id() -> Option<String> { None }
}

// -----------------------------------------------------------------------------
// Input Components
// -----------------------------------------------------------------------------

/// Text input field
struct TextField {
    value: String
    placeholder: String
    style: TextFieldStyle
    on_change: Option<fn(String)>
    on_submit: Option<fn(String)>
    obscure_text: Bool
    max_length: Option<Int>
    enabled: Bool
    autofocus: Bool
    
    fn new() -> Self {
        TextField {
            value: "",
            placeholder: "",
            style: TextFieldStyle.default(),
            on_change: None,
            on_submit: None,
            obscure_text: false,
            max_length: None,
            enabled: true,
            autofocus: false
        }
    }
    
    fn value(val: String) -> Self { self.value = val; self }
    fn placeholder(text: String) -> Self { self.placeholder = text; self }
    fn on_change(handler: fn(String)) -> Self { self.on_change = Some(handler); self }
    fn on_submit(handler: fn(String)) -> Self { self.on_submit = Some(handler); self }
    fn password() -> Self { self.obscure_text = true; self }
    fn max_length(len: Int) -> Self { self.max_length = Some(len); self }
    fn disabled() -> Self { self.enabled = false; self }
    fn autofocus() -> Self { self.autofocus = true; self }
}

struct TextFieldStyle {
    background: RGBA
    border: Border
    focused_border: Border
    error_border: Border
    padding: EdgeInsets
    text_style: TextStyle
    placeholder_color: RGBA
    
    fn default() -> Self {
        TextFieldStyle {
            background: RGBA.new(255, 255, 255, 1.0),
            border: Border.new(1.0, RGBA.new(209, 213, 219, 1.0)).with_radius(6.0),
            focused_border: Border.new(2.0, RGBA.new(59, 130, 246, 1.0)).with_radius(6.0),
            error_border: Border.new(2.0, RGBA.new(239, 68, 68, 1.0)).with_radius(6.0),
            padding: EdgeInsets.symmetric(12.0, 8.0),
            text_style: TextStyle.default(),
            placeholder_color: RGBA.new(156, 163, 175, 1.0)
        }
    }
}

/// Checkbox component
struct Checkbox {
    checked: Bool
    on_change: Option<fn(Bool)>
    label: Option<String>
    enabled: Bool
    indeterminate: Bool
    
    fn new(checked: Bool) -> Self {
        Checkbox { checked: checked, on_change: None, label: None, enabled: true, indeterminate: false }
    }
    
    fn on_change(handler: fn(Bool)) -> Self { self.on_change = Some(handler); self }
    fn label(text: String) -> Self { self.label = Some(text); self }
    fn disabled() -> Self { self.enabled = false; self }
    fn indeterminate() -> Self { self.indeterminate = true; self }
}

/// Radio button component
struct Radio<T> {
    value: T
    group_value: T
    on_change: Option<fn(T)>
    label: Option<String>
    enabled: Bool
    
    fn new(value: T, group_value: T) -> Self {
        Radio { value: value, group_value: group_value, on_change: None, label: None, enabled: true }
    }
    
    fn on_change(handler: fn(T)) -> Self { self.on_change = Some(handler); self }
    fn label(text: String) -> Self { self.label = Some(text); self }
    fn disabled() -> Self { self.enabled = false; self }
    fn is_selected() -> Bool { self.value == self.group_value }
}

/// Switch/Toggle component
struct Switch {
    value: Bool
    on_change: Option<fn(Bool)>
    enabled: Bool
    active_color: RGBA
    inactive_color: RGBA
    
    fn new(value: Bool) -> Self {
        Switch {
            value: value,
            on_change: None,
            enabled: true,
            active_color: RGBA.new(59, 130, 246, 1.0),
            inactive_color: RGBA.new(209, 213, 219, 1.0)
        }
    }
    
    fn on_change(handler: fn(Bool)) -> Self { self.on_change = Some(handler); self }
    fn disabled() -> Self { self.enabled = false; self }
    fn colors(active: RGBA, inactive: RGBA) -> Self {
        self.active_color = active
        self.inactive_color = inactive
        self
    }
}

/// Slider component
struct Slider {
    value: Float64
    min: Float64
    max: Float64
    step: Option<Float64>
    on_change: Option<fn(Float64)>
    enabled: Bool
    
    fn new(value: Float64, min: Float64, max: Float64) -> Self {
        Slider { value: value, min: min, max: max, step: None, on_change: None, enabled: true }
    }
    
    fn step(step: Float64) -> Self { self.step = Some(step); self }
    fn on_change(handler: fn(Float64)) -> Self { self.on_change = Some(handler); self }
    fn disabled() -> Self { self.enabled = false; self }
}

/// Dropdown/Select component
struct Dropdown<T> {
    value: Option<T>
    items: [DropdownItem<T>]
    on_change: Option<fn(T)>
    placeholder: String
    enabled: Bool
    
    fn new(items: [DropdownItem<T>]) -> Self {
        Dropdown { value: None, items: items, on_change: None, placeholder: "Select...", enabled: true }
    }
    
    fn value(val: T) -> Self { self.value = Some(val); self }
    fn on_change(handler: fn(T)) -> Self { self.on_change = Some(handler); self }
    fn placeholder(text: String) -> Self { self.placeholder = text; self }
    fn disabled() -> Self { self.enabled = false; self }
}

struct DropdownItem<T> {
    value: T
    label: String
    icon: Option<Icon>
    enabled: Bool
    
    fn new(value: T, label: String) -> Self {
        DropdownItem { value: value, label: label, icon: None, enabled: true }
    }
    
    fn with_icon(icon: Icon) -> Self { self.icon = Some(icon); self }
    fn disabled() -> Self { self.enabled = false; self }
}

// -----------------------------------------------------------------------------
// Container Components
// -----------------------------------------------------------------------------

/// Generic container with styling
struct Box {
    child: Option<Box<dyn Component>>
    padding: EdgeInsets
    margin: EdgeInsets
    background: Option<RGBA>
    border: Option<Border>
    shadow: Option<Shadow>
    width: Option<Float64>
    height: Option<Float64>
    
    fn new() -> Self {
        Box {
            child: None, padding: EdgeInsets.zero(), margin: EdgeInsets.zero(),
            background: None, border: None, shadow: None, width: None, height: None
        }
    }
    
    fn child(c: Box<dyn Component>) -> Self { self.child = Some(c); self }
    fn padding(p: EdgeInsets) -> Self { self.padding = p; self }
    fn margin(m: EdgeInsets) -> Self { self.margin = m; self }
    fn background(color: RGBA) -> Self { self.background = Some(color); self }
    fn border(b: Border) -> Self { self.border = Some(b); self }
    fn shadow(s: Shadow) -> Self { self.shadow = Some(s); self }
    fn size(w: Float64, h: Float64) -> Self { self.width = Some(w); self.height = Some(h); self }
}

/// Card component
struct Card {
    child: Box<dyn Component>
    elevation: Float64
    border_radius: BorderRadius
    background: RGBA
    padding: EdgeInsets
    
    fn new(child: Box<dyn Component>) -> Self {
        Card {
            child: child,
            elevation: 2.0,
            border_radius: BorderRadius.all(8.0),
            background: RGBA.new(255, 255, 255, 1.0),
            padding: EdgeInsets.all(16.0)
        }
    }
    
    fn elevation(e: Float64) -> Self { self.elevation = e; self }
    fn radius(r: Float64) -> Self { self.border_radius = BorderRadius.all(r); self }
    fn background(color: RGBA) -> Self { self.background = color; self }
    fn padding(p: EdgeInsets) -> Self { self.padding = p; self }
}

/// Scrollable container
struct ScrollView {
    child: Box<dyn Component>
    direction: ScrollDirection
    physics: ScrollPhysics
    controller: Option<ScrollController>
    
    fn new(child: Box<dyn Component>) -> Self {
        ScrollView {
            child: child,
            direction: ScrollDirection.Vertical,
            physics: ScrollPhysics.Bouncing,
            controller: None
        }
    }
    
    fn horizontal() -> Self { self.direction = ScrollDirection.Horizontal; self }
    fn physics(p: ScrollPhysics) -> Self { self.physics = p; self }
    fn controller(c: ScrollController) -> Self { self.controller = Some(c); self }
}

enum ScrollDirection { Vertical, Horizontal, Both }
enum ScrollPhysics { Bouncing, Clamping, NeverScrollable, AlwaysScrollable }

struct ScrollController {
    offset: Float64
    
    fn new() -> Self { ScrollController { offset: 0.0 } }
    fn scroll_to(offset: Float64) { self.offset = offset }
    fn animate_to(offset: Float64, duration: Float64) {
        @native("scroll_animate_to", self, offset, duration)
    }
}

// -----------------------------------------------------------------------------
// Alignment
// -----------------------------------------------------------------------------

struct Alignment {
    x: Float64
    y: Float64
    
    fn new(x: Float64, y: Float64) -> Self { Alignment { x: x, y: y } }
    fn top_left() -> Self { Alignment { x: -1.0, y: -1.0 } }
    fn top_center() -> Self { Alignment { x: 0.0, y: -1.0 } }
    fn top_right() -> Self { Alignment { x: 1.0, y: -1.0 } }
    fn center_left() -> Self { Alignment { x: -1.0, y: 0.0 } }
    fn center() -> Self { Alignment { x: 0.0, y: 0.0 } }
    fn center_right() -> Self { Alignment { x: 1.0, y: 0.0 } }
    fn bottom_left() -> Self { Alignment { x: -1.0, y: 1.0 } }
    fn bottom_center() -> Self { Alignment { x: 0.0, y: 1.0 } }
    fn bottom_right() -> Self { Alignment { x: 1.0, y: 1.0 } }
}

// -----------------------------------------------------------------------------
// Component State Management
// -----------------------------------------------------------------------------

/// State wrapper for reactive components
struct State<T> {
    value: T
    listeners: [fn(T)]
    
    fn new(initial: T) -> Self {
        State { value: initial, listeners: [] }
    }
    
    fn get() -> T { self.value }
    
    fn set(new_value: T) {
        self.value = new_value
        for listener in &self.listeners {
            listener(new_value)
        }
    }
    
    fn update(updater: fn(T) -> T) {
        self.set(updater(self.value))
    }
    
    fn listen(listener: fn(T)) {
        self.listeners.push(listener)
    }
}

/// Actor for managing component state
actor ComponentActor {
    state: Map<String, Any>
    
    fn new() -> Self {
        ComponentActor { state: Map.new() }
    }
    
    fn get_state(key: String) -> Option<Any> {
        self.state.get(&key)
    }
    
    fn set_state(key: String, value: Any) {
        self.state.insert(key, value)
    }
    
    fn remove_state(key: String) {
        self.state.remove(&key)
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "text component" {
    let text = Text.new("Hello, World!")
    assert_eq(text.content, "Hello, World!")?
}

test "button component" {
    let button = Button.new("Click me")
        .on_press(|| { println("Clicked!") })
    assert(button.enabled)?
}

test "text field" {
    let field = TextField.new()
        .placeholder("Enter text...")
        .max_length(100)
    assert_eq(field.placeholder, "Enter text...")?
    assert_eq(field.max_length, Some(100))?
}

test "constraints" {
    let constraints = Constraints.tight(100.0, 50.0)
    let size = constraints.constrain(Size.new(200.0, 100.0))
    assert_eq(size.width, 100.0)?
    assert_eq(size.height, 50.0)?
}

test "edge insets" {
    let insets = EdgeInsets.symmetric(10.0, 5.0)
    assert_eq(insets.horizontal(), 20.0)?
    assert_eq(insets.vertical(), 10.0)?
}

test "state management" {
    var state = State.new(0)
    state.set(42)
    assert_eq(state.get(), 42)?
    state.update(|v| v + 1)
    assert_eq(state.get(), 43)?
}
