// =============================================================================
// Vibee OS â€” AST Module
// Abstract Syntax Tree for Vibee Language
// =============================================================================

/// Source location for error reporting
struct Span {
    file: String
    start_line: Int
    start_col: Int
    end_line: Int
    end_col: Int
    
    fn new(file: String, sl: Int, sc: Int, el: Int, ec: Int) -> Self {
        Span { file: file, start_line: sl, start_col: sc, end_line: el, end_col: ec }
    }
    
    fn merge(other: Span) -> Span {
        Span {
            file: self.file,
            start_line: self.start_line.min(other.start_line),
            start_col: if self.start_line <= other.start_line { self.start_col } else { other.start_col },
            end_line: self.end_line.max(other.end_line),
            end_col: if self.end_line >= other.end_line { self.end_col } else { other.end_col }
        }
    }
    
    fn unknown() -> Self { Span { file: "<unknown>", start_line: 0, start_col: 0, end_line: 0, end_col: 0 } }
}

impl Display for Span {
    fn fmt(f: Formatter) { f.write(format!("{}:{}:{}", self.file, self.start_line, self.start_col)) }
}

/// Identifier with span
struct Identifier {
    name: String
    span: Span
}

impl Display for Identifier { fn fmt(f: Formatter) { f.write(self.name) } }

// =============================================================================
// Program Structure
// =============================================================================

struct Program { modules: [Module], span: Span }
struct Module { name: Identifier, items: [Item], imports: [Import], span: Span }
struct Import { path: [Identifier], alias: Option<Identifier>, items: Option<[ImportItem]>, span: Span }
struct ImportItem { name: Identifier, alias: Option<Identifier> }

// =============================================================================
// Items (Top-level declarations)
// =============================================================================

enum Item {
    Function(FunctionDef)
    Struct(StructDef)
    Enum(EnumDef)
    Trait(TraitDef)
    Impl(ImplBlock)
    Actor(ActorDef)
    Const(ConstDef)
    TypeAlias(TypeAliasDef)
    Test(TestDef)
}

enum Visibility { Public, Private, Crate }

// =============================================================================
// Type Definitions
// =============================================================================

struct FunctionDef {
    name: Identifier
    generics: Option<Generics>
    params: [Parameter]
    return_type: Option<Type>
    body: Option<Block>
    visibility: Visibility
    is_async: Bool
    attributes: [Attribute]
    span: Span
}

struct Parameter { name: Identifier, ty: Type, default: Option<Expr>, is_self: Bool, span: Span }

struct StructDef {
    name: Identifier
    generics: Option<Generics>
    fields: [Field]
    visibility: Visibility
    attributes: [Attribute]
    span: Span
}

struct Field { name: Identifier, ty: Type, default: Option<Expr>, visibility: Visibility, span: Span }

struct EnumDef {
    name: Identifier
    generics: Option<Generics>
    variants: [Variant]
    visibility: Visibility
    attributes: [Attribute]
    span: Span
}

struct Variant { name: Identifier, fields: VariantFields, span: Span }
enum VariantFields { Unit, Tuple([Type]), Struct([Field]) }

struct TraitDef {
    name: Identifier
    generics: Option<Generics>
    super_traits: [TypePath]
    items: [TraitItem]
    visibility: Visibility
    span: Span
}

enum TraitItem { Method(FunctionDef), Type(AssocType), Const(ConstDef) }
struct AssocType { name: Identifier, bounds: [TypePath], default: Option<Type>, span: Span }

struct ImplBlock {
    generics: Option<Generics>
    trait_ref: Option<TypePath>
    self_type: Type
    items: [ImplItem]
    span: Span
}

enum ImplItem { Method(FunctionDef), Type(TypeAliasDef), Const(ConstDef) }

struct ActorDef {
    name: Identifier
    generics: Option<Generics>
    state: [StateField]
    methods: [FunctionDef]
    visibility: Visibility
    attributes: [Attribute]
    span: Span
}

struct StateField { name: Identifier, ty: Type, default: Option<Expr>, span: Span }
struct ConstDef { name: Identifier, ty: Type, value: Expr, visibility: Visibility, span: Span }
struct TypeAliasDef { name: Identifier, generics: Option<Generics>, ty: Type, visibility: Visibility, span: Span }
struct TestDef { name: String, body: Block, span: Span }

// =============================================================================
// Generics
// =============================================================================

struct Generics { params: [GenericParam], span: Span }
enum GenericParam { Type(TypeParam), Const(ConstParam) }
struct TypeParam { name: Identifier, bounds: [TypePath], default: Option<Type>, span: Span }
struct ConstParam { name: Identifier, ty: Type, span: Span }

// =============================================================================
// Types
// =============================================================================

enum Type {
    Path(TypePath)
    Tuple([Type])
    Array(Box<Type>, Option<Expr>)
    Slice(Box<Type>)
    Reference(Box<Type>, Bool)
    Function(FnType)
    Impl([TypePath])
    Never
    Infer
}

struct TypePath { segments: [PathSegment], span: Span }
struct PathSegment { name: Identifier, generics: Option<GenericArgs>, span: Span }
struct GenericArgs { args: [GenericArg], span: Span }
enum GenericArg { Type(Type), Const(Expr), Binding(Identifier, Type) }
struct FnType { params: [Type], ret: Box<Type>, span: Span }

// =============================================================================
// Expressions
// =============================================================================

enum Expr {
    Literal(Literal)
    Path(TypePath)
    Binary(BinaryExpr)
    Unary(UnaryExpr)
    If(IfExpr)
    Match(MatchExpr)
    Loop(LoopExpr)
    While(WhileExpr)
    For(ForExpr)
    Block(Block)
    Call(CallExpr)
    MethodCall(MethodCallExpr)
    Closure(ClosureExpr)
    Field(FieldExpr)
    Index(IndexExpr)
    Struct(StructExpr)
    Tuple([Expr])
    Array(ArrayExpr)
    Reference(RefExpr)
    Deref(Box<Expr>)
    Cast(CastExpr)
    Await(Box<Expr>)
    Spawn(Box<Expr>)
    Return(Option<Box<Expr>>)
    Break(Option<Box<Expr>>)
    Continue
    Try(Box<Expr>)
    Range(RangeExpr)
    Assign(AssignExpr)
}

struct Literal { kind: LiteralKind, span: Span }
enum LiteralKind { Int(Int64), Float(Float64), String(String), Char(Char), Bool(Bool) }

struct BinaryExpr { left: Box<Expr>, op: BinaryOp, right: Box<Expr>, span: Span }
enum BinaryOp { Add, Sub, Mul, Div, Rem, BitAnd, BitOr, BitXor, Shl, Shr, And, Or, Eq, Ne, Lt, Le, Gt, Ge }

struct UnaryExpr { op: UnaryOp, expr: Box<Expr>, span: Span }
enum UnaryOp { Neg, Not, Deref, Ref, RefMut }

struct IfExpr { cond: Box<Expr>, then_branch: Block, else_branch: Option<Box<Expr>>, span: Span }
struct MatchExpr { scrutinee: Box<Expr>, arms: [MatchArm], span: Span }
struct MatchArm { pattern: Pattern, guard: Option<Expr>, body: Expr, span: Span }

struct LoopExpr { label: Option<Identifier>, body: Block, span: Span }
struct WhileExpr { label: Option<Identifier>, cond: Box<Expr>, body: Block, span: Span }
struct ForExpr { label: Option<Identifier>, pattern: Pattern, iter: Box<Expr>, body: Block, span: Span }

struct Block { stmts: [Statement], expr: Option<Box<Expr>>, span: Span }
struct CallExpr { callee: Box<Expr>, args: [Expr], span: Span }
struct MethodCallExpr { receiver: Box<Expr>, method: Identifier, args: [Expr], span: Span }
struct ClosureExpr { params: [ClosureParam], ret: Option<Type>, body: Box<Expr>, is_async: Bool, span: Span }
struct ClosureParam { pattern: Pattern, ty: Option<Type>, span: Span }

struct FieldExpr { base: Box<Expr>, field: Identifier, span: Span }
struct IndexExpr { base: Box<Expr>, index: Box<Expr>, span: Span }
struct StructExpr { path: TypePath, fields: [FieldInit], base: Option<Box<Expr>>, span: Span }
struct FieldInit { name: Identifier, value: Option<Expr>, span: Span }
struct ArrayExpr { kind: ArrayKind, span: Span }
enum ArrayKind { List([Expr]), Repeat(Box<Expr>, Box<Expr>) }
struct RefExpr { is_mut: Bool, expr: Box<Expr>, span: Span }
struct CastExpr { expr: Box<Expr>, ty: Type, span: Span }
struct RangeExpr { start: Option<Box<Expr>>, end: Option<Box<Expr>>, inclusive: Bool, span: Span }
struct AssignExpr { target: Box<Expr>, value: Box<Expr>, span: Span }

// =============================================================================
// Statements
// =============================================================================

enum Statement { Let(LetStmt), Expr(ExprStmt), Item(Item), Empty }
struct LetStmt { pattern: Pattern, ty: Option<Type>, init: Option<Expr>, is_mut: Bool, span: Span }
struct ExprStmt { expr: Expr, has_semi: Bool, span: Span }

// =============================================================================
// Patterns
// =============================================================================

enum Pattern {
    Wildcard(Span)
    Ident(IdentPattern)
    Literal(Literal)
    Tuple([Pattern])
    Struct(StructPattern)
    TupleStruct(TupleStructPattern)
    Path(TypePath)
    Ref(RefPattern)
    Or([Pattern])
}

struct IdentPattern { name: Identifier, is_mut: Bool, sub: Option<Box<Pattern>>, span: Span }
struct StructPattern { path: TypePath, fields: [FieldPattern], rest: Bool, span: Span }
struct FieldPattern { name: Identifier, pattern: Option<Pattern>, span: Span }
struct TupleStructPattern { path: TypePath, elems: [Pattern], span: Span }
struct RefPattern { is_mut: Bool, pattern: Box<Pattern>, span: Span }

// =============================================================================
// Attributes
// =============================================================================

struct Attribute { path: TypePath, args: Option<String>, span: Span }

// =============================================================================
// Visitor Pattern
// =============================================================================

trait Visitor {
    fn visit_program(p: Program)
    fn visit_item(i: Item)
    fn visit_expr(e: Expr)
    fn visit_stmt(s: Statement)
    fn visit_pattern(p: Pattern)
    fn visit_type(t: Type)
}

/// AST pretty printer
struct AstPrinter { buf: String, indent: Int }

impl AstPrinter {
    fn new() -> Self { AstPrinter { buf: "", indent: 0 } }
    fn print(program: Program) -> String { let p = Self.new(); p.visit_program(program); p.buf }
    fn writeln(s: String) { for _ in 0..self.indent { self.buf.push_str("  ") } self.buf.push_str(s); self.buf.push('\n') }
}

impl Visitor for AstPrinter {
    fn visit_program(p: Program) { self.writeln("Program"); self.indent += 1; for m in p.modules { for i in m.items { self.visit_item(i) } } }
    fn visit_item(i: Item) { match i { Item.Function(f) => self.writeln(format!("fn {}", f.name)), Item.Struct(s) => self.writeln(format!("struct {}", s.name)), Item.Enum(e) => self.writeln(format!("enum {}", e.name)), Item.Trait(t) => self.writeln(format!("trait {}", t.name)), Item.Actor(a) => self.writeln(format!("actor {}", a.name)), _ => {} } }
    fn visit_expr(e: Expr) {}
    fn visit_stmt(s: Statement) {}
    fn visit_pattern(p: Pattern) {}
    fn visit_type(t: Type) {}
}

// =============================================================================
// Tests
// =============================================================================

test "span merge" {
    let s1 = Span.new("test.vibee", 1, 1, 1, 10)
    let s2 = Span.new("test.vibee", 2, 5, 2, 15)
    let merged = s1.merge(s2)
    assert_eq(merged.start_line, 1)?
    assert_eq(merged.end_line, 2)?
}

test "identifier" {
    let id = Identifier { name: "test", span: Span.unknown() }
    assert_eq(id.name, "test")?
}
