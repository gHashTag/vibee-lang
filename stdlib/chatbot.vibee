// =============================================================================
// Vibee OS â€” Chatbot Module
// Universal chatbot with NLU, dialog management, and multi-platform support
// =============================================================================

use result::{Result, Ok, Err}
use json::{JsonValue, Serialize, Deserialize}

// =============================================================================
// Core Types
// =============================================================================

/// Intent recognized from user input
struct Intent {
    name: String,
    confidence: Float64,
    entities: [Entity]
}

impl Intent {
    fn new(name: String, confidence: Float64) -> Self {
        Intent { name: name, confidence: confidence, entities: [] }
    }
    
    fn with_entities(name: String, confidence: Float64, entities: [Entity]) -> Self {
        Intent { name: name, confidence: confidence, entities: entities }
    }
    
    fn is_confident(threshold: Float64) -> Bool {
        self.confidence >= threshold
    }
}

/// Entity extracted from user input
struct Entity {
    entity_type: String,
    value: String,
    start: Int,
    end: Int,
    confidence: Float64
}

impl Entity {
    fn new(entity_type: String, value: String) -> Self {
        Entity { entity_type: entity_type, value: value, start: 0, end: 0, confidence: 1.0 }
    }
    
    fn with_position(entity_type: String, value: String, start: Int, end: Int) -> Self {
        Entity { entity_type: entity_type, value: value, start: start, end: end, confidence: 1.0 }
    }
}

/// User message
struct UserMessage {
    text: String,
    user_id: String,
    channel_id: String,
    timestamp: Int64,
    metadata: Map<String, JsonValue>
}

impl UserMessage {
    fn new(text: String, user_id: String, channel_id: String) -> Self {
        UserMessage {
            text: text,
            user_id: user_id,
            channel_id: channel_id,
            timestamp: @native("timestamp_ms"),
            metadata: Map.new()
        }
    }
    
    fn with_metadata(text: String, user_id: String, channel_id: String, metadata: Map<String, JsonValue>) -> Self {
        UserMessage {
            text: text,
            user_id: user_id,
            channel_id: channel_id,
            timestamp: @native("timestamp_ms"),
            metadata: metadata
        }
    }
}

/// Bot response
struct BotResponse {
    text: String,
    quick_replies: [QuickReply],
    cards: [Card],
    actions: [ResponseAction],
    metadata: Map<String, JsonValue>
}

impl BotResponse {
    fn text(text: String) -> Self {
        BotResponse { text: text, quick_replies: [], cards: [], actions: [], metadata: Map.new() }
    }
    
    fn with_quick_replies(text: String, replies: [QuickReply]) -> Self {
        BotResponse { text: text, quick_replies: replies, cards: [], actions: [], metadata: Map.new() }
    }
    
    fn with_cards(text: String, cards: [Card]) -> Self {
        BotResponse { text: text, quick_replies: [], cards: cards, actions: [], metadata: Map.new() }
    }
    
    fn add_quick_reply(title: String, payload: String) -> Self {
        self.quick_replies.push(QuickReply { title: title, payload: payload });
        self
    }
    
    fn add_card(card: Card) -> Self {
        self.cards.push(card);
        self
    }
    
    fn add_action(action: ResponseAction) -> Self {
        self.actions.push(action);
        self
    }
}

/// Quick reply button
struct QuickReply {
    title: String,
    payload: String
}

/// Rich card
struct Card {
    title: String,
    subtitle: Option<String>,
    image_url: Option<String>,
    buttons: [CardButton]
}

impl Card {
    fn new(title: String) -> Self {
        Card { title: title, subtitle: None, image_url: None, buttons: [] }
    }
    
    fn subtitle(s: String) -> Self { self.subtitle = Some(s); self }
    fn image(url: String) -> Self { self.image_url = Some(url); self }
    fn button(title: String, action: String) -> Self { self.buttons.push(CardButton { title: title, action: action, url: None }); self }
    fn link_button(title: String, url: String) -> Self { self.buttons.push(CardButton { title: title, action: "link", url: Some(url) }); self }
}

struct CardButton {
    title: String,
    action: String,
    url: Option<String>
}

/// Response action
enum ResponseAction {
    Typing(Int),
    Delay(Int),
    HandoffToHuman(String),
    SetContext(String, JsonValue),
    ClearContext(String),
    TriggerEvent(String, JsonValue)
}

// =============================================================================
// Dialog Management
// =============================================================================

/// Conversation context
struct ConversationContext {
    user_id: String,
    session_id: String,
    current_state: String,
    slots: Map<String, JsonValue>,
    history: [DialogTurn],
    created_at: Int64,
    updated_at: Int64
}

impl ConversationContext {
    fn new(user_id: String) -> Self {
        let session_id = @native("uuid_v4");
        ConversationContext {
            user_id: user_id,
            session_id: session_id,
            current_state: "start",
            slots: Map.new(),
            history: [],
            created_at: @native("timestamp_ms"),
            updated_at: @native("timestamp_ms")
        }
    }
    
    fn get_slot<T: Deserialize>(name: String) -> Option<T> {
        self.slots.get(&name).and_then(|v| json::from_value(v.clone()).ok())
    }
    
    fn set_slot<T: Serialize>(name: String, value: T) {
        self.slots.insert(name, json::to_value(value));
        self.updated_at = @native("timestamp_ms");
    }
    
    fn clear_slot(name: String) {
        self.slots.remove(&name);
        self.updated_at = @native("timestamp_ms");
    }
    
    fn transition_to(state: String) {
        self.current_state = state;
        self.updated_at = @native("timestamp_ms");
    }
    
    fn add_turn(user_message: String, bot_response: String, intent: Option<Intent>) {
        self.history.push(DialogTurn {
            user_message: user_message,
            bot_response: bot_response,
            intent: intent,
            timestamp: @native("timestamp_ms")
        });
        self.updated_at = @native("timestamp_ms");
    }
    
    fn last_intent() -> Option<Intent> {
        self.history.last().and_then(|turn| turn.intent.clone())
    }
    
    fn is_expired(timeout_ms: Int64) -> Bool {
        @native("timestamp_ms") - self.updated_at > timeout_ms
    }
}

/// Dialog turn
struct DialogTurn {
    user_message: String,
    bot_response: String,
    intent: Option<Intent>,
    timestamp: Int64
}

/// Dialog state
struct DialogState {
    name: String,
    entry_action: Option<fn(ConversationContext) -> BotResponse>,
    handlers: Map<String, fn(ConversationContext, Intent) -> DialogTransition>,
    fallback: Option<fn(ConversationContext, String) -> BotResponse>
}

impl DialogState {
    fn new(name: String) -> Self {
        DialogState { name: name, entry_action: None, handlers: Map.new(), fallback: None }
    }
    
    fn on_enter(action: fn(ConversationContext) -> BotResponse) -> Self {
        self.entry_action = Some(action);
        self
    }
    
    fn on_intent(intent: String, handler: fn(ConversationContext, Intent) -> DialogTransition) -> Self {
        self.handlers.insert(intent, handler);
        self
    }
    
    fn on_fallback(handler: fn(ConversationContext, String) -> BotResponse) -> Self {
        self.fallback = Some(handler);
        self
    }
}

/// Dialog transition
struct DialogTransition {
    response: BotResponse,
    next_state: Option<String>
}

impl DialogTransition {
    fn respond(response: BotResponse) -> Self {
        DialogTransition { response: response, next_state: None }
    }
    
    fn respond_and_transition(response: BotResponse, next_state: String) -> Self {
        DialogTransition { response: response, next_state: Some(next_state) }
    }
    
    fn transition(next_state: String) -> Self {
        DialogTransition { response: BotResponse.text(""), next_state: Some(next_state) }
    }
}

// =============================================================================
// NLU (Natural Language Understanding)
// =============================================================================

/// NLU trait for intent recognition
trait NLUProvider {
    fn recognize(text: String) -> Result<Intent, NLUError>;
    fn extract_entities(text: String) -> Result<[Entity], NLUError>;
}

/// Simple pattern-based NLU
struct PatternNLU {
    patterns: Map<String, [String]>,
    entity_patterns: Map<String, String>
}

impl PatternNLU {
    fn new() -> Self {
        PatternNLU { patterns: Map.new(), entity_patterns: Map.new() }
    }
    
    fn add_intent(intent: String, patterns: [String]) -> Self {
        self.patterns.insert(intent, patterns);
        self
    }
    
    fn add_entity_pattern(entity_type: String, regex_pattern: String) -> Self {
        self.entity_patterns.insert(entity_type, regex_pattern);
        self
    }
}

impl NLUProvider for PatternNLU {
    fn recognize(text: String) -> Result<Intent, NLUError> {
        let text_lower = text.to_lower();
        let mut best_intent: Option<(String, Float64)> = None;
        
        for (intent, patterns) in self.patterns.iter() {
            for pattern in patterns.iter() {
                if text_lower.contains(pattern.to_lower()) {
                    let confidence = pattern.len() as Float64 / text.len() as Float64;
                    if best_intent.map(|(_, c)| confidence > c).unwrap_or(true) {
                        best_intent = Some((intent.clone(), confidence.min(1.0)));
                    }
                }
            }
        }
        
        best_intent
            .map(|(name, conf)| Intent.new(name, conf))
            .ok_or(NLUError.NoIntentMatched)
    }
    
    fn extract_entities(text: String) -> Result<[Entity], NLUError> {
        let mut entities = [];
        for (entity_type, pattern) in self.entity_patterns.iter() {
            let regex = Regex.new(pattern)?;
            for m in regex.find_all(text) {
                entities.push(Entity.with_position(entity_type.clone(), m.as_str().to_string(), m.start(), m.end()));
            }
        }
        Ok(entities)
    }
}

/// Keyword-based NLU
struct KeywordNLU {
    intents: Map<String, IntentDefinition>
}

struct IntentDefinition {
    keywords: [String],
    required_entities: [String],
    examples: [String]
}

impl KeywordNLU {
    fn new() -> Self { KeywordNLU { intents: Map.new() } }
    
    fn define_intent(name: String, keywords: [String]) -> Self {
        self.intents.insert(name, IntentDefinition { keywords: keywords, required_entities: [], examples: [] });
        self
    }
    
    fn with_examples(name: String, examples: [String]) -> Self {
        if let Some(def) = self.intents.get_mut(&name) {
            def.examples = examples;
        }
        self
    }
}

impl NLUProvider for KeywordNLU {
    fn recognize(text: String) -> Result<Intent, NLUError> {
        let text_lower = text.to_lower();
        let words: [String] = text_lower.split_whitespace().collect();
        let mut scores: Map<String, Float64> = Map.new();
        
        for (intent_name, def) in self.intents.iter() {
            let mut score = 0.0;
            for keyword in def.keywords.iter() {
                if words.contains(&keyword.to_lower()) {
                    score += 1.0;
                }
            }
            if score > 0.0 {
                scores.insert(intent_name.clone(), score / def.keywords.len() as Float64);
            }
        }
        
        scores.iter()
            .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(Ordering.Equal))
            .map(|(name, conf)| Intent.new(name.clone(), *conf))
            .ok_or(NLUError.NoIntentMatched)
    }
    
    fn extract_entities(text: String) -> Result<[Entity], NLUError> {
        Ok([])
    }
}

enum NLUError { NoIntentMatched, PatternError(String), ExtractionFailed }

// =============================================================================
// Chatbot Actor
// =============================================================================

/// Chatbot error
enum ChatbotError { NLUError(NLUError), StateNotFound(String), HandlerError(String) }

/// Universal Chatbot
actor Chatbot {
    state name: String
    state nlu: Box<dyn NLUProvider>
    state states: Map<String, DialogState>
    state contexts: Map<String, ConversationContext>
    state default_responses: DefaultResponses
    state confidence_threshold: Float64
    state session_timeout_ms: Int64
    state middleware: [fn(UserMessage, ConversationContext) -> Option<BotResponse>]
    state response_transformers: [fn(BotResponse) -> BotResponse]
    
    fn new(name: String) -> Self {
        Chatbot {
            name: name,
            nlu: Box.new(PatternNLU.new()),
            states: Map.new(),
            contexts: Map.new(),
            default_responses: DefaultResponses.default(),
            confidence_threshold: 0.5,
            session_timeout_ms: 30 * 60 * 1000, // 30 minutes
            middleware: [],
            response_transformers: []
        }
    }
    
    fn with_nlu<N: NLUProvider>(name: String, nlu: N) -> Self {
        let mut bot = Self.new(name);
        bot.nlu = Box.new(nlu);
        bot
    }
    
    fn set_confidence_threshold(threshold: Float64) -> Self {
        self.confidence_threshold = threshold;
        self
    }
    
    fn set_session_timeout(timeout_ms: Int64) -> Self {
        self.session_timeout_ms = timeout_ms;
        self
    }
    
    fn add_state(state: DialogState) -> Self {
        self.states.insert(state.name.clone(), state);
        self
    }
    
    fn set_default_responses(responses: DefaultResponses) -> Self {
        self.default_responses = responses;
        self
    }
    
    fn add_middleware(mw: fn(UserMessage, ConversationContext) -> Option<BotResponse>) -> Self {
        self.middleware.push(mw);
        self
    }
    
    fn add_response_transformer(transformer: fn(BotResponse) -> BotResponse) -> Self {
        self.response_transformers.push(transformer);
        self
    }
    
    fn get_or_create_context(user_id: String) -> ConversationContext {
        if let Some(ctx) = self.contexts.get(&user_id) {
            if !ctx.is_expired(self.session_timeout_ms) {
                return ctx.clone();
            }
        }
        let ctx = ConversationContext.new(user_id.clone());
        self.contexts.insert(user_id, ctx.clone());
        ctx
    }
    
    fn process_message(message: UserMessage) -> Result<BotResponse, ChatbotError> {
        let mut ctx = self.get_or_create_context(message.user_id.clone());
        
        // Run middleware
        for mw in self.middleware.iter() {
            if let Some(response) = mw(message.clone(), ctx.clone()) {
                return Ok(self.transform_response(response));
            }
        }
        
        // Recognize intent
        let intent = self.nlu.recognize(message.text.clone())
            .map_err(|e| ChatbotError.NLUError(e))?;
        
        // Extract entities
        if let Ok(entities) = self.nlu.extract_entities(message.text.clone()) {
            intent.entities = entities;
        }
        
        // Get current state
        let state = self.states.get(&ctx.current_state)
            .ok_or(ChatbotError.StateNotFound(ctx.current_state.clone()))?;
        
        // Handle intent
        let response = if intent.is_confident(self.confidence_threshold) {
            if let Some(handler) = state.handlers.get(&intent.name) {
                let transition = handler(ctx.clone(), intent.clone());
                if let Some(next_state) = transition.next_state {
                    ctx.transition_to(next_state.clone());
                    // Run entry action for new state
                    if let Some(new_state) = self.states.get(&next_state) {
                        if let Some(entry) = new_state.entry_action {
                            let entry_response = entry(ctx.clone());
                            // Combine responses
                            BotResponse {
                                text: format!("{}\n{}", transition.response.text, entry_response.text),
                                quick_replies: [transition.response.quick_replies, entry_response.quick_replies].concat(),
                                cards: [transition.response.cards, entry_response.cards].concat(),
                                actions: [transition.response.actions, entry_response.actions].concat(),
                                metadata: transition.response.metadata
                            }
                        } else {
                            transition.response
                        }
                    } else {
                        transition.response
                    }
                } else {
                    transition.response
                }
            } else if let Some(fallback) = state.fallback {
                fallback(ctx.clone(), message.text.clone())
            } else {
                BotResponse.text(self.default_responses.unknown_intent.clone())
            }
        } else {
            if let Some(fallback) = state.fallback {
                fallback(ctx.clone(), message.text.clone())
            } else {
                BotResponse.text(self.default_responses.low_confidence.clone())
            }
        };
        
        // Update context
        ctx.add_turn(message.text.clone(), response.text.clone(), Some(intent));
        self.contexts.insert(message.user_id.clone(), ctx);
        
        Ok(self.transform_response(response))
    }
    
    fn transform_response(response: BotResponse) -> BotResponse {
        let mut result = response;
        for transformer in self.response_transformers.iter() {
            result = transformer(result);
        }
        result
    }
    
    fn reset_context(user_id: String) {
        self.contexts.remove(&user_id);
    }
    
    fn get_context(user_id: String) -> Option<ConversationContext> {
        self.contexts.get(&user_id).cloned()
    }
}

/// Default responses
struct DefaultResponses {
    greeting: String,
    goodbye: String,
    unknown_intent: String,
    low_confidence: String,
    error: String
}

impl DefaultResponses {
    fn default() -> Self {
        DefaultResponses {
            greeting: "Hello! How can I help you?",
            goodbye: "Goodbye! Have a great day!",
            unknown_intent: "I'm not sure I understand. Could you rephrase that?",
            low_confidence: "I'm not quite sure what you mean. Can you be more specific?",
            error: "Sorry, something went wrong. Please try again."
        }
    }
}

// =============================================================================
// Chatbot Builder
// =============================================================================

/// Fluent builder for chatbot
struct ChatbotBuilder {
    name: String,
    nlu: Option<Box<dyn NLUProvider>>,
    states: [DialogState],
    intents: Map<String, [String]>,
    default_responses: Option<DefaultResponses>
}

impl ChatbotBuilder {
    fn new(name: String) -> Self {
        ChatbotBuilder {
            name: name,
            nlu: None,
            states: [],
            intents: Map.new(),
            default_responses: None
        }
    }
    
    fn with_pattern_nlu() -> Self {
        self.nlu = Some(Box.new(PatternNLU.new()));
        self
    }
    
    fn with_keyword_nlu() -> Self {
        self.nlu = Some(Box.new(KeywordNLU.new()));
        self
    }
    
    fn intent(name: String, patterns: [String]) -> Self {
        self.intents.insert(name, patterns);
        self
    }
    
    fn state(state: DialogState) -> Self {
        self.states.push(state);
        self
    }
    
    fn default_responses(responses: DefaultResponses) -> Self {
        self.default_responses = Some(responses);
        self
    }
    
    fn build() -> Chatbot {
        let mut nlu = PatternNLU.new();
        for (intent, patterns) in self.intents.iter() {
            nlu = nlu.add_intent(intent.clone(), patterns.clone());
        }
        
        let mut bot = Chatbot.with_nlu(self.name.clone(), nlu);
        for state in self.states.iter() {
            bot = bot.add_state(state.clone());
        }
        if let Some(responses) = self.default_responses {
            bot = bot.set_default_responses(responses);
        }
        bot
    }
}

// =============================================================================
// Tests
// =============================================================================

test "intent creation" {
    let intent = Intent.new("greeting", 0.95);
    assert_eq(intent.name, "greeting")?
    assert(intent.is_confident(0.9))?
    assert(!intent.is_confident(0.99))?
}

test "entity creation" {
    let entity = Entity.with_position("date", "tomorrow", 5, 13);
    assert_eq(entity.entity_type, "date")?
    assert_eq(entity.value, "tomorrow")?
}

test "bot response builder" {
    let response = BotResponse.text("Hello!")
        .add_quick_reply("Yes", "yes")
        .add_quick_reply("No", "no");
    assert_eq(response.text, "Hello!")?
    assert_eq(response.quick_replies.len(), 2)?
}

test "card builder" {
    let card = Card.new("Product")
        .subtitle("Description")
        .image("https://example.com/image.jpg")
        .button("Buy", "buy_action");
    assert_eq(card.title, "Product")?
    assert_eq(card.buttons.len(), 1)?
}

test "conversation context" {
    var ctx = ConversationContext.new("user123");
    ctx.set_slot("name", "John");
    ctx.transition_to("greeting");
    
    assert_eq(ctx.current_state, "greeting")?
    assert_eq(ctx.get_slot::<String>("name"), Some("John"))?
}

test "dialog transition" {
    let transition = DialogTransition.respond_and_transition(
        BotResponse.text("Moving on..."),
        "next_state"
    );
    assert_eq(transition.next_state, Some("next_state"))?
}

test "pattern nlu" {
    let nlu = PatternNLU.new()
        .add_intent("greeting", ["hello", "hi", "hey"])
        .add_intent("goodbye", ["bye", "goodbye", "see you"]);
    
    let intent = nlu.recognize("hello there").unwrap();
    assert_eq(intent.name, "greeting")?
}

test "keyword nlu" {
    let nlu = KeywordNLU.new()
        .define_intent("order", ["order", "buy", "purchase"])
        .define_intent("cancel", ["cancel", "stop", "abort"]);
    
    let intent = nlu.recognize("I want to order something").unwrap();
    assert_eq(intent.name, "order")?
}
