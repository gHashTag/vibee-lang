// =============================================================================
// Vibee OS â€” Attachment Module
// Email attachments with encoding, compression, and streaming support
// =============================================================================

use email.{Attachment as BaseAttachment}
use base64
use mimetype
use compress.{gzip_compress, gzip_decompress}
use crypto.{sha256_hash}

// =============================================================================
// Enhanced Attachment
// =============================================================================

/// Enhanced email attachment with metadata and processing
struct Attachment {
    filename: String
    content_type: String
    data: [UInt8]
    content_id: Option<String>
    disposition: AttachmentDisposition
    encoding: AttachmentEncoding
    size: Int64
    checksum: Option<String>
    metadata: Map<String, String>
}

enum AttachmentDisposition {
    Attachment   // Download as file
    Inline       // Display inline (images)
}

enum AttachmentEncoding {
    Base64
    QuotedPrintable
    Binary
    SevenBit
}

impl Attachment {
    fn new(filename: String, content_type: String, data: [UInt8]) -> Self {
        Attachment {
            filename: filename,
            content_type: content_type,
            data: data.clone(),
            content_id: None,
            disposition: AttachmentDisposition.Attachment,
            encoding: AttachmentEncoding.Base64,
            size: data.len() as Int64,
            checksum: None,
            metadata: Map.empty()
        }
    }
    
    /// Create from file path
    fn from_file(path: String) -> Result<Self, AttachmentError> {
        let data = @native("read_file_bytes", path).map_err(|e| AttachmentError.IoError(e))?
        let filename = path.split("/").last().unwrap_or(path.clone())
        let content_type = mimetype.from_path(path).map(|m| m.to_string()).unwrap_or("application/octet-stream")
        
        Ok(Self.new(filename, content_type, data))
    }
    
    /// Create from URL (download)
    fn from_url(url: String) -> Result<Self, AttachmentError> {
        let response = @native("http_get_bytes", url).map_err(|e| AttachmentError.DownloadError(e))?
        let filename = url.split("/").last().unwrap_or("download")
        let content_type = response.content_type.unwrap_or("application/octet-stream")
        
        Ok(Self.new(filename, content_type, response.data))
    }
    
    /// Create text attachment
    fn text(filename: String, content: String) -> Self {
        Self.new(filename, "text/plain; charset=utf-8", content.as_bytes())
    }
    
    /// Create HTML attachment
    fn html(filename: String, content: String) -> Self {
        Self.new(filename, "text/html; charset=utf-8", content.as_bytes())
    }
    
    /// Create JSON attachment
    fn json(filename: String, content: String) -> Self {
        Self.new(filename, "application/json", content.as_bytes())
    }
    
    /// Create CSV attachment
    fn csv(filename: String, content: String) -> Self {
        Self.new(filename, "text/csv", content.as_bytes())
    }
    
    /// Create PDF attachment
    fn pdf(filename: String, data: [UInt8]) -> Self {
        Self.new(filename, "application/pdf", data)
    }
    
    // Builder methods
    fn filename(name: String) -> Self { self.filename = name; self }
    fn content_type(ct: String) -> Self { self.content_type = ct; self }
    fn inline() -> Self { self.disposition = AttachmentDisposition.Inline; self }
    fn as_attachment() -> Self { self.disposition = AttachmentDisposition.Attachment; self }
    fn content_id(cid: String) -> Self { self.content_id = Some(cid); self }
    fn encoding(enc: AttachmentEncoding) -> Self { self.encoding = enc; self }
    fn meta(key: String, value: String) -> Self { self.metadata.set(key, value); self }
    
    /// Calculate and set checksum
    fn with_checksum() -> Self {
        self.checksum = Some(sha256_hash(self.data.clone()))
        self
    }
    
    /// Verify checksum
    fn verify_checksum() -> Bool {
        match self.checksum.clone() {
            Some(expected) => sha256_hash(self.data.clone()) == expected
            None => true
        }
    }
    
    /// Get base64 encoded data
    fn to_base64() -> String {
        base64.encode(self.data.clone())
    }
    
    /// Get data as string (if text)
    fn to_string() -> Result<String, AttachmentError> {
        String.from_utf8(self.data.clone()).map_err(|_| AttachmentError.EncodingError("Invalid UTF-8"))
    }
    
    /// Save to file
    fn save_to(path: String) -> Result<(), AttachmentError> {
        @native("write_file_bytes", path, self.data.clone()).map_err(|e| AttachmentError.IoError(e))
    }
    
    /// Check if image
    fn is_image() -> Bool {
        self.content_type.starts_with("image/")
    }
    
    /// Check if text-based
    fn is_text() -> Bool {
        self.content_type.starts_with("text/") || 
        self.content_type == "application/json" ||
        self.content_type == "application/xml"
    }
    
    /// Get file extension
    fn extension() -> Option<String> {
        self.filename.split(".").last().map(|s| s.to_lowercase())
    }
    
    /// Convert to base attachment
    fn to_base() -> BaseAttachment {
        BaseAttachment.new(self.filename.clone(), self.content_type.clone(), self.data.clone())
    }
}

// =============================================================================
// Attachment Builder
// =============================================================================

/// Fluent builder for creating attachments
struct AttachmentBuilder {
    filename: Option<String>
    content_type: Option<String>
    data: Option<[UInt8]>
    disposition: AttachmentDisposition
    content_id: Option<String>
    compress: Bool
    encrypt: Bool
}

impl AttachmentBuilder {
    fn new() -> Self {
        AttachmentBuilder {
            filename: None,
            content_type: None,
            data: None,
            disposition: AttachmentDisposition.Attachment,
            content_id: None,
            compress: false,
            encrypt: false
        }
    }
    
    fn filename(name: String) -> Self { self.filename = Some(name); self }
    fn content_type(ct: String) -> Self { self.content_type = Some(ct); self }
    fn data(d: [UInt8]) -> Self { self.data = Some(d); self }
    fn text(content: String) -> Self { self.data = Some(content.as_bytes()); self.content_type = Some("text/plain"); self }
    fn inline() -> Self { self.disposition = AttachmentDisposition.Inline; self }
    fn content_id(cid: String) -> Self { self.content_id = Some(cid); self }
    fn compress() -> Self { self.compress = true; self }
    
    fn from_file(path: String) -> Result<Self, AttachmentError> {
        let data = @native("read_file_bytes", path).map_err(|e| AttachmentError.IoError(e))?
        let filename = path.split("/").last().unwrap_or(path.clone())
        let content_type = mimetype.from_path(path).map(|m| m.to_string()).unwrap_or("application/octet-stream")
        
        Ok(Self.new().filename(filename).content_type(content_type).data(data))
    }
    
    fn build() -> Result<Attachment, AttachmentError> {
        let filename = self.filename.clone().ok_or(AttachmentError.ValidationError("Filename required"))?
        let content_type = self.content_type.clone().unwrap_or("application/octet-stream")
        var data = self.data.clone().ok_or(AttachmentError.ValidationError("Data required"))?
        
        if self.compress {
            data = gzip_compress(data).map_err(|e| AttachmentError.CompressionError(e))?
        }
        
        var attachment = Attachment.new(filename, content_type, data)
        attachment.disposition = self.disposition
        attachment.content_id = self.content_id.clone()
        
        Ok(attachment)
    }
}

// =============================================================================
// Inline Image
// =============================================================================

/// Helper for inline images in HTML emails
struct InlineImage {
    attachment: Attachment
    cid: String
}

impl InlineImage {
    fn new(filename: String, data: [UInt8]) -> Self {
        let content_type = mimetype.from_path(filename.clone()).map(|m| m.to_string()).unwrap_or("image/png")
        let cid = format!("img_{}", UUID.v4())
        
        let attachment = Attachment.new(filename, content_type, data)
            .inline()
            .content_id(cid.clone())
        
        InlineImage { attachment: attachment, cid: cid }
    }
    
    fn from_file(path: String) -> Result<Self, AttachmentError> {
        let attachment = Attachment.from_file(path)?
        let cid = format!("img_{}", UUID.v4())
        
        Ok(InlineImage {
            attachment: attachment.inline().content_id(cid.clone()),
            cid: cid
        })
    }
    
    /// Get HTML img tag
    fn html_tag() -> String {
        format!("<img src=\"cid:{}\" alt=\"{}\">", self.cid, self.attachment.filename)
    }
    
    /// Get HTML img tag with style
    fn html_tag_styled(style: String) -> String {
        format!("<img src=\"cid:{}\" alt=\"{}\" style=\"{}\">", self.cid, self.attachment.filename, style)
    }
    
    fn to_attachment() -> Attachment { self.attachment.clone() }
}

// =============================================================================
// Attachment Collection
// =============================================================================

/// Collection of attachments with utilities
struct AttachmentCollection {
    attachments: [Attachment]
    max_total_size: Int64
    allowed_types: Option<[String]>
}

impl AttachmentCollection {
    fn new() -> Self {
        AttachmentCollection {
            attachments: [],
            max_total_size: 25 * 1024 * 1024, // 25MB default
            allowed_types: None
        }
    }
    
    fn max_size(bytes: Int64) -> Self { self.max_total_size = bytes; self }
    fn allow_types(types: [String]) -> Self { self.allowed_types = Some(types); self }
    
    /// Add attachment with validation
    fn add(attachment: Attachment) -> Result<Self, AttachmentError> {
        // Check type
        if let Some(allowed) = self.allowed_types.clone() {
            if !allowed.iter().any(|t| attachment.content_type.starts_with(t)) {
                return Err(AttachmentError.TypeNotAllowed(attachment.content_type.clone()))
            }
        }
        
        // Check size
        let new_total = self.total_size() + attachment.size
        if new_total > self.max_total_size {
            return Err(AttachmentError.SizeLimitExceeded(new_total, self.max_total_size))
        }
        
        self.attachments.push(attachment)
        Ok(self)
    }
    
    /// Add from file
    fn add_file(path: String) -> Result<Self, AttachmentError> {
        let attachment = Attachment.from_file(path)?
        self.add(attachment)
    }
    
    /// Get total size
    fn total_size() -> Int64 {
        self.attachments.iter().map(|a| a.size).sum()
    }
    
    /// Get count
    fn count() -> Int { self.attachments.len() }
    
    /// Get by filename
    fn get(filename: String) -> Option<Attachment> {
        self.attachments.iter().find(|a| a.filename == filename).cloned()
    }
    
    /// Filter by type
    fn filter_by_type(content_type: String) -> [Attachment] {
        self.attachments.iter().filter(|a| a.content_type.starts_with(content_type)).cloned().collect()
    }
    
    /// Get images
    fn images() -> [Attachment] { self.filter_by_type("image/") }
    
    /// Get documents
    fn documents() -> [Attachment] {
        self.attachments.iter().filter(|a| 
            a.content_type == "application/pdf" ||
            a.content_type.contains("document") ||
            a.content_type.contains("spreadsheet")
        ).cloned().collect()
    }
    
    /// Convert to base attachments
    fn to_base() -> [BaseAttachment] {
        self.attachments.iter().map(|a| a.to_base()).collect()
    }
    
    fn iter() -> impl Iterator<Item = &Attachment> { self.attachments.iter() }
}

// =============================================================================
// Attachment Processor
// =============================================================================

/// Process attachments (resize, compress, convert)
struct AttachmentProcessor {}

impl AttachmentProcessor {
    /// Compress attachment if over size limit
    fn compress_if_needed(attachment: Attachment, max_size: Int64) -> Result<Attachment, AttachmentError> {
        if attachment.size <= max_size { return Ok(attachment) }
        
        let compressed = gzip_compress(attachment.data.clone())
            .map_err(|e| AttachmentError.CompressionError(e))?
        
        Ok(Attachment.new(
            format!("{}.gz", attachment.filename),
            "application/gzip",
            compressed
        ))
    }
    
    /// Resize image attachment
    fn resize_image(attachment: Attachment, max_width: Int, max_height: Int) -> Result<Attachment, AttachmentError> {
        if !attachment.is_image() {
            return Err(AttachmentError.ValidationError("Not an image"))
        }
        
        let resized = @native("image_resize", attachment.data.clone(), max_width, max_height)
            .map_err(|e| AttachmentError.ProcessingError(e))?
        
        Ok(Attachment.new(attachment.filename.clone(), attachment.content_type.clone(), resized))
    }
    
    /// Convert image format
    fn convert_image(attachment: Attachment, target_format: String) -> Result<Attachment, AttachmentError> {
        if !attachment.is_image() {
            return Err(AttachmentError.ValidationError("Not an image"))
        }
        
        let converted = @native("image_convert", attachment.data.clone(), target_format.clone())
            .map_err(|e| AttachmentError.ProcessingError(e))?
        
        let new_filename = attachment.filename.split(".").next().unwrap_or("image") + "." + target_format.clone()
        let content_type = format!("image/{}", target_format)
        
        Ok(Attachment.new(new_filename, content_type, converted))
    }
    
    /// Scan for viruses (requires external service)
    fn scan_virus(attachment: Attachment) -> Result<ScanResult, AttachmentError> {
        @native("virus_scan", attachment.data.clone())
            .map_err(|e| AttachmentError.ScanError(e))
    }
}

struct ScanResult {
    clean: Bool
    threats: [String]
    scanner: String
}

// =============================================================================
// MIME Helpers
// =============================================================================

/// Common MIME types
struct MimeTypes {}

impl MimeTypes {
    fn pdf() -> String { "application/pdf" }
    fn zip() -> String { "application/zip" }
    fn json() -> String { "application/json" }
    fn xml() -> String { "application/xml" }
    fn csv() -> String { "text/csv" }
    fn html() -> String { "text/html" }
    fn plain() -> String { "text/plain" }
    fn png() -> String { "image/png" }
    fn jpeg() -> String { "image/jpeg" }
    fn gif() -> String { "image/gif" }
    fn svg() -> String { "image/svg+xml" }
    fn mp3() -> String { "audio/mpeg" }
    fn mp4() -> String { "video/mp4" }
    fn doc() -> String { "application/msword" }
    fn docx() -> String { "application/vnd.openxmlformats-officedocument.wordprocessingml.document" }
    fn xls() -> String { "application/vnd.ms-excel" }
    fn xlsx() -> String { "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }
    fn ppt() -> String { "application/vnd.ms-powerpoint" }
    fn pptx() -> String { "application/vnd.openxmlformats-officedocument.presentationml.presentation" }
    
    fn from_extension(ext: String) -> String {
        match ext.to_lowercase().as_str() {
            "pdf" => Self.pdf()
            "zip" => Self.zip()
            "json" => Self.json()
            "xml" => Self.xml()
            "csv" => Self.csv()
            "html" | "htm" => Self.html()
            "txt" => Self.plain()
            "png" => Self.png()
            "jpg" | "jpeg" => Self.jpeg()
            "gif" => Self.gif()
            "svg" => Self.svg()
            "mp3" => Self.mp3()
            "mp4" => Self.mp4()
            "doc" => Self.doc()
            "docx" => Self.docx()
            "xls" => Self.xls()
            "xlsx" => Self.xlsx()
            "ppt" => Self.ppt()
            "pptx" => Self.pptx()
            _ => "application/octet-stream"
        }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum AttachmentError {
    IoError(String)
    DownloadError(String)
    EncodingError(String)
    ValidationError(String)
    SizeLimitExceeded(Int64, Int64)
    TypeNotAllowed(String)
    CompressionError(String)
    ProcessingError(String)
    ScanError(String)
}

impl Display for AttachmentError {
    fn fmt(f: Formatter) {
        match self {
            IoError(e) => f.write(format!("IO error: {}", e))
            DownloadError(e) => f.write(format!("Download error: {}", e))
            EncodingError(e) => f.write(format!("Encoding error: {}", e))
            ValidationError(e) => f.write(format!("Validation error: {}", e))
            SizeLimitExceeded(actual, max) => f.write(format!("Size {} exceeds limit {}", actual, max))
            TypeNotAllowed(t) => f.write(format!("Type not allowed: {}", t))
            CompressionError(e) => f.write(format!("Compression error: {}", e))
            ProcessingError(e) => f.write(format!("Processing error: {}", e))
            ScanError(e) => f.write(format!("Scan error: {}", e))
        }
    }
}

impl Error for AttachmentError {}

// =============================================================================
// Tests
// =============================================================================

test "attachment creation" {
    let attachment = Attachment.new("test.txt", "text/plain", "Hello".as_bytes())
    assert_eq(attachment.filename, "test.txt")?
    assert_eq(attachment.content_type, "text/plain")?
    assert_eq(attachment.size, 5)?
}

test "attachment text" {
    let attachment = Attachment.text("readme.txt", "Hello World")
    assert_eq(attachment.content_type, "text/plain; charset=utf-8")?
    assert_eq(attachment.to_string()?, "Hello World")?
}

test "attachment builder" {
    let attachment = AttachmentBuilder.new()
        .filename("data.json")
        .content_type("application/json")
        .text("{\"key\": \"value\"}")
        .build()?
    
    assert_eq(attachment.filename, "data.json")?
}

test "inline image" {
    let img = InlineImage.new("logo.png", [0x89, 0x50, 0x4E, 0x47])
    assert(img.html_tag().contains("cid:"))?
    assert(img.attachment.disposition == AttachmentDisposition.Inline)?
}

test "attachment collection" {
    var collection = AttachmentCollection.new().max_size(1024 * 1024)
    collection = collection.add(Attachment.text("a.txt", "Hello"))?
    collection = collection.add(Attachment.text("b.txt", "World"))?
    
    assert_eq(collection.count(), 2)?
}

test "mime types" {
    assert_eq(MimeTypes.from_extension("pdf"), "application/pdf")?
    assert_eq(MimeTypes.from_extension("PNG"), "image/png")?
}

test "attachment checksum" {
    let attachment = Attachment.text("test.txt", "Hello").with_checksum()
    assert(attachment.checksum.is_some())?
    assert(attachment.verify_checksum())?
}
