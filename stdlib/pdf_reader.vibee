// =============================================================================
// Vibee OS â€” PDF Reader Module
// Reading and extracting content from PDF documents
// =============================================================================

use fs::{File, IoError}
use image::{Image, ImageFormat}

// =============================================================================
// PDF Document
// =============================================================================

/// PDF document for reading
struct PdfDocument {
    handle: @native("PdfDocumentHandle")
    path: Option<String>
    metadata: PdfMetadata
    page_count: Int
}

impl PdfDocument {
    /// Open PDF from file path
    fn open(path: String) -> Result<Self, PdfError> {
        let handle = @native("pdf_open", path)?
        let metadata = @native("pdf_get_metadata", handle)?
        let page_count = @native("pdf_page_count", handle)?
        Ok(PdfDocument { handle: handle, path: Some(path), metadata: metadata, page_count: page_count })
    }
    
    /// Open PDF from bytes
    fn from_bytes(data: [UInt8]) -> Result<Self, PdfError> {
        let handle = @native("pdf_from_bytes", data)?
        let metadata = @native("pdf_get_metadata", handle)?
        let page_count = @native("pdf_page_count", handle)?
        Ok(PdfDocument { handle: handle, path: None, metadata: metadata, page_count: page_count })
    }
    
    /// Open password-protected PDF
    fn open_encrypted(path: String, password: String) -> Result<Self, PdfError> {
        let handle = @native("pdf_open_encrypted", path, password)?
        let metadata = @native("pdf_get_metadata", handle)?
        let page_count = @native("pdf_page_count", handle)?
        Ok(PdfDocument { handle: handle, path: Some(path), metadata: metadata, page_count: page_count })
    }
    
    /// Get page by index (0-based)
    fn page(index: Int) -> Result<PdfPage, PdfError> {
        if index < 0 || index >= self.page_count { return Err(PdfError.PageNotFound(index)) }
        let page_handle = @native("pdf_get_page", self.handle, index)?
        Ok(PdfPage { handle: page_handle, index: index })
    }
    
    /// Get all pages iterator
    fn pages() -> PdfPageIterator { PdfPageIterator { document: self, current: 0 } }
    
    /// Extract all text from document
    fn extract_text() -> Result<String, PdfError> {
        let mut text = String.new()
        for i in 0..self.page_count {
            let page = self.page(i)?
            text.push_str(page.extract_text()?)
            text.push('\n')
        }
        Ok(text)
    }
    
    /// Get document outline (bookmarks/TOC)
    fn outline() -> Result<[PdfOutlineItem], PdfError> { @native("pdf_get_outline", self.handle) }
    
    /// Get all embedded images
    fn images() -> Result<[PdfImage], PdfError> { @native("pdf_get_images", self.handle) }
    
    /// Search text in document
    fn search(query: String) -> Result<[PdfSearchResult], PdfError> {
        @native("pdf_search", self.handle, query, SearchOptions.default())
    }
    
    /// Check if document is encrypted
    fn is_encrypted() -> Bool { @native("pdf_is_encrypted", self.handle) }
    
    /// Get PDF version
    fn version() -> PdfVersion { @native("pdf_get_version", self.handle) }
    
    /// Close document
    fn close() { @native("pdf_close", self.handle) }
}

impl Drop for PdfDocument { fn drop() { self.close() } }

// =============================================================================
// PDF Page
// =============================================================================

struct PdfPage {
    handle: @native("PdfPageHandle")
    index: Int
}

impl PdfPage {
    fn width() -> Float64 { @native("pdf_page_width", self.handle) }
    fn height() -> Float64 { @native("pdf_page_height", self.handle) }
    fn size() -> PdfPageSize { PdfPageSize { width: self.width(), height: self.height() } }
    fn rotation() -> Int { @native("pdf_page_rotation", self.handle) }
    fn extract_text() -> Result<String, PdfError> { @native("pdf_page_extract_text", self.handle) }
    fn extract_text_blocks() -> Result<[TextBlock], PdfError> { @native("pdf_page_extract_text_blocks", self.handle) }
    fn annotations() -> Result<[PdfAnnotation], PdfError> { @native("pdf_page_annotations", self.handle) }
    fn links() -> Result<[PdfLink], PdfError> { @native("pdf_page_links", self.handle) }
    fn images() -> Result<[PdfImage], PdfError> { @native("pdf_page_images", self.handle) }
    fn render(dpi: Float64) -> Result<Image, PdfError> { @native("pdf_page_render", self.handle, dpi) }
    fn media_box() -> PdfRect { @native("pdf_page_media_box", self.handle) }
    fn crop_box() -> PdfRect { @native("pdf_page_crop_box", self.handle) }
}

struct PdfPageIterator { document: PdfDocument, current: Int }
impl Iterator for PdfPageIterator {
    type Item = Result<PdfPage, PdfError>
    fn next() -> Option<Self.Item> {
        if self.current >= self.document.page_count { return None }
        let page = self.document.page(self.current)
        self.current += 1
        Some(page)
    }
}

// =============================================================================
// PDF Metadata
// =============================================================================

struct PdfMetadata {
    title: Option<String>
    author: Option<String>
    subject: Option<String>
    keywords: Option<String>
    creator: Option<String>
    producer: Option<String>
    creation_date: Option<DateTime>
    modification_date: Option<DateTime>
}

// =============================================================================
// PDF Elements
// =============================================================================

struct PdfRect { x: Float64, y: Float64, width: Float64, height: Float64 }
impl PdfRect {
    fn new(x: Float64, y: Float64, w: Float64, h: Float64) -> Self { PdfRect { x: x, y: y, width: w, height: h } }
    fn contains(px: Float64, py: Float64) -> Bool {
        px >= self.x && px <= self.x + self.width && py >= self.y && py <= self.y + self.height
    }
}

struct PdfPageSize { width: Float64, height: Float64 }
impl PdfPageSize {
    fn a4() -> Self { PdfPageSize { width: 595.0, height: 842.0 } }
    fn letter() -> Self { PdfPageSize { width: 612.0, height: 792.0 } }
    fn legal() -> Self { PdfPageSize { width: 612.0, height: 1008.0 } }
}

struct PdfColor { r: Float64, g: Float64, b: Float64, a: Float64 }
impl PdfColor {
    fn rgb(r: Float64, g: Float64, b: Float64) -> Self { PdfColor { r: r, g: g, b: b, a: 1.0 } }
    fn black() -> Self { Self.rgb(0.0, 0.0, 0.0) }
    fn white() -> Self { Self.rgb(1.0, 1.0, 1.0) }
}

struct TextBlock { text: String, rect: PdfRect, font_name: Option<String>, font_size: Float64 }

// =============================================================================
// Annotations and Links
// =============================================================================

struct PdfAnnotation {
    annotation_type: AnnotationType
    rect: PdfRect
    contents: Option<String>
    page_index: Int
}

enum AnnotationType { Text, Link, FreeText, Highlight, Underline, StrikeOut, Stamp, Ink, Unknown(String) }

struct PdfLink { rect: PdfRect, destination: LinkDestination, page_index: Int }
enum LinkDestination { Page(Int), Uri(String), Named(String), External(String, Int), Unknown }

struct PdfOutlineItem { title: String, destination: Option<Int>, children: [PdfOutlineItem], is_open: Bool }

// =============================================================================
// Images
// =============================================================================

struct PdfImage { index: Int, width: Int, height: Int, page_index: Int, rect: PdfRect }
impl PdfImage {
    fn extract() -> Result<Image, PdfError> { @native("pdf_image_extract", self) }
    fn save(path: String, format: ImageFormat) -> Result<(), PdfError> {
        let img = self.extract()?
        img.save(path, format)?
        Ok(())
    }
}

// =============================================================================
// Search
// =============================================================================

struct SearchOptions { case_sensitive: Bool, whole_word: Bool, regex: Bool }
impl SearchOptions {
    fn default() -> Self { SearchOptions { case_sensitive: false, whole_word: false, regex: false } }
}

struct PdfSearchResult { page_index: Int, text: String, rect: PdfRect, context: String }

// =============================================================================
// PDF Version
// =============================================================================

enum PdfVersion { V1_0, V1_1, V1_2, V1_3, V1_4, V1_5, V1_6, V1_7, V2_0, Unknown(String) }

// =============================================================================
// Convenience Functions
// =============================================================================

fn open(path: String) -> Result<PdfDocument, PdfError> { PdfDocument.open(path) }
fn extract_text(path: String) -> Result<String, PdfError> { PdfDocument.open(path)?.extract_text() }
fn page_count(path: String) -> Result<Int, PdfError> { Ok(PdfDocument.open(path)?.page_count) }
fn render_page(path: String, page: Int, dpi: Float64) -> Result<Image, PdfError> {
    PdfDocument.open(path)?.page(page)?.render(dpi)
}

// =============================================================================
// Errors
// =============================================================================

enum PdfError {
    FileNotFound(String), InvalidPdf, PasswordRequired, InvalidPassword,
    PageNotFound(Int), CorruptedData, UnsupportedFeature(String), IoError(IoError), Other(String)
}

impl Display for PdfError {
    fn fmt(f: Formatter) {
        match self {
            FileNotFound(p) => { f.write("File not found: "); f.write(p) }
            InvalidPdf => f.write("Invalid PDF")
            PasswordRequired => f.write("Password required")
            PageNotFound(i) => { f.write("Page not found: "); f.write(i.to_string()) }
            Other(m) => f.write(m)
            _ => f.write("PDF error")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "open pdf" {
    let doc = PdfDocument.open("test.pdf")?
    assert(doc.page_count > 0)?
}

test "extract text" {
    let doc = PdfDocument.open("test.pdf")?
    let text = doc.extract_text()?
    assert(!text.is_empty())?
}

test "pdf rect" {
    let rect = PdfRect.new(0.0, 0.0, 100.0, 100.0)
    assert(rect.contains(50.0, 50.0))?
    assert(!rect.contains(150.0, 50.0))?
}
