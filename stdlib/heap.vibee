// =============================================================================
// Vibee OS â€” Heap Module
// Binary heap / priority queue
// =============================================================================

/// Min-heap (smallest element first)
struct MinHeap<T: Ord> {
    data: [T]
    
    fn new() -> Self { MinHeap { data: [] } }
    fn from(items: [T]) -> Self {
        var h = MinHeap { data: items }
        h.heapify()
        h
    }
    
    fn push(item: T) {
        self.data.push(item)
        self.sift_up(self.data.len() - 1)
    }
    
    fn pop() -> Option<T> {
        if self.is_empty() { return None }
        let result = self.data[0]
        let last = self.data.pop().unwrap()
        if !self.is_empty() {
            self.data[0] = last
            self.sift_down(0)
        }
        Some(result)
    }
    
    fn peek() -> Option<T> { self.data.first().cloned() }
    fn len() -> Int { self.data.len() }
    fn is_empty() -> Bool { self.data.is_empty() }
    fn clear() { self.data.clear() }
    
    fn sift_up(idx: Int) {
        var i = idx
        while i > 0 {
            let parent = (i - 1) / 2
            if self.data[i] >= self.data[parent] { break }
            self.data.swap(i, parent)
            i = parent
        }
    }
    
    fn sift_down(idx: Int) {
        var i = idx
        let len = self.data.len()
        loop {
            let left = 2 * i + 1
            let right = 2 * i + 2
            var smallest = i
            if left < len && self.data[left] < self.data[smallest] { smallest = left }
            if right < len && self.data[right] < self.data[smallest] { smallest = right }
            if smallest == i { break }
            self.data.swap(i, smallest)
            i = smallest
        }
    }
    
    fn heapify() {
        for i in (0..self.data.len() / 2).rev() { self.sift_down(i) }
    }
}

/// Max-heap (largest element first)
struct MaxHeap<T: Ord> {
    data: [T]
    
    fn new() -> Self { MaxHeap { data: [] } }
    fn from(items: [T]) -> Self {
        var h = MaxHeap { data: items }
        h.heapify()
        h
    }
    
    fn push(item: T) {
        self.data.push(item)
        self.sift_up(self.data.len() - 1)
    }
    
    fn pop() -> Option<T> {
        if self.is_empty() { return None }
        let result = self.data[0]
        let last = self.data.pop().unwrap()
        if !self.is_empty() {
            self.data[0] = last
            self.sift_down(0)
        }
        Some(result)
    }
    
    fn peek() -> Option<T> { self.data.first().cloned() }
    fn len() -> Int { self.data.len() }
    fn is_empty() -> Bool { self.data.is_empty() }
    
    fn sift_up(idx: Int) {
        var i = idx
        while i > 0 {
            let parent = (i - 1) / 2
            if self.data[i] <= self.data[parent] { break }
            self.data.swap(i, parent)
            i = parent
        }
    }
    
    fn sift_down(idx: Int) {
        var i = idx
        let len = self.data.len()
        loop {
            let left = 2 * i + 1
            let right = 2 * i + 2
            var largest = i
            if left < len && self.data[left] > self.data[largest] { largest = left }
            if right < len && self.data[right] > self.data[largest] { largest = right }
            if largest == i { break }
            self.data.swap(i, largest)
            i = largest
        }
    }
    
    fn heapify() {
        for i in (0..self.data.len() / 2).rev() { self.sift_down(i) }
    }
}

/// Priority queue with custom priority
struct PriorityQueue<T, P: Ord> {
    heap: MinHeap<(P, Int, T)>
    counter: Int
    
    fn new() -> Self { PriorityQueue { heap: MinHeap.new(), counter: 0 } }
    
    fn push(item: T, priority: P) {
        self.heap.push((priority, self.counter, item))
        self.counter += 1
    }
    
    fn pop() -> Option<T> { self.heap.pop().map(|(_, _, item)| item) }
    fn peek() -> Option<T> { self.heap.peek().map(|(_, _, item)| item.clone()) }
    fn len() -> Int { self.heap.len() }
    fn is_empty() -> Bool { self.heap.is_empty() }
}

// Heap sort
fn heap_sort<T: Ord>(items: [T]) -> [T] {
    var heap = MinHeap.from(items)
    var result = []
    while let Some(item) = heap.pop() { result.push(item) }
    result
}

// Tests
test "min heap" {
    var h = MinHeap::<Int>.new()
    h.push(3); h.push(1); h.push(2)
    assert_eq(h.pop(), Some(1))?
    assert_eq(h.pop(), Some(2))?
    assert_eq(h.pop(), Some(3))?
}

test "max heap" {
    var h = MaxHeap::<Int>.new()
    h.push(1); h.push(3); h.push(2)
    assert_eq(h.pop(), Some(3))?
    assert_eq(h.pop(), Some(2))?
}

test "heap sort" {
    assert_eq(heap_sort([3, 1, 4, 1, 5, 9, 2, 6]), [1, 1, 2, 3, 4, 5, 6, 9])?
}
