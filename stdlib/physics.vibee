// =============================================================================
// Vibee OS — Physics Module
// Physical constants, formulas, and 2D physics engine for games
// =============================================================================

use vector::{Vec2, Vec3}
use math::{PI, abs, min, max, sqrt, clamp, pow, sin, cos, exp, ln}

// =============================================================================
// PART 1: Physical Constants and Formulas
// =============================================================================

// -----------------------------------------------------------------------------
// Fundamental Physical Constants (SI Units)
// -----------------------------------------------------------------------------

/// Speed of light in vacuum (m/s)
const SPEED_OF_LIGHT: Float = 299792458.0
const C: Float = 299792458.0

/// Planck constant (J·s)
const PLANCK_CONSTANT: Float = 6.62607015e-34
const H: Float = 6.62607015e-34

/// Reduced Planck constant ℏ = h/(2π) (J·s)
const HBAR: Float = 1.054571817e-34

/// Gravitational constant (m³/(kg·s²))
const GRAVITATIONAL_CONSTANT: Float = 6.67430e-11
const G_CONST: Float = 6.67430e-11

/// Elementary charge (C)
const ELEMENTARY_CHARGE: Float = 1.602176634e-19
const E_CHARGE: Float = 1.602176634e-19

/// Electron mass (kg)
const ELECTRON_MASS: Float = 9.1093837015e-31

/// Proton mass (kg)
const PROTON_MASS: Float = 1.67262192369e-27

/// Neutron mass (kg)
const NEUTRON_MASS: Float = 1.67492749804e-27

/// Atomic mass unit (kg)
const ATOMIC_MASS_UNIT: Float = 1.66053906660e-27

/// Boltzmann constant (J/K)
const BOLTZMANN_CONSTANT: Float = 1.380649e-23
const K_B: Float = 1.380649e-23

/// Avogadro constant (mol⁻¹)
const AVOGADRO_CONSTANT: Float = 6.02214076e23

/// Gas constant (J/(mol·K))
const GAS_CONSTANT: Float = 8.314462618

/// Vacuum permittivity ε₀ (F/m)
const VACUUM_PERMITTIVITY: Float = 8.8541878128e-12
const EPSILON_0: Float = 8.8541878128e-12

/// Vacuum permeability μ₀ (H/m)
const VACUUM_PERMEABILITY: Float = 1.25663706212e-6
const MU_0: Float = 1.25663706212e-6

/// Fine structure constant α
const FINE_STRUCTURE: Float = 7.2973525693e-3

/// Stefan-Boltzmann constant (W/(m²·K⁴))
const STEFAN_BOLTZMANN: Float = 5.670374419e-8

/// Wien displacement constant (m·K)
const WIEN_CONSTANT: Float = 2.897771955e-3

/// Rydberg constant (m⁻¹)
const RYDBERG_CONSTANT: Float = 1.0973731568160e7

/// Bohr radius (m)
const BOHR_RADIUS: Float = 5.29177210903e-11

/// Standard gravity (m/s²)
const STANDARD_GRAVITY: Float = 9.80665

/// Standard atmosphere (Pa)
const STANDARD_ATMOSPHERE: Float = 101325.0

// -----------------------------------------------------------------------------
// Classical Mechanics
// -----------------------------------------------------------------------------

/// Kinetic energy: KE = ½mv²
fn kinetic_energy(mass: Float, velocity: Float) -> Float {
    0.5 * mass * velocity * velocity
}

/// Potential energy (gravitational): PE = mgh
fn potential_energy_gravity(mass: Float, height: Float, g: Float = STANDARD_GRAVITY) -> Float {
    mass * g * height
}

/// Momentum: p = mv
fn momentum(mass: Float, velocity: Float) -> Float {
    mass * velocity
}

/// Force from acceleration: F = ma
fn force_from_acceleration(mass: Float, acceleration: Float) -> Float {
    mass * acceleration
}

/// Work: W = F·d·cos(θ)
fn work(force: Float, distance: Float, angle: Float = 0.0) -> Float {
    force * distance * cos(angle)
}

/// Power: P = W/t = F·v
fn power_from_work(work: Float, time: Float) -> Float {
    work / time
}

fn power_from_force(force: Float, velocity: Float) -> Float {
    force * velocity
}

/// Centripetal acceleration: a = v²/r
fn centripetal_acceleration(velocity: Float, radius: Float) -> Float {
    velocity * velocity / radius
}

/// Centripetal force: F = mv²/r
fn centripetal_force(mass: Float, velocity: Float, radius: Float) -> Float {
    mass * velocity * velocity / radius
}

/// Angular velocity: ω = v/r
fn angular_velocity(velocity: Float, radius: Float) -> Float {
    velocity / radius
}

/// Period of circular motion: T = 2πr/v
fn circular_period(radius: Float, velocity: Float) -> Float {
    2.0 * PI * radius / velocity
}

/// Torque: τ = r × F = rF·sin(θ)
fn torque(radius: Float, force: Float, angle: Float = PI / 2.0) -> Float {
    radius * force * sin(angle)
}

/// Moment of inertia (point mass): I = mr²
fn moment_of_inertia_point(mass: Float, radius: Float) -> Float {
    mass * radius * radius
}

/// Rotational kinetic energy: KE = ½Iω²
fn rotational_kinetic_energy(moment_of_inertia: Float, angular_velocity: Float) -> Float {
    0.5 * moment_of_inertia * angular_velocity * angular_velocity
}

/// Angular momentum: L = Iω
fn angular_momentum(moment_of_inertia: Float, angular_velocity: Float) -> Float {
    moment_of_inertia * angular_velocity
}

// -----------------------------------------------------------------------------
// Gravitation
// -----------------------------------------------------------------------------

/// Gravitational force: F = GMm/r²
fn gravitational_force(m1: Float, m2: Float, distance: Float) -> Float {
    G_CONST * m1 * m2 / (distance * distance)
}

/// Gravitational potential energy: U = -GMm/r
fn gravitational_potential_energy(m1: Float, m2: Float, distance: Float) -> Float {
    -G_CONST * m1 * m2 / distance
}

/// Escape velocity: v = √(2GM/r)
fn escape_velocity(mass: Float, radius: Float) -> Float {
    sqrt(2.0 * G_CONST * mass / radius)
}

/// Orbital velocity (circular): v = √(GM/r)
fn orbital_velocity(central_mass: Float, radius: Float) -> Float {
    sqrt(G_CONST * central_mass / radius)
}

/// Orbital period: T = 2π√(r³/GM)
fn orbital_period(central_mass: Float, semi_major_axis: Float) -> Float {
    2.0 * PI * sqrt(pow(semi_major_axis, 3.0) / (G_CONST * central_mass))
}

/// Schwarzschild radius: r_s = 2GM/c²
fn schwarzschild_radius(mass: Float) -> Float {
    2.0 * G_CONST * mass / (C * C)
}

// -----------------------------------------------------------------------------
// Oscillations and Waves
// -----------------------------------------------------------------------------

/// Simple harmonic motion period: T = 2π√(m/k)
fn shm_period(mass: Float, spring_constant: Float) -> Float {
    2.0 * PI * sqrt(mass / spring_constant)
}

/// Pendulum period: T = 2π√(L/g)
fn pendulum_period(length: Float, g: Float = STANDARD_GRAVITY) -> Float {
    2.0 * PI * sqrt(length / g)
}

/// Wave velocity: v = fλ
fn wave_velocity(frequency: Float, wavelength: Float) -> Float {
    frequency * wavelength
}

/// Wave frequency: f = 1/T
fn wave_frequency(period: Float) -> Float {
    1.0 / period
}

/// Doppler effect (approaching): f' = f(v + v_observer)/(v - v_source)
fn doppler_approaching(f: Float, v_wave: Float, v_observer: Float, v_source: Float) -> Float {
    f * (v_wave + v_observer) / (v_wave - v_source)
}

/// Doppler effect (receding): f' = f(v - v_observer)/(v + v_source)
fn doppler_receding(f: Float, v_wave: Float, v_observer: Float, v_source: Float) -> Float {
    f * (v_wave - v_observer) / (v_wave + v_source)
}

// -----------------------------------------------------------------------------
// Thermodynamics
// -----------------------------------------------------------------------------

/// Ideal gas law: PV = nRT
fn ideal_gas_pressure(n: Float, v: Float, t: Float) -> Float {
    n * GAS_CONSTANT * t / v
}

fn ideal_gas_volume(n: Float, p: Float, t: Float) -> Float {
    n * GAS_CONSTANT * t / p
}

/// Kinetic theory: KE_avg = (3/2)kT
fn average_kinetic_energy(temperature: Float) -> Float {
    1.5 * K_B * temperature
}

/// RMS speed of gas molecules: v_rms = √(3kT/m)
fn rms_speed(temperature: Float, molecular_mass: Float) -> Float {
    sqrt(3.0 * K_B * temperature / molecular_mass)
}

/// Heat transfer: Q = mcΔT
fn heat_transfer(mass: Float, specific_heat: Float, delta_t: Float) -> Float {
    mass * specific_heat * delta_t
}

/// Thermal expansion: ΔL = αL₀ΔT
fn thermal_expansion(original_length: Float, coefficient: Float, delta_t: Float) -> Float {
    coefficient * original_length * delta_t
}

/// Stefan-Boltzmann law: P = εσAT⁴
fn blackbody_power(emissivity: Float, area: Float, temperature: Float) -> Float {
    emissivity * STEFAN_BOLTZMANN * area * pow(temperature, 4.0)
}

/// Wien's displacement law: λ_max = b/T
fn peak_wavelength(temperature: Float) -> Float {
    WIEN_CONSTANT / temperature
}

/// Carnot efficiency: η = 1 - T_cold/T_hot
fn carnot_efficiency(t_hot: Float, t_cold: Float) -> Float {
    1.0 - t_cold / t_hot
}

// -----------------------------------------------------------------------------
// Electromagnetism
// -----------------------------------------------------------------------------

/// Coulomb's law: F = kq₁q₂/r²
fn coulomb_force(q1: Float, q2: Float, distance: Float) -> Float {
    let k = 1.0 / (4.0 * PI * EPSILON_0)
    k * q1 * q2 / (distance * distance)
}

/// Electric field: E = kq/r²
fn electric_field(charge: Float, distance: Float) -> Float {
    let k = 1.0 / (4.0 * PI * EPSILON_0)
    k * charge / (distance * distance)
}

/// Electric potential: V = kq/r
fn electric_potential(charge: Float, distance: Float) -> Float {
    let k = 1.0 / (4.0 * PI * EPSILON_0)
    k * charge / distance
}

/// Capacitance (parallel plate): C = ε₀A/d
fn capacitance_parallel_plate(area: Float, separation: Float) -> Float {
    EPSILON_0 * area / separation
}

/// Energy stored in capacitor: U = ½CV²
fn capacitor_energy(capacitance: Float, voltage: Float) -> Float {
    0.5 * capacitance * voltage * voltage
}

/// Ohm's law: V = IR
fn ohms_law_voltage(current: Float, resistance: Float) -> Float {
    current * resistance
}

fn ohms_law_current(voltage: Float, resistance: Float) -> Float {
    voltage / resistance
}

/// Power dissipation: P = IV = I²R = V²/R
fn electrical_power(current: Float, voltage: Float) -> Float {
    current * voltage
}

/// Magnetic force on moving charge: F = qvB·sin(θ)
fn lorentz_force(charge: Float, velocity: Float, magnetic_field: Float, angle: Float = PI / 2.0) -> Float {
    charge * velocity * magnetic_field * sin(angle)
}

/// Magnetic field from wire: B = μ₀I/(2πr)
fn magnetic_field_wire(current: Float, distance: Float) -> Float {
    MU_0 * current / (2.0 * PI * distance)
}

/// Inductance energy: U = ½LI²
fn inductor_energy(inductance: Float, current: Float) -> Float {
    0.5 * inductance * current * current
}

/// Electromagnetic wave speed: c = 1/√(ε₀μ₀)
fn em_wave_speed() -> Float {
    1.0 / sqrt(EPSILON_0 * MU_0)
}

// -----------------------------------------------------------------------------
// Optics
// -----------------------------------------------------------------------------

/// Snell's law: n₁sin(θ₁) = n₂sin(θ₂)
fn snells_law(n1: Float, theta1: Float, n2: Float) -> Float {
    let sin_theta2 = n1 * sin(theta1) / n2
    if sin_theta2 > 1.0 { return -1.0 }  // Total internal reflection
    asin(sin_theta2)
}

fn asin(x: Float) -> Float { @native("math_asin", x) }

/// Critical angle for total internal reflection
fn critical_angle(n1: Float, n2: Float) -> Float {
    if n1 <= n2 { return -1.0 }  // No total internal reflection
    asin(n2 / n1)
}

/// Thin lens equation: 1/f = 1/d_o + 1/d_i
fn lens_image_distance(focal_length: Float, object_distance: Float) -> Float {
    1.0 / (1.0 / focal_length - 1.0 / object_distance)
}

/// Magnification: M = -d_i/d_o
fn magnification(image_distance: Float, object_distance: Float) -> Float {
    -image_distance / object_distance
}

/// Diffraction grating: d·sin(θ) = mλ
fn diffraction_angle(grating_spacing: Float, wavelength: Float, order: Int) -> Float {
    let sin_theta = order as Float * wavelength / grating_spacing
    if sin_theta > 1.0 { return -1.0 }
    asin(sin_theta)
}

// -----------------------------------------------------------------------------
// Quantum Mechanics
// -----------------------------------------------------------------------------

/// Photon energy: E = hf = hc/λ
fn photon_energy_frequency(frequency: Float) -> Float {
    H * frequency
}

fn photon_energy_wavelength(wavelength: Float) -> Float {
    H * C / wavelength
}

/// de Broglie wavelength: λ = h/p = h/(mv)
fn de_broglie_wavelength(mass: Float, velocity: Float) -> Float {
    H / (mass * velocity)
}

/// Heisenberg uncertainty: ΔxΔp ≥ ℏ/2
fn heisenberg_min_uncertainty_position(momentum_uncertainty: Float) -> Float {
    HBAR / (2.0 * momentum_uncertainty)
}

fn heisenberg_min_uncertainty_momentum(position_uncertainty: Float) -> Float {
    HBAR / (2.0 * position_uncertainty)
}

/// Bohr model energy levels: E_n = -13.6 eV / n²
fn hydrogen_energy_level(n: Int) -> Float {
    -13.6 * E_CHARGE / (n * n) as Float
}

/// Bohr radius for hydrogen: r_n = n²a₀
fn hydrogen_orbital_radius(n: Int) -> Float {
    (n * n) as Float * BOHR_RADIUS
}

// -----------------------------------------------------------------------------
// Relativity
// -----------------------------------------------------------------------------

/// Lorentz factor: γ = 1/√(1 - v²/c²)
fn lorentz_factor(velocity: Float) -> Float {
    1.0 / sqrt(1.0 - (velocity * velocity) / (C * C))
}

/// Time dilation: Δt' = γΔt
fn time_dilation(proper_time: Float, velocity: Float) -> Float {
    lorentz_factor(velocity) * proper_time
}

/// Length contraction: L' = L/γ
fn length_contraction(proper_length: Float, velocity: Float) -> Float {
    proper_length / lorentz_factor(velocity)
}

/// Relativistic mass: m' = γm
fn relativistic_mass(rest_mass: Float, velocity: Float) -> Float {
    lorentz_factor(velocity) * rest_mass
}

/// Relativistic kinetic energy: KE = (γ - 1)mc²
fn relativistic_kinetic_energy(rest_mass: Float, velocity: Float) -> Float {
    (lorentz_factor(velocity) - 1.0) * rest_mass * C * C
}

/// Mass-energy equivalence: E = mc²
fn mass_energy(mass: Float) -> Float {
    mass * C * C
}

/// Relativistic momentum: p = γmv
fn relativistic_momentum(rest_mass: Float, velocity: Float) -> Float {
    lorentz_factor(velocity) * rest_mass * velocity
}

// -----------------------------------------------------------------------------
// Nuclear Physics
// -----------------------------------------------------------------------------

/// Binding energy: E = Δm·c²
fn binding_energy(mass_defect: Float) -> Float {
    mass_defect * C * C
}

/// Radioactive decay: N(t) = N₀·e^(-λt)
fn radioactive_decay(initial: Float, decay_constant: Float, time: Float) -> Float {
    initial * exp(-decay_constant * time)
}

/// Half-life: t½ = ln(2)/λ
fn half_life(decay_constant: Float) -> Float {
    ln(2.0) / decay_constant
}

/// Decay constant from half-life
fn decay_constant(half_life: Float) -> Float {
    ln(2.0) / half_life
}

/// Activity: A = λN
fn activity(decay_constant: Float, number_of_atoms: Float) -> Float {
    decay_constant * number_of_atoms
}

// =============================================================================
// PART 2: 2D Physics Engine for Games
// =============================================================================

// -----------------------------------------------------------------------------
// Rigid Body
// -----------------------------------------------------------------------------

enum BodyType { Static, Dynamic, Kinematic }

struct RigidBody2D {
    position: Vec2
    velocity: Vec2
    acceleration: Vec2
    rotation: Float
    angular_velocity: Float
    mass: Float
    inv_mass: Float
    restitution: Float
    friction: Float
    body_type: BodyType
    
    fn new(pos: Vec2, mass: Float) -> Self {
        RigidBody2D {
            position: pos, velocity: Vec2.zero(), acceleration: Vec2.zero(),
            rotation: 0.0, angular_velocity: 0.0,
            mass: mass, inv_mass: if mass > 0.0 { 1.0 / mass } else { 0.0 },
            restitution: 0.5, friction: 0.3, body_type: BodyType.Dynamic
        }
    }
    
    fn static_body(pos: Vec2) -> Self {
        var body = RigidBody2D.new(pos, 0.0)
        body.body_type = BodyType.Static
        body
    }
    
    fn apply_force(force: Vec2) {
        if self.body_type == BodyType.Dynamic {
            self.acceleration = self.acceleration + force * self.inv_mass
        }
    }
    
    fn apply_impulse(impulse: Vec2) {
        if self.body_type == BodyType.Dynamic {
            self.velocity = self.velocity + impulse * self.inv_mass
        }
    }
    
    fn integrate(dt: Float) {
        if self.body_type != BodyType.Dynamic { return }
        self.velocity = self.velocity + self.acceleration * dt
        self.position = self.position + self.velocity * dt
        self.rotation += self.angular_velocity * dt
        self.acceleration = Vec2.zero()
    }
}

// -----------------------------------------------------------------------------
// Colliders
// -----------------------------------------------------------------------------

enum Collider2D {
    Circle { radius: Float },
    Box { half_width: Float, half_height: Float },
    Polygon { vertices: [Vec2] }
}

impl Collider2D {
    fn circle(r: Float) -> Self { Collider2D.Circle { radius: r } }
    fn box_collider(w: Float, h: Float) -> Self { Collider2D.Box { half_width: w/2.0, half_height: h/2.0 } }
    
    fn get_aabb(pos: Vec2) -> AABB {
        match self {
            Circle { radius } => AABB.new(pos - Vec2.new(radius, radius), pos + Vec2.new(radius, radius)),
            Box { half_width, half_height } => AABB.new(
                pos - Vec2.new(half_width, half_height),
                pos + Vec2.new(half_width, half_height)
            ),
            Polygon { vertices } => {
                var min_p = vertices[0]
                var max_p = vertices[0]
                for v in vertices { min_p = min_p.min(v); max_p = max_p.max(v) }
                AABB.new(pos + min_p, pos + max_p)
            }
        }
    }
}

struct AABB {
    min: Vec2
    max: Vec2
    
    fn new(min: Vec2, max: Vec2) -> Self { AABB { min: min, max: max } }
    
    fn intersects(other: AABB) -> Bool {
        self.max.x >= other.min.x && self.min.x <= other.max.x &&
        self.max.y >= other.min.y && self.min.y <= other.max.y
    }
    
    fn contains(point: Vec2) -> Bool {
        point.x >= self.min.x && point.x <= self.max.x &&
        point.y >= self.min.y && point.y <= self.max.y
    }
}

// -----------------------------------------------------------------------------
// Collision Detection
// -----------------------------------------------------------------------------

struct Contact {
    point: Vec2
    normal: Vec2
    penetration: Float
}

fn circle_vs_circle(p1: Vec2, r1: Float, p2: Vec2, r2: Float) -> Option<Contact> {
    let diff = p2 - p1
    let dist_sq = diff.length_squared()
    let radius_sum = r1 + r2
    
    if dist_sq >= radius_sum * radius_sum { return None }
    
    let dist = dist_sq.sqrt()
    let normal = if dist > 0.0001 { diff / dist } else { Vec2.new(1.0, 0.0) }
    
    Some(Contact {
        point: p1 + normal * r1,
        normal: normal,
        penetration: radius_sum - dist
    })
}

fn box_vs_box(p1: Vec2, hw1: Float, hh1: Float, p2: Vec2, hw2: Float, hh2: Float) -> Option<Contact> {
    let diff = p2 - p1
    let overlap_x = hw1 + hw2 - abs(diff.x)
    let overlap_y = hh1 + hh2 - abs(diff.y)
    
    if overlap_x <= 0.0 || overlap_y <= 0.0 { return None }
    
    if overlap_x < overlap_y {
        let sign = if diff.x < 0.0 { -1.0 } else { 1.0 }
        Some(Contact { point: p1 + Vec2.new(hw1 * sign, 0.0), normal: Vec2.new(sign, 0.0), penetration: overlap_x })
    } else {
        let sign = if diff.y < 0.0 { -1.0 } else { 1.0 }
        Some(Contact { point: p1 + Vec2.new(0.0, hh1 * sign), normal: Vec2.new(0.0, sign), penetration: overlap_y })
    }
}

fn circle_vs_box(cp: Vec2, r: Float, bp: Vec2, hw: Float, hh: Float) -> Option<Contact> {
    let diff = cp - bp
    let closest = Vec2.new(clamp(diff.x, -hw, hw), clamp(diff.y, -hh, hh))
    let to_circle = diff - closest
    let dist_sq = to_circle.length_squared()
    
    if dist_sq >= r * r { return None }
    
    let dist = dist_sq.sqrt()
    let normal = if dist > 0.0001 { to_circle / dist } else { Vec2.new(1.0, 0.0) }
    
    Some(Contact { point: bp + closest, normal: normal, penetration: r - dist })
}

// -----------------------------------------------------------------------------
// Physics World
// -----------------------------------------------------------------------------

struct PhysicsWorld2D {
    bodies: [RigidBody2D]
    colliders: [Collider2D]
    gravity: Vec2
    iterations: Int
    
    fn new() -> Self {
        PhysicsWorld2D { bodies: [], colliders: [], gravity: Vec2.new(0.0, -9.81), iterations: 8 }
    }
    
    fn add_body(body: RigidBody2D, collider: Collider2D) -> Int {
        self.bodies.push(body)
        self.colliders.push(collider)
        self.bodies.len() - 1
    }
    
    fn step(dt: Float) {
        // Apply gravity
        for body in self.bodies.iter_mut() {
            if body.body_type == BodyType.Dynamic {
                body.apply_force(self.gravity * body.mass)
            }
        }
        
        // Integrate
        for body in self.bodies.iter_mut() { body.integrate(dt) }
        
        // Collision detection and resolution
        for _ in 0..self.iterations {
            for i in 0..self.bodies.len() {
                for j in (i+1)..self.bodies.len() {
                    if let Some(contact) = self.check_collision(i, j) {
                        self.resolve_collision(i, j, contact)
                    }
                }
            }
        }
    }
    
    fn check_collision(i: Int, j: Int) -> Option<Contact> {
        let p1 = self.bodies[i].position
        let p2 = self.bodies[j].position
        
        match (&self.colliders[i], &self.colliders[j]) {
            (Circle { radius: r1 }, Circle { radius: r2 }) => circle_vs_circle(p1, *r1, p2, *r2),
            (Box { half_width: hw1, half_height: hh1 }, Box { half_width: hw2, half_height: hh2 }) => 
                box_vs_box(p1, *hw1, *hh1, p2, *hw2, *hh2),
            (Circle { radius }, Box { half_width, half_height }) => 
                circle_vs_box(p1, *radius, p2, *half_width, *half_height),
            (Box { half_width, half_height }, Circle { radius }) => 
                circle_vs_box(p2, *radius, p1, *half_width, *half_height).map(|c| Contact { normal: -c.normal, ..c }),
            _ => None
        }
    }
    
    fn resolve_collision(i: Int, j: Int, contact: Contact) {
        let a = &mut self.bodies[i]
        let b = &mut self.bodies[j]
        
        let rel_vel = b.velocity - a.velocity
        let vel_along_normal = rel_vel.dot(contact.normal)
        if vel_along_normal > 0.0 { return }
        
        let e = min(a.restitution, b.restitution)
        let inv_mass_sum = a.inv_mass + b.inv_mass
        if inv_mass_sum == 0.0 { return }
        
        let j_scalar = -(1.0 + e) * vel_along_normal / inv_mass_sum
        let impulse = contact.normal * j_scalar
        
        a.velocity = a.velocity - impulse * a.inv_mass
        b.velocity = b.velocity + impulse * b.inv_mass
        
        // Position correction
        let correction = contact.normal * (contact.penetration / inv_mass_sum * 0.8)
        a.position = a.position - correction * a.inv_mass
        b.position = b.position + correction * b.inv_mass
    }
}

// -----------------------------------------------------------------------------
// Raycasting
// -----------------------------------------------------------------------------

struct RayHit {
    point: Vec2
    normal: Vec2
    distance: Float
    body_index: Int
}

impl PhysicsWorld2D {
    fn raycast(origin: Vec2, direction: Vec2, max_dist: Float) -> Option<RayHit> {
        var closest: Option<RayHit> = None
        let dir = direction.normalize()
        
        for i in 0..self.bodies.len() {
            if let Some(hit) = self.ray_vs_collider(origin, dir, max_dist, i) {
                if closest.is_none() || hit.distance < closest.unwrap().distance {
                    closest = Some(hit)
                }
            }
        }
        closest
    }
    
    fn ray_vs_collider(origin: Vec2, dir: Vec2, max_dist: Float, idx: Int) -> Option<RayHit> {
        let pos = self.bodies[idx].position
        
        match &self.colliders[idx] {
            Circle { radius } => {
                let oc = origin - pos
                let a = dir.dot(dir)
                let b = 2.0 * oc.dot(dir)
                let c = oc.dot(oc) - radius * radius
                let disc = b * b - 4.0 * a * c
                
                if disc < 0.0 { return None }
                
                let t = (-b - disc.sqrt()) / (2.0 * a)
                if t < 0.0 || t > max_dist { return None }
                
                let point = origin + dir * t
                Some(RayHit { point: point, normal: (point - pos).normalize(), distance: t, body_index: idx })
            },
            Box { half_width, half_height } => {
                let min_p = pos - Vec2.new(*half_width, *half_height)
                let max_p = pos + Vec2.new(*half_width, *half_height)
                
                var tmin = (min_p.x - origin.x) / dir.x
                var tmax = (max_p.x - origin.x) / dir.x
                if tmin > tmax { let tmp = tmin; tmin = tmax; tmax = tmp }
                
                var tymin = (min_p.y - origin.y) / dir.y
                var tymax = (max_p.y - origin.y) / dir.y
                if tymin > tymax { let tmp = tymin; tymin = tymax; tymax = tmp }
                
                if tmin > tymax || tymin > tmax { return None }
                
                let t = max(tmin, tymin)
                if t < 0.0 || t > max_dist { return None }
                
                let point = origin + dir * t
                let normal = if tmin > tymin {
                    Vec2.new(if dir.x < 0.0 { 1.0 } else { -1.0 }, 0.0)
                } else {
                    Vec2.new(0.0, if dir.y < 0.0 { 1.0 } else { -1.0 })
                }
                Some(RayHit { point: point, normal: normal, distance: t, body_index: idx })
            },
            _ => None
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "circle collision" {
    let c = circle_vs_circle(Vec2.zero(), 1.0, Vec2.new(1.5, 0.0), 1.0)
    assert(c.is_some())?
    assert(c.unwrap().penetration > 0.0)?
}

test "physics step" {
    var world = PhysicsWorld2D.new()
    world.add_body(RigidBody2D.new(Vec2.new(0.0, 10.0), 1.0), Collider2D.circle(1.0))
    world.step(0.016)
    assert(world.bodies[0].position.y < 10.0)?
}

// -----------------------------------------------------------------------------
// Tests for Physical Formulas
// -----------------------------------------------------------------------------

test "kinetic energy" {
    let ke = kinetic_energy(2.0, 3.0)
    assert((ke - 9.0).abs() < 0.001)?
}

test "gravitational force" {
    // Earth-Moon system (approximate)
    let f = gravitational_force(5.97e24, 7.35e22, 3.84e8)
    assert(f > 1e20)?
}

test "escape velocity earth" {
    let v = escape_velocity(5.97e24, 6.371e6)
    assert((v - 11186.0).abs() < 100.0)?
}

test "lorentz factor" {
    let gamma = lorentz_factor(0.0)
    assert((gamma - 1.0).abs() < 0.001)?
    
    let gamma_half_c = lorentz_factor(C * 0.5)
    assert((gamma_half_c - 1.1547).abs() < 0.001)?
}

test "photon energy" {
    // Visible light ~500nm
    let e = photon_energy_wavelength(500e-9)
    assert(e > 3e-19 && e < 4e-19)?
}

test "ideal gas" {
    // 1 mol at STP
    let v = ideal_gas_volume(1.0, STANDARD_ATMOSPHERE, 273.15)
    assert((v - 0.0224).abs() < 0.001)?
}

test "coulomb force" {
    // Two electrons at 1nm
    let f = coulomb_force(E_CHARGE, E_CHARGE, 1e-9)
    assert(f > 2e-10)?
}

test "carnot efficiency" {
    let eff = carnot_efficiency(500.0, 300.0)
    assert((eff - 0.4).abs() < 0.001)?
}

test "half life" {
    let lambda = decay_constant(5730.0 * 365.25 * 24.0 * 3600.0)  // C-14
    let t_half = half_life(lambda)
    assert((t_half - 5730.0 * 365.25 * 24.0 * 3600.0).abs() < 1.0)?
}
