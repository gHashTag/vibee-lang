// =============================================================================
// Vibee OS â€” CSV Module
// CSV parsing, writing, and data manipulation
// =============================================================================

// -----------------------------------------------------------------------------
// CSV Reader
// -----------------------------------------------------------------------------

/// CSV reader
actor CSVReader {
    state source: Source
    state delimiter: Char
    state quote: Char
    state escape: Char
    state has_header: Bool
    state trim_fields: Bool
    state skip_empty: Bool
    state comment_char: Option<Char>
    state headers: Option<[String]>
    state line_number: Int
    
    /// Create reader from string
    fn from_string(content: String) -> Self {
        CSVReader {
            source: Source.String(content, 0),
            delimiter: ',',
            quote: '"',
            escape: '"',
            has_header: true,
            trim_fields: false,
            skip_empty: true,
            comment_char: None,
            line_number: 0
        }
    }
    
    /// Create reader from file
    fn from_file(path: String) -> Result<Self, CSVError> {
        let file = File.open(path, "r")?
        Ok(CSVReader {
            source: Source.File(file),
            delimiter: ',',
            quote: '"',
            escape: '"',
            has_header: true,
            trim_fields: false,
            skip_empty: true,
            comment_char: None,
            line_number: 0
        })
    }
    
    /// Create reader from stream
    fn from_stream(stream: Stream<String>) -> Self {
        CSVReader {
            source: Source.Stream(stream),
            delimiter: ',',
            quote: '"',
            escape: '"',
            has_header: true,
            trim_fields: false,
            skip_empty: true,
            comment_char: None,
            line_number: 0
        }
    }
    
    // Configuration
    on delimiter(d: Char) -> Self { self.delimiter = d; self }
    on quote(q: Char) -> Self { self.quote = q; self }
    on escape(e: Char) -> Self { self.escape = e; self }
    on has_header(h: Bool) -> Self { self.has_header = h; self }
    on trim(t: Bool) -> Self { self.trim_fields = t; self }
    on skip_empty(s: Bool) -> Self { self.skip_empty = s; self }
    on comment(c: Char) -> Self { self.comment_char = Some(c); self }
    
    /// Set custom headers (when file has no header)
    on headers(h: [String]) -> Self {
        self.headers = Some(h)
        self.has_header = false
        self
    }
    
    /// Read all records
    on read_all() -> Result<[Record], CSVError> {
        var records = []
        
        // Read header if present
        if self.has_header && self.headers.is_none() {
            if let row = self.read_row()? {
                self.headers = Some(row)
            }
        }
        
        while let Some(row) = self.read_row()? {
            let record = self.row_to_record(row)
            records.append(record)
        }
        
        Ok(records)
    }
    
    /// Read as iterator
    fn iter() -> CSVIterator {
        // Read header first
        if self.has_header && self.headers.is_none() {
            if let Ok(Some(row)) = self.read_row() {
                self.headers = Some(row)
            }
        }
        
        CSVIterator { reader: self }
    }
    
    /// Read single row
    fn read_row() -> Result<Option<[String]>, CSVError> {
        loop {
            let line = match self.source.read_line() {
                Some(l) => l
                None => return Ok(None)
            }
            
            self.line_number += 1
            
            // Skip empty lines
            if self.skip_empty && line.trim().is_empty() {
                continue
            }
            
            // Skip comments
            if let Some(cc) = self.comment_char {
                if line.trim().starts_with(cc) {
                    continue
                }
            }
            
            return Ok(Some(self.parse_row(line)?))
        }
    }
    
    /// Parse a single row
    fn parse_row(line: String) -> Result<[String], CSVError> {
        var fields = []
        var current = StringBuilder.new()
        var in_quotes = false
        var chars = line.chars().peekable()
        
        while let Some(c) = chars.next() {
            if in_quotes {
                if c == self.quote {
                    if chars.peek() == Some(self.escape) {
                        // Escaped quote
                        chars.next()
                        current.append(self.quote)
                    } else {
                        // End of quoted field
                        in_quotes = false
                    }
                } else {
                    current.append(c)
                }
            } else {
                if c == self.quote {
                    in_quotes = true
                } else if c == self.delimiter {
                    fields.append(self.finalize_field(current.build()))
                    current = StringBuilder.new()
                } else {
                    current.append(c)
                }
            }
        }
        
        // Add last field
        fields.append(self.finalize_field(current.build()))
        
        if in_quotes {
            return Err(CSVError.UnterminatedQuote(self.line_number))
        }
        
        Ok(fields)
    }
    
    fn finalize_field(field: String) -> String {
        if self.trim_fields {
            field.trim()
        } else {
            field
        }
    }
    
    fn row_to_record(row: [String]) -> Record {
        if let Some(headers) = self.headers {
            Record.with_headers(headers, row)
        } else {
            Record.indexed(row)
        }
    }
    
    /// Get headers
    fn get_headers() -> Option<[String]> {
        self.headers
    }
}

enum Source {
    String(String, Int)  // content, position
    File(File)
    Stream(Stream<String>)
    
    fn read_line() -> Option<String> {
        match self {
            .String(content, pos) => {
                if pos >= content.len() {
                    return None
                }
                let end = content[pos..].find("\n")
                    .map(|i| pos + i)
                    .unwrap_or(content.len())
                let line = content[pos..end]
                self = .String(content, end + 1)
                Some(line)
            }
            .File(file) => file.read_line()
            .Stream(stream) => stream.next()
        }
    }
}

/// CSV iterator
struct CSVIterator {
    reader: CSVReader
}

impl Iterator for CSVIterator {
    type Item = Result<Record, CSVError>
    
    fn next() -> Option<Self::Item> {
        match self.reader.read_row() {
            Ok(Some(row)) => Some(Ok(self.reader.row_to_record(row)))
            Ok(None) => None
            Err(e) => Some(Err(e))
        }
    }
}

// -----------------------------------------------------------------------------
// CSV Record
// -----------------------------------------------------------------------------

/// CSV record (row)
struct Record {
    fields: [String]
    headers: Option<[String]>
    header_index: Option<Map<String, Int>>
    
    /// Create indexed record (no headers)
    fn indexed(fields: [String]) -> Self {
        Record {
            fields: fields,
            headers: None,
            header_index: None
        }
    }
    
    /// Create record with headers
    fn with_headers(headers: [String], fields: [String]) -> Self {
        var index = Map.empty()
        for (i, h) in headers.enumerate() {
            index.set(h, i)
        }
        
        Record {
            fields: fields,
            headers: Some(headers),
            header_index: Some(index)
        }
    }
    
    /// Get field by index
    fn get(index: Int) -> Option<String> {
        if index >= 0 && index < self.fields.len() {
            Some(self.fields[index])
        } else {
            None
        }
    }
    
    /// Get field by name
    fn get_by_name(name: String) -> Option<String> {
        self.header_index
            .and_then(|idx| idx.get(name))
            .and_then(|i| self.get(i))
    }
    
    /// Get field with default
    fn get_or(index: Int, default: String) -> String {
        self.get(index).unwrap_or(default)
    }
    
    /// Get by name with default
    fn get_name_or(name: String, default: String) -> String {
        self.get_by_name(name).unwrap_or(default)
    }
    
    /// Parse field as type
    fn parse<T: FromStr>(index: Int) -> Result<T, ParseError> {
        let value = self.get(index).ok_or(ParseError.FieldNotFound(index))?
        T.from_str(value).map_err(|_| ParseError.InvalidValue(value))
    }
    
    /// Parse by name as type
    fn parse_name<T: FromStr>(name: String) -> Result<T, ParseError> {
        let value = self.get_by_name(name).ok_or(ParseError.FieldNotFound(name))?
        T.from_str(value).map_err(|_| ParseError.InvalidValue(value))
    }
    
    /// Get as integer
    fn get_int(index: Int) -> Option<Int> {
        self.get(index).and_then(|v| Int.parse(v).ok())
    }
    
    /// Get as float
    fn get_float(index: Int) -> Option<Float> {
        self.get(index).and_then(|v| Float.parse(v).ok())
    }
    
    /// Get as boolean
    fn get_bool(index: Int) -> Option<Bool> {
        self.get(index).map(|v| {
            match v.to_lower() {
                "true" | "1" | "yes" | "y" => true
                _ => false
            }
        })
    }
    
    /// Number of fields
    fn len() -> Int {
        self.fields.len()
    }
    
    /// Check if empty
    fn is_empty() -> Bool {
        self.fields.is_empty()
    }
    
    /// Convert to map
    fn to_map() -> Map<String, String> {
        var map = Map.empty()
        if let Some(headers) = self.headers {
            for (i, h) in headers.enumerate() {
                if i < self.fields.len() {
                    map.set(h, self.fields[i])
                }
            }
        }
        map
    }
    
    /// Iterate fields
    fn iter() -> impl Iterator<Item = String> {
        self.fields.iter()
    }
    
    /// Iterate with headers
    fn iter_named() -> impl Iterator<Item = (String, String)> {
        if let Some(headers) = self.headers {
            headers.iter().zip(self.fields.iter())
        } else {
            [].iter()
        }
    }
}

// Index access
impl Index<Int> for Record {
    type Output = String
    
    fn index(i: Int) -> String {
        self.fields[i]
    }
}

impl Index<String> for Record {
    type Output = Option<String>
    
    fn index(name: String) -> Option<String> {
        self.get_by_name(name)
    }
}

// -----------------------------------------------------------------------------
// CSV Writer
// -----------------------------------------------------------------------------

/// CSV writer
actor CSVWriter {
    state output: Output
    state delimiter: Char
    state quote: Char
    state quote_style: QuoteStyle
    state line_ending: String
    state headers_written: Bool
    
    /// Create writer to string
    fn to_string() -> Self {
        CSVWriter {
            output: Output.String(StringBuilder.new()),
            delimiter: ',',
            quote: '"',
            quote_style: .Necessary,
            line_ending: "\n",
            headers_written: false
        }
    }
    
    /// Create writer to file
    fn to_file(path: String) -> Result<Self, CSVError> {
        let file = File.create(path)?
        Ok(CSVWriter {
            output: Output.File(file),
            delimiter: ',',
            quote: '"',
            quote_style: .Necessary,
            line_ending: "\n",
            headers_written: false
        })
    }
    
    // Configuration
    on delimiter(d: Char) -> Self { self.delimiter = d; self }
    on quote(q: Char) -> Self { self.quote = q; self }
    on quote_style(s: QuoteStyle) -> Self { self.quote_style = s; self }
    on crlf() -> Self { self.line_ending = "\r\n"; self }
    
    /// Write header row
    on write_header(headers: [String]) -> Result<(), CSVError> {
        self.write_row(headers)?
        self.headers_written = true
        Ok(())
    }
    
    /// Write data row
    on write_row(fields: [String]) -> Result<(), CSVError> {
        let formatted = fields.map(|f| self.format_field(f))
        let line = formatted.join(self.delimiter.to_string()) + self.line_ending
        self.output.write(line)
    }
    
    /// Write record
    on write_record(record: Record) -> Result<(), CSVError> {
        self.write_row(record.fields)
    }
    
    /// Write multiple rows
    on write_rows(rows: [[String]]) -> Result<(), CSVError> {
        for row in rows {
            self.write_row(row)?
        }
        Ok(())
    }
    
    /// Write from iterator of records
    on write_all<I: Iterator<Item = Record>>(records: I) -> Result<(), CSVError> {
        for record in records {
            self.write_record(record)?
        }
        Ok(())
    }
    
    /// Format field with quoting
    fn format_field(field: String) -> String {
        let needs_quote = match self.quote_style {
            .Always => true
            .Never => false
            .Necessary => {
                field.contains(self.delimiter) ||
                field.contains(self.quote) ||
                field.contains('\n') ||
                field.contains('\r')
            }
            .NonNumeric => !field.chars().all(|c| c.is_digit() || c == '.' || c == '-')
        }
        
        if needs_quote {
            let escaped = field.replace(
                self.quote.to_string(),
                self.quote.to_string() + self.quote.to_string()
            )
            "\(self.quote)\(escaped)\(self.quote)"
        } else {
            field
        }
    }
    
    /// Flush and get result (for string output)
    on finish() -> Result<String, CSVError> {
        self.output.flush()?
        match self.output {
            .String(sb) => Ok(sb.build())
            .File(_) => Err(CSVError.NotStringOutput)
        }
    }
    
    /// Close writer
    on close() -> Result<(), CSVError> {
        self.output.close()
    }
}

enum Output {
    String(StringBuilder)
    File(File)
    
    fn write(data: String) -> Result<(), CSVError> {
        match self {
            .String(sb) => { sb.append(data); Ok(()) }
            .File(f) => f.write(data).map_err(|e| CSVError.IOError(e.message()))
        }
    }
    
    fn flush() -> Result<(), CSVError> {
        match self {
            .String(_) => Ok(())
            .File(f) => f.flush().map_err(|e| CSVError.IOError(e.message()))
        }
    }
    
    fn close() -> Result<(), CSVError> {
        match self {
            .String(_) => Ok(())
            .File(f) => f.close().map_err(|e| CSVError.IOError(e.message()))
        }
    }
}

enum QuoteStyle {
    Always      // Quote all fields
    Never       // Never quote
    Necessary   // Quote only when needed
    NonNumeric  // Quote non-numeric fields
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Parse CSV string
fn parse(content: String) -> Result<[Record], CSVError> {
    CSVReader.from_string(content).read_all()
}

/// Parse CSV file
fn parse_file(path: String) -> Result<[Record], CSVError> {
    CSVReader.from_file(path)?.read_all()
}

/// Generate CSV string
fn generate(records: [[String]], headers: Option<[String]> = None) -> Result<String, CSVError> {
    let writer = CSVWriter.to_string()
    
    if let Some(h) = headers {
        writer.write_header(h)?
    }
    
    writer.write_rows(records)?
    writer.finish()
}

/// Convert records to typed structs
fn deserialize<T: Deserialize>(records: [Record]) -> Result<[T], CSVError> {
    records.map(|r| {
        let map = r.to_map()
        T.deserialize(map)
    }).collect()
}

/// Convert structs to CSV
fn serialize<T: Serialize>(items: [T], headers: [String]) -> Result<String, CSVError> {
    let writer = CSVWriter.to_string()
    writer.write_header(headers)?
    
    for item in items {
        let map = item.serialize()
        let row = headers.map(|h| map.get(h).unwrap_or(""))
        writer.write_row(row)?
    }
    
    writer.finish()
}

// -----------------------------------------------------------------------------
// DataFrame-like Operations
// -----------------------------------------------------------------------------

/// CSV table for data manipulation
actor Table {
    state headers: [String]
    state rows: [[String]]
    
    /// Create from records
    fn from_records(records: [Record]) -> Self {
        let headers = records.first()
            .and_then(|r| r.headers)
            .unwrap_or([])
        
        let rows = records.map(|r| r.fields)
        
        Table { headers: headers, rows: rows }
    }
    
    /// Create from CSV string
    fn from_csv(content: String) -> Result<Self, CSVError> {
        let records = parse(content)?
        Ok(Self.from_records(records))
    }
    
    /// Select columns
    fn select(columns: [String]) -> Table {
        let indices = columns.filter_map(|c| {
            self.headers.position(|h| h == c)
        })
        
        let new_rows = self.rows.map(|row| {
            indices.map(|i| row.get(i).unwrap_or(""))
        })
        
        Table { headers: columns, rows: new_rows }
    }
    
    /// Filter rows
    fn filter<F: Fn(Record) -> Bool>(predicate: F) -> Table {
        let filtered = self.rows.filter(|row| {
            let record = Record.with_headers(self.headers, row)
            predicate(record)
        })
        
        Table { headers: self.headers, rows: filtered }
    }
    
    /// Map rows
    fn map<F: Fn(Record) -> Record>(transform: F) -> Table {
        let mapped = self.rows.map(|row| {
            let record = Record.with_headers(self.headers, row)
            transform(record).fields
        })
        
        Table { headers: self.headers, rows: mapped }
    }
    
    /// Sort by column
    fn sort_by(column: String, ascending: Bool = true) -> Table {
        let idx = self.headers.position(|h| h == column).unwrap_or(0)
        
        var sorted = self.rows.clone()
        sorted.sort_by(|a, b| {
            let cmp = a[idx].cmp(b[idx])
            if ascending { cmp } else { cmp.reverse() }
        })
        
        Table { headers: self.headers, rows: sorted }
    }
    
    /// Group by column
    fn group_by(column: String) -> Map<String, Table> {
        let idx = self.headers.position(|h| h == column).unwrap_or(0)
        var groups = Map.empty()
        
        for row in self.rows {
            let key = row.get(idx).unwrap_or("")
            groups.entry(key).or_default().append(row)
        }
        
        groups.map(|(k, rows)| {
            (k, Table { headers: self.headers, rows: rows })
        })
    }
    
    /// Add column
    fn add_column<F: Fn(Record) -> String>(name: String, compute: F) -> Table {
        let new_headers = self.headers + [name]
        let new_rows = self.rows.map(|row| {
            let record = Record.with_headers(self.headers, row)
            row + [compute(record)]
        })
        
        Table { headers: new_headers, rows: new_rows }
    }
    
    /// Rename column
    fn rename(old_name: String, new_name: String) -> Table {
        let new_headers = self.headers.map(|h| {
            if h == old_name { new_name } else { h }
        })
        
        Table { headers: new_headers, rows: self.rows }
    }
    
    /// Drop column
    fn drop(column: String) -> Table {
        let idx = self.headers.position(|h| h == column)
        if let Some(i) = idx {
            let new_headers = self.headers.enumerate()
                .filter(|(j, _)| j != i)
                .map(|(_, h)| h)
            
            let new_rows = self.rows.map(|row| {
                row.enumerate()
                    .filter(|(j, _)| j != i)
                    .map(|(_, v)| v)
            })
            
            Table { headers: new_headers, rows: new_rows }
        } else {
            self
        }
    }
    
    /// Get row count
    fn len() -> Int {
        self.rows.len()
    }
    
    /// Convert to CSV string
    fn to_csv() -> Result<String, CSVError> {
        generate(self.rows, Some(self.headers))
    }
    
    /// Convert to records
    fn to_records() -> [Record] {
        self.rows.map(|row| Record.with_headers(self.headers, row))
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum CSVError {
    IOError(String)
    UnterminatedQuote(Int)
    InvalidFieldCount(Int, Int, Int)  // line, expected, got
    NotStringOutput
    ParseError(String)
    
    fn message() -> String {
        match self {
            .IOError(msg) => "I/O error: \(msg)"
            .UnterminatedQuote(line) => "Unterminated quote at line \(line)"
            .InvalidFieldCount(line, exp, got) => 
                "Invalid field count at line \(line): expected \(exp), got \(got)"
            .NotStringOutput => "Output is not a string"
            .ParseError(msg) => "Parse error: \(msg)"
        }
    }
}

enum ParseError {
    FieldNotFound(Any)
    InvalidValue(String)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse simple csv" {
    let csv = "name,age\nAlice,30\nBob,25"
    let records = parse(csv)?
    
    assert(records.len() == 2)
    assert(records[0]["name"] == Some("Alice"))
    assert(records[0]["age"] == Some("30"))
}

test "parse with quotes" {
    let csv = "name,description\nTest,\"Hello, World\"\nQuote,\"Say \"\"Hi\"\"\""
    let records = parse(csv)?
    
    assert(records[0]["description"] == Some("Hello, World"))
    assert(records[1]["description"] == Some("Say \"Hi\""))
}

test "write csv" {
    let writer = CSVWriter.to_string()
    writer.write_header(["name", "value"])?
    writer.write_row(["test", "123"])?
    writer.write_row(["comma", "a,b"])?
    
    let result = writer.finish()?
    assert(result.contains("name,value"))
    assert(result.contains("\"a,b\""))
}

test "table operations" {
    let csv = "name,age,city\nAlice,30,NYC\nBob,25,LA\nCharlie,30,NYC"
    let table = Table.from_csv(csv)?
    
    let filtered = table.filter(|r| r.get_int(1).unwrap_or(0) >= 30)
    assert(filtered.len() == 2)
    
    let selected = table.select(["name", "city"])
    assert(selected.headers.len() == 2)
}
