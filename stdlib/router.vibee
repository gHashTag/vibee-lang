// =============================================================================
// Vibee OS â€” Router Module
// HTTP router with path parameters, groups, and middleware support
// =============================================================================

// =============================================================================
// Route Matching
// =============================================================================

/// HTTP Router
struct Router {
    routes: [Route]
    not_found_handler: Option<fn(Request) -> Response>
    method_not_allowed_handler: Option<fn(Request) -> Response>
    middleware: [Middleware]
    prefix: String
}

impl Router {
    /// Create a new router
    fn new() -> Self {
        Router {
            routes: [],
            not_found_handler: None,
            method_not_allowed_handler: None,
            middleware: [],
            prefix: ""
        }
    }
    
    /// Create router with prefix
    fn with_prefix(prefix: String) -> Self {
        Router {
            routes: [],
            not_found_handler: None,
            method_not_allowed_handler: None,
            middleware: [],
            prefix: prefix.trim_end("/")
        }
    }
    
    // -------------------------------------------------------------------------
    // Route Registration
    // -------------------------------------------------------------------------
    
    /// Register a route
    fn route(method: http.Method, path: String, handler: fn(Context) -> Response) -> Self {
        let full_path = format!("{}{}", self.prefix, path)
        let pattern = RoutePattern.parse(full_path)
        self.routes.push(Route {
            method: method,
            pattern: pattern,
            handler: handler,
            middleware: [],
            name: None
        })
        self
    }
    
    /// GET route
    fn get(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.GET, path, handler)
    }
    
    /// POST route
    fn post(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.POST, path, handler)
    }
    
    /// PUT route
    fn put(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.PUT, path, handler)
    }
    
    /// DELETE route
    fn delete(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.DELETE, path, handler)
    }
    
    /// PATCH route
    fn patch(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.PATCH, path, handler)
    }
    
    /// HEAD route
    fn head(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.HEAD, path, handler)
    }
    
    /// OPTIONS route
    fn options(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.OPTIONS, path, handler)
    }
    
    /// Register route for any HTTP method
    fn any(path: String, handler: fn(Context) -> Response) -> Self {
        for method in [http.Method.GET, http.Method.POST, http.Method.PUT, http.Method.DELETE, http.Method.PATCH] {
            self.route(method, path, handler)
        }
        self
    }
    
    /// Register multiple methods for same path
    fn methods(methods: [http.Method], path: String, handler: fn(Context) -> Response) -> Self {
        for method in methods {
            self.route(method, path, handler)
        }
        self
    }
    
    /// Named route for URL generation
    fn named(name: String) -> Self {
        if let Some(route) = self.routes.last_mut() {
            route.name = Some(name)
        }
        self
    }
    
    // -------------------------------------------------------------------------
    // Route Groups
    // -------------------------------------------------------------------------
    
    /// Create a route group with prefix
    fn group(prefix: String, configure: fn(RouteGroup) -> RouteGroup) -> Self {
        let group = RouteGroup.new(format!("{}{}", self.prefix, prefix))
        let configured = configure(group)
        self.routes.extend(configured.routes)
        self
    }
    
    /// Mount another router at prefix
    fn mount(prefix: String, router: Router) -> Self {
        let full_prefix = format!("{}{}", self.prefix, prefix)
        for route in router.routes {
            let new_pattern = RoutePattern.parse(format!("{}{}", full_prefix, route.pattern.raw))
            self.routes.push(Route {
                method: route.method,
                pattern: new_pattern,
                handler: route.handler,
                middleware: route.middleware,
                name: route.name
            })
        }
        self
    }
    
    // -------------------------------------------------------------------------
    // Middleware
    // -------------------------------------------------------------------------
    
    /// Add global middleware
    fn use(mw: Middleware) -> Self {
        self.middleware.push(mw)
        self
    }
    
    /// Add middleware to last registered route
    fn with(mw: Middleware) -> Self {
        if let Some(route) = self.routes.last_mut() {
            route.middleware.push(mw)
        }
        self
    }
    
    // -------------------------------------------------------------------------
    // Error Handlers
    // -------------------------------------------------------------------------
    
    /// Set 404 handler
    fn not_found(handler: fn(Request) -> Response) -> Self {
        self.not_found_handler = Some(handler)
        self
    }
    
    /// Set 405 handler
    fn method_not_allowed(handler: fn(Request) -> Response) -> Self {
        self.method_not_allowed_handler = Some(handler)
        self
    }
    
    // -------------------------------------------------------------------------
    // Route Matching
    // -------------------------------------------------------------------------
    
    /// Match a request to a route
    fn match(req: http.Request) -> Option<RouteMatch> {
        let path = url.URL.parse(req.url).map(|u| u.path).unwrap_or("/")
        var method_matched = false
        
        for route in self.routes {
            if let Some(params) = route.pattern.match(path) {
                method_matched = true
                if route.method == req.method {
                    return Some(RouteMatch {
                        route: route,
                        params: params,
                        path: path
                    })
                }
            }
        }
        
        if method_matched {
            return Some(RouteMatch.method_not_allowed())
        }
        
        None
    }
    
    /// Handle a request
    fn handle(req: http.Request) -> Response {
        let path = url.URL.parse(req.url).map(|u| u.path).unwrap_or("/")
        let query_params = url.URL.parse(req.url).map(|u| u.query_params()).unwrap_or(Map.empty())
        
        match self.match(req) {
            Some(route_match) if !route_match.is_method_not_allowed => {
                let ctx = Context {
                    request: req,
                    params: route_match.params,
                    query: query_params,
                    state: Map.empty(),
                    path: path
                }
                
                // Build middleware chain
                let all_middleware = self.middleware.clone()
                all_middleware.extend(route_match.route.middleware.clone())
                
                // Execute middleware chain
                let handler = route_match.route.handler
                let final_handler = all_middleware.iter().rev().fold(
                    |ctx| handler(ctx),
                    |next, mw| |ctx| mw.handle(ctx, next)
                )
                
                final_handler(ctx)
            }
            Some(_) => {
                // Method not allowed
                match self.method_not_allowed_handler {
                    Some(h) => h(req),
                    None => Response.error(405).text("Method Not Allowed")
                }
            }
            None => {
                // Not found
                match self.not_found_handler {
                    Some(h) => h(req),
                    None => Response.not_found().text("Not Found")
                }
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // URL Generation
    // -------------------------------------------------------------------------
    
    /// Generate URL for named route
    fn url_for(name: String, params: Map<String, String>) -> Option<String> {
        for route in self.routes {
            if route.name == Some(name) {
                return Some(route.pattern.build(params))
            }
        }
        None
    }
    
    /// List all registered routes
    fn routes() -> [RouteInfo] {
        self.routes.iter().map(|r| RouteInfo {
            method: r.method,
            path: r.pattern.raw.clone(),
            name: r.name.clone()
        }).collect()
    }
}

// =============================================================================
// Route Pattern
// =============================================================================

/// Route pattern with parameter extraction
struct RoutePattern {
    raw: String
    segments: [PatternSegment]
    regex: Option<Regex>
}

enum PatternSegment {
    Static(String)
    Param(String)
    Wildcard(String)
    Regex(String, String)  // (name, pattern)
}

impl RoutePattern {
    /// Parse a route pattern
    fn parse(pattern: String) -> Self {
        let pattern = if pattern.is_empty() { "/" } else { pattern }
        let pattern = if !pattern.starts_with("/") { format!("/{}", pattern) } else { pattern }
        
        var segments = []
        let parts = pattern.split("/").filter(|s| !s.is_empty())
        
        for part in parts {
            if part.starts_with(":") {
                // Parameter: :id
                let name = part[1..]
                if name.contains("<") && name.ends_with(">") {
                    // Regex constraint: :id<[0-9]+>
                    let idx = name.find("<").unwrap()
                    let param_name = name[0..idx]
                    let regex_pattern = name[(idx + 1)..(name.len() - 1)]
                    segments.push(PatternSegment.Regex(param_name, regex_pattern))
                } else {
                    segments.push(PatternSegment.Param(name))
                }
            } else if part.starts_with("*") {
                // Wildcard: *filepath
                let name = if part.len() > 1 { part[1..] } else { "wildcard" }
                segments.push(PatternSegment.Wildcard(name))
            } else {
                segments.push(PatternSegment.Static(part))
            }
        }
        
        RoutePattern {
            raw: pattern,
            segments: segments,
            regex: None
        }
    }
    
    /// Match path against pattern
    fn match(path: String) -> Option<Params> {
        let path_parts: [String] = path.split("/").filter(|s| !s.is_empty()).collect()
        var params = Params.new()
        var path_idx = 0
        
        for (seg_idx, segment) in self.segments.iter().enumerate() {
            match segment {
                PatternSegment.Static(s) => {
                    if path_idx >= path_parts.len() || path_parts[path_idx] != s {
                        return None
                    }
                    path_idx += 1
                }
                PatternSegment.Param(name) => {
                    if path_idx >= path_parts.len() {
                        return None
                    }
                    params.set(name.clone(), path_parts[path_idx].clone())
                    path_idx += 1
                }
                PatternSegment.Regex(name, pattern) => {
                    if path_idx >= path_parts.len() {
                        return None
                    }
                    let re = regex.Regex.new(format!("^{}$", pattern)).ok()?
                    if !re.is_match(path_parts[path_idx]) {
                        return None
                    }
                    params.set(name.clone(), path_parts[path_idx].clone())
                    path_idx += 1
                }
                PatternSegment.Wildcard(name) => {
                    // Capture rest of path
                    let rest = path_parts[path_idx..].join("/")
                    params.set(name.clone(), rest)
                    return Some(params)
                }
            }
        }
        
        // Check all path parts consumed
        if path_idx != path_parts.len() {
            return None
        }
        
        Some(params)
    }
    
    /// Build URL from pattern and params
    fn build(params: Map<String, String>) -> String {
        var parts = []
        
        for segment in self.segments {
            match segment {
                PatternSegment.Static(s) => parts.push(s)
                PatternSegment.Param(name) | PatternSegment.Regex(name, _) => {
                    if let Some(value) = params.get(name) {
                        parts.push(url.percent_encode(value))
                    } else {
                        parts.push(format!(":{}", name))
                    }
                }
                PatternSegment.Wildcard(name) => {
                    if let Some(value) = params.get(name) {
                        parts.push(value)
                    }
                }
            }
        }
        
        format!("/{}", parts.join("/"))
    }
}

// =============================================================================
// Route & Match
// =============================================================================

/// Route definition
struct Route {
    method: http.Method
    pattern: RoutePattern
    handler: fn(Context) -> Response
    middleware: [Middleware]
    name: Option<String>
}

/// Route match result
struct RouteMatch {
    route: Route
    params: Params
    path: String
    is_method_not_allowed: Bool
}

impl RouteMatch {
    fn method_not_allowed() -> Self {
        RouteMatch {
            route: Route { method: http.Method.GET, pattern: RoutePattern.parse("/"), handler: |_| Response.error(405), middleware: [], name: None },
            params: Params.new(),
            path: "",
            is_method_not_allowed: true
        }
    }
}

/// Route info for listing
struct RouteInfo {
    method: http.Method
    path: String
    name: Option<String>
}

// =============================================================================
// Route Group
// =============================================================================

/// Route group for organizing routes
struct RouteGroup {
    prefix: String
    routes: [Route]
    middleware: [Middleware]
}

impl RouteGroup {
    fn new(prefix: String) -> Self {
        RouteGroup {
            prefix: prefix.trim_end("/"),
            routes: [],
            middleware: []
        }
    }
    
    fn route(method: http.Method, path: String, handler: fn(Context) -> Response) -> Self {
        let full_path = format!("{}{}", self.prefix, path)
        let pattern = RoutePattern.parse(full_path)
        self.routes.push(Route {
            method: method,
            pattern: pattern,
            handler: handler,
            middleware: self.middleware.clone(),
            name: None
        })
        self
    }
    
    fn get(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.GET, path, handler)
    }
    
    fn post(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.POST, path, handler)
    }
    
    fn put(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.PUT, path, handler)
    }
    
    fn delete(path: String, handler: fn(Context) -> Response) -> Self {
        self.route(http.Method.DELETE, path, handler)
    }
    
    fn use(mw: Middleware) -> Self {
        self.middleware.push(mw)
        self
    }
    
    fn group(prefix: String, configure: fn(RouteGroup) -> RouteGroup) -> Self {
        let group = RouteGroup.new(format!("{}{}", self.prefix, prefix))
        let configured = configure(group)
        self.routes.extend(configured.routes)
        self
    }
}

// =============================================================================
// Request Context
// =============================================================================

/// Request context with params and state
struct Context {
    request: http.Request
    params: Params
    query: Map<String, String>
    state: Map<String, Any>
    path: String
}

impl Context {
    /// Get path parameter
    fn param(name: String) -> Option<String> {
        self.params.get(name)
    }
    
    /// Get path parameter as int
    fn param_int(name: String) -> Option<Int> {
        self.params.get(name).and_then(|s| Int.parse(s).ok())
    }
    
    /// Get query parameter
    fn query(name: String) -> Option<String> {
        self.query.get(name)
    }
    
    /// Get query parameter with default
    fn query_or(name: String, default: String) -> String {
        self.query.get(name).unwrap_or(default)
    }
    
    /// Get query parameter as int
    fn query_int(name: String) -> Option<Int> {
        self.query.get(name).and_then(|s| Int.parse(s).ok())
    }
    
    /// Get all query parameters for key
    fn query_all(name: String) -> [String] {
        // For multi-value params like ?tag=a&tag=b
        self.query.get(name).map(|v| [v]).unwrap_or([])
    }
    
    /// Get request header
    fn header(name: String) -> Option<String> {
        self.request.headers.get(name)
    }
    
    /// Get request body as string
    fn body_text() -> String {
        String.from_utf8(self.request.body.clone()).unwrap_or("")
    }
    
    /// Parse request body as JSON
    fn body_json<T: Deserialize>() -> Result<T, JsonError> {
        json.decode(self.body_text())
    }
    
    /// Get state value
    fn get<T>(key: String) -> Option<T> {
        self.state.get(key).and_then(|v| v.downcast::<T>())
    }
    
    /// Set state value
    fn set<T>(key: String, value: T) {
        self.state.set(key, value as Any)
    }
    
    /// Get request method
    fn method() -> http.Method {
        self.request.method
    }
    
    /// Check if request is AJAX
    fn is_ajax() -> Bool {
        self.header("X-Requested-With") == Some("XMLHttpRequest")
    }
    
    /// Get client IP
    fn client_ip() -> Option<String> {
        self.header("X-Forwarded-For")
            .and_then(|s| s.split(",").first().map(|s| s.trim()))
            .or_else(|| self.header("X-Real-IP"))
    }
    
    /// Get content type
    fn content_type() -> Option<String> {
        self.header("Content-Type")
    }
    
    // -------------------------------------------------------------------------
    // Response Helpers
    // -------------------------------------------------------------------------
    
    /// Return JSON response
    fn json<T: Serialize>(data: T) -> Response {
        Response.ok().json(data)
    }
    
    /// Return text response
    fn text(s: String) -> Response {
        Response.ok().text(s)
    }
    
    /// Return HTML response
    fn html(s: String) -> Response {
        Response.ok().html(s)
    }
    
    /// Return redirect response
    fn redirect(url: String) -> Response {
        Response.new(http.Status.new(302))
            .header("Location", url)
    }
    
    /// Return permanent redirect
    fn redirect_permanent(url: String) -> Response {
        Response.new(http.Status.new(301))
            .header("Location", url)
    }
    
    /// Return no content response
    fn no_content() -> Response {
        Response.new(http.Status.no_content())
    }
    
    /// Return error response
    fn error(code: Int, message: String) -> Response {
        Response.error(code).json({"error": message})
    }
}

// =============================================================================
// Path Parameters
// =============================================================================

/// Path parameters extracted from URL
struct Params {
    inner: Map<String, String>
}

impl Params {
    fn new() -> Self {
        Params { inner: Map.empty() }
    }
    
    fn get(name: String) -> Option<String> {
        self.inner.get(name)
    }
    
    fn get_or(name: String, default: String) -> String {
        self.inner.get(name).unwrap_or(default)
    }
    
    fn set(name: String, value: String) {
        self.inner.set(name, value)
    }
    
    fn contains(name: String) -> Bool {
        self.inner.contains(name)
    }
    
    fn iter() -> impl Iterator<Item = (String, String)> {
        self.inner.iter()
    }
    
    fn len() -> Int {
        self.inner.len()
    }
    
    fn is_empty() -> Bool {
        self.inner.is_empty()
    }
}

// =============================================================================
// Middleware Type
// =============================================================================

/// Middleware trait
trait Middleware {
    fn handle(ctx: Context, next: fn(Context) -> Response) -> Response
}

/// Function-based middleware wrapper
struct FnMiddleware {
    handler: fn(Context, fn(Context) -> Response) -> Response
}

impl Middleware for FnMiddleware {
    fn handle(ctx: Context, next: fn(Context) -> Response) -> Response {
        (self.handler)(ctx, next)
    }
}

/// Create middleware from function
fn middleware(f: fn(Context, fn(Context) -> Response) -> Response) -> Middleware {
    FnMiddleware { handler: f } as Middleware
}

// =============================================================================
// Response Helpers
// =============================================================================

/// Extend http.Response with convenience methods
impl http.Response {
    fn redirect(url: String) -> Self {
        Self.new(http.Status.new(302)).header("Location", url)
    }
    
    fn redirect_permanent(url: String) -> Self {
        Self.new(http.Status.new(301)).header("Location", url)
    }
    
    fn with_cookie(cookie: Cookie) -> Self {
        self.header("Set-Cookie", cookie.to_string())
    }
}

// =============================================================================
// Static File Serving
// =============================================================================

/// Static file handler
struct Static {
    root: String
    index: String
    cache_max_age: Int
}

impl Static {
    fn new(root: String) -> Self {
        Static {
            root: root,
            index: "index.html",
            cache_max_age: 86400
        }
    }
    
    fn index(file: String) -> Self {
        self.index = file
        self
    }
    
    fn cache(max_age: Int) -> Self {
        self.cache_max_age = max_age
        self
    }
    
    fn handler() -> fn(Context) -> Response {
        let root = self.root.clone()
        let index = self.index.clone()
        let max_age = self.cache_max_age
        
        |ctx| {
            let file_path = ctx.param("filepath").unwrap_or("")
            let full_path = path.join(root, file_path)
            
            // Security: prevent directory traversal
            if !path.is_subpath(full_path, root) {
                return Response.error(403).text("Forbidden")
            }
            
            // Check if directory, serve index
            if fs.is_dir(full_path) {
                full_path = path.join(full_path, index)
            }
            
            // Read file
            match fs.read(full_path) {
                Ok(data) => {
                    let mime = mimetype.from_path(full_path).unwrap_or("application/octet-stream")
                    Response.ok()
                        .header("Content-Type", mime)
                        .header("Cache-Control", format!("public, max-age={}", max_age))
                        .body(data)
                }
                Err(_) => Response.not_found().text("File not found")
            }
        }
    }
}

// =============================================================================
// Router Error
// =============================================================================

enum RouterError {
    InvalidPattern(String)
    DuplicateRoute(String)
    InvalidMethod(String)
}

impl Display for RouterError {
    fn fmt(f: Formatter) {
        match self {
            InvalidPattern(s) => f.write(format!("Invalid route pattern: {}", s))
            DuplicateRoute(s) => f.write(format!("Duplicate route: {}", s))
            InvalidMethod(s) => f.write(format!("Invalid HTTP method: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "pattern matching" {
    let pattern = RoutePattern.parse("/users/:id")
    
    let params = pattern.match("/users/123")?
    assert_eq(params.get("id"), Some("123"))?
    
    assert(pattern.match("/users").is_none())?
    assert(pattern.match("/users/123/posts").is_none())?
}

test "pattern with regex constraint" {
    let pattern = RoutePattern.parse("/users/:id<[0-9]+>")
    
    assert(pattern.match("/users/123").is_some())?
    assert(pattern.match("/users/abc").is_none())?
}

test "wildcard pattern" {
    let pattern = RoutePattern.parse("/static/*filepath")
    
    let params = pattern.match("/static/css/style.css")?
    assert_eq(params.get("filepath"), Some("css/style.css"))?
}

test "router basic" {
    let router = Router.new()
        .get("/", |ctx| ctx.text("Home"))
        .get("/users/:id", |ctx| {
            let id = ctx.param("id").unwrap_or("unknown")
            ctx.json({"id": id})
        })
    
    assert_eq(router.routes().len(), 2)?
}

test "route groups" {
    let router = Router.new()
        .group("/api/v1", |g| {
            g.get("/users", |ctx| ctx.json([]))
             .get("/posts", |ctx| ctx.json([]))
        })
    
    assert_eq(router.routes().len(), 2)?
    assert(router.routes()[0].path.starts_with("/api/v1"))?
}

test "url generation" {
    let router = Router.new()
        .get("/users/:id", |ctx| ctx.text("")).named("user")
    
    let url = router.url_for("user", Map.from([("id", "123")]))?
    assert_eq(url, "/users/123")?
}

test "context params" {
    let params = Params.new()
    params.set("id", "42")
    params.set("name", "test")
    
    assert_eq(params.get("id"), Some("42"))?
    assert_eq(params.len(), 2)?
}
