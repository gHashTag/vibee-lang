// =============================================================================
// Vibee OS â€” CBOR Module
// Concise Binary Object Representation (RFC 8949)
// =============================================================================

// -----------------------------------------------------------------------------
// Major Types
// -----------------------------------------------------------------------------

enum MajorType {
    UnsignedInt  // 0
    NegativeInt  // 1
    ByteString   // 2
    TextString   // 3
    Array        // 4
    Map          // 5
    Tag          // 6
    Simple       // 7
    
    fn from_byte(b: UInt8) -> MajorType {
        match b >> 5 {
            0 => .UnsignedInt
            1 => .NegativeInt
            2 => .ByteString
            3 => .TextString
            4 => .Array
            5 => .Map
            6 => .Tag
            _ => .Simple
        }
    }
    
    fn to_byte() -> UInt8 {
        match self {
            .UnsignedInt => 0
            .NegativeInt => 1
            .ByteString => 2
            .TextString => 3
            .Array => 4
            .Map => 5
            .Tag => 6
            .Simple => 7
        }
    }
}

// -----------------------------------------------------------------------------
// Value Type
// -----------------------------------------------------------------------------

enum Value {
    UInt(UInt64)
    NegInt(Int64)
    Bytes([UInt8])
    Text(String)
    Array([Value])
    Map([(Value, Value)])
    Tag(UInt64, Value)
    Simple(UInt8)
    Bool(Bool)
    Null
    Undefined
    Float16(Float32)
    Float32(Float32)
    Float64(Float64)
    
    fn is_null() -> Bool { match self { .Null => true, _ => false } }
    fn is_undefined() -> Bool { match self { .Undefined => true, _ => false } }
    
    fn as_int() -> Option<Int64> {
        match self {
            .UInt(u) => Some(u as Int64)
            .NegInt(n) => Some(n)
            _ => None
        }
    }
    
    fn as_uint() -> Option<UInt64> {
        match self {
            .UInt(u) => Some(u)
            _ => None
        }
    }
    
    fn as_bool() -> Option<Bool> {
        match self {
            .Bool(b) => Some(b)
            _ => None
        }
    }
    
    fn as_float() -> Option<Float64> {
        match self {
            .Float16(f) => Some(f as Float64)
            .Float32(f) => Some(f as Float64)
            .Float64(f) => Some(f)
            _ => None
        }
    }
    
    fn as_bytes() -> Option<[UInt8]> {
        match self {
            .Bytes(b) => Some(b)
            _ => None
        }
    }
    
    fn as_text() -> Option<String> {
        match self {
            .Text(s) => Some(s)
            _ => None
        }
    }
    
    fn as_array() -> Option<[Value]> {
        match self {
            .Array(a) => Some(a)
            _ => None
        }
    }
    
    fn as_map() -> Option<[(Value, Value)]> {
        match self {
            .Map(m) => Some(m)
            _ => None
        }
    }
    
    fn get(key: String) -> Option<Value> {
        match self {
            .Map(m) => {
                for (k, v) in m {
                    if let .Text(s) = k {
                        if s == key { return Some(v) }
                    }
                }
                None
            }
            _ => None
        }
    }
    
    fn at(idx: Int) -> Option<Value> {
        match self {
            .Array(a) if idx >= 0 && idx < a.len() => Some(a[idx])
            _ => None
        }
    }
}

// -----------------------------------------------------------------------------
// Encoder
// -----------------------------------------------------------------------------

actor Encoder {
    state buffer: [UInt8]
    state canonical: Bool
    
    fn new() -> Self { Encoder { buffer: [], canonical: false } }
    fn canonical() -> Self { Encoder { buffer: [], canonical: true } }
    
    fn encode(value: Value) -> [UInt8] {
        self.buffer.clear()
        self.write_value(value)
        self.buffer.clone()
    }
    
    fn write_value(value: Value) {
        match value {
            .UInt(u) => self.write_uint(MajorType.UnsignedInt, u)
            .NegInt(n) => self.write_uint(MajorType.NegativeInt, (-1 - n) as UInt64)
            .Bytes(b) => { self.write_uint(MajorType.ByteString, b.len() as UInt64); self.buffer.extend(b) }
            .Text(s) => { let b = s.as_bytes(); self.write_uint(MajorType.TextString, b.len() as UInt64); self.buffer.extend(b) }
            .Array(a) => { self.write_uint(MajorType.Array, a.len() as UInt64); for v in a { self.write_value(v) } }
            .Map(m) => self.write_map(m)
            .Tag(t, v) => { self.write_uint(MajorType.Tag, t); self.write_value(*v) }
            .Simple(s) => self.write_simple(s)
            .Bool(false) => self.buffer.push(0xf4)
            .Bool(true) => self.buffer.push(0xf5)
            .Null => self.buffer.push(0xf6)
            .Undefined => self.buffer.push(0xf7)
            .Float16(f) => { self.buffer.push(0xf9); self.write_be16(float_to_half(f)) }
            .Float32(f) => { self.buffer.push(0xfa); self.write_be32(f.to_bits()) }
            .Float64(f) => { self.buffer.push(0xfb); self.write_be64(f.to_bits()) }
        }
    }
    
    fn write_uint(major: MajorType, value: UInt64) {
        let mt = major.to_byte() << 5
        if value < 24 { self.buffer.push(mt | value as UInt8) }
        else if value <= 0xFF { self.buffer.push(mt | 24); self.buffer.push(value as UInt8) }
        else if value <= 0xFFFF { self.buffer.push(mt | 25); self.write_be16(value as UInt16) }
        else if value <= 0xFFFFFFFF { self.buffer.push(mt | 26); self.write_be32(value as UInt32) }
        else { self.buffer.push(mt | 27); self.write_be64(value) }
    }
    
    fn write_map(m: [(Value, Value)]) {
        let items = if self.canonical { self.sort_map(m) } else { m }
        self.write_uint(MajorType.Map, items.len() as UInt64)
        for (k, v) in items { self.write_value(k); self.write_value(v) }
    }
    
    fn sort_map(m: [(Value, Value)]) -> [(Value, Value)] {
        // Canonical CBOR: sort by encoded key bytes
        var encoded = m.map(|(k, v)| (Encoder.new().encode(k), k, v))
        encoded.sort_by(|(a, _, _), (b, _, _)| {
            if a.len() != b.len() { a.len().cmp(b.len()) }
            else { a.cmp(b) }
        })
        encoded.map(|(_, k, v)| (k, v))
    }
    
    fn write_simple(s: UInt8) {
        if s < 24 { self.buffer.push(0xe0 | s) }
        else { self.buffer.push(0xf8); self.buffer.push(s) }
    }
    
    fn write_be16(v: UInt16) { self.buffer.push((v >> 8) as UInt8); self.buffer.push(v as UInt8) }
    fn write_be32(v: UInt32) { for i in [24, 16, 8, 0] { self.buffer.push((v >> i) as UInt8) } }
    fn write_be64(v: UInt64) { for i in [56, 48, 40, 32, 24, 16, 8, 0] { self.buffer.push((v >> i) as UInt8) } }
}

// -----------------------------------------------------------------------------
// Decoder
// -----------------------------------------------------------------------------

actor Decoder {
    state data: [UInt8]
    state pos: Int
    
    fn new(data: [UInt8]) -> Self { Decoder { data: data, pos: 0 } }
    
    fn decode(data: [UInt8]) -> Result<Value, CBORError> {
        var d = Decoder.new(data)
        d.read_value()
    }
    
    fn read_value() -> Result<Value, CBORError> {
        let initial = self.read_byte()?
        let major = MajorType.from_byte(initial)
        let additional = initial & 0x1f
        
        match major {
            .UnsignedInt => Ok(Value.UInt(self.read_uint(additional)?))
            .NegativeInt => Ok(Value.NegInt(-1 - self.read_uint(additional)? as Int64))
            .ByteString => {
                let len = self.read_uint(additional)? as Int
                Ok(Value.Bytes(self.read_bytes(len)?))
            }
            .TextString => {
                let len = self.read_uint(additional)? as Int
                Ok(Value.Text(String.from_utf8(self.read_bytes(len)?)?))
            }
            .Array => {
                let len = self.read_uint(additional)? as Int
                var arr = []
                for _ in 0..len { arr.push(self.read_value()?) }
                Ok(Value.Array(arr))
            }
            .Map => {
                let len = self.read_uint(additional)? as Int
                var map = []
                for _ in 0..len {
                    let k = self.read_value()?
                    let v = self.read_value()?
                    map.push((k, v))
                }
                Ok(Value.Map(map))
            }
            .Tag => {
                let tag = self.read_uint(additional)?
                let value = self.read_value()?
                Ok(Value.Tag(tag, value))
            }
            .Simple => self.read_simple(additional)
        }
    }
    
    fn read_uint(additional: UInt8) -> Result<UInt64, CBORError> {
        match additional {
            0..=23 => Ok(additional as UInt64)
            24 => Ok(self.read_byte()? as UInt64)
            25 => Ok(self.read_be16()? as UInt64)
            26 => Ok(self.read_be32()? as UInt64)
            27 => self.read_be64()
            _ => Err(CBORError.InvalidAdditional(additional))
        }
    }
    
    fn read_simple(additional: UInt8) -> Result<Value, CBORError> {
        match additional {
            20 => Ok(Value.Bool(false))
            21 => Ok(Value.Bool(true))
            22 => Ok(Value.Null)
            23 => Ok(Value.Undefined)
            24 => Ok(Value.Simple(self.read_byte()?))
            25 => Ok(Value.Float16(half_to_float(self.read_be16()?)))
            26 => Ok(Value.Float32(Float32.from_bits(self.read_be32()?)))
            27 => Ok(Value.Float64(Float64.from_bits(self.read_be64()?)))
            31 => Err(CBORError.IndefiniteNotSupported)
            _ => Ok(Value.Simple(additional))
        }
    }
    
    fn read_byte() -> Result<UInt8, CBORError> {
        if self.pos >= self.data.len() { return Err(CBORError.UnexpectedEof) }
        let b = self.data[self.pos]; self.pos += 1; Ok(b)
    }
    
    fn read_bytes(len: Int) -> Result<[UInt8], CBORError> {
        if self.pos + len > self.data.len() { return Err(CBORError.UnexpectedEof) }
        let r = self.data[self.pos..(self.pos + len)].to_vec(); self.pos += len; Ok(r)
    }
    
    fn read_be16() -> Result<UInt16, CBORError> {
        let b = self.read_bytes(2)?
        Ok(((b[0] as UInt16) << 8) | (b[1] as UInt16))
    }
    
    fn read_be32() -> Result<UInt32, CBORError> {
        let b = self.read_bytes(4)?
        Ok(((b[0] as UInt32) << 24) | ((b[1] as UInt32) << 16) | ((b[2] as UInt32) << 8) | (b[3] as UInt32))
    }
    
    fn read_be64() -> Result<UInt64, CBORError> {
        let b = self.read_bytes(8)?
        var r: UInt64 = 0
        for i in 0..8 { r = (r << 8) | (b[i] as UInt64) }
        Ok(r)
    }
}

// -----------------------------------------------------------------------------
// Half-precision Float Conversion
// -----------------------------------------------------------------------------

fn float_to_half(f: Float32) -> UInt16 {
    let bits = f.to_bits()
    let sign = (bits >> 16) & 0x8000
    let exp = ((bits >> 23) & 0xFF) as Int - 127 + 15
    let mant = bits & 0x7FFFFF
    
    if exp <= 0 { sign as UInt16 }
    else if exp >= 31 { (sign | 0x7C00) as UInt16 }
    else { (sign | ((exp as UInt32) << 10) | (mant >> 13)) as UInt16 }
}

fn half_to_float(h: UInt16) -> Float32 {
    let sign = ((h & 0x8000) as UInt32) << 16
    let exp = ((h >> 10) & 0x1F) as Int
    let mant = (h & 0x3FF) as UInt32
    
    if exp == 0 {
        if mant == 0 { Float32.from_bits(sign) }
        else { Float32.from_bits(sign | (mant << 13)) }
    } else if exp == 31 {
        Float32.from_bits(sign | 0x7F800000 | (mant << 13))
    } else {
        Float32.from_bits(sign | (((exp - 15 + 127) as UInt32) << 23) | (mant << 13))
    }
}

// -----------------------------------------------------------------------------
// Standard Tags
// -----------------------------------------------------------------------------

const TAG_DATETIME_STRING: UInt64 = 0
const TAG_EPOCH_SECONDS: UInt64 = 1
const TAG_POSITIVE_BIGNUM: UInt64 = 2
const TAG_NEGATIVE_BIGNUM: UInt64 = 3
const TAG_DECIMAL_FRACTION: UInt64 = 4
const TAG_BIGFLOAT: UInt64 = 5
const TAG_BASE64URL: UInt64 = 21
const TAG_BASE64: UInt64 = 22
const TAG_BASE16: UInt64 = 23
const TAG_CBOR_DATA: UInt64 = 24
const TAG_URI: UInt64 = 32
const TAG_BASE64URL_STRING: UInt64 = 33
const TAG_BASE64_STRING: UInt64 = 34
const TAG_REGEX: UInt64 = 35
const TAG_MIME: UInt64 = 36
const TAG_SELF_DESCRIBE: UInt64 = 55799

// -----------------------------------------------------------------------------
// Errors & API
// -----------------------------------------------------------------------------

enum CBORError {
    UnexpectedEof
    InvalidAdditional(UInt8)
    InvalidUtf8
    IndefiniteNotSupported
    InvalidTag(UInt64)
}

fn encode(value: Value) -> [UInt8] { Encoder.new().encode(value) }
fn encode_canonical(value: Value) -> [UInt8] { Encoder.canonical().encode(value) }
fn decode(data: [UInt8]) -> Result<Value, CBORError> { Decoder.decode(data) }

trait CBORSerializable {
    fn to_cbor() -> Value
    fn from_cbor(v: Value) -> Result<Self, CBORError>
}

// -----------------------------------------------------------------------------
// Diagnostic Notation
// -----------------------------------------------------------------------------

fn to_diagnostic(value: Value) -> String {
    match value {
        .UInt(u) => "\(u)"
        .NegInt(n) => "\(n)"
        .Bytes(b) => "h'" + b.map(|x| format!("{:02x}", x)).join("") + "'"
        .Text(s) => "\"" + s.replace("\"", "\\\"") + "\""
        .Array(a) => "[" + a.map(|v| to_diagnostic(v)).join(", ") + "]"
        .Map(m) => "{" + m.map(|(k, v)| to_diagnostic(k) + ": " + to_diagnostic(v)).join(", ") + "}"
        .Tag(t, v) => "\(t)(" + to_diagnostic(*v) + ")"
        .Bool(b) => if b { "true" } else { "false" }
        .Null => "null"
        .Undefined => "undefined"
        .Float16(f) | .Float32(f) | .Float64(f) => "\(f)"
        .Simple(s) => "simple(\(s))"
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "roundtrip primitives" {
    assert(decode(encode(Value.UInt(42)))?.as_uint() == Some(42))
    assert(decode(encode(Value.NegInt(-42)))?.as_int() == Some(-42))
    assert(decode(encode(Value.Bool(true)))?.as_bool() == Some(true))
    assert(decode(encode(Value.Null))?.is_null())
}

test "roundtrip text" {
    let v = Value.Text("hello")
    assert(decode(encode(v))?.as_text() == Some("hello"))
}

test "roundtrip array" {
    let v = Value.Array([Value.UInt(1), Value.UInt(2), Value.UInt(3)])
    let decoded = decode(encode(v))?
    assert(decoded.as_array()?.len() == 3)
}

test "roundtrip map" {
    let v = Value.Map([
        (Value.Text("a"), Value.UInt(1)),
        (Value.Text("b"), Value.UInt(2))
    ])
    let decoded = decode(encode(v))?
    assert(decoded.get("a")?.as_uint() == Some(1))
}

test "canonical encoding" {
    let v = Value.Map([
        (Value.Text("bb"), Value.UInt(2)),
        (Value.Text("a"), Value.UInt(1))
    ])
    let canonical = encode_canonical(v)
    let normal = encode(v)
    // Canonical should have "a" before "bb" (shorter key first)
    assert(canonical != normal)
}
