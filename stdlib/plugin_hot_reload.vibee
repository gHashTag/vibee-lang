// =============================================================================
// Vibee OS â€” Plugin Hot Reload Module
// Hot reloading support for plugins during development
// =============================================================================

use result::{Result, Ok, Err}
use option::{Option, Some, None}
use plugin_api::{
    Plugin, PluginMetadata, PluginVersion, PluginState, PluginError,
    PluginEvent, PluginConfig, PluginContext
}
use plugin_registry::{PluginRegistry}
use plugin_loader::{PluginLoader, LoadedPluginModule}

// =============================================================================
// Hot Reload Configuration
// =============================================================================

/// Hot reload configuration
struct HotReloadConfig {
    enabled: Bool
    watch_interval_ms: Int
    debounce_ms: Int
    preserve_state: Bool
    auto_restart: Bool
    max_retries: Int
    retry_delay_ms: Int
    watch_patterns: [String]
    ignore_patterns: [String]
}

impl HotReloadConfig {
    fn default() -> Self {
        HotReloadConfig {
            enabled: true,
            watch_interval_ms: 500,
            debounce_ms: 100,
            preserve_state: true,
            auto_restart: true,
            max_retries: 3,
            retry_delay_ms: 1000,
            watch_patterns: ["*.vibee", "*.json", "*.toml"],
            ignore_patterns: ["*.tmp", "*.bak", ".git/*"]
        }
    }
    
    fn development() -> Self {
        HotReloadConfig {
            enabled: true,
            watch_interval_ms: 200,
            debounce_ms: 50,
            preserve_state: true,
            auto_restart: true,
            max_retries: 5,
            retry_delay_ms: 500,
            watch_patterns: ["*.vibee", "*.json"],
            ignore_patterns: ["*.tmp", ".git/*"]
        }
    }
    
    fn production() -> Self {
        HotReloadConfig {
            enabled: false,
            watch_interval_ms: 1000,
            debounce_ms: 500,
            preserve_state: true,
            auto_restart: false,
            max_retries: 1,
            retry_delay_ms: 5000,
            watch_patterns: [],
            ignore_patterns: ["*"]
        }
    }
}

// =============================================================================
// File Watcher
// =============================================================================

/// File change event
enum FileChangeEvent {
    Created(String)
    Modified(String)
    Deleted(String)
    Renamed(String, String)
}

/// File watcher for monitoring plugin files
struct FileWatcher {
    paths: Map<String, WatchedPath>
    callbacks: [fn(FileChangeEvent)]
    running: Bool
}

struct WatchedPath {
    path: String
    last_modified: Int64
    checksum: String
    is_directory: Bool
}

impl FileWatcher {
    fn new() -> Self {
        FileWatcher {
            paths: Map.new(),
            callbacks: [],
            running: false
        }
    }
    
    /// Add path to watch
    fn watch(path: String) -> Result<(), PluginError> {
        let info = self.get_file_info(path.clone())?
        
        self.paths.insert(path.clone(), WatchedPath {
            path: path,
            last_modified: info.modified_time,
            checksum: info.checksum,
            is_directory: info.is_directory
        })
        
        Ok(())
    }
    
    /// Remove path from watch
    fn unwatch(path: String) {
        self.paths.remove(path)
    }
    
    /// Add change callback
    fn on_change(callback: fn(FileChangeEvent)) {
        self.callbacks.push(callback)
    }
    
    /// Start watching
    async fn start(interval_ms: Int) {
        self.running = true
        
        while self.running {
            self.check_changes()
            Time.sleep(Duration.from_millis(interval_ms)).await
        }
    }
    
    /// Stop watching
    fn stop() {
        self.running = false
    }
    
    /// Check for file changes
    fn check_changes() {
        for (path, watched) in self.paths.iter_mut() {
            match self.get_file_info(path.clone()) {
                Ok(info) => {
                    if info.modified_time > watched.last_modified {
                        watched.last_modified = info.modified_time
                        watched.checksum = info.checksum.clone()
                        self.emit(FileChangeEvent.Modified(path.clone()))
                    }
                }
                Err(_) => {
                    // File might have been deleted
                    self.emit(FileChangeEvent.Deleted(path.clone()))
                }
            }
        }
    }
    
    fn emit(event: FileChangeEvent) {
        for callback in self.callbacks.iter() {
            callback(event.clone())
        }
    }
    
    fn get_file_info(path: String) -> Result<FileInfo, PluginError> {
        // Get file information
        Ok(FileInfo {
            modified_time: 0,
            checksum: "".to_string(),
            is_directory: false
        })
    }
}

struct FileInfo {
    modified_time: Int64
    checksum: String
    is_directory: Bool
}

// =============================================================================
// Hot Reload Manager
// =============================================================================

/// Hot reload manager for plugins
struct HotReloadManager {
    config: HotReloadConfig
    loader: PluginLoader
    watcher: FileWatcher
    watched_plugins: Map<String, WatchedPlugin>
    pending_reloads: Map<String, PendingReload>
    state_snapshots: Map<String, PluginStateSnapshot>
    callbacks: HotReloadCallbacks
}

/// Watched plugin information
struct WatchedPlugin {
    plugin_id: String
    paths: [String]
    last_reload: Int64
    reload_count: Int
    errors: [ReloadError]
}

/// Pending reload entry
struct PendingReload {
    plugin_id: String
    trigger_time: Int64
    reason: ReloadReason
    retry_count: Int
}

/// Reload reason
enum ReloadReason {
    FileChanged(String)
    ConfigChanged
    ManualTrigger
    DependencyReloaded(String)
    Error(String)
}

/// Reload error
struct ReloadError {
    timestamp: Int64
    message: String
    stack_trace: Option<String>
}

/// Plugin state snapshot for preservation
struct PluginStateSnapshot {
    plugin_id: String
    timestamp: Int64
    config: PluginConfig
    state_data: Map<String, [UInt8]>
    running: Bool
}

/// Hot reload callbacks
struct HotReloadCallbacks {
    before_reload: [fn(String)]
    after_reload: [fn(String, Result<(), PluginError>)]
    on_error: [fn(String, PluginError)]
}

impl HotReloadManager {
    fn new(loader: PluginLoader, config: HotReloadConfig) -> Self {
        HotReloadManager {
            config: config,
            loader: loader,
            watcher: FileWatcher.new(),
            watched_plugins: Map.new(),
            pending_reloads: Map.new(),
            state_snapshots: Map.new(),
            callbacks: HotReloadCallbacks {
                before_reload: [],
                after_reload: [],
                on_error: []
            }
        }
    }
    
    fn with_defaults(loader: PluginLoader) -> Self {
        Self.new(loader, HotReloadConfig.default())
    }
    
    // =========================================================================
    // Watch Management
    // =========================================================================
    
    /// Start watching a plugin for changes
    fn watch(plugin_id: String) -> Result<(), PluginError> {
        if !self.config.enabled {
            return Err(PluginError.ConfigurationError("Hot reload is disabled".to_string()))
        }
        
        // Get plugin paths
        let loaded = self.loader.get_loaded(plugin_id.clone())
            .ok_or(PluginError.NotFound(plugin_id.clone()))?
        
        // Watch plugin directory
        self.watcher.watch(loaded.path.clone())?
        
        // Watch individual files
        let files = self.get_plugin_files(loaded.path.clone())?
        for file in files.iter() {
            if self.should_watch(file.clone()) {
                self.watcher.watch(file.clone())?
            }
        }
        
        // Register watched plugin
        self.watched_plugins.insert(plugin_id.clone(), WatchedPlugin {
            plugin_id: plugin_id,
            paths: files,
            last_reload: Time.now().unix_millis(),
            reload_count: 0,
            errors: []
        })
        
        Ok(())
    }
    
    /// Stop watching a plugin
    fn unwatch(plugin_id: String) {
        if let Some(watched) = self.watched_plugins.remove(plugin_id.clone()) {
            for path in watched.paths.iter() {
                self.watcher.unwatch(path.clone())
            }
        }
    }
    
    /// Check if file should be watched
    fn should_watch(path: String) -> Bool {
        // Check ignore patterns
        for pattern in self.config.ignore_patterns.iter() {
            if self.matches_pattern(path.clone(), pattern.clone()) {
                return false
            }
        }
        
        // Check watch patterns
        for pattern in self.config.watch_patterns.iter() {
            if self.matches_pattern(path.clone(), pattern.clone()) {
                return true
            }
        }
        
        false
    }
    
    fn matches_pattern(path: String, pattern: String) -> Bool {
        // Simple glob matching
        if pattern == "*" { return true }
        if pattern.starts_with("*.") {
            let ext = pattern[1..].to_string()
            return path.ends_with(ext)
        }
        path.contains(pattern)
    }
    
    // =========================================================================
    // Reload Operations
    // =========================================================================
    
    /// Trigger reload for a plugin
    fn reload(plugin_id: String) -> Result<(), PluginError> {
        self.reload_with_reason(plugin_id, ReloadReason.ManualTrigger)
    }
    
    /// Trigger reload with specific reason
    fn reload_with_reason(plugin_id: String, reason: ReloadReason) -> Result<(), PluginError> {
        // Emit before reload callbacks
        for callback in self.callbacks.before_reload.iter() {
            callback(plugin_id.clone())
        }
        
        // Snapshot state if preservation enabled
        if self.config.preserve_state {
            self.snapshot_state(plugin_id.clone())?
        }
        
        // Perform reload
        let result = self.perform_reload(plugin_id.clone())
        
        // Restore state if preservation enabled
        if self.config.preserve_state && result.is_ok() {
            self.restore_state(plugin_id.clone())?
        }
        
        // Update watched plugin info
        if let Some(watched) = self.watched_plugins.get_mut(plugin_id.clone()) {
            watched.last_reload = Time.now().unix_millis()
            watched.reload_count += 1
            
            if let Err(ref e) = result {
                watched.errors.push(ReloadError {
                    timestamp: Time.now().unix_millis(),
                    message: e.message(),
                    stack_trace: None
                })
            }
        }
        
        // Emit after reload callbacks
        for callback in self.callbacks.after_reload.iter() {
            callback(plugin_id.clone(), result.clone())
        }
        
        // Emit error callbacks if failed
        if let Err(ref e) = result {
            for callback in self.callbacks.on_error.iter() {
                callback(plugin_id.clone(), e.clone())
            }
        }
        
        result
    }
    
    /// Perform the actual reload
    fn perform_reload(plugin_id: String) -> Result<(), PluginError> {
        var retries = 0
        
        loop {
            match self.loader.reload(plugin_id.clone()) {
                Ok(()) => {
                    // Reload dependents if needed
                    self.reload_dependents(plugin_id.clone())?
                    return Ok(())
                }
                Err(e) => {
                    retries += 1
                    if retries >= self.config.max_retries {
                        return Err(e)
                    }
                    Time.sleep(Duration.from_millis(self.config.retry_delay_ms))
                }
            }
        }
    }
    
    /// Reload plugins that depend on the given plugin
    fn reload_dependents(plugin_id: String) -> Result<(), PluginError> {
        let dependents = self.loader.get_dependents(plugin_id.clone())
        
        for dep_id in dependents.iter() {
            if self.watched_plugins.contains_key(dep_id.clone()) {
                self.reload_with_reason(
                    dep_id.clone(),
                    ReloadReason.DependencyReloaded(plugin_id.clone())
                )?
            }
        }
        
        Ok(())
    }
    
    // =========================================================================
    // State Management
    // =========================================================================
    
    /// Snapshot plugin state before reload
    fn snapshot_state(plugin_id: String) -> Result<(), PluginError> {
        let entry = self.loader.registry().get(plugin_id.clone())
            .ok_or(PluginError.NotFound(plugin_id.clone()))?
        
        // Get state data from plugin if it supports it
        var state_data: Map<String, [UInt8]> = Map.new()
        
        if let Some(ref instance) = entry.instance {
            if let Some(stateful) = instance.as_stateful() {
                state_data = stateful.export_state()
            }
        }
        
        let snapshot = PluginStateSnapshot {
            plugin_id: plugin_id.clone(),
            timestamp: Time.now().unix_millis(),
            config: entry.config.clone(),
            state_data: state_data,
            running: entry.state == PluginState.Running
        }
        
        self.state_snapshots.insert(plugin_id, snapshot)
        
        Ok(())
    }
    
    /// Restore plugin state after reload
    fn restore_state(plugin_id: String) -> Result<(), PluginError> {
        let snapshot = self.state_snapshots.remove(plugin_id.clone())
            .ok_or(PluginError.NotFound(format!("No snapshot for {}", plugin_id)))?
        
        // Restore config
        if let Some(entry) = self.loader.registry().plugins.get_mut(plugin_id.clone()) {
            entry.config = snapshot.config
        }
        
        // Restore state data
        let entry = self.loader.registry().get(plugin_id.clone())
            .ok_or(PluginError.NotFound(plugin_id.clone()))?
        
        if let Some(ref instance) = entry.instance {
            if let Some(stateful) = instance.as_stateful() {
                stateful.import_state(snapshot.state_data)?
            }
        }
        
        // Restart if was running
        if snapshot.running && self.config.auto_restart {
            self.loader.registry().start(plugin_id)?
        }
        
        Ok(())
    }
    
    // =========================================================================
    // Event Loop
    // =========================================================================
    
    /// Start the hot reload event loop
    async fn start() {
        if !self.config.enabled {
            return
        }
        
        // Set up file change handler
        self.watcher.on_change(|event| {
            self.handle_file_change(event)
        })
        
        // Start file watcher
        self.watcher.start(self.config.watch_interval_ms).await
        
        // Process pending reloads
        self.process_pending_reloads().await
    }
    
    /// Stop the hot reload event loop
    fn stop() {
        self.watcher.stop()
    }
    
    /// Handle file change event
    fn handle_file_change(event: FileChangeEvent) {
        let path = match event {
            FileChangeEvent.Created(p) => p,
            FileChangeEvent.Modified(p) => p,
            FileChangeEvent.Deleted(p) => p,
            FileChangeEvent.Renamed(_, p) => p
        }
        
        // Find plugin for this path
        for (plugin_id, watched) in self.watched_plugins.iter() {
            if watched.paths.contains(path.clone()) {
                self.schedule_reload(plugin_id.clone(), ReloadReason.FileChanged(path.clone()))
                break
            }
        }
    }
    
    /// Schedule a reload with debouncing
    fn schedule_reload(plugin_id: String, reason: ReloadReason) {
        let now = Time.now().unix_millis()
        
        // Check if already pending
        if let Some(pending) = self.pending_reloads.get(plugin_id.clone()) {
            // Update if within debounce window
            if now - pending.trigger_time < self.config.debounce_ms {
                return
            }
        }
        
        self.pending_reloads.insert(plugin_id.clone(), PendingReload {
            plugin_id: plugin_id,
            trigger_time: now,
            reason: reason,
            retry_count: 0
        })
    }
    
    /// Process pending reloads
    async fn process_pending_reloads() {
        loop {
            let now = Time.now().unix_millis()
            var to_reload: [String] = []
            
            for (plugin_id, pending) in self.pending_reloads.iter() {
                if now - pending.trigger_time >= self.config.debounce_ms {
                    to_reload.push(plugin_id.clone())
                }
            }
            
            for plugin_id in to_reload.iter() {
                if let Some(pending) = self.pending_reloads.remove(plugin_id.clone()) {
                    let _ = self.reload_with_reason(plugin_id.clone(), pending.reason)
                }
            }
            
            Time.sleep(Duration.from_millis(50)).await
        }
    }
    
    // =========================================================================
    // Callbacks
    // =========================================================================
    
    /// Register before reload callback
    fn on_before_reload(callback: fn(String)) {
        self.callbacks.before_reload.push(callback)
    }
    
    /// Register after reload callback
    fn on_after_reload(callback: fn(String, Result<(), PluginError>)) {
        self.callbacks.after_reload.push(callback)
    }
    
    /// Register error callback
    fn on_error(callback: fn(String, PluginError)) {
        self.callbacks.on_error.push(callback)
    }
    
    // =========================================================================
    // Helper Methods
    // =========================================================================
    
    fn get_plugin_files(path: String) -> Result<[String], PluginError> {
        // List all files in plugin directory
        Ok([])
    }
    
    /// Get reload statistics
    fn stats() -> HotReloadStats {
        var total_reloads = 0
        var total_errors = 0
        
        for (_, watched) in self.watched_plugins.iter() {
            total_reloads += watched.reload_count
            total_errors += watched.errors.len()
        }
        
        HotReloadStats {
            watched_plugins: self.watched_plugins.len(),
            total_reloads: total_reloads,
            total_errors: total_errors,
            pending_reloads: self.pending_reloads.len()
        }
    }
}

/// Hot reload statistics
struct HotReloadStats {
    watched_plugins: Int
    total_reloads: Int
    total_errors: Int
    pending_reloads: Int
}

// =============================================================================
// Stateful Plugin Trait
// =============================================================================

/// Trait for plugins that support state preservation
trait StatefulPlugin: Plugin {
    /// Export plugin state for preservation
    fn export_state() -> Map<String, [UInt8]>
    
    /// Import plugin state after reload
    fn import_state(state: Map<String, [UInt8]>) -> Result<(), PluginError>
    
    /// Get state version for compatibility checking
    fn state_version() -> Int { 1 }
}

// =============================================================================
// Hot Reload Actor
// =============================================================================

/// Thread-safe hot reload actor
actor HotReloadActor {
    manager: HotReloadManager
    
    fn new(loader: PluginLoader, config: HotReloadConfig) -> Self {
        HotReloadActor {
            manager: HotReloadManager.new(loader, config)
        }
    }
    
    async fn watch(plugin_id: String) -> Result<(), PluginError> {
        self.manager.watch(plugin_id)
    }
    
    async fn unwatch(plugin_id: String) {
        self.manager.unwatch(plugin_id)
    }
    
    async fn reload(plugin_id: String) -> Result<(), PluginError> {
        self.manager.reload(plugin_id)
    }
    
    async fn start() {
        self.manager.start().await
    }
    
    async fn stop() {
        self.manager.stop()
    }
    
    async fn stats() -> HotReloadStats {
        self.manager.stats()
    }
}

// =============================================================================
// Development Server Integration
// =============================================================================

/// Development server with hot reload support
struct DevServer {
    hot_reload: HotReloadManager
    port: Int
    running: Bool
}

impl DevServer {
    fn new(loader: PluginLoader, port: Int) -> Self {
        DevServer {
            hot_reload: HotReloadManager.new(loader, HotReloadConfig.development()),
            port: port,
            running: false
        }
    }
    
    /// Start development server
    async fn start() {
        self.running = true
        
        println!("ðŸ”¥ Hot reload enabled")
        println!("ðŸ“ Watching for file changes...")
        
        // Start hot reload
        self.hot_reload.start().await
    }
    
    /// Stop development server
    fn stop() {
        self.running = false
        self.hot_reload.stop()
        println!("Development server stopped")
    }
    
    /// Watch plugin for hot reload
    fn watch(plugin_id: String) -> Result<(), PluginError> {
        self.hot_reload.watch(plugin_id.clone())?
        println!("ðŸ‘€ Watching plugin: {}", plugin_id)
        Ok(())
    }
}

// =============================================================================
// Tests
// =============================================================================

test "hot reload config" {
    let dev = HotReloadConfig.development()
    assert(dev.enabled)?
    assert_eq(dev.watch_interval_ms, 200)?
    
    let prod = HotReloadConfig.production()
    assert(!prod.enabled)?
}

test "file watcher" {
    var watcher = FileWatcher.new()
    var changes: [FileChangeEvent] = []
    
    watcher.on_change(|e| changes.push(e))
    watcher.watch("/test/file.vibee")?
    
    assert_eq(watcher.paths.len(), 1)?
}

test "pattern matching" {
    let manager = HotReloadManager.with_defaults(PluginLoader.with_defaults())
    
    assert(manager.should_watch("plugin.vibee"))?
    assert(manager.should_watch("config.json"))?
    assert(!manager.should_watch("file.tmp"))?
    assert(!manager.should_watch(".git/config"))?
}

test "reload scheduling" {
    var manager = HotReloadManager.with_defaults(PluginLoader.with_defaults())
    
    manager.schedule_reload("test-plugin", ReloadReason.ManualTrigger)
    assert_eq(manager.pending_reloads.len(), 1)?
    
    // Duplicate within debounce window should not add
    manager.schedule_reload("test-plugin", ReloadReason.ManualTrigger)
    assert_eq(manager.pending_reloads.len(), 1)?
}

test "state snapshot" {
    var manager = HotReloadManager.with_defaults(PluginLoader.with_defaults())
    
    let snapshot = PluginStateSnapshot {
        plugin_id: "test".to_string(),
        timestamp: Time.now().unix_millis(),
        config: PluginConfig.empty(),
        state_data: Map.new(),
        running: true
    }
    
    manager.state_snapshots.insert("test", snapshot)
    assert(manager.state_snapshots.contains_key("test"))?
}

test "hot reload stats" {
    let manager = HotReloadManager.with_defaults(PluginLoader.with_defaults())
    let stats = manager.stats()
    
    assert_eq(stats.watched_plugins, 0)?
    assert_eq(stats.total_reloads, 0)?
}
