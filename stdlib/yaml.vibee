// =============================================================================
// Vibee OS â€” YAML Module
// YAML parsing and generation
// =============================================================================

// -----------------------------------------------------------------------------
// YAML Value
// -----------------------------------------------------------------------------

/// YAML value type
enum Value {
    Null
    Bool(Bool)
    Int(Int)
    Float(Float)
    String(String)
    Array([Value])
    Map(Map<String, Value>)
    
    /// Parse YAML string
    fn parse(yaml: String) -> Result<Value, YAMLError> {
        Parser.new(yaml).parse()
    }
    
    /// Parse file
    fn parse_file(path: String) -> Result<Value, YAMLError> {
        let content = File.read_string(path)?
        Self.parse(content)
    }
    
    /// Parse multiple documents
    fn parse_all(yaml: String) -> Result<[Value], YAMLError> {
        Parser.new(yaml).parse_all()
    }
    
    // Type checks
    fn is_null() -> Bool { match self { .Null => true, _ => false } }
    fn is_bool() -> Bool { match self { .Bool(_) => true, _ => false } }
    fn is_int() -> Bool { match self { .Int(_) => true, _ => false } }
    fn is_float() -> Bool { match self { .Float(_) => true, _ => false } }
    fn is_string() -> Bool { match self { .String(_) => true, _ => false } }
    fn is_array() -> Bool { match self { .Array(_) => true, _ => false } }
    fn is_map() -> Bool { match self { .Map(_) => true, _ => false } }
    
    // Value extraction
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    fn as_int() -> Option<Int> { match self { .Int(i) => Some(i), _ => None } }
    fn as_float() -> Option<Float> { match self { .Float(f) => Some(f), _ => None } }
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_array() -> Option<[Value]> { match self { .Array(a) => Some(a), _ => None } }
    fn as_map() -> Option<Map<String, Value>> { match self { .Map(m) => Some(m), _ => None } }
    
    /// Get by key (for maps)
    fn get(key: String) -> Option<Value> {
        match self {
            .Map(m) => m.get(key)
            _ => None
        }
    }
    
    /// Get by index (for arrays)
    fn at(index: Int) -> Option<Value> {
        match self {
            .Array(a) if index >= 0 && index < a.len() => Some(a[index])
            _ => None
        }
    }
    
    /// Get nested value by path
    fn path(p: String) -> Option<Value> {
        let parts = p.split(".")
        var current = self
        
        for part in parts {
            if let idx = Int.parse(part) {
                current = current.at(idx)?
            } else {
                current = current.get(part)?
            }
        }
        
        Some(current)
    }
    
    /// Convert to YAML string
    fn to_yaml() -> String {
        Emitter.new().emit(self)
    }
    
    /// Deserialize to type
    fn deserialize<T: Deserialize>() -> Result<T, YAMLError> {
        T.from_yaml(self)
    }
}

// Index access
impl Index<String> for Value {
    type Output = Option<Value>
    fn index(key: String) -> Option<Value> { self.get(key) }
}

impl Index<Int> for Value {
    type Output = Option<Value>
    fn index(idx: Int) -> Option<Value> { self.at(idx) }
}

// -----------------------------------------------------------------------------
// YAML Parser
// -----------------------------------------------------------------------------

actor Parser {
    state input: String
    state pos: Int
    state line: Int
    state indent_stack: [Int]
    
    fn new(input: String) -> Self {
        Parser {
            input: input,
            pos: 0,
            line: 1,
            indent_stack: [0]
        }
    }
    
    fn parse() -> Result<Value, YAMLError> {
        self.skip_whitespace_and_comments()
        self.parse_value(0)
    }
    
    fn parse_all() -> Result<[Value], YAMLError> {
        var docs = []
        
        while self.pos < self.input.len() {
            self.skip_whitespace_and_comments()
            
            if self.peek_str("---") {
                self.advance(3)
                self.skip_line()
            }
            
            if self.pos >= self.input.len() { break }
            
            docs.append(self.parse_value(0)?)
            
            if self.peek_str("...") {
                self.advance(3)
                self.skip_line()
            }
        }
        
        Ok(docs)
    }
    
    fn parse_value(min_indent: Int) -> Result<Value, YAMLError> {
        self.skip_whitespace_inline()
        
        if self.pos >= self.input.len() {
            return Ok(Value.Null)
        }
        
        let c = self.current_char()
        
        match c {
            '-' if self.peek_str("- ") || self.peek_str("-\n") => self.parse_array(min_indent)
            '[' => self.parse_flow_array()
            '{' => self.parse_flow_map()
            '"' => self.parse_double_quoted()
            '\'' => self.parse_single_quoted()
            '|' => self.parse_literal_block()
            '>' => self.parse_folded_block()
            '&' => self.parse_anchor()
            '*' => self.parse_alias()
            '!' => self.parse_tagged()
            _ => {
                // Check if it's a map key
                if let Some(key_end) = self.find_colon() {
                    self.parse_map(min_indent)
                } else {
                    self.parse_scalar()
                }
            }
        }
    }
    
    fn parse_scalar() -> Result<Value, YAMLError> {
        let start = self.pos
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c == '\n' || c == '#' { break }
            self.pos += 1
        }
        
        let value = self.input[start..self.pos].trim()
        Ok(self.interpret_scalar(value))
    }
    
    fn interpret_scalar(s: String) -> Value {
        match s.to_lower() {
            "" | "null" | "~" => Value.Null
            "true" | "yes" | "on" => Value.Bool(true)
            "false" | "no" | "off" => Value.Bool(false)
            _ => {
                if let Ok(i) = Int.parse(s) {
                    Value.Int(i)
                } else if let Ok(f) = Float.parse(s) {
                    Value.Float(f)
                } else {
                    Value.String(s)
                }
            }
        }
    }
    
    fn parse_double_quoted() -> Result<Value, YAMLError> {
        self.expect("\"")?
        var result = StringBuilder.new()
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            self.pos += 1
            
            if c == '"' { return Ok(Value.String(result.build())) }
            if c == '\\' {
                let escaped = self.parse_escape()?
                result.append(escaped)
            } else {
                result.append(c)
            }
        }
        
        Err(YAMLError.UnterminatedString(self.line))
    }
    
    fn parse_single_quoted() -> Result<Value, YAMLError> {
        self.expect("'")?
        var result = StringBuilder.new()
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            self.pos += 1
            
            if c == '\'' {
                if self.peek_char() == Some('\'') {
                    self.pos += 1
                    result.append('\'')
                } else {
                    return Ok(Value.String(result.build()))
                }
            } else {
                result.append(c)
            }
        }
        
        Err(YAMLError.UnterminatedString(self.line))
    }
    
    fn parse_array(min_indent: Int) -> Result<Value, YAMLError> {
        var items = []
        let array_indent = self.current_indent()
        
        while self.pos < self.input.len() {
            let indent = self.current_indent()
            if indent < array_indent { break }
            
            if !self.peek_str("- ") && !self.peek_str("-\n") { break }
            
            self.advance(1)  // Skip '-'
            self.skip_whitespace_inline()
            
            let value = self.parse_value(indent + 1)?
            items.append(value)
            
            self.skip_whitespace_and_comments()
        }
        
        Ok(Value.Array(items))
    }
    
    fn parse_map(min_indent: Int) -> Result<Value, YAMLError> {
        var map = Map.empty()
        let map_indent = self.current_indent()
        
        while self.pos < self.input.len() {
            self.skip_whitespace_and_comments()
            
            let indent = self.current_indent()
            if indent < map_indent { break }
            
            let key = self.parse_key()?
            self.expect(":")?
            self.skip_whitespace_inline()
            
            let value = if self.peek_char() == Some('\n') {
                self.skip_line()
                self.skip_whitespace_and_comments()
                self.parse_value(indent + 1)?
            } else {
                self.parse_value(indent)?
            }
            
            map.set(key, value)
        }
        
        Ok(Value.Map(map))
    }
    
    fn parse_key() -> Result<String, YAMLError> {
        let start = self.pos
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c == ':' { break }
            self.pos += 1
        }
        
        Ok(self.input[start..self.pos].trim())
    }
    
    fn parse_flow_array() -> Result<Value, YAMLError> {
        self.expect("[")?
        var items = []
        
        self.skip_whitespace_and_comments()
        
        while self.peek_char() != Some(']') {
            let value = self.parse_flow_value()?
            items.append(value)
            
            self.skip_whitespace_and_comments()
            if self.peek_char() == Some(',') {
                self.advance(1)
                self.skip_whitespace_and_comments()
            }
        }
        
        self.expect("]")?
        Ok(Value.Array(items))
    }
    
    fn parse_flow_map() -> Result<Value, YAMLError> {
        self.expect("{")?
        var map = Map.empty()
        
        self.skip_whitespace_and_comments()
        
        while self.peek_char() != Some('}') {
            let key = self.parse_flow_key()?
            self.skip_whitespace_and_comments()
            self.expect(":")?
            self.skip_whitespace_and_comments()
            let value = self.parse_flow_value()?
            
            map.set(key, value)
            
            self.skip_whitespace_and_comments()
            if self.peek_char() == Some(',') {
                self.advance(1)
                self.skip_whitespace_and_comments()
            }
        }
        
        self.expect("}")?
        Ok(Value.Map(map))
    }
    
    fn parse_flow_value() -> Result<Value, YAMLError> {
        self.skip_whitespace_inline()
        
        match self.peek_char() {
            Some('[') => self.parse_flow_array()
            Some('{') => self.parse_flow_map()
            Some('"') => self.parse_double_quoted()
            Some('\'') => self.parse_single_quoted()
            _ => self.parse_flow_scalar()
        }
    }
    
    fn parse_flow_scalar() -> Result<Value, YAMLError> {
        let start = self.pos
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c == ',' || c == ']' || c == '}' || c == '\n' { break }
            self.pos += 1
        }
        
        let value = self.input[start..self.pos].trim()
        Ok(self.interpret_scalar(value))
    }
    
    fn parse_flow_key() -> Result<String, YAMLError> {
        match self.peek_char() {
            Some('"') => self.parse_double_quoted()?.as_str().ok_or(YAMLError.InvalidKey(self.line))
            Some('\'') => self.parse_single_quoted()?.as_str().ok_or(YAMLError.InvalidKey(self.line))
            _ => {
                let start = self.pos
                while self.pos < self.input.len() {
                    let c = self.input[self.pos]
                    if c == ':' || c == ',' || c == '}' { break }
                    self.pos += 1
                }
                Ok(self.input[start..self.pos].trim())
            }
        }
    }
    
    fn parse_literal_block() -> Result<Value, YAMLError> {
        self.expect("|")?
        let chomping = self.parse_block_header()
        self.skip_line()
        
        let indent = self.detect_block_indent()
        var lines = []
        
        while self.pos < self.input.len() {
            let line_indent = self.current_indent()
            if line_indent < indent && !self.is_blank_line() { break }
            
            let line = self.read_line()
            if line_indent >= indent {
                lines.append(line[indent..])
            } else {
                lines.append("")
            }
        }
        
        let content = lines.join("\n")
        Ok(Value.String(self.apply_chomping(content, chomping)))
    }
    
    fn parse_folded_block() -> Result<Value, YAMLError> {
        self.expect(">")?
        let chomping = self.parse_block_header()
        self.skip_line()
        
        let indent = self.detect_block_indent()
        var paragraphs = []
        var current = []
        
        while self.pos < self.input.len() {
            let line_indent = self.current_indent()
            if line_indent < indent && !self.is_blank_line() { break }
            
            let line = self.read_line()
            if line.trim().is_empty() {
                if !current.is_empty() {
                    paragraphs.append(current.join(" "))
                    current = []
                }
                paragraphs.append("")
            } else {
                current.append(line[indent..].trim())
            }
        }
        
        if !current.is_empty() {
            paragraphs.append(current.join(" "))
        }
        
        let content = paragraphs.join("\n")
        Ok(Value.String(self.apply_chomping(content, chomping)))
    }
    
    fn parse_block_header() -> Chomping {
        match self.peek_char() {
            Some('-') => { self.advance(1); Chomping.Strip }
            Some('+') => { self.advance(1); Chomping.Keep }
            _ => Chomping.Clip
        }
    }
    
    fn apply_chomping(s: String, chomping: Chomping) -> String {
        match chomping {
            .Strip => s.trim_end("\n")
            .Clip => s.trim_end("\n") + "\n"
            .Keep => s
        }
    }
    
    // Helper methods
    fn current_char() -> Char { self.input[self.pos] }
    fn peek_char() -> Option<Char> {
        if self.pos < self.input.len() { Some(self.input[self.pos]) } else { None }
    }
    fn peek_str(s: String) -> Bool { self.input[self.pos..].starts_with(s) }
    fn advance(n: Int) { self.pos += n }
    fn expect(s: String) -> Result<(), YAMLError> {
        if self.peek_str(s) { self.advance(s.len()); Ok(()) }
        else { Err(YAMLError.Expected(s, self.line)) }
    }
    
    fn current_indent() -> Int {
        var indent = 0
        var p = self.pos
        while p > 0 && self.input[p - 1] != '\n' { p -= 1 }
        while p < self.input.len() && self.input[p] == ' ' { indent += 1; p += 1 }
        indent
    }
    
    fn skip_whitespace_inline() {
        while self.pos < self.input.len() && self.input[self.pos] == ' ' { self.pos += 1 }
    }
    
    fn skip_whitespace_and_comments() {
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
                if c == '\n' { self.line += 1 }
                self.pos += 1
            } else if c == '#' {
                while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1 }
            } else { break }
        }
    }
    
    fn skip_line() {
        while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1 }
        if self.pos < self.input.len() { self.pos += 1; self.line += 1 }
    }
    
    fn read_line() -> String {
        let start = self.pos
        while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1 }
        let line = self.input[start..self.pos]
        if self.pos < self.input.len() { self.pos += 1; self.line += 1 }
        line
    }
    
    fn is_blank_line() -> Bool {
        var p = self.pos
        while p < self.input.len() && self.input[p] != '\n' {
            if self.input[p] != ' ' && self.input[p] != '\t' { return false }
            p += 1
        }
        true
    }
    
    fn detect_block_indent() -> Int {
        var p = self.pos
        while p < self.input.len() && (self.input[p] == ' ' || self.input[p] == '\n') { p += 1 }
        var indent = 0
        while p > 0 && self.input[p - 1] == ' ' { indent += 1; p -= 1 }
        indent
    }
    
    fn find_colon() -> Option<Int> {
        var p = self.pos
        while p < self.input.len() {
            let c = self.input[p]
            if c == ':' { return Some(p) }
            if c == '\n' { return None }
            p += 1
        }
        None
    }
    
    fn parse_escape() -> Result<Char, YAMLError> {
        let c = self.input[self.pos]
        self.pos += 1
        match c {
            'n' => Ok('\n')
            't' => Ok('\t')
            'r' => Ok('\r')
            '\\' => Ok('\\')
            '"' => Ok('"')
            '0' => Ok('\0')
            _ => Ok(c)
        }
    }
    
    fn parse_anchor() -> Result<Value, YAMLError> { Err(YAMLError.NotImplemented("anchors")) }
    fn parse_alias() -> Result<Value, YAMLError> { Err(YAMLError.NotImplemented("aliases")) }
    fn parse_tagged() -> Result<Value, YAMLError> { Err(YAMLError.NotImplemented("tags")) }
}

enum Chomping { Strip, Clip, Keep }

// -----------------------------------------------------------------------------
// YAML Emitter
// -----------------------------------------------------------------------------

actor Emitter {
    state indent: String
    state current_indent: Int
    
    fn new() -> Self { Emitter { indent: "  ", current_indent: 0 } }
    
    fn emit(value: Value) -> String {
        self.emit_value(value, 0)
    }
    
    fn emit_value(value: Value, indent: Int) -> String {
        match value {
            .Null => "null"
            .Bool(b) => if b { "true" } else { "false" }
            .Int(i) => "\(i)"
            .Float(f) => "\(f)"
            .String(s) => self.emit_string(s)
            .Array(a) => self.emit_array(a, indent)
            .Map(m) => self.emit_map(m, indent)
        }
    }
    
    fn emit_string(s: String) -> String {
        if s.contains("\n") || s.contains(":") || s.contains("#") ||
           s.starts_with(" ") || s.ends_with(" ") {
            "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n") + "\""
        } else { s }
    }
    
    fn emit_array(arr: [Value], indent: Int) -> String {
        if arr.is_empty() { return "[]" }
        let prefix = self.indent.repeat(indent)
        arr.map(|v| "\(prefix)- \(self.emit_value(v, indent + 1))").join("\n")
    }
    
    fn emit_map(map: Map<String, Value>, indent: Int) -> String {
        if map.is_empty() { return "{}" }
        let prefix = self.indent.repeat(indent)
        map.map(|(k, v)| {
            let val = self.emit_value(v, indent + 1)
            if v.is_map() || v.is_array() {
                "\(prefix)\(k):\n\(val)"
            } else {
                "\(prefix)\(k): \(val)"
            }
        }).join("\n")
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn parse(yaml: String) -> Result<Value, YAMLError> { Value.parse(yaml) }
fn parse_file(path: String) -> Result<Value, YAMLError> { Value.parse_file(path) }
fn stringify(value: Value) -> String { value.to_yaml() }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum YAMLError {
    UnterminatedString(Int)
    Expected(String, Int)
    InvalidKey(Int)
    NotImplemented(String)
    IOError(String)
    
    fn message() -> String {
        match self {
            .UnterminatedString(l) => "Unterminated string at line \(l)"
            .Expected(s, l) => "Expected '\(s)' at line \(l)"
            .InvalidKey(l) => "Invalid key at line \(l)"
            .NotImplemented(f) => "Not implemented: \(f)"
            .IOError(m) => "I/O error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse scalar" {
    assert(parse("hello")?.as_str() == Some("hello"))
    assert(parse("42")?.as_int() == Some(42))
    assert(parse("true")?.as_bool() == Some(true))
}

test "parse map" {
    let yaml = "name: Alice\nage: 30"
    let v = parse(yaml)?
    assert(v["name"]?.as_str() == Some("Alice"))
    assert(v["age"]?.as_int() == Some(30))
}

test "parse array" {
    let yaml = "- one\n- two\n- three"
    let v = parse(yaml)?
    assert(v[0]?.as_str() == Some("one"))
    assert(v[2]?.as_str() == Some("three"))
}
