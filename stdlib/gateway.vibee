// =============================================================================
// Vibee OS â€” Gateway Module
// IoT gateway for device management, protocol translation, and edge computing
// =============================================================================

// -----------------------------------------------------------------------------
// Gateway Core
// -----------------------------------------------------------------------------

/// IoT Gateway actor
actor Gateway {
    state id: String
    state config: GatewayConfig
    state devices: Map<String, ConnectedDevice>
    state protocol_handlers: Map<String, Box<dyn ProtocolHandler>>
    state upstream: Option<UpstreamConnection>
    state status: GatewayStatus
    state message_queue: [GatewayMessage]
    state edge_modules: Map<String, Box<dyn EdgeModule>>
    
    fn new(id: String, config: GatewayConfig) -> Self {
        Gateway {
            id: id,
            config: config,
            devices: Map.empty(),
            protocol_handlers: Map.empty(),
            upstream: None,
            status: GatewayStatus.Stopped,
            message_queue: [],
            edge_modules: Map.empty()
        }
    }
    
    /// Start the gateway
    on start() -> Result<(), GatewayError> {
        self.status = GatewayStatus.Starting
        
        // Initialize protocol handlers
        for (name, handler) in self.protocol_handlers {
            handler.start()?
        }
        
        // Connect to upstream
        if let Some(upstream_config) = self.config.upstream {
            self.upstream = Some(UpstreamConnection.connect(upstream_config)?)
        }
        
        // Start message processing
        self.start_message_loop()
        
        // Start edge modules
        for (name, module) in self.edge_modules {
            module.start()?
        }
        
        self.status = GatewayStatus.Running
        Ok(())
    }
    
    /// Stop the gateway
    on stop() -> Result<(), GatewayError> {
        self.status = GatewayStatus.Stopping
        
        // Stop edge modules
        for (_, module) in self.edge_modules {
            module.stop()?
        }
        
        // Disconnect upstream
        if let Some(upstream) = self.upstream {
            upstream.disconnect()?
        }
        
        // Stop protocol handlers
        for (_, handler) in self.protocol_handlers {
            handler.stop()?
        }
        
        self.status = GatewayStatus.Stopped
        Ok(())
    }
    
    /// Register a protocol handler
    on register_protocol<P: ProtocolHandler>(name: String, handler: P) {
        self.protocol_handlers.set(name, Box.new(handler))
    }
    
    /// Register an edge module
    on register_edge_module<M: EdgeModule>(name: String, module: M) {
        self.edge_modules.set(name, Box.new(module))
    }
    
    /// Register a device
    on register_device(device: ConnectedDevice) -> Result<(), GatewayError> {
        if self.devices.len() >= self.config.max_devices {
            return Err(GatewayError.DeviceLimitReached)
        }
        self.devices.set(device.id.clone(), device)
        Ok(())
    }
    
    /// Unregister a device
    on unregister_device(device_id: String) {
        self.devices.remove(device_id)
    }
    
    /// Get connected device
    on get_device(device_id: String) -> Option<ConnectedDevice> {
        self.devices.get(device_id)
    }
    
    /// List all connected devices
    on list_devices() -> [ConnectedDevice] {
        self.devices.values().collect()
    }
    
    /// Send message to device
    on send_to_device(device_id: String, message: DeviceMessage) -> Result<(), GatewayError> {
        let device = self.devices.get(device_id).ok_or(GatewayError.DeviceNotFound(device_id))?
        let handler = self.protocol_handlers.get(device.protocol)
            .ok_or(GatewayError.ProtocolNotSupported(device.protocol))?
        handler.send(device, message)
    }
    
    /// Send message upstream
    on send_upstream(message: UpstreamMessage) -> Result<(), GatewayError> {
        let upstream = self.upstream.as_ref().ok_or(GatewayError.NotConnected)?
        upstream.send(message)
    }
    
    /// Process incoming device message
    on process_device_message(device_id: String, message: DeviceMessage) {
        // Run through edge modules
        var processed_message = message
        for (_, module) in self.edge_modules {
            if let Some(msg) = module.process(device_id, processed_message) {
                processed_message = msg
            } else {
                return  // Message filtered out
            }
        }
        
        // Queue for upstream
        self.message_queue.push(GatewayMessage {
            device_id: device_id,
            message: processed_message,
            timestamp: @native("timestamp_ms")
        })
    }
    
    fn start_message_loop() {
        async {
            while self.status == GatewayStatus.Running {
                if !self.message_queue.is_empty() && self.upstream.is_some() {
                    let messages = self.message_queue.drain(..).collect()
                    let batch = UpstreamMessage.Batch(messages)
                    let _ = self.send_upstream(batch)
                }
                @native("sleep_ms", 100)
            }
        }
    }
    
    fn status() -> GatewayStatus { self.status }
}

/// Gateway configuration
struct GatewayConfig {
    max_devices: Int
    upstream: Option<UpstreamConfig>
    store_and_forward: Bool
    buffer_size: Int
    heartbeat_interval_ms: Int64
    
    fn new() -> Self {
        GatewayConfig {
            max_devices: 1000,
            upstream: None,
            store_and_forward: true,
            buffer_size: 10000,
            heartbeat_interval_ms: 30000
        }
    }
    
    fn with_upstream(config: UpstreamConfig) -> Self {
        self.upstream = Some(config)
        self
    }
    
    fn with_max_devices(max: Int) -> Self {
        self.max_devices = max
        self
    }
}

enum GatewayStatus { Stopped, Starting, Running, Stopping, Error(String) }

// -----------------------------------------------------------------------------
// Connected Devices
// -----------------------------------------------------------------------------

/// Device connected to gateway
struct ConnectedDevice {
    id: String
    name: String
    protocol: String
    address: String
    metadata: Map<String, String>
    last_seen: Int64
    status: DeviceConnectionStatus
    
    fn new(id: String, protocol: String, address: String) -> Self {
        ConnectedDevice {
            id: id,
            name: id.clone(),
            protocol: protocol,
            address: address,
            metadata: Map.empty(),
            last_seen: @native("timestamp_ms"),
            status: DeviceConnectionStatus.Connected
        }
    }
    
    fn with_name(name: String) -> Self { self.name = name; self }
    fn with_metadata(key: String, value: String) -> Self { self.metadata.set(key, value); self }
    
    fn update_last_seen() { self.last_seen = @native("timestamp_ms") }
    
    fn is_stale(timeout_ms: Int64) -> Bool {
        @native("timestamp_ms") - self.last_seen > timeout_ms
    }
}

enum DeviceConnectionStatus { Connected, Disconnected, Reconnecting, Error }

/// Device message
struct DeviceMessage {
    message_type: MessageType
    payload: [Byte]
    properties: Map<String, String>
    timestamp: Int64
    
    fn new(message_type: MessageType, payload: [Byte]) -> Self {
        DeviceMessage {
            message_type: message_type,
            payload: payload,
            properties: Map.empty(),
            timestamp: @native("timestamp_ms")
        }
    }
    
    fn telemetry(payload: [Byte]) -> Self { DeviceMessage.new(MessageType.Telemetry, payload) }
    fn event(payload: [Byte]) -> Self { DeviceMessage.new(MessageType.Event, payload) }
    fn command_response(payload: [Byte]) -> Self { DeviceMessage.new(MessageType.CommandResponse, payload) }
}

enum MessageType { Telemetry, Event, Command, CommandResponse, Status }

struct GatewayMessage {
    device_id: String
    message: DeviceMessage
    timestamp: Int64
}

// -----------------------------------------------------------------------------
// Protocol Handlers
// -----------------------------------------------------------------------------

/// Protocol handler trait
trait ProtocolHandler {
    fn start() -> Result<(), GatewayError>
    fn stop() -> Result<(), GatewayError>
    fn send(device: ConnectedDevice, message: DeviceMessage) -> Result<(), GatewayError>
    fn on_message(handler: fn(String, DeviceMessage))
}

/// MQTT protocol handler
actor MqttProtocolHandler {
    state broker_host: String
    state broker_port: UInt16
    state client: Option<MqttClient>
    state message_handler: Option<fn(String, DeviceMessage)>
    state topic_prefix: String
    
    fn new(host: String, port: UInt16) -> Self {
        MqttProtocolHandler {
            broker_host: host,
            broker_port: port,
            client: None,
            message_handler: None,
            topic_prefix: "devices"
        }
    }
}

impl ProtocolHandler for MqttProtocolHandler {
    fn start() -> Result<(), GatewayError> {
        let options = MqttOptions.new("gateway", self.broker_host)
            .with_port(self.broker_port)
        let client = MqttClient.new(options)
        client.connect()?
        
        // Subscribe to device messages
        let sub = client.subscribe("\(self.topic_prefix)/+/upstream/#", QoS.AtLeastOnce)?
        
        let handler = self.message_handler
        async {
            for msg in sub.iter() {
                if let Some(h) = handler {
                    let parts = msg.topic.split("/")
                    if parts.len() >= 2 {
                        let device_id = parts[1]
                        let device_msg = DeviceMessage.telemetry(msg.payload)
                        h(device_id, device_msg)
                    }
                }
            }
        }
        
        self.client = Some(client)
        Ok(())
    }
    
    fn stop() -> Result<(), GatewayError> {
        if let Some(client) = self.client {
            client.disconnect()?
        }
        self.client = None
        Ok(())
    }
    
    fn send(device: ConnectedDevice, message: DeviceMessage) -> Result<(), GatewayError> {
        let client = self.client.as_ref().ok_or(GatewayError.NotConnected)?
        let topic = "\(self.topic_prefix)/\(device.id)/downstream"
        client.publish(topic, message.payload, QoS.AtLeastOnce, false)
            .map_err(|e| GatewayError.SendFailed(e.to_string()))
    }
    
    fn on_message(handler: fn(String, DeviceMessage)) {
        self.message_handler = Some(handler)
    }
}

/// Modbus protocol handler
actor ModbusProtocolHandler {
    state devices: Map<String, ModbusDeviceConfig>
    state poll_interval_ms: Int64
    state message_handler: Option<fn(String, DeviceMessage)>
    state running: Bool
    
    fn new(poll_interval_ms: Int64) -> Self {
        ModbusProtocolHandler {
            devices: Map.empty(),
            poll_interval_ms: poll_interval_ms,
            message_handler: None,
            running: false
        }
    }
    
    on add_device(device_id: String, config: ModbusDeviceConfig) {
        self.devices.set(device_id, config)
    }
}

struct ModbusDeviceConfig {
    host: String
    port: UInt16
    unit_id: UInt8
    registers: [ModbusRegisterConfig]
}

struct ModbusRegisterConfig {
    address: UInt16
    count: UInt16
    name: String
    register_type: ModbusRegisterType
}

enum ModbusRegisterType { Coil, DiscreteInput, HoldingRegister, InputRegister }

impl ProtocolHandler for ModbusProtocolHandler {
    fn start() -> Result<(), GatewayError> {
        self.running = true
        
        let devices = self.devices.clone()
        let handler = self.message_handler
        let interval = self.poll_interval_ms
        
        async {
            while self.running {
                for (device_id, config) in devices {
                    let client = ModbusClient.new(config.host, config.port, config.unit_id)
                    
                    for reg in config.registers {
                        let result = match reg.register_type {
                            ModbusRegisterType.HoldingRegister => 
                                client.read_holding_registers(reg.address, reg.count)
                            ModbusRegisterType.InputRegister =>
                                client.read_input_registers(reg.address, reg.count)
                            _ => continue
                        }
                        
                        if let Ok(values) = result {
                            if let Some(h) = handler {
                                let payload = JSON.stringify({"name": reg.name, "values": values}).bytes()
                                h(device_id, DeviceMessage.telemetry(payload))
                            }
                        }
                    }
                }
                @native("sleep_ms", interval)
            }
        }
        
        Ok(())
    }
    
    fn stop() -> Result<(), GatewayError> {
        self.running = false
        Ok(())
    }
    
    fn send(device: ConnectedDevice, message: DeviceMessage) -> Result<(), GatewayError> {
        // Modbus write operations
        Ok(())
    }
    
    fn on_message(handler: fn(String, DeviceMessage)) {
        self.message_handler = Some(handler)
    }
}

/// BLE protocol handler
actor BleProtocolHandler {
    state scanner: BleScanner
    state clients: Map<String, BleClient>
    state message_handler: Option<fn(String, DeviceMessage)>
    state running: Bool
    
    fn new() -> Self {
        BleProtocolHandler {
            scanner: BleScanner.new(),
            clients: Map.empty(),
            message_handler: None,
            running: false
        }
    }
}

impl ProtocolHandler for BleProtocolHandler {
    fn start() -> Result<(), GatewayError> {
        self.running = true
        Ok(())
    }
    
    fn stop() -> Result<(), GatewayError> {
        self.running = false
        for (_, client) in self.clients {
            let _ = client.disconnect()
        }
        self.clients.clear()
        Ok(())
    }
    
    fn send(device: ConnectedDevice, message: DeviceMessage) -> Result<(), GatewayError> {
        let client = self.clients.get(device.id).ok_or(GatewayError.DeviceNotFound(device.id))?
        // Write to characteristic
        Ok(())
    }
    
    fn on_message(handler: fn(String, DeviceMessage)) {
        self.message_handler = Some(handler)
    }
}

// -----------------------------------------------------------------------------
// Upstream Connection
// -----------------------------------------------------------------------------

/// Upstream connection configuration
struct UpstreamConfig {
    connection_type: UpstreamType
    endpoint: String
    credentials: Option<UpstreamCredentials>
    retry_policy: RetryPolicy
    
    fn mqtt(endpoint: String) -> Self {
        UpstreamConfig {
            connection_type: UpstreamType.Mqtt,
            endpoint: endpoint,
            credentials: None,
            retry_policy: RetryPolicy.default()
        }
    }
    
    fn http(endpoint: String) -> Self {
        UpstreamConfig {
            connection_type: UpstreamType.Http,
            endpoint: endpoint,
            credentials: None,
            retry_policy: RetryPolicy.default()
        }
    }
    
    fn with_credentials(creds: UpstreamCredentials) -> Self {
        self.credentials = Some(creds)
        self
    }
}

enum UpstreamType { Mqtt, Http, Amqp, Websocket }

struct UpstreamCredentials {
    auth_type: AuthType
    username: Option<String>
    password: Option<String>
    token: Option<String>
    certificate: Option<String>
}

enum AuthType { None, Basic, Token, Certificate, SAS }

struct RetryPolicy {
    max_retries: Int
    initial_delay_ms: Int64
    max_delay_ms: Int64
    backoff_multiplier: Float64
    
    fn default() -> Self {
        RetryPolicy {
            max_retries: 5,
            initial_delay_ms: 1000,
            max_delay_ms: 60000,
            backoff_multiplier: 2.0
        }
    }
}

/// Upstream connection
actor UpstreamConnection {
    state config: UpstreamConfig
    state connected: Bool
    state retry_count: Int
    
    fn connect(config: UpstreamConfig) -> Result<Self, GatewayError> {
        let conn = UpstreamConnection {
            config: config,
            connected: false,
            retry_count: 0
        }
        conn.establish_connection()?
        Ok(conn)
    }
    
    on establish_connection() -> Result<(), GatewayError> {
        match self.config.connection_type {
            UpstreamType.Mqtt => self.connect_mqtt()
            UpstreamType.Http => Ok(())  // HTTP is connectionless
            _ => Err(GatewayError.ProtocolNotSupported("Unsupported upstream type"))
        }
    }
    
    fn connect_mqtt() -> Result<(), GatewayError> {
        @native("mqtt_connect", self.config.endpoint, self.config.credentials)?
        self.connected = true
        Ok(())
    }
    
    on send(message: UpstreamMessage) -> Result<(), GatewayError> {
        match self.config.connection_type {
            UpstreamType.Mqtt => self.send_mqtt(message)
            UpstreamType.Http => self.send_http(message)
            _ => Err(GatewayError.ProtocolNotSupported("Unsupported upstream type"))
        }
    }
    
    fn send_mqtt(message: UpstreamMessage) -> Result<(), GatewayError> {
        let payload = message.to_json().bytes()
        @native("mqtt_publish", "gateway/telemetry", payload, 1, false)
            .map_err(|e| GatewayError.SendFailed(e.to_string()))
    }
    
    fn send_http(message: UpstreamMessage) -> Result<(), GatewayError> {
        let payload = message.to_json()
        @native("http_post", self.config.endpoint, payload, {}, 30000)
            .map_err(|e| GatewayError.SendFailed(e.to_string()))
    }
    
    on disconnect() -> Result<(), GatewayError> {
        self.connected = false
        Ok(())
    }
}

enum UpstreamMessage {
    Single(GatewayMessage)
    Batch([GatewayMessage])
    
    fn to_json() -> String {
        match self {
            .Single(msg) => JSON.stringify(msg)
            .Batch(msgs) => JSON.stringify(msgs)
        }
    }
}

// -----------------------------------------------------------------------------
// Edge Modules
// -----------------------------------------------------------------------------

/// Edge module trait
trait EdgeModule {
    fn start() -> Result<(), GatewayError>
    fn stop() -> Result<(), GatewayError>
    fn process(device_id: String, message: DeviceMessage) -> Option<DeviceMessage>
}

/// Filter edge module
actor FilterModule {
    state rules: [FilterRule]
    
    fn new() -> Self { FilterModule { rules: [] } }
    
    on add_rule(rule: FilterRule) { self.rules.push(rule) }
}

struct FilterRule {
    field: String
    operator: FilterOperator
    value: Value
}

enum FilterOperator { Equals, NotEquals, GreaterThan, LessThan, Contains }

impl EdgeModule for FilterModule {
    fn start() -> Result<(), GatewayError> { Ok(()) }
    fn stop() -> Result<(), GatewayError> { Ok(()) }
    
    fn process(device_id: String, message: DeviceMessage) -> Option<DeviceMessage> {
        // Apply filter rules
        for rule in self.rules {
            // Check if message passes rule
        }
        Some(message)
    }
}

/// Transform edge module
actor TransformModule {
    state transformations: Map<String, fn(Value) -> Value>
    
    fn new() -> Self { TransformModule { transformations: Map.empty() } }
    
    on add_transformation(field: String, transform: fn(Value) -> Value) {
        self.transformations.set(field, transform)
    }
}

impl EdgeModule for TransformModule {
    fn start() -> Result<(), GatewayError> { Ok(()) }
    fn stop() -> Result<(), GatewayError> { Ok(()) }
    
    fn process(device_id: String, message: DeviceMessage) -> Option<DeviceMessage> {
        // Apply transformations
        Some(message)
    }
}

/// Aggregation edge module
actor AggregationModule {
    state window_ms: Int64
    state aggregation_type: AggregationType
    state buffers: Map<String, [Float64]>
    
    fn new(window_ms: Int64, aggregation_type: AggregationType) -> Self {
        AggregationModule {
            window_ms: window_ms,
            aggregation_type: aggregation_type,
            buffers: Map.empty()
        }
    }
}

enum AggregationType { Average, Sum, Min, Max, Count }

impl EdgeModule for AggregationModule {
    fn start() -> Result<(), GatewayError> { Ok(()) }
    fn stop() -> Result<(), GatewayError> { Ok(()) }
    
    fn process(device_id: String, message: DeviceMessage) -> Option<DeviceMessage> {
        // Aggregate messages
        Some(message)
    }
}

/// Alert edge module
actor AlertModule {
    state rules: [AlertRule]
    state alert_handler: Option<fn(Alert)>
    
    fn new() -> Self { AlertModule { rules: [], alert_handler: None } }
    
    on add_rule(rule: AlertRule) { self.rules.push(rule) }
    on on_alert(handler: fn(Alert)) { self.alert_handler = Some(handler) }
}

struct AlertRule {
    name: String
    condition: AlertCondition
    severity: AlertSeverity
}

struct AlertCondition {
    field: String
    operator: FilterOperator
    threshold: Float64
}

enum AlertSeverity { Info, Warning, Error, Critical }

struct Alert {
    rule_name: String
    device_id: String
    severity: AlertSeverity
    message: String
    timestamp: Int64
}

impl EdgeModule for AlertModule {
    fn start() -> Result<(), GatewayError> { Ok(()) }
    fn stop() -> Result<(), GatewayError> { Ok(()) }
    
    fn process(device_id: String, message: DeviceMessage) -> Option<DeviceMessage> {
        // Check alert rules
        for rule in self.rules {
            // Evaluate condition and trigger alert if needed
        }
        Some(message)
    }
}

// -----------------------------------------------------------------------------
// Store and Forward
// -----------------------------------------------------------------------------

/// Store and forward buffer
actor StoreAndForward {
    state buffer_path: String
    state max_size: Int64
    state current_size: Int64
    
    fn new(buffer_path: String, max_size: Int64) -> Self {
        StoreAndForward {
            buffer_path: buffer_path,
            max_size: max_size,
            current_size: 0
        }
    }
    
    on store(message: GatewayMessage) -> Result<(), GatewayError> {
        let data = JSON.stringify(message)
        if self.current_size + data.len() as Int64 > self.max_size {
            return Err(GatewayError.BufferFull)
        }
        @native("file_append", self.buffer_path, data + "\n")?
        self.current_size += data.len() as Int64
        Ok(())
    }
    
    on retrieve(count: Int) -> Result<[GatewayMessage], GatewayError> {
        let content = @native("file_read", self.buffer_path)?
        content.lines()
            .take(count)
            .map(|line| JSON.parse::<GatewayMessage>(line))
            .collect::<Result<[GatewayMessage], _>>()
            .map_err(|_| GatewayError.ParseError)
    }
    
    on clear() -> Result<(), GatewayError> {
        @native("file_write", self.buffer_path, "")?
        self.current_size = 0
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum GatewayError {
    NotConnected
    DeviceNotFound(String)
    DeviceLimitReached
    ProtocolNotSupported(String)
    SendFailed(String)
    BufferFull
    ParseError
    ConfigError(String)
    
    fn to_string() -> String {
        match self {
            .NotConnected => "Gateway not connected"
            .DeviceNotFound(id) => "Device not found: \(id)"
            .DeviceLimitReached => "Device limit reached"
            .ProtocolNotSupported(p) => "Protocol not supported: \(p)"
            .SendFailed(msg) => "Send failed: \(msg)"
            .BufferFull => "Buffer full"
            .ParseError => "Parse error"
            .ConfigError(msg) => "Configuration error: \(msg)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "gateway config" {
    let config = GatewayConfig.new()
        .with_max_devices(500)
        .with_upstream(UpstreamConfig.mqtt("mqtt://broker:1883"))
    
    assert_eq(config.max_devices, 500)?
    assert(config.upstream.is_some())?
}

test "connected device" {
    let device = ConnectedDevice.new("sensor-1", "mqtt", "192.168.1.100")
        .with_name("Temperature Sensor")
        .with_metadata("location", "room1")
    
    assert_eq(device.id, "sensor-1")?
    assert_eq(device.name, "Temperature Sensor")?
    assert_eq(device.metadata.get("location"), Some("room1"))?
}

test "device message creation" {
    let msg = DeviceMessage.telemetry([1, 2, 3, 4])
    assert_eq(msg.message_type, MessageType.Telemetry)?
    assert_eq(msg.payload.len(), 4)?
}

test "retry policy" {
    let policy = RetryPolicy.default()
    assert_eq(policy.max_retries, 5)?
    assert_eq(policy.backoff_multiplier, 2.0)?
}

test "upstream config" {
    let config = UpstreamConfig.mqtt("mqtt://broker:1883")
        .with_credentials(UpstreamCredentials {
            auth_type: AuthType.Token,
            username: None,
            password: None,
            token: Some("secret-token"),
            certificate: None
        })
    
    assert_eq(config.connection_type, UpstreamType.Mqtt)?
    assert(config.credentials.is_some())?
}
