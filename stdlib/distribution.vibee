// =============================================================================
// Vibee OS â€” Distribution Module
// Probability distributions
// =============================================================================

use rng::{Rng, Xoshiro256StarStar, thread_rng}

const PI: Float = 3.141592653589793
const E: Float = 2.718281828459045
const SQRT2: Float = 1.4142135623730951

// -----------------------------------------------------------------------------
// Distribution Trait
// -----------------------------------------------------------------------------

trait Distribution<T> {
    fn sample<R: Rng>(rng: R) -> T
    fn samples<R: Rng>(rng: R, n: Int) -> [T] {
        (0..n).map(|_| self.sample(rng)).collect()
    }
}

trait ContinuousDistribution: Distribution<Float> {
    fn pdf(x: Float) -> Float
    fn cdf(x: Float) -> Float
    fn quantile(p: Float) -> Float
    fn mean() -> Float
    fn variance() -> Float
    fn std_dev() -> Float { self.variance().sqrt() }
}

trait DiscreteDistribution: Distribution<Int> {
    fn pmf(k: Int) -> Float
    fn cdf(k: Int) -> Float
    fn mean() -> Float
    fn variance() -> Float
}

// -----------------------------------------------------------------------------
// Uniform Distribution
// -----------------------------------------------------------------------------

struct Uniform { min: Float, max: Float }

impl Uniform {
    fn new(min: Float, max: Float) -> Self { Uniform { min: min, max: max } }
    fn unit() -> Self { Uniform { min: 0.0, max: 1.0 } }
}

impl Distribution<Float> for Uniform {
    fn sample<R: Rng>(rng: R) -> Float {
        self.min + rng.next_float() * (self.max - self.min)
    }
}

impl ContinuousDistribution for Uniform {
    fn pdf(x: Float) -> Float {
        if x >= self.min && x <= self.max { 1.0 / (self.max - self.min) } else { 0.0 }
    }
    fn cdf(x: Float) -> Float {
        if x < self.min { 0.0 }
        else if x > self.max { 1.0 }
        else { (x - self.min) / (self.max - self.min) }
    }
    fn quantile(p: Float) -> Float { self.min + p * (self.max - self.min) }
    fn mean() -> Float { (self.min + self.max) / 2.0 }
    fn variance() -> Float { (self.max - self.min).pow(2) / 12.0 }
}

// -----------------------------------------------------------------------------
// Normal (Gaussian) Distribution
// -----------------------------------------------------------------------------

struct Normal { mu: Float, sigma: Float }

impl Normal {
    fn new(mean: Float, std_dev: Float) -> Self { Normal { mu: mean, sigma: std_dev } }
    fn standard() -> Self { Normal { mu: 0.0, sigma: 1.0 } }
}

impl Distribution<Float> for Normal {
    fn sample<R: Rng>(rng: R) -> Float {
        // Box-Muller transform
        let u1 = rng.next_float()
        let u2 = rng.next_float()
        let z = (-2.0 * u1.ln()).sqrt() * (2.0 * PI * u2).cos()
        self.mu + self.sigma * z
    }
}

impl ContinuousDistribution for Normal {
    fn pdf(x: Float) -> Float {
        let z = (x - self.mu) / self.sigma
        (1.0 / (self.sigma * (2.0 * PI).sqrt())) * (-0.5 * z * z).exp()
    }
    fn cdf(x: Float) -> Float {
        0.5 * (1.0 + erf((x - self.mu) / (self.sigma * SQRT2)))
    }
    fn quantile(p: Float) -> Float {
        self.mu + self.sigma * SQRT2 * erfinv(2.0 * p - 1.0)
    }
    fn mean() -> Float { self.mu }
    fn variance() -> Float { self.sigma * self.sigma }
}

// -----------------------------------------------------------------------------
// Exponential Distribution
// -----------------------------------------------------------------------------

struct Exponential { lambda: Float }

impl Exponential {
    fn new(rate: Float) -> Self { Exponential { lambda: rate } }
    fn from_mean(mean: Float) -> Self { Exponential { lambda: 1.0 / mean } }
}

impl Distribution<Float> for Exponential {
    fn sample<R: Rng>(rng: R) -> Float {
        -rng.next_float().ln() / self.lambda
    }
}

impl ContinuousDistribution for Exponential {
    fn pdf(x: Float) -> Float {
        if x < 0.0 { 0.0 } else { self.lambda * (-self.lambda * x).exp() }
    }
    fn cdf(x: Float) -> Float {
        if x < 0.0 { 0.0 } else { 1.0 - (-self.lambda * x).exp() }
    }
    fn quantile(p: Float) -> Float { -(1.0 - p).ln() / self.lambda }
    fn mean() -> Float { 1.0 / self.lambda }
    fn variance() -> Float { 1.0 / (self.lambda * self.lambda) }
}

// -----------------------------------------------------------------------------
// Gamma Distribution
// -----------------------------------------------------------------------------

struct Gamma { alpha: Float, beta: Float }

impl Gamma {
    fn new(shape: Float, rate: Float) -> Self { Gamma { alpha: shape, beta: rate } }
}

impl Distribution<Float> for Gamma {
    fn sample<R: Rng>(rng: R) -> Float {
        // Marsaglia and Tsang's method
        if self.alpha < 1.0 {
            let u = rng.next_float()
            return Gamma.new(self.alpha + 1.0, self.beta).sample(rng) * u.pow(1.0 / self.alpha)
        }
        let d = self.alpha - 1.0 / 3.0
        let c = 1.0 / (9.0 * d).sqrt()
        loop {
            var x: Float
            var v: Float
            loop {
                x = Normal.standard().sample(rng)
                v = 1.0 + c * x
                if v > 0.0 { break }
            }
            v = v * v * v
            let u = rng.next_float()
            if u < 1.0 - 0.0331 * x * x * x * x { return d * v / self.beta }
            if u.ln() < 0.5 * x * x + d * (1.0 - v + v.ln()) { return d * v / self.beta }
        }
    }
}

impl ContinuousDistribution for Gamma {
    fn pdf(x: Float) -> Float {
        if x <= 0.0 { return 0.0 }
        (self.beta.pow(self.alpha) / gamma(self.alpha)) * x.pow(self.alpha - 1.0) * (-self.beta * x).exp()
    }
    fn cdf(x: Float) -> Float {
        if x <= 0.0 { 0.0 } else { lower_incomplete_gamma(self.alpha, self.beta * x) / gamma(self.alpha) }
    }
    fn quantile(p: Float) -> Float { @native("gamma_quantile", self.alpha, self.beta, p) }
    fn mean() -> Float { self.alpha / self.beta }
    fn variance() -> Float { self.alpha / (self.beta * self.beta) }
}

// -----------------------------------------------------------------------------
// Beta Distribution
// -----------------------------------------------------------------------------

struct Beta { alpha: Float, beta: Float }

impl Beta {
    fn new(a: Float, b: Float) -> Self { Beta { alpha: a, beta: b } }
}

impl Distribution<Float> for Beta {
    fn sample<R: Rng>(rng: R) -> Float {
        let x = Gamma.new(self.alpha, 1.0).sample(rng)
        let y = Gamma.new(self.beta, 1.0).sample(rng)
        x / (x + y)
    }
}

impl ContinuousDistribution for Beta {
    fn pdf(x: Float) -> Float {
        if x <= 0.0 || x >= 1.0 { return 0.0 }
        x.pow(self.alpha - 1.0) * (1.0 - x).pow(self.beta - 1.0) / beta_fn(self.alpha, self.beta)
    }
    fn cdf(x: Float) -> Float { incomplete_beta(self.alpha, self.beta, x) }
    fn quantile(p: Float) -> Float { @native("beta_quantile", self.alpha, self.beta, p) }
    fn mean() -> Float { self.alpha / (self.alpha + self.beta) }
    fn variance() -> Float {
        let ab = self.alpha + self.beta
        self.alpha * self.beta / (ab * ab * (ab + 1.0))
    }
}

// -----------------------------------------------------------------------------
// Chi-Squared Distribution
// -----------------------------------------------------------------------------

struct ChiSquared { k: Float }

impl ChiSquared {
    fn new(degrees_of_freedom: Float) -> Self { ChiSquared { k: degrees_of_freedom } }
}

impl Distribution<Float> for ChiSquared {
    fn sample<R: Rng>(rng: R) -> Float {
        Gamma.new(self.k / 2.0, 0.5).sample(rng)
    }
}

impl ContinuousDistribution for ChiSquared {
    fn pdf(x: Float) -> Float { Gamma.new(self.k / 2.0, 0.5).pdf(x) }
    fn cdf(x: Float) -> Float { Gamma.new(self.k / 2.0, 0.5).cdf(x) }
    fn quantile(p: Float) -> Float { Gamma.new(self.k / 2.0, 0.5).quantile(p) }
    fn mean() -> Float { self.k }
    fn variance() -> Float { 2.0 * self.k }
}

// -----------------------------------------------------------------------------
// Student's t-Distribution
// -----------------------------------------------------------------------------

struct StudentT { nu: Float }

impl StudentT {
    fn new(degrees_of_freedom: Float) -> Self { StudentT { nu: degrees_of_freedom } }
}

impl Distribution<Float> for StudentT {
    fn sample<R: Rng>(rng: R) -> Float {
        let z = Normal.standard().sample(rng)
        let v = ChiSquared.new(self.nu).sample(rng)
        z / (v / self.nu).sqrt()
    }
}

impl ContinuousDistribution for StudentT {
    fn pdf(x: Float) -> Float {
        let coef = gamma((self.nu + 1.0) / 2.0) / (gamma(self.nu / 2.0) * (self.nu * PI).sqrt())
        coef * (1.0 + x * x / self.nu).pow(-(self.nu + 1.0) / 2.0)
    }
    fn cdf(x: Float) -> Float { @native("student_t_cdf", self.nu, x) }
    fn quantile(p: Float) -> Float { @native("student_t_quantile", self.nu, p) }
    fn mean() -> Float { if self.nu > 1.0 { 0.0 } else { Float.nan() } }
    fn variance() -> Float {
        if self.nu > 2.0 { self.nu / (self.nu - 2.0) }
        else if self.nu > 1.0 { Float.infinity() }
        else { Float.nan() }
    }
}

// -----------------------------------------------------------------------------
// F-Distribution
// -----------------------------------------------------------------------------

struct FDistribution { d1: Float, d2: Float }

impl FDistribution {
    fn new(df1: Float, df2: Float) -> Self { FDistribution { d1: df1, d2: df2 } }
}

impl Distribution<Float> for FDistribution {
    fn sample<R: Rng>(rng: R) -> Float {
        let x1 = ChiSquared.new(self.d1).sample(rng) / self.d1
        let x2 = ChiSquared.new(self.d2).sample(rng) / self.d2
        x1 / x2
    }
}

// -----------------------------------------------------------------------------
// Log-Normal Distribution
// -----------------------------------------------------------------------------

struct LogNormal { mu: Float, sigma: Float }

impl LogNormal {
    fn new(mu: Float, sigma: Float) -> Self { LogNormal { mu: mu, sigma: sigma } }
    fn from_mean_std(mean: Float, std: Float) -> Self {
        let sigma2 = (1.0 + std * std / (mean * mean)).ln()
        LogNormal { mu: mean.ln() - sigma2 / 2.0, sigma: sigma2.sqrt() }
    }
}

impl Distribution<Float> for LogNormal {
    fn sample<R: Rng>(rng: R) -> Float {
        Normal.new(self.mu, self.sigma).sample(rng).exp()
    }
}

impl ContinuousDistribution for LogNormal {
    fn pdf(x: Float) -> Float {
        if x <= 0.0 { return 0.0 }
        let z = (x.ln() - self.mu) / self.sigma
        1.0 / (x * self.sigma * (2.0 * PI).sqrt()) * (-0.5 * z * z).exp()
    }
    fn cdf(x: Float) -> Float {
        if x <= 0.0 { 0.0 } else { Normal.standard().cdf((x.ln() - self.mu) / self.sigma) }
    }
    fn quantile(p: Float) -> Float { (self.mu + self.sigma * Normal.standard().quantile(p)).exp() }
    fn mean() -> Float { (self.mu + self.sigma * self.sigma / 2.0).exp() }
    fn variance() -> Float {
        let s2 = self.sigma * self.sigma
        ((2.0 * self.mu + s2).exp()) * (s2.exp() - 1.0)
    }
}

// -----------------------------------------------------------------------------
// Weibull Distribution
// -----------------------------------------------------------------------------

struct Weibull { k: Float, lambda: Float }

impl Weibull {
    fn new(shape: Float, scale: Float) -> Self { Weibull { k: shape, lambda: scale } }
}

impl Distribution<Float> for Weibull {
    fn sample<R: Rng>(rng: R) -> Float {
        self.lambda * (-rng.next_float().ln()).pow(1.0 / self.k)
    }
}

impl ContinuousDistribution for Weibull {
    fn pdf(x: Float) -> Float {
        if x < 0.0 { return 0.0 }
        (self.k / self.lambda) * (x / self.lambda).pow(self.k - 1.0) * (-(x / self.lambda).pow(self.k)).exp()
    }
    fn cdf(x: Float) -> Float {
        if x < 0.0 { 0.0 } else { 1.0 - (-(x / self.lambda).pow(self.k)).exp() }
    }
    fn quantile(p: Float) -> Float { self.lambda * (-(1.0 - p).ln()).pow(1.0 / self.k) }
    fn mean() -> Float { self.lambda * gamma(1.0 + 1.0 / self.k) }
    fn variance() -> Float {
        self.lambda * self.lambda * (gamma(1.0 + 2.0 / self.k) - gamma(1.0 + 1.0 / self.k).pow(2))
    }
}

// -----------------------------------------------------------------------------
// Pareto Distribution
// -----------------------------------------------------------------------------

struct Pareto { xm: Float, alpha: Float }

impl Pareto {
    fn new(scale: Float, shape: Float) -> Self { Pareto { xm: scale, alpha: shape } }
}

impl Distribution<Float> for Pareto {
    fn sample<R: Rng>(rng: R) -> Float {
        self.xm / rng.next_float().pow(1.0 / self.alpha)
    }
}

impl ContinuousDistribution for Pareto {
    fn pdf(x: Float) -> Float {
        if x < self.xm { 0.0 } else { self.alpha * self.xm.pow(self.alpha) / x.pow(self.alpha + 1.0) }
    }
    fn cdf(x: Float) -> Float {
        if x < self.xm { 0.0 } else { 1.0 - (self.xm / x).pow(self.alpha) }
    }
    fn quantile(p: Float) -> Float { self.xm / (1.0 - p).pow(1.0 / self.alpha) }
    fn mean() -> Float { if self.alpha > 1.0 { self.alpha * self.xm / (self.alpha - 1.0) } else { Float.infinity() } }
    fn variance() -> Float {
        if self.alpha > 2.0 { self.xm * self.xm * self.alpha / ((self.alpha - 1.0).pow(2) * (self.alpha - 2.0)) }
        else { Float.infinity() }
    }
}

// -----------------------------------------------------------------------------
// Cauchy Distribution
// -----------------------------------------------------------------------------

struct Cauchy { x0: Float, gamma: Float }

impl Cauchy {
    fn new(location: Float, scale: Float) -> Self { Cauchy { x0: location, gamma: scale } }
    fn standard() -> Self { Cauchy { x0: 0.0, gamma: 1.0 } }
}

impl Distribution<Float> for Cauchy {
    fn sample<R: Rng>(rng: R) -> Float {
        self.x0 + self.gamma * (PI * (rng.next_float() - 0.5)).tan()
    }
}

impl ContinuousDistribution for Cauchy {
    fn pdf(x: Float) -> Float {
        1.0 / (PI * self.gamma * (1.0 + ((x - self.x0) / self.gamma).pow(2)))
    }
    fn cdf(x: Float) -> Float { 0.5 + ((x - self.x0) / self.gamma).atan() / PI }
    fn quantile(p: Float) -> Float { self.x0 + self.gamma * (PI * (p - 0.5)).tan() }
    fn mean() -> Float { Float.nan() }
    fn variance() -> Float { Float.nan() }
}

// -----------------------------------------------------------------------------
// Discrete Distributions
// -----------------------------------------------------------------------------

struct Bernoulli { p: Float }
impl Bernoulli { fn new(p: Float) -> Self { Bernoulli { p: p } } }
impl Distribution<Int> for Bernoulli {
    fn sample<R: Rng>(rng: R) -> Int { if rng.next_float() < self.p { 1 } else { 0 } }
}
impl DiscreteDistribution for Bernoulli {
    fn pmf(k: Int) -> Float { if k == 1 { self.p } else if k == 0 { 1.0 - self.p } else { 0.0 } }
    fn cdf(k: Int) -> Float { if k < 0 { 0.0 } else if k < 1 { 1.0 - self.p } else { 1.0 } }
    fn mean() -> Float { self.p }
    fn variance() -> Float { self.p * (1.0 - self.p) }
}

struct Binomial { n: Int, p: Float }
impl Binomial { fn new(n: Int, p: Float) -> Self { Binomial { n: n, p: p } } }
impl Distribution<Int> for Binomial {
    fn sample<R: Rng>(rng: R) -> Int {
        var count = 0
        for _ in 0..self.n { if rng.next_float() < self.p { count += 1 } }
        count
    }
}
impl DiscreteDistribution for Binomial {
    fn pmf(k: Int) -> Float {
        if k < 0 || k > self.n { return 0.0 }
        binomial_coef(self.n, k) as Float * self.p.pow(k as Float) * (1.0 - self.p).pow((self.n - k) as Float)
    }
    fn cdf(k: Int) -> Float { (0..=k.min(self.n)).map(|i| self.pmf(i)).sum() }
    fn mean() -> Float { self.n as Float * self.p }
    fn variance() -> Float { self.n as Float * self.p * (1.0 - self.p) }
}

struct Poisson { lambda: Float }
impl Poisson { fn new(lambda: Float) -> Self { Poisson { lambda: lambda } } }
impl Distribution<Int> for Poisson {
    fn sample<R: Rng>(rng: R) -> Int {
        let l = (-self.lambda).exp()
        var k = 0; var p = 1.0
        while p > l { k += 1; p *= rng.next_float() }
        k - 1
    }
}
impl DiscreteDistribution for Poisson {
    fn pmf(k: Int) -> Float {
        if k < 0 { return 0.0 }
        self.lambda.pow(k as Float) * (-self.lambda).exp() / factorial(k) as Float
    }
    fn cdf(k: Int) -> Float { (0..=k).map(|i| self.pmf(i)).sum() }
    fn mean() -> Float { self.lambda }
    fn variance() -> Float { self.lambda }
}

struct Geometric { p: Float }
impl Geometric { fn new(p: Float) -> Self { Geometric { p: p } } }
impl Distribution<Int> for Geometric {
    fn sample<R: Rng>(rng: R) -> Int { (rng.next_float().ln() / (1.0 - self.p).ln()).floor() as Int }
}
impl DiscreteDistribution for Geometric {
    fn pmf(k: Int) -> Float { if k < 0 { 0.0 } else { self.p * (1.0 - self.p).pow(k as Float) } }
    fn cdf(k: Int) -> Float { if k < 0 { 0.0 } else { 1.0 - (1.0 - self.p).pow((k + 1) as Float) } }
    fn mean() -> Float { (1.0 - self.p) / self.p }
    fn variance() -> Float { (1.0 - self.p) / (self.p * self.p) }
}

struct NegativeBinomial { r: Int, p: Float }
impl NegativeBinomial { fn new(r: Int, p: Float) -> Self { NegativeBinomial { r: r, p: p } } }
impl Distribution<Int> for NegativeBinomial {
    fn sample<R: Rng>(rng: R) -> Int {
        var failures = 0; var successes = 0
        while successes < self.r {
            if rng.next_float() < self.p { successes += 1 } else { failures += 1 }
        }
        failures
    }
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

fn erf(x: Float) -> Float { @native("math_erf", x) }
fn erfinv(x: Float) -> Float { @native("math_erfinv", x) }
fn gamma(x: Float) -> Float { @native("math_gamma", x) }
fn lower_incomplete_gamma(a: Float, x: Float) -> Float { @native("math_lower_gamma", a, x) }
fn beta_fn(a: Float, b: Float) -> Float { gamma(a) * gamma(b) / gamma(a + b) }
fn incomplete_beta(a: Float, b: Float, x: Float) -> Float { @native("math_incomplete_beta", a, b, x) }
fn factorial(n: Int) -> Int { if n <= 1 { 1 } else { n * factorial(n - 1) } }
fn binomial_coef(n: Int, k: Int) -> Int {
    if k > n { return 0 }
    if k == 0 || k == n { return 1 }
    var result = 1
    for i in 0..k.min(n - k) { result = result * (n - i) / (i + 1) }
    result
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "normal distribution" {
    var rng = Xoshiro256StarStar.new(42)
    let n = Normal.standard()
    let samples = n.samples(rng, 10000)
    let mean = samples.sum() / samples.len() as Float
    assert(mean.abs() < 0.1)?
}

test "uniform distribution" {
    var rng = Xoshiro256StarStar.new(42)
    let u = Uniform.new(0.0, 1.0)
    for _ in 0..100 { let s = u.sample(rng); assert(s >= 0.0 && s <= 1.0)? }
}

test "exponential distribution" {
    let e = Exponential.new(2.0)
    assert(approx_eq(e.mean(), 0.5))?
}

test "binomial distribution" {
    let b = Binomial.new(10, 0.5)
    assert(approx_eq(b.mean(), 5.0))?
}

fn approx_eq(a: Float, b: Float) -> Bool { (a - b).abs() < 0.001 }
