// =============================================================================
// Vibee OS â€” MongoDB Module
// MongoDB NoSQL database client
// =============================================================================

// =============================================================================
// Connection Configuration
// =============================================================================

/// MongoDB connection configuration
struct MongoConfig {
    hosts: [(String, UInt16)]
    database: Option<String>
    username: Option<String>
    password: Option<String>
    auth_source: Option<String>
    replica_set: Option<String>
    tls: Bool
    connect_timeout_ms: Int64
    server_selection_timeout_ms: Int64
    max_pool_size: Int
    min_pool_size: Int
    options: Map<String, String>
}

impl MongoConfig {
    fn new() -> Self {
        MongoConfig {
            hosts: [("localhost", 27017)],
            database: None,
            username: None,
            password: None,
            auth_source: None,
            replica_set: None,
            tls: false,
            connect_timeout_ms: 10000,
            server_selection_timeout_ms: 30000,
            max_pool_size: 100,
            min_pool_size: 0,
            options: Map.empty()
        }
    }
    
    fn from_url(url: String) -> Result<Self, MongoError> {
        // mongodb://[username:password@]host1[:port1][,...hostN[:portN]][/[database][?options]]
        @native("mongo_parse_url", url)
    }
    
    fn host(h: String, port: UInt16) -> Self {
        self.hosts = [(h, port)]
        self
    }
    
    fn hosts(h: [(String, UInt16)]) -> Self { self.hosts = h; self }
    fn database(db: String) -> Self { self.database = Some(db); self }
    fn credentials(user: String, pass: String) -> Self {
        self.username = Some(user)
        self.password = Some(pass)
        self
    }
    fn auth_source(source: String) -> Self { self.auth_source = Some(source); self }
    fn replica_set(name: String) -> Self { self.replica_set = Some(name); self }
    fn tls(enabled: Bool) -> Self { self.tls = enabled; self }
    fn connect_timeout(ms: Int64) -> Self { self.connect_timeout_ms = ms; self }
    fn max_pool_size(size: Int) -> Self { self.max_pool_size = size; self }
    fn min_pool_size(size: Int) -> Self { self.min_pool_size = size; self }
    fn option(key: String, value: String) -> Self { self.options.set(key, value); self }
    
    fn connection_string() -> String {
        var url = "mongodb://"
        if let (Some(user), Some(pass)) = (self.username, self.password) {
            url += format!("{}:{}@", user, pass)
        }
        url += self.hosts.iter().map(|(h, p)| format!("{}:{}", h, p)).join(",")
        if let Some(db) = self.database {
            url += format!("/{}", db)
        }
        url
    }
}

// =============================================================================
// Client and Database
// =============================================================================

/// MongoDB client
struct MongoClient {
    inner: @native("MongoClient")
    config: MongoConfig
}

impl MongoClient {
    fn connect(config: MongoConfig) -> Result<Self, MongoError> {
        let inner = @native("mongo_connect", config)?
        Ok(MongoClient { inner: inner, config: config })
    }
    
    fn connect_url(url: String) -> Result<Self, MongoError> {
        Self.connect(MongoConfig.from_url(url)?)
    }
    
    /// Get a database
    fn database(name: String) -> MongoDatabase {
        MongoDatabase { client: self, name: name }
    }
    
    /// Get default database (from connection string)
    fn default_database() -> Option<MongoDatabase> {
        self.config.database.map(|name| self.database(name))
    }
    
    /// List all databases
    fn list_databases() -> Result<[DatabaseInfo], MongoError> {
        @native("mongo_list_databases", self.inner)
    }
    
    /// List database names
    fn list_database_names() -> Result<[String], MongoError> {
        @native("mongo_list_database_names", self.inner)
    }
    
    /// Drop a database
    fn drop_database(name: String) -> Result<(), MongoError> {
        @native("mongo_drop_database", self.inner, name)
    }
    
    /// Start a session
    fn start_session() -> Result<MongoSession, MongoError> {
        let session = @native("mongo_start_session", self.inner)?
        Ok(MongoSession { inner: session, client: self })
    }
    
    /// Close the client
    fn close() {
        @native("mongo_close", self.inner)
    }
}

impl Drop for MongoClient {
    fn drop() { self.close() }
}

/// Database info
struct DatabaseInfo {
    name: String
    size_on_disk: Int64
    empty: Bool
}

/// MongoDB database
struct MongoDatabase {
    client: MongoClient
    name: String
}

impl MongoDatabase {
    /// Get a collection
    fn collection<T>(name: String) -> MongoCollection<T> {
        MongoCollection { db: self, name: name, _phantom: () }
    }
    
    /// List all collections
    fn list_collections() -> Result<[CollectionInfo], MongoError> {
        @native("mongo_list_collections", self.client.inner, self.name)
    }
    
    /// List collection names
    fn list_collection_names() -> Result<[String], MongoError> {
        @native("mongo_list_collection_names", self.client.inner, self.name)
    }
    
    /// Create a collection
    fn create_collection(name: String, options: CreateCollectionOptions) -> Result<(), MongoError> {
        @native("mongo_create_collection", self.client.inner, self.name, name, options)
    }
    
    /// Drop a collection
    fn drop_collection(name: String) -> Result<(), MongoError> {
        @native("mongo_drop_collection", self.client.inner, self.name, name)
    }
    
    /// Run a command
    fn run_command(command: Document) -> Result<Document, MongoError> {
        @native("mongo_run_command", self.client.inner, self.name, command)
    }
    
    /// Aggregate across collections
    fn aggregate(pipeline: [Document]) -> Result<MongoCursor<Document>, MongoError> {
        let cursor = @native("mongo_db_aggregate", self.client.inner, self.name, pipeline)?
        Ok(MongoCursor { inner: cursor })
    }
}

/// Collection info
struct CollectionInfo {
    name: String
    type_: String
    options: Document
}

/// Collection creation options
struct CreateCollectionOptions {
    capped: Option<Bool>
    size: Option<Int64>
    max: Option<Int64>
    validator: Option<Document>
    validation_level: Option<String>
    validation_action: Option<String>
}

impl CreateCollectionOptions {
    fn new() -> Self {
        CreateCollectionOptions {
            capped: None, size: None, max: None,
            validator: None, validation_level: None, validation_action: None
        }
    }
    
    fn capped(size: Int64, max_docs: Option<Int64>) -> Self {
        self.capped = Some(true)
        self.size = Some(size)
        self.max = max_docs
        self
    }
    
    fn validator(doc: Document) -> Self { self.validator = Some(doc); self }
    fn validation_level(level: String) -> Self { self.validation_level = Some(level); self }
    fn validation_action(action: String) -> Self { self.validation_action = Some(action); self }
}

// =============================================================================
// Collection
// =============================================================================

/// MongoDB collection
struct MongoCollection<T> {
    db: MongoDatabase
    name: String
    _phantom: ()
}

impl<T: Serialize + Deserialize> MongoCollection<T> {
    /// Insert one document
    fn insert_one(doc: T) -> Result<InsertOneResult, MongoError> {
        @native("mongo_insert_one", self.db.client.inner, self.db.name, self.name, doc)
    }
    
    /// Insert many documents
    fn insert_many(docs: [T]) -> Result<InsertManyResult, MongoError> {
        @native("mongo_insert_many", self.db.client.inner, self.db.name, self.name, docs)
    }
    
    /// Find documents
    fn find(filter: Document) -> Result<MongoCursor<T>, MongoError> {
        self.find_with_options(filter, FindOptions.new())
    }
    
    /// Find documents with options
    fn find_with_options(filter: Document, options: FindOptions) -> Result<MongoCursor<T>, MongoError> {
        let cursor = @native("mongo_find", self.db.client.inner, self.db.name, self.name, filter, options)?
        Ok(MongoCursor { inner: cursor })
    }
    
    /// Find one document
    fn find_one(filter: Document) -> Result<Option<T>, MongoError> {
        @native("mongo_find_one", self.db.client.inner, self.db.name, self.name, filter)
    }
    
    /// Find one document by ID
    fn find_by_id(id: ObjectId) -> Result<Option<T>, MongoError> {
        self.find_one(doc!{ "_id": id })
    }
    
    /// Update one document
    fn update_one(filter: Document, update: Document) -> Result<UpdateResult, MongoError> {
        @native("mongo_update_one", self.db.client.inner, self.db.name, self.name, filter, update)
    }
    
    /// Update many documents
    fn update_many(filter: Document, update: Document) -> Result<UpdateResult, MongoError> {
        @native("mongo_update_many", self.db.client.inner, self.db.name, self.name, filter, update)
    }
    
    /// Replace one document
    fn replace_one(filter: Document, replacement: T) -> Result<UpdateResult, MongoError> {
        @native("mongo_replace_one", self.db.client.inner, self.db.name, self.name, filter, replacement)
    }
    
    /// Delete one document
    fn delete_one(filter: Document) -> Result<DeleteResult, MongoError> {
        @native("mongo_delete_one", self.db.client.inner, self.db.name, self.name, filter)
    }
    
    /// Delete many documents
    fn delete_many(filter: Document) -> Result<DeleteResult, MongoError> {
        @native("mongo_delete_many", self.db.client.inner, self.db.name, self.name, filter)
    }
    
    /// Count documents
    fn count_documents(filter: Document) -> Result<Int64, MongoError> {
        @native("mongo_count_documents", self.db.client.inner, self.db.name, self.name, filter)
    }
    
    /// Estimated document count
    fn estimated_document_count() -> Result<Int64, MongoError> {
        @native("mongo_estimated_count", self.db.client.inner, self.db.name, self.name)
    }
    
    /// Distinct values
    fn distinct(field: String, filter: Document) -> Result<[Bson], MongoError> {
        @native("mongo_distinct", self.db.client.inner, self.db.name, self.name, field, filter)
    }
    
    /// Aggregate pipeline
    fn aggregate(pipeline: [Document]) -> Result<MongoCursor<Document>, MongoError> {
        let cursor = @native("mongo_aggregate", self.db.client.inner, self.db.name, self.name, pipeline)?
        Ok(MongoCursor { inner: cursor })
    }
    
    /// Find one and update
    fn find_one_and_update(filter: Document, update: Document) -> Result<Option<T>, MongoError> {
        @native("mongo_find_one_and_update", self.db.client.inner, self.db.name, self.name, filter, update)
    }
    
    /// Find one and replace
    fn find_one_and_replace(filter: Document, replacement: T) -> Result<Option<T>, MongoError> {
        @native("mongo_find_one_and_replace", self.db.client.inner, self.db.name, self.name, filter, replacement)
    }
    
    /// Find one and delete
    fn find_one_and_delete(filter: Document) -> Result<Option<T>, MongoError> {
        @native("mongo_find_one_and_delete", self.db.client.inner, self.db.name, self.name, filter)
    }
    
    /// Create an index
    fn create_index(keys: Document, options: IndexOptions) -> Result<String, MongoError> {
        @native("mongo_create_index", self.db.client.inner, self.db.name, self.name, keys, options)
    }
    
    /// Create multiple indexes
    fn create_indexes(indexes: [IndexModel]) -> Result<[String], MongoError> {
        @native("mongo_create_indexes", self.db.client.inner, self.db.name, self.name, indexes)
    }
    
    /// List indexes
    fn list_indexes() -> Result<[IndexModel], MongoError> {
        @native("mongo_list_indexes", self.db.client.inner, self.db.name, self.name)
    }
    
    /// Drop an index
    fn drop_index(name: String) -> Result<(), MongoError> {
        @native("mongo_drop_index", self.db.client.inner, self.db.name, self.name, name)
    }
    
    /// Drop all indexes
    fn drop_indexes() -> Result<(), MongoError> {
        @native("mongo_drop_indexes", self.db.client.inner, self.db.name, self.name)
    }
    
    /// Watch for changes
    fn watch(pipeline: [Document]) -> Result<ChangeStream<T>, MongoError> {
        let stream = @native("mongo_watch", self.db.client.inner, self.db.name, self.name, pipeline)?
        Ok(ChangeStream { inner: stream })
    }
    
    /// Bulk write operations
    fn bulk_write(operations: [WriteModel<T>]) -> Result<BulkWriteResult, MongoError> {
        @native("mongo_bulk_write", self.db.client.inner, self.db.name, self.name, operations)
    }
}

// =============================================================================
// Find Options
// =============================================================================

/// Find operation options
struct FindOptions {
    projection: Option<Document>
    sort: Option<Document>
    skip: Option<Int64>
    limit: Option<Int64>
    batch_size: Option<Int>
    hint: Option<Document>
    allow_disk_use: Bool
    no_cursor_timeout: Bool
}

impl FindOptions {
    fn new() -> Self {
        FindOptions {
            projection: None, sort: None, skip: None, limit: None,
            batch_size: None, hint: None, allow_disk_use: false, no_cursor_timeout: false
        }
    }
    
    fn projection(doc: Document) -> Self { self.projection = Some(doc); self }
    fn sort(doc: Document) -> Self { self.sort = Some(doc); self }
    fn skip(n: Int64) -> Self { self.skip = Some(n); self }
    fn limit(n: Int64) -> Self { self.limit = Some(n); self }
    fn batch_size(n: Int) -> Self { self.batch_size = Some(n); self }
    fn hint(doc: Document) -> Self { self.hint = Some(doc); self }
    fn allow_disk_use(allow: Bool) -> Self { self.allow_disk_use = allow; self }
    fn no_cursor_timeout(no_timeout: Bool) -> Self { self.no_cursor_timeout = no_timeout; self }
}

// =============================================================================
// Results
// =============================================================================

/// Insert one result
struct InsertOneResult {
    inserted_id: ObjectId
}

/// Insert many result
struct InsertManyResult {
    inserted_ids: Map<Int, ObjectId>
}

/// Update result
struct UpdateResult {
    matched_count: Int64
    modified_count: Int64
    upserted_id: Option<ObjectId>
}

/// Delete result
struct DeleteResult {
    deleted_count: Int64
}

/// Bulk write result
struct BulkWriteResult {
    inserted_count: Int64
    matched_count: Int64
    modified_count: Int64
    deleted_count: Int64
    upserted_count: Int64
    upserted_ids: Map<Int, ObjectId>
}

// =============================================================================
// Cursor
// =============================================================================

/// MongoDB cursor
struct MongoCursor<T> {
    inner: @native("MongoCursor")
}

impl<T: Deserialize> MongoCursor<T> {
    fn next() -> Option<Result<T, MongoError>> {
        @native("mongo_cursor_next", self.inner)
    }
    
    fn try_next() -> Result<Option<T>, MongoError> {
        @native("mongo_cursor_try_next", self.inner)
    }
    
    fn collect() -> Result<[T], MongoError> {
        var results = []
        while let Some(result) = self.next() {
            results.push(result?)
        }
        Ok(results)
    }
    
    fn close() {
        @native("mongo_cursor_close", self.inner)
    }
}

impl<T: Deserialize> Iterator for MongoCursor<T> {
    type Item = Result<T, MongoError>
    fn next() -> Option<Self.Item> { self.next() }
}

// =============================================================================
// Change Stream
// =============================================================================

/// Change stream for watching collection changes
struct ChangeStream<T> {
    inner: @native("MongoChangeStream")
}

impl<T: Deserialize> ChangeStream<T> {
    fn next() -> Option<Result<ChangeEvent<T>, MongoError>> {
        @native("mongo_change_stream_next", self.inner)
    }
    
    fn close() {
        @native("mongo_change_stream_close", self.inner)
    }
}

/// Change event
struct ChangeEvent<T> {
    operation_type: OperationType
    document_key: Document
    full_document: Option<T>
    update_description: Option<UpdateDescription>
    cluster_time: Timestamp
}

enum OperationType { Insert, Update, Replace, Delete, Invalidate, Drop, Rename }

struct UpdateDescription {
    updated_fields: Document
    removed_fields: [String]
}

// =============================================================================
// Index
// =============================================================================

/// Index model
struct IndexModel {
    keys: Document
    options: IndexOptions
}

/// Index options
struct IndexOptions {
    name: Option<String>
    unique: Bool
    sparse: Bool
    background: Bool
    expire_after_seconds: Option<Int>
    partial_filter_expression: Option<Document>
    weights: Option<Document>
    default_language: Option<String>
}

impl IndexOptions {
    fn new() -> Self {
        IndexOptions {
            name: None, unique: false, sparse: false, background: false,
            expire_after_seconds: None, partial_filter_expression: None,
            weights: None, default_language: None
        }
    }
    
    fn name(n: String) -> Self { self.name = Some(n); self }
    fn unique(u: Bool) -> Self { self.unique = u; self }
    fn sparse(s: Bool) -> Self { self.sparse = s; self }
    fn background(b: Bool) -> Self { self.background = b; self }
    fn expire_after(seconds: Int) -> Self { self.expire_after_seconds = Some(seconds); self }
    fn partial_filter(expr: Document) -> Self { self.partial_filter_expression = Some(expr); self }
}

// =============================================================================
// Session and Transactions
// =============================================================================

/// MongoDB session
struct MongoSession {
    inner: @native("MongoSession")
    client: MongoClient
}

impl MongoSession {
    /// Start a transaction
    fn start_transaction() -> Result<MongoTransaction, MongoError> {
        @native("mongo_start_transaction", self.inner)?
        Ok(MongoTransaction { session: self, committed: false })
    }
    
    /// Start a transaction with options
    fn start_transaction_with_options(options: TransactionOptions) -> Result<MongoTransaction, MongoError> {
        @native("mongo_start_transaction_with_options", self.inner, options)?
        Ok(MongoTransaction { session: self, committed: false })
    }
    
    fn end() {
        @native("mongo_end_session", self.inner)
    }
}

/// Transaction options
struct TransactionOptions {
    read_concern: Option<ReadConcern>
    write_concern: Option<WriteConcern>
    read_preference: Option<ReadPreference>
    max_commit_time_ms: Option<Int64>
}

impl TransactionOptions {
    fn new() -> Self {
        TransactionOptions {
            read_concern: None, write_concern: None,
            read_preference: None, max_commit_time_ms: None
        }
    }
}

/// MongoDB transaction
struct MongoTransaction {
    session: MongoSession
    committed: Bool
}

impl MongoTransaction {
    fn commit() -> Result<(), MongoError> {
        @native("mongo_commit_transaction", self.session.inner)?
        self.committed = true
        Ok(())
    }
    
    fn abort() -> Result<(), MongoError> {
        @native("mongo_abort_transaction", self.session.inner)?
        self.committed = true
        Ok(())
    }
}

impl Drop for MongoTransaction {
    fn drop() {
        if !self.committed {
            let _ = self.abort()
        }
    }
}

// =============================================================================
// Read/Write Concerns
// =============================================================================

enum ReadConcern { Local, Available, Majority, Linearizable, Snapshot }
enum WriteConcern { W0, W1, W2, W3, Majority, Custom(Int) }
enum ReadPreference { Primary, PrimaryPreferred, Secondary, SecondaryPreferred, Nearest }

// =============================================================================
// BSON Types
// =============================================================================

/// BSON value
enum Bson {
    Null
    Bool(Bool)
    Int32(Int32)
    Int64(Int64)
    Double(Float64)
    String(String)
    Array([Bson])
    Document(Document)
    Binary([UInt8])
    ObjectId(ObjectId)
    DateTime(DateTime)
    Timestamp(Timestamp)
    Regex(String, String)
    Decimal128(Decimal)
    Undefined
    MinKey
    MaxKey
}

/// BSON Document
struct Document {
    inner: Map<String, Bson>
}

impl Document {
    fn new() -> Self { Document { inner: Map.empty() } }
    
    fn get(key: String) -> Option<Bson> { self.inner.get(key) }
    fn get_str(key: String) -> Option<String> {
        match self.get(key)? { Bson.String(s) => Some(s), _ => None }
    }
    fn get_i64(key: String) -> Option<Int64> {
        match self.get(key)? {
            Bson.Int64(n) => Some(n),
            Bson.Int32(n) => Some(n as Int64),
            _ => None
        }
    }
    fn get_bool(key: String) -> Option<Bool> {
        match self.get(key)? { Bson.Bool(b) => Some(b), _ => None }
    }
    fn get_document(key: String) -> Option<Document> {
        match self.get(key)? { Bson.Document(d) => Some(d), _ => None }
    }
    fn get_array(key: String) -> Option<[Bson]> {
        match self.get(key)? { Bson.Array(a) => Some(a), _ => None }
    }
    fn get_object_id(key: String) -> Option<ObjectId> {
        match self.get(key)? { Bson.ObjectId(id) => Some(id), _ => None }
    }
    
    fn insert(key: String, value: Bson) { self.inner.set(key, value) }
    fn remove(key: String) -> Option<Bson> { self.inner.remove(key) }
    fn contains_key(key: String) -> Bool { self.inner.contains(key) }
    fn keys() -> [String] { self.inner.keys().collect() }
    fn len() -> Int { self.inner.len() }
    fn is_empty() -> Bool { self.inner.is_empty() }
    fn iter() -> impl Iterator<Item = (String, Bson)> { self.inner.iter() }
}

/// ObjectId
struct ObjectId {
    bytes: [UInt8; 12]
}

impl ObjectId {
    fn new() -> Self { ObjectId { bytes: @native("mongo_new_object_id") } }
    fn from_hex(hex: String) -> Result<Self, MongoError> { @native("mongo_object_id_from_hex", hex) }
    fn to_hex() -> String { @native("mongo_object_id_to_hex", self.bytes) }
    fn timestamp() -> DateTime { @native("mongo_object_id_timestamp", self.bytes) }
}

/// Timestamp
struct Timestamp {
    time: UInt32
    increment: UInt32
}

// =============================================================================
// Write Models for Bulk Operations
// =============================================================================

enum WriteModel<T> {
    InsertOne(T)
    UpdateOne { filter: Document, update: Document, upsert: Bool }
    UpdateMany { filter: Document, update: Document, upsert: Bool }
    ReplaceOne { filter: Document, replacement: T, upsert: Bool }
    DeleteOne { filter: Document }
    DeleteMany { filter: Document }
}

// =============================================================================
// Document Macro
// =============================================================================

/// Create a document using doc! macro syntax
macro doc {
    ($($key:expr => $value:expr),* $(,)?) => {
        {
            var doc = Document.new()
            $(doc.insert($key.to_string(), Bson.from($value));)*
            doc
        }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum MongoError {
    ConnectionFailed(String)
    AuthenticationFailed
    QueryFailed(String)
    WriteError(String)
    BulkWriteError(String)
    TransactionFailed(String)
    Timeout
    InvalidConfig(String)
    InvalidObjectId
    DocumentNotFound
    DuplicateKey
    Io(String)
}

impl Display for MongoError {
    fn fmt(f: Formatter) {
        match self {
            ConnectionFailed(s) => f.write(format!("Connection failed: {}", s))
            AuthenticationFailed => f.write("Authentication failed")
            QueryFailed(s) => f.write(format!("Query failed: {}", s))
            WriteError(s) => f.write(format!("Write error: {}", s))
            BulkWriteError(s) => f.write(format!("Bulk write error: {}", s))
            TransactionFailed(s) => f.write(format!("Transaction failed: {}", s))
            Timeout => f.write("Operation timed out")
            InvalidConfig(s) => f.write(format!("Invalid config: {}", s))
            InvalidObjectId => f.write("Invalid ObjectId")
            DocumentNotFound => f.write("Document not found")
            DuplicateKey => f.write("Duplicate key error")
            Io(s) => f.write(format!("IO error: {}", s))
        }
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Quick connect
fn connect(url: String) -> Result<MongoClient, MongoError> {
    MongoClient.connect_url(url)
}

// =============================================================================
// Tests
// =============================================================================

test "config builder" {
    let config = MongoConfig.new()
        .host("localhost", 27017)
        .database("mydb")
        .credentials("admin", "secret")
    
    assert_eq(config.hosts[0], ("localhost", 27017))?
    assert_eq(config.database, Some("mydb"))?
}

test "document operations" {
    var doc = Document.new()
    doc.insert("name", Bson.String("John"))
    doc.insert("age", Bson.Int32(30))
    
    assert_eq(doc.get_str("name"), Some("John"))?
    assert_eq(doc.get_i64("age"), Some(30))?
    assert(doc.contains_key("name"))?
    assert_eq(doc.len(), 2)?
}

test "object id" {
    let id = ObjectId.new()
    let hex = id.to_hex()
    assert_eq(hex.len(), 24)?
    
    let parsed = ObjectId.from_hex(hex)?
    assert_eq(parsed.to_hex(), hex)?
}

test "find options" {
    let options = FindOptions.new()
        .sort(doc!{ "created_at" => -1 })
        .limit(10)
        .skip(20)
    
    assert_eq(options.limit, Some(10))?
    assert_eq(options.skip, Some(20))?
}

test "index options" {
    let options = IndexOptions.new()
        .name("email_unique")
        .unique(true)
        .sparse(true)
    
    assert(options.unique)?
    assert(options.sparse)?
    assert_eq(options.name, Some("email_unique"))?
}
