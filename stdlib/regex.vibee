// =============================================================================
// Vibee OS â€” Regex Module
// Regular expressions
// =============================================================================

/// Compiled regular expression
struct Regex {
    pattern: String
    flags: RegexFlags
    compiled: @native("RegexCompiled")
    
    /// Compile regex pattern
    fn new(pattern: String) -> Result<Self, RegexError> {
        Self.with_flags(pattern, RegexFlags.default())
    }
    
    /// Compile with flags
    fn with_flags(pattern: String, flags: RegexFlags) -> Result<Self, RegexError> {
        let compiled = @native("regex_compile", pattern, flags)
            .map_err(|e| RegexError.CompileError(e))?
        Ok(Regex { pattern: pattern, flags: flags, compiled: compiled })
    }
    
    /// Case-insensitive regex
    fn case_insensitive(pattern: String) -> Result<Self, RegexError> {
        Self.with_flags(pattern, RegexFlags { case_insensitive: true, ..RegexFlags.default() })
    }
    
    /// Multiline regex
    fn multiline(pattern: String) -> Result<Self, RegexError> {
        Self.with_flags(pattern, RegexFlags { multiline: true, ..RegexFlags.default() })
    }
    
    /// Check if pattern matches anywhere in text
    fn is_match(text: String) -> Bool {
        @native("regex_is_match", self.compiled, text)
    }
    
    /// Find first match
    fn find(text: String) -> Option<Match> {
        @native("regex_find", self.compiled, text)
    }
    
    /// Find all matches
    fn find_all(text: String) -> [Match] {
        @native("regex_find_all", self.compiled, text)
    }
    
    /// Find with capture groups
    fn captures(text: String) -> Option<Captures> {
        @native("regex_captures", self.compiled, text)
    }
    
    /// Find all captures
    fn captures_all(text: String) -> [Captures] {
        @native("regex_captures_all", self.compiled, text)
    }
    
    /// Replace first match
    fn replace(text: String, replacement: String) -> String {
        @native("regex_replace", self.compiled, text, replacement)
    }
    
    /// Replace all matches
    fn replace_all(text: String, replacement: String) -> String {
        @native("regex_replace_all", self.compiled, text, replacement)
    }
    
    /// Replace with callback
    fn replace_with(text: String, f: fn(Match) -> String) -> String {
        var result = text
        var offset = 0
        
        for m in self.find_all(text) {
            let replacement = f(m)
            let start = m.start + offset
            let end = m.end + offset
            result = format!("{}{}{}", result[0..start], replacement, result[end..])
            offset += replacement.len() as Int - (m.end - m.start) as Int
        }
        result
    }
    
    /// Split text by pattern
    fn split(text: String) -> [String] {
        @native("regex_split", self.compiled, text)
    }
    
    /// Split with limit
    fn splitn(text: String, n: Int) -> [String] {
        @native("regex_splitn", self.compiled, text, n)
    }
    
    /// Get capture group names
    fn capture_names() -> [Option<String>] {
        @native("regex_capture_names", self.compiled)
    }
    
    /// Get number of capture groups
    fn captures_len() -> Int {
        @native("regex_captures_len", self.compiled)
    }
}

impl Display for Regex {
    fn fmt(f: Formatter) {
        f.write(self.pattern)
    }
}

/// Regex flags
struct RegexFlags {
    case_insensitive: Bool
    multiline: Bool
    dot_matches_newline: Bool
    unicode: Bool
    
    fn default() -> Self {
        RegexFlags {
            case_insensitive: false,
            multiline: false,
            dot_matches_newline: false,
            unicode: true
        }
    }
}

/// Match result
struct Match {
    start: Int
    end: Int
    text: String
    
    fn len() -> Int { self.end - self.start }
    fn is_empty() -> Bool { self.start == self.end }
    fn range() -> (Int, Int) { (self.start, self.end) }
}

/// Capture groups
struct Captures {
    groups: [Option<Match>]
    named: Map<String, Match>
    
    /// Get capture by index
    fn get(index: Int) -> Option<Match> {
        self.groups.get(index).flatten()
    }
    
    /// Get capture by name
    fn name(name: String) -> Option<Match> {
        self.named.get(name)
    }
    
    /// Get full match (group 0)
    fn full() -> Option<Match> {
        self.get(0)
    }
    
    /// Number of groups
    fn len() -> Int {
        self.groups.len()
    }
    
    /// Iterate over groups
    fn iter() -> impl Iterator<Item = Option<Match>> {
        self.groups.iter()
    }
}

/// Regex error
enum RegexError {
    CompileError(String)
    InvalidEscape
    UnmatchedParen
    InvalidRepetition
}

impl Display for RegexError {
    fn fmt(f: Formatter) {
        match self {
            CompileError(s) => f.write(format!("Regex compile error: {}", s))
            InvalidEscape => f.write("Invalid escape sequence")
            UnmatchedParen => f.write("Unmatched parenthesis")
            InvalidRepetition => f.write("Invalid repetition")
        }
    }
}

// -----------------------------------------------------------------------------
// Regex Builder
// -----------------------------------------------------------------------------

/// Fluent regex builder
struct RegexBuilder {
    parts: [String]
    flags: RegexFlags
    
    fn new() -> Self {
        RegexBuilder { parts: [], flags: RegexFlags.default() }
    }
    
    fn literal(s: String) -> Self { self.parts.push(escape(s)); self }
    fn any() -> Self { self.parts.push("."); self }
    fn digit() -> Self { self.parts.push("\\d"); self }
    fn non_digit() -> Self { self.parts.push("\\D"); self }
    fn word() -> Self { self.parts.push("\\w"); self }
    fn non_word() -> Self { self.parts.push("\\W"); self }
    fn whitespace() -> Self { self.parts.push("\\s"); self }
    fn non_whitespace() -> Self { self.parts.push("\\S"); self }
    fn start() -> Self { self.parts.push("^"); self }
    fn end() -> Self { self.parts.push("$"); self }
    fn word_boundary() -> Self { self.parts.push("\\b"); self }
    
    fn char_class(chars: String) -> Self {
        self.parts.push(format!("[{}]", chars)); self
    }
    
    fn negated_class(chars: String) -> Self {
        self.parts.push(format!("[^{}]", chars)); self
    }
    
    fn range(start: Char, end: Char) -> Self {
        self.parts.push(format!("[{}-{}]", start, end)); self
    }
    
    fn group(inner: String) -> Self {
        self.parts.push(format!("({})", inner)); self
    }
    
    fn named_group(name: String, inner: String) -> Self {
        self.parts.push(format!("(?P<{}>{})", name, inner)); self
    }
    
    fn non_capturing(inner: String) -> Self {
        self.parts.push(format!("(?:{})", inner)); self
    }
    
    fn optional() -> Self { self.parts.push("?"); self }
    fn zero_or_more() -> Self { self.parts.push("*"); self }
    fn one_or_more() -> Self { self.parts.push("+"); self }
    fn exactly(n: Int) -> Self { self.parts.push(format!("{{{}}}", n)); self }
    fn at_least(n: Int) -> Self { self.parts.push(format!("{{{},}}", n)); self }
    fn between(min: Int, max: Int) -> Self { self.parts.push(format!("{{{},{}}}", min, max)); self }
    fn lazy() -> Self { self.parts.push("?"); self }
    
    fn or(alt: String) -> Self { self.parts.push(format!("|{}", alt)); self }
    
    fn case_insensitive() -> Self {
        self.flags.case_insensitive = true; self
    }
    
    fn multiline() -> Self {
        self.flags.multiline = true; self
    }
    
    fn build() -> Result<Regex, RegexError> {
        Regex.with_flags(self.parts.join(""), self.flags)
    }
}

// -----------------------------------------------------------------------------
// Utility Functions
// -----------------------------------------------------------------------------

/// Escape special regex characters
fn escape(s: String) -> String {
    var result = ""
    for c in s.chars() {
        match c {
            '\\' | '.' | '+' | '*' | '?' | '(' | ')' | '[' | ']' | '{' | '}' | '|' | '^' | '$' => {
                result.push('\\')
                result.push(c)
            }
            _ => result.push(c)
        }
    }
    result
}

/// Quick match check
fn is_match(pattern: String, text: String) -> Bool {
    Regex.new(pattern).map(|r| r.is_match(text)).unwrap_or(false)
}

/// Quick find
fn find(pattern: String, text: String) -> Option<Match> {
    Regex.new(pattern).ok()?.find(text)
}

/// Quick replace
fn replace(pattern: String, text: String, replacement: String) -> String {
    Regex.new(pattern).map(|r| r.replace(text, replacement)).unwrap_or(text)
}

/// Quick replace all
fn replace_all(pattern: String, text: String, replacement: String) -> String {
    Regex.new(pattern).map(|r| r.replace_all(text, replacement)).unwrap_or(text)
}

/// Quick split
fn split(pattern: String, text: String) -> [String] {
    Regex.new(pattern).map(|r| r.split(text)).unwrap_or([text])
}

// -----------------------------------------------------------------------------
// Common Patterns
// -----------------------------------------------------------------------------

module Patterns {
    fn EMAIL() -> String { r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}" }
    fn URL() -> String { r"https?://[^\s]+" }
    fn IPV4() -> String { r"\b(?:\d{1,3}\.){3}\d{1,3}\b" }
    fn IPV6() -> String { r"(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}" }
    fn PHONE() -> String { r"\+?[\d\s\-\(\)]{10,}" }
    fn DATE_ISO() -> String { r"\d{4}-\d{2}-\d{2}" }
    fn TIME_24H() -> String { r"(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d)?" }
    fn HEX_COLOR() -> String { r"#(?:[0-9a-fA-F]{3}){1,2}" }
    fn UUID() -> String { r"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}" }
    fn SLUG() -> String { r"[a-z0-9]+(?:-[a-z0-9]+)*" }
    fn USERNAME() -> String { r"[a-zA-Z][a-zA-Z0-9_]{2,}" }
    fn PASSWORD_STRONG() -> String { r"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$" }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "is_match" {
    let re = Regex.new(r"\d+")?
    assert(re.is_match("abc123def"))?
    assert(!re.is_match("abcdef"))?
}

test "find" {
    let re = Regex.new(r"\d+")?
    let m = re.find("abc123def")?
    assert_eq(m.text, "123")?
    assert_eq(m.start, 3)?
}

test "find_all" {
    let re = Regex.new(r"\d+")?
    let matches = re.find_all("a1b22c333")
    assert_eq(matches.len(), 3)?
    assert_eq(matches[2].text, "333")?
}

test "captures" {
    let re = Regex.new(r"(\w+)@(\w+)\.(\w+)")?
    let caps = re.captures("user@example.com")?
    assert_eq(caps.get(1)?.text, "user")?
    assert_eq(caps.get(2)?.text, "example")?
}

test "named captures" {
    let re = Regex.new(r"(?P<user>\w+)@(?P<domain>\w+\.\w+)")?
    let caps = re.captures("user@example.com")?
    assert_eq(caps.name("user")?.text, "user")?
}

test "replace" {
    let re = Regex.new(r"\d+")?
    assert_eq(re.replace("a1b2c3", "X"), "aXb2c3")?
    assert_eq(re.replace_all("a1b2c3", "X"), "aXbXcX")?
}

test "split" {
    let re = Regex.new(r"\s+")?
    let parts = re.split("hello   world  test")
    assert_eq(parts, ["hello", "world", "test"])?
}

test "escape" {
    assert_eq(escape("a.b*c"), r"a\.b\*c")?
}

test "case insensitive" {
    let re = Regex.case_insensitive("hello")?
    assert(re.is_match("HELLO"))?
}
