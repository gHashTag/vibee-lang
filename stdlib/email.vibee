// =============================================================================
// Vibee OS â€” Email Module
// Email sending and parsing
// =============================================================================

/// Email message
struct Email {
    from: Address
    to: [Address]
    cc: [Address]
    bcc: [Address]
    reply_to: Option<Address>
    subject: String
    text: Option<String>
    html: Option<String>
    attachments: [Attachment]
    headers: Map<String, String>
}

impl Email {
    fn new() -> Self { Email { from: Address.empty(), to: [], cc: [], bcc: [], reply_to: None, subject: "", text: None, html: None, attachments: [], headers: Map.empty() } }
    
    fn from(addr: String) -> Self { self.from = Address.parse(addr).unwrap_or(Address.empty()); self }
    fn from_named(name: String, addr: String) -> Self { self.from = Address { name: Some(name), email: addr }; self }
    fn to(addr: String) -> Self { if let Ok(a) = Address.parse(addr) { self.to.push(a) } self }
    fn cc(addr: String) -> Self { if let Ok(a) = Address.parse(addr) { self.cc.push(a) } self }
    fn bcc(addr: String) -> Self { if let Ok(a) = Address.parse(addr) { self.bcc.push(a) } self }
    fn reply_to(addr: String) -> Self { self.reply_to = Address.parse(addr).ok(); self }
    fn subject(s: String) -> Self { self.subject = s; self }
    fn text(s: String) -> Self { self.text = Some(s); self }
    fn html(s: String) -> Self { self.html = Some(s); self }
    fn attach(a: Attachment) -> Self { self.attachments.push(a); self }
    fn attach_file(path: String) -> Self { if let Ok(a) = Attachment.from_file(path) { self.attachments.push(a) } self }
    fn header(name: String, value: String) -> Self { self.headers.set(name, value); self }
    
    fn to_mime() -> String { @native("email_to_mime", self) }
    fn parse(raw: String) -> Result<Self, EmailError> { @native("email_parse", raw) }
}

/// Email address
struct Address { name: Option<String>, email: String }
impl Address {
    fn new(email: String) -> Self { Address { name: None, email: email } }
    fn named(name: String, email: String) -> Self { Address { name: Some(name), email: email } }
    fn empty() -> Self { Address { name: None, email: "" } }
    
    fn parse(s: String) -> Result<Self, EmailError> {
        let s = s.trim()
        if s.contains("<") {
            let start = s.find("<").unwrap()
            let end = s.find(">").ok_or(EmailError.InvalidAddress)?
            let name = s[0..start].trim().trim_matches('"')
            let email = s[(start+1)..end]
            Ok(Address { name: if name.is_empty() { None } else { Some(name) }, email: email })
        } else {
            Ok(Address { name: None, email: s })
        }
    }
    
    fn to_string() -> String {
        match self.name { Some(n) => format!("\"{}\" <{}>", n, self.email), None => self.email.clone() }
    }
    
    fn domain() -> Option<String> { self.email.split("@").nth(1).map(|s| s.to_string()) }
    fn local_part() -> Option<String> { self.email.split("@").nth(0).map(|s| s.to_string()) }
}

/// Email attachment
struct Attachment { filename: String, content_type: String, data: [UInt8] }
impl Attachment {
    fn new(filename: String, content_type: String, data: [UInt8]) -> Self { Attachment { filename: filename, content_type: content_type, data: data } }
    fn from_file(path: String) -> Result<Self, EmailError> {
        let data = @native("read_file_bytes", path)?
        let filename = path.split("/").last().unwrap_or(path)
        let content_type = mimetype.from_path(path).map(|m| m.to_string()).unwrap_or("application/octet-stream")
        Ok(Attachment { filename: filename, content_type: content_type, data: data })
    }
    fn text(filename: String, content: String) -> Self { Self.new(filename, "text/plain", content.as_bytes()) }
}

/// SMTP Client
struct SmtpClient {
    host: String
    port: Int
    username: Option<String>
    password: Option<String>
    encryption: SmtpEncryption
    timeout_ms: Int64
}

enum SmtpEncryption { None, StartTls, Tls }

impl SmtpClient {
    fn new(host: String) -> Self { SmtpClient { host: host, port: 587, username: None, password: None, encryption: SmtpEncryption.StartTls, timeout_ms: 30000 } }
    fn port(p: Int) -> Self { self.port = p; self }
    fn credentials(user: String, pass: String) -> Self { self.username = Some(user); self.password = Some(pass); self }
    fn tls() -> Self { self.encryption = SmtpEncryption.Tls; self.port = 465; self }
    fn starttls() -> Self { self.encryption = SmtpEncryption.StartTls; self.port = 587; self }
    fn plain() -> Self { self.encryption = SmtpEncryption.None; self.port = 25; self }
    fn timeout(ms: Int64) -> Self { self.timeout_ms = ms; self }
    
    fn send(email: Email) -> Result<(), EmailError> { @native("smtp_send", self, email) }
    fn send_batch(emails: [Email]) -> [Result<(), EmailError>] { emails.iter().map(|e| self.send(e)).collect() }
    fn verify() -> Result<(), EmailError> { @native("smtp_verify", self) }
    
    // Common providers
    fn gmail(user: String, pass: String) -> Self { Self.new("smtp.gmail.com").tls().credentials(user, pass) }
    fn outlook(user: String, pass: String) -> Self { Self.new("smtp.office365.com").starttls().credentials(user, pass) }
    fn sendgrid(api_key: String) -> Self { Self.new("smtp.sendgrid.net").tls().credentials("apikey", api_key) }
}

/// Email validation
fn is_valid_email(email: String) -> Bool {
    let parts = email.split("@")
    if parts.len() != 2 { return false }
    let local = parts[0]
    let domain = parts[1]
    !local.is_empty() && !domain.is_empty() && domain.contains(".") && !domain.starts_with(".") && !domain.ends_with(".")
}

enum EmailError { InvalidAddress, ConnectionFailed, AuthFailed, SendFailed, ParseError, Other(String) }
impl Display for EmailError {
    fn fmt(f: Formatter) { match self { InvalidAddress => f.write("Invalid email address"), ConnectionFailed => f.write("Connection failed"), AuthFailed => f.write("Authentication failed"), SendFailed => f.write("Send failed"), ParseError => f.write("Parse error"), Other(s) => f.write(s) } }
}

// Tests
test "address parse" {
    let addr = Address.parse("John Doe <john@example.com>")?
    assert_eq(addr.name, Some("John Doe"))?
    assert_eq(addr.email, "john@example.com")?
}

test "email builder" {
    let email = Email.new().from("sender@example.com").to("recipient@example.com").subject("Hello").text("World")
    assert_eq(email.subject, "Hello")?
    assert_eq(email.to.len(), 1)?
}

test "validate email" {
    assert(is_valid_email("test@example.com"))?
    assert(!is_valid_email("invalid"))?
    assert(!is_valid_email("@example.com"))?
}
