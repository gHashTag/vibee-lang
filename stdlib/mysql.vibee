// =============================================================================
// Vibee OS â€” MySQL Module
// MySQL/MariaDB database client
// =============================================================================

// =============================================================================
// Connection Configuration
// =============================================================================

/// MySQL connection configuration
struct MysqlConfig {
    host: String
    port: UInt16
    database: String
    user: String
    password: Option<String>
    charset: String
    ssl_mode: MysqlSslMode
    connect_timeout_ms: Int64
    socket: Option<String>
    options: Map<String, String>
}

impl MysqlConfig {
    fn new(database: String) -> Self {
        MysqlConfig {
            host: "localhost",
            port: 3306,
            database: database,
            user: "root",
            password: None,
            charset: "utf8mb4",
            ssl_mode: MysqlSslMode.Preferred,
            connect_timeout_ms: 30000,
            socket: None,
            options: Map.empty()
        }
    }
    
    fn from_url(url: String) -> Result<Self, MysqlError> {
        // mysql://user:password@host:port/database?options
        @native("mysql_parse_url", url)
    }
    
    fn host(h: String) -> Self { self.host = h; self }
    fn port(p: UInt16) -> Self { self.port = p; self }
    fn user(u: String) -> Self { self.user = u; self }
    fn password(p: String) -> Self { self.password = Some(p); self }
    fn charset(c: String) -> Self { self.charset = c; self }
    fn ssl_mode(m: MysqlSslMode) -> Self { self.ssl_mode = m; self }
    fn timeout(ms: Int64) -> Self { self.connect_timeout_ms = ms; self }
    fn socket(s: String) -> Self { self.socket = Some(s); self }
    fn option(key: String, value: String) -> Self { self.options.set(key, value); self }
}

enum MysqlSslMode { Disabled, Preferred, Required, VerifyCa, VerifyIdentity }

// =============================================================================
// Connection
// =============================================================================

/// MySQL connection
struct MysqlConnection {
    inner: @native("MysqlConn")
    config: MysqlConfig
    in_transaction: Bool
}

impl MysqlConnection {
    fn connect(config: MysqlConfig) -> Result<Self, MysqlError> {
        let inner = @native("mysql_connect", config)?
        Ok(MysqlConnection { inner: inner, config: config, in_transaction: false })
    }
    
    fn connect_url(url: String) -> Result<Self, MysqlError> {
        Self.connect(MysqlConfig.from_url(url)?)
    }
    
    /// Execute a query without returning rows
    fn execute(sql: String, params: [MysqlValue]) -> Result<MysqlResult, MysqlError> {
        @native("mysql_execute", self.inner, sql, params)
    }
    
    /// Execute a query and return rows
    fn query(sql: String, params: [MysqlValue]) -> Result<MysqlRows, MysqlError> {
        let rows = @native("mysql_query", self.inner, sql, params)?
        Ok(MysqlRows { inner: rows })
    }
    
    /// Execute a query and return a single row
    fn query_one(sql: String, params: [MysqlValue]) -> Result<MysqlRow, MysqlError> {
        let rows = self.query(sql, params)?
        rows.next().ok_or(MysqlError.NoRows)
    }
    
    /// Execute a query and return an optional row
    fn query_opt(sql: String, params: [MysqlValue]) -> Result<Option<MysqlRow>, MysqlError> {
        let rows = self.query(sql, params)?
        Ok(rows.next())
    }
    
    /// Prepare a statement
    fn prepare(sql: String) -> Result<MysqlStatement, MysqlError> {
        let stmt = @native("mysql_prepare", self.inner, sql)?
        Ok(MysqlStatement { inner: stmt, conn: self })
    }
    
    /// Begin a transaction
    fn begin() -> Result<MysqlTransaction, MysqlError> {
        self.execute("START TRANSACTION", [])?
        self.in_transaction = true
        Ok(MysqlTransaction { conn: self, committed: false })
    }
    
    /// Begin a transaction with isolation level
    fn begin_with_isolation(level: IsolationLevel) -> Result<MysqlTransaction, MysqlError> {
        self.execute(format!("SET TRANSACTION ISOLATION LEVEL {}", level.to_string()), [])?
        self.begin()
    }
    
    /// Execute multiple statements
    fn multi_query(sql: String) -> Result<[MysqlResult], MysqlError> {
        @native("mysql_multi_query", self.inner, sql)
    }
    
    /// Get last insert ID
    fn last_insert_id() -> Int64 {
        @native("mysql_last_insert_id", self.inner)
    }
    
    /// Get affected rows from last query
    fn affected_rows() -> Int64 {
        @native("mysql_affected_rows", self.inner)
    }
    
    /// Ping the server
    fn ping() -> Bool {
        @native("mysql_ping", self.inner)
    }
    
    /// Get server info
    fn server_info() -> String {
        @native("mysql_server_info", self.inner)
    }
    
    /// Get server version
    fn server_version() -> Int {
        @native("mysql_server_version", self.inner)
    }
    
    /// Escape a string for safe SQL inclusion
    fn escape_string(s: String) -> String {
        @native("mysql_escape_string", self.inner, s)
    }
    
    /// Close the connection
    fn close() {
        @native("mysql_close", self.inner)
    }
    
    /// Select a different database
    fn select_db(database: String) -> Result<(), MysqlError> {
        @native("mysql_select_db", self.inner, database)
    }
    
    /// Set character set
    fn set_charset(charset: String) -> Result<(), MysqlError> {
        @native("mysql_set_charset", self.inner, charset)
    }
}

impl Drop for MysqlConnection {
    fn drop() { self.close() }
}

/// Transaction isolation levels
enum IsolationLevel {
    ReadUncommitted
    ReadCommitted
    RepeatableRead
    Serializable
}

impl IsolationLevel {
    fn to_string() -> String {
        match self {
            ReadUncommitted => "READ UNCOMMITTED"
            ReadCommitted => "READ COMMITTED"
            RepeatableRead => "REPEATABLE READ"
            Serializable => "SERIALIZABLE"
        }
    }
}

// =============================================================================
// Prepared Statement
// =============================================================================

/// Prepared statement
struct MysqlStatement {
    inner: @native("MysqlStmt")
    conn: MysqlConnection
}

impl MysqlStatement {
    fn execute(params: [MysqlValue]) -> Result<MysqlResult, MysqlError> {
        @native("mysql_stmt_execute", self.inner, params)
    }
    
    fn query(params: [MysqlValue]) -> Result<MysqlRows, MysqlError> {
        let rows = @native("mysql_stmt_query", self.inner, params)?
        Ok(MysqlRows { inner: rows })
    }
    
    fn query_one(params: [MysqlValue]) -> Result<MysqlRow, MysqlError> {
        self.query(params)?.next().ok_or(MysqlError.NoRows)
    }
    
    fn close() {
        @native("mysql_stmt_close", self.inner)
    }
    
    fn param_count() -> Int {
        @native("mysql_stmt_param_count", self.inner)
    }
}

// =============================================================================
// Transaction
// =============================================================================

/// Transaction handle
struct MysqlTransaction {
    conn: MysqlConnection
    committed: Bool
}

impl MysqlTransaction {
    fn execute(sql: String, params: [MysqlValue]) -> Result<MysqlResult, MysqlError> {
        self.conn.execute(sql, params)
    }
    
    fn query(sql: String, params: [MysqlValue]) -> Result<MysqlRows, MysqlError> {
        self.conn.query(sql, params)
    }
    
    fn query_one(sql: String, params: [MysqlValue]) -> Result<MysqlRow, MysqlError> {
        self.conn.query_one(sql, params)
    }
    
    fn commit() -> Result<(), MysqlError> {
        self.conn.execute("COMMIT", [])?
        self.conn.in_transaction = false
        self.committed = true
        Ok(())
    }
    
    fn rollback() -> Result<(), MysqlError> {
        self.conn.execute("ROLLBACK", [])?
        self.conn.in_transaction = false
        self.committed = true
        Ok(())
    }
    
    fn savepoint(name: String) -> Result<MysqlSavepoint, MysqlError> {
        self.conn.execute(format!("SAVEPOINT {}", name), [])?
        Ok(MysqlSavepoint { tx: self, name: name })
    }
}

impl Drop for MysqlTransaction {
    fn drop() {
        if !self.committed {
            let _ = self.rollback()
        }
    }
}

/// Savepoint within a transaction
struct MysqlSavepoint {
    tx: MysqlTransaction
    name: String
}

impl MysqlSavepoint {
    fn release() -> Result<(), MysqlError> {
        self.tx.conn.execute(format!("RELEASE SAVEPOINT {}", self.name), [])?
        Ok(())
    }
    
    fn rollback() -> Result<(), MysqlError> {
        self.tx.conn.execute(format!("ROLLBACK TO SAVEPOINT {}", self.name), [])?
        Ok(())
    }
}

// =============================================================================
// Result and Rows
// =============================================================================

/// Query execution result
struct MysqlResult {
    affected_rows: Int64
    last_insert_id: Int64
    warnings: Int
}

/// Query result rows
struct MysqlRows {
    inner: @native("MysqlRows")
}

impl MysqlRows {
    fn next() -> Option<MysqlRow> {
        @native("mysql_rows_next", self.inner).map(|r| MysqlRow { inner: r })
    }
    
    fn columns() -> [MysqlColumn] {
        @native("mysql_rows_columns", self.inner)
    }
    
    fn num_rows() -> Int64 {
        @native("mysql_rows_num_rows", self.inner)
    }
}

impl Iterator for MysqlRows {
    type Item = MysqlRow
    fn next() -> Option<MysqlRow> { self.next() }
}

/// Single row
struct MysqlRow {
    inner: @native("MysqlRow")
}

impl MysqlRow {
    fn get<T: FromMysqlValue>(index: Int) -> Result<T, MysqlError> {
        let value = @native("mysql_row_get", self.inner, index)?
        T.from_mysql_value(value)
    }
    
    fn get_by_name<T: FromMysqlValue>(name: String) -> Result<T, MysqlError> {
        let value = @native("mysql_row_get_by_name", self.inner, name)?
        T.from_mysql_value(value)
    }
    
    fn try_get<T: FromMysqlValue>(index: Int) -> Option<T> {
        self.get(index).ok()
    }
    
    fn is_null(index: Int) -> Bool {
        @native("mysql_row_is_null", self.inner, index)
    }
    
    fn len() -> Int {
        @native("mysql_row_len", self.inner)
    }
}

/// Column metadata
struct MysqlColumn {
    name: String
    table: String
    type_: MysqlType
    flags: Int
    decimals: Int
    max_length: Int
}

/// MySQL data types
enum MysqlType {
    Decimal, Tiny, Short, Long, Float, Double, Null, Timestamp,
    LongLong, Int24, Date, Time, DateTime, Year, NewDate, Varchar,
    Bit, Json, NewDecimal, Enum, Set, TinyBlob, MediumBlob, LongBlob,
    Blob, VarString, String, Geometry
}

// =============================================================================
// Values
// =============================================================================

/// MySQL value types
enum MysqlValue {
    Null
    Bool(Bool)
    Int(Int64)
    UInt(UInt64)
    Float(Float64)
    String(String)
    Bytes([UInt8])
    Date(Date)
    Time(Time)
    DateTime(DateTime)
    Timestamp(Int64)
    Json(JsonValue)
}

impl MysqlValue {
    fn null() -> Self { MysqlValue.Null }
    fn bool(v: Bool) -> Self { MysqlValue.Bool(v) }
    fn int(v: Int64) -> Self { MysqlValue.Int(v) }
    fn uint(v: UInt64) -> Self { MysqlValue.UInt(v) }
    fn float(v: Float64) -> Self { MysqlValue.Float(v) }
    fn string(v: String) -> Self { MysqlValue.String(v) }
    fn bytes(v: [UInt8]) -> Self { MysqlValue.Bytes(v) }
    fn date(v: Date) -> Self { MysqlValue.Date(v) }
    fn time(v: Time) -> Self { MysqlValue.Time(v) }
    fn datetime(v: DateTime) -> Self { MysqlValue.DateTime(v) }
    fn json(v: JsonValue) -> Self { MysqlValue.Json(v) }
    
    fn is_null() -> Bool { matches!(self, Null) }
}

/// Trait for converting from MysqlValue
trait FromMysqlValue {
    fn from_mysql_value(value: MysqlValue) -> Result<Self, MysqlError>
}

impl FromMysqlValue for Bool {
    fn from_mysql_value(value: MysqlValue) -> Result<Self, MysqlError> {
        match value {
            MysqlValue.Bool(v) => Ok(v),
            MysqlValue.Int(v) => Ok(v != 0),
            _ => Err(MysqlError.TypeMismatch)
        }
    }
}

impl FromMysqlValue for Int64 {
    fn from_mysql_value(value: MysqlValue) -> Result<Self, MysqlError> {
        match value {
            MysqlValue.Int(v) => Ok(v),
            MysqlValue.UInt(v) => Ok(v as Int64),
            _ => Err(MysqlError.TypeMismatch)
        }
    }
}

impl FromMysqlValue for String {
    fn from_mysql_value(value: MysqlValue) -> Result<Self, MysqlError> {
        match value {
            MysqlValue.String(v) => Ok(v),
            MysqlValue.Bytes(v) => String.from_utf8(v).map_err(|_| MysqlError.TypeMismatch),
            _ => Err(MysqlError.TypeMismatch)
        }
    }
}

impl<T: FromMysqlValue> FromMysqlValue for Option<T> {
    fn from_mysql_value(value: MysqlValue) -> Result<Self, MysqlError> {
        match value {
            MysqlValue.Null => Ok(None),
            v => Ok(Some(T.from_mysql_value(v)?))
        }
    }
}

/// Trait for converting to MysqlValue
trait ToMysqlValue {
    fn to_mysql_value() -> MysqlValue
}

impl ToMysqlValue for Bool { fn to_mysql_value() -> MysqlValue { MysqlValue.Bool(self) } }
impl ToMysqlValue for Int64 { fn to_mysql_value() -> MysqlValue { MysqlValue.Int(self) } }
impl ToMysqlValue for String { fn to_mysql_value() -> MysqlValue { MysqlValue.String(self) } }
impl<T: ToMysqlValue> ToMysqlValue for Option<T> {
    fn to_mysql_value() -> MysqlValue {
        match self { Some(v) => v.to_mysql_value(), None => MysqlValue.Null }
    }
}

// =============================================================================
// Connection Pool
// =============================================================================

/// Connection pool
actor MysqlPool {
    state config: MysqlConfig
    state connections: [MysqlConnection]
    state available: [MysqlConnection]
    state min_size: Int
    state max_size: Int
    state waiting: [fn(MysqlConnection)]
    
    fn new(config: MysqlConfig) -> Result<Self, MysqlError> {
        Self.with_size(config, 5, 20)
    }
    
    fn with_size(config: MysqlConfig, min: Int, max: Int) -> Result<Self, MysqlError> {
        var pool = MysqlPool {
            config: config,
            connections: [],
            available: [],
            min_size: min,
            max_size: max,
            waiting: []
        }
        
        for _ in 0..min {
            let conn = MysqlConnection.connect(config.clone())?
            pool.connections.push(conn.clone())
            pool.available.push(conn)
        }
        
        Ok(pool)
    }
    
    fn acquire() -> Result<MysqlPooledConnection, MysqlError> {
        if let Some(conn) = self.available.pop() {
            if conn.ping() {
                return Ok(MysqlPooledConnection { conn: conn, pool: self })
            }
            self.connections.retain(|c| c != conn)
        }
        
        if self.connections.len() < self.max_size {
            let conn = MysqlConnection.connect(self.config.clone())?
            self.connections.push(conn.clone())
            return Ok(MysqlPooledConnection { conn: conn, pool: self })
        }
        
        @native("mysql_pool_wait", self)
    }
    
    fn release(conn: MysqlConnection) {
        if conn.ping() && !conn.in_transaction {
            self.available.push(conn)
            if let Some(waiter) = self.waiting.pop() {
                if let Some(c) = self.available.pop() {
                    waiter(c)
                }
            }
        } else {
            self.connections.retain(|c| c != conn)
        }
    }
    
    fn size() -> Int { self.connections.len() }
    fn available_count() -> Int { self.available.len() }
    
    fn close() {
        for conn in self.connections { conn.close() }
        self.connections.clear()
        self.available.clear()
    }
}

/// Pooled connection wrapper
struct MysqlPooledConnection {
    conn: MysqlConnection
    pool: MysqlPool
}

impl MysqlPooledConnection {
    fn execute(sql: String, params: [MysqlValue]) -> Result<MysqlResult, MysqlError> {
        self.conn.execute(sql, params)
    }
    
    fn query(sql: String, params: [MysqlValue]) -> Result<MysqlRows, MysqlError> {
        self.conn.query(sql, params)
    }
    
    fn query_one(sql: String, params: [MysqlValue]) -> Result<MysqlRow, MysqlError> {
        self.conn.query_one(sql, params)
    }
    
    fn begin() -> Result<MysqlTransaction, MysqlError> {
        self.conn.begin()
    }
    
    fn last_insert_id() -> Int64 {
        self.conn.last_insert_id()
    }
}

impl Drop for MysqlPooledConnection {
    fn drop() { self.pool.release(self.conn) }
}

// =============================================================================
// Query Builder
// =============================================================================

/// SQL query builder for MySQL
struct MysqlQueryBuilder {
    parts: [String]
    params: [MysqlValue]
}

impl MysqlQueryBuilder {
    fn new() -> Self { MysqlQueryBuilder { parts: [], params: [] } }
    
    fn select(columns: [String]) -> Self {
        self.parts.push(format!("SELECT {}", columns.join(", ")))
        self
    }
    
    fn from(table: String) -> Self {
        self.parts.push(format!("FROM `{}`", table))
        self
    }
    
    fn where_(condition: String, params: [MysqlValue]) -> Self {
        self.parts.push(format!("WHERE {}", condition))
        self.params.extend(params)
        self
    }
    
    fn and(condition: String, params: [MysqlValue]) -> Self {
        self.parts.push(format!("AND {}", condition))
        self.params.extend(params)
        self
    }
    
    fn or(condition: String, params: [MysqlValue]) -> Self {
        self.parts.push(format!("OR {}", condition))
        self.params.extend(params)
        self
    }
    
    fn order_by(column: String, direction: String) -> Self {
        self.parts.push(format!("ORDER BY `{}` {}", column, direction))
        self
    }
    
    fn limit(n: Int) -> Self {
        self.parts.push(format!("LIMIT {}", n))
        self
    }
    
    fn offset(n: Int) -> Self {
        self.parts.push(format!("OFFSET {}", n))
        self
    }
    
    fn join(table: String, condition: String) -> Self {
        self.parts.push(format!("JOIN `{}` ON {}", table, condition))
        self
    }
    
    fn left_join(table: String, condition: String) -> Self {
        self.parts.push(format!("LEFT JOIN `{}` ON {}", table, condition))
        self
    }
    
    fn group_by(columns: [String]) -> Self {
        self.parts.push(format!("GROUP BY {}", columns.join(", ")))
        self
    }
    
    fn having(condition: String, params: [MysqlValue]) -> Self {
        self.parts.push(format!("HAVING {}", condition))
        self.params.extend(params)
        self
    }
    
    fn insert_into(table: String, columns: [String]) -> Self {
        self.parts.push(format!("INSERT INTO `{}` ({})", table, columns.iter().map(|c| format!("`{}`", c)).join(", ")))
        self
    }
    
    fn values(values: [MysqlValue]) -> Self {
        let placeholders = values.iter().map(|_| "?").join(", ")
        self.parts.push(format!("VALUES ({})", placeholders))
        self.params.extend(values)
        self
    }
    
    fn on_duplicate_key_update(assignments: [(String, MysqlValue)]) -> Self {
        var sets = []
        for (col, val) in assignments {
            sets.push(format!("`{}` = ?", col))
            self.params.push(val)
        }
        self.parts.push(format!("ON DUPLICATE KEY UPDATE {}", sets.join(", ")))
        self
    }
    
    fn update(table: String) -> Self {
        self.parts.push(format!("UPDATE `{}`", table))
        self
    }
    
    fn set(assignments: [(String, MysqlValue)]) -> Self {
        var sets = []
        for (col, val) in assignments {
            sets.push(format!("`{}` = ?", col))
            self.params.push(val)
        }
        self.parts.push(format!("SET {}", sets.join(", ")))
        self
    }
    
    fn delete_from(table: String) -> Self {
        self.parts.push(format!("DELETE FROM `{}`", table))
        self
    }
    
    fn build() -> (String, [MysqlValue]) {
        (self.parts.join(" "), self.params)
    }
}

// =============================================================================
// Errors
// =============================================================================

enum MysqlError {
    ConnectionFailed(String)
    QueryFailed(String)
    NoRows
    TypeMismatch
    TransactionFailed
    PoolExhausted
    Timeout
    InvalidConfig(String)
    DuplicateEntry
    ForeignKeyViolation
    Io(String)
}

impl Display for MysqlError {
    fn fmt(f: Formatter) {
        match self {
            ConnectionFailed(s) => f.write(format!("Connection failed: {}", s))
            QueryFailed(s) => f.write(format!("Query failed: {}", s))
            NoRows => f.write("No rows returned")
            TypeMismatch => f.write("Type mismatch")
            TransactionFailed => f.write("Transaction failed")
            PoolExhausted => f.write("Connection pool exhausted")
            Timeout => f.write("Operation timed out")
            InvalidConfig(s) => f.write(format!("Invalid config: {}", s))
            DuplicateEntry => f.write("Duplicate entry")
            ForeignKeyViolation => f.write("Foreign key violation")
            Io(s) => f.write(format!("IO error: {}", s))
        }
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Quick connect
fn connect(url: String) -> Result<MysqlConnection, MysqlError> {
    MysqlConnection.connect_url(url)
}

/// Create a connection pool
fn pool(url: String) -> Result<MysqlPool, MysqlError> {
    MysqlPool.new(MysqlConfig.from_url(url)?)
}

// =============================================================================
// Tests
// =============================================================================

test "config builder" {
    let config = MysqlConfig.new("mydb")
        .host("localhost")
        .port(3306)
        .user("admin")
        .password("secret")
        .charset("utf8mb4")
    
    assert_eq(config.database, "mydb")?
    assert_eq(config.host, "localhost")?
    assert_eq(config.charset, "utf8mb4")?
}

test "query builder" {
    let (sql, params) = MysqlQueryBuilder.new()
        .select(["id", "name", "email"])
        .from("users")
        .where_("active = ?", [MysqlValue.bool(true)])
        .order_by("created_at", "DESC")
        .limit(10)
        .build()
    
    assert(sql.contains("SELECT id, name, email"))?
    assert(sql.contains("FROM `users`"))?
    assert(sql.contains("LIMIT 10"))?
}

test "mysql value types" {
    let v1 = MysqlValue.string("hello")
    let v2 = MysqlValue.int(42)
    let v3 = MysqlValue.null()
    
    assert(!v1.is_null())?
    assert(!v2.is_null())?
    assert(v3.is_null())?
}

test "insert with on duplicate key" {
    let (sql, params) = MysqlQueryBuilder.new()
        .insert_into("users", ["id", "name"])
        .values([MysqlValue.int(1), MysqlValue.string("John")])
        .on_duplicate_key_update([("name", MysqlValue.string("John Updated"))])
        .build()
    
    assert(sql.contains("INSERT INTO"))?
    assert(sql.contains("ON DUPLICATE KEY UPDATE"))?
    assert_eq(params.len(), 3)?
}

test "isolation levels" {
    assert_eq(IsolationLevel.ReadCommitted.to_string(), "READ COMMITTED")?
    assert_eq(IsolationLevel.Serializable.to_string(), "SERIALIZABLE")?
}
