// =============================================================================
// Vibee OS â€” TLS Module
// TLS/SSL encryption
// =============================================================================

/// TLS Configuration
struct TlsConfig {
    min_version: TlsVersion
    max_version: TlsVersion
    certs: [Certificate]
    key: Option<PrivateKey>
    ca_certs: [Certificate]
    verify_peer: Bool
    sni: Option<String>
    alpn: [String]
}

impl TlsConfig {
    fn client() -> Self { TlsConfig { min_version: TlsVersion.V1_2, max_version: TlsVersion.V1_3, certs: [], key: None, ca_certs: [], verify_peer: true, sni: None, alpn: [] } }
    fn server(cert: Certificate, key: PrivateKey) -> Self { TlsConfig { min_version: TlsVersion.V1_2, max_version: TlsVersion.V1_3, certs: [cert], key: Some(key), ca_certs: [], verify_peer: false, sni: None, alpn: [] } }
    fn insecure() -> Self { Self.client().verify(false) }
    
    fn min_version(v: TlsVersion) -> Self { self.min_version = v; self }
    fn max_version(v: TlsVersion) -> Self { self.max_version = v; self }
    fn cert(c: Certificate) -> Self { self.certs.push(c); self }
    fn key(k: PrivateKey) -> Self { self.key = Some(k); self }
    fn ca(c: Certificate) -> Self { self.ca_certs.push(c); self }
    fn verify(v: Bool) -> Self { self.verify_peer = v; self }
    fn sni(s: String) -> Self { self.sni = Some(s); self }
    fn alpn(protocols: [String]) -> Self { self.alpn = protocols; self }
}

enum TlsVersion { V1_0, V1_1, V1_2, V1_3 }

/// Certificate
struct Certificate { der: [UInt8] }
impl Certificate {
    fn from_pem(pem: String) -> Result<Self, TlsError> { @native("cert_from_pem", pem) }
    fn from_der(der: [UInt8]) -> Self { Certificate { der: der } }
    fn from_file(path: String) -> Result<Self, TlsError> { Self.from_pem(@native("read_file", path)?) }
    fn subject() -> String { @native("cert_subject", self.der) }
    fn issuer() -> String { @native("cert_issuer", self.der) }
    fn not_before() -> DateTime { @native("cert_not_before", self.der) }
    fn not_after() -> DateTime { @native("cert_not_after", self.der) }
    fn is_valid() -> Bool { let now = DateTime.now(); now >= self.not_before() && now <= self.not_after() }
    fn fingerprint_sha256() -> String { @native("cert_fingerprint_sha256", self.der) }
}

/// Private Key
struct PrivateKey { der: [UInt8] }
impl PrivateKey {
    fn from_pem(pem: String) -> Result<Self, TlsError> { @native("key_from_pem", pem) }
    fn from_der(der: [UInt8]) -> Self { PrivateKey { der: der } }
    fn from_file(path: String) -> Result<Self, TlsError> { Self.from_pem(@native("read_file", path)?) }
}

/// TLS Stream (wraps TCP)
struct TlsStream { inner: @native("TlsStream") }
impl TlsStream {
    fn connect(host: String, port: Int) -> Result<Self, TlsError> { Self.connect_with(host, port, TlsConfig.client()) }
    fn connect_with(host: String, port: Int, config: TlsConfig) -> Result<Self, TlsError> {
        let config = if config.sni.is_none() { config.sni(host) } else { config }
        let inner = @native("tls_connect", host, port, config)?
        Ok(TlsStream { inner: inner })
    }
    
    fn from_tcp(tcp: TcpStream, config: TlsConfig) -> Result<Self, TlsError> { Ok(TlsStream { inner: @native("tls_wrap", tcp, config)? }) }
    
    fn read(buf: [UInt8]) -> Result<Int, TlsError> { @native("tls_read", self.inner, buf) }
    fn write(data: [UInt8]) -> Result<Int, TlsError> { @native("tls_write", self.inner, data) }
    fn read_exact(buf: [UInt8]) -> Result<(), TlsError> { @native("tls_read_exact", self.inner, buf) }
    fn write_all(data: [UInt8]) -> Result<(), TlsError> { @native("tls_write_all", self.inner, data) }
    fn flush() -> Result<(), TlsError> { @native("tls_flush", self.inner) }
    fn shutdown() -> Result<(), TlsError> { @native("tls_shutdown", self.inner) }
    
    fn peer_certificate() -> Option<Certificate> { @native("tls_peer_cert", self.inner) }
    fn negotiated_alpn() -> Option<String> { @native("tls_alpn", self.inner) }
    fn protocol_version() -> TlsVersion { @native("tls_version", self.inner) }
    fn cipher_suite() -> String { @native("tls_cipher", self.inner) }
}

/// TLS Acceptor (server-side)
struct TlsAcceptor { config: TlsConfig }
impl TlsAcceptor {
    fn new(cert: Certificate, key: PrivateKey) -> Self { TlsAcceptor { config: TlsConfig.server(cert, key) } }
    fn with_config(config: TlsConfig) -> Self { TlsAcceptor { config: config } }
    fn accept(tcp: TcpStream) -> Result<TlsStream, TlsError> { TlsStream.from_tcp(tcp, self.config) }
}

/// TLS Listener
struct TlsListener { tcp: TcpListener, acceptor: TlsAcceptor }
impl TlsListener {
    fn bind(addr: String, cert: Certificate, key: PrivateKey) -> Result<Self, TlsError> {
        let tcp = TcpListener.bind(SocketAddr.parse(addr)?)?
        Ok(TlsListener { tcp: tcp, acceptor: TlsAcceptor.new(cert, key) })
    }
    fn accept() -> Result<TlsStream, TlsError> { let (tcp, _) = self.tcp.accept()?; self.acceptor.accept(tcp) }
}

enum TlsError { HandshakeFailed, CertificateError, ProtocolError, Io(NetError), Other(String) }
impl Display for TlsError {
    fn fmt(f: Formatter) { match self { HandshakeFailed => f.write("TLS handshake failed"), CertificateError => f.write("Certificate error"), ProtocolError => f.write("Protocol error"), Io(e) => f.write(format!("IO: {}", e)), Other(s) => f.write(s) } }
}

// Tests
test "tls config" {
    let config = TlsConfig.client().min_version(TlsVersion.V1_2).verify(true)
    assert(config.verify_peer)?
}

test "certificate" {
    let pem = "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
    // Would need valid cert for actual test
}
