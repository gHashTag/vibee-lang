// =============================================================================
// Vibee OS â€” A/B Testing Module
// Experiment design, assignment, and statistical analysis
// =============================================================================

use datetime::{DateTime, Duration}
use uuid::{UUID}
use result::{Result, Ok, Err}
use stats::{mean, std_dev, t_test_two_sample, TTestResult}

// =============================================================================
// Experiment Definition
// =============================================================================

/// A/B Test experiment
struct Experiment {
    id: String
    name: String
    description: String
    hypothesis: String
    variants: [Variant]
    status: ExperimentStatus
    allocation: AllocationStrategy
    targeting: TargetingRules
    metrics: [Metric]
    start_date: Option<DateTime>
    end_date: Option<DateTime>
    created_at: DateTime
}

enum ExperimentStatus { Draft, Running, Paused, Completed, Archived }

/// Experiment variant
struct Variant {
    id: String
    name: String
    description: String
    weight: Float
    is_control: Bool
    config: Map<String, ConfigValue>
}

enum ConfigValue { String(String), Int(Int), Float(Float), Bool(Bool), Json(String) }

impl Experiment {
    fn new(name: String) -> Self {
        Experiment {
            id: UUID.v4(), name: name, description: "", hypothesis: "",
            variants: [], status: ExperimentStatus.Draft,
            allocation: AllocationStrategy.Random, targeting: TargetingRules.new(),
            metrics: [], start_date: None, end_date: None, created_at: DateTime.now()
        }
    }
    
    fn description(d: String) -> Self { self.description = d; self }
    fn hypothesis(h: String) -> Self { self.hypothesis = h; self }
    
    fn control(name: String) -> Self {
        self.variants.push(Variant { id: UUID.v4(), name: name, description: "", weight: 0.5, is_control: true, config: Map.empty() })
        self
    }
    
    fn variant(name: String, weight: Float) -> Self {
        self.variants.push(Variant { id: UUID.v4(), name: name, description: "", weight: weight, is_control: false, config: Map.empty() })
        self
    }
    
    fn metric(m: Metric) -> Self { self.metrics.push(m); self }
    fn targeting(rules: TargetingRules) -> Self { self.targeting = rules; self }
    fn allocation(strategy: AllocationStrategy) -> Self { self.allocation = strategy; self }
    
    fn start() -> Self { self.status = ExperimentStatus.Running; self.start_date = Some(DateTime.now()); self }
    fn pause() -> Self { self.status = ExperimentStatus.Paused; self }
    fn complete() -> Self { self.status = ExperimentStatus.Completed; self.end_date = Some(DateTime.now()); self }
}

// =============================================================================
// Allocation & Targeting
// =============================================================================

enum AllocationStrategy { Random, Deterministic, Sticky }

struct TargetingRules {
    rules: [TargetingRule]
    match_type: MatchType
}

struct TargetingRule { field: String, operator: RuleOperator, value: String }
enum RuleOperator { Equals, NotEquals, Contains, In, GreaterThan, LessThan }
enum MatchType { All, Any }

impl TargetingRules {
    fn new() -> Self { TargetingRules { rules: [], match_type: MatchType.All } }
    fn rule(field: String, op: RuleOperator, value: String) -> Self { self.rules.push(TargetingRule { field: field, operator: op, value: value }); self }
    fn match_all() -> Self { self.match_type = MatchType.All; self }
    fn match_any() -> Self { self.match_type = MatchType.Any; self }
}

// =============================================================================
// Metrics
// =============================================================================

struct Metric { name: String, metric_type: MetricType, event_name: String, goal: MetricGoal }
enum MetricType { Conversion, Revenue, Count, Duration, Rate }
enum MetricGoal { Increase, Decrease }

impl Metric {
    fn conversion(name: String, event: String) -> Self { Metric { name: name, metric_type: MetricType.Conversion, event_name: event, goal: MetricGoal.Increase } }
    fn revenue(name: String, event: String) -> Self { Metric { name: name, metric_type: MetricType.Revenue, event_name: event, goal: MetricGoal.Increase } }
    fn count(name: String, event: String) -> Self { Metric { name: name, metric_type: MetricType.Count, event_name: event, goal: MetricGoal.Increase } }
}

// =============================================================================
// Experiment Engine Actor
// =============================================================================

actor ExperimentEngine {
    state experiments: Map<String, Experiment>
    state assignments: Map<String, Map<String, String>>
    state results: Map<String, ExperimentResults>
    
    fn new() -> Self { ExperimentEngine { experiments: Map.empty(), assignments: Map.empty(), results: Map.empty() } }
    
    fn create(exp: Experiment) -> String { let id = exp.id.clone(); self.experiments.set(id.clone(), exp); id }
    fn get(id: String) -> Option<&Experiment> { self.experiments.get(&id) }
    fn list() -> [&Experiment] { self.experiments.values().collect() }
    
    fn start(id: String) -> Result<(), ExperimentError> {
        let exp = self.experiments.get_mut(&id).ok_or(ExperimentError.NotFound)?
        exp.status = ExperimentStatus.Running
        exp.start_date = Some(DateTime.now())
        Ok(())
    }
    
    fn assign(experiment_id: String, user_id: String, context: Map<String, String>) -> Result<Assignment, ExperimentError> {
        let exp = self.experiments.get(&experiment_id).ok_or(ExperimentError.NotFound)?
        if exp.status != ExperimentStatus.Running { return Err(ExperimentError.NotRunning) }
        
        // Check existing assignment
        if let Some(variant_id) = self.assignments.get(&experiment_id)?.get(&user_id) {
            let variant = exp.variants.iter().find(|v| v.id == *variant_id).ok_or(ExperimentError.VariantNotFound)?
            return Ok(Assignment { experiment_id: experiment_id, user_id: user_id, variant_id: variant_id.clone(), variant_name: variant.name.clone(), assigned_at: DateTime.now() })
        }
        
        // Assign new variant
        let variant = self.select_variant(exp, &user_id)?
        self.assignments.entry(experiment_id.clone()).or_insert(Map.empty()).set(user_id.clone(), variant.id.clone())
        
        Ok(Assignment { experiment_id: experiment_id, user_id: user_id, variant_id: variant.id.clone(), variant_name: variant.name.clone(), assigned_at: DateTime.now() })
    }
    
    fn select_variant(exp: &Experiment, user_id: &String) -> Result<&Variant, ExperimentError> {
        match exp.allocation {
            AllocationStrategy.Random => {
                let r = Random.float()
                var cumulative = 0.0
                for variant in exp.variants.iter() {
                    cumulative += variant.weight
                    if r < cumulative { return Ok(variant) }
                }
                exp.variants.last().ok_or(ExperimentError.NoVariants)
            }
            AllocationStrategy.Deterministic => {
                let hash = user_id.hash() as Float / u64::MAX as Float
                var cumulative = 0.0
                for variant in exp.variants.iter() {
                    cumulative += variant.weight
                    if hash < cumulative { return Ok(variant) }
                }
                exp.variants.last().ok_or(ExperimentError.NoVariants)
            }
            AllocationStrategy.Sticky => {
                let idx = (user_id.hash() as usize) % exp.variants.len()
                Ok(&exp.variants[idx])
            }
        }
    }
    
    fn record_conversion(experiment_id: String, user_id: String, metric_name: String, value: Float) -> Result<(), ExperimentError> {
        let variant_id = self.assignments.get(&experiment_id)?.get(&user_id).ok_or(ExperimentError.NotAssigned)?.clone()
        let results = self.results.entry(experiment_id).or_insert(ExperimentResults.new())
        results.record(variant_id, metric_name, value)
        Ok(())
    }
    
    fn analyze(experiment_id: String) -> Result<ExperimentAnalysis, ExperimentError> {
        let exp = self.experiments.get(&experiment_id).ok_or(ExperimentError.NotFound)?
        let results = self.results.get(&experiment_id).ok_or(ExperimentError.NoResults)?
        
        let control = exp.variants.iter().find(|v| v.is_control).ok_or(ExperimentError.NoControl)?
        var variant_analyses: [VariantAnalysis] = []
        
        for variant in exp.variants.iter() {
            let data = results.get_variant_data(&variant.id)
            let control_data = results.get_variant_data(&control.id)
            
            let analysis = VariantAnalysis {
                variant_id: variant.id.clone(),
                variant_name: variant.name.clone(),
                sample_size: data.len(),
                conversion_rate: self.calc_conversion_rate(&data),
                mean_value: mean(data.clone()).unwrap_or(0.0),
                std_dev: std_dev(data.clone()).unwrap_or(0.0),
                uplift: self.calc_uplift(&data, &control_data),
                statistical_significance: self.calc_significance(&data, &control_data),
                confidence_interval: self.calc_confidence_interval(&data)
            }
            variant_analyses.push(analysis)
        }
        
        let winner = self.determine_winner(&variant_analyses, control)
        
        Ok(ExperimentAnalysis {
            experiment_id: experiment_id, experiment_name: exp.name.clone(),
            status: exp.status.clone(), variant_analyses: variant_analyses,
            winner: winner, recommendation: self.get_recommendation(&variant_analyses)
        })
    }
    
    fn calc_conversion_rate(data: &[Float]) -> Float {
        if data.is_empty() { 0.0 } else { data.iter().filter(|&v| *v > 0.0).count() as Float / data.len() as Float }
    }
    
    fn calc_uplift(variant: &[Float], control: &[Float]) -> Float {
        let v_mean = mean(variant.to_vec()).unwrap_or(0.0)
        let c_mean = mean(control.to_vec()).unwrap_or(0.0)
        if c_mean == 0.0 { 0.0 } else { (v_mean - c_mean) / c_mean }
    }
    
    fn calc_significance(variant: &[Float], control: &[Float]) -> Float {
        if let Some(result) = t_test_two_sample(variant.to_vec(), control.to_vec()) {
            1.0 - result.p_value
        } else { 0.0 }
    }
    
    fn calc_confidence_interval(data: &[Float]) -> (Float, Float) {
        let m = mean(data.to_vec()).unwrap_or(0.0)
        let s = std_dev(data.to_vec()).unwrap_or(0.0)
        let n = data.len() as Float
        let margin = 1.96 * s / n.sqrt()
        (m - margin, m + margin)
    }
    
    fn determine_winner(analyses: &[VariantAnalysis], control: &Variant) -> Option<String> {
        analyses.iter()
            .filter(|a| a.statistical_significance >= 0.95 && a.uplift > 0.0 && a.variant_id != control.id)
            .max_by(|a, b| a.uplift.partial_cmp(&b.uplift).unwrap())
            .map(|a| a.variant_id.clone())
    }
    
    fn get_recommendation(analyses: &[VariantAnalysis]) -> Recommendation {
        let significant = analyses.iter().any(|a| a.statistical_significance >= 0.95)
        let positive_uplift = analyses.iter().any(|a| a.uplift > 0.05)
        
        if significant && positive_uplift { Recommendation.ShipWinner }
        else if significant { Recommendation.KeepControl }
        else { Recommendation.ContinueTesting }
    }
}

// =============================================================================
// Results & Analysis
// =============================================================================

struct Assignment { experiment_id: String, user_id: String, variant_id: String, variant_name: String, assigned_at: DateTime }

struct ExperimentResults {
    variant_data: Map<String, Map<String, [Float]>>
}

impl ExperimentResults {
    fn new() -> Self { ExperimentResults { variant_data: Map.empty() } }
    
    fn record(variant_id: String, metric: String, value: Float) {
        self.variant_data.entry(variant_id).or_insert(Map.empty()).entry(metric).or_insert(Vec.new()).push(value)
    }
    
    fn get_variant_data(variant_id: &String) -> [Float] {
        self.variant_data.get(variant_id).map(|m| m.values().flatten().cloned().collect()).unwrap_or(Vec.new())
    }
}

struct ExperimentAnalysis {
    experiment_id: String
    experiment_name: String
    status: ExperimentStatus
    variant_analyses: [VariantAnalysis]
    winner: Option<String>
    recommendation: Recommendation
}

struct VariantAnalysis {
    variant_id: String
    variant_name: String
    sample_size: Int
    conversion_rate: Float
    mean_value: Float
    std_dev: Float
    uplift: Float
    statistical_significance: Float
    confidence_interval: (Float, Float)
}

enum Recommendation { ShipWinner, KeepControl, ContinueTesting, InsufficientData }

// =============================================================================
// Errors
// =============================================================================

enum ExperimentError { NotFound, NotRunning, NoVariants, NoControl, VariantNotFound, NotAssigned, NoResults }

// =============================================================================
// Builder Functions
// =============================================================================

fn experiment(name: String) -> Experiment { Experiment.new(name) }
fn targeting() -> TargetingRules { TargetingRules.new() }

// =============================================================================
// Tests
// =============================================================================

test "experiment creation" {
    let exp = Experiment.new("Button Color Test").control("Blue").variant("Green", 0.5)
    assert_eq(exp.name, "Button Color Test")?
    assert_eq(exp.variants.len(), 2)?
}

test "metric creation" {
    let m = Metric.conversion("Signup Rate", "signup_complete")
    assert_eq(m.name, "Signup Rate")?
}

test "targeting rules" {
    let rules = TargetingRules.new().rule("country", RuleOperator.Equals, "US").match_all()
    assert_eq(rules.rules.len(), 1)?
}

test "experiment results" {
    var results = ExperimentResults.new()
    results.record("v1", "conversion", 1.0)
    results.record("v1", "conversion", 0.0)
    let data = results.get_variant_data(&"v1")
    assert_eq(data.len(), 2)?
}
