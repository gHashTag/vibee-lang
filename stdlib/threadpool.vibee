// =============================================================================
// Vibee OS â€” ThreadPool Module
// Thread pool for parallel execution
// =============================================================================

/// Thread pool
actor ThreadPool {
    state workers: [Worker]
    state queue: [Job]
    state shutdown: Bool
    
    fn new(size: Int) -> Self {
        let pool = ThreadPool { workers: [], queue: [], shutdown: false }
        for i in 0..size { pool.workers.push(Worker.new(i, pool)) }
        pool
    }
    
    fn default() -> Self { Self.new(@native("cpu_count")) }
    
    /// Execute task
    fn execute(f: fn()) {
        if self.shutdown { return }
        self.queue.push(Job { task: f })
        self.notify_worker()
    }
    
    /// Execute and get future
    fn spawn<T>(f: fn() -> T) -> Future<T> {
        let future = Future.new()
        self.execute(|| future.resolve(f()))
        future
    }
    
    /// Execute batch of tasks
    fn execute_batch(tasks: [fn()]) {
        for task in tasks { self.execute(task) }
    }
    
    /// Map in parallel
    fn map<T, U>(items: [T], f: fn(T) -> U) -> [Future<U>] {
        items.iter().map(|item| self.spawn(|| f(item))).collect()
    }
    
    /// Parallel for each
    fn for_each<T>(items: [T], f: fn(T)) {
        for item in items { self.execute(|| f(item)) }
    }
    
    /// Shutdown pool
    fn shutdown() {
        self.shutdown = true
        for worker in self.workers { worker.stop() }
    }
    
    /// Shutdown and wait
    fn shutdown_and_wait() {
        self.shutdown()
        for worker in self.workers { worker.join() }
    }
    
    fn notify_worker() {
        for worker in self.workers {
            if !worker.is_busy() { worker.wake(); return }
        }
    }
    
    fn take_job() -> Option<Job> {
        if self.queue.is_empty() { None } else { Some(self.queue.remove(0)) }
    }
    
    fn worker_count() -> Int { self.workers.len() }
    fn queue_len() -> Int { self.queue.len() }
    fn is_shutdown() -> Bool { self.shutdown }
}

struct Job { task: fn() }

actor Worker {
    state id: Int
    state pool: ThreadPool
    state busy: Bool
    state running: Bool
    
    fn new(id: Int, pool: ThreadPool) -> Self {
        let worker = Worker { id: id, pool: pool, busy: false, running: true }
        spawn { worker.run() }
        worker
    }
    
    fn run() {
        while self.running {
            match self.pool.take_job() {
                Some(job) => { self.busy = true; (job.task)(); self.busy = false }
                None => @native("worker_wait", self)
            }
        }
    }
    
    fn wake() { @native("worker_wake", self) }
    fn stop() { self.running = false; self.wake() }
    fn join() { while self.running { @native("yield") } }
    fn is_busy() -> Bool { self.busy }
}

/// Scoped thread pool
fn scoped<R>(size: Int, f: fn(ThreadPool) -> R) -> R {
    let pool = ThreadPool.new(size)
    let result = f(pool)
    pool.shutdown_and_wait()
    result
}

/// Parallel iterator
trait ParallelIterator: Iterator {
    fn par_map<U>(f: fn(Self.Item) -> U) -> [U] {
        let pool = ThreadPool.default()
        let futures = self.map(|item| pool.spawn(|| f(item))).collect::<Vec<_>>()
        let results = futures.iter().map(|f| f.await().unwrap()).collect()
        pool.shutdown()
        results
    }
    
    fn par_for_each(f: fn(Self.Item)) {
        let pool = ThreadPool.default()
        for item in self { pool.execute(|| f(item)) }
        pool.shutdown_and_wait()
    }
    
    fn par_filter(pred: fn(Self.Item) -> Bool) -> [Self.Item] {
        self.par_map(|item| if pred(item) { Some(item) } else { None })
            .into_iter().filter_map(|x| x).collect()
    }
}

/// Work stealing pool
actor WorkStealingPool {
    state workers: [StealingWorker]
    state global_queue: [Job]
    
    fn new(size: Int) -> Self {
        let pool = WorkStealingPool { workers: [], global_queue: [] }
        for i in 0..size { pool.workers.push(StealingWorker.new(i, pool)) }
        pool
    }
    
    fn execute(f: fn()) {
        // Try to push to least loaded worker
        let min_worker = self.workers.iter().min_by(|w| w.queue_len())
        match min_worker {
            Some(w) => w.push(Job { task: f })
            None => self.global_queue.push(Job { task: f })
        }
    }
    
    fn steal() -> Option<Job> {
        if !self.global_queue.is_empty() { return Some(self.global_queue.remove(0)) }
        // Steal from busiest worker
        let max_worker = self.workers.iter().max_by(|w| w.queue_len())?
        max_worker.steal()
    }
}

actor StealingWorker {
    state id: Int
    state pool: WorkStealingPool
    state local_queue: [Job]
    
    fn new(id: Int, pool: WorkStealingPool) -> Self {
        let w = StealingWorker { id: id, pool: pool, local_queue: [] }
        spawn { w.run() }
        w
    }
    
    fn run() {
        loop {
            let job = self.local_queue.pop().or_else(|| self.pool.steal())
            match job { Some(j) => (j.task)(), None => @native("yield") }
        }
    }
    
    fn push(job: Job) { self.local_queue.push(job) }
    fn steal() -> Option<Job> { if self.local_queue.len() > 1 { Some(self.local_queue.remove(0)) } else { None } }
    fn queue_len() -> Int { self.local_queue.len() }
}

// Tests
test "execute" {
    let pool = ThreadPool.new(2)
    let counter = Counter.new()
    for _ in 0..10 { pool.execute(|| counter.inc()) }
    pool.shutdown_and_wait()
    assert_eq(counter.get(), 10)?
}

test "spawn" {
    let pool = ThreadPool.new(2)
    let f = pool.spawn(|| 42)
    assert_eq(f.await()?, 42)?
    pool.shutdown()
}

test "map" {
    let pool = ThreadPool.new(4)
    let futures = pool.map([1, 2, 3, 4], |x| x * 2)
    let results: [Int] = futures.iter().map(|f| f.await().unwrap()).collect()
    pool.shutdown()
    assert_eq(results.iter().sum(), 20)?
}
