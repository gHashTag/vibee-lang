// =============================================================================
// Vibee OS â€” ECDSA Module
// Elliptic Curve Digital Signature Algorithm
// =============================================================================

enum EcCurve { P256, P384, P521, Secp256k1 }

impl EcCurve {
    fn name() -> String { match self { P256 => "P-256", P384 => "P-384", P521 => "P-521", Secp256k1 => "secp256k1" } }
    fn key_size() -> Int { match self { P256 => 32, P384 => 48, P521 => 66, Secp256k1 => 32 } }
    fn signature_size() -> Int { self.key_size() * 2 }
}

struct EcdsaKeyPair { public_key: EcdsaPublicKey, private_key: EcdsaPrivateKey, curve: EcCurve }

impl EcdsaKeyPair {
    fn generate(curve: EcCurve) -> Result<Self, EcdsaError> { @native("ecdsa_generate", curve).map_err(|_| EcdsaError.KeyGenerationFailed) }
    fn p256() -> Result<Self, EcdsaError> { Self.generate(EcCurve.P256) }
    fn p384() -> Result<Self, EcdsaError> { Self.generate(EcCurve.P384) }
    fn secp256k1() -> Result<Self, EcdsaError> { Self.generate(EcCurve.Secp256k1) }
    fn public() -> EcdsaPublicKey { self.public_key }
    fn private() -> EcdsaPrivateKey { self.private_key }
}

struct EcdsaPublicKey { der: [UInt8], curve: EcCurve }

impl EcdsaPublicKey {
    fn from_der(der: [UInt8], curve: EcCurve) -> Self { EcdsaPublicKey { der: der, curve: curve } }
    fn from_pem(pem: String) -> Result<Self, EcdsaError> { @native("ecdsa_public_from_pem", pem).map_err(|_| EcdsaError.InvalidKey) }
    fn to_pem() -> String { @native("ecdsa_public_to_pem", self.der) }
    fn to_der() -> [UInt8] { self.der }
    fn verify(message: [UInt8], signature: [UInt8]) -> Bool { @native("ecdsa_verify", self.der, message, signature) }
    fn verify_digest(digest: [UInt8], signature: [UInt8]) -> Bool { @native("ecdsa_verify_digest", self.der, digest, signature) }
    fn fingerprint() -> String { hex.encode(crypto.sha256(self.der))[0..16] }
}

struct EcdsaPrivateKey { der: [UInt8], curve: EcCurve }

impl EcdsaPrivateKey {
    fn from_der(der: [UInt8], curve: EcCurve) -> Self { EcdsaPrivateKey { der: der, curve: curve } }
    fn from_pem(pem: String) -> Result<Self, EcdsaError> { @native("ecdsa_private_from_pem", pem).map_err(|_| EcdsaError.InvalidKey) }
    fn to_pem() -> String { @native("ecdsa_private_to_pem", self.der) }
    fn sign(message: [UInt8]) -> Result<[UInt8], EcdsaError> { @native("ecdsa_sign", self.der, message).map_err(|_| EcdsaError.SigningFailed) }
    fn sign_digest(digest: [UInt8]) -> Result<[UInt8], EcdsaError> { @native("ecdsa_sign_digest", self.der, digest).map_err(|_| EcdsaError.SigningFailed) }
    fn public_key() -> EcdsaPublicKey { let der = @native("ecdsa_private_to_public", self.der); EcdsaPublicKey { der: der, curve: self.curve } }
    fn zeroize() { crypto.secure_zero(self.der) }
}

struct EcdsaSignature { r: [UInt8], s: [UInt8] }

impl EcdsaSignature {
    fn from_der(der: [UInt8]) -> Result<Self, EcdsaError> { @native("ecdsa_sig_from_der", der).map_err(|_| EcdsaError.InvalidSignature) }
    fn to_der() -> [UInt8] { @native("ecdsa_sig_to_der", self.r, self.s) }
    fn from_compact(data: [UInt8]) -> Result<Self, EcdsaError> {
        if data.len() % 2 != 0 { return Err(EcdsaError.InvalidSignature) }
        let half = data.len() / 2
        Ok(EcdsaSignature { r: data[0..half], s: data[half..] })
    }
    fn to_compact() -> [UInt8] { self.r + self.s }
}

fn sign(private_key: EcdsaPrivateKey, message: [UInt8]) -> Result<[UInt8], EcdsaError> { private_key.sign(message) }
fn verify(public_key: EcdsaPublicKey, message: [UInt8], signature: [UInt8]) -> Bool { public_key.verify(message, signature) }

enum EcdsaError { KeyGenerationFailed, InvalidKey, InvalidSignature, SigningFailed, VerificationFailed }
impl Display for EcdsaError { fn fmt(f: Formatter) { match self { KeyGenerationFailed => f.write("Key generation failed"), InvalidKey => f.write("Invalid key"), InvalidSignature => f.write("Invalid signature"), SigningFailed => f.write("Signing failed"), VerificationFailed => f.write("Verification failed") } } }

test "p256 sign verify" { let kp = EcdsaKeyPair.p256()?; let sig = kp.private_key.sign("test".as_bytes())?; assert(kp.public_key.verify("test".as_bytes(), sig))? }
test "secp256k1" { let kp = EcdsaKeyPair.secp256k1()?; let sig = kp.private_key.sign("bitcoin".as_bytes())?; assert(kp.public_key.verify("bitcoin".as_bytes(), sig))? }
