// =============================================================================
// Vibee OS â€” Subscription Module
// Subscription management for reactive streams
// =============================================================================

/// Subscription - represents a disposable resource
struct Subscription {
    unsubscribe_fn: fn()
    closed: Bool
}

impl Subscription {
    /// Create new subscription with unsubscribe action
    fn new(unsubscribe: fn()) -> Self {
        Subscription {
            unsubscribe_fn: unsubscribe,
            closed: false
        }
    }
    
    /// Create empty subscription (already closed)
    fn empty() -> Self {
        Subscription {
            unsubscribe_fn: || {},
            closed: true
        }
    }
    
    /// Unsubscribe and release resources
    fn unsubscribe() {
        if !self.closed {
            self.closed = true
            (self.unsubscribe_fn)()
        }
    }
    
    /// Check if subscription is closed
    fn is_closed() -> Bool { self.closed }
    
    /// Add child subscription (disposed when parent is disposed)
    fn add(child: Subscription) -> Subscription {
        if self.closed {
            child.unsubscribe()
            return self
        }
        
        let parent_unsub = self.unsubscribe_fn
        self.unsubscribe_fn = || {
            parent_unsub()
            child.unsubscribe()
        }
        self
    }
    
    /// Remove child subscription
    fn remove(child: Subscription) {
        // In a real implementation, we'd track children separately
        // For simplicity, this is a no-op
    }
}

/// Composite subscription - manages multiple subscriptions
struct CompositeSubscription {
    subscriptions: [Subscription]
    closed: Bool
}

impl CompositeSubscription {
    fn new() -> Self {
        CompositeSubscription {
            subscriptions: [],
            closed: false
        }
    }
    
    /// Add subscription to composite
    fn add(sub: Subscription) {
        if self.closed {
            sub.unsubscribe()
            return
        }
        self.subscriptions.push(sub)
    }
    
    /// Remove subscription from composite
    fn remove(sub: Subscription) {
        self.subscriptions.retain(|s| !ptr_eq(s, sub))
    }
    
    /// Unsubscribe all
    fn unsubscribe() {
        if self.closed { return }
        self.closed = true
        
        for sub in self.subscriptions.drain(..) {
            sub.unsubscribe()
        }
    }
    
    /// Clear all subscriptions
    fn clear() {
        for sub in self.subscriptions.drain(..) {
            sub.unsubscribe()
        }
    }
    
    /// Check if closed
    fn is_closed() -> Bool { self.closed }
    
    /// Get count of active subscriptions
    fn count() -> Int { self.subscriptions.len() }
    
    /// Convert to single subscription
    fn as_subscription() -> Subscription {
        Subscription.new(|| self.unsubscribe())
    }
}

/// Serial subscription - holds single subscription, replacing previous
struct SerialSubscription {
    current: Option<Subscription>
    closed: Bool
}

impl SerialSubscription {
    fn new() -> Self {
        SerialSubscription {
            current: None,
            closed: false
        }
    }
    
    /// Set new subscription, disposing previous
    fn set(sub: Subscription) {
        if self.closed {
            sub.unsubscribe()
            return
        }
        
        if let Some(old) = self.current.take() {
            old.unsubscribe()
        }
        self.current = Some(sub)
    }
    
    /// Get current subscription
    fn get() -> Option<Subscription> { self.current.clone() }
    
    /// Unsubscribe current
    fn unsubscribe() {
        if self.closed { return }
        self.closed = true
        
        if let Some(sub) = self.current.take() {
            sub.unsubscribe()
        }
    }
    
    fn is_closed() -> Bool { self.closed }
    
    fn as_subscription() -> Subscription {
        Subscription.new(|| self.unsubscribe())
    }
}

/// Single assignment subscription - can only be set once
struct SingleAssignmentSubscription {
    inner: Option<Subscription>
    closed: Bool
    assigned: Bool
}

impl SingleAssignmentSubscription {
    fn new() -> Self {
        SingleAssignmentSubscription {
            inner: None,
            closed: false,
            assigned: false
        }
    }
    
    /// Set subscription (can only be called once)
    fn set(sub: Subscription) -> Result<(), Error> {
        if self.assigned {
            return Err(Error.new("SingleAssignmentSubscription already assigned"))
        }
        
        self.assigned = true
        
        if self.closed {
            sub.unsubscribe()
        } else {
            self.inner = Some(sub)
        }
        
        Ok(())
    }
    
    fn unsubscribe() {
        if self.closed { return }
        self.closed = true
        
        if let Some(sub) = self.inner.take() {
            sub.unsubscribe()
        }
    }
    
    fn is_closed() -> Bool { self.closed }
    fn is_assigned() -> Bool { self.assigned }
    
    fn as_subscription() -> Subscription {
        Subscription.new(|| self.unsubscribe())
    }
}

/// Boolean subscription - tracks disposed state
struct BooleanSubscription {
    disposed: Bool
}

impl BooleanSubscription {
    fn new() -> Self {
        BooleanSubscription { disposed: false }
    }
    
    fn is_disposed() -> Bool { self.disposed }
    
    fn dispose() {
        self.disposed = true
    }
    
    fn as_subscription() -> Subscription {
        Subscription.new(|| self.dispose())
    }
}

/// Refcounted subscription - disposed when refcount reaches 0
actor RefCountSubscription {
    state inner: Subscription
    state ref_count: Int
    
    fn new(sub: Subscription) -> Self {
        RefCountSubscription {
            inner: sub,
            ref_count: 1
        }
    }
    
    fn retain() {
        self.ref_count += 1
    }
    
    fn release() {
        self.ref_count -= 1
        if self.ref_count == 0 {
            self.inner.unsubscribe()
        }
    }
    
    fn ref_count() -> Int { self.ref_count }
}

/// Scheduled subscription - subscription with scheduler
struct ScheduledSubscription {
    subscription: Subscription
    scheduler: impl Scheduler
}

impl ScheduledSubscription {
    fn new(sub: Subscription, scheduler: impl Scheduler) -> Self {
        ScheduledSubscription {
            subscription: sub,
            scheduler: scheduler
        }
    }
    
    fn unsubscribe() {
        self.scheduler.schedule(|| self.subscription.unsubscribe())
    }
}

/// Auto-disposing subscription - disposes after timeout
struct AutoDisposingSubscription {
    inner: Subscription
    timer_id: Option<Int64>
}

impl AutoDisposingSubscription {
    fn new(sub: Subscription, timeout_ms: Int64) -> Self {
        let auto_sub = AutoDisposingSubscription {
            inner: sub,
            timer_id: None
        }
        
        auto_sub.timer_id = Some(@native("set_timeout", timeout_ms, || {
            auto_sub.inner.unsubscribe()
        }))
        
        auto_sub
    }
    
    fn unsubscribe() {
        if let Some(id) = self.timer_id.take() {
            @native("clear_timeout", id)
        }
        self.inner.unsubscribe()
    }
    
    fn cancel_auto_dispose() {
        if let Some(id) = self.timer_id.take() {
            @native("clear_timeout", id)
        }
    }
}

/// Subscription bag - convenient collection for managing subscriptions
struct SubscriptionBag {
    composite: CompositeSubscription
}

impl SubscriptionBag {
    fn new() -> Self {
        SubscriptionBag { composite: CompositeSubscription.new() }
    }
    
    /// Add subscription using += operator style
    fn insert(sub: Subscription) {
        self.composite.add(sub)
    }
    
    /// Dispose all subscriptions
    fn dispose() {
        self.composite.unsubscribe()
    }
    
    /// Check if disposed
    fn is_disposed() -> Bool { self.composite.is_closed() }
}

/// Subscription scope - RAII-style subscription management
struct SubscriptionScope {
    bag: SubscriptionBag
}

impl SubscriptionScope {
    fn new() -> Self {
        SubscriptionScope { bag: SubscriptionBag.new() }
    }
    
    fn add(sub: Subscription) {
        self.bag.insert(sub)
    }
}

impl Drop for SubscriptionScope {
    fn drop() {
        self.bag.dispose()
    }
}

/// Helper to create subscription from multiple unsubscribe actions
fn combine(unsubscribes: [fn()]) -> Subscription {
    Subscription.new(|| {
        for unsub in unsubscribes {
            unsub()
        }
    })
}

/// Create subscription that runs action on unsubscribe
fn on_unsubscribe(action: fn()) -> Subscription {
    Subscription.new(action)
}

/// Create subscription from disposable
fn from_disposable(disposable: impl Disposable) -> Subscription {
    Subscription.new(|| disposable.dispose())
}

// =============================================================================
// Subscription Extensions
// =============================================================================

/// Extension trait for subscription-like types
trait SubscriptionLike {
    fn unsubscribe()
    fn is_closed() -> Bool
}

impl SubscriptionLike for Subscription {
    fn unsubscribe() { self.unsubscribe() }
    fn is_closed() -> Bool { self.is_closed() }
}

impl SubscriptionLike for CompositeSubscription {
    fn unsubscribe() { self.unsubscribe() }
    fn is_closed() -> Bool { self.is_closed() }
}

impl SubscriptionLike for SerialSubscription {
    fn unsubscribe() { self.unsubscribe() }
    fn is_closed() -> Bool { self.is_closed() }
}

// =============================================================================
// Tests
// =============================================================================

test "subscription unsubscribe" {
    var unsubscribed = false
    let sub = Subscription.new(|| unsubscribed = true)
    
    assert(!sub.is_closed())?
    assert(!unsubscribed)?
    
    sub.unsubscribe()
    
    assert(sub.is_closed())?
    assert(unsubscribed)?
}

test "subscription unsubscribe once" {
    var count = 0
    let sub = Subscription.new(|| count += 1)
    
    sub.unsubscribe()
    sub.unsubscribe()
    sub.unsubscribe()
    
    assert_eq(count, 1)?  // Only called once
}

test "composite subscription" {
    var count = 0
    let composite = CompositeSubscription.new()
    
    composite.add(Subscription.new(|| count += 1))
    composite.add(Subscription.new(|| count += 1))
    composite.add(Subscription.new(|| count += 1))
    
    assert_eq(composite.count(), 3)?
    
    composite.unsubscribe()
    
    assert_eq(count, 3)?
    assert(composite.is_closed())?
}

test "serial subscription" {
    var disposed = [false, false, false]
    let serial = SerialSubscription.new()
    
    serial.set(Subscription.new(|| disposed[0] = true))
    assert(!disposed[0])?
    
    serial.set(Subscription.new(|| disposed[1] = true))
    assert(disposed[0])?  // First was disposed
    assert(!disposed[1])?
    
    serial.set(Subscription.new(|| disposed[2] = true))
    assert(disposed[1])?  // Second was disposed
    assert(!disposed[2])?
    
    serial.unsubscribe()
    assert(disposed[2])?  // Third disposed on unsubscribe
}

test "single assignment subscription" {
    var disposed = false
    let single = SingleAssignmentSubscription.new()
    
    assert(!single.is_assigned())?
    
    single.set(Subscription.new(|| disposed = true)).unwrap()
    assert(single.is_assigned())?
    
    // Second assignment should fail
    let result = single.set(Subscription.new(|| {}))
    assert(result.is_err())?
    
    single.unsubscribe()
    assert(disposed)?
}

test "subscription bag" {
    var count = 0
    let bag = SubscriptionBag.new()
    
    bag.insert(Subscription.new(|| count += 1))
    bag.insert(Subscription.new(|| count += 1))
    
    bag.dispose()
    
    assert_eq(count, 2)?
    assert(bag.is_disposed())?
}

test "add child subscription" {
    var parent_disposed = false
    var child_disposed = false
    
    let parent = Subscription.new(|| parent_disposed = true)
    let child = Subscription.new(|| child_disposed = true)
    
    parent.add(child)
    parent.unsubscribe()
    
    assert(parent_disposed)?
    assert(child_disposed)?
}

test "empty subscription" {
    let sub = Subscription.empty()
    assert(sub.is_closed())?
    
    // Should be safe to call multiple times
    sub.unsubscribe()
    sub.unsubscribe()
}
