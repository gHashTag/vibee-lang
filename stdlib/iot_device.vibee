// =============================================================================
// Vibee OS — IoT Device Module
// IoT device abstractions, lifecycle management, and device twins
// =============================================================================

// -----------------------------------------------------------------------------
// Device Traits
// -----------------------------------------------------------------------------

/// Base trait for all IoT devices
trait Device {
    fn device_id() -> String
    fn device_type() -> DeviceType
    fn status() -> DeviceStatus
    fn capabilities() -> [DeviceCapability]
    fn metadata() -> DeviceMetadata
}

/// Trait for controllable devices
trait Controllable: Device {
    fn execute_command(cmd: DeviceCommand) -> Result<CommandResponse, DeviceError>
    fn supported_commands() -> [String]
}

/// Trait for devices with state
trait Stateful: Device {
    type State
    fn get_state() -> Self.State
    fn set_state(state: Self.State) -> Result<(), DeviceError>
}

/// Trait for devices that report telemetry
trait TelemetryReporter: Device {
    type Telemetry
    fn report_telemetry() -> Result<Self.Telemetry, DeviceError>
    fn telemetry_interval() -> Duration
}

// -----------------------------------------------------------------------------
// Device Types
// -----------------------------------------------------------------------------

enum DeviceType {
    Sensor
    Actuator
    Gateway
    Controller
    Display
    Camera
    Speaker
    Light
    Thermostat
    Lock
    Switch
    Motor
    Valve
    Custom(String)
    
    fn to_string() -> String {
        match self {
            .Sensor => "sensor"
            .Actuator => "actuator"
            .Gateway => "gateway"
            .Controller => "controller"
            .Display => "display"
            .Camera => "camera"
            .Speaker => "speaker"
            .Light => "light"
            .Thermostat => "thermostat"
            .Lock => "lock"
            .Switch => "switch"
            .Motor => "motor"
            .Valve => "valve"
            .Custom(name) => name
        }
    }
}

enum DeviceCapability {
    Read
    Write
    Execute
    Stream
    Configure
    Update
    Reboot
    Reset
    
    fn to_string() -> String {
        match self {
            .Read => "read"
            .Write => "write"
            .Execute => "execute"
            .Stream => "stream"
            .Configure => "configure"
            .Update => "update"
            .Reboot => "reboot"
            .Reset => "reset"
        }
    }
}

// -----------------------------------------------------------------------------
// Device Status
// -----------------------------------------------------------------------------

enum DeviceStatus {
    Online
    Offline
    Connecting
    Disconnecting
    Error(String)
    Maintenance
    Updating
    Sleeping
    
    fn is_available() -> Bool {
        match self {
            .Online => true
            _ => false
        }
    }
    
    fn to_string() -> String {
        match self {
            .Online => "online"
            .Offline => "offline"
            .Connecting => "connecting"
            .Disconnecting => "disconnecting"
            .Error(msg) => "error: \(msg)"
            .Maintenance => "maintenance"
            .Updating => "updating"
            .Sleeping => "sleeping"
        }
    }
}

// -----------------------------------------------------------------------------
// Device Metadata
// -----------------------------------------------------------------------------

struct DeviceMetadata {
    manufacturer: String
    model: String
    serial_number: String
    firmware_version: String
    hardware_version: String
    location: Option<DeviceLocation>
    tags: Map<String, String>
    created_at: Int64
    updated_at: Int64
    
    fn new(manufacturer: String, model: String, serial: String) -> Self {
        let now = @native("timestamp_ms")
        DeviceMetadata {
            manufacturer: manufacturer,
            model: model,
            serial_number: serial,
            firmware_version: "1.0.0",
            hardware_version: "1.0",
            location: None,
            tags: Map.empty(),
            created_at: now,
            updated_at: now
        }
    }
    
    fn with_firmware(version: String) -> Self {
        self.firmware_version = version
        self
    }
    
    fn with_location(location: DeviceLocation) -> Self {
        self.location = Some(location)
        self
    }
    
    fn with_tag(key: String, value: String) -> Self {
        self.tags.set(key, value)
        self
    }
}

struct DeviceLocation {
    name: String
    latitude: Option<Float64>
    longitude: Option<Float64>
    building: Option<String>
    floor: Option<String>
    room: Option<String>
    
    fn new(name: String) -> Self {
        DeviceLocation {
            name: name, latitude: None, longitude: None,
            building: None, floor: None, room: None
        }
    }
    
    fn with_coordinates(lat: Float64, lon: Float64) -> Self {
        self.latitude = Some(lat)
        self.longitude = Some(lon)
        self
    }
    
    fn with_building(building: String, floor: String, room: String) -> Self {
        self.building = Some(building)
        self.floor = Some(floor)
        self.room = Some(room)
        self
    }
}

// -----------------------------------------------------------------------------
// Device Commands
// -----------------------------------------------------------------------------

struct DeviceCommand {
    name: String
    params: Map<String, Value>
    correlation_id: String
    timestamp: Int64
    timeout_ms: Int64
    
    fn new(name: String) -> Self {
        DeviceCommand {
            name: name,
            params: Map.empty(),
            correlation_id: @native("uuid_v4"),
            timestamp: @native("timestamp_ms"),
            timeout_ms: 30000
        }
    }
    
    fn with_param(key: String, value: Value) -> Self {
        self.params.set(key, value)
        self
    }
    
    fn with_timeout(ms: Int64) -> Self {
        self.timeout_ms = ms
        self
    }
}

struct CommandResponse {
    correlation_id: String
    status: CommandStatus
    result: Option<Value>
    error: Option<String>
    timestamp: Int64
    execution_time_ms: Int64
    
    fn success(correlation_id: String, result: Value) -> Self {
        CommandResponse {
            correlation_id: correlation_id,
            status: CommandStatus.Success,
            result: Some(result),
            error: None,
            timestamp: @native("timestamp_ms"),
            execution_time_ms: 0
        }
    }
    
    fn failure(correlation_id: String, error: String) -> Self {
        CommandResponse {
            correlation_id: correlation_id,
            status: CommandStatus.Failed,
            result: None,
            error: Some(error),
            timestamp: @native("timestamp_ms"),
            execution_time_ms: 0
        }
    }
}

enum CommandStatus { Pending, Running, Success, Failed, Timeout, Cancelled }

// -----------------------------------------------------------------------------
// Device Twin
// -----------------------------------------------------------------------------

/// Digital twin representation of a device
actor DeviceTwin {
    state device_id: String
    state desired: Map<String, Value>
    state reported: Map<String, Value>
    state metadata: DeviceMetadata
    state version: Int64
    state last_sync: Int64
    state sync_handlers: [fn(Map<String, Value>)]
    
    fn new(device_id: String, metadata: DeviceMetadata) -> Self {
        DeviceTwin {
            device_id: device_id,
            desired: Map.empty(),
            reported: Map.empty(),
            metadata: metadata,
            version: 1,
            last_sync: 0,
            sync_handlers: []
        }
    }
    
    /// Get desired property
    on get_desired(key: String) -> Option<Value> {
        self.desired.get(key)
    }
    
    /// Set desired property
    on set_desired(key: String, value: Value) {
        self.desired.set(key, value)
        self.version += 1
        self.notify_sync()
    }
    
    /// Get reported property
    on get_reported(key: String) -> Option<Value> {
        self.reported.get(key)
    }
    
    /// Update reported property
    on update_reported(key: String, value: Value) {
        self.reported.set(key, value)
        self.last_sync = @native("timestamp_ms")
    }
    
    /// Batch update reported properties
    on update_reported_batch(properties: Map<String, Value>) {
        for (key, value) in properties {
            self.reported.set(key, value)
        }
        self.last_sync = @native("timestamp_ms")
    }
    
    /// Get delta between desired and reported
    on get_delta() -> Map<String, (Option<Value>, Option<Value>)> {
        var delta = Map.empty()
        for (key, desired_value) in self.desired {
            let reported_value = self.reported.get(key)
            if reported_value != Some(desired_value) {
                delta.set(key, (Some(desired_value), reported_value))
            }
        }
        delta
    }
    
    /// Check if device is in sync
    on is_synced() -> Bool {
        self.get_delta().is_empty()
    }
    
    /// Register sync handler
    on on_sync(handler: fn(Map<String, Value>)) {
        self.sync_handlers.push(handler)
    }
    
    fn notify_sync() {
        let delta = self.get_delta()
        if !delta.is_empty() {
            for handler in self.sync_handlers {
                handler(self.desired.clone())
            }
        }
    }
    
    /// Serialize twin to JSON
    on to_json() -> String {
        JSON.stringify({
            "deviceId": self.device_id,
            "desired": self.desired,
            "reported": self.reported,
            "version": self.version,
            "lastSync": self.last_sync
        })
    }
}

// -----------------------------------------------------------------------------
// Device Implementations
// -----------------------------------------------------------------------------

/// Smart light device
actor SmartLight {
    state id: String
    state status: DeviceStatus
    state on: Bool
    state brightness: Int  // 0-100
    state color: Option<Color>
    state metadata: DeviceMetadata
    
    fn new(id: String, metadata: DeviceMetadata) -> Self {
        SmartLight {
            id: id,
            status: DeviceStatus.Online,
            on: false,
            brightness: 100,
            color: None,
            metadata: metadata
        }
    }
    
    on turn_on() -> Result<(), DeviceError> {
        self.on = true
        Ok(())
    }
    
    on turn_off() -> Result<(), DeviceError> {
        self.on = false
        Ok(())
    }
    
    on set_brightness(level: Int) -> Result<(), DeviceError> {
        if level < 0 || level > 100 {
            return Err(DeviceError.InvalidParameter("Brightness must be 0-100"))
        }
        self.brightness = level
        Ok(())
    }
    
    on set_color(color: Color) -> Result<(), DeviceError> {
        self.color = Some(color)
        Ok(())
    }
    
    on execute_command(cmd: DeviceCommand) -> Result<CommandResponse, DeviceError> {
        match cmd.name.as_str() {
            "turn_on" => { self.turn_on()?; Ok(CommandResponse.success(cmd.correlation_id, Value.Bool(true))) }
            "turn_off" => { self.turn_off()?; Ok(CommandResponse.success(cmd.correlation_id, Value.Bool(true))) }
            "set_brightness" => {
                let level = cmd.params.get("level").and_then(|v| v.as_int()).ok_or(DeviceError.InvalidParameter("Missing level"))?
                self.set_brightness(level)?
                Ok(CommandResponse.success(cmd.correlation_id, Value.Int(level)))
            }
            _ => Err(DeviceError.UnsupportedCommand(cmd.name))
        }
    }
    
    fn device_id() -> String { self.id }
    fn device_type() -> DeviceType { DeviceType.Light }
    fn status() -> DeviceStatus { self.status }
    fn capabilities() -> [DeviceCapability] { [DeviceCapability.Read, DeviceCapability.Write, DeviceCapability.Execute] }
    fn metadata() -> DeviceMetadata { self.metadata }
}

struct Color {
    r: UInt8
    g: UInt8
    b: UInt8
    
    fn new(r: UInt8, g: UInt8, b: UInt8) -> Self { Color { r: r, g: g, b: b } }
    fn white() -> Self { Color { r: 255, g: 255, b: 255 } }
    fn warm_white() -> Self { Color { r: 255, g: 244, b: 229 } }
    fn from_hex(hex: String) -> Result<Self, DeviceError> {
        if hex.len() != 6 { return Err(DeviceError.InvalidParameter("Invalid hex color")) }
        let r = UInt8.parse_hex(hex[0..2])?
        let g = UInt8.parse_hex(hex[2..4])?
        let b = UInt8.parse_hex(hex[4..6])?
        Ok(Color { r: r, g: g, b: b })
    }
}

/// Smart thermostat device
actor SmartThermostat {
    state id: String
    state status: DeviceStatus
    state current_temp: Float64
    state target_temp: Float64
    state mode: ThermostatMode
    state metadata: DeviceMetadata
    
    fn new(id: String, metadata: DeviceMetadata) -> Self {
        SmartThermostat {
            id: id,
            status: DeviceStatus.Online,
            current_temp: 20.0,
            target_temp: 22.0,
            mode: ThermostatMode.Auto,
            metadata: metadata
        }
    }
    
    on set_target_temperature(temp: Float64) -> Result<(), DeviceError> {
        if temp < 10.0 || temp > 35.0 {
            return Err(DeviceError.InvalidParameter("Temperature must be 10-35°C"))
        }
        self.target_temp = temp
        Ok(())
    }
    
    on set_mode(mode: ThermostatMode) -> Result<(), DeviceError> {
        self.mode = mode
        Ok(())
    }
    
    on get_current_temperature() -> Float64 { self.current_temp }
    on get_target_temperature() -> Float64 { self.target_temp }
    on get_mode() -> ThermostatMode { self.mode }
    
    on execute_command(cmd: DeviceCommand) -> Result<CommandResponse, DeviceError> {
        match cmd.name.as_str() {
            "set_temperature" => {
                let temp = cmd.params.get("temperature").and_then(|v| v.as_float()).ok_or(DeviceError.InvalidParameter("Missing temperature"))?
                self.set_target_temperature(temp)?
                Ok(CommandResponse.success(cmd.correlation_id, Value.Float(temp)))
            }
            "set_mode" => {
                let mode_str = cmd.params.get("mode").and_then(|v| v.as_string()).ok_or(DeviceError.InvalidParameter("Missing mode"))?
                let mode = ThermostatMode.from_string(mode_str)?
                self.set_mode(mode)?
                Ok(CommandResponse.success(cmd.correlation_id, Value.String(mode_str)))
            }
            _ => Err(DeviceError.UnsupportedCommand(cmd.name))
        }
    }
    
    fn device_id() -> String { self.id }
    fn device_type() -> DeviceType { DeviceType.Thermostat }
    fn status() -> DeviceStatus { self.status }
}

enum ThermostatMode {
    Off
    Heat
    Cool
    Auto
    Fan
    
    fn from_string(s: String) -> Result<Self, DeviceError> {
        match s.to_lowercase().as_str() {
            "off" => Ok(ThermostatMode.Off)
            "heat" => Ok(ThermostatMode.Heat)
            "cool" => Ok(ThermostatMode.Cool)
            "auto" => Ok(ThermostatMode.Auto)
            "fan" => Ok(ThermostatMode.Fan)
            _ => Err(DeviceError.InvalidParameter("Unknown mode"))
        }
    }
}

/// Smart lock device
actor SmartLock {
    state id: String
    state status: DeviceStatus
    state locked: Bool
    state auto_lock_delay: Option<Duration>
    state access_log: [AccessLogEntry]
    state metadata: DeviceMetadata
    
    fn new(id: String, metadata: DeviceMetadata) -> Self {
        SmartLock {
            id: id,
            status: DeviceStatus.Online,
            locked: true,
            auto_lock_delay: Some(Duration.seconds(30)),
            access_log: [],
            metadata: metadata
        }
    }
    
    on lock() -> Result<(), DeviceError> {
        self.locked = true
        self.log_access(AccessType.Lock, None)
        Ok(())
    }
    
    on unlock(user_id: Option<String>) -> Result<(), DeviceError> {
        self.locked = false
        self.log_access(AccessType.Unlock, user_id)
        
        if let Some(delay) = self.auto_lock_delay {
            async {
                @native("sleep_ms", delay.as_millis())
                self.lock()
            }
        }
        Ok(())
    }
    
    on is_locked() -> Bool { self.locked }
    
    on get_access_log() -> [AccessLogEntry] { self.access_log.clone() }
    
    fn log_access(access_type: AccessType, user_id: Option<String>) {
        self.access_log.push(AccessLogEntry {
            timestamp: @native("timestamp_ms"),
            access_type: access_type,
            user_id: user_id
        })
    }
    
    fn device_id() -> String { self.id }
    fn device_type() -> DeviceType { DeviceType.Lock }
    fn status() -> DeviceStatus { self.status }
}

struct AccessLogEntry {
    timestamp: Int64
    access_type: AccessType
    user_id: Option<String>
}

enum AccessType { Lock, Unlock, FailedAttempt }

/// Smart switch device
actor SmartSwitch {
    state id: String
    state status: DeviceStatus
    state on: Bool
    state power_consumption: Float64
    state metadata: DeviceMetadata
    
    fn new(id: String, metadata: DeviceMetadata) -> Self {
        SmartSwitch {
            id: id,
            status: DeviceStatus.Online,
            on: false,
            power_consumption: 0.0,
            metadata: metadata
        }
    }
    
    on turn_on() -> Result<(), DeviceError> { self.on = true; Ok(()) }
    on turn_off() -> Result<(), DeviceError> { self.on = false; Ok(()) }
    on toggle() -> Result<Bool, DeviceError> { self.on = !self.on; Ok(self.on) }
    on is_on() -> Bool { self.on }
    on get_power_consumption() -> Float64 { self.power_consumption }
    
    fn device_id() -> String { self.id }
    fn device_type() -> DeviceType { DeviceType.Switch }
    fn status() -> DeviceStatus { self.status }
}

// -----------------------------------------------------------------------------
// Device Registry
// -----------------------------------------------------------------------------

/// Registry for managing devices
actor DeviceRegistry {
    state devices: Map<String, Box<dyn Device>>
    state twins: Map<String, DeviceTwin>
    state groups: Map<String, [String]>
    
    fn new() -> Self {
        DeviceRegistry {
            devices: Map.empty(),
            twins: Map.empty(),
            groups: Map.empty()
        }
    }
    
    on register<D: Device>(device: D) -> Result<(), DeviceError> {
        let id = device.device_id()
        if self.devices.contains_key(id) {
            return Err(DeviceError.AlreadyExists(id))
        }
        
        let twin = DeviceTwin.new(id, device.metadata())
        self.devices.set(id, Box.new(device))
        self.twins.set(id, twin)
        Ok(())
    }
    
    on unregister(device_id: String) -> Result<(), DeviceError> {
        if !self.devices.contains_key(device_id) {
            return Err(DeviceError.NotFound(device_id))
        }
        self.devices.remove(device_id)
        self.twins.remove(device_id)
        Ok(())
    }
    
    on get_device(device_id: String) -> Option<Box<dyn Device>> {
        self.devices.get(device_id)
    }
    
    on get_twin(device_id: String) -> Option<DeviceTwin> {
        self.twins.get(device_id)
    }
    
    on list_devices() -> [String] {
        self.devices.keys().collect()
    }
    
    on list_by_type(device_type: DeviceType) -> [String] {
        self.devices.iter()
            .filter(|(_, d)| d.device_type() == device_type)
            .map(|(id, _)| id)
            .collect()
    }
    
    on create_group(name: String, device_ids: [String]) {
        self.groups.set(name, device_ids)
    }
    
    on get_group(name: String) -> Option<[String]> {
        self.groups.get(name)
    }
    
    on execute_on_group(group_name: String, cmd: DeviceCommand) -> Map<String, Result<CommandResponse, DeviceError>> {
        var results = Map.empty()
        if let Some(device_ids) = self.groups.get(group_name) {
            for id in device_ids {
                if let Some(device) = self.devices.get(id) {
                    if let controllable = device as Controllable {
                        results.set(id, controllable.execute_command(cmd.clone()))
                    }
                }
            }
        }
        results
    }
}

// -----------------------------------------------------------------------------
// Device Provisioning
// -----------------------------------------------------------------------------

struct DeviceProvisioningInfo {
    device_id: String
    device_type: DeviceType
    connection_string: String
    symmetric_key: Option<String>
    x509_cert: Option<String>
    
    fn new(device_id: String, device_type: DeviceType) -> Self {
        DeviceProvisioningInfo {
            device_id: device_id,
            device_type: device_type,
            connection_string: "",
            symmetric_key: None,
            x509_cert: None
        }
    }
    
    fn with_symmetric_key(key: String) -> Self {
        self.symmetric_key = Some(key)
        self
    }
    
    fn with_x509(cert: String) -> Self {
        self.x509_cert = Some(cert)
        self
    }
}

actor DeviceProvisioning {
    state endpoint: String
    state scope_id: String
    
    fn new(endpoint: String, scope_id: String) -> Self {
        DeviceProvisioning { endpoint: endpoint, scope_id: scope_id }
    }
    
    on provision(info: DeviceProvisioningInfo) -> Result<ProvisioningResult, DeviceError> {
        @native("dps_provision", self.endpoint, self.scope_id, info)
    }
}

struct ProvisioningResult {
    device_id: String
    assigned_hub: String
    status: ProvisioningStatus
}

enum ProvisioningStatus { Assigned, Assigning, Failed, Disabled }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum DeviceError {
    NotFound(String)
    AlreadyExists(String)
    NotAvailable
    InvalidParameter(String)
    UnsupportedCommand(String)
    CommunicationError(String)
    AuthenticationError(String)
    Timeout
    
    fn to_string() -> String {
        match self {
            .NotFound(id) => "Device not found: \(id)"
            .AlreadyExists(id) => "Device already exists: \(id)"
            .NotAvailable => "Device not available"
            .InvalidParameter(msg) => "Invalid parameter: \(msg)"
            .UnsupportedCommand(cmd) => "Unsupported command: \(cmd)"
            .CommunicationError(msg) => "Communication error: \(msg)"
            .AuthenticationError(msg) => "Authentication error: \(msg)"
            .Timeout => "Device operation timeout"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "device status availability" {
    assert(DeviceStatus.Online.is_available())?
    assert(!DeviceStatus.Offline.is_available())?
    assert(!DeviceStatus.Maintenance.is_available())?
}

test "smart light operations" {
    let metadata = DeviceMetadata.new("TestCo", "Light1", "SN001")
    let light = SmartLight.new("light-1", metadata)
    
    light.turn_on()?
    assert(light.on)?
    
    light.set_brightness(50)?
    assert_eq(light.brightness, 50)?
}

test "device twin sync" {
    let metadata = DeviceMetadata.new("TestCo", "Device1", "SN001")
    let twin = DeviceTwin.new("device-1", metadata)
    
    twin.set_desired("temperature", Value.Float(22.0))
    twin.update_reported("temperature", Value.Float(20.0))
    
    assert(!twin.is_synced())?
    
    twin.update_reported("temperature", Value.Float(22.0))
    assert(twin.is_synced())?
}

test "thermostat mode parsing" {
    assert_eq(ThermostatMode.from_string("heat")?, ThermostatMode.Heat)?
    assert_eq(ThermostatMode.from_string("AUTO")?, ThermostatMode.Auto)?
}

test "color from hex" {
    let color = Color.from_hex("FF5500")?
    assert_eq(color.r, 255)?
    assert_eq(color.g, 85)?
    assert_eq(color.b, 0)?
}
