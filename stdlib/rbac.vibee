// =============================================================================
// Vibee OS â€” RBAC Module
// Role-Based Access Control
// =============================================================================

// =============================================================================
// Core Types
// =============================================================================

/// Role definition
struct Role {
    id: String
    name: String
    description: Option<String>
    permissions: Set<String>
    parent_roles: [String]
    metadata: Map<String, String>
    created_at: DateTime
    updated_at: DateTime
}

impl Role {
    fn new(name: String) -> Self {
        Role {
            id: uuid.v4(),
            name: name,
            description: None,
            permissions: Set.empty(),
            parent_roles: [],
            metadata: Map.empty(),
            created_at: DateTime.now(),
            updated_at: DateTime.now()
        }
    }
    
    fn with_description(desc: String) -> Self { self.description = Some(desc); self }
    fn with_permission(perm: String) -> Self { self.permissions.insert(perm); self }
    fn with_permissions(perms: [String]) -> Self { for p in perms { self.permissions.insert(p) }; self }
    fn with_parent(parent: String) -> Self { self.parent_roles.push(parent); self }
    fn with_parents(parents: [String]) -> Self { self.parent_roles.extend(parents); self }
    
    fn has_permission(perm: String) -> Bool { self.permissions.contains(perm) }
    fn add_permission(perm: String) { self.permissions.insert(perm); self.updated_at = DateTime.now() }
    fn remove_permission(perm: String) { self.permissions.remove(perm); self.updated_at = DateTime.now() }
}

/// Permission definition
struct Permission {
    id: String
    name: String
    resource: String
    action: String
    description: Option<String>
    conditions: [PermissionCondition]
}

impl Permission {
    fn new(name: String, resource: String, action: String) -> Self {
        Permission {
            id: uuid.v4(),
            name: name,
            resource: resource,
            action: action,
            description: None,
            conditions: []
        }
    }
    
    fn with_description(desc: String) -> Self { self.description = Some(desc); self }
    fn with_condition(cond: PermissionCondition) -> Self { self.conditions.push(cond); self }
    
    /// Create permission string
    fn to_string() -> String { format!("{}:{}", self.resource, self.action) }
    
    /// Parse permission string
    fn from_string(s: String) -> Option<Self> {
        let parts = s.split(":")
        if parts.len() != 2 { return None }
        Some(Permission.new(s.clone(), parts[0].clone(), parts[1].clone()))
    }
}

/// Permission condition
enum PermissionCondition {
    TimeRange { start: Time, end: Time }
    IpRange { cidr: String }
    Attribute { key: String, op: ConditionOp, value: String }
    Custom { name: String, params: Map<String, String> }
}

enum ConditionOp { Eq, Ne, Gt, Lt, Gte, Lte, Contains, StartsWith, EndsWith, Matches }

// =============================================================================
// Role Assignment
// =============================================================================

/// Role assignment to a subject
struct RoleAssignment {
    id: String
    subject_id: String
    subject_type: SubjectType
    role_id: String
    scope: Option<String>
    expires_at: Option<DateTime>
    granted_by: String
    granted_at: DateTime
}

enum SubjectType { User, Group, ServiceAccount, ApiKey }

impl RoleAssignment {
    fn new(subject_id: String, subject_type: SubjectType, role_id: String) -> Self {
        RoleAssignment {
            id: uuid.v4(),
            subject_id: subject_id,
            subject_type: subject_type,
            role_id: role_id,
            scope: None,
            expires_at: None,
            granted_by: "",
            granted_at: DateTime.now()
        }
    }
    
    fn with_scope(scope: String) -> Self { self.scope = Some(scope); self }
    fn with_expiry(expires_at: DateTime) -> Self { self.expires_at = Some(expires_at); self }
    fn with_granter(granter: String) -> Self { self.granted_by = granter; self }
    
    fn is_expired() -> Bool {
        self.expires_at.map(|t| DateTime.now() > t).unwrap_or(false)
    }
    
    fn is_valid() -> Bool { !self.is_expired() }
}

// =============================================================================
// RBAC Manager
// =============================================================================

/// RBAC Manager
struct RbacManager<S: RoleStore> {
    store: S
    cache: RoleCache
    config: RbacConfig
}

struct RbacConfig {
    enable_caching: Bool
    cache_ttl: Int64
    enable_hierarchy: Bool
    max_hierarchy_depth: Int
    enable_wildcards: Bool
}

impl RbacConfig {
    fn default() -> Self {
        RbacConfig {
            enable_caching: true,
            cache_ttl: 300,
            enable_hierarchy: true,
            max_hierarchy_depth: 10,
            enable_wildcards: true
        }
    }
}

impl<S: RoleStore> RbacManager<S> {
    fn new(store: S) -> Self {
        RbacManager {
            store: store,
            cache: RoleCache.new(),
            config: RbacConfig.default()
        }
    }
    
    fn with_config(config: RbacConfig) -> Self { self.config = config; self }
    
    // -------------------------------------------------------------------------
    // Role Management
    // -------------------------------------------------------------------------
    
    fn create_role(role: Role) -> Result<Role, RbacError> {
        if self.store.find_role_by_name(role.name.clone()).is_some() {
            return Err(RbacError.RoleExists(role.name))
        }
        self.store.create_role(role)
    }
    
    fn get_role(role_id: String) -> Option<Role> {
        if self.config.enable_caching {
            if let Some(role) = self.cache.get_role(role_id.clone()) {
                return Some(role)
            }
        }
        
        let role = self.store.find_role_by_id(role_id.clone())?
        
        if self.config.enable_caching {
            self.cache.set_role(role_id, role.clone())
        }
        
        Some(role)
    }
    
    fn get_role_by_name(name: String) -> Option<Role> {
        self.store.find_role_by_name(name)
    }
    
    fn update_role(role: Role) -> Result<Role, RbacError> {
        let result = self.store.update_role(role.clone())?
        if self.config.enable_caching {
            self.cache.invalidate_role(role.id.clone())
        }
        Ok(result)
    }
    
    fn delete_role(role_id: String) -> Result<(), RbacError> {
        // Check if role has assignments
        let assignments = self.store.list_assignments_by_role(role_id.clone())
        if !assignments.is_empty() {
            return Err(RbacError.RoleInUse(role_id))
        }
        
        self.store.delete_role(role_id.clone())?
        
        if self.config.enable_caching {
            self.cache.invalidate_role(role_id)
        }
        
        Ok(())
    }
    
    fn list_roles() -> [Role] {
        self.store.list_roles()
    }
    
    // -------------------------------------------------------------------------
    // Permission Management
    // -------------------------------------------------------------------------
    
    fn add_permission_to_role(role_id: String, permission: String) -> Result<(), RbacError> {
        var role = self.store.find_role_by_id(role_id.clone()).ok_or(RbacError.RoleNotFound(role_id.clone()))?
        role.add_permission(permission)
        self.store.update_role(role)?
        
        if self.config.enable_caching {
            self.cache.invalidate_role(role_id)
        }
        
        Ok(())
    }
    
    fn remove_permission_from_role(role_id: String, permission: String) -> Result<(), RbacError> {
        var role = self.store.find_role_by_id(role_id.clone()).ok_or(RbacError.RoleNotFound(role_id.clone()))?
        role.remove_permission(permission)
        self.store.update_role(role)?
        
        if self.config.enable_caching {
            self.cache.invalidate_role(role_id)
        }
        
        Ok(())
    }
    
    fn get_role_permissions(role_id: String) -> Result<Set<String>, RbacError> {
        let role = self.get_role(role_id.clone()).ok_or(RbacError.RoleNotFound(role_id))?
        
        if self.config.enable_hierarchy {
            return Ok(self.get_effective_permissions(role))
        }
        
        Ok(role.permissions)
    }
    
    fn get_effective_permissions(role: Role) -> Set<String> {
        var permissions = role.permissions.clone()
        var visited = Set.empty()
        self.collect_parent_permissions(role, permissions, visited, 0)
        permissions
    }
    
    fn collect_parent_permissions(role: Role, permissions: Set<String>, visited: Set<String>, depth: Int) {
        if depth >= self.config.max_hierarchy_depth { return }
        if visited.contains(role.id.clone()) { return }
        
        visited.insert(role.id.clone())
        
        for parent_id in role.parent_roles {
            if let Some(parent) = self.get_role(parent_id) {
                for perm in parent.permissions { permissions.insert(perm) }
                self.collect_parent_permissions(parent, permissions, visited, depth + 1)
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // Role Assignment
    // -------------------------------------------------------------------------
    
    fn assign_role(subject_id: String, subject_type: SubjectType, role_id: String) -> Result<RoleAssignment, RbacError> {
        // Verify role exists
        if self.get_role(role_id.clone()).is_none() {
            return Err(RbacError.RoleNotFound(role_id))
        }
        
        let assignment = RoleAssignment.new(subject_id, subject_type, role_id)
        self.store.create_assignment(assignment)
    }
    
    fn assign_role_with_scope(subject_id: String, subject_type: SubjectType, role_id: String, scope: String) -> Result<RoleAssignment, RbacError> {
        if self.get_role(role_id.clone()).is_none() {
            return Err(RbacError.RoleNotFound(role_id))
        }
        
        let assignment = RoleAssignment.new(subject_id, subject_type, role_id).with_scope(scope)
        self.store.create_assignment(assignment)
    }
    
    fn assign_role_with_expiry(subject_id: String, subject_type: SubjectType, role_id: String, expires_at: DateTime) -> Result<RoleAssignment, RbacError> {
        if self.get_role(role_id.clone()).is_none() {
            return Err(RbacError.RoleNotFound(role_id))
        }
        
        let assignment = RoleAssignment.new(subject_id, subject_type, role_id).with_expiry(expires_at)
        self.store.create_assignment(assignment)
    }
    
    fn revoke_role(subject_id: String, role_id: String) -> Result<(), RbacError> {
        self.store.delete_assignment(subject_id, role_id)?
        
        if self.config.enable_caching {
            self.cache.invalidate_subject(subject_id)
        }
        
        Ok(())
    }
    
    fn get_subject_roles(subject_id: String) -> [Role] {
        let assignments = self.store.list_assignments_by_subject(subject_id)
        assignments.iter()
            .filter(|a| a.is_valid())
            .filter_map(|a| self.get_role(a.role_id.clone()))
            .collect()
    }
    
    fn get_subject_permissions(subject_id: String) -> Set<String> {
        let roles = self.get_subject_roles(subject_id)
        var permissions = Set.empty()
        
        for role in roles {
            let role_perms = self.get_effective_permissions(role)
            for perm in role_perms { permissions.insert(perm) }
        }
        
        permissions
    }
    
    // -------------------------------------------------------------------------
    // Authorization Checks
    // -------------------------------------------------------------------------
    
    fn has_role(subject_id: String, role_name: String) -> Bool {
        let roles = self.get_subject_roles(subject_id)
        roles.iter().any(|r| r.name == role_name)
    }
    
    fn has_any_role(subject_id: String, role_names: [String]) -> Bool {
        let roles = self.get_subject_roles(subject_id)
        role_names.iter().any(|name| roles.iter().any(|r| r.name == *name))
    }
    
    fn has_all_roles(subject_id: String, role_names: [String]) -> Bool {
        let roles = self.get_subject_roles(subject_id)
        role_names.iter().all(|name| roles.iter().any(|r| r.name == *name))
    }
    
    fn has_permission(subject_id: String, permission: String) -> Bool {
        let permissions = self.get_subject_permissions(subject_id)
        
        if permissions.contains(permission.clone()) { return true }
        
        // Check wildcards
        if self.config.enable_wildcards {
            if permissions.contains("*") { return true }
            
            let parts = permission.split(":")
            if parts.len() == 2 {
                let resource_wildcard = format!("{}:*", parts[0])
                if permissions.contains(resource_wildcard) { return true }
            }
        }
        
        false
    }
    
    fn has_permission_in_scope(subject_id: String, permission: String, scope: String) -> Bool {
        let assignments = self.store.list_assignments_by_subject(subject_id.clone())
        
        for assignment in assignments {
            if !assignment.is_valid() { continue }
            
            // Check scope match
            if let Some(assigned_scope) = assignment.scope.clone() {
                if !self.scope_matches(assigned_scope, scope.clone()) { continue }
            }
            
            if let Some(role) = self.get_role(assignment.role_id) {
                let perms = self.get_effective_permissions(role)
                if perms.contains(permission.clone()) { return true }
                
                if self.config.enable_wildcards && perms.contains("*") { return true }
            }
        }
        
        false
    }
    
    fn scope_matches(pattern: String, scope: String) -> Bool {
        if pattern == scope { return true }
        if pattern == "*" { return true }
        if pattern.ends_with("/*") {
            let prefix = pattern.trim_end("/*")
            return scope.starts_with(prefix)
        }
        false
    }
    
    fn check_permission(subject_id: String, permission: String) -> Result<(), RbacError> {
        if self.has_permission(subject_id.clone(), permission.clone()) {
            Ok(())
        } else {
            Err(RbacError.PermissionDenied(subject_id, permission))
        }
    }
    
    // -------------------------------------------------------------------------
    // Cleanup
    // -------------------------------------------------------------------------
    
    fn cleanup_expired_assignments() -> Int {
        self.store.delete_expired_assignments()
    }
}

// =============================================================================
// Role Store Trait
// =============================================================================

trait RoleStore {
    fn find_role_by_id(id: String) -> Option<Role>
    fn find_role_by_name(name: String) -> Option<Role>
    fn create_role(role: Role) -> Result<Role, RbacError>
    fn update_role(role: Role) -> Result<Role, RbacError>
    fn delete_role(id: String) -> Result<(), RbacError>
    fn list_roles() -> [Role]
    
    fn create_assignment(assignment: RoleAssignment) -> Result<RoleAssignment, RbacError>
    fn delete_assignment(subject_id: String, role_id: String) -> Result<(), RbacError>
    fn list_assignments_by_subject(subject_id: String) -> [RoleAssignment]
    fn list_assignments_by_role(role_id: String) -> [RoleAssignment]
    fn delete_expired_assignments() -> Int
}

// =============================================================================
// In-Memory Role Store
// =============================================================================

struct InMemoryRoleStore {
    roles: Map<String, Role>
    assignments: [RoleAssignment]
}

impl InMemoryRoleStore {
    fn new() -> Self { InMemoryRoleStore { roles: Map.empty(), assignments: [] } }
}

impl RoleStore for InMemoryRoleStore {
    fn find_role_by_id(id: String) -> Option<Role> { self.roles.get(id) }
    
    fn find_role_by_name(name: String) -> Option<Role> {
        self.roles.values().find(|r| r.name == name)
    }
    
    fn create_role(role: Role) -> Result<Role, RbacError> {
        self.roles.set(role.id.clone(), role.clone())
        Ok(role)
    }
    
    fn update_role(role: Role) -> Result<Role, RbacError> {
        if !self.roles.contains_key(role.id.clone()) {
            return Err(RbacError.RoleNotFound(role.id))
        }
        self.roles.set(role.id.clone(), role.clone())
        Ok(role)
    }
    
    fn delete_role(id: String) -> Result<(), RbacError> {
        self.roles.remove(id)
        Ok(())
    }
    
    fn list_roles() -> [Role] { self.roles.values().collect() }
    
    fn create_assignment(assignment: RoleAssignment) -> Result<RoleAssignment, RbacError> {
        self.assignments.push(assignment.clone())
        Ok(assignment)
    }
    
    fn delete_assignment(subject_id: String, role_id: String) -> Result<(), RbacError> {
        self.assignments = self.assignments.iter()
            .filter(|a| !(a.subject_id == subject_id && a.role_id == role_id))
            .collect()
        Ok(())
    }
    
    fn list_assignments_by_subject(subject_id: String) -> [RoleAssignment] {
        self.assignments.iter().filter(|a| a.subject_id == subject_id).collect()
    }
    
    fn list_assignments_by_role(role_id: String) -> [RoleAssignment] {
        self.assignments.iter().filter(|a| a.role_id == role_id).collect()
    }
    
    fn delete_expired_assignments() -> Int {
        let before = self.assignments.len()
        self.assignments = self.assignments.iter().filter(|a| a.is_valid()).collect()
        before - self.assignments.len()
    }
}

// =============================================================================
// Role Cache
// =============================================================================

struct RoleCache {
    roles: Map<String, CachedRole>
    subject_permissions: Map<String, CachedPermissions>
    ttl: Int64
}

struct CachedRole { role: Role, cached_at: Int64 }
struct CachedPermissions { permissions: Set<String>, cached_at: Int64 }

impl RoleCache {
    fn new() -> Self {
        RoleCache { roles: Map.empty(), subject_permissions: Map.empty(), ttl: 300 }
    }
    
    fn with_ttl(ttl: Int64) -> Self { self.ttl = ttl; self }
    
    fn get_role(id: String) -> Option<Role> {
        let cached = self.roles.get(id)?
        if DateTime.now().timestamp() - cached.cached_at > self.ttl { return None }
        Some(cached.role.clone())
    }
    
    fn set_role(id: String, role: Role) {
        self.roles.set(id, CachedRole { role: role, cached_at: DateTime.now().timestamp() })
    }
    
    fn invalidate_role(id: String) { self.roles.remove(id) }
    fn invalidate_subject(id: String) { self.subject_permissions.remove(id) }
    fn clear() { self.roles.clear(); self.subject_permissions.clear() }
}

// =============================================================================
// Predefined Roles
// =============================================================================

/// Common predefined roles
struct PredefinedRoles {}

impl PredefinedRoles {
    fn super_admin() -> Role {
        Role.new("super_admin")
            .with_description("Full system access")
            .with_permission("*")
    }
    
    fn admin() -> Role {
        Role.new("admin")
            .with_description("Administrative access")
            .with_permissions(["users:*", "roles:*", "settings:*"])
    }
    
    fn moderator() -> Role {
        Role.new("moderator")
            .with_description("Content moderation access")
            .with_permissions(["content:read", "content:update", "content:delete", "users:read"])
    }
    
    fn editor() -> Role {
        Role.new("editor")
            .with_description("Content editing access")
            .with_permissions(["content:read", "content:create", "content:update"])
    }
    
    fn viewer() -> Role {
        Role.new("viewer")
            .with_description("Read-only access")
            .with_permission("content:read")
    }
    
    fn guest() -> Role {
        Role.new("guest")
            .with_description("Limited guest access")
            .with_permission("public:read")
    }
}

// =============================================================================
// RBAC Actor
// =============================================================================

actor RbacActor {
    state manager: RbacManager<InMemoryRoleStore>
    
    fn new() -> Self {
        RbacActor { manager: RbacManager.new(InMemoryRoleStore.new()) }
    }
    
    fn create_role(role: Role) -> Result<Role, RbacError> { self.manager.create_role(role) }
    fn get_role(id: String) -> Option<Role> { self.manager.get_role(id) }
    fn assign_role(subject_id: String, role_id: String) -> Result<RoleAssignment, RbacError> {
        self.manager.assign_role(subject_id, SubjectType.User, role_id)
    }
    fn has_permission(subject_id: String, permission: String) -> Bool {
        self.manager.has_permission(subject_id, permission)
    }
    fn check_permission(subject_id: String, permission: String) -> Result<(), RbacError> {
        self.manager.check_permission(subject_id, permission)
    }
}

// =============================================================================
// Errors
// =============================================================================

enum RbacError {
    RoleNotFound(String)
    RoleExists(String)
    RoleInUse(String)
    PermissionDenied(String, String)
    InvalidAssignment(String)
    Other(String)
}

impl Display for RbacError {
    fn fmt(f: Formatter) {
        match self {
            RoleNotFound(id) => f.write(format!("Role not found: {}", id))
            RoleExists(name) => f.write(format!("Role already exists: {}", name))
            RoleInUse(id) => f.write(format!("Role is in use: {}", id))
            PermissionDenied(subject, perm) => f.write(format!("Permission denied: {} lacks {}", subject, perm))
            InvalidAssignment(msg) => f.write(format!("Invalid assignment: {}", msg))
            Other(msg) => f.write(msg)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create role" {
    let store = InMemoryRoleStore.new()
    var manager = RbacManager.new(store)
    
    let role = Role.new("admin").with_permissions(["users:read", "users:write"])
    let created = manager.create_role(role)?
    
    assert_eq(created.name, "admin")?
    assert(created.has_permission("users:read"))?
}

test "role hierarchy" {
    let store = InMemoryRoleStore.new()
    var manager = RbacManager.new(store)
    
    let viewer = Role.new("viewer").with_permission("content:read")
    let editor = Role.new("editor").with_permission("content:write").with_parent("viewer")
    
    manager.create_role(viewer)?
    let created_editor = manager.create_role(editor)?
    
    let perms = manager.get_effective_permissions(created_editor)
    assert(perms.contains("content:read"))?
    assert(perms.contains("content:write"))?
}

test "assign and check permission" {
    let store = InMemoryRoleStore.new()
    var manager = RbacManager.new(store)
    
    let role = Role.new("admin").with_permission("users:*")
    manager.create_role(role.clone())?
    manager.assign_role("user-123", SubjectType.User, role.id)?
    
    assert(manager.has_permission("user-123", "users:read"))?
    assert(manager.has_permission("user-123", "users:write"))?
    assert(!manager.has_permission("user-123", "settings:read"))?
}

test "wildcard permissions" {
    let store = InMemoryRoleStore.new()
    var manager = RbacManager.new(store)
    
    let role = Role.new("super_admin").with_permission("*")
    manager.create_role(role.clone())?
    manager.assign_role("admin-1", SubjectType.User, role.id)?
    
    assert(manager.has_permission("admin-1", "anything:here"))?
}

test "scoped permissions" {
    let store = InMemoryRoleStore.new()
    var manager = RbacManager.new(store)
    
    let role = Role.new("org_admin").with_permission("users:*")
    manager.create_role(role.clone())?
    manager.assign_role_with_scope("user-1", SubjectType.User, role.id, "org/acme/*")?
    
    assert(manager.has_permission_in_scope("user-1", "users:read", "org/acme/team1"))?
    assert(!manager.has_permission_in_scope("user-1", "users:read", "org/other/team1"))?
}
