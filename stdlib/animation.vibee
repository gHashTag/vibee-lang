// =============================================================================
// Vibee OS â€” Animation Module
// UI animations and transitions
// =============================================================================

use color::RGBA
use canvas::{Point, Rect, Transform}

// -----------------------------------------------------------------------------
// Easing Functions
// -----------------------------------------------------------------------------

enum Easing {
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut,
    CubicBezier(Float64, Float64, Float64, Float64),
    Spring(Float64, Float64, Float64)
}

impl Easing {
    fn apply(t: Float64) -> Float64 {
        match self {
            Linear => t,
            EaseIn => t * t,
            EaseOut => 1.0 - (1.0 - t).powi(2),
            EaseInOut => if t < 0.5 { 2.0 * t * t } else { 1.0 - (-2.0 * t + 2.0).powi(2) / 2.0 },
            CubicBezier(x1, y1, x2, y2) => cubic_bezier(t, x1, y1, x2, y2),
            Spring(stiffness, damping, mass) => spring_value(t, stiffness, damping, mass)
        }
    }
}

fn cubic_bezier(t: Float64, x1: Float64, y1: Float64, x2: Float64, y2: Float64) -> Float64 {
    let cx = 3.0 * x1
    let bx = 3.0 * (x2 - x1) - cx
    let ax = 1.0 - cx - bx
    ((ax * t + bx) * t + cx) * t
}

fn spring_value(t: Float64, stiffness: Float64, damping: Float64, mass: Float64) -> Float64 {
    let omega = (stiffness / mass).sqrt()
    let zeta = damping / (2.0 * (stiffness * mass).sqrt())
    if zeta < 1.0 {
        let omega_d = omega * (1.0 - zeta * zeta).sqrt()
        1.0 - (-zeta * omega * t).exp() * ((zeta * omega * t / omega_d).sin() + (omega_d * t).cos())
    } else {
        1.0 - (1.0 + omega * t) * (-omega * t).exp()
    }
}

// -----------------------------------------------------------------------------
// Animation Value
// -----------------------------------------------------------------------------

trait Animatable {
    fn lerp(other: Self, t: Float64) -> Self
}

impl Animatable for Float64 {
    fn lerp(other: Float64, t: Float64) -> Float64 { self + (other - self) * t }
}

impl Animatable for Point {
    fn lerp(other: Point, t: Float64) -> Point {
        Point { x: self.x.lerp(other.x, t), y: self.y.lerp(other.y, t) }
    }
}

impl Animatable for RGBA {
    fn lerp(other: RGBA, t: Float64) -> RGBA {
        RGBA {
            r: (self.r as Float64).lerp(other.r as Float64, t) as UInt8,
            g: (self.g as Float64).lerp(other.g as Float64, t) as UInt8,
            b: (self.b as Float64).lerp(other.b as Float64, t) as UInt8,
            a: self.a.lerp(other.a, t)
        }
    }
}

// -----------------------------------------------------------------------------
// Tween Animation
// -----------------------------------------------------------------------------

struct Tween<T: Animatable> {
    from: T
    to: T
    duration: Float64
    easing: Easing
    delay: Float64
    on_complete: Option<fn()>
    
    fn new(from: T, to: T, duration: Float64) -> Self {
        Tween { from: from, to: to, duration: duration, easing: Easing.EaseInOut, delay: 0.0, on_complete: None }
    }
    
    fn easing(e: Easing) -> Self { self.easing = e; self }
    fn delay(d: Float64) -> Self { self.delay = d; self }
    fn on_complete(f: fn()) -> Self { self.on_complete = Some(f); self }
    
    fn value_at(time: Float64) -> T {
        let t = ((time - self.delay) / self.duration).clamp(0.0, 1.0)
        self.from.lerp(self.to, self.easing.apply(t))
    }
}

// -----------------------------------------------------------------------------
// Animation Controller
// -----------------------------------------------------------------------------

struct AnimationController {
    duration: Float64
    value: Float64
    status: AnimationStatus
    direction: AnimationDirection
    repeat: RepeatMode
    on_status_change: Option<fn(AnimationStatus)>
    
    fn new(duration: Float64) -> Self {
        AnimationController {
            duration: duration, value: 0.0, status: AnimationStatus.Dismissed,
            direction: AnimationDirection.Forward, repeat: RepeatMode.None, on_status_change: None
        }
    }
    
    fn forward() { self.direction = AnimationDirection.Forward; self.status = AnimationStatus.Forward }
    fn reverse() { self.direction = AnimationDirection.Reverse; self.status = AnimationStatus.Reverse }
    fn stop() { self.status = AnimationStatus.Dismissed }
    fn reset() { self.value = 0.0; self.status = AnimationStatus.Dismissed }
    fn repeat(mode: RepeatMode) -> Self { self.repeat = mode; self }
    
    fn update(dt: Float64) {
        if self.status == AnimationStatus.Dismissed || self.status == AnimationStatus.Completed { return }
        
        let delta = dt / self.duration
        match self.direction {
            Forward => self.value = (self.value + delta).min(1.0),
            Reverse => self.value = (self.value - delta).max(0.0)
        }
        
        if self.value >= 1.0 || self.value <= 0.0 {
            match self.repeat {
                None => self.status = AnimationStatus.Completed,
                Loop => self.value = if self.value >= 1.0 { 0.0 } else { 1.0 },
                Reverse => { self.direction = if self.direction == AnimationDirection.Forward { AnimationDirection.Reverse } else { AnimationDirection.Forward } }
            }
        }
    }
    
    fn is_animating() -> Bool {
        self.status == AnimationStatus.Forward || self.status == AnimationStatus.Reverse
    }
}

enum AnimationStatus { Dismissed, Forward, Reverse, Completed }
enum AnimationDirection { Forward, Reverse }
enum RepeatMode { None, Loop, Reverse }

// -----------------------------------------------------------------------------
// Keyframe Animation
// -----------------------------------------------------------------------------

struct Keyframe<T: Animatable> {
    time: Float64
    value: T
    easing: Easing
}

struct KeyframeAnimation<T: Animatable> {
    keyframes: [Keyframe<T>]
    duration: Float64
    
    fn new() -> Self { KeyframeAnimation { keyframes: [], duration: 0.0 } }
    
    fn add(time: Float64, value: T) -> Self {
        self.keyframes.push(Keyframe { time: time, value: value, easing: Easing.Linear })
        self.duration = self.duration.max(time)
        self
    }
    
    fn add_with_easing(time: Float64, value: T, easing: Easing) -> Self {
        self.keyframes.push(Keyframe { time: time, value: value, easing: easing })
        self.duration = self.duration.max(time)
        self
    }
    
    fn value_at(time: Float64) -> T {
        let t = time.clamp(0.0, self.duration)
        var prev = &self.keyframes[0]
        for kf in &self.keyframes {
            if kf.time > t { break }
            prev = kf
        }
        
        for kf in &self.keyframes {
            if kf.time > t {
                let local_t = (t - prev.time) / (kf.time - prev.time)
                return prev.value.lerp(kf.value, kf.easing.apply(local_t))
            }
        }
        self.keyframes.last().unwrap().value
    }
}

// -----------------------------------------------------------------------------
// Transition Widgets
// -----------------------------------------------------------------------------

struct FadeTransition {
    opacity: Float64
    child: Box<dyn Component>
    controller: AnimationController
    
    fn new(child: Box<dyn Component>, controller: AnimationController) -> Self {
        FadeTransition { opacity: 1.0, child: child, controller: controller }
    }
    
    fn update(dt: Float64) { self.controller.update(dt); self.opacity = self.controller.value }
}

struct SlideTransition {
    offset: Point
    child: Box<dyn Component>
    controller: AnimationController
    begin: Point
    end: Point
    
    fn new(child: Box<dyn Component>, controller: AnimationController) -> Self {
        SlideTransition { offset: Point.zero(), child: child, controller: controller, begin: Point.new(-1.0, 0.0), end: Point.zero() }
    }
    
    fn from_left() -> Self { self.begin = Point.new(-1.0, 0.0); self }
    fn from_right() -> Self { self.begin = Point.new(1.0, 0.0); self }
    fn from_top() -> Self { self.begin = Point.new(0.0, -1.0); self }
    fn from_bottom() -> Self { self.begin = Point.new(0.0, 1.0); self }
    
    fn update(dt: Float64) {
        self.controller.update(dt)
        self.offset = self.begin.lerp(self.end, self.controller.value)
    }
}

struct ScaleTransition {
    scale: Float64
    child: Box<dyn Component>
    controller: AnimationController
    
    fn new(child: Box<dyn Component>, controller: AnimationController) -> Self {
        ScaleTransition { scale: 1.0, child: child, controller: controller }
    }
    
    fn update(dt: Float64) { self.controller.update(dt); self.scale = self.controller.value }
}

struct RotationTransition {
    angle: Float64
    child: Box<dyn Component>
    controller: AnimationController
    turns: Float64
    
    fn new(child: Box<dyn Component>, controller: AnimationController) -> Self {
        RotationTransition { angle: 0.0, child: child, controller: controller, turns: 1.0 }
    }
    
    fn turns(t: Float64) -> Self { self.turns = t; self }
    fn update(dt: Float64) { self.controller.update(dt); self.angle = self.controller.value * self.turns * 2.0 * 3.14159 }
}

// -----------------------------------------------------------------------------
// Animated Builder
// -----------------------------------------------------------------------------

struct AnimatedBuilder<T: Animatable> {
    animation: Tween<T>
    builder: fn(T) -> Box<dyn Component>
    elapsed: Float64
    
    fn new(animation: Tween<T>, builder: fn(T) -> Box<dyn Component>) -> Self {
        AnimatedBuilder { animation: animation, builder: builder, elapsed: 0.0 }
    }
    
    fn update(dt: Float64) { self.elapsed += dt }
    fn build() -> Box<dyn Component> { self.builder(self.animation.value_at(self.elapsed)) }
}

// -----------------------------------------------------------------------------
// Staggered Animation
// -----------------------------------------------------------------------------

struct StaggeredAnimation {
    animations: [Box<dyn Animation>]
    stagger_delay: Float64
    
    fn new(stagger_delay: Float64) -> Self {
        StaggeredAnimation { animations: [], stagger_delay: stagger_delay }
    }
    
    fn add(animation: Box<dyn Animation>) -> Self { self.animations.push(animation); self }
    
    fn start() {
        for (i, anim) in self.animations.iter().enumerate() {
            let delay = i as Float64 * self.stagger_delay
            @native("schedule_animation", anim, delay)
        }
    }
}

trait Animation {
    fn start()
    fn stop()
    fn update(dt: Float64)
    fn is_complete() -> Bool
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "easing linear" {
    let e = Easing.Linear
    assert_eq(e.apply(0.5), 0.5)?
}

test "easing ease_in" {
    let e = Easing.EaseIn
    assert(e.apply(0.5) < 0.5)?
}

test "tween" {
    let tween = Tween.new(0.0, 100.0, 1.0)
    assert_eq(tween.value_at(0.5), 50.0)?
}

test "animation controller" {
    var ctrl = AnimationController.new(1.0)
    ctrl.forward()
    ctrl.update(0.5)
    assert_eq(ctrl.value, 0.5)?
}

test "keyframe animation" {
    let anim = KeyframeAnimation.new()
        .add(0.0, 0.0)
        .add(1.0, 100.0)
    assert_eq(anim.value_at(0.5), 50.0)?
}
