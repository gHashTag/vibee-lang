// =============================================================================
// Vibee OS ‚Äî Typing Indicator Module
// Real-time typing status and indicators for chat
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Typing Status
// =============================================================================

/// Typing action type
enum TypingAction {
    Typing,
    RecordingVoice,
    RecordingVideo,
    UploadingPhoto,
    UploadingVideo,
    UploadingDocument,
    ChoosingSticker,
    ChoosingLocation,
    ChoosingContact,
    PlayingGame
}

impl TypingAction {
    fn display_text() -> String {
        match self {
            TypingAction.Typing => "typing",
            TypingAction.RecordingVoice => "recording voice message",
            TypingAction.RecordingVideo => "recording video",
            TypingAction.UploadingPhoto => "uploading photo",
            TypingAction.UploadingVideo => "uploading video",
            TypingAction.UploadingDocument => "uploading document",
            TypingAction.ChoosingSticker => "choosing sticker",
            TypingAction.ChoosingLocation => "choosing location",
            TypingAction.ChoosingContact => "choosing contact",
            TypingAction.PlayingGame => "playing game"
        }
    }
    
    fn icon() -> String {
        match self {
            TypingAction.Typing => "‚úçÔ∏è",
            TypingAction.RecordingVoice => "üé§",
            TypingAction.RecordingVideo => "üìπ",
            TypingAction.UploadingPhoto => "üì∑",
            TypingAction.UploadingVideo => "üé¨",
            TypingAction.UploadingDocument => "üìé",
            TypingAction.ChoosingSticker => "üé≠",
            TypingAction.ChoosingLocation => "üìç",
            TypingAction.ChoosingContact => "üë§",
            TypingAction.PlayingGame => "üéÆ"
        }
    }
    
    fn default_timeout() -> Duration {
        match self {
            TypingAction.Typing => Duration.seconds(5),
            TypingAction.RecordingVoice | TypingAction.RecordingVideo => Duration.seconds(30),
            TypingAction.UploadingPhoto | TypingAction.UploadingVideo | 
            TypingAction.UploadingDocument => Duration.seconds(60),
            _ => Duration.seconds(10)
        }
    }
}

/// Individual typing status
struct TypingStatus {
    user_id: String,
    user_name: String,
    action: TypingAction,
    started_at: DateTime,
    expires_at: DateTime
}

impl TypingStatus {
    fn new(user_id: String, user_name: String, action: TypingAction) -> Self {
        let timeout = action.default_timeout()
        TypingStatus {
            user_id: user_id,
            user_name: user_name,
            action: action,
            started_at: DateTime.now(),
            expires_at: DateTime.now() + timeout
        }
    }
    
    fn with_timeout(user_id: String, user_name: String, action: TypingAction, timeout: Duration) -> Self {
        TypingStatus {
            user_id: user_id,
            user_name: user_name,
            action: action,
            started_at: DateTime.now(),
            expires_at: DateTime.now() + timeout
        }
    }
    
    fn is_expired() -> Bool {
        DateTime.now() > self.expires_at
    }
    
    fn refresh() {
        self.expires_at = DateTime.now() + self.action.default_timeout()
    }
    
    fn display() -> String {
        self.action.icon() + " " + self.user_name + " is " + self.action.display_text()
    }
}

// =============================================================================
// Typing Event
// =============================================================================

/// Typing event for pub/sub
struct TypingEvent {
    conversation_id: String,
    user_id: String,
    user_name: String,
    action: TypingAction,
    is_typing: Bool,
    timestamp: DateTime
}

impl TypingEvent {
    fn started(conv_id: String, user_id: String, user_name: String, action: TypingAction) -> Self {
        TypingEvent {
            conversation_id: conv_id,
            user_id: user_id,
            user_name: user_name,
            action: action,
            is_typing: true,
            timestamp: DateTime.now()
        }
    }
    
    fn stopped(conv_id: String, user_id: String, user_name: String) -> Self {
        TypingEvent {
            conversation_id: conv_id,
            user_id: user_id,
            user_name: user_name,
            action: TypingAction.Typing,
            is_typing: false,
            timestamp: DateTime.now()
        }
    }
}

// =============================================================================
// Typing Indicator Actor
// =============================================================================

/// Typing indicator for a single conversation
actor TypingIndicator {
    state conversation_id: String
    state typing_users: Map<String, TypingStatus>
    state on_change: [fn([TypingStatus])]
    state cleanup_interval: Duration
    
    fn new(conversation_id: String) -> Self {
        let indicator = TypingIndicator {
            conversation_id: conversation_id,
            typing_users: Map.empty(),
            on_change: [],
            cleanup_interval: Duration.seconds(1)
        }
        indicator.start_cleanup()
        indicator
    }
    
    on start_typing(user_id: String, user_name: String, action: TypingAction) {
        let status = TypingStatus.new(user_id.clone(), user_name, action)
        self.typing_users.insert(user_id, status)
        self.notify_change()
    }
    
    on stop_typing(user_id: String) {
        if self.typing_users.remove(user_id).is_some() {
            self.notify_change()
        }
    }
    
    on refresh_typing(user_id: String) {
        if let Some(status) = self.typing_users.get(user_id) {
            status.refresh()
        }
    }
    
    on get_typing_users() -> [TypingStatus] {
        self.typing_users.values()
            .filter(|s| !s.is_expired())
            .cloned()
            .collect()
    }
    
    on is_anyone_typing() -> Bool {
        self.typing_users.values().any(|s| !s.is_expired())
    }
    
    on typing_count() -> Int {
        self.typing_users.values().filter(|s| !s.is_expired()).count()
    }
    
    on get_display_text(exclude_user: Option<String>) -> Option<String> {
        let typing = self.typing_users.values()
            .filter(|s| !s.is_expired())
            .filter(|s| exclude_user.map(|u| s.user_id != u).unwrap_or(true))
            .collect::<Vec<_>>()
        
        if typing.is_empty() {
            return None
        }
        
        let text = match typing.len() {
            1 => typing[0].display(),
            2 => "\(typing[0].user_name) and \(typing[1].user_name) are typing",
            _ => {
                let first_two = typing[0..2].iter().map(|s| s.user_name.clone()).join(", ")
                let remaining = typing.len() - 2
                "\(first_two) and \(remaining) others are typing"
            }
        }
        
        Some(text)
    }
    
    fn notify_change() {
        let current = self.get_typing_users()
        for handler in self.on_change {
            handler(current.clone())
        }
    }
    
    fn start_cleanup() {
        @native("set_interval", self.cleanup_interval.as_millis(), || {
            self.cleanup_expired()
        })
    }
    
    fn cleanup_expired() {
        let before_count = self.typing_users.len()
        self.typing_users.retain(|_, status| !status.is_expired())
        
        if self.typing_users.len() != before_count {
            self.notify_change()
        }
    }
    
    fn on_typing_change(handler: fn([TypingStatus])) {
        self.on_change.push(handler)
    }
}

// =============================================================================
// Typing Manager Actor
// =============================================================================

/// Global typing manager across all conversations
actor TypingManager {
    state indicators: Map<String, TypingIndicator>
    state user_typing_in: Map<String, String>  // user_id -> conversation_id
    state on_event: [fn(TypingEvent)]
    state debounce_ms: Int
    state last_sent: Map<String, DateTime>
    
    fn new() -> Self {
        TypingManager {
            indicators: Map.empty(),
            user_typing_in: Map.empty(),
            on_event: [],
            debounce_ms: 500,
            last_sent: Map.empty()
        }
    }
    
    on get_or_create_indicator(conversation_id: String) -> TypingIndicator {
        if let Some(indicator) = self.indicators.get(conversation_id) {
            indicator.clone()
        } else {
            let indicator = TypingIndicator.new(conversation_id.clone())
            self.indicators.insert(conversation_id, indicator.clone())
            indicator
        }
    }
    
    on start_typing(conversation_id: String, user_id: String, user_name: String, action: TypingAction) {
        // Check debounce
        let key = "\(conversation_id):\(user_id)"
        if let Some(last) = self.last_sent.get(key) {
            let elapsed = (DateTime.now() - last).as_millis()
            if elapsed < self.debounce_ms {
                return
            }
        }
        self.last_sent.insert(key, DateTime.now())
        
        // Stop typing in previous conversation if any
        if let Some(prev_conv) = self.user_typing_in.get(user_id) {
            if prev_conv != conversation_id {
                self.stop_typing(prev_conv.clone(), user_id.clone())
            }
        }
        
        // Start typing in new conversation
        let indicator = self.get_or_create_indicator(conversation_id.clone())
        indicator.start_typing(user_id.clone(), user_name.clone(), action)
        self.user_typing_in.insert(user_id.clone(), conversation_id.clone())
        
        // Emit event
        let event = TypingEvent.started(conversation_id, user_id, user_name, action)
        self.emit_event(event)
    }
    
    on stop_typing(conversation_id: String, user_id: String) {
        if let Some(indicator) = self.indicators.get(conversation_id) {
            indicator.stop_typing(user_id.clone())
        }
        self.user_typing_in.remove(user_id.clone())
        
        // Emit event
        let event = TypingEvent.stopped(conversation_id, user_id.clone(), "")
        self.emit_event(event)
    }
    
    on stop_all_typing(user_id: String) {
        if let Some(conv_id) = self.user_typing_in.remove(user_id.clone()) {
            if let Some(indicator) = self.indicators.get(conv_id) {
                indicator.stop_typing(user_id)
            }
        }
    }
    
    on get_typing_users(conversation_id: String) -> [TypingStatus] {
        self.indicators.get(conversation_id)
            .map(|i| i.get_typing_users())
            .unwrap_or([])
    }
    
    on is_typing(conversation_id: String, user_id: String) -> Bool {
        self.indicators.get(conversation_id)
            .map(|i| i.get_typing_users().iter().any(|s| s.user_id == user_id))
            .unwrap_or(false)
    }
    
    on get_display_text(conversation_id: String, exclude_user: Option<String>) -> Option<String> {
        self.indicators.get(conversation_id)
            .and_then(|i| i.get_display_text(exclude_user))
    }
    
    fn emit_event(event: TypingEvent) {
        for handler in self.on_event {
            handler(event.clone())
        }
    }
    
    fn on_typing_event(handler: fn(TypingEvent)) {
        self.on_event.push(handler)
    }
    
    fn set_debounce(ms: Int) {
        self.debounce_ms = ms
    }
}

// =============================================================================
// Typing Animation
// =============================================================================

/// Typing animation state for UI
struct TypingAnimation {
    dots: Int,
    max_dots: Int,
    interval_ms: Int,
    is_running: Bool
}

impl TypingAnimation {
    fn new() -> Self {
        TypingAnimation {
            dots: 0,
            max_dots: 3,
            interval_ms: 400,
            is_running: false
        }
    }
    
    fn start() {
        self.is_running = true
        self.dots = 0
    }
    
    fn stop() {
        self.is_running = false
        self.dots = 0
    }
    
    fn tick() {
        if self.is_running {
            self.dots = (self.dots + 1) % (self.max_dots + 1)
        }
    }
    
    fn display() -> String {
        ".".repeat(self.dots)
    }
    
    fn display_with_text(text: String) -> String {
        text + self.display()
    }
}

/// Animated typing indicator component
actor TypingAnimationController {
    state animation: TypingAnimation
    state text: String
    state on_update: [fn(String)]
    state timer_id: Option<Int>
    
    fn new() -> Self {
        TypingAnimationController {
            animation: TypingAnimation.new(),
            text: "typing",
            on_update: [],
            timer_id: None
        }
    }
    
    on start(text: String) {
        self.text = text
        self.animation.start()
        
        self.timer_id = Some(@native("set_interval", self.animation.interval_ms, || {
            self.tick()
        }))
    }
    
    on stop() {
        self.animation.stop()
        if let Some(id) = self.timer_id {
            @native("clear_interval", id)
            self.timer_id = None
        }
        self.notify("")
    }
    
    fn tick() {
        self.animation.tick()
        self.notify(self.animation.display_with_text(self.text))
    }
    
    fn notify(text: String) {
        for handler in self.on_update {
            handler(text)
        }
    }
    
    fn on_animation_update(handler: fn(String)) {
        self.on_update.push(handler)
    }
}

// =============================================================================
// Typing Throttler
// =============================================================================

/// Throttle typing events to reduce network traffic
struct TypingThrottler {
    last_sent: Option<DateTime>,
    min_interval: Duration,
    pending: Bool
}

impl TypingThrottler {
    fn new(min_interval: Duration) -> Self {
        TypingThrottler {
            last_sent: None,
            min_interval: min_interval,
            pending: false
        }
    }
    
    fn default() -> Self {
        Self.new(Duration.seconds(3))
    }
    
    fn should_send() -> Bool {
        match self.last_sent {
            Some(last) => {
                let elapsed = DateTime.now() - last
                elapsed >= self.min_interval
            },
            None => true
        }
    }
    
    fn mark_sent() {
        self.last_sent = Some(DateTime.now())
        self.pending = false
    }
    
    fn mark_pending() {
        self.pending = true
    }
    
    fn has_pending() -> Bool {
        self.pending
    }
    
    fn reset() {
        self.last_sent = None
        self.pending = false
    }
}

// =============================================================================
// Typing Input Handler
// =============================================================================

/// Handle typing input and emit events
actor TypingInputHandler {
    state conversation_id: String
    state user_id: String
    state user_name: String
    state manager: TypingManager
    state throttler: TypingThrottler
    state stop_timer: Option<Int>
    state stop_delay: Duration
    
    fn new(conv_id: String, user_id: String, user_name: String, manager: TypingManager) -> Self {
        TypingInputHandler {
            conversation_id: conv_id,
            user_id: user_id,
            user_name: user_name,
            manager: manager,
            throttler: TypingThrottler.default(),
            stop_timer: None,
            stop_delay: Duration.seconds(3)
        }
    }
    
    on on_input() {
        // Cancel stop timer
        if let Some(timer) = self.stop_timer {
            @native("clear_timeout", timer)
            self.stop_timer = None
        }
        
        // Send typing if throttle allows
        if self.throttler.should_send() {
            self.manager.start_typing(
                self.conversation_id.clone(),
                self.user_id.clone(),
                self.user_name.clone(),
                TypingAction.Typing
            )
            self.throttler.mark_sent()
        } else {
            self.throttler.mark_pending()
        }
        
        // Set stop timer
        self.stop_timer = Some(@native("set_timeout", self.stop_delay.as_millis(), || {
            self.on_stop()
        }))
    }
    
    on on_stop() {
        self.manager.stop_typing(self.conversation_id.clone(), self.user_id.clone())
        self.throttler.reset()
        self.stop_timer = None
    }
    
    on on_send() {
        // Message sent, stop typing immediately
        self.on_stop()
    }
    
    on on_blur() {
        // Input lost focus, stop typing
        self.on_stop()
    }
}

// =============================================================================
// Tests
// =============================================================================

test "typing action" {
    assert_eq(TypingAction.Typing.display_text(), "typing")?
    assert_eq(TypingAction.RecordingVoice.icon(), "üé§")?
}

test "typing status" {
    let status = TypingStatus.new("user1", "Alice", TypingAction.Typing)
    assert(!status.is_expired())?
    assert_eq(status.display(), "‚úçÔ∏è Alice is typing")?
}

test "typing indicator" {
    let indicator = TypingIndicator.new("conv1")
    
    indicator.start_typing("user1", "Alice", TypingAction.Typing)
    indicator.start_typing("user2", "Bob", TypingAction.Typing)
    
    assert_eq(indicator.typing_count(), 2)?
    assert(indicator.is_anyone_typing())?
    
    indicator.stop_typing("user1")
    assert_eq(indicator.typing_count(), 1)?
}

test "typing display text" {
    let indicator = TypingIndicator.new("conv1")
    
    indicator.start_typing("user1", "Alice", TypingAction.Typing)
    let text = indicator.get_display_text(None)
    assert_eq(text, Some("‚úçÔ∏è Alice is typing"))?
    
    indicator.start_typing("user2", "Bob", TypingAction.Typing)
    let text2 = indicator.get_display_text(None)
    assert_eq(text2, Some("Alice and Bob are typing"))?
}

test "typing manager" {
    let manager = TypingManager.new()
    
    manager.start_typing("conv1", "user1", "Alice", TypingAction.Typing)
    assert(manager.is_typing("conv1", "user1"))?
    
    manager.stop_typing("conv1", "user1")
    assert(!manager.is_typing("conv1", "user1"))?
}

test "typing animation" {
    var anim = TypingAnimation.new()
    anim.start()
    
    assert_eq(anim.display(), "")?
    anim.tick()
    assert_eq(anim.display(), ".")?
    anim.tick()
    assert_eq(anim.display(), "..")?
    anim.tick()
    assert_eq(anim.display(), "...")?
    anim.tick()
    assert_eq(anim.display(), "")?  // Wraps around
}

test "typing throttler" {
    var throttler = TypingThrottler.new(Duration.seconds(1))
    
    assert(throttler.should_send())?
    throttler.mark_sent()
    assert(!throttler.should_send())?  // Too soon
    
    // After waiting, should be able to send again
    throttler.reset()
    assert(throttler.should_send())?
}

test "typing event" {
    let event = TypingEvent.started("conv1", "user1", "Alice", TypingAction.Typing)
    assert(event.is_typing)?
    assert_eq(event.action, TypingAction.Typing)?
    
    let stop_event = TypingEvent.stopped("conv1", "user1", "Alice")
    assert(!stop_event.is_typing)?
}
