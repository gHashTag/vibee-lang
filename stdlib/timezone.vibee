// =============================================================================
// Vibee OS â€” Timezone Module
// Timezone handling and conversions
// =============================================================================

// -----------------------------------------------------------------------------
// Timezone
// -----------------------------------------------------------------------------

/// Timezone representation
struct Timezone {
    name: String
    rules: [TimezoneRule]
    
    /// UTC timezone
    fn utc() -> Self {
        Timezone { name: "UTC", rules: [TimezoneRule.fixed(0)] }
    }
    
    /// Local system timezone
    fn local() -> Self {
        let name = @native("timezone_local_name")
        Self.from_name(name).unwrap_or(Self.utc())
    }
    
    /// Create from IANA timezone name
    fn from_name(name: String) -> Option<Self> {
        TIMEZONE_DB.get(name)
    }
    
    /// Create fixed offset timezone
    fn fixed(offset_minutes: Int) -> Self {
        let sign = if offset_minutes >= 0 { "+" } else { "-" }
        let h = offset_minutes.abs() / 60
        let m = offset_minutes.abs() % 60
        let name = format!("UTC{}{:02}:{:02}", sign, h, m)
        Timezone { name: name, rules: [TimezoneRule.fixed(offset_minutes)] }
    }
    
    /// Create from offset string (e.g., "+05:30", "-08:00")
    fn from_offset_string(s: String) -> Option<Self> {
        let offset = parse_offset(s)?
        Some(Self.fixed(offset))
    }
    
    /// Get offset at specific datetime
    fn offset_at(dt: DateTime) -> Int {
        for rule in self.rules.rev() {
            if rule.applies_at(dt) {
                return rule.offset
            }
        }
        0
    }
    
    /// Get current offset
    fn current_offset() -> Int {
        self.offset_at(DateTime.now())
    }
    
    /// Check if DST is active at datetime
    fn is_dst_at(dt: DateTime) -> Bool {
        for rule in self.rules.rev() {
            if rule.applies_at(dt) {
                return rule.is_dst
            }
        }
        false
    }
    
    /// Get abbreviation at datetime (e.g., "PST", "PDT")
    fn abbreviation_at(dt: DateTime) -> String {
        for rule in self.rules.rev() {
            if rule.applies_at(dt) {
                return rule.abbreviation
            }
        }
        self.name
    }
    
    /// Convert datetime to this timezone
    fn convert(dt: DateTime) -> DateTime {
        dt.to_timezone(self)
    }
    
    /// Get all transitions in a year
    fn transitions_in_year(year: Int) -> [TimezoneTransition] {
        var transitions = []
        let start = DateTime.new(year, 1, 1)
        let end = DateTime.new(year + 1, 1, 1)
        
        var prev_offset = self.offset_at(start)
        var current = start
        
        while current < end {
            let next = current + Duration.hours(1)
            let offset = self.offset_at(next)
            
            if offset != prev_offset {
                transitions.append(TimezoneTransition {
                    datetime: next,
                    from_offset: prev_offset,
                    to_offset: offset,
                    is_dst: self.is_dst_at(next)
                })
            }
            
            prev_offset = offset
            current = next
        }
        
        transitions
    }
}

/// Timezone rule
struct TimezoneRule {
    offset: Int           // Offset from UTC in minutes
    is_dst: Bool          // Is daylight saving time
    abbreviation: String  // e.g., "PST", "PDT"
    start: Option<DateTime>
    end: Option<DateTime>
    
    fn fixed(offset: Int) -> Self {
        let sign = if offset >= 0 { "+" } else { "-" }
        let abbr = format!("UTC{}{}", sign, offset.abs() / 60)
        TimezoneRule {
            offset: offset,
            is_dst: false,
            abbreviation: abbr,
            start: None,
            end: None
        }
    }
    
    fn applies_at(dt: DateTime) -> Bool {
        let after_start = self.start.map(|s| dt >= s).unwrap_or(true)
        let before_end = self.end.map(|e| dt < e).unwrap_or(true)
        after_start && before_end
    }
}

/// Timezone transition
struct TimezoneTransition {
    datetime: DateTime
    from_offset: Int
    to_offset: Int
    is_dst: Bool
}

// -----------------------------------------------------------------------------
// Common Timezones
// -----------------------------------------------------------------------------

module Timezones {
    fn UTC() -> Timezone { Timezone.utc() }
    
    // Americas
    fn America_New_York() -> Timezone { Timezone.from_name("America/New_York").unwrap() }
    fn America_Los_Angeles() -> Timezone { Timezone.from_name("America/Los_Angeles").unwrap() }
    fn America_Chicago() -> Timezone { Timezone.from_name("America/Chicago").unwrap() }
    fn America_Denver() -> Timezone { Timezone.from_name("America/Denver").unwrap() }
    fn America_Toronto() -> Timezone { Timezone.from_name("America/Toronto").unwrap() }
    fn America_Vancouver() -> Timezone { Timezone.from_name("America/Vancouver").unwrap() }
    fn America_Sao_Paulo() -> Timezone { Timezone.from_name("America/Sao_Paulo").unwrap() }
    fn America_Mexico_City() -> Timezone { Timezone.from_name("America/Mexico_City").unwrap() }
    
    // Europe
    fn Europe_London() -> Timezone { Timezone.from_name("Europe/London").unwrap() }
    fn Europe_Paris() -> Timezone { Timezone.from_name("Europe/Paris").unwrap() }
    fn Europe_Berlin() -> Timezone { Timezone.from_name("Europe/Berlin").unwrap() }
    fn Europe_Moscow() -> Timezone { Timezone.from_name("Europe/Moscow").unwrap() }
    fn Europe_Rome() -> Timezone { Timezone.from_name("Europe/Rome").unwrap() }
    fn Europe_Madrid() -> Timezone { Timezone.from_name("Europe/Madrid").unwrap() }
    fn Europe_Amsterdam() -> Timezone { Timezone.from_name("Europe/Amsterdam").unwrap() }
    
    // Asia
    fn Asia_Tokyo() -> Timezone { Timezone.from_name("Asia/Tokyo").unwrap() }
    fn Asia_Shanghai() -> Timezone { Timezone.from_name("Asia/Shanghai").unwrap() }
    fn Asia_Hong_Kong() -> Timezone { Timezone.from_name("Asia/Hong_Kong").unwrap() }
    fn Asia_Singapore() -> Timezone { Timezone.from_name("Asia/Singapore").unwrap() }
    fn Asia_Seoul() -> Timezone { Timezone.from_name("Asia/Seoul").unwrap() }
    fn Asia_Dubai() -> Timezone { Timezone.from_name("Asia/Dubai").unwrap() }
    fn Asia_Kolkata() -> Timezone { Timezone.from_name("Asia/Kolkata").unwrap() }
    fn Asia_Bangkok() -> Timezone { Timezone.from_name("Asia/Bangkok").unwrap() }
    
    // Pacific
    fn Pacific_Auckland() -> Timezone { Timezone.from_name("Pacific/Auckland").unwrap() }
    fn Pacific_Sydney() -> Timezone { Timezone.from_name("Australia/Sydney").unwrap() }
    fn Pacific_Honolulu() -> Timezone { Timezone.from_name("Pacific/Honolulu").unwrap() }
    
    // Africa
    fn Africa_Cairo() -> Timezone { Timezone.from_name("Africa/Cairo").unwrap() }
    fn Africa_Johannesburg() -> Timezone { Timezone.from_name("Africa/Johannesburg").unwrap() }
    fn Africa_Lagos() -> Timezone { Timezone.from_name("Africa/Lagos").unwrap() }
}

// -----------------------------------------------------------------------------
// Timezone Database
// -----------------------------------------------------------------------------

/// Timezone database
actor TimezoneDB {
    state zones: Map<String, Timezone>
    
    fn new() -> Self {
        let db = TimezoneDB { zones: Map.empty() }
        db.load_builtin()
        db
    }
    
    fn load_builtin() {
        // Load common timezones with their rules
        self.add_zone("UTC", 0, false)
        
        // US timezones with DST
        self.add_zone_with_dst("America/New_York", -300, -240, "EST", "EDT")
        self.add_zone_with_dst("America/Chicago", -360, -300, "CST", "CDT")
        self.add_zone_with_dst("America/Denver", -420, -360, "MST", "MDT")
        self.add_zone_with_dst("America/Los_Angeles", -480, -420, "PST", "PDT")
        
        // Europe with DST
        self.add_zone_with_dst("Europe/London", 0, 60, "GMT", "BST")
        self.add_zone_with_dst("Europe/Paris", 60, 120, "CET", "CEST")
        self.add_zone_with_dst("Europe/Berlin", 60, 120, "CET", "CEST")
        
        // Fixed offset zones
        self.add_zone("Europe/Moscow", 180, false)
        self.add_zone("Asia/Tokyo", 540, false)
        self.add_zone("Asia/Shanghai", 480, false)
        self.add_zone("Asia/Singapore", 480, false)
        self.add_zone("Asia/Dubai", 240, false)
        self.add_zone("Asia/Kolkata", 330, false)
        self.add_zone("Australia/Sydney", 600, true)  // Has DST
        self.add_zone("Pacific/Auckland", 720, true)  // Has DST
    }
    
    fn add_zone(name: String, offset: Int, has_dst: Bool) {
        let rules = [TimezoneRule {
            offset: offset,
            is_dst: false,
            abbreviation: name.split("/").last().unwrap_or(name),
            start: None,
            end: None
        }]
        self.zones.set(name, Timezone { name: name, rules: rules })
    }
    
    fn add_zone_with_dst(name: String, std_offset: Int, dst_offset: Int, std_abbr: String, dst_abbr: String) {
        // Simplified DST rules (US-style: 2nd Sunday March, 1st Sunday November)
        let rules = [
            TimezoneRule { offset: std_offset, is_dst: false, abbreviation: std_abbr, start: None, end: None },
            TimezoneRule { offset: dst_offset, is_dst: true, abbreviation: dst_abbr, start: None, end: None }
        ]
        self.zones.set(name, Timezone { name: name, rules: rules })
    }
    
    fn get(name: String) -> Option<Timezone> {
        self.zones.get(name)
    }
    
    fn list() -> [String] {
        self.zones.keys().sorted()
    }
    
    fn search(query: String) -> [String] {
        self.zones.keys()
            .filter(|k| k.to_lower().contains(query.to_lower()))
            .sorted()
    }
}

var TIMEZONE_DB = TimezoneDB.new()

// -----------------------------------------------------------------------------
// Timezone Conversion Utilities
// -----------------------------------------------------------------------------

/// Convert between timezones
fn convert(dt: DateTime, from: Timezone, to: Timezone) -> DateTime {
    let utc = DateTime {
        timestamp: dt.timestamp - from.offset_at(dt) as Int64 * 60000,
        offset: 0
    }
    DateTime {
        timestamp: utc.timestamp,
        offset: to.offset_at(utc)
    }
}

/// Get current time in timezone
fn now_in(tz: Timezone) -> DateTime {
    DateTime.now().to_timezone(tz)
}

/// Format datetime with timezone name
fn format_with_tz(dt: DateTime, tz: Timezone, pattern: String) -> String {
    let converted = dt.to_timezone(tz)
    let formatted = converted.format(pattern)
    let abbr = tz.abbreviation_at(converted)
    "\(formatted) \(abbr)"
}

// -----------------------------------------------------------------------------
// Offset Parsing
// -----------------------------------------------------------------------------

fn parse_offset(s: String) -> Option<Int> {
    let s = s.trim()
    if s == "Z" { return Some(0) }
    
    let sign = match s[0] {
        '+' => 1
        '-' => -1
        _ => return None
    }
    
    let rest = s[1..]
    let parts = rest.split(":")
    
    let hours = Int.parse(parts[0]).ok()?
    let minutes = parts.get(1).and_then(|m| Int.parse(m).ok()).unwrap_or(0)
    
    Some(sign * (hours * 60 + minutes))
}

// -----------------------------------------------------------------------------
// DST Utilities
// -----------------------------------------------------------------------------

/// Check if DST is currently active in timezone
fn is_dst_now(tz: Timezone) -> Bool {
    tz.is_dst_at(DateTime.now())
}

/// Get next DST transition
fn next_dst_transition(tz: Timezone) -> Option<TimezoneTransition> {
    let now = DateTime.now()
    let year = now.year()
    
    // Check current and next year
    for y in [year, year + 1] {
        for transition in tz.transitions_in_year(y) {
            if transition.datetime > now {
                return Some(transition)
            }
        }
    }
    None
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "utc timezone" {
    let tz = Timezone.utc()
    assert_eq(tz.current_offset(), 0)?
    assert_eq(tz.name, "UTC")?
}

test "fixed offset" {
    let tz = Timezone.fixed(330)  // UTC+5:30
    assert_eq(tz.current_offset(), 330)?
}

test "parse offset" {
    assert_eq(parse_offset("+05:30"), Some(330))?
    assert_eq(parse_offset("-08:00"), Some(-480))?
    assert_eq(parse_offset("Z"), Some(0))?
}

test "timezone conversion" {
    let utc = Timezone.utc()
    let tokyo = Timezone.fixed(540)  // UTC+9
    
    let dt_utc = DateTime.new(2024, 1, 1, 12, 0, 0)
    let dt_tokyo = convert(dt_utc, utc, tokyo)
    
    assert_eq(dt_tokyo.hour(), 21)?
}
