// =============================================================================
// Vibee OS â€” Path Module
// File path manipulation
// =============================================================================

/// File path
struct Path {
    raw: String
    
    /// Create from string
    fn new(s: String) -> Self {
        Path { raw: s }
    }
    
    /// Current directory
    fn cwd() -> Self {
        Path { raw: @native("getcwd") }
    }
    
    /// Home directory
    fn home() -> Self {
        Path { raw: @native("home_dir") }
    }
    
    /// Temp directory
    fn temp() -> Self {
        Path { raw: @native("temp_dir") }
    }
    
    /// Join paths
    fn join(other: String) -> Self {
        if other.starts_with("/") {
            return Path { raw: other }
        }
        let sep = if self.raw.ends_with("/") { "" } else { "/" }
        Path { raw: format!("{}{}{}", self.raw, sep, other) }
    }
    
    /// Join multiple components
    fn join_all(parts: [String]) -> Self {
        var result = self
        for part in parts {
            result = result.join(part)
        }
        result
    }
    
    /// Get parent directory
    fn parent() -> Option<Self> {
        let idx = self.raw.rfind("/")?
        if idx == 0 {
            Some(Path { raw: "/" })
        } else {
            Some(Path { raw: self.raw[0..idx] })
        }
    }
    
    /// Get file name
    fn file_name() -> Option<String> {
        let idx = self.raw.rfind("/")?
        Some(self.raw[(idx + 1)..])
    }
    
    /// Get file stem (name without extension)
    fn file_stem() -> Option<String> {
        let name = self.file_name()?
        match name.rfind(".") {
            Some(idx) if idx > 0 => Some(name[0..idx])
            _ => Some(name)
        }
    }
    
    /// Get extension
    fn extension() -> Option<String> {
        let name = self.file_name()?
        let idx = name.rfind(".")?
        if idx == 0 { return None }
        Some(name[(idx + 1)..])
    }
    
    /// Set extension
    fn with_extension(ext: String) -> Self {
        let stem = self.file_stem().unwrap_or(self.raw)
        let parent = self.parent().map(|p| p.raw).unwrap_or("")
        let ext = ext.trim_start(".")
        if parent.is_empty() {
            Path { raw: format!("{}.{}", stem, ext) }
        } else {
            Path { raw: format!("{}/{}.{}", parent, stem, ext) }
        }
    }
    
    /// Set file name
    fn with_file_name(name: String) -> Self {
        match self.parent() {
            Some(p) => p.join(name)
            None => Path { raw: name }
        }
    }
    
    /// Check if absolute
    fn is_absolute() -> Bool {
        self.raw.starts_with("/")
    }
    
    /// Check if relative
    fn is_relative() -> Bool {
        !self.is_absolute()
    }
    
    /// Convert to absolute
    fn to_absolute() -> Self {
        if self.is_absolute() {
            self
        } else {
            Path.cwd().join(self.raw)
        }
    }
    
    /// Normalize path (resolve . and ..)
    fn normalize() -> Self {
        let parts = self.raw.split("/").filter(|s| !s.is_empty() && s != ".")
        var stack = []
        
        for part in parts {
            if part == ".." {
                if !stack.is_empty() && stack.last() != Some("..") {
                    stack.pop()
                } else if self.is_relative() {
                    stack.push(part)
                }
            } else {
                stack.push(part)
            }
        }
        
        let result = stack.join("/")
        if self.is_absolute() {
            Path { raw: format!("/{}", result) }
        } else if result.is_empty() {
            Path { raw: "." }
        } else {
            Path { raw: result }
        }
    }
    
    /// Get relative path from base
    fn relative_to(base: Path) -> Option<Self> {
        let self_parts = self.normalize().raw.split("/").filter(|s| !s.is_empty()).collect::<Vec<_>>()
        let base_parts = base.normalize().raw.split("/").filter(|s| !s.is_empty()).collect::<Vec<_>>()
        
        // Find common prefix
        var common = 0
        while common < self_parts.len() && common < base_parts.len() {
            if self_parts[common] != base_parts[common] {
                break
            }
            common += 1
        }
        
        // Build relative path
        var parts = []
        for _ in common..base_parts.len() {
            parts.push("..")
        }
        for i in common..self_parts.len() {
            parts.push(self_parts[i])
        }
        
        if parts.is_empty() {
            Some(Path { raw: "." })
        } else {
            Some(Path { raw: parts.join("/") })
        }
    }
    
    /// Get components
    fn components() -> [PathComponent] {
        var result = []
        
        if self.raw.starts_with("/") {
            result.push(PathComponent.RootDir)
        }
        
        for part in self.raw.split("/").filter(|s| !s.is_empty()) {
            match part {
                "." => result.push(PathComponent.CurDir)
                ".." => result.push(PathComponent.ParentDir)
                _ => result.push(PathComponent.Normal(part))
            }
        }
        
        result
    }
    
    /// Iterate ancestors
    fn ancestors() -> [Path] {
        var result = [self]
        var current = self
        
        while let Some(parent) = current.parent() {
            result.push(parent)
            current = parent
        }
        
        result
    }
    
    /// Check if starts with prefix
    fn starts_with(prefix: Path) -> Bool {
        self.normalize().raw.starts_with(prefix.normalize().raw)
    }
    
    /// Check if ends with suffix
    fn ends_with(suffix: String) -> Bool {
        self.raw.ends_with(suffix)
    }
    
    /// Check if path exists
    fn exists() -> Bool {
        @native("path_exists", self.raw)
    }
    
    /// Check if is file
    fn is_file() -> Bool {
        @native("is_file", self.raw)
    }
    
    /// Check if is directory
    fn is_dir() -> Bool {
        @native("is_dir", self.raw)
    }
    
    /// Check if is symlink
    fn is_symlink() -> Bool {
        @native("is_symlink", self.raw)
    }
    
    /// Get metadata
    fn metadata() -> Option<Metadata> {
        @native("path_metadata", self.raw)
    }
    
    /// Read directory entries
    fn read_dir() -> Result<[DirEntry], IoError> {
        @native("read_dir", self.raw)
    }
    
    /// Convert to string
    fn to_string() -> String {
        self.raw
    }
    
    /// Display path
    fn display() -> String {
        self.raw
    }
}

impl Display for Path {
    fn fmt(f: Formatter) {
        f.write(self.raw)
    }
}

impl Eq for Path {
    fn eq(other: Path) -> Bool {
        self.normalize().raw == other.normalize().raw
    }
}

/// Path component
enum PathComponent {
    RootDir
    CurDir
    ParentDir
    Normal(String)
}

/// Directory entry
struct DirEntry {
    path: Path
    name: String
    is_file: Bool
    is_dir: Bool
    is_symlink: Bool
}

/// File metadata
struct Metadata {
    size: Int64
    created: Option<DateTime>
    modified: Option<DateTime>
    accessed: Option<DateTime>
    is_readonly: Bool
    permissions: Int
}

// -----------------------------------------------------------------------------
// Path Builder
// -----------------------------------------------------------------------------

/// Fluent path builder
struct PathBuilder {
    parts: [String]
    
    fn new() -> Self {
        PathBuilder { parts: [] }
    }
    
    fn from(base: String) -> Self {
        PathBuilder { parts: [base] }
    }
    
    fn push(part: String) -> Self {
        self.parts.push(part)
        self
    }
    
    fn pop() -> Self {
        self.parts.pop()
        self
    }
    
    fn build() -> Path {
        Path { raw: self.parts.join("/") }
    }
}

// -----------------------------------------------------------------------------
// Utility Functions
// -----------------------------------------------------------------------------

/// Join paths
fn join(base: String, parts: [String]) -> String {
    Path.new(base).join_all(parts).to_string()
}

/// Get file extension
fn extname(path: String) -> Option<String> {
    Path.new(path).extension()
}

/// Get directory name
fn dirname(path: String) -> Option<String> {
    Path.new(path).parent().map(|p| p.to_string())
}

/// Get base name
fn basename(path: String) -> Option<String> {
    Path.new(path).file_name()
}

/// Get base name without extension
fn stem(path: String) -> Option<String> {
    Path.new(path).file_stem()
}

/// Normalize path
fn normalize(path: String) -> String {
    Path.new(path).normalize().to_string()
}

/// Check if absolute
fn is_absolute(path: String) -> Bool {
    Path.new(path).is_absolute()
}

/// Resolve path (normalize + make absolute)
fn resolve(path: String) -> String {
    Path.new(path).to_absolute().normalize().to_string()
}

/// Get relative path
fn relative(from: String, to: String) -> Option<String> {
    Path.new(to).relative_to(Path.new(from)).map(|p| p.to_string())
}

// -----------------------------------------------------------------------------
// Platform-specific
// -----------------------------------------------------------------------------

module posix {
    const SEPARATOR: String = "/"
    const DELIMITER: String = ":"
    
    fn is_absolute(path: String) -> Bool {
        path.starts_with("/")
    }
}

module windows {
    const SEPARATOR: String = "\\"
    const DELIMITER: String = ";"
    
    fn is_absolute(path: String) -> Bool {
        // C:\ or \\server
        (path.len() >= 3 && path[1..2] == ":" && (path[2..3] == "\\" || path[2..3] == "/")) ||
        path.starts_with("\\\\")
    }
    
    fn to_posix(path: String) -> String {
        path.replace("\\", "/")
    }
    
    fn from_posix(path: String) -> String {
        path.replace("/", "\\")
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "join" {
    let p = Path.new("/home/user").join("documents").join("file.txt")
    assert_eq(p.to_string(), "/home/user/documents/file.txt")?
}

test "parent" {
    let p = Path.new("/home/user/file.txt")
    assert_eq(p.parent()?.to_string(), "/home/user")?
}

test "file_name" {
    let p = Path.new("/home/user/file.txt")
    assert_eq(p.file_name(), Some("file.txt"))?
}

test "extension" {
    let p = Path.new("/home/user/file.txt")
    assert_eq(p.extension(), Some("txt"))?
    
    let p2 = Path.new("/home/user/.gitignore")
    assert_eq(p2.extension(), Some("gitignore"))?
}

test "file_stem" {
    let p = Path.new("/home/user/file.txt")
    assert_eq(p.file_stem(), Some("file"))?
}

test "with_extension" {
    let p = Path.new("/home/user/file.txt")
    assert_eq(p.with_extension("md").to_string(), "/home/user/file.md")?
}

test "normalize" {
    let p = Path.new("/home/user/../user/./documents")
    assert_eq(p.normalize().to_string(), "/home/user/documents")?
}

test "relative_to" {
    let p = Path.new("/home/user/documents/file.txt")
    let base = Path.new("/home/user")
    assert_eq(p.relative_to(base)?.to_string(), "documents/file.txt")?
}

test "components" {
    let p = Path.new("/home/user/file.txt")
    let comps = p.components()
    assert_eq(comps.len(), 4)?
    assert_eq(comps[0], PathComponent.RootDir)?
}

test "is_absolute" {
    assert(Path.new("/home/user").is_absolute())?
    assert(!Path.new("home/user").is_absolute())?
}
