// =============================================================================
// Vibee OS â€” Theme Module
// Theming, styling, and design tokens
// =============================================================================

use color::{RGB, RGBA, HSL}
use component::{TextStyle, FontWeight, EdgeInsets, Border, Shadow}

// -----------------------------------------------------------------------------
// Theme Data
// -----------------------------------------------------------------------------

/// Complete theme configuration
struct Theme {
    colors: ColorScheme
    typography: Typography
    spacing: Spacing
    radius: RadiusScale
    shadows: ShadowScale
    breakpoints: Breakpoints
    transitions: TransitionConfig
    
    fn light() -> Self {
        Theme {
            colors: ColorScheme.light(),
            typography: Typography.default(),
            spacing: Spacing.default(),
            radius: RadiusScale.default(),
            shadows: ShadowScale.default(),
            breakpoints: Breakpoints.default(),
            transitions: TransitionConfig.default()
        }
    }
    
    fn dark() -> Self {
        Theme {
            colors: ColorScheme.dark(),
            typography: Typography.default(),
            spacing: Spacing.default(),
            radius: RadiusScale.default(),
            shadows: ShadowScale.dark(),
            breakpoints: Breakpoints.default(),
            transitions: TransitionConfig.default()
        }
    }
    
    fn custom(colors: ColorScheme) -> Self {
        var theme = Theme.light()
        theme.colors = colors
        theme
    }
}

// -----------------------------------------------------------------------------
// Color Scheme
// -----------------------------------------------------------------------------

/// Color palette for theming
struct ColorScheme {
    // Primary colors
    primary: RGBA
    primary_light: RGBA
    primary_dark: RGBA
    on_primary: RGBA
    
    // Secondary colors
    secondary: RGBA
    secondary_light: RGBA
    secondary_dark: RGBA
    on_secondary: RGBA
    
    // Background colors
    background: RGBA
    surface: RGBA
    on_background: RGBA
    on_surface: RGBA
    
    // Semantic colors
    error: RGBA
    on_error: RGBA
    warning: RGBA
    on_warning: RGBA
    success: RGBA
    on_success: RGBA
    info: RGBA
    on_info: RGBA
    
    // Text colors
    text_primary: RGBA
    text_secondary: RGBA
    text_disabled: RGBA
    text_hint: RGBA
    
    // Border and divider
    border: RGBA
    divider: RGBA
    
    // Overlay
    overlay: RGBA
    scrim: RGBA
    
    fn light() -> Self {
        ColorScheme {
            primary: RGBA.new(59, 130, 246, 1.0),
            primary_light: RGBA.new(96, 165, 250, 1.0),
            primary_dark: RGBA.new(29, 78, 216, 1.0),
            on_primary: RGBA.new(255, 255, 255, 1.0),
            
            secondary: RGBA.new(139, 92, 246, 1.0),
            secondary_light: RGBA.new(167, 139, 250, 1.0),
            secondary_dark: RGBA.new(109, 40, 217, 1.0),
            on_secondary: RGBA.new(255, 255, 255, 1.0),
            
            background: RGBA.new(255, 255, 255, 1.0),
            surface: RGBA.new(249, 250, 251, 1.0),
            on_background: RGBA.new(17, 24, 39, 1.0),
            on_surface: RGBA.new(31, 41, 55, 1.0),
            
            error: RGBA.new(239, 68, 68, 1.0),
            on_error: RGBA.new(255, 255, 255, 1.0),
            warning: RGBA.new(245, 158, 11, 1.0),
            on_warning: RGBA.new(255, 255, 255, 1.0),
            success: RGBA.new(34, 197, 94, 1.0),
            on_success: RGBA.new(255, 255, 255, 1.0),
            info: RGBA.new(59, 130, 246, 1.0),
            on_info: RGBA.new(255, 255, 255, 1.0),
            
            text_primary: RGBA.new(17, 24, 39, 1.0),
            text_secondary: RGBA.new(107, 114, 128, 1.0),
            text_disabled: RGBA.new(156, 163, 175, 1.0),
            text_hint: RGBA.new(156, 163, 175, 1.0),
            
            border: RGBA.new(229, 231, 235, 1.0),
            divider: RGBA.new(229, 231, 235, 1.0),
            
            overlay: RGBA.new(0, 0, 0, 0.5),
            scrim: RGBA.new(0, 0, 0, 0.32)
        }
    }
    
    fn dark() -> Self {
        ColorScheme {
            primary: RGBA.new(96, 165, 250, 1.0),
            primary_light: RGBA.new(147, 197, 253, 1.0),
            primary_dark: RGBA.new(59, 130, 246, 1.0),
            on_primary: RGBA.new(17, 24, 39, 1.0),
            
            secondary: RGBA.new(167, 139, 250, 1.0),
            secondary_light: RGBA.new(196, 181, 253, 1.0),
            secondary_dark: RGBA.new(139, 92, 246, 1.0),
            on_secondary: RGBA.new(17, 24, 39, 1.0),
            
            background: RGBA.new(17, 24, 39, 1.0),
            surface: RGBA.new(31, 41, 55, 1.0),
            on_background: RGBA.new(243, 244, 246, 1.0),
            on_surface: RGBA.new(229, 231, 235, 1.0),
            
            error: RGBA.new(248, 113, 113, 1.0),
            on_error: RGBA.new(17, 24, 39, 1.0),
            warning: RGBA.new(251, 191, 36, 1.0),
            on_warning: RGBA.new(17, 24, 39, 1.0),
            success: RGBA.new(74, 222, 128, 1.0),
            on_success: RGBA.new(17, 24, 39, 1.0),
            info: RGBA.new(96, 165, 250, 1.0),
            on_info: RGBA.new(17, 24, 39, 1.0),
            
            text_primary: RGBA.new(243, 244, 246, 1.0),
            text_secondary: RGBA.new(156, 163, 175, 1.0),
            text_disabled: RGBA.new(107, 114, 128, 1.0),
            text_hint: RGBA.new(107, 114, 128, 1.0),
            
            border: RGBA.new(55, 65, 81, 1.0),
            divider: RGBA.new(55, 65, 81, 1.0),
            
            overlay: RGBA.new(0, 0, 0, 0.7),
            scrim: RGBA.new(0, 0, 0, 0.5)
        }
    }
    
    fn from_seed(seed: RGBA) -> Self {
        let hsl = seed.to_rgb().to_hsl()
        var scheme = ColorScheme.light()
        scheme.primary = seed
        scheme.primary_light = hsl.lighten(0.15).to_rgb().to_rgba(1.0)
        scheme.primary_dark = hsl.darken(0.15).to_rgb().to_rgba(1.0)
        scheme
    }
}

// -----------------------------------------------------------------------------
// Typography
// -----------------------------------------------------------------------------

/// Typography scale
struct Typography {
    display_large: TextStyle
    display_medium: TextStyle
    display_small: TextStyle
    headline_large: TextStyle
    headline_medium: TextStyle
    headline_small: TextStyle
    title_large: TextStyle
    title_medium: TextStyle
    title_small: TextStyle
    body_large: TextStyle
    body_medium: TextStyle
    body_small: TextStyle
    label_large: TextStyle
    label_medium: TextStyle
    label_small: TextStyle
    
    fn default() -> Self {
        let base_family = "system-ui"
        let base_color = RGBA.new(17, 24, 39, 1.0)
        
        Typography {
            display_large: TextStyle { font_family: base_family, font_size: 57.0, font_weight: FontWeight.Normal, color: base_color },
            display_medium: TextStyle { font_family: base_family, font_size: 45.0, font_weight: FontWeight.Normal, color: base_color },
            display_small: TextStyle { font_family: base_family, font_size: 36.0, font_weight: FontWeight.Normal, color: base_color },
            headline_large: TextStyle { font_family: base_family, font_size: 32.0, font_weight: FontWeight.Normal, color: base_color },
            headline_medium: TextStyle { font_family: base_family, font_size: 28.0, font_weight: FontWeight.Normal, color: base_color },
            headline_small: TextStyle { font_family: base_family, font_size: 24.0, font_weight: FontWeight.Normal, color: base_color },
            title_large: TextStyle { font_family: base_family, font_size: 22.0, font_weight: FontWeight.Medium, color: base_color },
            title_medium: TextStyle { font_family: base_family, font_size: 16.0, font_weight: FontWeight.Medium, color: base_color },
            title_small: TextStyle { font_family: base_family, font_size: 14.0, font_weight: FontWeight.Medium, color: base_color },
            body_large: TextStyle { font_family: base_family, font_size: 16.0, font_weight: FontWeight.Normal, color: base_color },
            body_medium: TextStyle { font_family: base_family, font_size: 14.0, font_weight: FontWeight.Normal, color: base_color },
            body_small: TextStyle { font_family: base_family, font_size: 12.0, font_weight: FontWeight.Normal, color: base_color },
            label_large: TextStyle { font_family: base_family, font_size: 14.0, font_weight: FontWeight.Medium, color: base_color },
            label_medium: TextStyle { font_family: base_family, font_size: 12.0, font_weight: FontWeight.Medium, color: base_color },
            label_small: TextStyle { font_family: base_family, font_size: 11.0, font_weight: FontWeight.Medium, color: base_color }
        }
    }
    
    fn with_font(family: String) -> Self {
        var typo = Typography.default()
        typo.display_large.font_family = family
        typo.display_medium.font_family = family
        typo.display_small.font_family = family
        typo.headline_large.font_family = family
        typo.headline_medium.font_family = family
        typo.headline_small.font_family = family
        typo.title_large.font_family = family
        typo.title_medium.font_family = family
        typo.title_small.font_family = family
        typo.body_large.font_family = family
        typo.body_medium.font_family = family
        typo.body_small.font_family = family
        typo.label_large.font_family = family
        typo.label_medium.font_family = family
        typo.label_small.font_family = family
        typo
    }
}

// -----------------------------------------------------------------------------
// Spacing Scale
// -----------------------------------------------------------------------------

/// Spacing scale for consistent margins and padding
struct Spacing {
    xs: Float64    // 4
    sm: Float64    // 8
    md: Float64    // 16
    lg: Float64    // 24
    xl: Float64    // 32
    xxl: Float64   // 48
    xxxl: Float64  // 64
    
    fn default() -> Self {
        Spacing { xs: 4.0, sm: 8.0, md: 16.0, lg: 24.0, xl: 32.0, xxl: 48.0, xxxl: 64.0 }
    }
    
    fn compact() -> Self {
        Spacing { xs: 2.0, sm: 4.0, md: 8.0, lg: 12.0, xl: 16.0, xxl: 24.0, xxxl: 32.0 }
    }
    
    fn comfortable() -> Self {
        Spacing { xs: 8.0, sm: 16.0, md: 24.0, lg: 32.0, xl: 48.0, xxl: 64.0, xxxl: 96.0 }
    }
    
    fn get(scale: SpacingScale) -> Float64 {
        match scale {
            SpacingScale.XS => self.xs,
            SpacingScale.SM => self.sm,
            SpacingScale.MD => self.md,
            SpacingScale.LG => self.lg,
            SpacingScale.XL => self.xl,
            SpacingScale.XXL => self.xxl,
            SpacingScale.XXXL => self.xxxl
        }
    }
}

enum SpacingScale { XS, SM, MD, LG, XL, XXL, XXXL }

// -----------------------------------------------------------------------------
// Border Radius Scale
// -----------------------------------------------------------------------------

/// Border radius scale
struct RadiusScale {
    none: Float64
    sm: Float64
    md: Float64
    lg: Float64
    xl: Float64
    full: Float64
    
    fn default() -> Self {
        RadiusScale { none: 0.0, sm: 4.0, md: 8.0, lg: 12.0, xl: 16.0, full: 9999.0 }
    }
    
    fn sharp() -> Self {
        RadiusScale { none: 0.0, sm: 2.0, md: 4.0, lg: 6.0, xl: 8.0, full: 9999.0 }
    }
    
    fn rounded() -> Self {
        RadiusScale { none: 0.0, sm: 8.0, md: 16.0, lg: 24.0, xl: 32.0, full: 9999.0 }
    }
}

// -----------------------------------------------------------------------------
// Shadow Scale
// -----------------------------------------------------------------------------

/// Shadow elevation scale
struct ShadowScale {
    none: Shadow
    sm: Shadow
    md: Shadow
    lg: Shadow
    xl: Shadow
    
    fn default() -> Self {
        ShadowScale {
            none: Shadow.new(0.0, 0.0, 0.0, RGBA.new(0, 0, 0, 0.0)),
            sm: Shadow.new(0.0, 1.0, 2.0, RGBA.new(0, 0, 0, 0.05)),
            md: Shadow.new(0.0, 4.0, 6.0, RGBA.new(0, 0, 0, 0.1)),
            lg: Shadow.new(0.0, 10.0, 15.0, RGBA.new(0, 0, 0, 0.1)),
            xl: Shadow.new(0.0, 20.0, 25.0, RGBA.new(0, 0, 0, 0.15))
        }
    }
    
    fn dark() -> Self {
        ShadowScale {
            none: Shadow.new(0.0, 0.0, 0.0, RGBA.new(0, 0, 0, 0.0)),
            sm: Shadow.new(0.0, 1.0, 2.0, RGBA.new(0, 0, 0, 0.3)),
            md: Shadow.new(0.0, 4.0, 6.0, RGBA.new(0, 0, 0, 0.4)),
            lg: Shadow.new(0.0, 10.0, 15.0, RGBA.new(0, 0, 0, 0.5)),
            xl: Shadow.new(0.0, 20.0, 25.0, RGBA.new(0, 0, 0, 0.6))
        }
    }
}

// -----------------------------------------------------------------------------
// Breakpoints
// -----------------------------------------------------------------------------

/// Responsive breakpoints
struct Breakpoints {
    xs: Float64   // Mobile small
    sm: Float64   // Mobile
    md: Float64   // Tablet
    lg: Float64   // Desktop
    xl: Float64   // Large desktop
    xxl: Float64  // Extra large
    
    fn default() -> Self {
        Breakpoints { xs: 0.0, sm: 640.0, md: 768.0, lg: 1024.0, xl: 1280.0, xxl: 1536.0 }
    }
    
    fn is_mobile(width: Float64) -> Bool { width < self.md }
    fn is_tablet(width: Float64) -> Bool { width >= self.md && width < self.lg }
    fn is_desktop(width: Float64) -> Bool { width >= self.lg }
    
    fn current(width: Float64) -> BreakpointSize {
        if width < self.sm { BreakpointSize.XS }
        else if width < self.md { BreakpointSize.SM }
        else if width < self.lg { BreakpointSize.MD }
        else if width < self.xl { BreakpointSize.LG }
        else if width < self.xxl { BreakpointSize.XL }
        else { BreakpointSize.XXL }
    }
}

enum BreakpointSize { XS, SM, MD, LG, XL, XXL }

// -----------------------------------------------------------------------------
// Transitions
// -----------------------------------------------------------------------------

/// Transition configuration
struct TransitionConfig {
    duration_fast: Float64
    duration_normal: Float64
    duration_slow: Float64
    easing_default: Easing
    easing_in: Easing
    easing_out: Easing
    easing_in_out: Easing
    
    fn default() -> Self {
        TransitionConfig {
            duration_fast: 150.0,
            duration_normal: 300.0,
            duration_slow: 500.0,
            easing_default: Easing.EaseInOut,
            easing_in: Easing.EaseIn,
            easing_out: Easing.EaseOut,
            easing_in_out: Easing.EaseInOut
        }
    }
}

enum Easing { Linear, EaseIn, EaseOut, EaseInOut, CubicBezier(Float64, Float64, Float64, Float64) }

// -----------------------------------------------------------------------------
// Style Builder
// -----------------------------------------------------------------------------

/// Fluent style builder
struct StyleBuilder {
    background: Option<RGBA>
    foreground: Option<RGBA>
    padding: Option<EdgeInsets>
    margin: Option<EdgeInsets>
    border: Option<Border>
    shadow: Option<Shadow>
    radius: Option<Float64>
    opacity: Option<Float64>
    
    fn new() -> Self {
        StyleBuilder {
            background: None, foreground: None, padding: None, margin: None,
            border: None, shadow: None, radius: None, opacity: None
        }
    }
    
    fn bg(color: RGBA) -> Self { self.background = Some(color); self }
    fn fg(color: RGBA) -> Self { self.foreground = Some(color); self }
    fn p(insets: EdgeInsets) -> Self { self.padding = Some(insets); self }
    fn px(h: Float64) -> Self { self.padding = Some(EdgeInsets.symmetric(h, 0.0)); self }
    fn py(v: Float64) -> Self { self.padding = Some(EdgeInsets.symmetric(0.0, v)); self }
    fn m(insets: EdgeInsets) -> Self { self.margin = Some(insets); self }
    fn border(b: Border) -> Self { self.border = Some(b); self }
    fn shadow(s: Shadow) -> Self { self.shadow = Some(s); self }
    fn rounded(r: Float64) -> Self { self.radius = Some(r); self }
    fn opacity(o: Float64) -> Self { self.opacity = Some(o); self }
}

// -----------------------------------------------------------------------------
// Theme Provider
// -----------------------------------------------------------------------------

/// Global theme provider
actor ThemeProvider {
    current: Theme
    listeners: [fn(Theme)]
    
    fn new(theme: Theme) -> Self {
        ThemeProvider { current: theme, listeners: [] }
    }
    
    fn get() -> Theme { self.current }
    
    fn set(theme: Theme) {
        self.current = theme
        for listener in &self.listeners {
            listener(theme)
        }
    }
    
    fn toggle_dark_mode() {
        if self.is_dark() {
            self.set(Theme.light())
        } else {
            self.set(Theme.dark())
        }
    }
    
    fn is_dark() -> Bool {
        self.current.colors.background.r < 128
    }
    
    fn listen(listener: fn(Theme)) {
        self.listeners.push(listener)
    }
}

// -----------------------------------------------------------------------------
// CSS-like Utilities
// -----------------------------------------------------------------------------

module CSS {
    fn rgb(r: Int, g: Int, b: Int) -> RGBA {
        RGBA.new(r as UInt8, g as UInt8, b as UInt8, 1.0)
    }
    
    fn rgba(r: Int, g: Int, b: Int, a: Float64) -> RGBA {
        RGBA.new(r as UInt8, g as UInt8, b as UInt8, a)
    }
    
    fn hex(value: String) -> Option<RGBA> {
        RGB.from_hex(value).map(|c| c.to_rgba(1.0))
    }
    
    fn hsl(h: Float64, s: Float64, l: Float64) -> RGBA {
        HSL.new(h, s, l).to_rgb().to_rgba(1.0)
    }
    
    fn transparent() -> RGBA { RGBA.new(0, 0, 0, 0.0) }
    fn white() -> RGBA { RGBA.new(255, 255, 255, 1.0) }
    fn black() -> RGBA { RGBA.new(0, 0, 0, 1.0) }
}

// -----------------------------------------------------------------------------
// Tailwind-like Color Palette
// -----------------------------------------------------------------------------

module Palette {
    // Gray
    fn gray_50() -> RGBA { RGBA.new(249, 250, 251, 1.0) }
    fn gray_100() -> RGBA { RGBA.new(243, 244, 246, 1.0) }
    fn gray_200() -> RGBA { RGBA.new(229, 231, 235, 1.0) }
    fn gray_300() -> RGBA { RGBA.new(209, 213, 219, 1.0) }
    fn gray_400() -> RGBA { RGBA.new(156, 163, 175, 1.0) }
    fn gray_500() -> RGBA { RGBA.new(107, 114, 128, 1.0) }
    fn gray_600() -> RGBA { RGBA.new(75, 85, 99, 1.0) }
    fn gray_700() -> RGBA { RGBA.new(55, 65, 81, 1.0) }
    fn gray_800() -> RGBA { RGBA.new(31, 41, 55, 1.0) }
    fn gray_900() -> RGBA { RGBA.new(17, 24, 39, 1.0) }
    
    // Blue
    fn blue_50() -> RGBA { RGBA.new(239, 246, 255, 1.0) }
    fn blue_100() -> RGBA { RGBA.new(219, 234, 254, 1.0) }
    fn blue_200() -> RGBA { RGBA.new(191, 219, 254, 1.0) }
    fn blue_300() -> RGBA { RGBA.new(147, 197, 253, 1.0) }
    fn blue_400() -> RGBA { RGBA.new(96, 165, 250, 1.0) }
    fn blue_500() -> RGBA { RGBA.new(59, 130, 246, 1.0) }
    fn blue_600() -> RGBA { RGBA.new(37, 99, 235, 1.0) }
    fn blue_700() -> RGBA { RGBA.new(29, 78, 216, 1.0) }
    fn blue_800() -> RGBA { RGBA.new(30, 64, 175, 1.0) }
    fn blue_900() -> RGBA { RGBA.new(30, 58, 138, 1.0) }
    
    // Red
    fn red_50() -> RGBA { RGBA.new(254, 242, 242, 1.0) }
    fn red_500() -> RGBA { RGBA.new(239, 68, 68, 1.0) }
    fn red_600() -> RGBA { RGBA.new(220, 38, 38, 1.0) }
    
    // Green
    fn green_50() -> RGBA { RGBA.new(240, 253, 244, 1.0) }
    fn green_500() -> RGBA { RGBA.new(34, 197, 94, 1.0) }
    fn green_600() -> RGBA { RGBA.new(22, 163, 74, 1.0) }
    
    // Yellow
    fn yellow_50() -> RGBA { RGBA.new(254, 252, 232, 1.0) }
    fn yellow_500() -> RGBA { RGBA.new(234, 179, 8, 1.0) }
    fn yellow_600() -> RGBA { RGBA.new(202, 138, 4, 1.0) }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "light theme" {
    let theme = Theme.light()
    assert_eq(theme.colors.background.r, 255)?
}

test "dark theme" {
    let theme = Theme.dark()
    assert(theme.colors.background.r < 50)?
}

test "spacing scale" {
    let spacing = Spacing.default()
    assert_eq(spacing.md, 16.0)?
}

test "breakpoints" {
    let bp = Breakpoints.default()
    assert(bp.is_mobile(500.0))?
    assert(bp.is_desktop(1200.0))?
}

test "color from seed" {
    let seed = RGBA.new(255, 100, 50, 1.0)
    let scheme = ColorScheme.from_seed(seed)
    assert_eq(scheme.primary, seed)?
}

test "css helpers" {
    let color = CSS.rgb(255, 128, 64)
    assert_eq(color.r, 255)?
    assert_eq(color.g, 128)?
}
