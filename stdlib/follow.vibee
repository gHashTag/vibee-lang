// =============================================================================
// Vibee OS â€” Follow Module
// Social following, subscriptions, and relationship management
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Follow Status
// =============================================================================

/// Follow relationship status
enum FollowStatus {
    NotFollowing,
    Following,
    Pending,
    Blocked,
    Muted
}

impl FollowStatus {
    fn is_following() -> Bool {
        match self {
            FollowStatus.Following => true,
            _ => false
        }
    }
    
    fn is_pending() -> Bool {
        match self {
            FollowStatus.Pending => true,
            _ => false
        }
    }
    
    fn is_blocked() -> Bool {
        match self {
            FollowStatus.Blocked => true,
            _ => false
        }
    }
    
    fn display_name() -> String {
        match self {
            FollowStatus.NotFollowing => "Not Following",
            FollowStatus.Following => "Following",
            FollowStatus.Pending => "Pending",
            FollowStatus.Blocked => "Blocked",
            FollowStatus.Muted => "Muted"
        }
    }
}

// =============================================================================
// Follow Relationship
// =============================================================================

/// Follow relationship between users
struct Follow {
    id: String,
    follower_id: String,
    following_id: String,
    status: FollowStatus,
    notify: Bool,
    created_at: DateTime,
    updated_at: DateTime,
    metadata: Map<String, String>
}

impl Follow {
    /// Create new follow relationship
    fn new(follower_id: String, following_id: String) -> Self {
        Follow {
            id: generate_id(),
            follower_id: follower_id,
            following_id: following_id,
            status: FollowStatus.Following,
            notify: true,
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            metadata: Map.empty()
        }
    }
    
    /// Create pending follow request
    fn pending(follower_id: String, following_id: String) -> Self {
        var follow = Self.new(follower_id, following_id)
        follow.status = FollowStatus.Pending
        follow
    }
    
    /// Accept pending follow
    fn accept() -> Result<(), FollowError> {
        if self.status != FollowStatus.Pending {
            return Err(FollowError.NotPending)
        }
        self.status = FollowStatus.Following
        self.updated_at = DateTime.now()
        Ok(())
    }
    
    /// Reject pending follow
    fn reject() -> Result<(), FollowError> {
        if self.status != FollowStatus.Pending {
            return Err(FollowError.NotPending)
        }
        self.status = FollowStatus.NotFollowing
        self.updated_at = DateTime.now()
        Ok(())
    }
    
    /// Mute notifications
    fn mute() {
        self.notify = false
        self.updated_at = DateTime.now()
    }
    
    /// Unmute notifications
    fn unmute() {
        self.notify = true
        self.updated_at = DateTime.now()
    }
    
    /// Toggle notifications
    fn toggle_notify() {
        self.notify = !self.notify
        self.updated_at = DateTime.now()
    }
    
    /// Set metadata
    fn set_metadata(key: String, value: String) {
        self.metadata.set(key, value)
        self.updated_at = DateTime.now()
    }
    
    /// Get follow duration
    fn duration() -> Duration {
        DateTime.now() - self.created_at
    }
}

// =============================================================================
// Mutual Follow
// =============================================================================

/// Mutual follow (friendship) relationship
struct MutualFollow {
    user_a: String,
    user_b: String,
    since: DateTime,
    close_friend: Bool
}

impl MutualFollow {
    fn new(user_a: String, user_b: String) -> Self {
        MutualFollow {
            user_a: user_a,
            user_b: user_b,
            since: DateTime.now(),
            close_friend: false
        }
    }
    
    fn involves(user_id: String) -> Bool {
        self.user_a == user_id || self.user_b == user_id
    }
    
    fn other_user(user_id: String) -> Option<String> {
        if self.user_a == user_id { Some(self.user_b) }
        else if self.user_b == user_id { Some(self.user_a) }
        else { None }
    }
    
    fn mark_close_friend() {
        self.close_friend = true
    }
    
    fn unmark_close_friend() {
        self.close_friend = false
    }
}

// =============================================================================
// Follow Request
// =============================================================================

/// Follow request for private accounts
struct FollowRequest {
    id: String,
    from_user_id: String,
    to_user_id: String,
    message: Option<String>,
    status: RequestStatus,
    created_at: DateTime,
    responded_at: Option<DateTime>
}

enum RequestStatus {
    Pending,
    Accepted,
    Rejected,
    Cancelled
}

impl FollowRequest {
    fn new(from: String, to: String) -> Self {
        FollowRequest {
            id: generate_id(),
            from_user_id: from,
            to_user_id: to,
            message: None,
            status: RequestStatus.Pending,
            created_at: DateTime.now(),
            responded_at: None
        }
    }
    
    fn with_message(from: String, to: String, message: String) -> Self {
        var request = Self.new(from, to)
        request.message = Some(message)
        request
    }
    
    fn accept() {
        self.status = RequestStatus.Accepted
        self.responded_at = Some(DateTime.now())
    }
    
    fn reject() {
        self.status = RequestStatus.Rejected
        self.responded_at = Some(DateTime.now())
    }
    
    fn cancel() {
        self.status = RequestStatus.Cancelled
        self.responded_at = Some(DateTime.now())
    }
    
    fn is_pending() -> Bool {
        match self.status {
            RequestStatus.Pending => true,
            _ => false
        }
    }
    
    fn is_accepted() -> Bool {
        match self.status {
            RequestStatus.Accepted => true,
            _ => false
        }
    }
    
    fn age() -> Duration {
        DateTime.now() - self.created_at
    }
}

// =============================================================================
// Block Relationship
// =============================================================================

/// Block relationship
struct Block {
    id: String,
    blocker_id: String,
    blocked_id: String,
    reason: Option<String>,
    created_at: DateTime
}

impl Block {
    fn new(blocker: String, blocked: String) -> Self {
        Block {
            id: generate_id(),
            blocker_id: blocker,
            blocked_id: blocked,
            reason: None,
            created_at: DateTime.now()
        }
    }
    
    fn with_reason(blocker: String, blocked: String, reason: String) -> Self {
        var block = Self.new(blocker, blocked)
        block.reason = Some(reason)
        block
    }
}

// =============================================================================
// Follow Service
// =============================================================================

/// Follow service actor
actor FollowService {
    state follows: Map<String, Follow>
    state followers_index: Map<String, [String]>  // user_id -> [follower_ids]
    state following_index: Map<String, [String]>  // user_id -> [following_ids]
    state blocks: Map<String, Block>
    state requests: Map<String, FollowRequest>
    state private_accounts: Set<String>
    
    fn new() -> Self {
        FollowService {
            follows: Map.empty(),
            followers_index: Map.empty(),
            following_index: Map.empty(),
            blocks: Map.empty(),
            requests: Map.empty(),
            private_accounts: Set.empty()
        }
    }
    
    /// Follow a user
    on follow(follower_id: String, following_id: String) -> Result<Follow, FollowError> {
        // Can't follow yourself
        if follower_id == following_id {
            return Err(FollowError.CannotFollowSelf)
        }
        
        // Check if blocked
        let block_key = format!("{}:{}", following_id, follower_id)
        if self.blocks.contains_key(block_key) {
            return Err(FollowError.Blocked)
        }
        
        // Check if already following
        let key = format!("{}:{}", follower_id, following_id)
        if self.follows.contains_key(key) {
            return Err(FollowError.AlreadyFollowing)
        }
        
        // Check if private account
        if self.private_accounts.contains(following_id) {
            let request = FollowRequest.new(follower_id, following_id)
            self.requests.set(request.id.clone(), request.clone())
            return Err(FollowError.RequiresApproval(request.id))
        }
        
        // Create follow
        let follow = Follow.new(follower_id.clone(), following_id.clone())
        self.follows.set(key, follow.clone())
        
        // Update indexes
        self.followers_index.entry(following_id.clone())
            .or_insert([])
            .push(follower_id.clone())
        
        self.following_index.entry(follower_id.clone())
            .or_insert([])
            .push(following_id.clone())
        
        Ok(follow)
    }
    
    /// Unfollow a user
    on unfollow(follower_id: String, following_id: String) -> Result<(), FollowError> {
        let key = format!("{}:{}", follower_id, following_id)
        
        if !self.follows.contains_key(key) {
            return Err(FollowError.NotFollowing)
        }
        
        self.follows.remove(key)
        
        // Update indexes
        if let Some(followers) = self.followers_index.get_mut(following_id) {
            followers.retain(|id| *id != follower_id)
        }
        
        if let Some(following) = self.following_index.get_mut(follower_id) {
            following.retain(|id| *id != following_id)
        }
        
        Ok(())
    }
    
    /// Check if user A follows user B
    on is_following(follower_id: String, following_id: String) -> Bool {
        let key = format!("{}:{}", follower_id, following_id)
        self.follows.contains_key(key)
    }
    
    /// Check if users follow each other
    on is_mutual(user_a: String, user_b: String) -> Bool {
        self.is_following(user_a.clone(), user_b.clone()) &&
        self.is_following(user_b, user_a)
    }
    
    /// Get followers of a user
    on get_followers(user_id: String, limit: Int, offset: Int) -> [String] {
        self.followers_index.get(user_id)
            .map(|f| f.skip(offset).take(limit).collect())
            .unwrap_or([])
    }
    
    /// Get users that a user follows
    on get_following(user_id: String, limit: Int, offset: Int) -> [String] {
        self.following_index.get(user_id)
            .map(|f| f.skip(offset).take(limit).collect())
            .unwrap_or([])
    }
    
    /// Get followers count
    on followers_count(user_id: String) -> Int {
        self.followers_index.get(user_id)
            .map(|f| f.len())
            .unwrap_or(0)
    }
    
    /// Get following count
    on following_count(user_id: String) -> Int {
        self.following_index.get(user_id)
            .map(|f| f.len())
            .unwrap_or(0)
    }
    
    /// Get mutual followers
    on get_mutual_followers(user_a: String, user_b: String) -> [String] {
        let followers_a = self.followers_index.get(user_a).unwrap_or([])
        let followers_b = self.followers_index.get(user_b).unwrap_or([])
        
        followers_a.filter(|id| followers_b.contains(id)).collect()
    }
    
    /// Get mutual friends (both follow each other)
    on get_mutual_friends(user_id: String) -> [String] {
        let followers = self.followers_index.get(user_id).unwrap_or([])
        let following = self.following_index.get(user_id).unwrap_or([])
        
        followers.filter(|id| following.contains(id)).collect()
    }
    
    /// Block a user
    on block(blocker_id: String, blocked_id: String) -> Result<Block, FollowError> {
        if blocker_id == blocked_id {
            return Err(FollowError.CannotBlockSelf)
        }
        
        let key = format!("{}:{}", blocker_id, blocked_id)
        
        if self.blocks.contains_key(key) {
            return Err(FollowError.AlreadyBlocked)
        }
        
        // Remove any existing follow relationships
        self.unfollow(blocker_id.clone(), blocked_id.clone()).ok()
        self.unfollow(blocked_id.clone(), blocker_id.clone()).ok()
        
        let block = Block.new(blocker_id, blocked_id)
        self.blocks.set(key, block.clone())
        
        Ok(block)
    }
    
    /// Unblock a user
    on unblock(blocker_id: String, blocked_id: String) -> Result<(), FollowError> {
        let key = format!("{}:{}", blocker_id, blocked_id)
        
        if !self.blocks.contains_key(key) {
            return Err(FollowError.NotBlocked)
        }
        
        self.blocks.remove(key)
        Ok(())
    }
    
    /// Check if user A blocked user B
    on is_blocked(blocker_id: String, blocked_id: String) -> Bool {
        let key = format!("{}:{}", blocker_id, blocked_id)
        self.blocks.contains_key(key)
    }
    
    /// Check if either user blocked the other
    on has_block_between(user_a: String, user_b: String) -> Bool {
        self.is_blocked(user_a.clone(), user_b.clone()) ||
        self.is_blocked(user_b, user_a)
    }
    
    /// Get blocked users
    on get_blocked(user_id: String) -> [String] {
        self.blocks.values()
            .filter(|b| b.blocker_id == user_id)
            .map(|b| b.blocked_id.clone())
            .collect()
    }
    
    /// Set account as private
    on set_private(user_id: String) {
        self.private_accounts.insert(user_id)
    }
    
    /// Set account as public
    on set_public(user_id: String) {
        self.private_accounts.remove(user_id)
    }
    
    /// Check if account is private
    on is_private(user_id: String) -> Bool {
        self.private_accounts.contains(user_id)
    }
    
    /// Accept follow request
    on accept_request(request_id: String) -> Result<Follow, FollowError> {
        let request = self.requests.get_mut(request_id.clone())
            .ok_or(FollowError.RequestNotFound)?
        
        if !request.is_pending() {
            return Err(FollowError.RequestAlreadyProcessed)
        }
        
        request.accept()
        
        // Create the follow
        let follow = Follow.new(request.from_user_id.clone(), request.to_user_id.clone())
        let key = format!("{}:{}", request.from_user_id, request.to_user_id)
        self.follows.set(key, follow.clone())
        
        // Update indexes
        self.followers_index.entry(request.to_user_id.clone())
            .or_insert([])
            .push(request.from_user_id.clone())
        
        self.following_index.entry(request.from_user_id.clone())
            .or_insert([])
            .push(request.to_user_id.clone())
        
        Ok(follow)
    }
    
    /// Reject follow request
    on reject_request(request_id: String) -> Result<(), FollowError> {
        let request = self.requests.get_mut(request_id)
            .ok_or(FollowError.RequestNotFound)?
        
        if !request.is_pending() {
            return Err(FollowError.RequestAlreadyProcessed)
        }
        
        request.reject()
        Ok(())
    }
    
    /// Get pending requests for a user
    on get_pending_requests(user_id: String) -> [FollowRequest] {
        self.requests.values()
            .filter(|r| r.to_user_id == user_id && r.is_pending())
            .collect()
    }
    
    /// Get sent requests by a user
    on get_sent_requests(user_id: String) -> [FollowRequest] {
        self.requests.values()
            .filter(|r| r.from_user_id == user_id && r.is_pending())
            .collect()
    }
    
    /// Get follow suggestions based on mutual connections
    on get_suggestions(user_id: String, limit: Int) -> [FollowSuggestion] {
        let following = self.following_index.get(user_id).unwrap_or([])
        var suggestions = Map.empty()
        
        // Find friends of friends
        for friend_id in following {
            let friends_following = self.following_index.get(friend_id).unwrap_or([])
            for suggested_id in friends_following {
                if suggested_id != user_id && !following.contains(suggested_id) {
                    let entry = suggestions.entry(suggested_id.clone())
                        .or_insert(FollowSuggestion.new(suggested_id.clone()))
                    entry.mutual_count += 1
                    entry.mutual_friends.push(friend_id.clone())
                }
            }
        }
        
        var result = suggestions.values().collect()
        result.sort_by(|a, b| b.mutual_count.cmp(a.mutual_count))
        result.take(limit)
    }
    
    /// Get relationship status between two users
    on get_relationship(from_user: String, to_user: String) -> RelationshipStatus {
        if self.is_blocked(to_user.clone(), from_user.clone()) {
            return RelationshipStatus.BlockedBy
        }
        
        if self.is_blocked(from_user.clone(), to_user.clone()) {
            return RelationshipStatus.Blocking
        }
        
        let is_following = self.is_following(from_user.clone(), to_user.clone())
        let is_followed_by = self.is_following(to_user, from_user)
        
        match (is_following, is_followed_by) {
            (true, true) => RelationshipStatus.Mutual,
            (true, false) => RelationshipStatus.Following,
            (false, true) => RelationshipStatus.FollowedBy,
            (false, false) => RelationshipStatus.None
        }
    }
}

/// Follow suggestion
struct FollowSuggestion {
    user_id: String,
    mutual_count: Int,
    mutual_friends: [String],
    reason: SuggestionReason
}

impl FollowSuggestion {
    fn new(user_id: String) -> Self {
        FollowSuggestion {
            user_id: user_id,
            mutual_count: 0,
            mutual_friends: [],
            reason: SuggestionReason.MutualFriends
        }
    }
}

/// Suggestion reason
enum SuggestionReason {
    MutualFriends,
    SimilarInterests,
    Location,
    Contacts,
    Popular
}

/// Relationship status
enum RelationshipStatus {
    None,
    Following,
    FollowedBy,
    Mutual,
    Blocking,
    BlockedBy
}

impl RelationshipStatus {
    fn display_name() -> String {
        match self {
            RelationshipStatus.None => "Not Connected",
            RelationshipStatus.Following => "Following",
            RelationshipStatus.FollowedBy => "Follows You",
            RelationshipStatus.Mutual => "Mutual",
            RelationshipStatus.Blocking => "Blocked",
            RelationshipStatus.BlockedBy => "Blocked By"
        }
    }
    
    fn can_interact() -> Bool {
        match self {
            RelationshipStatus.Blocking | RelationshipStatus.BlockedBy => false,
            _ => true
        }
    }
}

// =============================================================================
// Follow Errors
// =============================================================================

/// Follow errors
enum FollowError {
    CannotFollowSelf,
    CannotBlockSelf,
    AlreadyFollowing,
    NotFollowing,
    AlreadyBlocked,
    NotBlocked,
    Blocked,
    RequiresApproval(String),
    RequestNotFound,
    RequestAlreadyProcessed,
    RateLimited
}

impl FollowError {
    fn message() -> String {
        match self {
            FollowError.CannotFollowSelf => "Cannot follow yourself",
            FollowError.CannotBlockSelf => "Cannot block yourself",
            FollowError.AlreadyFollowing => "Already following this user",
            FollowError.NotFollowing => "Not following this user",
            FollowError.AlreadyBlocked => "User is already blocked",
            FollowError.NotBlocked => "User is not blocked",
            FollowError.Blocked => "You are blocked by this user",
            FollowError.RequiresApproval(id) => format!("Follow request sent: {}", id),
            FollowError.RequestNotFound => "Follow request not found",
            FollowError.RequestAlreadyProcessed => "Request already processed",
            FollowError.RateLimited => "Too many follow actions, please wait"
        }
    }
}

// =============================================================================
// Follow Events
// =============================================================================

/// Follow events for event sourcing
enum FollowEvent {
    Followed { follower_id: String, following_id: String, timestamp: DateTime },
    Unfollowed { follower_id: String, following_id: String, timestamp: DateTime },
    Blocked { blocker_id: String, blocked_id: String, timestamp: DateTime },
    Unblocked { blocker_id: String, blocked_id: String, timestamp: DateTime },
    RequestSent { from_id: String, to_id: String, timestamp: DateTime },
    RequestAccepted { request_id: String, timestamp: DateTime },
    RequestRejected { request_id: String, timestamp: DateTime }
}

impl FollowEvent {
    fn timestamp() -> DateTime {
        match self {
            FollowEvent.Followed { timestamp, .. } => timestamp,
            FollowEvent.Unfollowed { timestamp, .. } => timestamp,
            FollowEvent.Blocked { timestamp, .. } => timestamp,
            FollowEvent.Unblocked { timestamp, .. } => timestamp,
            FollowEvent.RequestSent { timestamp, .. } => timestamp,
            FollowEvent.RequestAccepted { timestamp, .. } => timestamp,
            FollowEvent.RequestRejected { timestamp, .. } => timestamp
        }
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn generate_id() -> String {
    @native("uuid_v4")
}

// =============================================================================
// Tests
// =============================================================================

test "follow user" {
    let service = FollowService.new()
    
    let result = service.follow("user1", "user2")
    assert(result.is_ok())?
    
    assert(service.is_following("user1", "user2"))?
    assert(!service.is_following("user2", "user1"))?
}

test "cannot follow self" {
    let service = FollowService.new()
    
    let result = service.follow("user1", "user1")
    assert(result.is_err())?
}

test "unfollow user" {
    let service = FollowService.new()
    
    service.follow("user1", "user2").unwrap()
    assert(service.is_following("user1", "user2"))?
    
    service.unfollow("user1", "user2").unwrap()
    assert(!service.is_following("user1", "user2"))?
}

test "mutual follow" {
    let service = FollowService.new()
    
    service.follow("user1", "user2").unwrap()
    service.follow("user2", "user1").unwrap()
    
    assert(service.is_mutual("user1", "user2"))?
}

test "block user" {
    let service = FollowService.new()
    
    service.follow("user1", "user2").unwrap()
    service.block("user2", "user1").unwrap()
    
    // Follow should be removed
    assert(!service.is_following("user1", "user2"))?
    assert(service.is_blocked("user2", "user1"))?
}

test "private account follow request" {
    let service = FollowService.new()
    
    service.set_private("user2")
    
    let result = service.follow("user1", "user2")
    match result {
        Err(FollowError.RequiresApproval(_)) => assert(true)?,
        _ => assert(false)?
    }
}

test "followers count" {
    let service = FollowService.new()
    
    service.follow("user1", "user3").unwrap()
    service.follow("user2", "user3").unwrap()
    
    assert_eq(service.followers_count("user3"), 2)?
    assert_eq(service.following_count("user1"), 1)?
}

test "relationship status" {
    let service = FollowService.new()
    
    service.follow("user1", "user2").unwrap()
    
    assert_eq(service.get_relationship("user1", "user2"), RelationshipStatus.Following)?
    assert_eq(service.get_relationship("user2", "user1"), RelationshipStatus.FollowedBy)?
    
    service.follow("user2", "user1").unwrap()
    assert_eq(service.get_relationship("user1", "user2"), RelationshipStatus.Mutual)?
}
