// =============================================================================
// Vibee OS â€” Snapshot Module
// Snapshot testing for comparing outputs against saved references
// =============================================================================

// -----------------------------------------------------------------------------
// Snapshot Manager
// -----------------------------------------------------------------------------

/// Global snapshot manager
actor SnapshotManager {
    state snapshots_dir: String
    state update_mode: UpdateMode
    state snapshots: Map<String, Snapshot>
    state results: [SnapshotResult]
    
    fn new() -> Self {
        SnapshotManager {
            snapshots_dir: "__snapshots__",
            update_mode: UpdateMode.Compare,
            snapshots: Map.empty(),
            results: []
        }
    }
    
    /// Set snapshots directory
    on dir(path: String) -> Self {
        self.snapshots_dir = path
        self
    }
    
    /// Set update mode
    on mode(mode: UpdateMode) -> Self {
        self.update_mode = mode
        self
    }
    
    /// Assert value matches snapshot
    fn assert_snapshot<T: Serialize>(name: String, value: T) -> Result<(), SnapshotError> {
        let serialized = serialize_value(value)
        self.assert_snapshot_raw(name, serialized)
    }
    
    /// Assert raw string matches snapshot
    fn assert_snapshot_raw(name: String, actual: String) -> Result<(), SnapshotError> {
        let snapshot_path = self.snapshot_path(name)
        
        match self.update_mode {
            .Update => {
                self.write_snapshot(snapshot_path, actual)?
                self.results.append(SnapshotResult.Updated(name))
                Ok(())
            }
            .Compare => {
                if let Ok(expected) = self.read_snapshot(snapshot_path) {
                    if actual == expected {
                        self.results.append(SnapshotResult.Passed(name))
                        Ok(())
                    } else {
                        let diff = compute_diff(expected, actual)
                        self.results.append(SnapshotResult.Failed(name, diff.clone()))
                        Err(SnapshotError.Mismatch(name, diff))
                    }
                } else {
                    // New snapshot
                    self.write_snapshot(snapshot_path, actual)?
                    self.results.append(SnapshotResult.Created(name))
                    Ok(())
                }
            }
            .Verify => {
                let expected = self.read_snapshot(snapshot_path)?
                if actual == expected {
                    self.results.append(SnapshotResult.Passed(name))
                    Ok(())
                } else {
                    let diff = compute_diff(expected, actual)
                    self.results.append(SnapshotResult.Failed(name, diff.clone()))
                    Err(SnapshotError.Mismatch(name, diff))
                }
            }
        }
    }
    
    fn snapshot_path(name: String) -> String {
        format!("{}/{}.snap", self.snapshots_dir, name.replace(" ", "_"))
    }
    
    fn read_snapshot(path: String) -> Result<String, SnapshotError> {
        @native("read_file", path)
            .map_err(|_| SnapshotError.NotFound(path))
    }
    
    fn write_snapshot(path: String, content: String) -> Result<(), SnapshotError> {
        // Ensure directory exists
        let dir = @native("path_parent", path)
        @native("create_dir_all", dir)
            .map_err(|e| SnapshotError.WriteError(e.to_string()))?
        
        @native("write_file", path, content)
            .map_err(|e| SnapshotError.WriteError(e.to_string()))
    }
    
    /// Get summary of results
    fn summary() -> SnapshotSummary {
        var passed = 0
        var failed = 0
        var created = 0
        var updated = 0
        
        for result in self.results {
            match result {
                .Passed(_) => passed += 1
                .Failed(_, _) => failed += 1
                .Created(_) => created += 1
                .Updated(_) => updated += 1
            }
        }
        
        SnapshotSummary { passed: passed, failed: failed, created: created, updated: updated }
    }
    
    /// Print summary
    fn print_summary() {
        let s = self.summary()
        println("\n=== Snapshot Summary ===")
        println("Passed:  {}", s.passed)
        println("Failed:  {}", s.failed)
        println("Created: {}", s.created)
        println("Updated: {}", s.updated)
    }
}

/// Update mode
enum UpdateMode {
    Compare   // Compare with existing, create if missing
    Update    // Always update snapshots
    Verify    // Fail if snapshot doesn't exist
}

/// Snapshot result
enum SnapshotResult {
    Passed(String)
    Failed(String, SnapshotDiff)
    Created(String)
    Updated(String)
}

/// Snapshot summary
struct SnapshotSummary {
    passed: Int
    failed: Int
    created: Int
    updated: Int
    
    fn total() -> Int { self.passed + self.failed + self.created + self.updated }
    fn all_passed() -> Bool { self.failed == 0 }
}

// -----------------------------------------------------------------------------
// Snapshot Types
// -----------------------------------------------------------------------------

/// Stored snapshot
struct Snapshot {
    name: String
    content: String
    metadata: SnapshotMetadata
}

/// Snapshot metadata
struct SnapshotMetadata {
    created_at: DateTime
    updated_at: DateTime
    version: Int
}

// -----------------------------------------------------------------------------
// Diff Computation
// -----------------------------------------------------------------------------

/// Snapshot diff
struct SnapshotDiff {
    expected: String
    actual: String
    hunks: [DiffHunk]
}

impl SnapshotDiff {
    fn has_changes() -> Bool { !self.hunks.is_empty() }
    
    fn format() -> String {
        var output = ""
        for hunk in self.hunks {
            output += hunk.format()
        }
        output
    }
    
    fn format_inline() -> String {
        var output = ""
        output += red("- Expected:\n")
        output += self.expected
        output += "\n"
        output += green("+ Actual:\n")
        output += self.actual
        output
    }
}

/// Diff hunk
struct DiffHunk {
    old_start: Int
    old_count: Int
    new_start: Int
    new_count: Int
    lines: [DiffLine]
}

impl DiffHunk {
    fn format() -> String {
        var output = format!("@@ -{},{} +{},{} @@\n", 
            self.old_start, self.old_count, self.new_start, self.new_count)
        
        for line in self.lines {
            output += line.format()
        }
        output
    }
}

/// Diff line
enum DiffLine {
    Context(String)
    Added(String)
    Removed(String)
    
    fn format() -> String {
        match self {
            .Context(s) => format!(" {}\n", s)
            .Added(s) => green(format!("+ {}\n", s))
            .Removed(s) => red(format!("- {}\n", s))
        }
    }
}

/// Compute diff between two strings
fn compute_diff(expected: String, actual: String) -> SnapshotDiff {
    let expected_lines = expected.lines().collect()
    let actual_lines = actual.lines().collect()
    
    let hunks = @native("compute_diff_hunks", expected_lines, actual_lines)
    
    SnapshotDiff {
        expected: expected,
        actual: actual,
        hunks: hunks
    }
}

// -----------------------------------------------------------------------------
// Serialization
// -----------------------------------------------------------------------------

/// Serialize value for snapshot
fn serialize_value<T: Serialize>(value: T) -> String {
    // Try JSON first for structured data
    if let Ok(json) = @native("json_encode_pretty", value) {
        return json
    }
    
    // Fall back to debug representation
    format!("{:?}", value)
}

/// Snapshot serializer trait
trait SnapshotSerialize {
    fn to_snapshot() -> String
}

impl SnapshotSerialize for String {
    fn to_snapshot() -> String { self }
}

impl<T: Debug> SnapshotSerialize for [T] {
    fn to_snapshot() -> String {
        var output = "[\n"
        for (i, item) in self.enumerate() {
            output += format!("  {:?}", item)
            if i < self.len() - 1 { output += "," }
            output += "\n"
        }
        output += "]"
        output
    }
}

impl<K: Debug, V: Debug> SnapshotSerialize for Map<K, V> {
    fn to_snapshot() -> String {
        var output = "{\n"
        let entries: [(K, V)] = self.iter().collect()
        for (i, (k, v)) in entries.enumerate() {
            output += format!("  {:?}: {:?}", k, v)
            if i < entries.len() - 1 { output += "," }
            output += "\n"
        }
        output += "}"
        output
    }
}

// -----------------------------------------------------------------------------
// Inline Snapshots
// -----------------------------------------------------------------------------

/// Inline snapshot assertion
fn assert_inline_snapshot<T: Serialize>(value: T, expected: String) -> Result<(), SnapshotError> {
    let actual = serialize_value(value)
    
    if actual == expected {
        Ok(())
    } else {
        let diff = compute_diff(expected, actual)
        Err(SnapshotError.InlineMismatch(diff))
    }
}

// -----------------------------------------------------------------------------
// Property-based Snapshots
// -----------------------------------------------------------------------------

/// Snapshot with custom comparison
fn assert_snapshot_with<T, F>(name: String, value: T, serializer: (T) -> String) -> Result<(), SnapshotError> 
where F: Fn(T) -> String {
    let manager = SnapshotManager.new()
    let serialized = serializer(value)
    manager.assert_snapshot_raw(name, serialized)
}

/// Snapshot with custom matcher
fn assert_snapshot_matches<T>(name: String, value: T, matcher: (String, String) -> Bool) -> Result<(), SnapshotError> {
    let manager = SnapshotManager.new()
    let actual = serialize_value(value)
    let snapshot_path = manager.snapshot_path(name)
    
    if let Ok(expected) = manager.read_snapshot(snapshot_path) {
        if matcher(expected, actual) {
            Ok(())
        } else {
            Err(SnapshotError.CustomMismatch(name))
        }
    } else {
        manager.write_snapshot(snapshot_path, actual)
    }
}

// -----------------------------------------------------------------------------
// Snapshot Testing Helpers
// -----------------------------------------------------------------------------

/// Create snapshot test context
fn snapshot_test<F>(name: String, f: (SnapshotContext) -> Result<(), SnapshotError>) -> Result<(), SnapshotError> {
    let ctx = SnapshotContext.new(name)
    f(ctx)
}

/// Snapshot test context
actor SnapshotContext {
    state test_name: String
    state manager: SnapshotManager
    state counter: Int
    
    fn new(test_name: String) -> Self {
        SnapshotContext {
            test_name: test_name,
            manager: SnapshotManager.new(),
            counter: 0
        }
    }
    
    /// Assert snapshot with auto-generated name
    fn assert<T: Serialize>(value: T) -> Result<(), SnapshotError> {
        let name = format!("{}_{}", self.test_name, self.counter)
        self.counter += 1
        self.manager.assert_snapshot(name, value)
    }
    
    /// Assert snapshot with custom name
    fn assert_named<T: Serialize>(name: String, value: T) -> Result<(), SnapshotError> {
        let full_name = format!("{}_{}", self.test_name, name)
        self.manager.assert_snapshot(full_name, value)
    }
}

// -----------------------------------------------------------------------------
// File Snapshots
// -----------------------------------------------------------------------------

/// Assert file content matches snapshot
fn assert_file_snapshot(name: String, file_path: String) -> Result<(), SnapshotError> {
    let content = @native("read_file", file_path)
        .map_err(|e| SnapshotError.ReadError(e.to_string()))?
    
    let manager = SnapshotManager.new()
    manager.assert_snapshot_raw(name, content)
}

/// Assert directory structure matches snapshot
fn assert_dir_snapshot(name: String, dir_path: String) -> Result<(), SnapshotError> {
    let structure = capture_dir_structure(dir_path)?
    
    let manager = SnapshotManager.new()
    manager.assert_snapshot_raw(name, structure)
}

fn capture_dir_structure(path: String) -> Result<String, SnapshotError> {
    var output = ""
    let entries = @native("read_dir_recursive", path)
        .map_err(|e| SnapshotError.ReadError(e.to_string()))?
    
    for entry in entries.sorted() {
        let relative = entry.strip_prefix(path).unwrap_or(entry)
        output += format!("{}\n", relative)
    }
    
    Ok(output)
}

// -----------------------------------------------------------------------------
// Image Snapshots
// -----------------------------------------------------------------------------

/// Assert image matches snapshot (with tolerance)
fn assert_image_snapshot(name: String, image: Image, tolerance: Float) -> Result<(), SnapshotError> {
    let manager = SnapshotManager.new()
    let snapshot_path = manager.snapshot_path(format!("{}.png", name))
    
    if let Ok(expected_bytes) = @native("read_file_bytes", snapshot_path) {
        let expected = Image.from_bytes(expected_bytes)?
        let diff = compare_images(expected, image)
        
        if diff <= tolerance {
            Ok(())
        } else {
            Err(SnapshotError.ImageMismatch(name, diff))
        }
    } else {
        // Save new snapshot
        let bytes = image.to_png()
        @native("write_file_bytes", snapshot_path, bytes)
            .map_err(|e| SnapshotError.WriteError(e.to_string()))
    }
}

fn compare_images(a: Image, b: Image) -> Float {
    @native("image_diff_percent", a, b)
}

struct Image {
    width: Int
    height: Int
    data: [UInt8]
    
    fn from_bytes(bytes: [UInt8]) -> Result<Self, SnapshotError> {
        @native("image_decode", bytes).map_err(|e| SnapshotError.ReadError(e.to_string()))
    }
    
    fn to_png() -> [UInt8] {
        @native("image_encode_png", self)
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum SnapshotError {
    NotFound(String)
    Mismatch(String, SnapshotDiff)
    InlineMismatch(SnapshotDiff)
    CustomMismatch(String)
    ImageMismatch(String, Float)
    ReadError(String)
    WriteError(String)
    SerializationError(String)
    
    fn message() -> String {
        match self {
            .NotFound(p) => format!("Snapshot not found: {}", p)
            .Mismatch(n, d) => format!("Snapshot '{}' mismatch:\n{}", n, d.format())
            .InlineMismatch(d) => format!("Inline snapshot mismatch:\n{}", d.format_inline())
            .CustomMismatch(n) => format!("Custom matcher failed for '{}'", n)
            .ImageMismatch(n, d) => format!("Image '{}' differs by {:.2}%", n, d * 100.0)
            .ReadError(m) => format!("Read error: {}", m)
            .WriteError(m) => format!("Write error: {}", m)
            .SerializationError(m) => format!("Serialization error: {}", m)
        }
    }
}

// -----------------------------------------------------------------------------
// Color Helpers
// -----------------------------------------------------------------------------

fn red(s: String) -> String { format!("\x1b[31m{}\x1b[0m", s) }
fn green(s: String) -> String { format!("\x1b[32m{}\x1b[0m", s) }
fn yellow(s: String) -> String { format!("\x1b[33m{}\x1b[0m", s) }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "snapshot basic" {
    let manager = SnapshotManager.new().dir("/tmp/test_snapshots")
    
    let data = Map.from([("name", "Alice"), ("age", "30")])
    manager.assert_snapshot("user_data", data)?
}

test "inline snapshot" {
    assert_inline_snapshot([1, 2, 3], "[\n  1,\n  2,\n  3\n]")?
}

test "diff computation" {
    let diff = compute_diff("hello\nworld", "hello\nuniverse")
    assert(diff.has_changes())
    assert_eq(diff.hunks.len(), 1)?
}

test "snapshot summary" {
    let manager = SnapshotManager.new()
    manager.results = [
        SnapshotResult.Passed("test1"),
        SnapshotResult.Passed("test2"),
        SnapshotResult.Created("test3")
    ]
    
    let summary = manager.summary()
    assert_eq(summary.passed, 2)?
    assert_eq(summary.created, 1)?
    assert(summary.all_passed())
}
