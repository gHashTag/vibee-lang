// =============================================================================
// Vibee OS â€” GCP Module
// Google Cloud Platform SDK
// =============================================================================

// -----------------------------------------------------------------------------
// GCP Client Configuration
// -----------------------------------------------------------------------------

struct GcpConfig {
    project_id: String
    credentials_path: String?
    credentials_json: String?
    region: String?
    zone: String?
}

impl GcpConfig {
    fn new(project_id: String) -> Self {
        GcpConfig {
            project_id: project_id,
            credentials_path: None,
            credentials_json: None,
            region: None,
            zone: None
        }
    }
    
    fn from_env() -> Result<Self, GcpError> {
        @native("gcp_config_from_env")
    }
    
    fn from_service_account(path: String) -> Result<Self, GcpError> {
        @native("gcp_config_from_service_account", path)
    }
    
    fn from_default_credentials() -> Result<Self, GcpError> {
        @native("gcp_config_from_adc")
    }
    
    fn with_region(region: String) -> Self {
        self.region = Some(region)
        self
    }
    
    fn with_zone(zone: String) -> Self {
        self.zone = Some(zone)
        self
    }
}

// -----------------------------------------------------------------------------
// Compute Engine
// -----------------------------------------------------------------------------

actor ComputeClient {
    state config: GcpConfig
    
    init(config: GcpConfig) { self.config = config }
    
    // Instances
    on list_instances(zone: String) -> Result<[ComputeInstance], GcpError> {
        @native("gcp_compute_list_instances", self.config, zone)
    }
    
    on get_instance(zone: String, name: String) -> Result<ComputeInstance, GcpError> {
        @native("gcp_compute_get_instance", self.config, zone, name)
    }
    
    on create_instance(zone: String, params: CreateInstanceParams) -> Result<Operation, GcpError> {
        @native("gcp_compute_create_instance", self.config, zone, params)
    }
    
    on delete_instance(zone: String, name: String) -> Result<Operation, GcpError> {
        @native("gcp_compute_delete_instance", self.config, zone, name)
    }
    
    on start_instance(zone: String, name: String) -> Result<Operation, GcpError> {
        @native("gcp_compute_start_instance", self.config, zone, name)
    }
    
    on stop_instance(zone: String, name: String) -> Result<Operation, GcpError> {
        @native("gcp_compute_stop_instance", self.config, zone, name)
    }
    
    on reset_instance(zone: String, name: String) -> Result<Operation, GcpError> {
        @native("gcp_compute_reset_instance", self.config, zone, name)
    }
    
    // Disks
    on list_disks(zone: String) -> Result<[Disk], GcpError> {
        @native("gcp_compute_list_disks", self.config, zone)
    }
    
    on create_disk(zone: String, name: String, size_gb: Int, disk_type: String = "pd-standard") -> Result<Operation, GcpError> {
        @native("gcp_compute_create_disk", self.config, zone, name, size_gb, disk_type)
    }
    
    on delete_disk(zone: String, name: String) -> Result<Operation, GcpError> {
        @native("gcp_compute_delete_disk", self.config, zone, name)
    }
    
    // Networks
    on list_networks() -> Result<[Network], GcpError> {
        @native("gcp_compute_list_networks", self.config)
    }
    
    on create_network(name: String, auto_create_subnets: Bool = true) -> Result<Operation, GcpError> {
        @native("gcp_compute_create_network", self.config, name, auto_create_subnets)
    }
    
    // Firewalls
    on list_firewalls() -> Result<[Firewall], GcpError> {
        @native("gcp_compute_list_firewalls", self.config)
    }
    
    on create_firewall(params: FirewallParams) -> Result<Operation, GcpError> {
        @native("gcp_compute_create_firewall", self.config, params)
    }
    
    // Images
    on list_images(project: String = "debian-cloud") -> Result<[ComputeImage], GcpError> {
        @native("gcp_compute_list_images", self.config, project)
    }
    
    // Operations
    on wait_for_operation(zone: String, operation_name: String) -> Result<Operation, GcpError> {
        @native("gcp_compute_wait_operation", self.config, zone, operation_name)
    }
}

struct ComputeInstance {
    id: String
    name: String
    zone: String
    machine_type: String
    status: InstanceStatus
    network_interfaces: [NetworkInterface]
    disks: [AttachedDisk]
    labels: Map<String, String>
    creation_timestamp: DateTime
}

enum InstanceStatus { Provisioning, Staging, Running, Stopping, Stopped, Suspending, Suspended, Terminated }

struct NetworkInterface {
    network: String
    subnetwork: String?
    network_ip: String
    access_configs: [AccessConfig]
}

struct AccessConfig { name: String, nat_ip: String?, type_: String }
struct AttachedDisk { source: String, boot: Bool, auto_delete: Bool, mode: String }

struct CreateInstanceParams {
    name: String
    machine_type: String
    source_image: String
    disk_size_gb: Int
    network: String
    subnetwork: String?
    tags: [String]
    labels: Map<String, String>
    metadata: Map<String, String>
    service_account: String?
    scopes: [String]
}

impl CreateInstanceParams {
    fn new(name: String, machine_type: String, source_image: String) -> Self {
        CreateInstanceParams {
            name: name,
            machine_type: machine_type,
            source_image: source_image,
            disk_size_gb: 10,
            network: "default",
            subnetwork: None,
            tags: [],
            labels: Map.empty(),
            metadata: Map.empty(),
            service_account: None,
            scopes: []
        }
    }
}

struct Disk { id: String, name: String, zone: String, size_gb: Int, type_: String, status: String }
struct Network { id: String, name: String, auto_create_subnetworks: Bool, subnetworks: [String] }
struct Firewall { id: String, name: String, network: String, direction: String, allowed: [FirewallRule], source_ranges: [String] }
struct FirewallRule { protocol: String, ports: [String] }
struct FirewallParams { name: String, network: String, direction: String, allowed: [FirewallRule], source_ranges: [String], target_tags: [String] }
struct ComputeImage { id: String, name: String, family: String?, status: String, disk_size_gb: Int }
struct Operation { id: String, name: String, status: String, target_link: String?, error: OperationError? }
struct OperationError { code: String, message: String }

// -----------------------------------------------------------------------------
// Cloud Storage
// -----------------------------------------------------------------------------

actor StorageClient {
    state config: GcpConfig
    
    init(config: GcpConfig) { self.config = config }
    
    on list_buckets() -> Result<[Bucket], GcpError> {
        @native("gcp_storage_list_buckets", self.config)
    }
    
    on get_bucket(name: String) -> Result<Bucket, GcpError> {
        @native("gcp_storage_get_bucket", self.config, name)
    }
    
    on create_bucket(name: String, location: String = "US") -> Result<Bucket, GcpError> {
        @native("gcp_storage_create_bucket", self.config, name, location)
    }
    
    on delete_bucket(name: String) -> Result<(), GcpError> {
        @native("gcp_storage_delete_bucket", self.config, name)
    }
    
    on list_objects(bucket: String, prefix: String? = None) -> Result<[GcsObject], GcpError> {
        @native("gcp_storage_list_objects", self.config, bucket, prefix)
    }
    
    on get_object(bucket: String, name: String) -> Result<[Byte], GcpError> {
        @native("gcp_storage_get_object", self.config, bucket, name)
    }
    
    on upload_object(bucket: String, name: String, data: [Byte], content_type: String? = None) -> Result<GcsObject, GcpError> {
        @native("gcp_storage_upload_object", self.config, bucket, name, data, content_type)
    }
    
    on delete_object(bucket: String, name: String) -> Result<(), GcpError> {
        @native("gcp_storage_delete_object", self.config, bucket, name)
    }
    
    on copy_object(src_bucket: String, src_name: String, dst_bucket: String, dst_name: String) -> Result<GcsObject, GcpError> {
        @native("gcp_storage_copy_object", self.config, src_bucket, src_name, dst_bucket, dst_name)
    }
    
    on generate_signed_url(bucket: String, name: String, expiration: Duration, method: String = "GET") -> Result<String, GcpError> {
        @native("gcp_storage_signed_url", self.config, bucket, name, expiration, method)
    }
}

struct Bucket {
    name: String
    location: String
    storage_class: String
    time_created: DateTime
    labels: Map<String, String>
    versioning_enabled: Bool
}

struct GcsObject {
    name: String
    bucket: String
    size: Int64
    content_type: String
    md5_hash: String
    time_created: DateTime
    updated: DateTime
    metadata: Map<String, String>
}

// -----------------------------------------------------------------------------
// Pub/Sub
// -----------------------------------------------------------------------------

actor PubSubClient {
    state config: GcpConfig
    
    init(config: GcpConfig) { self.config = config }
    
    // Topics
    on create_topic(name: String) -> Result<Topic, GcpError> {
        @native("gcp_pubsub_create_topic", self.config, name)
    }
    
    on get_topic(name: String) -> Result<Topic, GcpError> {
        @native("gcp_pubsub_get_topic", self.config, name)
    }
    
    on list_topics() -> Result<[Topic], GcpError> {
        @native("gcp_pubsub_list_topics", self.config)
    }
    
    on delete_topic(name: String) -> Result<(), GcpError> {
        @native("gcp_pubsub_delete_topic", self.config, name)
    }
    
    on publish(topic: String, data: [Byte], attributes: Map<String, String> = Map.empty()) -> Result<String, GcpError> {
        @native("gcp_pubsub_publish", self.config, topic, data, attributes)
    }
    
    on publish_json<T: Serialize>(topic: String, data: T) -> Result<String, GcpError> {
        self.publish(topic, json.encode(data).bytes(), Map.empty())
    }
    
    // Subscriptions
    on create_subscription(name: String, topic: String, ack_deadline: Int = 10) -> Result<PubSubSubscription, GcpError> {
        @native("gcp_pubsub_create_subscription", self.config, name, topic, ack_deadline)
    }
    
    on get_subscription(name: String) -> Result<PubSubSubscription, GcpError> {
        @native("gcp_pubsub_get_subscription", self.config, name)
    }
    
    on list_subscriptions(topic: String? = None) -> Result<[PubSubSubscription], GcpError> {
        @native("gcp_pubsub_list_subscriptions", self.config, topic)
    }
    
    on delete_subscription(name: String) -> Result<(), GcpError> {
        @native("gcp_pubsub_delete_subscription", self.config, name)
    }
    
    on pull(subscription: String, max_messages: Int = 10) -> Result<[ReceivedMessage], GcpError> {
        @native("gcp_pubsub_pull", self.config, subscription, max_messages)
    }
    
    on acknowledge(subscription: String, ack_ids: [String]) -> Result<(), GcpError> {
        @native("gcp_pubsub_acknowledge", self.config, subscription, ack_ids)
    }
}

struct Topic { name: String, labels: Map<String, String> }
struct PubSubSubscription { name: String, topic: String, ack_deadline_seconds: Int, push_config: PushConfig? }
struct PushConfig { push_endpoint: String, attributes: Map<String, String> }
struct ReceivedMessage { ack_id: String, message: PubSubMessage }
struct PubSubMessage { message_id: String, data: [Byte], attributes: Map<String, String>, publish_time: DateTime }

// -----------------------------------------------------------------------------
// Cloud Functions
// -----------------------------------------------------------------------------

actor FunctionsClient {
    state config: GcpConfig
    
    init(config: GcpConfig) { self.config = config }
    
    on list_functions(location: String) -> Result<[CloudFunction], GcpError> {
        @native("gcp_functions_list", self.config, location)
    }
    
    on get_function(location: String, name: String) -> Result<CloudFunction, GcpError> {
        @native("gcp_functions_get", self.config, location, name)
    }
    
    on create_function(location: String, params: CreateFunctionParams) -> Result<Operation, GcpError> {
        @native("gcp_functions_create", self.config, location, params)
    }
    
    on delete_function(location: String, name: String) -> Result<Operation, GcpError> {
        @native("gcp_functions_delete", self.config, location, name)
    }
    
    on call_function(location: String, name: String, data: String) -> Result<String, GcpError> {
        @native("gcp_functions_call", self.config, location, name, data)
    }
}

struct CloudFunction {
    name: String
    status: FunctionStatus
    entry_point: String
    runtime: String
    timeout: Duration
    available_memory_mb: Int
    https_trigger: HttpsTrigger?
    event_trigger: EventTrigger?
}

enum FunctionStatus { Active, Offline, DeployInProgress, DeleteInProgress, Unknown }
struct HttpsTrigger { url: String }
struct EventTrigger { event_type: String, resource: String }

struct CreateFunctionParams {
    name: String
    entry_point: String
    runtime: String
    source_archive_url: String?
    source_repository: String?
    timeout: Duration
    available_memory_mb: Int
    environment_variables: Map<String, String>
    https_trigger: Bool
    event_trigger: EventTrigger?
}

// -----------------------------------------------------------------------------
// BigQuery
// -----------------------------------------------------------------------------

actor BigQueryClient {
    state config: GcpConfig
    
    init(config: GcpConfig) { self.config = config }
    
    on list_datasets() -> Result<[Dataset], GcpError> {
        @native("gcp_bigquery_list_datasets", self.config)
    }
    
    on create_dataset(dataset_id: String, location: String = "US") -> Result<Dataset, GcpError> {
        @native("gcp_bigquery_create_dataset", self.config, dataset_id, location)
    }
    
    on delete_dataset(dataset_id: String, delete_contents: Bool = false) -> Result<(), GcpError> {
        @native("gcp_bigquery_delete_dataset", self.config, dataset_id, delete_contents)
    }
    
    on list_tables(dataset_id: String) -> Result<[TableInfo], GcpError> {
        @native("gcp_bigquery_list_tables", self.config, dataset_id)
    }
    
    on create_table(dataset_id: String, table_id: String, schema: [SchemaField]) -> Result<TableInfo, GcpError> {
        @native("gcp_bigquery_create_table", self.config, dataset_id, table_id, schema)
    }
    
    on query(sql: String, params: Map<String, Value> = Map.empty()) -> Result<QueryResult, GcpError> {
        @native("gcp_bigquery_query", self.config, sql, params)
    }
    
    on insert_rows(dataset_id: String, table_id: String, rows: [Map<String, Value>]) -> Result<InsertResult, GcpError> {
        @native("gcp_bigquery_insert_rows", self.config, dataset_id, table_id, rows)
    }
}

struct Dataset { dataset_id: String, project_id: String, location: String, creation_time: DateTime }
struct TableInfo { table_id: String, dataset_id: String, type_: String, creation_time: DateTime, num_rows: Int64 }
struct SchemaField { name: String, type_: String, mode: String, description: String? }
struct QueryResult { rows: [Map<String, Value>], total_rows: Int64, schema: [SchemaField] }
struct InsertResult { insert_errors: [InsertError] }
struct InsertError { index: Int, errors: [ErrorProto] }
struct ErrorProto { reason: String, message: String }

// -----------------------------------------------------------------------------
// IAM
// -----------------------------------------------------------------------------

actor IamClient {
    state config: GcpConfig
    
    init(config: GcpConfig) { self.config = config }
    
    on get_iam_policy(resource: String) -> Result<IamPolicy, GcpError> {
        @native("gcp_iam_get_policy", self.config, resource)
    }
    
    on set_iam_policy(resource: String, policy: IamPolicy) -> Result<IamPolicy, GcpError> {
        @native("gcp_iam_set_policy", self.config, resource, policy)
    }
    
    on list_service_accounts() -> Result<[ServiceAccount], GcpError> {
        @native("gcp_iam_list_service_accounts", self.config)
    }
    
    on create_service_account(account_id: String, display_name: String) -> Result<ServiceAccount, GcpError> {
        @native("gcp_iam_create_service_account", self.config, account_id, display_name)
    }
    
    on delete_service_account(email: String) -> Result<(), GcpError> {
        @native("gcp_iam_delete_service_account", self.config, email)
    }
    
    on create_service_account_key(email: String) -> Result<ServiceAccountKey, GcpError> {
        @native("gcp_iam_create_sa_key", self.config, email)
    }
}

struct IamPolicy { version: Int, bindings: [Binding], etag: String }
struct Binding { role: String, members: [String], condition: Condition? }
struct Condition { title: String, description: String?, expression: String }
struct ServiceAccount { name: String, email: String, unique_id: String, display_name: String }
struct ServiceAccountKey { name: String, private_key_data: String, valid_after_time: DateTime, valid_before_time: DateTime }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum GcpError {
    Authentication(String)
    PermissionDenied(String)
    NotFound(String)
    AlreadyExists(String)
    InvalidArgument(String)
    QuotaExceeded(String)
    ServiceError(String, Int)
    Timeout
    NetworkError(String)
    
    fn message() -> String {
        match self {
            .Authentication(m) => "Authentication error: \(m)"
            .PermissionDenied(m) => "Permission denied: \(m)"
            .NotFound(m) => "Not found: \(m)"
            .AlreadyExists(m) => "Already exists: \(m)"
            .InvalidArgument(m) => "Invalid argument: \(m)"
            .QuotaExceeded(m) => "Quota exceeded: \(m)"
            .ServiceError(m, c) => "Service error (\(c)): \(m)"
            .Timeout => "Request timed out"
            .NetworkError(m) => "Network error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "gcp config" {
    let config = GcpConfig.new("my-project").with_region("us-central1")
    assert(config.project_id == "my-project")
    assert(config.region == Some("us-central1"))
}

test "create instance params" {
    let params = CreateInstanceParams.new("my-vm", "n1-standard-1", "projects/debian-cloud/global/images/debian-11")
    assert(params.name == "my-vm")
    assert(params.disk_size_gb == 10)
}

test "instance status" {
    let status = InstanceStatus.Running
    match status {
        .Running => assert(true)
        _ => assert(false)
    }
}
