// =============================================================================
// Vibee OS â€” SMS Verification Module
// Phone number verification via SMS OTP codes
// =============================================================================

use sms_sender.{SmsSender, SmsMessage, SmsResult, SmsError, SmsProvider}
use crypto.{random_bytes, constant_time_compare}
use sms_template.{SmsTemplate, TemplateEngine}

// =============================================================================
// Verification Service
// =============================================================================

/// SMS verification service
struct SmsVerificationService {
    sender: SmsSender
    store: Box<dyn VerificationStore>
    config: VerificationConfig
    template: Option<SmsTemplate>
}

struct VerificationConfig {
    code_length: Int
    code_type: CodeType
    expiry_seconds: Int64
    max_attempts: Int
    cooldown_seconds: Int64
    rate_limit_per_phone: Int
    rate_limit_window_seconds: Int64
    default_message: String
}

enum CodeType {
    Numeric
    Alphanumeric
    AlphanumericUppercase
}

impl VerificationConfig {
    fn default() -> Self {
        VerificationConfig {
            code_length: 6,
            code_type: CodeType.Numeric,
            expiry_seconds: 300,  // 5 minutes
            max_attempts: 3,
            cooldown_seconds: 60,
            rate_limit_per_phone: 5,
            rate_limit_window_seconds: 3600,
            default_message: "Your verification code is: {code}. Valid for {expiry} minutes."
        }
    }
    
    fn code_length(len: Int) -> Self { self.code_length = len; self }
    fn numeric() -> Self { self.code_type = CodeType.Numeric; self }
    fn alphanumeric() -> Self { self.code_type = CodeType.Alphanumeric; self }
    fn expiry(seconds: Int64) -> Self { self.expiry_seconds = seconds; self }
    fn max_attempts(n: Int) -> Self { self.max_attempts = n; self }
    fn cooldown(seconds: Int64) -> Self { self.cooldown_seconds = seconds; self }
    fn rate_limit(count: Int, window_seconds: Int64) -> Self {
        self.rate_limit_per_phone = count
        self.rate_limit_window_seconds = window_seconds
        self
    }
    fn message(msg: String) -> Self { self.default_message = msg; self }
}

impl SmsVerificationService {
    fn new(sender: SmsSender, store: Box<dyn VerificationStore>) -> Self {
        SmsVerificationService {
            sender: sender,
            store: store,
            config: VerificationConfig.default(),
            template: None
        }
    }
    
    fn with_config(config: VerificationConfig) -> Self { self.config = config; self }
    fn with_template(template: SmsTemplate) -> Self { self.template = Some(template); self }
    
    /// Send verification code to phone number
    fn send(phone: String) -> Result<VerificationSession, VerificationError> {
        self.send_with_context(phone, None)
    }
    
    /// Send verification code with additional context
    fn send_with_context(phone: String, context: Option<String>) -> Result<VerificationSession, VerificationError> {
        // Check rate limit
        self.check_rate_limit(phone.clone())?
        
        // Check cooldown
        if let Some(last) = self.store.get_last_sent(phone.clone()) {
            let elapsed = Instant.now().duration_since(last).as_secs()
            if elapsed < self.config.cooldown_seconds {
                let remaining = self.config.cooldown_seconds - elapsed
                return Err(VerificationError.Cooldown(remaining))
            }
        }
        
        // Generate code
        let code = self.generate_code()
        let code_hash = self.hash_code(code.clone())
        
        // Create session
        let session = VerificationSession {
            id: UUID.v4(),
            phone: phone.clone(),
            code_hash: code_hash,
            context: context,
            attempts: 0,
            max_attempts: self.config.max_attempts,
            created_at: Instant.now(),
            expires_at: Instant.now() + Duration.seconds(self.config.expiry_seconds),
            verified_at: None,
            status: VerificationStatus.Pending
        }
        
        // Store session
        self.store.save(session.clone())?
        self.store.record_sent(phone.clone())
        
        // Build message
        let message = self.build_message(code.clone())
        
        // Send SMS
        self.sender.send(phone, message)
            .map_err(|e| VerificationError.SendFailed(e.to_string()))?
        
        Ok(session)
    }
    
    /// Verify the code
    fn verify(session_id: String, code: String) -> Result<VerificationResult, VerificationError> {
        let mut session = self.store.get(session_id.clone())
            .ok_or(VerificationError.SessionNotFound)?
        
        // Check if already verified
        if session.status == VerificationStatus.Verified {
            return Ok(VerificationResult.AlreadyVerified)
        }
        
        // Check if expired
        if Instant.now() > session.expires_at {
            session.status = VerificationStatus.Expired
            self.store.save(session)?
            return Err(VerificationError.Expired)
        }
        
        // Check attempts
        if session.attempts >= session.max_attempts {
            session.status = VerificationStatus.MaxAttemptsReached
            self.store.save(session)?
            return Err(VerificationError.MaxAttemptsReached)
        }
        
        // Increment attempts
        session.attempts += 1
        
        // Verify code
        let code_hash = self.hash_code(code)
        if constant_time_compare(code_hash.as_bytes(), session.code_hash.as_bytes()) {
            session.status = VerificationStatus.Verified
            session.verified_at = Some(Instant.now())
            self.store.save(session.clone())?
            Ok(VerificationResult.Success(session))
        } else {
            self.store.save(session.clone())?
            let remaining = session.max_attempts - session.attempts
            Ok(VerificationResult.InvalidCode(remaining))
        }
    }
    
    /// Verify by phone number (finds latest pending session)
    fn verify_phone(phone: String, code: String) -> Result<VerificationResult, VerificationError> {
        let session = self.store.get_pending_by_phone(phone)
            .ok_or(VerificationError.SessionNotFound)?
        self.verify(session.id, code)
    }
    
    /// Resend verification code
    fn resend(session_id: String) -> Result<VerificationSession, VerificationError> {
        let session = self.store.get(session_id)
            .ok_or(VerificationError.SessionNotFound)?
        
        if session.status == VerificationStatus.Verified {
            return Err(VerificationError.AlreadyVerified)
        }
        
        // Invalidate old session
        self.store.invalidate(session.id)?
        
        // Send new code
        self.send_with_context(session.phone, session.context)
    }
    
    /// Cancel verification session
    fn cancel(session_id: String) -> Result<(), VerificationError> {
        self.store.invalidate(session_id)
    }
    
    /// Get session status
    fn get_status(session_id: String) -> Result<VerificationStatus, VerificationError> {
        let session = self.store.get(session_id)
            .ok_or(VerificationError.SessionNotFound)?
        
        if Instant.now() > session.expires_at && session.status == VerificationStatus.Pending {
            Ok(VerificationStatus.Expired)
        } else {
            Ok(session.status)
        }
    }
    
    fn generate_code() -> String {
        let chars = match self.config.code_type {
            CodeType.Numeric => "0123456789",
            CodeType.Alphanumeric => "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
            CodeType.AlphanumericUppercase => "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        }
        
        let bytes = random_bytes(self.config.code_length)
        bytes.iter().map(|b| chars.chars().nth((*b as Int) % chars.len()).unwrap()).collect()
    }
    
    fn hash_code(code: String) -> String {
        @native("sha256_hex", code)
    }
    
    fn build_message(code: String) -> String {
        let expiry_minutes = self.config.expiry_seconds / 60
        
        if let Some(ref template) = self.template {
            var vars = Map.empty()
            vars.set("code", code)
            vars.set("expiry", expiry_minutes.to_string())
            template.render(vars).unwrap_or(self.config.default_message.clone())
        } else {
            self.config.default_message
                .replace("{code}", code.as_str())
                .replace("{expiry}", expiry_minutes.to_string().as_str())
        }
    }
    
    fn check_rate_limit(phone: String) -> Result<(), VerificationError> {
        let count = self.store.get_sent_count(phone.clone(), self.config.rate_limit_window_seconds)
        if count >= self.config.rate_limit_per_phone {
            Err(VerificationError.RateLimited)
        } else {
            Ok(())
        }
    }
}

// =============================================================================
// Verification Session
// =============================================================================

struct VerificationSession {
    id: String
    phone: String
    code_hash: String
    context: Option<String>
    attempts: Int
    max_attempts: Int
    created_at: Instant
    expires_at: Instant
    verified_at: Option<Instant>
    status: VerificationStatus
}

impl VerificationSession {
    fn is_valid() -> Bool {
        self.status == VerificationStatus.Pending && Instant.now() < self.expires_at
    }
    
    fn is_verified() -> Bool { self.status == VerificationStatus.Verified }
    fn is_expired() -> Bool { Instant.now() > self.expires_at }
    fn remaining_attempts() -> Int { self.max_attempts - self.attempts }
    fn time_remaining() -> Duration { self.expires_at.duration_since(Instant.now()) }
}

enum VerificationStatus {
    Pending
    Verified
    Expired
    MaxAttemptsReached
    Cancelled
}

enum VerificationResult {
    Success(VerificationSession)
    InvalidCode(Int)  // remaining attempts
    AlreadyVerified
}

impl VerificationResult {
    fn is_success() -> Bool { match self { Success(_) => true, _ => false } }
    fn is_invalid() -> Bool { match self { InvalidCode(_) => true, _ => false } }
}

// =============================================================================
// Verification Store Trait
// =============================================================================

trait VerificationStore {
    fn save(session: VerificationSession) -> Result<(), VerificationError>
    fn get(id: String) -> Option<VerificationSession>
    fn get_pending_by_phone(phone: String) -> Option<VerificationSession>
    fn invalidate(id: String) -> Result<(), VerificationError>
    fn record_sent(phone: String)
    fn get_last_sent(phone: String) -> Option<Instant>
    fn get_sent_count(phone: String, window_seconds: Int64) -> Int
    fn cleanup_expired()
}

// =============================================================================
// In-Memory Store
// =============================================================================

struct InMemoryVerificationStore {
    sessions: Map<String, VerificationSession>
    phone_sessions: Map<String, [String]>
    sent_times: Map<String, [Instant]>
}

impl InMemoryVerificationStore {
    fn new() -> Self {
        InMemoryVerificationStore {
            sessions: Map.empty(),
            phone_sessions: Map.empty(),
            sent_times: Map.empty()
        }
    }
}

impl VerificationStore for InMemoryVerificationStore {
    fn save(session: VerificationSession) -> Result<(), VerificationError> {
        let phone = session.phone.clone()
        let id = session.id.clone()
        
        self.sessions.set(id.clone(), session)
        
        let ids = self.phone_sessions.get(phone.clone()).cloned().unwrap_or_default()
        var new_ids = ids.clone()
        if !new_ids.contains(&id) {
            new_ids.push(id)
        }
        self.phone_sessions.set(phone, new_ids)
        
        Ok(())
    }
    
    fn get(id: String) -> Option<VerificationSession> {
        self.sessions.get(id).cloned()
    }
    
    fn get_pending_by_phone(phone: String) -> Option<VerificationSession> {
        let ids = self.phone_sessions.get(phone)?
        for id in ids.iter().rev() {
            if let Some(session) = self.sessions.get(id.clone()) {
                if session.status == VerificationStatus.Pending && Instant.now() < session.expires_at {
                    return Some(session.clone())
                }
            }
        }
        None
    }
    
    fn invalidate(id: String) -> Result<(), VerificationError> {
        if let Some(mut session) = self.sessions.get_mut(id) {
            session.status = VerificationStatus.Cancelled
        }
        Ok(())
    }
    
    fn record_sent(phone: String) {
        let times = self.sent_times.get(phone.clone()).cloned().unwrap_or_default()
        var new_times = times.clone()
        new_times.push(Instant.now())
        self.sent_times.set(phone, new_times)
    }
    
    fn get_last_sent(phone: String) -> Option<Instant> {
        self.sent_times.get(phone).and_then(|times| times.last().cloned())
    }
    
    fn get_sent_count(phone: String, window_seconds: Int64) -> Int {
        let cutoff = Instant.now() - Duration.seconds(window_seconds)
        self.sent_times.get(phone)
            .map(|times| times.iter().filter(|t| **t > cutoff).count())
            .unwrap_or(0)
    }
    
    fn cleanup_expired() {
        let now = Instant.now()
        let expired: Vec<String> = self.sessions.iter()
            .filter(|(_, s)| s.expires_at < now && s.status == VerificationStatus.Pending)
            .map(|(id, _)| id.clone())
            .collect()
        
        for id in expired {
            if let Some(mut session) = self.sessions.get_mut(id) {
                session.status = VerificationStatus.Expired
            }
        }
    }
}

// =============================================================================
// Verification Actor
// =============================================================================

actor VerificationActor {
    state service: SmsVerificationService
    state cleanup_interval: Duration
    
    fn new(service: SmsVerificationService) -> Self {
        VerificationActor {
            service: service,
            cleanup_interval: Duration.minutes(5)
        }
    }
    
    fn start() {
        spawn {
            loop {
                @native("sleep", self.cleanup_interval)
                self.service.store.cleanup_expired()
            }
        }
    }
    
    fn send(phone: String) -> Result<VerificationSession, VerificationError> {
        self.service.send(phone)
    }
    
    fn verify(session_id: String, code: String) -> Result<VerificationResult, VerificationError> {
        self.service.verify(session_id, code)
    }
    
    fn verify_phone(phone: String, code: String) -> Result<VerificationResult, VerificationError> {
        self.service.verify_phone(phone, code)
    }
    
    fn resend(session_id: String) -> Result<VerificationSession, VerificationError> {
        self.service.resend(session_id)
    }
    
    fn cancel(session_id: String) -> Result<(), VerificationError> {
        self.service.cancel(session_id)
    }
    
    fn status(session_id: String) -> Result<VerificationStatus, VerificationError> {
        self.service.get_status(session_id)
    }
}

// =============================================================================
// Phone Verification Flow
// =============================================================================

/// High-level phone verification flow
struct PhoneVerificationFlow {
    service: SmsVerificationService
    on_verified: Option<fn(String)>
    on_failed: Option<fn(String, VerificationError)>
}

impl PhoneVerificationFlow {
    fn new(service: SmsVerificationService) -> Self {
        PhoneVerificationFlow {
            service: service,
            on_verified: None,
            on_failed: None
        }
    }
    
    fn on_verified(callback: fn(String)) -> Self { self.on_verified = Some(callback); self }
    fn on_failed(callback: fn(String, VerificationError)) -> Self { self.on_failed = Some(callback); self }
    
    fn start(phone: String) -> Result<String, VerificationError> {
        let session = self.service.send(phone)?
        Ok(session.id)
    }
    
    fn complete(session_id: String, code: String) -> Result<Bool, VerificationError> {
        match self.service.verify(session_id.clone(), code) {
            Ok(VerificationResult.Success(session)) => {
                if let Some(callback) = self.on_verified {
                    callback(session.phone)
                }
                Ok(true)
            }
            Ok(VerificationResult.InvalidCode(remaining)) => {
                Ok(false)
            }
            Ok(VerificationResult.AlreadyVerified) => {
                Ok(true)
            }
            Err(e) => {
                if let Some(callback) = self.on_failed {
                    callback(session_id, e.clone())
                }
                Err(e)
            }
        }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum VerificationError {
    SessionNotFound
    Expired
    MaxAttemptsReached
    AlreadyVerified
    Cooldown(Int64)
    RateLimited
    SendFailed(String)
    StoreError(String)
    InvalidPhone
}

impl Display for VerificationError {
    fn fmt(f: Formatter) {
        match self {
            SessionNotFound => f.write("Verification session not found"),
            Expired => f.write("Verification code expired"),
            MaxAttemptsReached => f.write("Maximum verification attempts reached"),
            AlreadyVerified => f.write("Phone already verified"),
            Cooldown(secs) => f.write(format!("Please wait {} seconds before requesting a new code", secs)),
            RateLimited => f.write("Too many verification requests"),
            SendFailed(msg) => f.write(format!("Failed to send SMS: {}", msg)),
            StoreError(msg) => f.write(format!("Store error: {}", msg)),
            InvalidPhone => f.write("Invalid phone number")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "verification config" {
    let config = VerificationConfig.default()
        .code_length(4)
        .numeric()
        .expiry(600)
        .max_attempts(5)
    
    assert_eq(config.code_length, 4)?
    assert_eq(config.expiry_seconds, 600)?
    assert_eq(config.max_attempts, 5)?
}

test "in memory store" {
    let mut store = InMemoryVerificationStore.new()
    
    let session = VerificationSession {
        id: "test-123",
        phone: "+1234567890",
        code_hash: "hash",
        context: None,
        attempts: 0,
        max_attempts: 3,
        created_at: Instant.now(),
        expires_at: Instant.now() + Duration.minutes(5),
        verified_at: None,
        status: VerificationStatus.Pending
    }
    
    store.save(session.clone())?
    
    let retrieved = store.get("test-123")
    assert(retrieved.is_some())?
    assert_eq(retrieved.unwrap().phone, "+1234567890")?
}

test "verification session validity" {
    let valid_session = VerificationSession {
        id: "test",
        phone: "+1234",
        code_hash: "hash",
        context: None,
        attempts: 0,
        max_attempts: 3,
        created_at: Instant.now(),
        expires_at: Instant.now() + Duration.minutes(5),
        verified_at: None,
        status: VerificationStatus.Pending
    }
    
    assert(valid_session.is_valid())?
    assert_eq(valid_session.remaining_attempts(), 3)?
}

test "verification result" {
    let success = VerificationResult.Success(VerificationSession {
        id: "test",
        phone: "+1234",
        code_hash: "hash",
        context: None,
        attempts: 1,
        max_attempts: 3,
        created_at: Instant.now(),
        expires_at: Instant.now() + Duration.minutes(5),
        verified_at: Some(Instant.now()),
        status: VerificationStatus.Verified
    })
    
    assert(success.is_success())?
    
    let invalid = VerificationResult.InvalidCode(2)
    assert(invalid.is_invalid())?
}
