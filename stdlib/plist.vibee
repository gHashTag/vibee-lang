// =============================================================================
// Vibee OS â€” Property List Module
// Apple Property List (plist) parsing and generation
// =============================================================================

// -----------------------------------------------------------------------------
// Plist Value
// -----------------------------------------------------------------------------

enum Value {
    String(String)
    Int(Int)
    Real(Float)
    Bool(Bool)
    Date(DateTime)
    Data(Bytes)
    Array([Value])
    Dict(Map<String, Value>)
    
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_int() -> Option<Int> { match self { .Int(i) => Some(i), _ => None } }
    fn as_real() -> Option<Float> { match self { .Real(f) => Some(f), _ => None } }
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    fn as_date() -> Option<DateTime> { match self { .Date(d) => Some(d), _ => None } }
    fn as_data() -> Option<Bytes> { match self { .Data(d) => Some(d), _ => None } }
    fn as_array() -> Option<[Value]> { match self { .Array(a) => Some(a), _ => None } }
    fn as_dict() -> Option<Map<String, Value>> { match self { .Dict(d) => Some(d), _ => None } }
    
    fn get(key: String) -> Option<Value> { match self { .Dict(d) => d.get(key), _ => None } }
    fn at(idx: Int) -> Option<Value> { match self { .Array(a) if idx >= 0 && idx < a.len() => Some(a[idx]), _ => None } }
    
    fn path(p: String) -> Option<Value> {
        let parts = p.split(".")
        var current = self
        for part in parts { current = current.get(part)? }
        Some(current)
    }
}

impl Index<String> for Value {
    type Output = Option<Value>
    fn index(key: String) -> Option<Value> { self.get(key) }
}

// -----------------------------------------------------------------------------
// XML Parser
// -----------------------------------------------------------------------------

actor XMLParser {
    state input: String
    state pos: Int
    
    fn new(input: String) -> Self { XMLParser { input: input, pos: 0 } }
    
    fn parse() -> Result<Value, PlistError> {
        self.skip_xml_header()
        self.skip_doctype()
        self.skip_whitespace()
        self.expect_tag("plist")?
        self.skip_whitespace()
        let value = self.parse_value()?
        Ok(value)
    }
    
    fn parse_value() -> Result<Value, PlistError> {
        self.skip_whitespace()
        if self.peek_str("<string>") { self.parse_string() }
        else if self.peek_str("<integer>") { self.parse_integer() }
        else if self.peek_str("<real>") { self.parse_real() }
        else if self.peek_str("<true/>") { self.advance(7); Ok(Value.Bool(true)) }
        else if self.peek_str("<false/>") { self.advance(8); Ok(Value.Bool(false)) }
        else if self.peek_str("<date>") { self.parse_date() }
        else if self.peek_str("<data>") { self.parse_data() }
        else if self.peek_str("<array>") { self.parse_array() }
        else if self.peek_str("<dict>") { self.parse_dict() }
        else { Err(PlistError.UnexpectedElement(self.pos)) }
    }
    
    fn parse_string() -> Result<Value, PlistError> {
        self.expect_tag("string")?
        let content = self.read_until("</string>")?
        self.expect_close_tag("string")?
        Ok(Value.String(self.unescape_xml(content)))
    }
    
    fn parse_integer() -> Result<Value, PlistError> {
        self.expect_tag("integer")?
        let content = self.read_until("</integer>")?
        self.expect_close_tag("integer")?
        Ok(Value.Int(Int.parse(content)?))
    }
    
    fn parse_real() -> Result<Value, PlistError> {
        self.expect_tag("real")?
        let content = self.read_until("</real>")?
        self.expect_close_tag("real")?
        Ok(Value.Real(Float.parse(content)?))
    }
    
    fn parse_date() -> Result<Value, PlistError> {
        self.expect_tag("date")?
        let content = self.read_until("</date>")?
        self.expect_close_tag("date")?
        Ok(Value.Date(DateTime.parse_iso8601(content)?))
    }
    
    fn parse_data() -> Result<Value, PlistError> {
        self.expect_tag("data")?
        let content = self.read_until("</data>")?
        self.expect_close_tag("data")?
        Ok(Value.Data(Base64.decode(content.trim())?))
    }
    
    fn parse_array() -> Result<Value, PlistError> {
        self.expect_tag("array")?
        var items = []
        self.skip_whitespace()
        while !self.peek_str("</array>") {
            items.append(self.parse_value()?)
            self.skip_whitespace()
        }
        self.expect_close_tag("array")?
        Ok(Value.Array(items))
    }
    
    fn parse_dict() -> Result<Value, PlistError> {
        self.expect_tag("dict")?
        var map = Map.empty()
        self.skip_whitespace()
        while !self.peek_str("</dict>") {
            self.expect_tag("key")?
            let key = self.read_until("</key>")?
            self.expect_close_tag("key")?
            self.skip_whitespace()
            let value = self.parse_value()?
            map.set(key, value)
            self.skip_whitespace()
        }
        self.expect_close_tag("dict")?
        Ok(Value.Dict(map))
    }
    
    fn skip_xml_header() {
        if self.peek_str("<?xml") {
            while self.pos < self.input.len() && !self.peek_str("?>") { self.pos += 1 }
            self.pos += 2
        }
    }
    
    fn skip_doctype() {
        self.skip_whitespace()
        if self.peek_str("<!DOCTYPE") {
            while self.pos < self.input.len() && self.input[self.pos] != '>' { self.pos += 1 }
            self.pos += 1
        }
    }
    
    fn expect_tag(name: String) -> Result<(), PlistError> {
        let tag = "<\(name)>"
        if self.peek_str(tag) { self.advance(tag.len()); Ok(()) }
        else { Err(PlistError.ExpectedTag(name, self.pos)) }
    }
    
    fn expect_close_tag(name: String) -> Result<(), PlistError> {
        let tag = "</\(name)>"
        if self.peek_str(tag) { self.advance(tag.len()); Ok(()) }
        else { Err(PlistError.ExpectedCloseTag(name, self.pos)) }
    }
    
    fn read_until(end: String) -> Result<String, PlistError> {
        let start = self.pos
        while self.pos < self.input.len() && !self.peek_str(end) { self.pos += 1 }
        Ok(self.input[start..self.pos])
    }
    
    fn unescape_xml(s: String) -> String {
        s.replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&").replace("&quot;", "\"").replace("&apos;", "'")
    }
    
    fn peek_str(s: String) -> Bool { self.input[self.pos..].starts_with(s) }
    fn advance(n: Int) { self.pos += n }
    fn skip_whitespace() { while self.pos < self.input.len() && self.input[self.pos].is_whitespace() { self.pos += 1 } }
}

// -----------------------------------------------------------------------------
// XML Emitter
// -----------------------------------------------------------------------------

actor XMLEmitter {
    state indent: Int
    
    fn new() -> Self { XMLEmitter { indent: 0 } }
    
    fn emit(value: Value) -> String {
        var result = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        result += "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n"
        result += "<plist version=\"1.0\">\n"
        result += self.emit_value(value)
        result += "</plist>\n"
        result
    }
    
    fn emit_value(value: Value) -> String {
        match value {
            .String(s) => self.line("<string>\(self.escape_xml(s))</string>")
            .Int(i) => self.line("<integer>\(i)</integer>")
            .Real(f) => self.line("<real>\(f)</real>")
            .Bool(b) => self.line(if b { "<true/>" } else { "<false/>" })
            .Date(d) => self.line("<date>\(d.to_iso8601())</date>")
            .Data(d) => self.line("<data>\(Base64.encode(d))</data>")
            .Array(a) => self.emit_array(a)
            .Dict(d) => self.emit_dict(d)
        }
    }
    
    fn emit_array(items: [Value]) -> String {
        var result = self.line("<array>")
        self.indent += 1
        for item in items { result += self.emit_value(item) }
        self.indent -= 1
        result += self.line("</array>")
        result
    }
    
    fn emit_dict(map: Map<String, Value>) -> String {
        var result = self.line("<dict>")
        self.indent += 1
        for (key, value) in map {
            result += self.line("<key>\(self.escape_xml(key))</key>")
            result += self.emit_value(value)
        }
        self.indent -= 1
        result += self.line("</dict>")
        result
    }
    
    fn line(content: String) -> String { "\t".repeat(self.indent) + content + "\n" }
    fn escape_xml(s: String) -> String { s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;") }
}

// -----------------------------------------------------------------------------
// Binary Parser (simplified)
// -----------------------------------------------------------------------------

actor BinaryParser {
    state data: Bytes
    state pos: Int
    state offset_size: Int
    state ref_size: Int
    state num_objects: Int
    state offsets: [Int]
    
    fn new(data: Bytes) -> Self {
        BinaryParser { data: data, pos: 0, offset_size: 0, ref_size: 0, num_objects: 0, offsets: [] }
    }
    
    fn parse() -> Result<Value, PlistError> {
        if !self.data.starts_with("bplist") { return Err(PlistError.InvalidBinaryHeader) }
        self.read_trailer()?
        self.read_offsets()?
        self.read_object(0)
    }
    
    fn read_trailer() -> Result<(), PlistError> {
        let trailer_start = self.data.len() - 32
        self.offset_size = self.data[trailer_start + 6] as Int
        self.ref_size = self.data[trailer_start + 7] as Int
        self.num_objects = self.read_int_at(trailer_start + 8, 8)
        Ok(())
    }
    
    fn read_offsets() -> Result<(), PlistError> {
        let offset_table_start = self.data.len() - 32 - (self.num_objects * self.offset_size)
        for i in 0..self.num_objects {
            self.offsets.append(self.read_int_at(offset_table_start + i * self.offset_size, self.offset_size))
        }
        Ok(())
    }
    
    fn read_object(idx: Int) -> Result<Value, PlistError> {
        self.pos = self.offsets[idx]
        let marker = self.data[self.pos]
        let type_byte = marker >> 4
        let size_nibble = marker & 0x0F
        self.pos += 1
        
        match type_byte {
            0x0 => if size_nibble == 0x08 { Ok(Value.Bool(false)) } else if size_nibble == 0x09 { Ok(Value.Bool(true)) } else { Err(PlistError.InvalidType) }
            0x1 => Ok(Value.Int(self.read_int(1 << size_nibble)))
            0x2 => Ok(Value.Real(self.read_float(1 << size_nibble)))
            0x5 => Ok(Value.String(self.read_ascii_string(self.get_size(size_nibble))))
            0x6 => Ok(Value.String(self.read_utf16_string(self.get_size(size_nibble))))
            0xA => self.read_array(self.get_size(size_nibble))
            0xD => self.read_dict(self.get_size(size_nibble))
            _ => Err(PlistError.InvalidType)
        }
    }
    
    fn get_size(nibble: Int) -> Int {
        if nibble == 0x0F { let s = self.data[self.pos] & 0x0F; self.pos += 1; self.read_int(1 << s) }
        else { nibble }
    }
    
    fn read_int(size: Int) -> Int {
        var result = 0
        for i in 0..size { result = (result << 8) | (self.data[self.pos + i] as Int) }
        self.pos += size
        result
    }
    
    fn read_int_at(offset: Int, size: Int) -> Int {
        var result = 0
        for i in 0..size { result = (result << 8) | (self.data[offset + i] as Int) }
        result
    }
    
    fn read_float(size: Int) -> Float {
        let bytes = self.data[self.pos..self.pos + size]
        self.pos += size
        Float.from_be_bytes(bytes)
    }
    
    fn read_ascii_string(len: Int) -> String {
        let s = String.from_utf8(self.data[self.pos..self.pos + len])
        self.pos += len
        s
    }
    
    fn read_utf16_string(len: Int) -> String {
        let s = String.from_utf16_be(self.data[self.pos..self.pos + len * 2])
        self.pos += len * 2
        s
    }
    
    fn read_array(count: Int) -> Result<Value, PlistError> {
        var refs = []
        for _ in 0..count { refs.append(self.read_int(self.ref_size)) }
        var items = []
        for ref in refs { items.append(self.read_object(ref)?) }
        Ok(Value.Array(items))
    }
    
    fn read_dict(count: Int) -> Result<Value, PlistError> {
        var key_refs = []
        var val_refs = []
        for _ in 0..count { key_refs.append(self.read_int(self.ref_size)) }
        for _ in 0..count { val_refs.append(self.read_int(self.ref_size)) }
        var map = Map.empty()
        for i in 0..count {
            let key = self.read_object(key_refs[i])?.as_str()?
            let val = self.read_object(val_refs[i])?
            map.set(key, val)
        }
        Ok(Value.Dict(map))
    }
}

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

fn parse(input: String) -> Result<Value, PlistError> { XMLParser.new(input).parse() }
fn parse_binary(data: Bytes) -> Result<Value, PlistError> { BinaryParser.new(data).parse() }

fn parse_file(path: String) -> Result<Value, PlistError> {
    let data = File.read_bytes(path)?
    if data.starts_with("bplist") { parse_binary(data) }
    else { parse(String.from_utf8(data)) }
}

fn to_xml(value: Value) -> String { XMLEmitter.new().emit(value) }

fn save(path: String, value: Value) -> Result<(), PlistError> {
    File.write_string(path, to_xml(value))?
    Ok(())
}

// -----------------------------------------------------------------------------
// Builder
// -----------------------------------------------------------------------------

struct Builder {
    stack: [Value]
    
    fn new() -> Self { Builder { stack: [Value.Dict(Map.empty())] } }
    fn dict() -> Self { Builder { stack: [Value.Dict(Map.empty())] } }
    fn array() -> Self { Builder { stack: [Value.Array([])] } }
    
    fn set(key: String, value: Value) -> Self {
        if let .Dict(d) = self.stack.last() { d.set(key, value) }
        self
    }
    
    fn string(key: String, value: String) -> Self { self.set(key, Value.String(value)) }
    fn int(key: String, value: Int) -> Self { self.set(key, Value.Int(value)) }
    fn real(key: String, value: Float) -> Self { self.set(key, Value.Real(value)) }
    fn bool(key: String, value: Bool) -> Self { self.set(key, Value.Bool(value)) }
    
    fn add(value: Value) -> Self {
        if let .Array(a) = self.stack.last() { a.append(value) }
        self
    }
    
    fn build() -> Value { self.stack[0] }
}

fn builder() -> Builder { Builder.new() }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum PlistError {
    UnexpectedElement(Int)
    ExpectedTag(String, Int)
    ExpectedCloseTag(String, Int)
    InvalidBinaryHeader
    InvalidType
    IOError(String)
    
    fn message() -> String {
        match self {
            .UnexpectedElement(p) => "Unexpected element at position \(p)"
            .ExpectedTag(t, p) => "Expected <\(t)> at position \(p)"
            .ExpectedCloseTag(t, p) => "Expected </\(t)> at position \(p)"
            .InvalidBinaryHeader => "Invalid binary plist header"
            .InvalidType => "Invalid plist type"
            .IOError(m) => "I/O error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse xml plist" {
    let xml = "<?xml version=\"1.0\"?><!DOCTYPE plist><plist version=\"1.0\"><dict><key>name</key><string>Test</string><key>count</key><integer>42</integer></dict></plist>"
    let v = parse(xml)?
    assert(v["name"]?.as_str() == Some("Test"))
    assert(v["count"]?.as_int() == Some(42))
}

test "emit xml plist" {
    let v = builder().string("app", "MyApp").int("version", 1).bool("enabled", true).build()
    let xml = to_xml(v)
    assert(xml.contains("<string>MyApp</string>"))
    assert(xml.contains("<integer>1</integer>"))
    assert(xml.contains("<true/>"))
}

test "nested structures" {
    let xml = "<?xml version=\"1.0\"?><plist version=\"1.0\"><dict><key>items</key><array><string>a</string><string>b</string></array></dict></plist>"
    let v = parse(xml)?
    assert(v["items"]?.at(0)?.as_str() == Some("a"))
}
