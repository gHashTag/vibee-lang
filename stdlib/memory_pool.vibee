// =============================================================================
// Vibee OS â€” Memory Pool Module
// Efficient memory pooling and object reuse
// =============================================================================

// -----------------------------------------------------------------------------
// Fixed Size Pool
// -----------------------------------------------------------------------------

/// Fixed-size memory pool for objects of same size
actor FixedPool<T> {
    state block_size: Int
    state capacity: Int
    state free_list: [*T]
    state allocated: [*T]
    state memory: *UInt8
    state stats: PoolStats
    
    fn new(capacity: Int) -> Self {
        let block_size = @native("size_of", T)
        let total_size = block_size * capacity
        let memory = @native("allocate_raw", total_size)
        
        var free_list = []
        for i in 0..capacity {
            let ptr = (memory as Int + i * block_size) as *T
            free_list.push(ptr)
        }
        
        FixedPool {
            block_size: block_size,
            capacity: capacity,
            free_list: free_list,
            allocated: [],
            memory: memory,
            stats: PoolStats.new()
        }
    }
    
    /// Allocate object from pool
    on allocate() -> Option<*T> {
        if self.free_list.is_empty() {
            self.stats.allocation_failures += 1
            return None
        }
        
        let ptr = self.free_list.pop().unwrap()
        self.allocated.push(ptr)
        self.stats.allocations += 1
        self.stats.current_used += 1
        self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
        
        Some(ptr)
    }
    
    /// Allocate and initialize object
    on allocate_init(value: T) -> Option<*T> {
        match self.allocate() {
            Some(ptr) => {
                *ptr = value
                Some(ptr)
            }
            None => None
        }
    }
    
    /// Return object to pool
    on deallocate(ptr: *T) {
        if !self.is_from_pool(ptr) {
            return
        }
        
        self.allocated.retain(|p| p != ptr)
        self.free_list.push(ptr)
        self.stats.deallocations += 1
        self.stats.current_used -= 1
    }
    
    /// Check if pointer belongs to this pool
    fn is_from_pool(ptr: *T) -> Bool {
        let addr = ptr as Int
        let start = self.memory as Int
        let end = start + self.block_size * self.capacity
        addr >= start && addr < end
    }
    
    fn available() -> Int { self.free_list.len() }
    fn used() -> Int { self.allocated.len() }
    fn capacity() -> Int { self.capacity }
    fn is_empty() -> Bool { self.free_list.is_empty() }
    fn is_full() -> Bool { self.free_list.len() == self.capacity }
    fn stats() -> PoolStats { self.stats }
    
    /// Reset pool (deallocate all)
    on reset() {
        self.free_list.clear()
        self.allocated.clear()
        
        for i in 0..self.capacity {
            let ptr = (self.memory as Int + i * self.block_size) as *T
            self.free_list.push(ptr)
        }
        
        self.stats.current_used = 0
    }
}

impl<T> Drop for FixedPool<T> {
    fn drop() {
        @native("deallocate_raw", self.memory, self.block_size * self.capacity)
    }
}

// -----------------------------------------------------------------------------
// Slab Allocator
// -----------------------------------------------------------------------------

/// Slab allocator for efficient object allocation
actor SlabAllocator<T> {
    state slabs: [Slab<T>]
    state slab_size: Int
    state stats: PoolStats
    
    fn new() -> Self {
        Self.with_slab_size(64)
    }
    
    fn with_slab_size(size: Int) -> Self {
        SlabAllocator {
            slabs: [Slab.new(size)],
            slab_size: size,
            stats: PoolStats.new()
        }
    }
    
    /// Allocate object
    on allocate() -> *T {
        // Find slab with free space
        for slab in self.slabs {
            if !slab.is_full() {
                self.stats.allocations += 1
                self.stats.current_used += 1
                self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
                return slab.allocate()
            }
        }
        
        // Create new slab
        let new_slab = Slab.new(self.slab_size)
        let ptr = new_slab.allocate()
        self.slabs.push(new_slab)
        
        self.stats.allocations += 1
        self.stats.current_used += 1
        self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
        
        ptr
    }
    
    /// Allocate and initialize
    on allocate_init(value: T) -> *T {
        let ptr = self.allocate()
        *ptr = value
        ptr
    }
    
    /// Deallocate object
    on deallocate(ptr: *T) {
        for slab in self.slabs {
            if slab.contains(ptr) {
                slab.deallocate(ptr)
                self.stats.deallocations += 1
                self.stats.current_used -= 1
                return
            }
        }
    }
    
    /// Shrink by removing empty slabs
    on shrink() {
        self.slabs.retain(|s| !s.is_empty_slab())
        if self.slabs.is_empty() {
            self.slabs.push(Slab.new(self.slab_size))
        }
    }
    
    fn stats() -> PoolStats { self.stats }
    fn slab_count() -> Int { self.slabs.len() }
}

/// Single slab in slab allocator
struct Slab<T> {
    objects: [SlabEntry<T>]
    free_head: Int
    used_count: Int
    
    fn new(size: Int) -> Self {
        var objects = []
        for i in 0..size {
            objects.push(SlabEntry {
                data: @native("zeroed", T),
                next_free: if i + 1 < size { i + 1 } else { -1 },
                in_use: false
            })
        }
        
        Slab {
            objects: objects,
            free_head: 0,
            used_count: 0
        }
    }
    
    fn allocate() -> *T {
        if self.free_head == -1 {
            panic("Slab is full")
        }
        
        let idx = self.free_head
        self.free_head = self.objects[idx].next_free
        self.objects[idx].in_use = true
        self.used_count += 1
        
        &mut self.objects[idx].data
    }
    
    fn deallocate(ptr: *T) {
        for (i, entry) in self.objects.enumerate() {
            if &entry.data as *T == ptr {
                entry.in_use = false
                entry.next_free = self.free_head
                self.free_head = i
                self.used_count -= 1
                return
            }
        }
    }
    
    fn contains(ptr: *T) -> Bool {
        for entry in self.objects {
            if &entry.data as *T == ptr {
                return true
            }
        }
        false
    }
    
    fn is_full() -> Bool { self.free_head == -1 }
    fn is_empty_slab() -> Bool { self.used_count == 0 }
}

struct SlabEntry<T> {
    data: T
    next_free: Int
    in_use: Bool
}

// -----------------------------------------------------------------------------
// Object Pool
// -----------------------------------------------------------------------------

/// Generic object pool with factory
actor ObjectPool<T> {
    state pool: [T]
    state factory: () -> T
    state reset_fn: Option<(T) -> T>
    state max_size: Int
    state stats: PoolStats
    
    fn new(factory: () -> T) -> Self {
        Self.with_max_size(factory, 1000)
    }
    
    fn with_max_size(factory: () -> T, max_size: Int) -> Self {
        ObjectPool {
            pool: [],
            factory: factory,
            reset_fn: None,
            max_size: max_size,
            stats: PoolStats.new()
        }
    }
    
    /// Set reset function called when object is returned
    on with_reset(f: (T) -> T) -> Self {
        self.reset_fn = Some(f)
        self
    }
    
    /// Pre-allocate objects
    on preallocate(count: Int) {
        for _ in 0..count.min(self.max_size - self.pool.len()) {
            self.pool.push((self.factory)())
        }
    }
    
    /// Acquire object from pool
    on acquire() -> T {
        self.stats.allocations += 1
        self.stats.current_used += 1
        self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
        
        if self.pool.is_empty() {
            (self.factory)()
        } else {
            self.pool.pop().unwrap()
        }
    }
    
    /// Release object back to pool
    on release(obj: T) {
        self.stats.deallocations += 1
        self.stats.current_used -= 1
        
        if self.pool.len() < self.max_size {
            let obj = match self.reset_fn {
                Some(f) => f(obj),
                None => obj
            }
            self.pool.push(obj)
        }
    }
    
    /// Use object with automatic release
    fn with<R>(f: (T) -> R) -> R {
        let obj = self.acquire()
        let result = f(obj)
        self.release(obj)
        result
    }
    
    fn available() -> Int { self.pool.len() }
    fn stats() -> PoolStats { self.stats }
    
    /// Clear pool
    on clear() {
        self.pool.clear()
        self.stats.current_used = 0
    }
}

// -----------------------------------------------------------------------------
// Buffer Pool
// -----------------------------------------------------------------------------

/// Pool of byte buffers
actor BufferPool {
    state pools: Map<Int, [Buffer]>
    state sizes: [Int]
    state max_per_size: Int
    state stats: PoolStats
    
    fn new() -> Self {
        Self.with_sizes([64, 256, 1024, 4096, 16384, 65536])
    }
    
    fn with_sizes(sizes: [Int]) -> Self {
        var pools = Map.new()
        for size in sizes {
            pools.insert(size, [])
        }
        
        BufferPool {
            pools: pools,
            sizes: sizes.sorted(),
            max_per_size: 100,
            stats: PoolStats.new()
        }
    }
    
    /// Get buffer of at least given size
    on acquire(min_size: Int) -> Buffer {
        self.stats.allocations += 1
        self.stats.current_used += 1
        self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
        
        // Find smallest size that fits
        let size = self.find_size(min_size)
        
        if let Some(pool) = self.pools.get_mut(size) {
            if !pool.is_empty() {
                return pool.pop().unwrap()
            }
        }
        
        Buffer.with_capacity(size)
    }
    
    /// Release buffer back to pool
    on release(buf: Buffer) {
        self.stats.deallocations += 1
        self.stats.current_used -= 1
        
        let size = self.find_size(buf.capacity())
        
        if let Some(pool) = self.pools.get_mut(size) {
            if pool.len() < self.max_per_size {
                buf.clear()
                pool.push(buf)
            }
        }
    }
    
    fn find_size(min_size: Int) -> Int {
        for size in self.sizes {
            if size >= min_size {
                return size
            }
        }
        self.sizes.last().unwrap_or(min_size)
    }
    
    /// Use buffer with automatic release
    fn with<R>(min_size: Int, f: (Buffer) -> R) -> R {
        let buf = self.acquire(min_size)
        let result = f(buf)
        self.release(buf)
        result
    }
    
    fn stats() -> PoolStats { self.stats }
    
    /// Clear all pools
    on clear() {
        for (_, pool) in self.pools {
            pool.clear()
        }
    }
}

// -----------------------------------------------------------------------------
// Arena Allocator
// -----------------------------------------------------------------------------

/// Arena allocator for batch allocations
actor Arena {
    state chunks: [ArenaChunk]
    state chunk_size: Int
    state current: Int
    state stats: PoolStats
    
    fn new() -> Self {
        Self.with_chunk_size(64 * 1024)  // 64 KB chunks
    }
    
    fn with_chunk_size(size: Int) -> Self {
        Arena {
            chunks: [ArenaChunk.new(size)],
            chunk_size: size,
            current: 0,
            stats: PoolStats.new()
        }
    }
    
    /// Allocate bytes from arena
    on allocate(size: Int) -> *UInt8 {
        self.allocate_aligned(size, 8)
    }
    
    /// Allocate with alignment
    on allocate_aligned(size: Int, align: Int) -> *UInt8 {
        // Try current chunk
        if let Some(ptr) = self.chunks[self.current].allocate(size, align) {
            self.stats.allocations += 1
            self.stats.current_used += size
            self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
            return ptr
        }
        
        // Need new chunk
        let chunk_size = self.chunk_size.max(size + align)
        let new_chunk = ArenaChunk.new(chunk_size)
        self.chunks.push(new_chunk)
        self.current = self.chunks.len() - 1
        
        self.stats.allocations += 1
        self.stats.current_used += size
        self.stats.peak_used = self.stats.peak_used.max(self.stats.current_used)
        
        self.chunks[self.current].allocate(size, align).unwrap()
    }
    
    /// Allocate typed object
    on allocate_obj<T>() -> *T {
        let size = @native("size_of", T)
        let align = @native("align_of", T)
        self.allocate_aligned(size, align) as *T
    }
    
    /// Allocate and initialize object
    on allocate_init<T>(value: T) -> *T {
        let ptr = self.allocate_obj::<T>()
        *ptr = value
        ptr
    }
    
    /// Allocate array
    on allocate_array<T>(count: Int) -> *T {
        let size = @native("size_of", T) * count
        let align = @native("align_of", T)
        self.allocate_aligned(size, align) as *T
    }
    
    /// Reset arena (free all allocations)
    on reset() {
        for chunk in self.chunks {
            chunk.reset()
        }
        self.current = 0
        self.stats.current_used = 0
    }
    
    /// Clear arena (free all chunks except first)
    on clear() {
        if self.chunks.len() > 1 {
            let first = self.chunks[0]
            self.chunks.clear()
            self.chunks.push(first)
        }
        self.chunks[0].reset()
        self.current = 0
        self.stats.current_used = 0
    }
    
    fn used() -> Int { self.stats.current_used }
    fn stats() -> PoolStats { self.stats }
}

struct ArenaChunk {
    memory: *UInt8
    size: Int
    offset: Int
    
    fn new(size: Int) -> Self {
        ArenaChunk {
            memory: @native("allocate_raw", size),
            size: size,
            offset: 0
        }
    }
    
    fn allocate(size: Int, align: Int) -> Option<*UInt8> {
        let aligned_offset = (self.offset + align - 1) & !(align - 1)
        
        if aligned_offset + size > self.size {
            return None
        }
        
        let ptr = (self.memory as Int + aligned_offset) as *UInt8
        self.offset = aligned_offset + size
        Some(ptr)
    }
    
    fn reset() {
        self.offset = 0
    }
    
    fn available() -> Int { self.size - self.offset }
}

impl Drop for ArenaChunk {
    fn drop() {
        @native("deallocate_raw", self.memory, self.size)
    }
}

// -----------------------------------------------------------------------------
// Ring Buffer Pool
// -----------------------------------------------------------------------------

/// Ring buffer for streaming allocations
actor RingPool {
    state buffer: *UInt8
    state size: Int
    state head: Int
    state tail: Int
    state stats: PoolStats
    
    fn new(size: Int) -> Self {
        RingPool {
            buffer: @native("allocate_raw", size),
            size: size,
            head: 0,
            tail: 0,
            stats: PoolStats.new()
        }
    }
    
    /// Allocate from ring buffer
    on allocate(size: Int) -> Option<*UInt8> {
        if self.available() < size {
            self.stats.allocation_failures += 1
            return None
        }
        
        let ptr = (self.buffer as Int + self.head) as *UInt8
        self.head = (self.head + size) % self.size
        
        self.stats.allocations += 1
        self.stats.current_used += size
        
        Some(ptr)
    }
    
    /// Free from tail
    on free(size: Int) {
        self.tail = (self.tail + size) % self.size
        self.stats.deallocations += 1
        self.stats.current_used -= size
    }
    
    fn available() -> Int {
        if self.head >= self.tail {
            self.size - self.head + self.tail
        } else {
            self.tail - self.head
        }
    }
    
    fn used() -> Int { self.size - self.available() }
    
    on reset() {
        self.head = 0
        self.tail = 0
        self.stats.current_used = 0
    }
}

impl Drop for RingPool {
    fn drop() {
        @native("deallocate_raw", self.buffer, self.size)
    }
}

// -----------------------------------------------------------------------------
// Pool Statistics
// -----------------------------------------------------------------------------

struct PoolStats {
    allocations: Int
    deallocations: Int
    allocation_failures: Int
    current_used: Int
    peak_used: Int
    
    fn new() -> Self {
        PoolStats {
            allocations: 0,
            deallocations: 0,
            allocation_failures: 0,
            current_used: 0,
            peak_used: 0
        }
    }
    
    fn hit_rate() -> Float {
        if self.allocations == 0 { 0.0 }
        else { (self.allocations - self.allocation_failures) as Float / self.allocations as Float }
    }
    
    fn print() {
        println("=== Pool Statistics ===")
        println("Allocations:   \(self.allocations)")
        println("Deallocations: \(self.deallocations)")
        println("Failures:      \(self.allocation_failures)")
        println("Current used:  \(self.current_used)")
        println("Peak used:     \(self.peak_used)")
        println("Hit rate:      \((self.hit_rate() * 100.0).round(2))%")
        println("=======================")
    }
}

// -----------------------------------------------------------------------------
// Scoped Pool
// -----------------------------------------------------------------------------

/// Pool that automatically releases on scope exit
struct ScopedPool<T> {
    pool: ObjectPool<T>
    acquired: [T]
    
    fn new(pool: ObjectPool<T>) -> Self {
        ScopedPool { pool: pool, acquired: [] }
    }
    
    fn acquire() -> T {
        let obj = self.pool.acquire()
        self.acquired.push(obj)
        obj
    }
}

impl<T> Drop for ScopedPool<T> {
    fn drop() {
        for obj in self.acquired {
            self.pool.release(obj)
        }
    }
}

/// Use pool in scoped context
fn scoped<T, R>(pool: ObjectPool<T>, f: (ScopedPool<T>) -> R) -> R {
    let scoped = ScopedPool.new(pool)
    f(scoped)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "fixed pool" {
    let pool = FixedPool::<Int>.new(10)
    
    let ptr1 = pool.allocate().unwrap()
    let ptr2 = pool.allocate().unwrap()
    
    *ptr1 = 42
    *ptr2 = 100
    
    assert_eq(*ptr1, 42)?
    assert_eq(pool.used(), 2)?
    
    pool.deallocate(ptr1)
    assert_eq(pool.used(), 1)?
}

test "object pool" {
    let pool = ObjectPool.new(|| Vec::<Int>.new())
        .with_reset(|v| { v.clear(); v })
    
    pool.preallocate(5)
    assert_eq(pool.available(), 5)?
    
    let vec = pool.acquire()
    vec.push(1)
    vec.push(2)
    
    pool.release(vec)
    
    let vec2 = pool.acquire()
    assert(vec2.is_empty())?  // Should be reset
}

test "buffer pool" {
    let pool = BufferPool.new()
    
    let buf = pool.acquire(100)
    assert(buf.capacity() >= 100)?
    
    pool.release(buf)
}

test "arena" {
    let arena = Arena.new()
    
    let ptr1 = arena.allocate_init(42)
    let ptr2 = arena.allocate_init("hello")
    
    assert_eq(*ptr1, 42)?
    assert_eq(*ptr2, "hello")?
    
    arena.reset()
    assert_eq(arena.used(), 0)?
}

test "slab allocator" {
    let slab = SlabAllocator::<Int>.new()
    
    let ptr1 = slab.allocate()
    let ptr2 = slab.allocate()
    
    *ptr1 = 10
    *ptr2 = 20
    
    assert_eq(*ptr1, 10)?
    assert_eq(*ptr2, 20)?
    
    slab.deallocate(ptr1)
}
