// =============================================================================
// Vibee OS — Number Format Module
// Locale-aware number, currency, and percentage formatting
// =============================================================================

use locale.{Locale, Locales}
use currency.{Currency}
use decimal.{Decimal}

// -----------------------------------------------------------------------------
// Number Format
// -----------------------------------------------------------------------------

/// Locale-aware number formatter
struct NumberFormat {
    locale: Locale
    options: NumberFormatOptions
    
    fn for_locale(locale: Locale) -> Self {
        NumberFormat { locale: locale, options: NumberFormatOptions.default() }
    }
    
    fn current() -> Self {
        Self.for_locale(Locale.current())
    }
    
    fn with_options(options: NumberFormatOptions) -> Self {
        NumberFormat { locale: self.locale, options: options }
    }
    
    // Basic formatting
    
    /// Format integer
    fn format_integer(n: Int) -> String {
        self.format_with_grouping(n.to_string(), 0)
    }
    
    /// Format float
    fn format(n: Float) -> String {
        let decimals = self.options.max_fraction_digits.unwrap_or(2)
        let formatted = self.round_to_decimals(n, decimals)
        self.format_with_grouping(formatted, decimals)
    }
    
    /// Format decimal
    fn format_decimal(d: Decimal) -> String {
        let decimals = self.options.max_fraction_digits.unwrap_or(d.scale())
        let formatted = d.round(decimals).to_string()
        self.format_with_grouping(formatted, decimals)
    }
    
    /// Format with specific decimal places
    fn format_fixed(n: Float, decimals: Int) -> String {
        let formatted = self.round_to_decimals(n, decimals)
        self.format_with_grouping(formatted, decimals)
    }
    
    // Currency formatting
    
    /// Format as currency
    fn format_currency(amount: Decimal, currency: Currency) -> String {
        let decimals = currency.decimal_places()
        let formatted = self.format_decimal(amount.round(decimals))
        let symbol = currency.symbol()
        
        match self.currency_pattern() {
            CurrencyPattern.SymbolBefore => symbol + formatted
            CurrencyPattern.SymbolAfter => formatted + " " + symbol
            CurrencyPattern.SymbolBeforeSpace => symbol + " " + formatted
            CurrencyPattern.CodeAfter => formatted + " " + currency.code()
        }
    }
    
    /// Format as currency with code
    fn format_currency_code(amount: Decimal, currency: Currency) -> String {
        let decimals = currency.decimal_places()
        let formatted = self.format_decimal(amount.round(decimals))
        formatted + " " + currency.code()
    }
    
    /// Format as accounting (negative in parentheses)
    fn format_accounting(amount: Decimal, currency: Currency) -> String {
        let is_negative = amount.is_negative()
        let abs_amount = amount.abs()
        let formatted = self.format_currency(abs_amount, currency)
        
        if is_negative { "(" + formatted + ")" } else { formatted }
    }
    
    // Percentage formatting
    
    /// Format as percentage (0.15 -> "15%")
    fn format_percent(n: Float) -> String {
        let value = n * 100.0
        let decimals = self.options.max_fraction_digits.unwrap_or(0)
        let formatted = self.format_fixed(value, decimals)
        formatted + self.percent_symbol()
    }
    
    /// Format as percentage with decimals
    fn format_percent_fixed(n: Float, decimals: Int) -> String {
        let value = n * 100.0
        let formatted = self.format_fixed(value, decimals)
        formatted + self.percent_symbol()
    }
    
    // Scientific notation
    
    /// Format in scientific notation
    fn format_scientific(n: Float) -> String {
        let (mantissa, exponent) = self.to_scientific(n)
        let formatted = self.format_fixed(mantissa, 2)
        formatted + "×10" + self.superscript(exponent)
    }
    
    /// Format in engineering notation (exponent multiple of 3)
    fn format_engineering(n: Float) -> String {
        let (mantissa, exponent) = self.to_engineering(n)
        let formatted = self.format_fixed(mantissa, 2)
        formatted + "×10" + self.superscript(exponent)
    }
    
    // Compact notation
    
    /// Format in compact notation (1.5K, 2.3M, etc.)
    fn format_compact(n: Float) -> String {
        let (value, suffix) = self.to_compact(n)
        let formatted = self.format_fixed(value, 1)
        formatted + suffix
    }
    
    /// Format in compact notation (long form: 1.5 thousand)
    fn format_compact_long(n: Float) -> String {
        let (value, suffix) = self.to_compact_long(n)
        let formatted = self.format_fixed(value, 1)
        formatted + " " + suffix
    }
    
    // Helpers
    
    fn format_with_grouping(s: String, decimals: Int) -> String {
        let (int_part, frac_part) = if let Some(dot) = s.find('.') {
            (s[..dot], s[(dot + 1)..])
        } else {
            (s, "")
        }
        
        let negative = int_part.starts_with('-')
        let digits = if negative { int_part[1..] } else { int_part }
        
        // Add grouping separators
        var grouped = ""
        let group_sep = self.grouping_separator()
        let group_size = 3
        
        for (i, c) in digits.chars().rev().enumerate() {
            if i > 0 && i % group_size == 0 {
                grouped = group_sep + grouped
            }
            grouped = c.to_string() + grouped
        }
        
        // Add decimal part
        let decimal_sep = self.decimal_separator()
        let result = if frac_part.is_empty() && decimals == 0 {
            grouped
        } else {
            let padded_frac = frac_part.pad_right(decimals, '0')[..decimals]
            grouped + decimal_sep + padded_frac
        }
        
        // Add negative sign
        if negative { self.negative_prefix() + result + self.negative_suffix() }
        else { result }
    }
    
    fn round_to_decimals(n: Float, decimals: Int) -> String {
        let factor = 10.0.pow(decimals as Float)
        let rounded = (n * factor).round() / factor
        
        if decimals == 0 {
            (rounded as Int).to_string()
        } else {
            let s = rounded.to_string()
            if let Some(dot) = s.find('.') {
                let frac = s[(dot + 1)..]
                if frac.len() < decimals as usize {
                    s + "0".repeat(decimals - frac.len() as Int)
                } else {
                    s[..(dot + 1 + decimals as usize)]
                }
            } else {
                s + "." + "0".repeat(decimals)
            }
        }
    }
    
    fn to_scientific(n: Float) -> (Float, Int) {
        if n == 0.0 { return (0.0, 0) }
        let abs_n = n.abs()
        let exp = abs_n.log10().floor() as Int
        let mantissa = n / 10.0.pow(exp as Float)
        (mantissa, exp)
    }
    
    fn to_engineering(n: Float) -> (Float, Int) {
        let (mantissa, exp) = self.to_scientific(n)
        let adj = exp % 3
        let new_exp = exp - adj
        let new_mantissa = mantissa * 10.0.pow(adj as Float)
        (new_mantissa, new_exp)
    }
    
    fn to_compact(n: Float) -> (Float, String) {
        let abs_n = n.abs()
        let sign = if n < 0.0 { -1.0 } else { 1.0 }
        
        let suffixes = self.compact_suffixes()
        
        if abs_n >= 1_000_000_000_000.0 {
            (sign * abs_n / 1_000_000_000_000.0, suffixes.trillion)
        } else if abs_n >= 1_000_000_000.0 {
            (sign * abs_n / 1_000_000_000.0, suffixes.billion)
        } else if abs_n >= 1_000_000.0 {
            (sign * abs_n / 1_000_000.0, suffixes.million)
        } else if abs_n >= 1_000.0 {
            (sign * abs_n / 1_000.0, suffixes.thousand)
        } else {
            (n, "")
        }
    }
    
    fn to_compact_long(n: Float) -> (Float, String) {
        let abs_n = n.abs()
        let sign = if n < 0.0 { -1.0 } else { 1.0 }
        
        let suffixes = self.compact_suffixes_long()
        
        if abs_n >= 1_000_000_000_000.0 {
            (sign * abs_n / 1_000_000_000_000.0, suffixes.trillion)
        } else if abs_n >= 1_000_000_000.0 {
            (sign * abs_n / 1_000_000_000.0, suffixes.billion)
        } else if abs_n >= 1_000_000.0 {
            (sign * abs_n / 1_000_000.0, suffixes.million)
        } else if abs_n >= 1_000.0 {
            (sign * abs_n / 1_000.0, suffixes.thousand)
        } else {
            (n, "")
        }
    }
    
    fn superscript(n: Int) -> String {
        let digits = "⁰¹²³⁴⁵⁶⁷⁸⁹"
        var result = ""
        var num = n.abs()
        
        if n < 0 { result = "⁻" }
        
        if num == 0 { return "⁰" }
        
        var chars: [Char] = []
        while num > 0 {
            let digit = num % 10
            chars.push(digits.chars().nth(digit).unwrap())
            num /= 10
        }
        
        for c in chars.rev() {
            result += c.to_string()
        }
        result
    }
    
    // Locale-specific symbols
    
    fn decimal_separator() -> String {
        match self.locale.language {
            "de" | "fr" | "es" | "it" | "pt" | "ru" | "pl" | "nl" => ","
            _ => "."
        }
    }
    
    fn grouping_separator() -> String {
        match self.locale.language {
            "de" | "nl" => "."
            "fr" | "ru" | "pl" => " "
            "es" | "it" | "pt" => "."
            "en" => if self.locale.region == Some("IN") { "," } else { "," }
            _ => ","
        }
    }
    
    fn percent_symbol() -> String {
        match self.locale.language {
            "ar" => "٪"
            _ => "%"
        }
    }
    
    fn negative_prefix() -> String {
        match self.locale.language {
            _ => "-"
        }
    }
    
    fn negative_suffix() -> String {
        ""
    }
    
    fn currency_pattern() -> CurrencyPattern {
        match self.locale.language {
            "de" | "fr" | "es" | "it" | "pt" | "ru" | "pl" => CurrencyPattern.SymbolAfter
            "en" => CurrencyPattern.SymbolBefore
            _ => CurrencyPattern.SymbolBefore
        }
    }
    
    fn compact_suffixes() -> CompactSuffixes {
        match self.locale.language {
            "ru" => CompactSuffixes { thousand: " тыс.", million: " млн", billion: " млрд", trillion: " трлн" }
            "de" => CompactSuffixes { thousand: " Tsd.", million: " Mio.", billion: " Mrd.", trillion: " Bio." }
            "fr" => CompactSuffixes { thousand: " k", million: " M", billion: " Md", trillion: " Bn" }
            "zh" => CompactSuffixes { thousand: "千", million: "百万", billion: "十亿", trillion: "万亿" }
            "ja" => CompactSuffixes { thousand: "千", million: "百万", billion: "十億", trillion: "兆" }
            _ => CompactSuffixes { thousand: "K", million: "M", billion: "B", trillion: "T" }
        }
    }
    
    fn compact_suffixes_long() -> CompactSuffixes {
        match self.locale.language {
            "ru" => CompactSuffixes { thousand: "тысяч", million: "миллионов", billion: "миллиардов", trillion: "триллионов" }
            "de" => CompactSuffixes { thousand: "Tausend", million: "Millionen", billion: "Milliarden", trillion: "Billionen" }
            "fr" => CompactSuffixes { thousand: "mille", million: "millions", billion: "milliards", trillion: "billions" }
            _ => CompactSuffixes { thousand: "thousand", million: "million", billion: "billion", trillion: "trillion" }
        }
    }
}

struct CompactSuffixes {
    thousand: String
    million: String
    billion: String
    trillion: String
}

enum CurrencyPattern {
    SymbolBefore        // $100
    SymbolAfter         // 100 €
    SymbolBeforeSpace   // $ 100
    CodeAfter           // 100 USD
}

// -----------------------------------------------------------------------------
// Number Format Options
// -----------------------------------------------------------------------------

struct NumberFormatOptions {
    min_integer_digits: Option<Int>
    min_fraction_digits: Option<Int>
    max_fraction_digits: Option<Int>
    use_grouping: Bool
    rounding_mode: RoundingMode
    
    fn default() -> Self {
        NumberFormatOptions {
            min_integer_digits: None,
            min_fraction_digits: None,
            max_fraction_digits: None,
            use_grouping: true,
            rounding_mode: RoundingMode.HalfUp
        }
    }
    
    fn integer() -> Self {
        NumberFormatOptions {
            min_integer_digits: None,
            min_fraction_digits: Some(0),
            max_fraction_digits: Some(0),
            use_grouping: true,
            rounding_mode: RoundingMode.HalfUp
        }
    }
    
    fn decimal(places: Int) -> Self {
        NumberFormatOptions {
            min_integer_digits: None,
            min_fraction_digits: Some(places),
            max_fraction_digits: Some(places),
            use_grouping: true,
            rounding_mode: RoundingMode.HalfUp
        }
    }
    
    fn currency() -> Self {
        NumberFormatOptions {
            min_integer_digits: None,
            min_fraction_digits: Some(2),
            max_fraction_digits: Some(2),
            use_grouping: true,
            rounding_mode: RoundingMode.HalfUp
        }
    }
    
    fn percent() -> Self {
        NumberFormatOptions {
            min_integer_digits: None,
            min_fraction_digits: Some(0),
            max_fraction_digits: Some(2),
            use_grouping: false,
            rounding_mode: RoundingMode.HalfUp
        }
    }
}

enum RoundingMode {
    HalfUp
    HalfDown
    HalfEven
    Up
    Down
    Ceiling
    Floor
}

// -----------------------------------------------------------------------------
// Number Parser
// -----------------------------------------------------------------------------

/// Parse numbers according to locale
struct NumberParser {
    locale: Locale
    
    fn for_locale(locale: Locale) -> Self {
        NumberParser { locale: locale }
    }
    
    fn current() -> Self {
        Self.for_locale(Locale.current())
    }
    
    /// Parse integer
    fn parse_int(s: String) -> Result<Int, ParseError> {
        let cleaned = self.clean_number(s)
        Int.parse(cleaned).map_err(|_| ParseError.InvalidNumber)
    }
    
    /// Parse float
    fn parse_float(s: String) -> Result<Float, ParseError> {
        let cleaned = self.clean_number(s)
        Float.parse(cleaned).map_err(|_| ParseError.InvalidNumber)
    }
    
    /// Parse decimal
    fn parse_decimal(s: String) -> Result<Decimal, ParseError> {
        let cleaned = self.clean_number(s)
        Decimal.from_string(cleaned).map_err(|_| ParseError.InvalidNumber)
    }
    
    /// Parse currency amount
    fn parse_currency(s: String) -> Result<(Decimal, Option<Currency>), ParseError> {
        var cleaned = s.trim()
        var currency: Option<Currency> = None
        
        // Try to detect currency symbol
        for (symbol, curr) in CURRENCY_SYMBOLS {
            if cleaned.starts_with(symbol) {
                currency = Some(curr)
                cleaned = cleaned[symbol.len()..].trim()
                break
            }
            if cleaned.ends_with(symbol) {
                currency = Some(curr)
                cleaned = cleaned[..(cleaned.len() - symbol.len())].trim()
                break
            }
        }
        
        // Try to detect currency code
        if currency.is_none() {
            for code in ["USD", "EUR", "GBP", "JPY", "RUB", "CNY"] {
                if cleaned.ends_with(code) {
                    currency = Currency.from_code(code)
                    cleaned = cleaned[..(cleaned.len() - code.len())].trim()
                    break
                }
            }
        }
        
        let amount = self.parse_decimal(cleaned)?
        Ok((amount, currency))
    }
    
    /// Parse percentage
    fn parse_percent(s: String) -> Result<Float, ParseError> {
        var cleaned = s.trim()
        if cleaned.ends_with("%") || cleaned.ends_with("٪") {
            cleaned = cleaned[..(cleaned.len() - 1)].trim()
        }
        let value = self.parse_float(cleaned)?
        Ok(value / 100.0)
    }
    
    fn clean_number(s: String) -> String {
        var result = s.trim()
        
        // Remove grouping separators
        let group_sep = self.grouping_separator()
        result = result.replace(group_sep, "")
        
        // Replace decimal separator with dot
        let dec_sep = self.decimal_separator()
        if dec_sep != "." {
            result = result.replace(dec_sep, ".")
        }
        
        // Remove currency symbols and whitespace
        result = result.replace(" ", "")
        for symbol in ["$", "€", "£", "¥", "₽", "₹"] {
            result = result.replace(symbol, "")
        }
        
        result
    }
    
    fn decimal_separator() -> String {
        NumberFormat.for_locale(self.locale).decimal_separator()
    }
    
    fn grouping_separator() -> String {
        NumberFormat.for_locale(self.locale).grouping_separator()
    }
}

var CURRENCY_SYMBOLS: [(String, Currency)] = [
    ("$", Currency.USD),
    ("€", Currency.EUR),
    ("£", Currency.GBP),
    ("¥", Currency.JPY),
    ("₽", Currency.RUB),
    ("₹", Currency.INR),
    ("₩", Currency.KRW),
    ("₴", Currency.UAH),
]

enum ParseError {
    InvalidNumber
    InvalidCurrency
    InvalidFormat
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn format_number(n: Float) -> String {
    NumberFormat.current().format(n)
}

fn format_integer(n: Int) -> String {
    NumberFormat.current().format_integer(n)
}

fn format_currency(amount: Decimal, currency: Currency) -> String {
    NumberFormat.current().format_currency(amount, currency)
}

fn format_percent(n: Float) -> String {
    NumberFormat.current().format_percent(n)
}

fn format_compact(n: Float) -> String {
    NumberFormat.current().format_compact(n)
}

fn parse_number(s: String) -> Result<Float, ParseError> {
    NumberParser.current().parse_float(s)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "format integer" {
    let fmt = NumberFormat.for_locale(Locales.en_US())
    assert_eq(fmt.format_integer(1234567), "1,234,567")?
    
    let fmt_de = NumberFormat.for_locale(Locales.de_DE())
    assert_eq(fmt_de.format_integer(1234567), "1.234.567")?
    
    let fmt_fr = NumberFormat.for_locale(Locales.fr_FR())
    assert_eq(fmt_fr.format_integer(1234567), "1 234 567")?
}

test "format decimal" {
    let fmt = NumberFormat.for_locale(Locales.en_US())
    assert_eq(fmt.format(1234.56), "1,234.56")?
    
    let fmt_de = NumberFormat.for_locale(Locales.de_DE())
    assert_eq(fmt_de.format(1234.56), "1.234,56")?
}

test "format currency" {
    let fmt = NumberFormat.for_locale(Locales.en_US())
    let amount = Decimal.from_string("1234.56")?
    assert_eq(fmt.format_currency(amount, Currency.USD), "$1,234.56")?
    
    let fmt_de = NumberFormat.for_locale(Locales.de_DE())
    assert_eq(fmt_de.format_currency(amount, Currency.EUR), "1.234,56 €")?
}

test "format percent" {
    let fmt = NumberFormat.for_locale(Locales.en_US())
    assert_eq(fmt.format_percent(0.1525), "15%")?
    assert_eq(fmt.format_percent_fixed(0.1525, 1), "15.3%")?
}

test "format compact" {
    let fmt = NumberFormat.for_locale(Locales.en_US())
    assert_eq(fmt.format_compact(1500.0), "1.5K")?
    assert_eq(fmt.format_compact(2500000.0), "2.5M")?
    
    let fmt_ru = NumberFormat.for_locale(Locales.ru_RU())
    assert(fmt_ru.format_compact(1500.0).contains("тыс"))?
}

test "parse number" {
    let parser = NumberParser.for_locale(Locales.en_US())
    assert_eq(parser.parse_float("1,234.56")?, 1234.56)?
    
    let parser_de = NumberParser.for_locale(Locales.de_DE())
    assert_eq(parser_de.parse_float("1.234,56")?, 1234.56)?
}

test "parse currency" {
    let parser = NumberParser.for_locale(Locales.en_US())
    let (amount, currency) = parser.parse_currency("$1,234.56")?
    assert_eq(amount.to_float(), 1234.56)?
    assert_eq(currency, Some(Currency.USD))?
}

test "parse percent" {
    let parser = NumberParser.for_locale(Locales.en_US())
    assert_eq(parser.parse_percent("15%")?, 0.15)?
    assert_eq(parser.parse_percent("15.5%")?, 0.155)?
}

test "scientific notation" {
    let fmt = NumberFormat.for_locale(Locales.en_US())
    let result = fmt.format_scientific(1234567.0)
    assert(result.contains("1.23"))?
    assert(result.contains("10"))?
}
