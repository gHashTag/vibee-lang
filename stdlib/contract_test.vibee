// =============================================================================
// Vibee OS â€” Contract Testing Module
// Consumer-driven contract testing for APIs and services
// =============================================================================

// -----------------------------------------------------------------------------
// Contract Test Runner
// -----------------------------------------------------------------------------

/// Contract test runner
actor ContractRunner {
    state contracts: [Contract]
    state config: ContractConfig
    state results: [ContractResult]
    state broker: Option<PactBroker>
    
    fn new() -> Self {
        ContractRunner {
            contracts: [],
            config: ContractConfig.default(),
            results: [],
            broker: None
        }
    }
    
    on config(c: ContractConfig) -> Self { self.config = c; self }
    
    /// Connect to Pact broker
    on broker(url: String, token: String) -> Self {
        self.broker = Some(PactBroker { url: url, token: token })
        self
    }
    
    /// Add contract
    on contract(name: String, setup: (ContractBuilder) -> ContractBuilder) -> Self {
        let builder = ContractBuilder.new(name)
        let contract = setup(builder).build()
        self.contracts.append(contract)
        self
    }
    
    /// Run consumer tests
    async on run_consumer_tests() -> ContractSummary {
        println("\nðŸ“ Running Consumer Contract Tests...\n")
        
        for contract in self.contracts {
            let result = self.verify_consumer(contract).await
            self.results.append(result)
            self.print_result(result)
        }
        
        // Publish to broker
        if let broker = self.broker {
            self.publish_contracts(broker).await
        }
        
        self.create_summary()
    }
    
    /// Run provider verification
    async on run_provider_verification(provider: String) -> ContractSummary {
        println("\nðŸ” Running Provider Verification for '\(provider)'...\n")
        
        // Fetch contracts from broker
        if let broker = self.broker {
            let contracts = broker.fetch_contracts(provider).await?
            for contract in contracts {
                let result = self.verify_provider(contract).await
                self.results.append(result)
                self.print_result(result)
            }
        }
        
        self.create_summary()
    }
    
    async fn verify_consumer(contract: Contract) -> ContractResult {
        println("ðŸ“‹ Contract: \(contract.consumer) -> \(contract.provider)")
        
        var interaction_results = []
        let mock_server = MockServer.start(contract).await?
        
        for interaction in contract.interactions {
            let result = self.verify_interaction(interaction, mock_server).await
            interaction_results.append(result)
        }
        
        mock_server.stop().await
        
        let all_passed = interaction_results.all(|r| r.passed)
        
        ContractResult {
            contract: contract,
            status: if all_passed { .Passed } else { .Failed },
            interactions: interaction_results,
            error: None
        }
    }
    
    async fn verify_provider(contract: Contract) -> ContractResult {
        println("ðŸ” Verifying: \(contract.consumer) -> \(contract.provider)")
        
        var interaction_results = []
        
        for interaction in contract.interactions {
            let result = self.replay_interaction(interaction).await
            interaction_results.append(result)
        }
        
        let all_passed = interaction_results.all(|r| r.passed)
        
        ContractResult {
            contract: contract,
            status: if all_passed { .Passed } else { .Failed },
            interactions: interaction_results,
            error: None
        }
    }
    
    async fn verify_interaction(interaction: Interaction, server: MockServer) -> InteractionResult {
        let start = Instant.now()
        
        // Execute consumer code against mock
        match interaction.consumer_test(server.base_url()).await {
            Ok(()) => {
                // Verify mock received expected request
                if server.verify_interaction(interaction) {
                    InteractionResult {
                        description: interaction.description,
                        passed: true,
                        duration: start.elapsed(),
                        error: None
                    }
                } else {
                    InteractionResult {
                        description: interaction.description,
                        passed: false,
                        duration: start.elapsed(),
                        error: Some("Mock did not receive expected request")
                    }
                }
            }
            Err(e) => {
                InteractionResult {
                    description: interaction.description,
                    passed: false,
                    duration: start.elapsed(),
                    error: Some(e.to_string())
                }
            }
        }
    }
    
    async fn replay_interaction(interaction: Interaction) -> InteractionResult {
        let start = Instant.now()
        
        // Make actual request to provider
        let response = self.make_request(interaction.request).await
        
        // Verify response matches expected
        match self.verify_response(response, interaction.response) {
            Ok(()) => {
                InteractionResult {
                    description: interaction.description,
                    passed: true,
                    duration: start.elapsed(),
                    error: None
                }
            }
            Err(e) => {
                InteractionResult {
                    description: interaction.description,
                    passed: false,
                    duration: start.elapsed(),
                    error: Some(e)
                }
            }
        }
    }
    
    async fn make_request(req: RequestSpec) -> http.Response {
        let url = "\(self.config.provider_url)\(req.path)"
        var request = http.Request.new(req.method, url)
        
        for (k, v) in req.headers {
            request = request.header(k, v)
        }
        
        if let body = req.body {
            request = request.body(body.as_bytes())
        }
        
        http.Client.new().send(request).unwrap()
    }
    
    fn verify_response(actual: http.Response, expected: ResponseSpec) -> Result<(), String> {
        // Verify status
        if actual.status.code != expected.status {
            return Err("Status mismatch: expected \(expected.status), got \(actual.status.code)")
        }
        
        // Verify headers
        for (k, v) in expected.headers {
            if actual.headers.get(k) != Some(v) {
                return Err("Header mismatch for '\(k)'")
            }
        }
        
        // Verify body
        if let expected_body = expected.body {
            let actual_body = actual.text()
            if !self.match_body(actual_body, expected_body, expected.matchers) {
                return Err("Body mismatch")
            }
        }
        
        Ok(())
    }
    
    fn match_body(actual: String, expected: String, matchers: [Matcher]) -> Bool {
        if matchers.is_empty() {
            return actual == expected
        }
        
        // Parse as JSON and apply matchers
        let actual_json = json.parse(actual).ok()
        let expected_json = json.parse(expected).ok()
        
        if let (Some(a), Some(e)) = (actual_json, expected_json) {
            for matcher in matchers {
                if !matcher.matches(a, e) {
                    return false
                }
            }
            true
        } else {
            actual == expected
        }
    }
    
    async fn publish_contracts(broker: PactBroker) {
        for contract in self.contracts {
            broker.publish(contract).await
        }
    }
    
    fn print_result(result: ContractResult) {
        let icon = if result.status == .Passed { "âœ…" } else { "âŒ" }
        println("\(icon) \(result.contract.consumer) -> \(result.contract.provider)")
        
        for ir in result.interactions {
            let i_icon = if ir.passed { "  âœ“" } else { "  âœ—" }
            println("\(i_icon) \(ir.description)")
            if let error = ir.error {
                println("      Error: \(error)")
            }
        }
    }
    
    fn create_summary() -> ContractSummary {
        let passed = self.results.filter(|r| r.status == .Passed).len()
        let failed = self.results.filter(|r| r.status == .Failed).len()
        
        ContractSummary {
            total: self.results.len(),
            passed: passed,
            failed: failed,
            results: self.results
        }
    }
}

struct ContractConfig {
    provider_url: String
    publish_verification: Bool
    consumer_version: String
    provider_version: String
    
    fn default() -> Self {
        ContractConfig {
            provider_url: "http://localhost:8080",
            publish_verification: true,
            consumer_version: "1.0.0",
            provider_version: "1.0.0"
        }
    }
}

// -----------------------------------------------------------------------------
// Contract Builder
// -----------------------------------------------------------------------------

actor ContractBuilder {
    state consumer: String
    state provider: String
    state interactions: [Interaction]
    
    fn new(consumer: String) -> Self {
        ContractBuilder { consumer: consumer, provider: "", interactions: [] }
    }
    
    on provider(name: String) -> Self {
        self.provider = name
        self
    }
    
    /// Add interaction
    on interaction(description: String, setup: (InteractionBuilder) -> InteractionBuilder) -> Self {
        let builder = InteractionBuilder.new(description)
        let interaction = setup(builder).build()
        self.interactions.append(interaction)
        self
    }
    
    fn build() -> Contract {
        Contract {
            consumer: self.consumer,
            provider: self.provider,
            interactions: self.interactions
        }
    }
}

struct Contract {
    consumer: String
    provider: String
    interactions: [Interaction]
    
    fn to_pact() -> PactFile {
        PactFile {
            consumer: PactParticipant { name: self.consumer },
            provider: PactParticipant { name: self.provider },
            interactions: self.interactions.map(|i| i.to_pact_interaction()),
            metadata: PactMetadata { pact_specification: PactSpec { version: "3.0.0" } }
        }
    }
}

// -----------------------------------------------------------------------------
// Interaction Builder
// -----------------------------------------------------------------------------

actor InteractionBuilder {
    state description: String
    state provider_state: Option<String>
    state request: RequestSpec
    state response: ResponseSpec
    state consumer_test: Option<(String) -> Result<(), ContractError>>
    
    fn new(description: String) -> Self {
        InteractionBuilder {
            description: description,
            provider_state: None,
            request: RequestSpec.default(),
            response: ResponseSpec.default(),
            consumer_test: None
        }
    }
    
    /// Set provider state
    on given(state: String) -> Self {
        self.provider_state = Some(state)
        self
    }
    
    /// Set request
    on upon_receiving(method: http.Method, path: String) -> Self {
        self.request.method = method
        self.request.path = path
        self
    }
    
    /// Add request header
    on with_header(name: String, value: String) -> Self {
        self.request.headers.set(name, value)
        self
    }
    
    /// Add request query param
    on with_query(name: String, value: String) -> Self {
        self.request.query.set(name, value)
        self
    }
    
    /// Set request body
    on with_body(body: String) -> Self {
        self.request.body = Some(body)
        self
    }
    
    /// Set JSON request body
    on with_json_body<T: Serialize>(body: T) -> Self {
        self.request.body = Some(json.encode(body))
        self.request.headers.set("Content-Type", "application/json")
        self
    }
    
    /// Set expected response status
    on will_respond_with(status: Int) -> Self {
        self.response.status = status
        self
    }
    
    /// Add response header
    on with_response_header(name: String, value: String) -> Self {
        self.response.headers.set(name, value)
        self
    }
    
    /// Set response body
    on with_response_body(body: String) -> Self {
        self.response.body = Some(body)
        self
    }
    
    /// Set JSON response body
    on with_json_response<T: Serialize>(body: T) -> Self {
        self.response.body = Some(json.encode(body))
        self.response.headers.set("Content-Type", "application/json")
        self
    }
    
    /// Add matcher
    on with_matcher(matcher: Matcher) -> Self {
        self.response.matchers.append(matcher)
        self
    }
    
    /// Set consumer test function
    on test(f: (String) -> Result<(), ContractError>) -> Self {
        self.consumer_test = Some(f)
        self
    }
    
    fn build() -> Interaction {
        Interaction {
            description: self.description,
            provider_state: self.provider_state,
            request: self.request,
            response: self.response,
            consumer_test: self.consumer_test.unwrap_or(|_| Ok(()))
        }
    }
}

struct Interaction {
    description: String
    provider_state: Option<String>
    request: RequestSpec
    response: ResponseSpec
    consumer_test: (String) -> Result<(), ContractError>
    
    fn to_pact_interaction() -> PactInteraction {
        PactInteraction {
            description: self.description,
            provider_state: self.provider_state,
            request: self.request.to_pact(),
            response: self.response.to_pact()
        }
    }
}

struct RequestSpec {
    method: http.Method
    path: String
    headers: Map<String, String>
    query: Map<String, String>
    body: Option<String>
    
    fn default() -> Self {
        RequestSpec {
            method: .GET,
            path: "/",
            headers: Map.empty(),
            query: Map.empty(),
            body: None
        }
    }
    
    fn to_pact() -> PactRequest {
        PactRequest {
            method: self.method.to_string(),
            path: self.path,
            headers: self.headers,
            query: self.query,
            body: self.body
        }
    }
}

struct ResponseSpec {
    status: Int
    headers: Map<String, String>
    body: Option<String>
    matchers: [Matcher]
    
    fn default() -> Self {
        ResponseSpec {
            status: 200,
            headers: Map.empty(),
            body: None,
            matchers: []
        }
    }
    
    fn to_pact() -> PactResponse {
        PactResponse {
            status: self.status,
            headers: self.headers,
            body: self.body,
            matching_rules: self.matchers.map(|m| m.to_pact_rule())
        }
    }
}

// -----------------------------------------------------------------------------
// Matchers
// -----------------------------------------------------------------------------

enum Matcher {
    Type(String)
    Regex(String, String)
    Integer(String)
    Decimal(String)
    Date(String, String)
    Time(String, String)
    DateTime(String, String)
    Include(String, String)
    MinLength(String, Int)
    MaxLength(String, Int)
    ArrayContains(String, [Matcher])
    EachLike(String, Matcher)
    
    fn matches(actual: json.Value, expected: json.Value) -> Bool {
        match self {
            .Type(path) => {
                let a = actual.get_path(path)
                let e = expected.get_path(path)
                a.map(|v| v.type_name()).unwrap_or("") == e.map(|v| v.type_name()).unwrap_or("")
            }
            .Regex(path, pattern) => {
                actual.get_path(path)
                    .and_then(|v| v.as_string())
                    .map(|s| Regex.new(pattern).map(|r| r.is_match(s)).unwrap_or(false))
                    .unwrap_or(false)
            }
            .Integer(path) => {
                actual.get_path(path).map(|v| v.is_integer()).unwrap_or(false)
            }
            .Decimal(path) => {
                actual.get_path(path).map(|v| v.is_number()).unwrap_or(false)
            }
            .Include(path, substring) => {
                actual.get_path(path)
                    .and_then(|v| v.as_string())
                    .map(|s| s.contains(substring))
                    .unwrap_or(false)
            }
            .MinLength(path, min) => {
                actual.get_path(path)
                    .and_then(|v| v.as_array())
                    .map(|a| a.len() >= min)
                    .unwrap_or(false)
            }
            .MaxLength(path, max) => {
                actual.get_path(path)
                    .and_then(|v| v.as_array())
                    .map(|a| a.len() <= max)
                    .unwrap_or(false)
            }
            _ => true
        }
    }
    
    fn to_pact_rule() -> PactMatchingRule {
        match self {
            .Type(path) => PactMatchingRule { path: path, rule: "type" }
            .Regex(path, pattern) => PactMatchingRule { path: path, rule: "regex:\(pattern)" }
            .Integer(path) => PactMatchingRule { path: path, rule: "integer" }
            .Decimal(path) => PactMatchingRule { path: path, rule: "decimal" }
            _ => PactMatchingRule { path: "$", rule: "type" }
        }
    }
}

// Matcher helpers
fn type_matcher(path: String) -> Matcher { Matcher.Type(path) }
fn regex_matcher(path: String, pattern: String) -> Matcher { Matcher.Regex(path, pattern) }
fn integer_matcher(path: String) -> Matcher { Matcher.Integer(path) }
fn decimal_matcher(path: String) -> Matcher { Matcher.Decimal(path) }
fn uuid_matcher(path: String) -> Matcher { Matcher.Regex(path, "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$") }
fn email_matcher(path: String) -> Matcher { Matcher.Regex(path, "^[\\w.-]+@[\\w.-]+\\.\\w+$") }
fn date_matcher(path: String) -> Matcher { Matcher.Date(path, "yyyy-MM-dd") }
fn datetime_matcher(path: String) -> Matcher { Matcher.DateTime(path, "yyyy-MM-dd'T'HH:mm:ss") }

// -----------------------------------------------------------------------------
// Mock Server
// -----------------------------------------------------------------------------

actor MockServer {
    state contract: Contract
    state port: Int
    state received_requests: [ReceivedRequest]
    state handle: @native("ServerHandle")
    
    async fn start(contract: Contract) -> Result<Self, ContractError> {
        let port = @native("find_free_port")
        let handle = @native("start_mock_server", port, contract.to_pact())
            .map_err(|e| ContractError.MockServerFailed(e.to_string()))?
        
        Ok(MockServer {
            contract: contract,
            port: port,
            received_requests: [],
            handle: handle
        })
    }
    
    fn base_url() -> String {
        "http://localhost:\(self.port)"
    }
    
    fn verify_interaction(interaction: Interaction) -> Bool {
        self.received_requests.any(|r| {
            r.method == interaction.request.method.to_string() &&
            r.path == interaction.request.path
        })
    }
    
    async fn stop() -> Result<(), ContractError> {
        @native("stop_mock_server", self.handle)
            .map_err(|e| ContractError.MockServerFailed(e.to_string()))
    }
}

struct ReceivedRequest {
    method: String
    path: String
    headers: Map<String, String>
    body: Option<String>
}

// -----------------------------------------------------------------------------
// Pact Broker
// -----------------------------------------------------------------------------

actor PactBroker {
    state url: String
    state token: String
    
    async fn publish(contract: Contract) -> Result<(), ContractError> {
        let pact = contract.to_pact()
        let body = json.encode(pact)
        
        http.Client.new()
            .send(http.Request.put("\(self.url)/pacts/provider/\(contract.provider)/consumer/\(contract.consumer)/version/latest")
                .header("Authorization", "Bearer \(self.token)")
                .header("Content-Type", "application/json")
                .body(body.as_bytes()))
            .map_err(|e| ContractError.BrokerError(e.to_string()))?
        
        Ok(())
    }
    
    async fn fetch_contracts(provider: String) -> Result<[Contract], ContractError> {
        let response = http.Client.new()
            .send(http.Request.get("\(self.url)/pacts/provider/\(provider)/latest")
                .header("Authorization", "Bearer \(self.token)"))
            .map_err(|e| ContractError.BrokerError(e.to_string()))?
        
        let pacts: [PactFile] = response.json().map_err(|e| ContractError.BrokerError(e.to_string()))?
        Ok(pacts.map(|p| p.to_contract()))
    }
    
    async fn publish_verification(provider: String, consumer: String, success: Bool) -> Result<(), ContractError> {
        let body = json.encode({ "success": success, "providerApplicationVersion": "latest" })
        
        http.Client.new()
            .send(http.Request.post("\(self.url)/pacts/provider/\(provider)/consumer/\(consumer)/verification-results")
                .header("Authorization", "Bearer \(self.token)")
                .header("Content-Type", "application/json")
                .body(body.as_bytes()))
            .map_err(|e| ContractError.BrokerError(e.to_string()))?
        
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Pact File Format
// -----------------------------------------------------------------------------

struct PactFile {
    consumer: PactParticipant
    provider: PactParticipant
    interactions: [PactInteraction]
    metadata: PactMetadata
    
    fn to_contract() -> Contract {
        Contract {
            consumer: self.consumer.name,
            provider: self.provider.name,
            interactions: self.interactions.map(|i| i.to_interaction())
        }
    }
}

struct PactParticipant { name: String }

struct PactInteraction {
    description: String
    provider_state: Option<String>
    request: PactRequest
    response: PactResponse
    
    fn to_interaction() -> Interaction {
        Interaction {
            description: self.description,
            provider_state: self.provider_state,
            request: self.request.to_spec(),
            response: self.response.to_spec(),
            consumer_test: |_| Ok(())
        }
    }
}

struct PactRequest {
    method: String
    path: String
    headers: Map<String, String>
    query: Map<String, String>
    body: Option<String>
    
    fn to_spec() -> RequestSpec {
        RequestSpec {
            method: http.Method.from_str(self.method).unwrap_or(.GET),
            path: self.path,
            headers: self.headers,
            query: self.query,
            body: self.body
        }
    }
}

struct PactResponse {
    status: Int
    headers: Map<String, String>
    body: Option<String>
    matching_rules: [PactMatchingRule]
    
    fn to_spec() -> ResponseSpec {
        ResponseSpec {
            status: self.status,
            headers: self.headers,
            body: self.body,
            matchers: []
        }
    }
}

struct PactMatchingRule {
    path: String
    rule: String
}

struct PactMetadata {
    pact_specification: PactSpec
}

struct PactSpec { version: String }

// -----------------------------------------------------------------------------
// Results
// -----------------------------------------------------------------------------

enum ContractStatus { Passed, Failed }

struct ContractResult {
    contract: Contract
    status: ContractStatus
    interactions: [InteractionResult]
    error: Option<ContractError>
}

struct InteractionResult {
    description: String
    passed: Bool
    duration: Duration
    error: Option<String>
}

struct ContractSummary {
    total: Int
    passed: Int
    failed: Int
    results: [ContractResult]
    
    fn print() {
        println("\n" + "=".repeat(50))
        println("ðŸ“ Contract Test Summary")
        println("=".repeat(50))
        println("Total:  \(self.total)")
        println("Passed: \(self.passed) âœ…")
        println("Failed: \(self.failed) âŒ")
        println("=".repeat(50))
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ContractError {
    MockServerFailed(String)
    BrokerError(String)
    VerificationFailed(String)
    MatcherFailed(String)
    
    fn message() -> String {
        match self {
            .MockServerFailed(m) => "Mock server failed: \(m)"
            .BrokerError(m) => "Broker error: \(m)"
            .VerificationFailed(m) => "Verification failed: \(m)"
            .MatcherFailed(m) => "Matcher failed: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "contract builder" {
    let contract = ContractBuilder.new("UserService")
        .provider("UserAPI")
        .interaction("Get user by ID", |i| {
            i.given("User 1 exists")
             .upon_receiving(.GET, "/users/1")
             .will_respond_with(200)
             .with_json_response({ "id": 1, "name": "Alice" })
        })
        .build()
    
    assert_eq(contract.consumer, "UserService")?
    assert_eq(contract.provider, "UserAPI")?
    assert_eq(contract.interactions.len(), 1)?
}

test "interaction builder" {
    let interaction = InteractionBuilder.new("Create user")
        .given("No users exist")
        .upon_receiving(.POST, "/users")
        .with_json_body({ "name": "Bob" })
        .will_respond_with(201)
        .with_response_header("Location", "/users/1")
        .build()
    
    assert_eq(interaction.request.method, .POST)?
    assert_eq(interaction.response.status, 201)?
}

test "matchers" {
    let type_m = type_matcher("$.id")
    let uuid_m = uuid_matcher("$.uuid")
    let email_m = email_matcher("$.email")
    
    assert_eq(type_m, Matcher.Type("$.id"))?
}

test "request spec" {
    let spec = RequestSpec.default()
    assert_eq(spec.method, .GET)?
    assert_eq(spec.path, "/")?
}

test "response spec" {
    let spec = ResponseSpec.default()
    assert_eq(spec.status, 200)?
}
