// =============================================================================
// Vibee OS â€” Log Filter Module
// Log filtering by level, content, and custom rules
// =============================================================================

use logger.{LogRecord, Level}
use regex.{Regex}
use datetime.{DateTime, Duration}

// -----------------------------------------------------------------------------
// Filter Trait
// -----------------------------------------------------------------------------

/// Core filter interface
trait Filter {
    /// Returns true if the record should be logged
    fn filter(record: LogRecord) -> Bool
}

// -----------------------------------------------------------------------------
// Level Filter
// -----------------------------------------------------------------------------

/// Filters by log level
struct LevelFilter {
    min_level: Option<Level>
    max_level: Option<Level>
    exact_levels: Option<[Level]>
}

impl LevelFilter {
    fn new() -> Self {
        LevelFilter {
            min_level: None,
            max_level: None,
            exact_levels: None
        }
    }
    
    /// Only allow logs at or above this level
    fn min(level: Level) -> Self {
        LevelFilter {
            min_level: Some(level),
            max_level: None,
            exact_levels: None
        }
    }
    
    /// Only allow logs at or below this level
    fn max(level: Level) -> Self {
        LevelFilter {
            min_level: None,
            max_level: Some(level),
            exact_levels: None
        }
    }
    
    /// Only allow logs within a range
    fn range(min: Level, max: Level) -> Self {
        LevelFilter {
            min_level: Some(min),
            max_level: Some(max),
            exact_levels: None
        }
    }
    
    /// Only allow specific levels
    fn exact(levels: [Level]) -> Self {
        LevelFilter {
            min_level: None,
            max_level: None,
            exact_levels: Some(levels)
        }
    }
    
    /// Only errors and above
    fn errors_only() -> Self {
        Self.min(Level.Error)
    }
    
    /// Only warnings and above
    fn warnings_and_above() -> Self {
        Self.min(Level.Warn)
    }
    
    /// Exclude trace and debug
    fn production() -> Self {
        Self.min(Level.Info)
    }
}

impl Filter for LevelFilter {
    fn filter(record: LogRecord) -> Bool {
        // Check exact levels first
        if let Some(levels) = self.exact_levels.as_ref() {
            return levels.contains(&record.level)
        }
        
        // Check min level
        if let Some(min) = self.min_level {
            if record.level < min { return false }
        }
        
        // Check max level
        if let Some(max) = self.max_level {
            if record.level > max { return false }
        }
        
        true
    }
}

// -----------------------------------------------------------------------------
// Logger Name Filter
// -----------------------------------------------------------------------------

/// Filters by logger name
struct LoggerFilter {
    include: [String]
    exclude: [String]
    include_patterns: [Regex]
    exclude_patterns: [Regex]
}

impl LoggerFilter {
    fn new() -> Self {
        LoggerFilter {
            include: [],
            exclude: [],
            include_patterns: [],
            exclude_patterns: []
        }
    }
    
    /// Include only these logger names
    fn include(names: [String]) -> Self {
        self.include = names
        self
    }
    
    /// Exclude these logger names
    fn exclude(names: [String]) -> Self {
        self.exclude = names
        self
    }
    
    /// Include loggers matching pattern
    fn include_pattern(pattern: String) -> Self {
        if let Ok(regex) = Regex.new(pattern) {
            self.include_patterns.push(regex)
        }
        self
    }
    
    /// Exclude loggers matching pattern
    fn exclude_pattern(pattern: String) -> Self {
        if let Ok(regex) = Regex.new(pattern) {
            self.exclude_patterns.push(regex)
        }
        self
    }
    
    /// Include logger and its children
    fn include_tree(name: String) -> Self {
        self.include_pattern("\(name)(\\..*)?")?
    }
    
    /// Exclude logger and its children
    fn exclude_tree(name: String) -> Self {
        self.exclude_pattern("\(name)(\\..*)?")?
    }
}

impl Filter for LoggerFilter {
    fn filter(record: LogRecord) -> Bool {
        let name = record.logger_name.as_str()
        
        // Check exclusions first
        if self.exclude.contains(&record.logger_name) {
            return false
        }
        
        for pattern in self.exclude_patterns.iter() {
            if pattern.is_match(name) {
                return false
            }
        }
        
        // If no inclusions specified, allow all (that weren't excluded)
        if self.include.is_empty() && self.include_patterns.is_empty() {
            return true
        }
        
        // Check inclusions
        if self.include.contains(&record.logger_name) {
            return true
        }
        
        for pattern in self.include_patterns.iter() {
            if pattern.is_match(name) {
                return true
            }
        }
        
        false
    }
}

// -----------------------------------------------------------------------------
// Message Filter
// -----------------------------------------------------------------------------

/// Filters by message content
struct MessageFilter {
    contains: [String]
    not_contains: [String]
    patterns: [Regex]
    not_patterns: [Regex]
}

impl MessageFilter {
    fn new() -> Self {
        MessageFilter {
            contains: [],
            not_contains: [],
            patterns: [],
            not_patterns: []
        }
    }
    
    /// Message must contain this string
    fn contains(text: String) -> Self {
        self.contains.push(text)
        self
    }
    
    /// Message must not contain this string
    fn not_contains(text: String) -> Self {
        self.not_contains.push(text)
        self
    }
    
    /// Message must match this pattern
    fn matches(pattern: String) -> Self {
        if let Ok(regex) = Regex.new(pattern) {
            self.patterns.push(regex)
        }
        self
    }
    
    /// Message must not match this pattern
    fn not_matches(pattern: String) -> Self {
        if let Ok(regex) = Regex.new(pattern) {
            self.not_patterns.push(regex)
        }
        self
    }
    
    /// Filter out health check logs
    fn no_health_checks() -> Self {
        Self.new()
            .not_contains("/health")
            .not_contains("/healthz")
            .not_contains("/ready")
            .not_contains("/live")
    }
    
    /// Filter out metrics endpoint logs
    fn no_metrics() -> Self {
        Self.new()
            .not_contains("/metrics")
            .not_contains("/prometheus")
    }
}

impl Filter for MessageFilter {
    fn filter(record: LogRecord) -> Bool {
        let msg = record.message.as_str()
        
        // Check not_contains
        for text in self.not_contains.iter() {
            if msg.contains(text) {
                return false
            }
        }
        
        // Check not_patterns
        for pattern in self.not_patterns.iter() {
            if pattern.is_match(msg) {
                return false
            }
        }
        
        // If no positive filters, allow
        if self.contains.is_empty() && self.patterns.is_empty() {
            return true
        }
        
        // Check contains
        for text in self.contains.iter() {
            if msg.contains(text) {
                return true
            }
        }
        
        // Check patterns
        for pattern in self.patterns.iter() {
            if pattern.is_match(msg) {
                return true
            }
        }
        
        false
    }
}

// -----------------------------------------------------------------------------
// Field Filter
// -----------------------------------------------------------------------------

/// Filters by field values
struct FieldFilter {
    required_fields: [String]
    field_values: Map<String, Any>
    field_patterns: Map<String, Regex>
}

impl FieldFilter {
    fn new() -> Self {
        FieldFilter {
            required_fields: [],
            field_values: Map.new(),
            field_patterns: Map.new()
        }
    }
    
    /// Require this field to be present
    fn require(field: String) -> Self {
        self.required_fields.push(field)
        self
    }
    
    /// Require field to have specific value
    fn equals(field: String, value: Any) -> Self {
        self.field_values.insert(field, value)
        self
    }
    
    /// Require field to match pattern
    fn matches(field: String, pattern: String) -> Self {
        if let Ok(regex) = Regex.new(pattern) {
            self.field_patterns.insert(field, regex)
        }
        self
    }
    
    /// Filter by request ID
    fn request_id(id: String) -> Self {
        Self.new().equals("request_id", id)
    }
    
    /// Filter by user ID
    fn user_id(id: String) -> Self {
        Self.new().equals("user_id", id)
    }
    
    /// Filter by trace ID
    fn trace_id(id: String) -> Self {
        Self.new().equals("trace_id", id)
    }
}

impl Filter for FieldFilter {
    fn filter(record: LogRecord) -> Bool {
        // Check required fields
        for field in self.required_fields.iter() {
            if !record.fields.contains_key(field) {
                return false
            }
        }
        
        // Check field values
        for (field, expected) in self.field_values.iter() {
            match record.fields.get(field) {
                Some(actual) => {
                    if actual.to_string() != expected.to_string() {
                        return false
                    }
                }
                None => return false
            }
        }
        
        // Check field patterns
        for (field, pattern) in self.field_patterns.iter() {
            match record.fields.get(field) {
                Some(value) => {
                    if !pattern.is_match(value.to_string().as_str()) {
                        return false
                    }
                }
                None => return false
            }
        }
        
        true
    }
}

// -----------------------------------------------------------------------------
// Rate Limit Filter
// -----------------------------------------------------------------------------

/// Limits log rate to prevent flooding
struct RateLimitFilter {
    max_per_second: Int
    window: Duration
    counts: Map<String, (Int, DateTime)>
    key_fn: fn(LogRecord) -> String
}

impl RateLimitFilter {
    fn new(max_per_second: Int) -> Self {
        RateLimitFilter {
            max_per_second: max_per_second,
            window: Duration.seconds(1),
            counts: Map.new(),
            key_fn: |r| r.message.clone()
        }
    }
    
    fn with_window(window: Duration) -> Self {
        self.window = window
        self
    }
    
    /// Key by message
    fn by_message() -> Self {
        self.key_fn = |r| r.message.clone()
        self
    }
    
    /// Key by logger name
    fn by_logger() -> Self {
        self.key_fn = |r| r.logger_name.clone()
        self
    }
    
    /// Key by level
    fn by_level() -> Self {
        self.key_fn = |r| r.level.name()
        self
    }
    
    /// Key by custom function
    fn by<F: Fn(LogRecord) -> String>(key_fn: F) -> Self {
        self.key_fn = key_fn
        self
    }
    
    fn cleanup_old_entries() {
        let now = DateTime.now()
        let expired: [String] = self.counts.iter()
            .filter(|(_, (_, time))| now.diff(*time) > self.window)
            .map(|(k, _)| k.clone())
            .collect()
        
        for key in expired {
            self.counts.remove(&key)
        }
    }
}

impl Filter for RateLimitFilter {
    fn filter(record: LogRecord) -> Bool {
        let key = (self.key_fn)(record.clone())
        let now = DateTime.now()
        
        // Cleanup periodically
        if self.counts.len() > 1000 {
            self.cleanup_old_entries()
        }
        
        match self.counts.get_mut(&key) {
            Some((count, start_time)) => {
                if now.diff(*start_time) > self.window {
                    // Reset window
                    *count = 1
                    *start_time = now
                    true
                } else if *count < self.max_per_second {
                    *count += 1
                    true
                } else {
                    false
                }
            }
            None => {
                self.counts.insert(key, (1, now))
                true
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Sampling Filter
// -----------------------------------------------------------------------------

/// Samples logs at a given rate
struct SamplingFilter {
    rate: Float
    counter: Int
    sample_every: Option<Int>
}

impl SamplingFilter {
    /// Sample at given rate (0.0 to 1.0)
    fn new(rate: Float) -> Self {
        SamplingFilter {
            rate: rate.clamp(0.0, 1.0),
            counter: 0,
            sample_every: None
        }
    }
    
    /// Sample every N logs
    fn every(n: Int) -> Self {
        SamplingFilter {
            rate: 1.0,
            counter: 0,
            sample_every: Some(n)
        }
    }
    
    /// 10% sampling
    fn ten_percent() -> Self {
        Self.new(0.1)
    }
    
    /// 1% sampling
    fn one_percent() -> Self {
        Self.new(0.01)
    }
}

impl Filter for SamplingFilter {
    fn filter(_record: LogRecord) -> Bool {
        if let Some(n) = self.sample_every {
            self.counter += 1
            if self.counter >= n {
                self.counter = 0
                return true
            }
            return false
        }
        
        Random.float() < self.rate
    }
}

// -----------------------------------------------------------------------------
// Deduplication Filter
// -----------------------------------------------------------------------------

/// Deduplicates repeated log messages
struct DeduplicationFilter {
    window: Duration
    seen: Map<String, (Int, DateTime)>
    max_duplicates: Int
    key_fn: fn(LogRecord) -> String
}

impl DeduplicationFilter {
    fn new(window: Duration) -> Self {
        DeduplicationFilter {
            window: window,
            seen: Map.new(),
            max_duplicates: 1,
            key_fn: |r| r.message.clone()
        }
    }
    
    fn with_max_duplicates(max: Int) -> Self {
        self.max_duplicates = max
        self
    }
    
    /// Key by message and level
    fn by_message_and_level() -> Self {
        self.key_fn = |r| "\(r.level.name()):\(r.message)"
        self
    }
    
    /// Key by custom function
    fn by<F: Fn(LogRecord) -> String>(key_fn: F) -> Self {
        self.key_fn = key_fn
        self
    }
    
    fn cleanup_old_entries() {
        let now = DateTime.now()
        let expired: [String] = self.seen.iter()
            .filter(|(_, (_, time))| now.diff(*time) > self.window)
            .map(|(k, _)| k.clone())
            .collect()
        
        for key in expired {
            self.seen.remove(&key)
        }
    }
}

impl Filter for DeduplicationFilter {
    fn filter(record: LogRecord) -> Bool {
        let key = (self.key_fn)(record.clone())
        let now = DateTime.now()
        
        // Cleanup periodically
        if self.seen.len() > 1000 {
            self.cleanup_old_entries()
        }
        
        match self.seen.get_mut(&key) {
            Some((count, first_seen)) => {
                if now.diff(*first_seen) > self.window {
                    // Reset window
                    *count = 1
                    *first_seen = now
                    true
                } else if *count < self.max_duplicates {
                    *count += 1
                    true
                } else {
                    false
                }
            }
            None => {
                self.seen.insert(key, (1, now))
                true
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Composite Filters
// -----------------------------------------------------------------------------

/// Combines filters with AND logic
struct AndFilter {
    filters: [Box<dyn Filter>]
}

impl AndFilter {
    fn new() -> Self {
        AndFilter { filters: [] }
    }
    
    fn add<F: Filter>(filter: F) -> Self {
        self.filters.push(Box.new(filter))
        self
    }
}

impl Filter for AndFilter {
    fn filter(record: LogRecord) -> Bool {
        for filter in self.filters.iter() {
            if !filter.filter(record.clone()) {
                return false
            }
        }
        true
    }
}

/// Combines filters with OR logic
struct OrFilter {
    filters: [Box<dyn Filter>]
}

impl OrFilter {
    fn new() -> Self {
        OrFilter { filters: [] }
    }
    
    fn add<F: Filter>(filter: F) -> Self {
        self.filters.push(Box.new(filter))
        self
    }
}

impl Filter for OrFilter {
    fn filter(record: LogRecord) -> Bool {
        if self.filters.is_empty() {
            return true
        }
        
        for filter in self.filters.iter() {
            if filter.filter(record.clone()) {
                return true
            }
        }
        false
    }
}

/// Negates a filter
struct NotFilter {
    inner: Box<dyn Filter>
}

impl NotFilter {
    fn new<F: Filter>(filter: F) -> Self {
        NotFilter { inner: Box.new(filter) }
    }
}

impl Filter for NotFilter {
    fn filter(record: LogRecord) -> Bool {
        !self.inner.filter(record)
    }
}

// -----------------------------------------------------------------------------
// Callback Filter
// -----------------------------------------------------------------------------

/// Custom filter using callback function
struct CallbackFilter {
    callback: fn(LogRecord) -> Bool
}

impl CallbackFilter {
    fn new<F: Fn(LogRecord) -> Bool>(callback: F) -> Self {
        CallbackFilter { callback: callback }
    }
}

impl Filter for CallbackFilter {
    fn filter(record: LogRecord) -> Bool {
        (self.callback)(record)
    }
}

// -----------------------------------------------------------------------------
// Time-based Filter
// -----------------------------------------------------------------------------

/// Filters by time of day
struct TimeFilter {
    start_hour: Int
    end_hour: Int
    days: Option<[Weekday]>
}

impl TimeFilter {
    fn new(start_hour: Int, end_hour: Int) -> Self {
        TimeFilter {
            start_hour: start_hour,
            end_hour: end_hour,
            days: None
        }
    }
    
    /// Business hours (9-17)
    fn business_hours() -> Self {
        Self.new(9, 17)
    }
    
    /// Night hours (22-6)
    fn night_hours() -> Self {
        Self.new(22, 6)
    }
    
    fn on_days(days: [Weekday]) -> Self {
        self.days = Some(days)
        self
    }
    
    fn weekdays_only() -> Self {
        self.on_days([Weekday.Monday, Weekday.Tuesday, Weekday.Wednesday, 
                      Weekday.Thursday, Weekday.Friday])
    }
}

impl Filter for TimeFilter {
    fn filter(record: LogRecord) -> Bool {
        let hour = record.timestamp.hour()
        
        // Check hour range
        let in_range = if self.start_hour <= self.end_hour {
            hour >= self.start_hour && hour < self.end_hour
        } else {
            // Wraps around midnight
            hour >= self.start_hour || hour < self.end_hour
        }
        
        if !in_range { return false }
        
        // Check days
        if let Some(days) = self.days.as_ref() {
            let weekday = record.timestamp.weekday()
            if !days.contains(&weekday) {
                return false
            }
        }
        
        true
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "level filter min" {
    let filter = LevelFilter.min(Level.Warn)
    
    assert(!filter.filter(LogRecord.new(Level.Debug, "debug")))?
    assert(!filter.filter(LogRecord.new(Level.Info, "info")))?
    assert(filter.filter(LogRecord.new(Level.Warn, "warn")))?
    assert(filter.filter(LogRecord.new(Level.Error, "error")))?
}

test "level filter exact" {
    let filter = LevelFilter.exact([Level.Info, Level.Error])
    
    assert(!filter.filter(LogRecord.new(Level.Debug, "debug")))?
    assert(filter.filter(LogRecord.new(Level.Info, "info")))?
    assert(!filter.filter(LogRecord.new(Level.Warn, "warn")))?
    assert(filter.filter(LogRecord.new(Level.Error, "error")))?
}

test "message filter contains" {
    let filter = MessageFilter.new()
        .contains("error")
        .not_contains("ignore")
    
    assert(filter.filter(LogRecord.new(Level.Info, "an error occurred")))?
    assert(!filter.filter(LogRecord.new(Level.Info, "ignore this error")))?
    assert(!filter.filter(LogRecord.new(Level.Info, "normal message")))?
}

test "field filter" {
    let filter = FieldFilter.new()
        .require("user_id")
        .equals("status", "active")
    
    let record1 = LogRecord.new(Level.Info, "test")
        .with_field("user_id", "123")
        .with_field("status", "active")
    
    let record2 = LogRecord.new(Level.Info, "test")
        .with_field("status", "active")
    
    assert(filter.filter(record1))?
    assert(!filter.filter(record2))?
}

test "and filter" {
    let filter = AndFilter.new()
        .add(LevelFilter.min(Level.Info))
        .add(MessageFilter.new().contains("important"))
    
    assert(!filter.filter(LogRecord.new(Level.Debug, "important")))?
    assert(!filter.filter(LogRecord.new(Level.Info, "normal")))?
    assert(filter.filter(LogRecord.new(Level.Info, "important message")))?
}

test "or filter" {
    let filter = OrFilter.new()
        .add(LevelFilter.min(Level.Error))
        .add(MessageFilter.new().contains("critical"))
    
    assert(filter.filter(LogRecord.new(Level.Error, "error")))?
    assert(filter.filter(LogRecord.new(Level.Info, "critical issue")))?
    assert(!filter.filter(LogRecord.new(Level.Info, "normal")))?
}

test "sampling filter" {
    let filter = SamplingFilter.every(10)
    var passed = 0
    
    for _ in 0..100 {
        if filter.filter(LogRecord.new(Level.Info, "test")) {
            passed += 1
        }
    }
    
    assert_eq(passed, 10)?
}
