// =============================================================================
// Vibee OS â€” JSONC Module
// JSON with Comments parsing and generation
// =============================================================================

// -----------------------------------------------------------------------------
// JSONC Value
// -----------------------------------------------------------------------------

enum Value {
    Null
    Bool(Bool)
    Number(Float)
    String(String)
    Array([Value])
    Object(Map<String, Value>)
    
    fn parse(jsonc: String) -> Result<Value, JSONCError> { Parser.new(jsonc).parse() }
    
    fn parse_file(path: String) -> Result<Value, JSONCError> {
        let content = File.read_string(path)?
        Self.parse(content)
    }
    
    fn is_null() -> Bool { match self { .Null => true, _ => false } }
    fn is_bool() -> Bool { match self { .Bool(_) => true, _ => false } }
    fn is_number() -> Bool { match self { .Number(_) => true, _ => false } }
    fn is_string() -> Bool { match self { .String(_) => true, _ => false } }
    fn is_array() -> Bool { match self { .Array(_) => true, _ => false } }
    fn is_object() -> Bool { match self { .Object(_) => true, _ => false } }
    
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    fn as_number() -> Option<Float> { match self { .Number(n) => Some(n), _ => None } }
    fn as_int() -> Option<Int> { match self { .Number(n) => Some(n as Int), _ => None } }
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_array() -> Option<[Value]> { match self { .Array(a) => Some(a), _ => None } }
    fn as_object() -> Option<Map<String, Value>> { match self { .Object(o) => Some(o), _ => None } }
    
    fn get(key: String) -> Option<Value> { match self { .Object(o) => o.get(key), _ => None } }
    fn at(idx: Int) -> Option<Value> { match self { .Array(a) if idx >= 0 && idx < a.len() => Some(a[idx]), _ => None } }
    
    fn path(p: String) -> Option<Value> {
        let parts = p.split(".")
        var current = self
        for part in parts {
            if let Ok(idx) = Int.parse(part) { current = current.at(idx)? }
            else { current = current.get(part)? }
        }
        Some(current)
    }
    
    fn to_json() -> String { Emitter.new().emit(self) }
    fn to_json_pretty() -> String { Emitter.pretty().emit(self) }
    fn to_jsonc() -> String { self.to_json_pretty() }
}

impl Index<String> for Value {
    type Output = Option<Value>
    fn index(key: String) -> Option<Value> { self.get(key) }
}

// -----------------------------------------------------------------------------
// Parser
// -----------------------------------------------------------------------------

actor Parser {
    state input: String
    state pos: Int
    state line: Int
    state col: Int
    
    fn new(input: String) -> Self {
        Parser { input: input, pos: 0, line: 1, col: 1 }
    }
    
    fn parse() -> Result<Value, JSONCError> {
        self.skip_whitespace_and_comments()
        let value = self.parse_value()?
        self.skip_whitespace_and_comments()
        if self.pos < self.input.len() {
            return Err(JSONCError.TrailingContent(self.line, self.col))
        }
        Ok(value)
    }
    
    fn parse_value() -> Result<Value, JSONCError> {
        self.skip_whitespace_and_comments()
        
        match self.peek_char() {
            Some('{') => self.parse_object()
            Some('[') => self.parse_array()
            Some('"') => Ok(Value.String(self.parse_string()?))
            Some('t') if self.peek_str("true") => { self.advance(4); Ok(Value.Bool(true)) }
            Some('f') if self.peek_str("false") => { self.advance(5); Ok(Value.Bool(false)) }
            Some('n') if self.peek_str("null") => { self.advance(4); Ok(Value.Null) }
            Some(c) if c.is_digit() || c == '-' => self.parse_number()
            Some(c) => Err(JSONCError.UnexpectedChar(c, self.line, self.col))
            None => Err(JSONCError.UnexpectedEOF)
        }
    }
    
    fn parse_object() -> Result<Value, JSONCError> {
        self.expect('{')?
        var map = Map.empty()
        
        self.skip_whitespace_and_comments()
        if self.peek_char() == Some('}') {
            self.advance(1)
            return Ok(Value.Object(map))
        }
        
        loop {
            self.skip_whitespace_and_comments()
            let key = self.parse_string()?
            
            self.skip_whitespace_and_comments()
            self.expect(':')?
            
            self.skip_whitespace_and_comments()
            let value = self.parse_value()?
            map.set(key, value)
            
            self.skip_whitespace_and_comments()
            match self.peek_char() {
                Some(',') => { self.advance(1); self.skip_whitespace_and_comments(); if self.peek_char() == Some('}') { self.advance(1); break } }
                Some('}') => { self.advance(1); break }
                _ => return Err(JSONCError.Expected(',', self.line, self.col))
            }
        }
        
        Ok(Value.Object(map))
    }
    
    fn parse_array() -> Result<Value, JSONCError> {
        self.expect('[')?
        var items = []
        
        self.skip_whitespace_and_comments()
        if self.peek_char() == Some(']') {
            self.advance(1)
            return Ok(Value.Array(items))
        }
        
        loop {
            self.skip_whitespace_and_comments()
            items.append(self.parse_value()?)
            
            self.skip_whitespace_and_comments()
            match self.peek_char() {
                Some(',') => { self.advance(1); self.skip_whitespace_and_comments(); if self.peek_char() == Some(']') { self.advance(1); break } }
                Some(']') => { self.advance(1); break }
                _ => return Err(JSONCError.Expected(',', self.line, self.col))
            }
        }
        
        Ok(Value.Array(items))
    }
    
    fn parse_string() -> Result<String, JSONCError> {
        self.expect('"')?
        var result = StringBuilder.new()
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            self.pos += 1
            self.col += 1
            
            if c == '"' { return Ok(result.build()) }
            if c == '\\' {
                if self.pos >= self.input.len() { return Err(JSONCError.UnexpectedEOF) }
                let escaped = self.input[self.pos]
                self.pos += 1
                self.col += 1
                
                match escaped {
                    '"' => result.append('"')
                    '\\' => result.append('\\')
                    '/' => result.append('/')
                    'b' => result.append('\x08')
                    'f' => result.append('\x0C')
                    'n' => result.append('\n')
                    'r' => result.append('\r')
                    't' => result.append('\t')
                    'u' => {
                        if self.pos + 4 > self.input.len() { return Err(JSONCError.InvalidEscape(self.line)) }
                        let hex = self.input[self.pos..self.pos + 4]
                        self.pos += 4
                        self.col += 4
                        let code = Int.parse_hex(hex)?
                        result.append(Char.from_code(code))
                    }
                    _ => return Err(JSONCError.InvalidEscape(self.line))
                }
            } else if c == '\n' {
                return Err(JSONCError.UnterminatedString(self.line))
            } else {
                result.append(c)
            }
        }
        
        Err(JSONCError.UnterminatedString(self.line))
    }
    
    fn parse_number() -> Result<Value, JSONCError> {
        let start = self.pos
        
        if self.peek_char() == Some('-') { self.advance(1) }
        
        if self.peek_char() == Some('0') {
            self.advance(1)
        } else if self.peek_char()?.is_digit() {
            while self.peek_char()?.is_digit() { self.advance(1) }
        } else {
            return Err(JSONCError.InvalidNumber(self.line))
        }
        
        if self.peek_char() == Some('.') {
            self.advance(1)
            if !self.peek_char()?.is_digit() { return Err(JSONCError.InvalidNumber(self.line)) }
            while self.peek_char()?.is_digit() { self.advance(1) }
        }
        
        if self.peek_char() == Some('e') || self.peek_char() == Some('E') {
            self.advance(1)
            if self.peek_char() == Some('+') || self.peek_char() == Some('-') { self.advance(1) }
            if !self.peek_char()?.is_digit() { return Err(JSONCError.InvalidNumber(self.line)) }
            while self.peek_char()?.is_digit() { self.advance(1) }
        }
        
        let s = self.input[start..self.pos]
        Ok(Value.Number(Float.parse(s)?))
    }
    
    fn skip_whitespace_and_comments() {
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            
            if c == ' ' || c == '\t' || c == '\r' {
                self.pos += 1
                self.col += 1
            } else if c == '\n' {
                self.pos += 1
                self.line += 1
                self.col = 1
            } else if self.peek_str("//") {
                self.skip_line_comment()
            } else if self.peek_str("/*") {
                self.skip_block_comment()
            } else {
                break
            }
        }
    }
    
    fn skip_line_comment() {
        self.pos += 2
        self.col += 2
        while self.pos < self.input.len() && self.input[self.pos] != '\n' {
            self.pos += 1
            self.col += 1
        }
    }
    
    fn skip_block_comment() {
        self.pos += 2
        self.col += 2
        while self.pos < self.input.len() - 1 {
            if self.input[self.pos] == '\n' {
                self.line += 1
                self.col = 1
            } else {
                self.col += 1
            }
            if self.peek_str("*/") {
                self.pos += 2
                self.col += 2
                return
            }
            self.pos += 1
        }
    }
    
    fn peek_char() -> Option<Char> { if self.pos < self.input.len() { Some(self.input[self.pos]) } else { None } }
    fn peek_str(s: String) -> Bool { self.input[self.pos..].starts_with(s) }
    fn advance(n: Int) { self.pos += n; self.col += n }
    fn expect(c: Char) -> Result<(), JSONCError> {
        if self.peek_char() == Some(c) { self.advance(1); Ok(()) }
        else { Err(JSONCError.Expected(c, self.line, self.col)) }
    }
}

// -----------------------------------------------------------------------------
// Emitter
// -----------------------------------------------------------------------------

struct EmitOptions {
    indent: String
    trailing_comma: Bool
    
    fn default() -> Self { EmitOptions { indent: "", trailing_comma: false } }
    fn pretty() -> Self { EmitOptions { indent: "  ", trailing_comma: true } }
}

actor Emitter {
    state options: EmitOptions
    state depth: Int
    
    fn new() -> Self { Emitter { options: EmitOptions.default(), depth: 0 } }
    fn pretty() -> Self { Emitter { options: EmitOptions.pretty(), depth: 0 } }
    fn with_options(options: EmitOptions) -> Self { Emitter { options: options, depth: 0 } }
    
    fn emit(value: Value) -> String {
        match value {
            .Null => "null"
            .Bool(b) => if b { "true" } else { "false" }
            .Number(n) => if n == n.floor() && n.abs() < 1e15 { "\(n as Int)" } else { "\(n)" }
            .String(s) => self.emit_string(s)
            .Array(a) => self.emit_array(a)
            .Object(o) => self.emit_object(o)
        }
    }
    
    fn emit_string(s: String) -> String {
        var result = "\""
        for c in s {
            match c {
                '"' => result += "\\\""
                '\\' => result += "\\\\"
                '\n' => result += "\\n"
                '\r' => result += "\\r"
                '\t' => result += "\\t"
                _ if c.code() < 32 => result += "\\u\(c.code().to_hex_padded(4))"
                _ => result += c
            }
        }
        result + "\""
    }
    
    fn emit_array(items: [Value]) -> String {
        if items.is_empty() { return "[]" }
        
        if self.options.indent.is_empty() {
            return "[" + items.map(|v| self.emit(v)).join(",") + "]"
        }
        
        self.depth += 1
        var result = "[\n"
        for (i, item) in items.enumerate() {
            result += self.indent() + self.emit(item)
            if i < items.len() - 1 { result += "," }
            else if self.options.trailing_comma { result += "," }
            result += "\n"
        }
        self.depth -= 1
        result += self.indent() + "]"
        result
    }
    
    fn emit_object(map: Map<String, Value>) -> String {
        if map.is_empty() { return "{}" }
        
        if self.options.indent.is_empty() {
            return "{" + map.map(|(k, v)| self.emit_string(k) + ":" + self.emit(v)).join(",") + "}"
        }
        
        self.depth += 1
        var result = "{\n"
        let entries = map.entries()
        for (i, (key, value)) in entries.enumerate() {
            result += self.indent() + self.emit_string(key) + ": " + self.emit(value)
            if i < entries.len() - 1 { result += "," }
            else if self.options.trailing_comma { result += "," }
            result += "\n"
        }
        self.depth -= 1
        result += self.indent() + "}"
        result
    }
    
    fn indent() -> String { self.options.indent.repeat(self.depth) }
}

// -----------------------------------------------------------------------------
// Builder
// -----------------------------------------------------------------------------

struct ObjectBuilder {
    map: Map<String, Value>
    
    fn new() -> Self { ObjectBuilder { map: Map.empty() } }
    fn set(key: String, value: Value) -> Self { self.map.set(key, value); self }
    fn string(key: String, value: String) -> Self { self.set(key, Value.String(value)) }
    fn number(key: String, value: Float) -> Self { self.set(key, Value.Number(value)) }
    fn int(key: String, value: Int) -> Self { self.set(key, Value.Number(value as Float)) }
    fn bool(key: String, value: Bool) -> Self { self.set(key, Value.Bool(value)) }
    fn null(key: String) -> Self { self.set(key, Value.Null) }
    fn array(key: String, items: [Value]) -> Self { self.set(key, Value.Array(items)) }
    fn object(key: String, obj: Value) -> Self { self.set(key, obj) }
    fn build() -> Value { Value.Object(self.map) }
}

struct ArrayBuilder {
    items: [Value]
    
    fn new() -> Self { ArrayBuilder { items: [] } }
    fn add(value: Value) -> Self { self.items.append(value); self }
    fn string(value: String) -> Self { self.add(Value.String(value)) }
    fn number(value: Float) -> Self { self.add(Value.Number(value)) }
    fn int(value: Int) -> Self { self.add(Value.Number(value as Float)) }
    fn bool(value: Bool) -> Self { self.add(Value.Bool(value)) }
    fn null() -> Self { self.add(Value.Null) }
    fn build() -> Value { Value.Array(self.items) }
}

fn object() -> ObjectBuilder { ObjectBuilder.new() }
fn array() -> ArrayBuilder { ArrayBuilder.new() }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum JSONCError {
    UnexpectedChar(Char, Int, Int)
    UnexpectedEOF
    Expected(Char, Int, Int)
    UnterminatedString(Int)
    InvalidEscape(Int)
    InvalidNumber(Int)
    TrailingContent(Int, Int)
    IOError(String)
    
    fn message() -> String {
        match self {
            .UnexpectedChar(c, l, col) => "Unexpected character '\(c)' at line \(l), column \(col)"
            .UnexpectedEOF => "Unexpected end of file"
            .Expected(c, l, col) => "Expected '\(c)' at line \(l), column \(col)"
            .UnterminatedString(l) => "Unterminated string at line \(l)"
            .InvalidEscape(l) => "Invalid escape sequence at line \(l)"
            .InvalidNumber(l) => "Invalid number at line \(l)"
            .TrailingContent(l, col) => "Trailing content at line \(l), column \(col)"
            .IOError(m) => "I/O error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn parse(jsonc: String) -> Result<Value, JSONCError> { Value.parse(jsonc) }
fn parse_file(path: String) -> Result<Value, JSONCError> { Value.parse_file(path) }

fn strip_comments(jsonc: String) -> String {
    var result = StringBuilder.new()
    var pos = 0
    var in_string = false
    
    while pos < jsonc.len() {
        let c = jsonc[pos]
        
        if in_string {
            result.append(c)
            if c == '"' && (pos == 0 || jsonc[pos - 1] != '\\') { in_string = false }
            pos += 1
        } else if c == '"' {
            in_string = true
            result.append(c)
            pos += 1
        } else if jsonc[pos..].starts_with("//") {
            while pos < jsonc.len() && jsonc[pos] != '\n' { pos += 1 }
        } else if jsonc[pos..].starts_with("/*") {
            pos += 2
            while pos < jsonc.len() - 1 && !jsonc[pos..].starts_with("*/") { pos += 1 }
            pos += 2
        } else {
            result.append(c)
            pos += 1
        }
    }
    
    result.build()
}

fn to_json(value: Value) -> String { value.to_json() }
fn to_json_pretty(value: Value) -> String { value.to_json_pretty() }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse with line comments" {
    let jsonc = "{\n  // This is a comment\n  \"name\": \"test\"\n}"
    let v = parse(jsonc)?
    assert(v["name"]?.as_str() == Some("test"))
}

test "parse with block comments" {
    let jsonc = "{\n  /* multi\n     line\n     comment */\n  \"value\": 42\n}"
    let v = parse(jsonc)?
    assert(v["value"]?.as_int() == Some(42))
}

test "parse with trailing commas" {
    let jsonc = "{\n  \"a\": 1,\n  \"b\": 2,\n}"
    let v = parse(jsonc)?
    assert(v["a"]?.as_int() == Some(1))
    assert(v["b"]?.as_int() == Some(2))
}

test "parse array with trailing comma" {
    let jsonc = "[1, 2, 3,]"
    let v = parse(jsonc)?
    assert(v.at(0)?.as_int() == Some(1))
    assert(v.at(2)?.as_int() == Some(3))
}

test "emit pretty jsonc" {
    let v = object().string("name", "test").int("count", 42).build()
    let jsonc = v.to_json_pretty()
    assert(jsonc.contains("\"name\": \"test\""))
    assert(jsonc.contains("\"count\": 42"))
}

test "strip comments" {
    let jsonc = "{\n  // comment\n  \"key\": \"value\" /* inline */\n}"
    let json = strip_comments(jsonc)
    assert(!json.contains("//"))
    assert(!json.contains("/*"))
}

test "nested structures" {
    let jsonc = "{\n  \"config\": {\n    // nested comment\n    \"enabled\": true\n  }\n}"
    let v = parse(jsonc)?
    assert(v.path("config.enabled")?.as_bool() == Some(true))
}
