// =============================================================================
// Vibee OS â€” Contract Module
// Smart contract development and interaction
// =============================================================================

// =============================================================================
// Contract Definition
// =============================================================================

/// Smart contract base trait
trait Contract {
    fn address() -> Address
    fn balance() -> UInt256
    fn code() -> [UInt8]
}

/// Contract storage
struct Storage {
    slots: Map<[UInt8; 32], [UInt8; 32]>
    
    fn new() -> Self { Storage { slots: Map.empty() } }
    
    fn get(slot: [UInt8; 32]) -> [UInt8; 32] {
        self.slots.get(slot).unwrap_or([0u8; 32])
    }
    
    fn set(slot: [UInt8; 32], value: [UInt8; 32]) {
        self.slots.set(slot, value)
    }
    
    fn get_uint(slot: [UInt8; 32]) -> UInt256 {
        UInt256.from_be_bytes(self.get(slot))
    }
    
    fn set_uint(slot: [UInt8; 32], value: UInt256) {
        self.set(slot, value.to_be_bytes())
    }
    
    fn get_address(slot: [UInt8; 32]) -> Address {
        Address { bytes: self.get(slot)[12..32].try_into().unwrap() }
    }
    
    fn set_address(slot: [UInt8; 32], addr: Address) {
        var value = [0u8; 32]
        value[12..32].copy_from_slice(addr.bytes)
        self.set(slot, value)
    }
    
    fn slot_for_mapping(key: [UInt8], base_slot: [UInt8; 32]) -> [UInt8; 32] {
        crypto.keccak256(key + base_slot)
    }
    
    fn slot_for_array(index: UInt256, base_slot: [UInt8; 32]) -> [UInt8; 32] {
        let base = UInt256.from_be_bytes(crypto.keccak256(base_slot))
        (base + index).to_be_bytes()
    }
}

// =============================================================================
// ABI Encoding/Decoding
// =============================================================================

/// ABI encoder for contract calls
struct AbiEncoder {
    data: [UInt8]
    
    fn new() -> Self { AbiEncoder { data: [] } }
    
    fn with_selector(selector: [UInt8; 4]) -> Self {
        AbiEncoder { data: selector.to_vec() }
    }
    
    fn function(signature: String) -> Self {
        let hash = crypto.keccak256(signature.as_bytes())
        Self.with_selector(hash[0..4].try_into().unwrap())
    }
    
    fn encode_uint256(value: UInt256) -> Self {
        self.data.extend(value.to_be_bytes())
        self
    }
    
    fn encode_int256(value: Int256) -> Self {
        self.data.extend(value.to_be_bytes())
        self
    }
    
    fn encode_address(addr: Address) -> Self {
        var padded = [0u8; 32]
        padded[12..32].copy_from_slice(addr.bytes)
        self.data.extend(padded)
        self
    }
    
    fn encode_bool(value: Bool) -> Self {
        var padded = [0u8; 32]
        if value { padded[31] = 1 }
        self.data.extend(padded)
        self
    }
    
    fn encode_bytes32(value: [UInt8; 32]) -> Self {
        self.data.extend(value)
        self
    }
    
    fn encode_bytes(value: [UInt8]) -> Self {
        let offset = self.data.len() + 32
        self.encode_uint256(UInt256.from(offset))
        
        let len = value.len()
        self.encode_uint256(UInt256.from(len))
        
        self.data.extend(value)
        let padding = (32 - len % 32) % 32
        self.data.extend(vec![0u8; padding])
        self
    }
    
    fn encode_string(value: String) -> Self {
        self.encode_bytes(value.as_bytes())
    }
    
    fn encode_array<T>(values: [T], encoder: fn(T) -> [UInt8; 32]) -> Self {
        let offset = self.data.len() + 32
        self.encode_uint256(UInt256.from(offset))
        self.encode_uint256(UInt256.from(values.len()))
        for v in values {
            self.data.extend(encoder(v))
        }
        self
    }
    
    fn build() -> [UInt8] { self.data.clone() }
}

/// ABI decoder for contract responses
struct AbiDecoder {
    data: [UInt8]
    offset: Int
    
    fn new(data: [UInt8]) -> Self { AbiDecoder { data: data, offset: 0 } }
    
    fn decode_uint256() -> UInt256 {
        let value = UInt256.from_be_bytes(self.data[self.offset..self.offset+32].try_into().unwrap())
        self.offset += 32
        value
    }
    
    fn decode_int256() -> Int256 {
        let value = Int256.from_be_bytes(self.data[self.offset..self.offset+32].try_into().unwrap())
        self.offset += 32
        value
    }
    
    fn decode_address() -> Address {
        let bytes = self.data[self.offset+12..self.offset+32].try_into().unwrap()
        self.offset += 32
        Address { bytes: bytes }
    }
    
    fn decode_bool() -> Bool {
        let value = self.data[self.offset + 31] != 0
        self.offset += 32
        value
    }
    
    fn decode_bytes32() -> [UInt8; 32] {
        let value = self.data[self.offset..self.offset+32].try_into().unwrap()
        self.offset += 32
        value
    }
    
    fn decode_bytes() -> [UInt8] {
        let data_offset = self.decode_uint256().to_int()
        let saved = self.offset
        self.offset = data_offset
        let len = self.decode_uint256().to_int()
        let value = self.data[self.offset..self.offset+len].to_vec()
        self.offset = saved
        value
    }
    
    fn decode_string() -> String {
        String.from_utf8(self.decode_bytes()).unwrap_or("")
    }
    
    fn skip(count: Int) { self.offset += count * 32 }
}

/// Function selector
fn selector(signature: String) -> [UInt8; 4] {
    crypto.keccak256(signature.as_bytes())[0..4].try_into().unwrap()
}

/// Event topic
fn event_topic(signature: String) -> [UInt8; 32] {
    crypto.keccak256(signature.as_bytes())
}

// =============================================================================
// Contract Call
// =============================================================================

/// Contract call builder
struct ContractCall {
    to: Address
    data: [UInt8]
    value: UInt256
    gas: Option<UInt64>
    
    fn new(to: Address) -> Self {
        ContractCall { to: to, data: [], value: UInt256.zero(), gas: None }
    }
    
    fn function(signature: String) -> Self {
        self.data = AbiEncoder.function(signature).build()
        self
    }
    
    fn with_data(data: [UInt8]) -> Self {
        self.data = data
        self
    }
    
    fn with_value(value: UInt256) -> Self {
        self.value = value
        self
    }
    
    fn with_gas(gas: UInt64) -> Self {
        self.gas = Some(gas)
        self
    }
    
    fn encode_param<T: AbiEncode>(param: T) -> Self {
        self.data.extend(param.abi_encode())
        self
    }
    
    fn call() -> Result<[UInt8], ContractError> {
        @native("eth_call", self.to, self.data, self.value, self.gas)
    }
    
    fn estimate_gas() -> Result<UInt64, ContractError> {
        @native("eth_estimate_gas", self.to, self.data, self.value)
    }
}

/// Trait for ABI encoding
trait AbiEncode {
    fn abi_encode() -> [UInt8]
}

impl AbiEncode for UInt256 {
    fn abi_encode() -> [UInt8] { self.to_be_bytes().to_vec() }
}

impl AbiEncode for Address {
    fn abi_encode() -> [UInt8] {
        var padded = [0u8; 32]
        padded[12..32].copy_from_slice(self.bytes)
        padded.to_vec()
    }
}

impl AbiEncode for Bool {
    fn abi_encode() -> [UInt8] {
        var padded = [0u8; 32]
        if self { padded[31] = 1 }
        padded.to_vec()
    }
}

// =============================================================================
// Contract Deployment
// =============================================================================

/// Contract deployment
struct ContractDeployment {
    bytecode: [UInt8]
    constructor_args: [UInt8]
    value: UInt256
    
    fn new(bytecode: [UInt8]) -> Self {
        ContractDeployment { bytecode: bytecode, constructor_args: [], value: UInt256.zero() }
    }
    
    fn from_hex(hex: String) -> Result<Self, ContractError> {
        let bytecode = hex.decode(hex.trim_start("0x"))?
        Ok(Self.new(bytecode))
    }
    
    fn with_constructor<T: AbiEncode>(args: [T]) -> Self {
        for arg in args {
            self.constructor_args.extend(arg.abi_encode())
        }
        self
    }
    
    fn with_value(value: UInt256) -> Self {
        self.value = value
        self
    }
    
    fn data() -> [UInt8] {
        var data = self.bytecode.clone()
        data.extend(self.constructor_args)
        data
    }
    
    fn deploy(signer: Account) -> Result<Address, ContractError> {
        let tx = Transaction {
            to: None,
            value: self.value,
            data: self.data(),
            gas_limit: 0,
            gas_price: UInt256.zero(),
            nonce: 0,
            chain_id: 1
        }
        let receipt = tx.send(signer)?
        receipt.contract_address.ok_or(ContractError.DeploymentFailed)
    }
}

// =============================================================================
// Events
// =============================================================================

/// Contract event
struct Event {
    address: Address
    topics: [[UInt8; 32]]
    data: [UInt8]
    block_number: UInt64
    transaction_hash: [UInt8; 32]
    log_index: UInt64
    
    fn topic(index: Int) -> Option<[UInt8; 32]> {
        self.topics.get(index).cloned()
    }
    
    fn decode_data<T: AbiDecode>() -> Result<T, ContractError> {
        T.abi_decode(self.data)
    }
}

/// Event filter
struct EventFilter {
    address: Option<Address>
    topics: [Option<[UInt8; 32]>; 4]
    from_block: BlockNumber
    to_block: BlockNumber
    
    fn new() -> Self {
        EventFilter {
            address: None,
            topics: [None, None, None, None],
            from_block: BlockNumber.Latest,
            to_block: BlockNumber.Latest
        }
    }
    
    fn address(addr: Address) -> Self {
        self.address = Some(addr)
        self
    }
    
    fn topic0(topic: [UInt8; 32]) -> Self {
        self.topics[0] = Some(topic)
        self
    }
    
    fn event(signature: String) -> Self {
        self.topic0(event_topic(signature))
    }
    
    fn from(block: BlockNumber) -> Self {
        self.from_block = block
        self
    }
    
    fn to(block: BlockNumber) -> Self {
        self.to_block = block
        self
    }
    
    fn query() -> Result<[Event], ContractError> {
        @native("eth_get_logs", self)
    }
}

enum BlockNumber {
    Latest
    Pending
    Earliest
    Number(UInt64)
}

/// Trait for ABI decoding
trait AbiDecode {
    fn abi_decode(data: [UInt8]) -> Result<Self, ContractError>
}

// =============================================================================
// Standard Interfaces
// =============================================================================

/// ERC-20 Token interface
struct ERC20 {
    address: Address
    
    fn new(address: Address) -> Self { ERC20 { address: address } }
    
    fn name() -> Result<String, ContractError> {
        let data = ContractCall.new(self.address).function("name()").call()?
        Ok(AbiDecoder.new(data).decode_string())
    }
    
    fn symbol() -> Result<String, ContractError> {
        let data = ContractCall.new(self.address).function("symbol()").call()?
        Ok(AbiDecoder.new(data).decode_string())
    }
    
    fn decimals() -> Result<UInt8, ContractError> {
        let data = ContractCall.new(self.address).function("decimals()").call()?
        Ok(AbiDecoder.new(data).decode_uint256().to_u8())
    }
    
    fn total_supply() -> Result<UInt256, ContractError> {
        let data = ContractCall.new(self.address).function("totalSupply()").call()?
        Ok(AbiDecoder.new(data).decode_uint256())
    }
    
    fn balance_of(account: Address) -> Result<UInt256, ContractError> {
        let data = AbiEncoder.function("balanceOf(address)").encode_address(account).build()
        let result = ContractCall.new(self.address).with_data(data).call()?
        Ok(AbiDecoder.new(result).decode_uint256())
    }
    
    fn allowance(owner: Address, spender: Address) -> Result<UInt256, ContractError> {
        let data = AbiEncoder.function("allowance(address,address)")
            .encode_address(owner)
            .encode_address(spender)
            .build()
        let result = ContractCall.new(self.address).with_data(data).call()?
        Ok(AbiDecoder.new(result).decode_uint256())
    }
    
    fn transfer(to: Address, amount: UInt256) -> ContractCall {
        let data = AbiEncoder.function("transfer(address,uint256)")
            .encode_address(to)
            .encode_uint256(amount)
            .build()
        ContractCall.new(self.address).with_data(data)
    }
    
    fn approve(spender: Address, amount: UInt256) -> ContractCall {
        let data = AbiEncoder.function("approve(address,uint256)")
            .encode_address(spender)
            .encode_uint256(amount)
            .build()
        ContractCall.new(self.address).with_data(data)
    }
    
    fn transfer_from(from: Address, to: Address, amount: UInt256) -> ContractCall {
        let data = AbiEncoder.function("transferFrom(address,address,uint256)")
            .encode_address(from)
            .encode_address(to)
            .encode_uint256(amount)
            .build()
        ContractCall.new(self.address).with_data(data)
    }
}

/// ERC-721 NFT interface
struct ERC721 {
    address: Address
    
    fn new(address: Address) -> Self { ERC721 { address: address } }
    
    fn name() -> Result<String, ContractError> {
        let data = ContractCall.new(self.address).function("name()").call()?
        Ok(AbiDecoder.new(data).decode_string())
    }
    
    fn symbol() -> Result<String, ContractError> {
        let data = ContractCall.new(self.address).function("symbol()").call()?
        Ok(AbiDecoder.new(data).decode_string())
    }
    
    fn owner_of(token_id: UInt256) -> Result<Address, ContractError> {
        let data = AbiEncoder.function("ownerOf(uint256)").encode_uint256(token_id).build()
        let result = ContractCall.new(self.address).with_data(data).call()?
        Ok(AbiDecoder.new(result).decode_address())
    }
    
    fn balance_of(owner: Address) -> Result<UInt256, ContractError> {
        let data = AbiEncoder.function("balanceOf(address)").encode_address(owner).build()
        let result = ContractCall.new(self.address).with_data(data).call()?
        Ok(AbiDecoder.new(result).decode_uint256())
    }
    
    fn token_uri(token_id: UInt256) -> Result<String, ContractError> {
        let data = AbiEncoder.function("tokenURI(uint256)").encode_uint256(token_id).build()
        let result = ContractCall.new(self.address).with_data(data).call()?
        Ok(AbiDecoder.new(result).decode_string())
    }
    
    fn transfer_from(from: Address, to: Address, token_id: UInt256) -> ContractCall {
        let data = AbiEncoder.function("transferFrom(address,address,uint256)")
            .encode_address(from)
            .encode_address(to)
            .encode_uint256(token_id)
            .build()
        ContractCall.new(self.address).with_data(data)
    }
    
    fn safe_transfer_from(from: Address, to: Address, token_id: UInt256) -> ContractCall {
        let data = AbiEncoder.function("safeTransferFrom(address,address,uint256)")
            .encode_address(from)
            .encode_address(to)
            .encode_uint256(token_id)
            .build()
        ContractCall.new(self.address).with_data(data)
    }
    
    fn approve(to: Address, token_id: UInt256) -> ContractCall {
        let data = AbiEncoder.function("approve(address,uint256)")
            .encode_address(to)
            .encode_uint256(token_id)
            .build()
        ContractCall.new(self.address).with_data(data)
    }
}

// =============================================================================
// Contract Builder (DSL)
// =============================================================================

/// Contract builder for creating contracts
struct ContractBuilder {
    name: String
    storage_vars: [(String, String)]
    functions: [FunctionDef]
    events: [EventDef]
    modifiers: [ModifierDef]
    
    fn new(name: String) -> Self {
        ContractBuilder {
            name: name,
            storage_vars: [],
            functions: [],
            events: [],
            modifiers: []
        }
    }
    
    fn storage(name: String, type_name: String) -> Self {
        self.storage_vars.push((name, type_name))
        self
    }
    
    fn function(def: FunctionDef) -> Self {
        self.functions.push(def)
        self
    }
    
    fn event(def: EventDef) -> Self {
        self.events.push(def)
        self
    }
    
    fn modifier(def: ModifierDef) -> Self {
        self.modifiers.push(def)
        self
    }
    
    fn compile() -> Result<[UInt8], ContractError> {
        @native("solidity_compile", self)
    }
}

struct FunctionDef {
    name: String
    visibility: Visibility
    mutability: Mutability
    params: [(String, String)]
    returns: [String]
    modifiers: [String]
    body: String
}

struct EventDef {
    name: String
    params: [(String, String, Bool)]  // (name, type, indexed)
}

struct ModifierDef {
    name: String
    params: [(String, String)]
    body: String
}

enum Visibility { Public, Private, Internal, External }
enum Mutability { Pure, View, Payable, NonPayable }

// =============================================================================
// Errors
// =============================================================================

enum ContractError {
    CallFailed(String)
    DeploymentFailed
    InvalidAbi
    InvalidBytecode
    InsufficientFunds
    Reverted(String)
    OutOfGas
}

impl Display for ContractError {
    fn fmt(f: Formatter) {
        match self {
            CallFailed(s) => f.write(format!("Call failed: {}", s))
            DeploymentFailed => f.write("Deployment failed")
            InvalidAbi => f.write("Invalid ABI")
            InvalidBytecode => f.write("Invalid bytecode")
            InsufficientFunds => f.write("Insufficient funds")
            Reverted(s) => f.write(format!("Reverted: {}", s))
            OutOfGas => f.write("Out of gas")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "selector" {
    assert_eq(selector("transfer(address,uint256)"), [0xa9, 0x05, 0x9c, 0xbb])?
}

test "abi encode uint256" {
    let encoded = AbiEncoder.new().encode_uint256(UInt256.from(1)).build()
    assert_eq(encoded.len(), 32)?
    assert_eq(encoded[31], 1)?
}

test "abi encode address" {
    let addr = Address.from_hex("0x1234567890123456789012345678901234567890")?
    let encoded = AbiEncoder.new().encode_address(addr).build()
    assert_eq(encoded.len(), 32)?
}

test "abi decode" {
    var data = [0u8; 32]
    data[31] = 42
    let decoder = AbiDecoder.new(data)
    assert_eq(decoder.decode_uint256(), UInt256.from(42))?
}

test "erc20 balance_of encoding" {
    let token = ERC20.new(Address.zero())
    let call = token.balance_of(Address.zero())
    // Should have selector + address
}

test "event topic" {
    let topic = event_topic("Transfer(address,address,uint256)")
    assert_eq(topic.len(), 32)?
}
