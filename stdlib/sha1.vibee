// =============================================================================
// Vibee OS â€” SHA-1 Module
// SHA-1 cryptographic hash function (FIPS 180-4)
// =============================================================================
//
// WARNING: SHA-1 is cryptographically broken and should NOT be used for
// security purposes. Collision attacks are practical. Use SHA-256 or BLAKE3
// for security-critical applications. SHA-1 is provided for legacy
// compatibility (e.g., Git, older TLS certificates).
// =============================================================================

const DIGEST_SIZE: Int = 20
const BLOCK_SIZE: Int = 64

// Initial hash values
const H0: UInt32 = 0x67452301
const H1: UInt32 = 0xefcdab89
const H2: UInt32 = 0x98badcfe
const H3: UInt32 = 0x10325476
const H4: UInt32 = 0xc3d2e1f0

// Round constants
const K0: UInt32 = 0x5a827999  // Rounds 0-19
const K1: UInt32 = 0x6ed9eba1  // Rounds 20-39
const K2: UInt32 = 0x8f1bbcdc  // Rounds 40-59
const K3: UInt32 = 0xca62c1d6  // Rounds 60-79

// =============================================================================
// Core Functions
// =============================================================================

/// Compute SHA-1 hash of byte array
fn hash(data: [UInt8]) -> [UInt8; 20] {
    @native("sha1", data)
}

/// Compute SHA-1 hash and return as hex string
fn hash_hex(data: [UInt8]) -> String {
    hex.encode(hash(data))
}

/// Compute SHA-1 hash of string
fn hash_string(s: String) -> [UInt8; 20] {
    hash(s.as_bytes())
}

/// Compute SHA-1 hash of string and return as hex string
fn hash_string_hex(s: String) -> String {
    hex.encode(hash_string(s))
}

/// Compute SHA-1 hash of file
fn hash_file(path: String) -> Result<[UInt8; 20], Sha1Error> {
    let data = fs.read_bytes(path).map_err(|e| Sha1Error.IoError(e.to_string()))?
    Ok(hash(data))
}

/// Compute SHA-1 hash of file and return as hex string
fn hash_file_hex(path: String) -> Result<String, Sha1Error> {
    Ok(hex.encode(hash_file(path)?))
}

// =============================================================================
// SHA-1 Digest Struct
// =============================================================================

/// Fixed-size SHA-1 digest (20 bytes / 160 bits)
struct Sha1Digest {
    bytes: [UInt8; 20]
}

impl Sha1Digest {
    /// Create digest from bytes
    fn from_bytes(bytes: [UInt8; 20]) -> Self {
        Sha1Digest { bytes: bytes }
    }
    
    /// Create digest from hex string
    fn from_hex(s: String) -> Result<Self, Sha1Error> {
        let bytes = hex.decode(s).map_err(|_| Sha1Error.InvalidHex)?
        if bytes.len() != 20 {
            return Err(Sha1Error.InvalidLength)
        }
        Ok(Sha1Digest { bytes: bytes.try_into().unwrap() })
    }
    
    /// Get bytes
    fn as_bytes() -> [UInt8; 20] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to uppercase hex string
    fn to_hex_upper() -> String {
        hex.encode_upper(self.bytes)
    }
    
    /// Compare digests in constant time
    fn eq(other: Sha1Digest) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
    
    /// Get first N bytes (for short identifiers like Git)
    fn short(len: Int) -> String {
        hex.encode(self.bytes[0..len.min(20)])
    }
    
    /// Get Git-style short hash (7 characters)
    fn git_short() -> String {
        self.to_hex()[0..7]
    }
}

impl Display for Sha1Digest {
    fn fmt(f: Formatter) {
        f.write(self.to_hex())
    }
}

impl Hash for Sha1Digest {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

// =============================================================================
// Incremental Hasher
// =============================================================================

/// Incremental SHA-1 hasher for streaming data
struct Sha1Hasher {
    inner: @native("Sha1Hasher")
}

impl Sha1Hasher {
    /// Create new SHA-1 hasher
    fn new() -> Self {
        Sha1Hasher { inner: @native("sha1_hasher_new") }
    }
    
    /// Update hasher with data
    fn update(data: [UInt8]) -> Self {
        @native("sha1_hasher_update", self.inner, data)
        self
    }
    
    /// Update hasher with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Finalize and get digest
    fn finalize() -> Sha1Digest {
        let bytes = @native("sha1_hasher_finalize", self.inner)
        Sha1Digest { bytes: bytes }
    }
    
    /// Finalize and get hex string
    fn finalize_hex() -> String {
        self.finalize().to_hex()
    }
    
    /// Reset hasher for reuse
    fn reset() {
        @native("sha1_hasher_reset", self.inner)
    }
    
    /// Clone hasher state
    fn clone() -> Self {
        Sha1Hasher { inner: @native("sha1_hasher_clone", self.inner) }
    }
}

// =============================================================================
// Streaming Actor
// =============================================================================

/// Actor for streaming SHA-1 computation
actor Sha1Stream {
    state hasher: Sha1Hasher
    state total_bytes: Int
    
    fn new() -> Self {
        Sha1Stream { hasher: Sha1Hasher.new(), total_bytes: 0 }
    }
    
    /// Write data to stream
    fn write(data: [UInt8]) {
        self.hasher.update(data)
        self.total_bytes += data.len()
    }
    
    /// Write string to stream
    fn write_str(s: String) {
        self.write(s.as_bytes())
    }
    
    /// Get current byte count
    fn bytes_processed() -> Int {
        self.total_bytes
    }
    
    /// Finalize and get digest
    fn finalize() -> Sha1Digest {
        self.hasher.finalize()
    }
    
    /// Reset stream
    fn reset() {
        self.hasher.reset()
        self.total_bytes = 0
    }
}

// =============================================================================
// HMAC-SHA1
// =============================================================================

/// Compute HMAC-SHA1
fn hmac(key: [UInt8], data: [UInt8]) -> [UInt8; 20] {
    @native("hmac_sha1", key, data)
}

/// Compute HMAC-SHA1 and return as hex string
fn hmac_hex(key: [UInt8], data: [UInt8]) -> String {
    hex.encode(hmac(key, data))
}

/// HMAC-SHA1 with string inputs
fn hmac_string(key: String, data: String) -> [UInt8; 20] {
    hmac(key.as_bytes(), data.as_bytes())
}

/// Incremental HMAC-SHA1
struct HmacSha1 {
    inner: @native("HmacSha1")
}

impl HmacSha1 {
    fn new(key: [UInt8]) -> Self {
        HmacSha1 { inner: @native("hmac_sha1_new", key) }
    }
    
    fn update(data: [UInt8]) -> Self {
        @native("hmac_sha1_update", self.inner, data)
        self
    }
    
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    fn finalize() -> [UInt8; 20] {
        @native("hmac_sha1_finalize", self.inner)
    }
    
    fn finalize_hex() -> String {
        hex.encode(self.finalize())
    }
    
    fn verify(expected: [UInt8]) -> Bool {
        crypto.constant_time_eq(self.finalize(), expected)
    }
}

// =============================================================================
// Git-Compatible Functions
// =============================================================================

/// Compute Git blob hash
fn git_blob_hash(content: [UInt8]) -> Sha1Digest {
    let header = format!("blob {}\0", content.len())
    var hasher = Sha1Hasher.new()
    hasher.update(header.as_bytes())
    hasher.update(content)
    hasher.finalize()
}

/// Compute Git tree hash
fn git_tree_hash(content: [UInt8]) -> Sha1Digest {
    let header = format!("tree {}\0", content.len())
    var hasher = Sha1Hasher.new()
    hasher.update(header.as_bytes())
    hasher.update(content)
    hasher.finalize()
}

/// Compute Git commit hash
fn git_commit_hash(content: [UInt8]) -> Sha1Digest {
    let header = format!("commit {}\0", content.len())
    var hasher = Sha1Hasher.new()
    hasher.update(header.as_bytes())
    hasher.update(content)
    hasher.finalize()
}

// =============================================================================
// Verification
// =============================================================================

/// Verify data against expected SHA-1 hash (hex string)
fn verify(data: [UInt8], expected_hex: String) -> Bool {
    let computed = hash_hex(data)
    crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes())
}

/// Verify string against expected SHA-1 hash
fn verify_string(s: String, expected_hex: String) -> Bool {
    verify(s.as_bytes(), expected_hex)
}

/// Verify file against expected SHA-1 hash
fn verify_file(path: String, expected_hex: String) -> Result<Bool, Sha1Error> {
    let computed = hash_file_hex(path)?
    Ok(crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes()))
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Check if string is valid SHA-1 hex hash
fn is_valid_hash(s: String) -> Bool {
    s.len() == 40 && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Parse SHA-1 hash from various formats
fn parse(s: String) -> Result<Sha1Digest, Sha1Error> {
    let s = s.trim().to_lowercase()
    
    // Remove common prefixes
    let s = if s.starts_with("sha1:") { s[5..] } else { s }
    let s = if s.starts_with("0x") { s[2..] } else { s }
    
    Sha1Digest.from_hex(s)
}

/// Format digest with prefix
fn format_with_prefix(digest: Sha1Digest) -> String {
    format!("sha1:{}", digest.to_hex())
}

// =============================================================================
// Errors
// =============================================================================

enum Sha1Error {
    InvalidHex
    InvalidLength
    IoError(String)
}

impl Display for Sha1Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidLength => f.write("Invalid SHA-1 hash length (expected 20 bytes)")
            IoError(s) => f.write(format!("I/O error: {}", s))
        }
    }
}

// =============================================================================
// Trait Implementations
// =============================================================================

trait Sha1Hashable {
    fn sha1() -> Sha1Digest
}

impl Sha1Hashable for [UInt8] {
    fn sha1() -> Sha1Digest {
        Sha1Digest { bytes: hash(self) }
    }
}

impl Sha1Hashable for String {
    fn sha1() -> Sha1Digest {
        Sha1Digest { bytes: hash_string(self) }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "empty string" {
    assert_eq(hash_string_hex(""), "da39a3ee5e6b4b0d3255bfef95601890afd80709")?
}

test "hello world" {
    assert_eq(hash_string_hex("hello"), "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")?
    assert_eq(hash_string_hex("Hello, World!"), "0a0a9f2a6772942557ab5355d76af442f8f65e01")?
}

test "incremental hashing" {
    var hasher = Sha1Hasher.new()
    hasher.update_str("hello")
    hasher.update_str(" ")
    hasher.update_str("world")
    assert_eq(hasher.finalize_hex(), hash_string_hex("hello world"))?
}

test "digest from hex" {
    let digest = Sha1Digest.from_hex("da39a3ee5e6b4b0d3255bfef95601890afd80709")?
    assert_eq(digest.to_hex(), "da39a3ee5e6b4b0d3255bfef95601890afd80709")?
}

test "git short hash" {
    let digest = Sha1Digest.from_hex("da39a3ee5e6b4b0d3255bfef95601890afd80709")?
    assert_eq(digest.git_short(), "da39a3e")?
}

test "verify" {
    assert(verify_string("hello", "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"))?
    assert(!verify_string("hello", "0000000000000000000000000000000000000000"))?
}

test "is_valid_hash" {
    assert(is_valid_hash("da39a3ee5e6b4b0d3255bfef95601890afd80709"))?
    assert(!is_valid_hash("invalid"))?
    assert(!is_valid_hash("da39a3ee5e6b4b0d3255bfef95601890afd8070"))?  // Too short
}

test "hmac" {
    let mac = hmac_string("key", "message")
    assert_eq(mac.len(), 20)?
}

test "git blob hash" {
    let content = "hello\n".as_bytes()
    let digest = git_blob_hash(content)
    // Git: echo -n "hello" | git hash-object --stdin
    assert_eq(digest.to_hex().len(), 40)?
}

test "streaming actor" {
    var stream = Sha1Stream.new()
    stream.write_str("hello")
    stream.write_str(" world")
    assert_eq(stream.bytes_processed(), 11)?
    assert_eq(stream.finalize().to_hex(), hash_string_hex("hello world"))?
}

test "trait implementation" {
    let digest = "hello".sha1()
    assert_eq(digest.to_hex(), "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")?
}
