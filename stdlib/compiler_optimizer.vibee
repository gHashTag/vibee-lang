// =============================================================================
// Vibee OS â€” Compiler Optimizer Module
// Code Optimization Passes for Vibee Compiler
// =============================================================================

use ir::*
use ast::*

// =============================================================================
// Optimization Configuration
// =============================================================================

/// Optimization level
enum OptimizationLevel {
    O0  // No optimization
    O1  // Basic optimizations
    O2  // Standard optimizations
    O3  // Aggressive optimizations
    Os  // Optimize for size
    Oz  // Optimize for minimal size
}

/// Optimizer configuration
struct OptimizerConfig {
    level: OptimizationLevel
    inline_threshold: Int
    unroll_threshold: Int
    enable_vectorization: Bool
    enable_loop_opts: Bool
    enable_dead_code_elim: Bool
    enable_constant_folding: Bool
    enable_cse: Bool
    enable_licm: Bool
    max_iterations: Int
}

impl OptimizerConfig {
    fn default() -> Self {
        OptimizerConfig {
            level: OptimizationLevel.O2,
            inline_threshold: 100,
            unroll_threshold: 4,
            enable_vectorization: true,
            enable_loop_opts: true,
            enable_dead_code_elim: true,
            enable_constant_folding: true,
            enable_cse: true,
            enable_licm: true,
            max_iterations: 10
        }
    }
    
    fn for_level(level: OptimizationLevel) -> Self {
        match level {
            OptimizationLevel.O0 => OptimizerConfig {
                level: level,
                inline_threshold: 0,
                unroll_threshold: 0,
                enable_vectorization: false,
                enable_loop_opts: false,
                enable_dead_code_elim: false,
                enable_constant_folding: false,
                enable_cse: false,
                enable_licm: false,
                max_iterations: 0
            }
            OptimizationLevel.O1 => OptimizerConfig {
                level: level,
                inline_threshold: 50,
                unroll_threshold: 2,
                enable_vectorization: false,
                enable_loop_opts: false,
                enable_dead_code_elim: true,
                enable_constant_folding: true,
                enable_cse: true,
                enable_licm: false,
                max_iterations: 3
            }
            OptimizationLevel.O3 => OptimizerConfig {
                level: level,
                inline_threshold: 500,
                unroll_threshold: 8,
                enable_vectorization: true,
                enable_loop_opts: true,
                enable_dead_code_elim: true,
                enable_constant_folding: true,
                enable_cse: true,
                enable_licm: true,
                max_iterations: 20
            }
            OptimizationLevel.Os | OptimizationLevel.Oz => OptimizerConfig {
                level: level,
                inline_threshold: 20,
                unroll_threshold: 0,
                enable_vectorization: false,
                enable_loop_opts: true,
                enable_dead_code_elim: true,
                enable_constant_folding: true,
                enable_cse: true,
                enable_licm: true,
                max_iterations: 5
            }
            _ => Self.default()
        }
    }
}

// =============================================================================
// Optimization Pass Trait
// =============================================================================

/// Base trait for optimization passes
trait OptimizationPass {
    fn name() -> String
    fn run(module: IrModule) -> IrModule
    fn is_enabled(config: OptimizerConfig) -> Bool
}

/// Pass manager
struct PassManager {
    passes: [Box<dyn OptimizationPass>]
    config: OptimizerConfig
    stats: OptimizationStats
}

struct OptimizationStats {
    instructions_removed: Int
    instructions_added: Int
    functions_inlined: Int
    loops_unrolled: Int
    constants_folded: Int
    dead_code_eliminated: Int
}

impl OptimizationStats {
    fn new() -> Self {
        OptimizationStats {
            instructions_removed: 0,
            instructions_added: 0,
            functions_inlined: 0,
            loops_unrolled: 0,
            constants_folded: 0,
            dead_code_eliminated: 0
        }
    }
}

impl PassManager {
    fn new(config: OptimizerConfig) -> Self {
        PassManager {
            passes: [],
            config: config,
            stats: OptimizationStats.new()
        }
    }
    
    fn add_pass(pass: Box<dyn OptimizationPass>) {
        self.passes.push(pass)
    }
    
    fn run(module: IrModule) -> IrModule {
        var current = module
        
        for _ in 0..self.config.max_iterations {
            var changed = false
            
            for pass in self.passes.iter() {
                if pass.is_enabled(self.config) {
                    let before_count = current.instruction_count()
                    current = pass.run(current)
                    let after_count = current.instruction_count()
                    
                    if before_count != after_count {
                        changed = true
                    }
                }
            }
            
            if !changed { break }
        }
        
        current
    }
    
    fn create_default_pipeline(config: OptimizerConfig) -> Self {
        var pm = Self.new(config)
        
        // Add passes in order
        pm.add_pass(Box.new(ConstantFoldingPass.new()))
        pm.add_pass(Box.new(DeadCodeEliminationPass.new()))
        pm.add_pass(Box.new(CommonSubexpressionEliminationPass.new()))
        pm.add_pass(Box.new(InliningPass.new()))
        pm.add_pass(Box.new(LoopInvariantCodeMotionPass.new()))
        pm.add_pass(Box.new(StrengthReductionPass.new()))
        pm.add_pass(Box.new(TailCallOptimizationPass.new()))
        
        pm
    }
}

// =============================================================================
// Constant Folding Pass
// =============================================================================

/// Constant folding optimization
struct ConstantFoldingPass {}

impl ConstantFoldingPass {
    fn new() -> Self { ConstantFoldingPass {} }
    
    fn fold_binary(op: BinaryOp, left: IrValue, right: IrValue) -> Option<IrValue> {
        match (left, right) {
            (IrValue.Int(a), IrValue.Int(b)) => {
                Some(IrValue.Int(match op {
                    BinaryOp.Add => a + b
                    BinaryOp.Sub => a - b
                    BinaryOp.Mul => a * b
                    BinaryOp.Div if b != 0 => a / b
                    BinaryOp.Rem if b != 0 => a % b
                    BinaryOp.BitAnd => a & b
                    BinaryOp.BitOr => a | b
                    BinaryOp.BitXor => a ^ b
                    BinaryOp.Shl => a << b
                    BinaryOp.Shr => a >> b
                    _ => return None
                }))
            }
            (IrValue.Float(a), IrValue.Float(b)) => {
                Some(IrValue.Float(match op {
                    BinaryOp.Add => a + b
                    BinaryOp.Sub => a - b
                    BinaryOp.Mul => a * b
                    BinaryOp.Div if b != 0.0 => a / b
                    _ => return None
                }))
            }
            (IrValue.Bool(a), IrValue.Bool(b)) => {
                Some(IrValue.Bool(match op {
                    BinaryOp.And => a && b
                    BinaryOp.Or => a || b
                    _ => return None
                }))
            }
            _ => None
        }
    }
    
    fn fold_comparison(op: BinaryOp, left: IrValue, right: IrValue) -> Option<IrValue> {
        match (left, right) {
            (IrValue.Int(a), IrValue.Int(b)) => {
                Some(IrValue.Bool(match op {
                    BinaryOp.Eq => a == b
                    BinaryOp.Ne => a != b
                    BinaryOp.Lt => a < b
                    BinaryOp.Le => a <= b
                    BinaryOp.Gt => a > b
                    BinaryOp.Ge => a >= b
                    _ => return None
                }))
            }
            _ => None
        }
    }
    
    fn fold_unary(op: UnaryOp, value: IrValue) -> Option<IrValue> {
        match (op, value) {
            (UnaryOp.Neg, IrValue.Int(n)) => Some(IrValue.Int(-n))
            (UnaryOp.Neg, IrValue.Float(n)) => Some(IrValue.Float(-n))
            (UnaryOp.Not, IrValue.Bool(b)) => Some(IrValue.Bool(!b))
            _ => None
        }
    }
}

impl OptimizationPass for ConstantFoldingPass {
    fn name() -> String { "constant-folding" }
    
    fn run(module: IrModule) -> IrModule {
        var new_module = module.clone()
        
        for func in new_module.functions.iter_mut() {
            for block in func.blocks.iter_mut() {
                var new_instructions = []
                
                for inst in block.instructions.iter() {
                    let folded = match inst.op {
                        IrOp.Add(a, b) => Self.fold_binary(BinaryOp.Add, a, b)
                        IrOp.Sub(a, b) => Self.fold_binary(BinaryOp.Sub, a, b)
                        IrOp.Mul(a, b) => Self.fold_binary(BinaryOp.Mul, a, b)
                        IrOp.Div(a, b) => Self.fold_binary(BinaryOp.Div, a, b)
                        IrOp.Neg(v) => Self.fold_unary(UnaryOp.Neg, v)
                        IrOp.Not(v) => Self.fold_unary(UnaryOp.Not, v)
                        _ => None
                    }
                    
                    if let Some(value) = folded {
                        new_instructions.push(IrInstruction {
                            id: inst.id,
                            op: IrOp.Const(value),
                            ty: inst.ty
                        })
                    } else {
                        new_instructions.push(inst.clone())
                    }
                }
                
                block.instructions = new_instructions
            }
        }
        
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.enable_constant_folding
    }
}

// =============================================================================
// Dead Code Elimination Pass
// =============================================================================

/// Dead code elimination
struct DeadCodeEliminationPass {
    used_values: Set<ValueId>
}

impl DeadCodeEliminationPass {
    fn new() -> Self {
        DeadCodeEliminationPass { used_values: Set.new() }
    }
    
    fn mark_used(module: IrModule) {
        self.used_values.clear()
        
        for func in module.functions.iter() {
            for block in func.blocks.iter() {
                for inst in block.instructions.iter() {
                    self.mark_operands(inst)
                }
            }
        }
    }
    
    fn mark_operands(inst: IrInstruction) {
        match inst.op {
            IrOp.Add(a, b) | IrOp.Sub(a, b) | IrOp.Mul(a, b) | IrOp.Div(a, b) => {
                if let IrValue.Ref(id) = a { self.used_values.insert(id) }
                if let IrValue.Ref(id) = b { self.used_values.insert(id) }
            }
            IrOp.Load(ptr) => {
                if let IrValue.Ref(id) = ptr { self.used_values.insert(id) }
            }
            IrOp.Store(val, ptr) => {
                if let IrValue.Ref(id) = val { self.used_values.insert(id) }
                if let IrValue.Ref(id) = ptr { self.used_values.insert(id) }
            }
            IrOp.Ret(Some(v)) => {
                if let IrValue.Ref(id) = v { self.used_values.insert(id) }
            }
            IrOp.Call(_, args) => {
                for arg in args {
                    if let IrValue.Ref(id) = arg { self.used_values.insert(id) }
                }
            }
            _ => {}
        }
    }
    
    fn is_dead(inst: IrInstruction) -> Bool {
        // Side-effect free instructions that are not used
        match inst.op {
            IrOp.Const(_) | IrOp.Add(_, _) | IrOp.Sub(_, _) | 
            IrOp.Mul(_, _) | IrOp.Div(_, _) => {
                !self.used_values.contains(inst.id)
            }
            _ => false
        }
    }
}

impl OptimizationPass for DeadCodeEliminationPass {
    fn name() -> String { "dead-code-elimination" }
    
    fn run(module: IrModule) -> IrModule {
        self.mark_used(module.clone())
        
        var new_module = module.clone()
        
        for func in new_module.functions.iter_mut() {
            for block in func.blocks.iter_mut() {
                block.instructions.retain(|inst| !self.is_dead(inst))
            }
        }
        
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.enable_dead_code_elim
    }
}

// =============================================================================
// Common Subexpression Elimination Pass
// =============================================================================

/// CSE optimization
struct CommonSubexpressionEliminationPass {
    expressions: Map<String, ValueId>
}

impl CommonSubexpressionEliminationPass {
    fn new() -> Self {
        CommonSubexpressionEliminationPass { expressions: Map.new() }
    }
    
    fn expr_key(inst: IrInstruction) -> Option<String> {
        match inst.op {
            IrOp.Add(a, b) => Some(format!("add:{:?}:{:?}", a, b))
            IrOp.Sub(a, b) => Some(format!("sub:{:?}:{:?}", a, b))
            IrOp.Mul(a, b) => Some(format!("mul:{:?}:{:?}", a, b))
            IrOp.Div(a, b) => Some(format!("div:{:?}:{:?}", a, b))
            _ => None
        }
    }
}

impl OptimizationPass for CommonSubexpressionEliminationPass {
    fn name() -> String { "cse" }
    
    fn run(module: IrModule) -> IrModule {
        var new_module = module.clone()
        
        for func in new_module.functions.iter_mut() {
            self.expressions.clear()
            
            for block in func.blocks.iter_mut() {
                var new_instructions = []
                
                for inst in block.instructions.iter() {
                    if let Some(key) = Self.expr_key(inst) {
                        if let Some(existing_id) = self.expressions.get(key) {
                            // Replace with reference to existing computation
                            new_instructions.push(IrInstruction {
                                id: inst.id,
                                op: IrOp.Copy(IrValue.Ref(existing_id)),
                                ty: inst.ty
                            })
                        } else {
                            self.expressions.insert(key, inst.id)
                            new_instructions.push(inst.clone())
                        }
                    } else {
                        new_instructions.push(inst.clone())
                    }
                }
                
                block.instructions = new_instructions
            }
        }
        
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.enable_cse
    }
}

// =============================================================================
// Function Inlining Pass
// =============================================================================

/// Function inlining
struct InliningPass {
    call_graph: Map<String, [String]>
    function_sizes: Map<String, Int>
}

impl InliningPass {
    fn new() -> Self {
        InliningPass {
            call_graph: Map.new(),
            function_sizes: Map.new()
        }
    }
    
    fn should_inline(func_name: String, threshold: Int) -> Bool {
        let size = self.function_sizes.get(func_name).unwrap_or(Int.MAX)
        size <= threshold
    }
    
    fn build_call_graph(module: IrModule) {
        self.call_graph.clear()
        self.function_sizes.clear()
        
        for func in module.functions.iter() {
            var callees = []
            var size = 0
            
            for block in func.blocks.iter() {
                size += block.instructions.len()
                
                for inst in block.instructions.iter() {
                    if let IrOp.Call(name, _) = inst.op {
                        callees.push(name.clone())
                    }
                }
            }
            
            self.call_graph.insert(func.name.clone(), callees)
            self.function_sizes.insert(func.name.clone(), size)
        }
    }
    
    fn inline_call(caller: IrFunction, call_site: IrInstruction, callee: IrFunction) -> [IrInstruction] {
        // Generate inlined instructions
        var inlined = []
        
        // Map parameters to arguments
        // Copy callee's instructions with renamed values
        // Handle return value
        
        inlined
    }
}

impl OptimizationPass for InliningPass {
    fn name() -> String { "inlining" }
    
    fn run(module: IrModule) -> IrModule {
        self.build_call_graph(module.clone())
        
        var new_module = module.clone()
        // Inline eligible functions
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.inline_threshold > 0
    }
}

// =============================================================================
// Loop Invariant Code Motion Pass
// =============================================================================

/// LICM optimization
struct LoopInvariantCodeMotionPass {}

impl LoopInvariantCodeMotionPass {
    fn new() -> Self { LoopInvariantCodeMotionPass {} }
    
    fn find_loops(func: IrFunction) -> [Loop] {
        // Find natural loops using dominance analysis
        []
    }
    
    fn is_loop_invariant(inst: IrInstruction, loop_: Loop) -> Bool {
        // Check if instruction's operands are defined outside the loop
        // or are themselves loop invariant
        false
    }
}

impl OptimizationPass for LoopInvariantCodeMotionPass {
    fn name() -> String { "licm" }
    
    fn run(module: IrModule) -> IrModule {
        var new_module = module.clone()
        
        for func in new_module.functions.iter_mut() {
            let loops = Self.find_loops(func.clone())
            
            for loop_ in loops {
                // Move invariant instructions to preheader
            }
        }
        
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.enable_licm
    }
}

struct Loop {
    header: BlockId
    blocks: Set<BlockId>
    preheader: Option<BlockId>
    exits: [BlockId]
}

// =============================================================================
// Strength Reduction Pass
// =============================================================================

/// Strength reduction (replace expensive ops with cheaper ones)
struct StrengthReductionPass {}

impl StrengthReductionPass {
    fn new() -> Self { StrengthReductionPass {} }
    
    fn reduce(inst: IrInstruction) -> Option<IrInstruction> {
        match inst.op {
            // x * 2 -> x << 1
            IrOp.Mul(a, IrValue.Int(2)) => {
                Some(IrInstruction {
                    id: inst.id,
                    op: IrOp.Shl(a, IrValue.Int(1)),
                    ty: inst.ty
                })
            }
            // x * 4 -> x << 2
            IrOp.Mul(a, IrValue.Int(4)) => {
                Some(IrInstruction {
                    id: inst.id,
                    op: IrOp.Shl(a, IrValue.Int(2)),
                    ty: inst.ty
                })
            }
            // x * 8 -> x << 3
            IrOp.Mul(a, IrValue.Int(8)) => {
                Some(IrInstruction {
                    id: inst.id,
                    op: IrOp.Shl(a, IrValue.Int(3)),
                    ty: inst.ty
                })
            }
            // x / 2 -> x >> 1 (for unsigned)
            IrOp.Div(a, IrValue.Int(2)) => {
                Some(IrInstruction {
                    id: inst.id,
                    op: IrOp.Shr(a, IrValue.Int(1)),
                    ty: inst.ty
                })
            }
            // x % 2 -> x & 1
            IrOp.Rem(a, IrValue.Int(2)) => {
                Some(IrInstruction {
                    id: inst.id,
                    op: IrOp.And(a, IrValue.Int(1)),
                    ty: inst.ty
                })
            }
            _ => None
        }
    }
}

impl OptimizationPass for StrengthReductionPass {
    fn name() -> String { "strength-reduction" }
    
    fn run(module: IrModule) -> IrModule {
        var new_module = module.clone()
        
        for func in new_module.functions.iter_mut() {
            for block in func.blocks.iter_mut() {
                block.instructions = block.instructions.iter().map(|inst| {
                    Self.reduce(inst).unwrap_or(inst.clone())
                }).collect()
            }
        }
        
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.level != OptimizationLevel.O0
    }
}

// =============================================================================
// Tail Call Optimization Pass
// =============================================================================

/// Tail call optimization
struct TailCallOptimizationPass {}

impl TailCallOptimizationPass {
    fn new() -> Self { TailCallOptimizationPass {} }
    
    fn is_tail_call(block: IrBlock, inst_idx: Int) -> Bool {
        // Check if call is immediately followed by return
        if inst_idx + 1 < block.instructions.len() {
            if let IrOp.Ret(_) = block.instructions[inst_idx + 1].op {
                return true
            }
        }
        false
    }
}

impl OptimizationPass for TailCallOptimizationPass {
    fn name() -> String { "tail-call-opt" }
    
    fn run(module: IrModule) -> IrModule {
        var new_module = module.clone()
        
        for func in new_module.functions.iter_mut() {
            for block in func.blocks.iter_mut() {
                for (i, inst) in block.instructions.iter_mut().enumerate() {
                    if let IrOp.Call(name, args) = inst.op.clone() {
                        if Self.is_tail_call(block.clone(), i) {
                            inst.op = IrOp.TailCall(name, args)
                        }
                    }
                }
            }
        }
        
        new_module
    }
    
    fn is_enabled(config: OptimizerConfig) -> Bool {
        config.level != OptimizationLevel.O0
    }
}

// =============================================================================
// Peephole Optimizer
// =============================================================================

/// Peephole optimization patterns
struct PeepholeOptimizer {
    patterns: [PeepholePattern]
}

struct PeepholePattern {
    name: String
    match_fn: fn([IrInstruction]) -> Bool
    replace_fn: fn([IrInstruction]) -> [IrInstruction]
    window_size: Int
}

impl PeepholeOptimizer {
    fn new() -> Self {
        var opt = PeepholeOptimizer { patterns: [] }
        opt.add_default_patterns()
        opt
    }
    
    fn add_default_patterns() {
        // x + 0 -> x
        // x * 1 -> x
        // x - x -> 0
        // x & 0 -> 0
        // x | 0 -> x
        // etc.
    }
    
    fn optimize(instructions: [IrInstruction]) -> [IrInstruction] {
        var result = instructions.clone()
        
        for pattern in self.patterns.iter() {
            var i = 0
            while i + pattern.window_size <= result.len() {
                let window = result[i..i + pattern.window_size].to_vec()
                if (pattern.match_fn)(window.clone()) {
                    let replacement = (pattern.replace_fn)(window)
                    result.splice(i..i + pattern.window_size, replacement.iter().cloned())
                } else {
                    i += 1
                }
            }
        }
        
        result
    }
}

// =============================================================================
// Tests
// =============================================================================

test "constant folding" {
    let pass = ConstantFoldingPass.new()
    
    let result = pass.fold_binary(BinaryOp.Add, IrValue.Int(10), IrValue.Int(20))
    assert_eq(result, Some(IrValue.Int(30)))?
    
    let result2 = pass.fold_binary(BinaryOp.Mul, IrValue.Int(5), IrValue.Int(6))
    assert_eq(result2, Some(IrValue.Int(30)))?
}

test "strength reduction" {
    let pass = StrengthReductionPass.new()
    
    let inst = IrInstruction {
        id: 0,
        op: IrOp.Mul(IrValue.Ref(1), IrValue.Int(8)),
        ty: IrType.I64
    }
    
    let reduced = pass.reduce(inst)?
    match reduced.op {
        IrOp.Shl(_, IrValue.Int(3)) => assert(true)?
        _ => assert(false)?
    }
}

test "optimizer config levels" {
    let o0 = OptimizerConfig.for_level(OptimizationLevel.O0)
    assert_eq(o0.inline_threshold, 0)?
    assert(!o0.enable_vectorization)?
    
    let o3 = OptimizerConfig.for_level(OptimizationLevel.O3)
    assert(o3.inline_threshold > 100)?
    assert(o3.enable_vectorization)?
}

test "pass manager" {
    let config = OptimizerConfig.default()
    let pm = PassManager.create_default_pipeline(config)
    
    assert(pm.passes.len() > 0)?
}
