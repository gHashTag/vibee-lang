// =============================================================================
// Vibee OS â€” OAuth Module
// OAuth 2.0 client
// =============================================================================

/// OAuth2 Client
struct OAuth2Client {
    client_id: String
    client_secret: Option<String>
    auth_url: String
    token_url: String
    redirect_uri: String
    scopes: [String]
}

impl OAuth2Client {
    fn new(client_id: String, auth_url: String, token_url: String) -> Self {
        OAuth2Client { client_id: client_id, client_secret: None, auth_url: auth_url, token_url: token_url, redirect_uri: "", scopes: [] }
    }
    
    fn secret(secret: String) -> Self { self.client_secret = Some(secret); self }
    fn redirect_uri(uri: String) -> Self { self.redirect_uri = uri; self }
    fn scope(scope: String) -> Self { self.scopes.push(scope); self }
    fn scopes(scopes: [String]) -> Self { self.scopes.extend(scopes); self }
    
    /// Generate authorization URL
    fn authorize_url() -> (String, String) { self.authorize_url_with(None) }
    
    fn authorize_url_with(pkce: Option<PkceChallenge>) -> (String, String) {
        let state = base64.encode_url_safe(crypto.random_bytes(32))
        var params = [
            ("client_id", self.client_id.clone()),
            ("response_type", "code"),
            ("redirect_uri", self.redirect_uri.clone()),
            ("state", state.clone()),
        ]
        if !self.scopes.is_empty() { params.push(("scope", self.scopes.join(" "))) }
        if let Some(p) = pkce { params.push(("code_challenge", p.challenge)); params.push(("code_challenge_method", "S256")) }
        
        let query = params.iter().map(|(k, v)| format!("{}={}", k, url.encode_uri_component(v))).join("&")
        (format!("{}?{}", self.auth_url, query), state)
    }
    
    /// Exchange authorization code for tokens
    fn exchange_code(code: String) -> Result<TokenResponse, OAuthError> { self.exchange_code_with(code, None) }
    
    fn exchange_code_with(code: String, pkce_verifier: Option<String>) -> Result<TokenResponse, OAuthError> {
        var params = Map.empty()
        params.set("grant_type", "authorization_code")
        params.set("code", code)
        params.set("redirect_uri", self.redirect_uri.clone())
        params.set("client_id", self.client_id.clone())
        if let Some(secret) = self.client_secret { params.set("client_secret", secret) }
        if let Some(verifier) = pkce_verifier { params.set("code_verifier", verifier) }
        
        self.token_request(params)
    }
    
    /// Refresh access token
    fn refresh_token(refresh_token: String) -> Result<TokenResponse, OAuthError> {
        var params = Map.empty()
        params.set("grant_type", "refresh_token")
        params.set("refresh_token", refresh_token)
        params.set("client_id", self.client_id.clone())
        if let Some(secret) = self.client_secret { params.set("client_secret", secret) }
        
        self.token_request(params)
    }
    
    /// Client credentials flow
    fn client_credentials() -> Result<TokenResponse, OAuthError> {
        var params = Map.empty()
        params.set("grant_type", "client_credentials")
        params.set("client_id", self.client_id.clone())
        if let Some(secret) = self.client_secret { params.set("client_secret", secret) }
        if !self.scopes.is_empty() { params.set("scope", self.scopes.join(" ")) }
        
        self.token_request(params)
    }
    
    fn token_request(params: Map<String, String>) -> Result<TokenResponse, OAuthError> {
        let response = http.Client.new()
            .send(http.Request.post(self.token_url.clone()).form(params))
            .map_err(|e| OAuthError.NetworkError(e.to_string()))?
        
        if !response.is_success() { return Err(OAuthError.TokenError(response.text())) }
        
        response.json::<TokenResponse>().map_err(|_| OAuthError.InvalidResponse)
    }
    
    // Common providers
    fn google(client_id: String, client_secret: String) -> Self {
        Self.new(client_id, "https://accounts.google.com/o/oauth2/v2/auth", "https://oauth2.googleapis.com/token").secret(client_secret)
    }
    
    fn github(client_id: String, client_secret: String) -> Self {
        Self.new(client_id, "https://github.com/login/oauth/authorize", "https://github.com/login/oauth/access_token").secret(client_secret)
    }
    
    fn microsoft(client_id: String, tenant: String) -> Self {
        Self.new(client_id, format!("https://login.microsoftonline.com/{}/oauth2/v2.0/authorize", tenant), format!("https://login.microsoftonline.com/{}/oauth2/v2.0/token", tenant))
    }
    
    fn facebook(client_id: String, client_secret: String) -> Self {
        Self.new(client_id, "https://www.facebook.com/v18.0/dialog/oauth", "https://graph.facebook.com/v18.0/oauth/access_token").secret(client_secret)
    }
}

/// Token response
struct TokenResponse {
    access_token: String
    token_type: String
    expires_in: Option<Int64>
    refresh_token: Option<String>
    scope: Option<String>
    id_token: Option<String>
}

impl TokenResponse {
    fn is_expired() -> Bool {
        // Would need issued_at tracking for accurate check
        false
    }
    
    fn bearer_header() -> String { format!("Bearer {}", self.access_token) }
}

/// PKCE (Proof Key for Code Exchange)
struct PkceChallenge { verifier: String, challenge: String }

impl PkceChallenge {
    fn generate() -> Self {
        let verifier = base64.encode_url_safe(crypto.random_bytes(32))
        let challenge = base64.encode_url_safe(crypto.sha256(verifier.as_bytes()))
        PkceChallenge { verifier: verifier, challenge: challenge }
    }
    
    fn verifier() -> String { self.verifier.clone() }
}

/// OAuth state manager
actor OAuthStateManager {
    state states: Map<String, StateData>
    state ttl_ms: Int64
    
    fn new() -> Self { OAuthStateManager { states: Map.empty(), ttl_ms: 600000 } }
    
    fn create() -> String {
        let state = base64.encode_url_safe(crypto.random_bytes(32))
        self.states.set(state.clone(), StateData { created: @native("timestamp_ms"), pkce: None })
        state
    }
    
    fn create_with_pkce() -> (String, PkceChallenge) {
        let state = base64.encode_url_safe(crypto.random_bytes(32))
        let pkce = PkceChallenge.generate()
        self.states.set(state.clone(), StateData { created: @native("timestamp_ms"), pkce: Some(pkce.verifier.clone()) })
        (state, pkce)
    }
    
    fn validate(state: String) -> Option<Option<String>> {
        let data = self.states.remove(state)?
        if @native("timestamp_ms") - data.created > self.ttl_ms { return None }
        Some(data.pkce)
    }
    
    fn cleanup() {
        let now = @native("timestamp_ms")
        let expired: [String] = self.states.iter().filter(|(_, d)| now - d.created > self.ttl_ms).map(|(k, _)| k.clone()).collect()
        for k in expired { self.states.remove(k) }
    }
}

struct StateData { created: Int64, pkce: Option<String> }

enum OAuthError { NetworkError(String), TokenError(String), InvalidResponse, InvalidState, Other(String) }
impl Display for OAuthError { fn fmt(f: Formatter) { match self { NetworkError(s) => f.write(format!("Network error: {}", s)), TokenError(s) => f.write(format!("Token error: {}", s)), InvalidResponse => f.write("Invalid response"), InvalidState => f.write("Invalid state"), Other(s) => f.write(s) } } }

// Tests
test "pkce" {
    let pkce = PkceChallenge.generate()
    assert(!pkce.verifier.is_empty())?
    assert(!pkce.challenge.is_empty())?
    assert(pkce.verifier != pkce.challenge)?
}

test "authorize url" {
    let client = OAuth2Client.new("client123", "https://auth.example.com/authorize", "https://auth.example.com/token").redirect_uri("https://app.example.com/callback").scope("openid").scope("profile")
    let (url, state) = client.authorize_url()
    assert(url.contains("client_id=client123"))?
    assert(url.contains("scope=openid%20profile"))?
    assert(!state.is_empty())?
}
