// =============================================================================
// Vibee OS â€” Trie Module
// Prefix tree implementation
// =============================================================================

/// Trie (prefix tree)
struct Trie<V> {
    root: TrieNode<V>
    len: Int
    
    fn new() -> Self { Trie { root: TrieNode.new(), len: 0 } }
    
    /// Insert key-value pair
    fn insert(key: String, value: V) {
        var node = self.root
        for c in key.chars() {
            node = node.children.entry(c).or_insert(TrieNode.new())
        }
        if node.value.is_none() { self.len += 1 }
        node.value = Some(value)
    }
    
    /// Get value by key
    fn get(key: String) -> Option<V> {
        self.find_node(key)?.value.clone()
    }
    
    /// Check if key exists
    fn contains(key: String) -> Bool {
        self.find_node(key).map(|n| n.value.is_some()).unwrap_or(false)
    }
    
    /// Remove key
    fn remove(key: String) -> Option<V> {
        let node = self.find_node_mut(key)?
        let value = node.value.take()
        if value.is_some() { self.len -= 1 }
        value
    }
    
    /// Find all keys with prefix
    fn keys_with_prefix(prefix: String) -> [String] {
        var results = []
        if let Some(node) = self.find_node(prefix) {
            self.collect_keys(node, prefix, results)
        }
        results
    }
    
    /// Find all values with prefix
    fn values_with_prefix(prefix: String) -> [V] {
        var results = []
        if let Some(node) = self.find_node(prefix) {
            self.collect_values(node, results)
        }
        results
    }
    
    /// Autocomplete suggestions
    fn autocomplete(prefix: String, limit: Int) -> [String] {
        self.keys_with_prefix(prefix).into_iter().take(limit).collect()
    }
    
    /// Longest prefix match
    fn longest_prefix(key: String) -> Option<String> {
        var node = self.root
        var longest = None
        var current = ""
        
        for c in key.chars() {
            match node.children.get(c) {
                Some(child) => {
                    current.push(c)
                    if child.value.is_some() { longest = Some(current.clone()) }
                    node = child
                }
                None => break
            }
        }
        longest
    }
    
    /// Check if any key starts with prefix
    fn has_prefix(prefix: String) -> Bool {
        self.find_node(prefix).is_some()
    }
    
    fn len() -> Int { self.len }
    fn is_empty() -> Bool { self.len == 0 }
    
    fn find_node(key: String) -> Option<TrieNode<V>> {
        var node = self.root
        for c in key.chars() {
            node = node.children.get(c)?
        }
        Some(node)
    }
    
    fn find_node_mut(key: String) -> Option<TrieNode<V>> {
        var node = self.root
        for c in key.chars() {
            node = node.children.get_mut(c)?
        }
        Some(node)
    }
    
    fn collect_keys(node: TrieNode<V>, prefix: String, results: [String]) {
        if node.value.is_some() { results.push(prefix.clone()) }
        for (c, child) in node.children.iter() {
            self.collect_keys(child, format!("{}{}", prefix, c), results)
        }
    }
    
    fn collect_values(node: TrieNode<V>, results: [V]) {
        if let Some(v) = node.value.clone() { results.push(v) }
        for (_, child) in node.children.iter() {
            self.collect_values(child, results)
        }
    }
}

struct TrieNode<V> {
    children: Map<Char, TrieNode<V>>
    value: Option<V>
    
    fn new() -> Self { TrieNode { children: Map.empty(), value: None } }
}

/// Set-based trie (no values)
struct TrieSet {
    trie: Trie<()>
    
    fn new() -> Self { TrieSet { trie: Trie.new() } }
    fn insert(key: String) { self.trie.insert(key, ()) }
    fn contains(key: String) -> Bool { self.trie.contains(key) }
    fn remove(key: String) -> Bool { self.trie.remove(key).is_some() }
    fn keys_with_prefix(prefix: String) -> [String] { self.trie.keys_with_prefix(prefix) }
    fn len() -> Int { self.trie.len() }
}

// Tests
test "insert and get" {
    var t = Trie::<Int>.new()
    t.insert("hello", 1)
    t.insert("world", 2)
    assert_eq(t.get("hello"), Some(1))?
    assert_eq(t.get("world"), Some(2))?
    assert_eq(t.get("hi"), None)?
}

test "prefix search" {
    var t = Trie::<Int>.new()
    t.insert("app", 1)
    t.insert("apple", 2)
    t.insert("application", 3)
    t.insert("banana", 4)
    let keys = t.keys_with_prefix("app")
    assert_eq(keys.len(), 3)?
}

test "longest prefix" {
    var t = Trie::<Int>.new()
    t.insert("a", 1)
    t.insert("ab", 2)
    t.insert("abc", 3)
    assert_eq(t.longest_prefix("abcd"), Some("abc"))?
}
