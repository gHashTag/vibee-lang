// =============================================================================
// Vibee OS â€” Parser Module
// Syntactic Analyzer for Vibee Language
// =============================================================================

use ast::*
use lexer::{Token, TokenKind, Lexer}

/// Parser error
struct ParseError { message: String, span: Span }

impl Display for ParseError {
    fn fmt(f: Formatter) { f.write(format!("Parse error at {}: {}", self.span, self.message)) }
}

/// Parser state
struct Parser {
    tokens: [Token]
    pos: Int
    errors: [ParseError]
}

impl Parser {
    fn new(tokens: [Token]) -> Self { Parser { tokens: tokens, pos: 0, errors: [] } }
    
    /// Parse program
    fn parse() -> Result<Program, [ParseError]> {
        var items = []
        while !self.is_eof() { items.push(self.parse_item()?) }
        if self.errors.is_empty() {
            Ok(Program { modules: [Module { name: Identifier { name: "main", span: Span.unknown() }, items: items, imports: [], span: Span.unknown() }], span: Span.unknown() })
        } else { Err(self.errors) }
    }
    
    fn parse_item() -> Result<Item, ParseError> {
        self.skip_newlines()
        match self.peek().kind {
            TokenKind.Fn => Ok(Item.Function(self.parse_function()?))
            TokenKind.Struct => Ok(Item.Struct(self.parse_struct()?))
            TokenKind.Enum => Ok(Item.Enum(self.parse_enum()?))
            TokenKind.Trait => Ok(Item.Trait(self.parse_trait()?))
            TokenKind.Impl => Ok(Item.Impl(self.parse_impl()?))
            TokenKind.Actor => Ok(Item.Actor(self.parse_actor()?))
            TokenKind.Test => Ok(Item.Test(self.parse_test()?))
            TokenKind.Pub => { self.advance(); self.parse_item() }
            _ => Err(self.error("Expected item"))
        }
    }
    
    fn parse_function() -> Result<FunctionDef, ParseError> {
        let start = self.expect(TokenKind.Fn)?
        let name = self.parse_ident()?
        let generics = self.parse_generics()?
        self.expect(TokenKind.LParen)?
        let params = self.parse_params()?
        self.expect(TokenKind.RParen)?
        let ret = if self.check(TokenKind.Arrow) { self.advance(); Some(self.parse_type()?) } else { None }
        let body = if self.check(TokenKind.LBrace) { Some(self.parse_block()?) } else { None }
        Ok(FunctionDef { name: name, generics: generics, params: params, return_type: ret, body: body, visibility: Visibility.Private, is_async: false, attributes: [], span: start.span })
    }
    
    fn parse_struct() -> Result<StructDef, ParseError> {
        let start = self.expect(TokenKind.Struct)?
        let name = self.parse_ident()?
        let generics = self.parse_generics()?
        self.expect(TokenKind.LBrace)?
        let fields = self.parse_fields()?
        self.expect(TokenKind.RBrace)?
        Ok(StructDef { name: name, generics: generics, fields: fields, visibility: Visibility.Private, attributes: [], span: start.span })
    }
    
    fn parse_enum() -> Result<EnumDef, ParseError> {
        let start = self.expect(TokenKind.Enum)?
        let name = self.parse_ident()?
        let generics = self.parse_generics()?
        self.expect(TokenKind.LBrace)?
        var variants = []
        while !self.check(TokenKind.RBrace) && !self.is_eof() {
            self.skip_newlines()
            let vname = self.parse_ident()?
            let fields = if self.check(TokenKind.LParen) { self.advance(); let t = self.parse_type_list()?; self.expect(TokenKind.RParen)?; VariantFields.Tuple(t) } else { VariantFields.Unit }
            variants.push(Variant { name: vname, fields: fields, span: vname.span })
            self.skip_newlines()
        }
        self.expect(TokenKind.RBrace)?
        Ok(EnumDef { name: name, generics: generics, variants: variants, visibility: Visibility.Private, attributes: [], span: start.span })
    }
    
    fn parse_trait() -> Result<TraitDef, ParseError> {
        let start = self.expect(TokenKind.Trait)?
        let name = self.parse_ident()?
        let generics = self.parse_generics()?
        var supers = []
        if self.check(TokenKind.Colon) { self.advance(); supers = self.parse_type_bounds()? }
        self.expect(TokenKind.LBrace)?
        var items = []
        while !self.check(TokenKind.RBrace) && !self.is_eof() {
            self.skip_newlines()
            if self.check(TokenKind.Fn) { items.push(TraitItem.Method(self.parse_function()?)) }
            else if self.check(TokenKind.Type) { self.advance(); let n = self.parse_ident()?; items.push(TraitItem.Type(AssocType { name: n, bounds: [], default: None, span: n.span })) }
            self.skip_newlines()
        }
        self.expect(TokenKind.RBrace)?
        Ok(TraitDef { name: name, generics: generics, super_traits: supers, items: items, visibility: Visibility.Private, span: start.span })
    }
    
    fn parse_impl() -> Result<ImplBlock, ParseError> {
        let start = self.expect(TokenKind.Impl)?
        let generics = self.parse_generics()?
        let first_type = self.parse_type()?
        var trait_ref = None
        var self_type = first_type
        if self.check(TokenKind.For) { self.advance(); trait_ref = Some(self.type_to_path(first_type)); self_type = self.parse_type()? }
        self.expect(TokenKind.LBrace)?
        var items = []
        while !self.check(TokenKind.RBrace) && !self.is_eof() {
            self.skip_newlines()
            if self.check(TokenKind.Fn) { items.push(ImplItem.Method(self.parse_function()?)) }
            self.skip_newlines()
        }
        self.expect(TokenKind.RBrace)?
        Ok(ImplBlock { generics: generics, trait_ref: trait_ref, self_type: self_type, items: items, span: start.span })
    }
    
    fn parse_actor() -> Result<ActorDef, ParseError> {
        let start = self.expect(TokenKind.Actor)?
        let name = self.parse_ident()?
        let generics = self.parse_generics()?
        self.expect(TokenKind.LBrace)?
        var state = []
        var methods = []
        while !self.check(TokenKind.RBrace) && !self.is_eof() {
            self.skip_newlines()
            if self.check_ident("state") { self.advance(); let sn = self.parse_ident()?; self.expect(TokenKind.Colon)?; let st = self.parse_type()?; state.push(StateField { name: sn, ty: st, default: None, span: sn.span }) }
            else if self.check(TokenKind.Fn) { methods.push(self.parse_function()?) }
            self.skip_newlines()
        }
        self.expect(TokenKind.RBrace)?
        Ok(ActorDef { name: name, generics: generics, state: state, methods: methods, visibility: Visibility.Private, attributes: [], span: start.span })
    }
    
    fn parse_test() -> Result<TestDef, ParseError> {
        let start = self.expect(TokenKind.Test)?
        let name = match self.peek().kind { TokenKind.StringLit(s) => { self.advance(); s }, _ => "test" }
        let body = self.parse_block()?
        Ok(TestDef { name: name, body: body, span: start.span })
    }
    
    fn parse_block() -> Result<Block, ParseError> {
        let start = self.expect(TokenKind.LBrace)?
        var stmts = []
        while !self.check(TokenKind.RBrace) && !self.is_eof() {
            self.skip_newlines()
            if self.check(TokenKind.RBrace) { break }
            stmts.push(self.parse_stmt()?)
        }
        self.expect(TokenKind.RBrace)?
        Ok(Block { stmts: stmts, expr: None, span: start.span })
    }
    
    fn parse_stmt() -> Result<Statement, ParseError> {
        match self.peek().kind {
            TokenKind.Let | TokenKind.Var => Ok(Statement.Let(self.parse_let()?))
            _ => Ok(Statement.Expr(ExprStmt { expr: self.parse_expr()?, has_semi: self.consume(TokenKind.Semicolon), span: Span.unknown() }))
        }
    }
    
    fn parse_let() -> Result<LetStmt, ParseError> {
        let is_mut = self.check(TokenKind.Var)
        self.advance()
        let pattern = self.parse_pattern()?
        let ty = if self.check(TokenKind.Colon) { self.advance(); Some(self.parse_type()?) } else { None }
        let init = if self.check(TokenKind.Assign) { self.advance(); Some(self.parse_expr()?) } else { None }
        Ok(LetStmt { pattern: pattern, ty: ty, init: init, is_mut: is_mut, span: Span.unknown() })
    }
    
    fn parse_expr() -> Result<Expr, ParseError> { self.parse_binary(0) }
    
    fn parse_binary(min_prec: Int) -> Result<Expr, ParseError> {
        var left = self.parse_unary()?
        while self.peek().kind.precedence() > min_prec {
            let op = self.parse_binary_op()?
            let right = self.parse_binary(op.precedence())?
            left = Expr.Binary(BinaryExpr { left: Box.new(left), op: op, right: Box.new(right), span: Span.unknown() })
        }
        Ok(left)
    }
    
    fn parse_unary() -> Result<Expr, ParseError> {
        match self.peek().kind {
            TokenKind.Minus => { self.advance(); Ok(Expr.Unary(UnaryExpr { op: UnaryOp.Neg, expr: Box.new(self.parse_unary()?), span: Span.unknown() })) }
            TokenKind.Bang => { self.advance(); Ok(Expr.Unary(UnaryExpr { op: UnaryOp.Not, expr: Box.new(self.parse_unary()?), span: Span.unknown() })) }
            TokenKind.Star => { self.advance(); Ok(Expr.Unary(UnaryExpr { op: UnaryOp.Deref, expr: Box.new(self.parse_unary()?), span: Span.unknown() })) }
            TokenKind.Ampersand => { self.advance(); let m = self.consume(TokenKind.Mut); Ok(Expr.Reference(RefExpr { is_mut: m, expr: Box.new(self.parse_unary()?), span: Span.unknown() })) }
            _ => self.parse_postfix()
        }
    }
    
    fn parse_postfix() -> Result<Expr, ParseError> {
        var expr = self.parse_primary()?
        loop {
            match self.peek().kind {
                TokenKind.Dot => { self.advance(); let f = self.parse_ident()?; expr = Expr.Field(FieldExpr { base: Box.new(expr), field: f, span: Span.unknown() }) }
                TokenKind.LParen => { self.advance(); let args = self.parse_expr_list()?; self.expect(TokenKind.RParen)?; expr = Expr.Call(CallExpr { callee: Box.new(expr), args: args, span: Span.unknown() }) }
                TokenKind.LBracket => { self.advance(); let idx = self.parse_expr()?; self.expect(TokenKind.RBracket)?; expr = Expr.Index(IndexExpr { base: Box.new(expr), index: Box.new(idx), span: Span.unknown() }) }
                TokenKind.Question => { self.advance(); expr = Expr.Try(Box.new(expr)) }
                _ => break
            }
        }
        Ok(expr)
    }
    
    fn parse_primary() -> Result<Expr, ParseError> {
        match self.peek().kind {
            TokenKind.IntLit(n) => { self.advance(); Ok(Expr.Literal(Literal { kind: LiteralKind.Int(n), span: Span.unknown() })) }
            TokenKind.FloatLit(n) => { self.advance(); Ok(Expr.Literal(Literal { kind: LiteralKind.Float(n), span: Span.unknown() })) }
            TokenKind.StringLit(s) => { self.advance(); Ok(Expr.Literal(Literal { kind: LiteralKind.String(s), span: Span.unknown() })) }
            TokenKind.CharLit(c) => { self.advance(); Ok(Expr.Literal(Literal { kind: LiteralKind.Char(c), span: Span.unknown() })) }
            TokenKind.BoolLit(b) => { self.advance(); Ok(Expr.Literal(Literal { kind: LiteralKind.Bool(b), span: Span.unknown() })) }
            TokenKind.Ident(_) => self.parse_path_or_struct()
            TokenKind.If => self.parse_if()
            TokenKind.Match => self.parse_match()
            TokenKind.Loop => { self.advance(); Ok(Expr.Loop(LoopExpr { label: None, body: self.parse_block()?, span: Span.unknown() })) }
            TokenKind.While => self.parse_while()
            TokenKind.For => self.parse_for()
            TokenKind.Return => { self.advance(); let v = if !self.check(TokenKind.Semicolon) && !self.check(TokenKind.RBrace) { Some(Box.new(self.parse_expr()?)) } else { None }; Ok(Expr.Return(v)) }
            TokenKind.Break => { self.advance(); Ok(Expr.Break(None)) }
            TokenKind.Continue => { self.advance(); Ok(Expr.Continue) }
            TokenKind.LParen => { self.advance(); let e = self.parse_expr()?; self.expect(TokenKind.RParen)?; Ok(e) }
            TokenKind.LBracket => self.parse_array()
            TokenKind.LBrace => Ok(Expr.Block(self.parse_block()?))
            TokenKind.Pipe => self.parse_closure()
            _ => Err(self.error("Expected expression"))
        }
    }
    
    fn parse_if() -> Result<Expr, ParseError> {
        self.expect(TokenKind.If)?
        let cond = self.parse_expr()?
        let then_b = self.parse_block()?
        let else_b = if self.check(TokenKind.Else) { self.advance(); Some(Box.new(if self.check(TokenKind.If) { self.parse_if()? } else { Expr.Block(self.parse_block()?) })) } else { None }
        Ok(Expr.If(IfExpr { cond: Box.new(cond), then_branch: then_b, else_branch: else_b, span: Span.unknown() }))
    }
    
    fn parse_match() -> Result<Expr, ParseError> {
        self.expect(TokenKind.Match)?
        let scrutinee = self.parse_expr()?
        self.expect(TokenKind.LBrace)?
        var arms = []
        while !self.check(TokenKind.RBrace) && !self.is_eof() {
            self.skip_newlines()
            let pat = self.parse_pattern()?
            self.expect(TokenKind.FatArrow)?
            let body = self.parse_expr()?
            arms.push(MatchArm { pattern: pat, guard: None, body: body, span: Span.unknown() })
            self.consume(TokenKind.Comma)
            self.skip_newlines()
        }
        self.expect(TokenKind.RBrace)?
        Ok(Expr.Match(MatchExpr { scrutinee: Box.new(scrutinee), arms: arms, span: Span.unknown() }))
    }
    
    fn parse_while() -> Result<Expr, ParseError> {
        self.expect(TokenKind.While)?
        let cond = self.parse_expr()?
        let body = self.parse_block()?
        Ok(Expr.While(WhileExpr { label: None, cond: Box.new(cond), body: body, span: Span.unknown() }))
    }
    
    fn parse_for() -> Result<Expr, ParseError> {
        self.expect(TokenKind.For)?
        let pat = self.parse_pattern()?
        self.expect(TokenKind.In)?
        let iter = self.parse_expr()?
        let body = self.parse_block()?
        Ok(Expr.For(ForExpr { label: None, pattern: pat, iter: Box.new(iter), body: body, span: Span.unknown() }))
    }
    
    fn parse_array() -> Result<Expr, ParseError> {
        self.expect(TokenKind.LBracket)?
        if self.check(TokenKind.RBracket) { self.advance(); return Ok(Expr.Array(ArrayExpr { kind: ArrayKind.List([]), span: Span.unknown() })) }
        let first = self.parse_expr()?
        if self.check(TokenKind.Semicolon) { self.advance(); let count = self.parse_expr()?; self.expect(TokenKind.RBracket)?; return Ok(Expr.Array(ArrayExpr { kind: ArrayKind.Repeat(Box.new(first), Box.new(count)), span: Span.unknown() })) }
        var elems = [first]
        while self.check(TokenKind.Comma) { self.advance(); if self.check(TokenKind.RBracket) { break }; elems.push(self.parse_expr()?) }
        self.expect(TokenKind.RBracket)?
        Ok(Expr.Array(ArrayExpr { kind: ArrayKind.List(elems), span: Span.unknown() }))
    }
    
    fn parse_closure() -> Result<Expr, ParseError> {
        self.expect(TokenKind.Pipe)?
        var params = []
        while !self.check(TokenKind.Pipe) { let p = self.parse_pattern()?; params.push(ClosureParam { pattern: p, ty: None, span: Span.unknown() }); self.consume(TokenKind.Comma) }
        self.expect(TokenKind.Pipe)?
        let body = self.parse_expr()?
        Ok(Expr.Closure(ClosureExpr { params: params, ret: None, body: Box.new(body), is_async: false, span: Span.unknown() }))
    }
    
    fn parse_path_or_struct() -> Result<Expr, ParseError> {
        let path = self.parse_type_path()?
        if self.check(TokenKind.LBrace) { self.advance(); var fields = []; while !self.check(TokenKind.RBrace) { self.skip_newlines(); let n = self.parse_ident()?; let v = if self.check(TokenKind.Colon) { self.advance(); Some(self.parse_expr()?) } else { None }; fields.push(FieldInit { name: n, value: v, span: Span.unknown() }); self.consume(TokenKind.Comma); self.skip_newlines() }; self.expect(TokenKind.RBrace)?; Ok(Expr.Struct(StructExpr { path: path, fields: fields, base: None, span: Span.unknown() })) }
        else { Ok(Expr.Path(path)) }
    }
    
    fn parse_pattern() -> Result<Pattern, ParseError> {
        match self.peek().kind {
            TokenKind.Ident(name) => { self.advance(); Ok(Pattern.Ident(IdentPattern { name: Identifier { name: name, span: Span.unknown() }, is_mut: false, sub: None, span: Span.unknown() })) }
            TokenKind.IntLit(n) => { self.advance(); Ok(Pattern.Literal(Literal { kind: LiteralKind.Int(n), span: Span.unknown() })) }
            TokenKind.LParen => { self.advance(); var pats = []; while !self.check(TokenKind.RParen) { pats.push(self.parse_pattern()?); self.consume(TokenKind.Comma) }; self.expect(TokenKind.RParen)?; Ok(Pattern.Tuple(pats)) }
            _ => { self.advance(); Ok(Pattern.Wildcard(Span.unknown())) }
        }
    }
    
    fn parse_type() -> Result<Type, ParseError> { Ok(Type.Path(self.parse_type_path()?)) }
    fn parse_type_path() -> Result<TypePath, ParseError> {
        var segs = []
        loop { let name = self.parse_ident()?; let gen = self.parse_generic_args()?; segs.push(PathSegment { name: name, generics: gen, span: name.span }); if !self.check(TokenKind.DoubleColon) { break }; self.advance() }
        Ok(TypePath { segments: segs, span: Span.unknown() })
    }
    fn parse_generics() -> Result<Option<Generics>, ParseError> { if !self.check(TokenKind.Lt) { return Ok(None) }; self.advance(); var params = []; while !self.check(TokenKind.Gt) { let n = self.parse_ident()?; params.push(GenericParam.Type(TypeParam { name: n, bounds: [], default: None, span: n.span })); self.consume(TokenKind.Comma) }; self.expect(TokenKind.Gt)?; Ok(Some(Generics { params: params, span: Span.unknown() })) }
    fn parse_generic_args() -> Result<Option<GenericArgs>, ParseError> { if !self.check(TokenKind.Lt) { return Ok(None) }; self.advance(); var args = []; while !self.check(TokenKind.Gt) { args.push(GenericArg.Type(self.parse_type()?)); self.consume(TokenKind.Comma) }; self.expect(TokenKind.Gt)?; Ok(Some(GenericArgs { args: args, span: Span.unknown() })) }
    fn parse_params() -> Result<[Parameter], ParseError> { var params = []; while !self.check(TokenKind.RParen) { let n = self.parse_ident()?; self.expect(TokenKind.Colon)?; let t = self.parse_type()?; params.push(Parameter { name: n, ty: t, default: None, is_self: false, span: n.span }); self.consume(TokenKind.Comma) }; Ok(params) }
    fn parse_fields() -> Result<[Field], ParseError> { var fields = []; while !self.check(TokenKind.RBrace) { self.skip_newlines(); let n = self.parse_ident()?; self.expect(TokenKind.Colon)?; let t = self.parse_type()?; fields.push(Field { name: n, ty: t, default: None, visibility: Visibility.Private, span: n.span }); self.skip_newlines() }; Ok(fields) }
    fn parse_type_list() -> Result<[Type], ParseError> { var types = []; while !self.check(TokenKind.RParen) { types.push(self.parse_type()?); self.consume(TokenKind.Comma) }; Ok(types) }
    fn parse_type_bounds() -> Result<[TypePath], ParseError> { var bounds = []; bounds.push(self.parse_type_path()?); while self.check(TokenKind.Plus) { self.advance(); bounds.push(self.parse_type_path()?) }; Ok(bounds) }
    fn parse_expr_list() -> Result<[Expr], ParseError> { var exprs = []; while !self.check(TokenKind.RParen) { exprs.push(self.parse_expr()?); self.consume(TokenKind.Comma) }; Ok(exprs) }
    fn parse_binary_op() -> Result<BinaryOp, ParseError> { let t = self.advance(); match t.kind { TokenKind.Plus => Ok(BinaryOp.Add), TokenKind.Minus => Ok(BinaryOp.Sub), TokenKind.Star => Ok(BinaryOp.Mul), TokenKind.Slash => Ok(BinaryOp.Div), TokenKind.Percent => Ok(BinaryOp.Rem), TokenKind.Eq => Ok(BinaryOp.Eq), TokenKind.Ne => Ok(BinaryOp.Ne), TokenKind.Lt => Ok(BinaryOp.Lt), TokenKind.Le => Ok(BinaryOp.Le), TokenKind.Gt => Ok(BinaryOp.Gt), TokenKind.Ge => Ok(BinaryOp.Ge), TokenKind.And => Ok(BinaryOp.And), TokenKind.Or => Ok(BinaryOp.Or), _ => Err(self.error("Expected operator")) } }
    fn parse_ident() -> Result<Identifier, ParseError> { match self.peek().kind { TokenKind.Ident(name) => { self.advance(); Ok(Identifier { name: name, span: Span.unknown() }) }, _ => Err(self.error("Expected identifier")) } }
    fn type_to_path(ty: Type) -> TypePath { match ty { Type.Path(p) => p, _ => TypePath { segments: [], span: Span.unknown() } } }
    
    fn peek() -> Token { self.tokens.get(self.pos).unwrap_or(Token { kind: TokenKind.Eof, span: Span.unknown() }) }
    fn advance() -> Token { let t = self.peek(); self.pos += 1; t }
    fn is_eof() -> Bool { self.pos >= self.tokens.len() || self.peek().kind == TokenKind.Eof }
    fn check(kind: TokenKind) -> Bool { self.peek().kind == kind }
    fn check_ident(name: String) -> Bool { match self.peek().kind { TokenKind.Ident(n) => n == name, _ => false } }
    fn consume(kind: TokenKind) -> Bool { if self.check(kind) { self.advance(); true } else { false } }
    fn expect(kind: TokenKind) -> Result<Token, ParseError> { if self.check(kind) { Ok(self.advance()) } else { Err(self.error(format!("Expected {:?}", kind))) } }
    fn skip_newlines() { while self.check(TokenKind.Newline) { self.advance() } }
    fn error(msg: String) -> ParseError { ParseError { message: msg, span: self.peek().span } }
}

/// Parse source code
fn parse(source: String, file: String) -> Result<Program, [ParseError]> {
    let tokens = lexer::tokenize(source, file).map_err(|e| e.iter().map(|x| ParseError { message: x.message, span: x.span }).collect())?
    Parser.new(tokens).parse()
}

test "parse function" { let p = parse("fn foo() {}", "test")?; assert_eq(p.modules[0].items.len(), 1)? }
test "parse struct" { let p = parse("struct Foo { x: Int }", "test")?; assert_eq(p.modules[0].items.len(), 1)? }
