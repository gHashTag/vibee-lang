// =============================================================================
// Vibee OS â€” Category Module
// Categories, hierarchical organization, and content classification
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Category Types
// =============================================================================

/// Category type
enum CategoryType {
    Content,
    Product,
    Forum,
    Blog,
    News,
    Documentation,
    Custom(String)
}

impl CategoryType {
    fn display_name() -> String {
        match self {
            CategoryType.Content => "Content",
            CategoryType.Product => "Product",
            CategoryType.Forum => "Forum",
            CategoryType.Blog => "Blog",
            CategoryType.News => "News",
            CategoryType.Documentation => "Documentation",
            CategoryType.Custom(name) => name
        }
    }
}

/// Category status
enum CategoryStatus {
    Active,
    Hidden,
    Archived,
    Deleted
}

impl CategoryStatus {
    fn is_visible() -> Bool {
        match self {
            CategoryStatus.Active => true,
            _ => false
        }
    }
    
    fn display_name() -> String {
        match self {
            CategoryStatus.Active => "Active",
            CategoryStatus.Hidden => "Hidden",
            CategoryStatus.Archived => "Archived",
            CategoryStatus.Deleted => "Deleted"
        }
    }
}

// =============================================================================
// Category Structure
// =============================================================================

/// Category
struct Category {
    id: String,
    name: String,
    slug: String,
    description: Option<String>,
    category_type: CategoryType,
    status: CategoryStatus,
    parent_id: Option<String>,
    depth: Int,
    position: Int,
    icon: Option<String>,
    color: Option<String>,
    image_url: Option<String>,
    item_count: Int64,
    children_count: Int,
    path: [String],
    seo_title: Option<String>,
    seo_description: Option<String>,
    created_at: DateTime,
    updated_at: DateTime,
    metadata: Map<String, String>
}

impl Category {
    fn new(name: String, category_type: CategoryType) -> Self {
        let now = DateTime.now()
        Category {
            id: generate_id(),
            name: name.clone(),
            slug: slugify(name),
            description: None,
            category_type: category_type,
            status: CategoryStatus.Active,
            parent_id: None,
            depth: 0,
            position: 0,
            icon: None,
            color: None,
            image_url: None,
            item_count: 0,
            children_count: 0,
            path: [],
            seo_title: None,
            seo_description: None,
            created_at: now,
            updated_at: now,
            metadata: Map.empty()
        }
    }
    
    fn with_description(description: String) -> Self {
        self.description = Some(description)
        self
    }
    
    fn with_icon(icon: String) -> Self {
        self.icon = Some(icon)
        self
    }
    
    fn with_color(color: String) -> Self {
        self.color = Some(color)
        self
    }
    
    fn with_image(url: String) -> Self {
        self.image_url = Some(url)
        self
    }
    
    fn with_seo(title: String, description: String) -> Self {
        self.seo_title = Some(title)
        self.seo_description = Some(description)
        self
    }
    
    fn with_position(position: Int) -> Self {
        self.position = position
        self
    }
    
    fn set_parent(parent_id: String, parent_path: [String], parent_depth: Int) {
        self.parent_id = Some(parent_id.clone())
        self.depth = parent_depth + 1
        self.path = parent_path.clone()
        self.path.push(parent_id)
        self.updated_at = DateTime.now()
    }
    
    fn increment_items() {
        self.item_count += 1
        self.updated_at = DateTime.now()
    }
    
    fn decrement_items() {
        if self.item_count > 0 { self.item_count -= 1 }
        self.updated_at = DateTime.now()
    }
    
    fn increment_children() {
        self.children_count += 1
        self.updated_at = DateTime.now()
    }
    
    fn decrement_children() {
        if self.children_count > 0 { self.children_count -= 1 }
        self.updated_at = DateTime.now()
    }
    
    fn hide() {
        self.status = CategoryStatus.Hidden
        self.updated_at = DateTime.now()
    }
    
    fn archive() {
        self.status = CategoryStatus.Archived
        self.updated_at = DateTime.now()
    }
    
    fn delete() {
        self.status = CategoryStatus.Deleted
        self.updated_at = DateTime.now()
    }
    
    fn activate() {
        self.status = CategoryStatus.Active
        self.updated_at = DateTime.now()
    }
    
    fn is_visible() -> Bool { self.status.is_visible() }
    fn is_root() -> Bool { self.parent_id.is_none() }
    fn has_children() -> Bool { self.children_count > 0 }
    fn has_items() -> Bool { self.item_count > 0 }
    
    fn url() -> String {
        if self.path.is_empty() {
            format!("/category/{}", self.slug)
        } else {
            let path_str = self.path.join("/")
            format!("/category/{}/{}", path_str, self.slug)
        }
    }
    
    fn breadcrumb_path() -> [String] {
        var result = self.path.clone()
        result.push(self.id.clone())
        result
    }
    
    fn full_name(separator: String) -> String {
        // This would need parent names from service
        self.name.clone()
    }
}

// =============================================================================
// Category Tree
// =============================================================================

/// Category tree node
struct CategoryNode {
    category: Category,
    children: [CategoryNode]
}

impl CategoryNode {
    fn new(category: Category) -> Self {
        CategoryNode {
            category: category,
            children: []
        }
    }
    
    fn add_child(child: CategoryNode) {
        self.children.push(child)
        self.category.increment_children()
    }
    
    fn flatten() -> [Category] {
        var result: [Category] = [self.category.clone()]
        for child in self.children.iter() {
            result.extend(child.flatten())
        }
        result
    }
    
    fn depth() -> Int {
        if self.children.is_empty() {
            0
        } else {
            1 + self.children.iter().map(|c| c.depth()).max().unwrap_or(0)
        }
    }
    
    fn total_items() -> Int64 {
        var total = self.category.item_count
        for child in self.children.iter() {
            total += child.total_items()
        }
        total
    }
    
    fn sort_children_by_position() {
        self.children.sort_by(|a, b| a.category.position.cmp(b.category.position))
        for child in self.children.iter_mut() {
            child.sort_children_by_position()
        }
    }
    
    fn sort_children_by_name() {
        self.children.sort_by(|a, b| a.category.name.cmp(b.category.name))
        for child in self.children.iter_mut() {
            child.sort_children_by_name()
        }
    }
    
    fn find(category_id: String) -> Option<CategoryNode> {
        if self.category.id == category_id {
            return Some(self.clone())
        }
        for child in self.children.iter() {
            if let Some(found) = child.find(category_id.clone()) {
                return Some(found)
            }
        }
        None
    }
}

// =============================================================================
// Category Service
// =============================================================================

/// Category service actor
actor CategoryService {
    state categories: Map<String, Category>
    state slug_index: Map<String, String>
    state parent_children: Map<String, [String]>
    state root_categories: [String]
    state content_categories: Map<String, Set<String>>
    state category_content: Map<String, Set<String>>
    
    fn new() -> Self {
        CategoryService {
            categories: Map.empty(),
            slug_index: Map.empty(),
            parent_children: Map.empty(),
            root_categories: [],
            content_categories: Map.empty(),
            category_content: Map.empty()
        }
    }
    
    /// Create category
    on create(category: Category) -> Result<Category, CategoryError> {
        if self.slug_index.contains_key(category.slug.clone()) {
            return Err(CategoryError.SlugExists)
        }
        
        let category_id = category.id.clone()
        
        self.categories.set(category_id.clone(), category.clone())
        self.slug_index.set(category.slug.clone(), category_id.clone())
        
        if let Some(parent_id) = category.parent_id.clone() {
            self.parent_children.entry(parent_id.clone()).or_insert([]).push(category_id.clone())
            
            // Increment parent's children count
            if let Some(parent) = self.categories.get_mut(parent_id) {
                parent.increment_children()
            }
        } else {
            self.root_categories.push(category_id)
        }
        
        Ok(category)
    }
    
    /// Create child category
    on create_child(parent_id: String, name: String, category_type: CategoryType) -> Result<Category, CategoryError> {
        let parent = self.categories.get(parent_id.clone())
            .ok_or(CategoryError.ParentNotFound)?
        
        var category = Category.new(name, category_type)
        category.set_parent(parent_id, parent.path.clone(), parent.depth)
        
        self.create(category)
    }
    
    /// Get category by ID
    on get(category_id: String) -> Option<Category> {
        self.categories.get(category_id)
    }
    
    /// Get category by slug
    on get_by_slug(slug: String) -> Option<Category> {
        self.slug_index.get(slug)
            .and_then(|id| self.categories.get(id))
    }
    
    /// Update category
    on update(category_id: String, name: Option<String>, description: Option<String>) -> Result<Category, CategoryError> {
        let category = self.categories.get_mut(category_id.clone())
            .ok_or(CategoryError.NotFound)?
        
        if let Some(n) = name {
            let new_slug = slugify(n.clone())
            
            // Check if new slug conflicts
            if new_slug != category.slug && self.slug_index.contains_key(new_slug.clone()) {
                return Err(CategoryError.SlugExists)
            }
            
            // Update slug index
            self.slug_index.remove(category.slug.clone())
            self.slug_index.set(new_slug.clone(), category_id)
            
            category.name = n
            category.slug = new_slug
        }
        
        if let Some(d) = description {
            category.description = Some(d)
        }
        
        category.updated_at = DateTime.now()
        Ok(category.clone())
    }
    
    /// Move category to new parent
    on move_to(category_id: String, new_parent_id: Option<String>) -> Result<Category, CategoryError> {
        let category = self.categories.get_mut(category_id.clone())
            .ok_or(CategoryError.NotFound)?
        
        // Remove from old parent
        if let Some(old_parent_id) = category.parent_id.clone() {
            if let Some(children) = self.parent_children.get_mut(old_parent_id.clone()) {
                children.retain(|id| *id != category_id)
            }
            if let Some(old_parent) = self.categories.get_mut(old_parent_id) {
                old_parent.decrement_children()
            }
        } else {
            self.root_categories.retain(|id| *id != category_id)
        }
        
        // Add to new parent
        if let Some(parent_id) = new_parent_id.clone() {
            let parent = self.categories.get(parent_id.clone())
                .ok_or(CategoryError.ParentNotFound)?
            
            // Check for circular reference
            if parent.path.contains(category_id.clone()) || parent_id == category_id {
                return Err(CategoryError.CircularReference)
            }
            
            category.set_parent(parent_id.clone(), parent.path.clone(), parent.depth)
            self.parent_children.entry(parent_id.clone()).or_insert([]).push(category_id.clone())
            
            if let Some(new_parent) = self.categories.get_mut(parent_id) {
                new_parent.increment_children()
            }
        } else {
            category.parent_id = None
            category.depth = 0
            category.path = []
            self.root_categories.push(category_id)
        }
        
        category.updated_at = DateTime.now()
        Ok(category.clone())
    }
    
    /// Delete category
    on delete(category_id: String, move_children_to: Option<String>) -> Result<(), CategoryError> {
        let category = self.categories.get_mut(category_id.clone())
            .ok_or(CategoryError.NotFound)?
        
        // Handle children
        let children = self.parent_children.get(category_id.clone()).unwrap_or([]).clone()
        
        if !children.is_empty() {
            if let Some(new_parent) = move_children_to {
                for child_id in children.iter() {
                    self.move_to(child_id.clone(), Some(new_parent.clone()))?
                }
            } else {
                return Err(CategoryError.HasChildren)
            }
        }
        
        // Remove from parent
        if let Some(parent_id) = category.parent_id.clone() {
            if let Some(siblings) = self.parent_children.get_mut(parent_id.clone()) {
                siblings.retain(|id| *id != category_id)
            }
            if let Some(parent) = self.categories.get_mut(parent_id) {
                parent.decrement_children()
            }
        } else {
            self.root_categories.retain(|id| *id != category_id)
        }
        
        // Mark as deleted
        category.delete()
        
        // Remove from slug index
        self.slug_index.remove(category.slug.clone())
        
        Ok(())
    }
    
    /// Get root categories
    on get_roots() -> [Category] {
        var categories: [Category] = self.root_categories.iter()
            .filter_map(|id| self.categories.get(id))
            .filter(|c| c.is_visible())
            .collect()
        
        categories.sort_by(|a, b| a.position.cmp(b.position))
        categories
    }
    
    /// Get children of category
    on get_children(parent_id: String) -> [Category] {
        var children: [Category] = self.parent_children.get(parent_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.categories.get(id))
                    .filter(|c| c.is_visible())
                    .collect()
            })
            .unwrap_or([])
        
        children.sort_by(|a, b| a.position.cmp(b.position))
        children
    }
    
    /// Get ancestors of category
    on get_ancestors(category_id: String) -> [Category] {
        let category = self.categories.get(category_id)?
        
        category.path.iter()
            .filter_map(|id| self.categories.get(id))
            .collect()
    }
    
    /// Get descendants of category
    on get_descendants(category_id: String) -> [Category] {
        var result: [Category] = []
        var queue: [String] = [category_id]
        
        while !queue.is_empty() {
            let current_id = queue.remove(0)
            
            if let Some(children_ids) = self.parent_children.get(current_id) {
                for child_id in children_ids.iter() {
                    if let Some(child) = self.categories.get(child_id.clone()) {
                        if child.is_visible() {
                            result.push(child.clone())
                            queue.push(child_id.clone())
                        }
                    }
                }
            }
        }
        
        result
    }
    
    /// Build category tree
    on get_tree() -> [CategoryNode] {
        var roots: [CategoryNode] = []
        
        for root_id in self.root_categories.iter() {
            if let Some(root) = self.categories.get(root_id.clone()) {
                if root.is_visible() {
                    let node = self.build_node(root_id.clone())
                    roots.push(node)
                }
            }
        }
        
        roots.sort_by(|a, b| a.category.position.cmp(b.category.position))
        roots
    }
    
    fn build_node(category_id: String) -> CategoryNode {
        let category = self.categories.get(category_id.clone()).unwrap()
        var node = CategoryNode.new(category.clone())
        
        if let Some(children_ids) = self.parent_children.get(category_id) {
            for child_id in children_ids.iter() {
                if let Some(child) = self.categories.get(child_id.clone()) {
                    if child.is_visible() {
                        let child_node = self.build_node(child_id.clone())
                        node.children.push(child_node)
                    }
                }
            }
        }
        
        node.children.sort_by(|a, b| a.category.position.cmp(b.category.position))
        node
    }
    
    /// Assign content to category
    on assign_content(content_id: String, category_id: String) -> Result<(), CategoryError> {
        let category = self.categories.get_mut(category_id.clone())
            .ok_or(CategoryError.NotFound)?
        
        let added = self.content_categories.entry(content_id.clone())
            .or_insert(Set.empty())
            .insert(category_id.clone())
        
        if added {
            self.category_content.entry(category_id).or_insert(Set.empty()).insert(content_id)
            category.increment_items()
        }
        
        Ok(())
    }
    
    /// Remove content from category
    on unassign_content(content_id: String, category_id: String) -> Result<(), CategoryError> {
        let category = self.categories.get_mut(category_id.clone())
            .ok_or(CategoryError.NotFound)?
        
        if let Some(categories) = self.content_categories.get_mut(content_id.clone()) {
            if categories.remove(category_id.clone()) {
                if let Some(content) = self.category_content.get_mut(category_id) {
                    content.remove(content_id)
                }
                category.decrement_items()
            }
        }
        
        Ok(())
    }
    
    /// Get categories for content
    on get_content_categories(content_id: String) -> [Category] {
        self.content_categories.get(content_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.categories.get(id))
                    .collect()
            })
            .unwrap_or([])
    }
    
    /// Get content in category
    on get_category_content(category_id: String, include_children: Bool, limit: Int, offset: Int) -> [String] {
        var content_ids: Set<String> = self.category_content.get(category_id.clone())
            .map(|s| s.clone())
            .unwrap_or(Set.empty())
        
        if include_children {
            let descendants = self.get_descendants(category_id)
            for desc in descendants.iter() {
                if let Some(desc_content) = self.category_content.get(desc.id.clone()) {
                    content_ids.extend(desc_content.iter())
                }
            }
        }
        
        content_ids.iter().skip(offset).take(limit).collect()
    }
    
    /// Search categories
    on search(query: String, limit: Int) -> [Category] {
        let query_lower = query.to_lowercase()
        self.categories.values()
            .filter(|c| c.is_visible() && c.name.to_lowercase().contains(query_lower.clone()))
            .take(limit)
            .collect()
    }
    
    /// Reorder categories
    on reorder(category_ids: [String]) {
        for (i, category_id) in category_ids.iter().enumerate() {
            if let Some(category) = self.categories.get_mut(category_id.clone()) {
                category.position = i as Int
                category.updated_at = DateTime.now()
            }
        }
    }
    
    /// Get breadcrumbs for category
    on get_breadcrumbs(category_id: String) -> [Category] {
        var breadcrumbs = self.get_ancestors(category_id.clone())
        if let Some(category) = self.categories.get(category_id) {
            breadcrumbs.push(category.clone())
        }
        breadcrumbs
    }
}

// =============================================================================
// Category Errors
// =============================================================================

/// Category errors
enum CategoryError {
    NotFound,
    ParentNotFound,
    SlugExists,
    HasChildren,
    CircularReference,
    MaxDepthReached,
    Unauthorized
}

impl CategoryError {
    fn message() -> String {
        match self {
            CategoryError.NotFound => "Category not found",
            CategoryError.ParentNotFound => "Parent category not found",
            CategoryError.SlugExists => "Category with this slug already exists",
            CategoryError.HasChildren => "Cannot delete category with children",
            CategoryError.CircularReference => "Cannot create circular reference",
            CategoryError.MaxDepthReached => "Maximum category depth reached",
            CategoryError.Unauthorized => "Not authorized to perform this action"
        }
    }
}

// =============================================================================
// Category Events
// =============================================================================

/// Category events for event sourcing
enum CategoryEvent {
    Created { category_id: String, name: String, parent_id: Option<String>, timestamp: DateTime },
    Updated { category_id: String, timestamp: DateTime },
    Moved { category_id: String, old_parent: Option<String>, new_parent: Option<String>, timestamp: DateTime },
    Deleted { category_id: String, timestamp: DateTime },
    ContentAssigned { category_id: String, content_id: String, timestamp: DateTime },
    ContentUnassigned { category_id: String, content_id: String, timestamp: DateTime },
    Reordered { category_ids: [String], timestamp: DateTime }
}

impl CategoryEvent {
    fn timestamp() -> DateTime {
        match self {
            CategoryEvent.Created { timestamp, .. } => timestamp,
            CategoryEvent.Updated { timestamp, .. } => timestamp,
            CategoryEvent.Moved { timestamp, .. } => timestamp,
            CategoryEvent.Deleted { timestamp, .. } => timestamp,
            CategoryEvent.ContentAssigned { timestamp, .. } => timestamp,
            CategoryEvent.ContentUnassigned { timestamp, .. } => timestamp,
            CategoryEvent.Reordered { timestamp, .. } => timestamp
        }
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn generate_id() -> String {
    @native("uuid_v4")
}

fn slugify(text: String) -> String {
    text.to_lowercase()
        .replace(" ", "-")
        .replace("_", "-")
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '-')
        .collect()
}

// =============================================================================
// Tests
// =============================================================================

test "category creation" {
    let category = Category.new("Technology", CategoryType.Content)
    assert_eq(category.name, "Technology")?
    assert_eq(category.slug, "technology")?
    assert(category.is_root())?
}

test "category with description" {
    let category = Category.new("Programming", CategoryType.Blog)
        .with_description("All about coding")
        .with_icon("ðŸ’»")
        .with_color("#3498db")
    
    assert_eq(category.description, Some("All about coding"))?
    assert_eq(category.icon, Some("ðŸ’»"))?
}

test "category hierarchy" {
    var parent = Category.new("Technology", CategoryType.Content)
    var child = Category.new("Programming", CategoryType.Content)
    
    child.set_parent(parent.id.clone(), parent.path.clone(), parent.depth)
    
    assert_eq(child.depth, 1)?
    assert_eq(child.parent_id, Some(parent.id))?
    assert(child.path.contains(parent.id))?
}

test "category tree" {
    let root = Category.new("Root", CategoryType.Content)
    var tree = CategoryNode.new(root)
    
    let child1 = Category.new("Child 1", CategoryType.Content)
    let child2 = Category.new("Child 2", CategoryType.Content)
    
    tree.add_child(CategoryNode.new(child1))
    tree.add_child(CategoryNode.new(child2))
    
    assert_eq(tree.children.len(), 2)?
    assert_eq(tree.depth(), 1)?
}

test "category service" {
    let service = CategoryService.new()
    
    let category = Category.new("Test", CategoryType.Content)
    service.create(category.clone()).unwrap()
    
    let retrieved = service.get(category.id.clone())
    assert(retrieved.is_some())?
    assert_eq(retrieved.unwrap().name, "Test")?
}

test "category service hierarchy" {
    let service = CategoryService.new()
    
    let parent = Category.new("Parent", CategoryType.Content)
    service.create(parent.clone()).unwrap()
    
    let child = service.create_child(parent.id.clone(), "Child", CategoryType.Content).unwrap()
    
    assert_eq(child.parent_id, Some(parent.id))?
    assert_eq(child.depth, 1)?
    
    let children = service.get_children(parent.id)
    assert_eq(children.len(), 1)?
}

test "category content assignment" {
    let service = CategoryService.new()
    
    let category = Category.new("Test", CategoryType.Content)
    service.create(category.clone()).unwrap()
    
    service.assign_content("content1", category.id.clone()).unwrap()
    service.assign_content("content2", category.id.clone()).unwrap()
    
    let content = service.get_category_content(category.id.clone(), false, 10, 0)
    assert_eq(content.len(), 2)?
}

test "category breadcrumbs" {
    let service = CategoryService.new()
    
    let root = Category.new("Root", CategoryType.Content)
    service.create(root.clone()).unwrap()
    
    let child = service.create_child(root.id.clone(), "Child", CategoryType.Content).unwrap()
    let grandchild = service.create_child(child.id.clone(), "Grandchild", CategoryType.Content).unwrap()
    
    let breadcrumbs = service.get_breadcrumbs(grandchild.id)
    assert_eq(breadcrumbs.len(), 3)?
}
