// =============================================================================
// Vibee OS â€” Webhook Module
// Webhook sending, receiving, and management
// =============================================================================

use http::{Request, Response, Status, Method, Client as HttpClient, Headers}
use crypto::{hmac_sha256, hmac_sha512, constant_time_eq}
use json::{JsonValue, Serialize, Deserialize}
use uuid::{uuid}

// =============================================================================
// Webhook Sender
// =============================================================================

/// Webhook client for sending webhooks
actor WebhookSender {
    state http: HttpClient
    state config: WebhookConfig
    state retry_queue: [PendingWebhook]
    state event_log: [WebhookEvent]
    
    fn new() -> Self {
        WebhookSender {
            http: HttpClient.new(),
            config: WebhookConfig.default(),
            retry_queue: [],
            event_log: []
        }
    }
    
    fn config(cfg: WebhookConfig) -> Self { self.config = cfg; self }
    fn timeout(ms: Int64) -> Self { self.http = self.http.timeout(ms); self }
    
    /// Send webhook to a single endpoint
    fn send<T: Serialize>(endpoint: WebhookEndpoint, event: String, payload: T) -> Result<WebhookResult, WebhookError> {
        let webhook = Webhook {
            id: uuid.v4(),
            event: event,
            payload: json.encode(payload),
            timestamp: DateTime.now(),
            attempt: 1
        }
        
        self.deliver(endpoint, webhook)
    }
    
    /// Send webhook to multiple endpoints
    fn broadcast<T: Serialize>(endpoints: [WebhookEndpoint], event: String, payload: T) -> [WebhookResult] {
        let payload_json = json.encode(payload)
        
        endpoints.iter().map(|endpoint| {
            let webhook = Webhook {
                id: uuid.v4(),
                event: event.clone(),
                payload: payload_json.clone(),
                timestamp: DateTime.now(),
                attempt: 1
            }
            
            self.deliver(endpoint, webhook).unwrap_or_else(|e| WebhookResult {
                webhook_id: webhook.id,
                endpoint_url: endpoint.url.clone(),
                success: false,
                status_code: None,
                error: Some(e.to_string()),
                duration_ms: 0
            })
        }).collect()
    }
    
    /// Deliver webhook with retry logic
    fn deliver(endpoint: WebhookEndpoint, webhook: Webhook) -> Result<WebhookResult, WebhookError> {
        var current_webhook = webhook
        var last_error: Option<WebhookError> = None
        
        while current_webhook.attempt <= self.config.max_retries + 1 {
            let start = Instant.now()
            
            match self.attempt_delivery(endpoint.clone(), current_webhook.clone()) {
                Ok(result) => {
                    self.log_event(WebhookEvent.Delivered {
                        webhook_id: current_webhook.id.clone(),
                        endpoint: endpoint.url.clone(),
                        attempt: current_webhook.attempt,
                        status_code: result.status_code.unwrap_or(0)
                    })
                    return Ok(result)
                }
                Err(e) => {
                    self.log_event(WebhookEvent.Failed {
                        webhook_id: current_webhook.id.clone(),
                        endpoint: endpoint.url.clone(),
                        attempt: current_webhook.attempt,
                        error: e.to_string()
                    })
                    
                    last_error = Some(e)
                    
                    if current_webhook.attempt <= self.config.max_retries {
                        let delay = self.config.retry_delay(current_webhook.attempt)
                        sleep(delay)
                        current_webhook.attempt += 1
                    } else {
                        break
                    }
                }
            }
        }
        
        // Add to dead letter queue if configured
        if self.config.dead_letter_queue {
            self.retry_queue.push(PendingWebhook {
                webhook: current_webhook,
                endpoint: endpoint,
                failed_at: DateTime.now()
            })
        }
        
        Err(last_error.unwrap_or(WebhookError.MaxRetriesExceeded))
    }
    
    fn attempt_delivery(endpoint: WebhookEndpoint, webhook: Webhook) -> Result<WebhookResult, WebhookError> {
        let start = Instant.now()
        
        // Build request
        var req = Request.post(endpoint.url.clone())
            .header("Content-Type", "application/json")
            .header("X-Webhook-ID", webhook.id.clone())
            .header("X-Webhook-Event", webhook.event.clone())
            .header("X-Webhook-Timestamp", webhook.timestamp.to_rfc3339())
            .header("X-Webhook-Attempt", webhook.attempt.to_string())
        
        // Add custom headers
        for (name, value) in endpoint.headers.iter() {
            req = req.header(name, value)
        }
        
        // Sign payload if secret is configured
        if let Some(secret) = endpoint.secret {
            let signature = self.sign_payload(webhook.payload.clone(), secret, endpoint.signature_algorithm)
            req = req.header(endpoint.signature_header.unwrap_or("X-Webhook-Signature"), signature)
        }
        
        req = req.body(webhook.payload.as_bytes())
        
        // Send request
        let response = self.http.send(req).map_err(|e| WebhookError.NetworkError(e.to_string()))?
        let duration = start.elapsed().as_millis()
        
        // Check response
        if response.status.is_success() {
            Ok(WebhookResult {
                webhook_id: webhook.id,
                endpoint_url: endpoint.url,
                success: true,
                status_code: Some(response.status.code),
                error: None,
                duration_ms: duration
            })
        } else {
            Err(WebhookError.HttpError {
                status_code: response.status.code,
                body: response.text()
            })
        }
    }
    
    fn sign_payload(payload: String, secret: String, algorithm: SignatureAlgorithm) -> String {
        let signature = match algorithm {
            SignatureAlgorithm.HmacSha256 => hmac_sha256(secret.as_bytes(), payload.as_bytes()),
            SignatureAlgorithm.HmacSha512 => hmac_sha512(secret.as_bytes(), payload.as_bytes())
        }
        
        format!("{}={}", algorithm.prefix(), hex.encode(signature))
    }
    
    fn log_event(event: WebhookEvent) {
        if self.config.enable_logging {
            self.event_log.push(event)
            
            // Trim log if too large
            if self.event_log.len() > self.config.max_log_entries {
                self.event_log = self.event_log[self.event_log.len() - self.config.max_log_entries..]
            }
        }
    }
    
    /// Get pending webhooks in retry queue
    fn pending_webhooks() -> [PendingWebhook] { self.retry_queue.clone() }
    
    /// Retry all pending webhooks
    fn retry_pending() -> [WebhookResult] {
        let pending = self.retry_queue.drain(..)
        pending.iter().map(|p| {
            self.deliver(p.endpoint.clone(), p.webhook.clone())
                .unwrap_or_else(|e| WebhookResult {
                    webhook_id: p.webhook.id.clone(),
                    endpoint_url: p.endpoint.url.clone(),
                    success: false,
                    status_code: None,
                    error: Some(e.to_string()),
                    duration_ms: 0
                })
        }).collect()
    }
    
    /// Get event log
    fn events() -> [WebhookEvent] { self.event_log.clone() }
}

/// Webhook endpoint configuration
struct WebhookEndpoint {
    url: String
    secret: Option<String>
    headers: Map<String, String>
    signature_algorithm: SignatureAlgorithm
    signature_header: Option<String>
    enabled: Bool
    events: [String]  // Event types to receive, empty = all
}

impl WebhookEndpoint {
    fn new(url: String) -> Self {
        WebhookEndpoint {
            url: url,
            secret: None,
            headers: Map.empty(),
            signature_algorithm: SignatureAlgorithm.HmacSha256,
            signature_header: None,
            enabled: true,
            events: []
        }
    }
    
    fn secret(s: String) -> Self { self.secret = Some(s); self }
    fn header(name: String, value: String) -> Self { self.headers.set(name, value); self }
    fn algorithm(alg: SignatureAlgorithm) -> Self { self.signature_algorithm = alg; self }
    fn signature_header(h: String) -> Self { self.signature_header = Some(h); self }
    fn events(e: [String]) -> Self { self.events = e; self }
    fn disable() -> Self { self.enabled = false; self }
    
    fn accepts_event(event: String) -> Bool {
        self.enabled && (self.events.is_empty() || self.events.contains(event))
    }
}

/// Webhook data
struct Webhook {
    id: String
    event: String
    payload: String
    timestamp: DateTime
    attempt: Int
}

/// Pending webhook for retry
struct PendingWebhook {
    webhook: Webhook
    endpoint: WebhookEndpoint
    failed_at: DateTime
}

/// Webhook delivery result
struct WebhookResult {
    webhook_id: String
    endpoint_url: String
    success: Bool
    status_code: Option<Int>
    error: Option<String>
    duration_ms: Int64
}

// =============================================================================
// Webhook Receiver
// =============================================================================

/// Webhook receiver/handler
actor WebhookReceiver {
    state handlers: Map<String, fn(WebhookPayload) -> Result<(), WebhookError>>
    state secrets: Map<String, String>  // source -> secret
    state config: ReceiverConfig
    state received_ids: LruCache<String, DateTime>  // For deduplication
    
    fn new() -> Self {
        WebhookReceiver {
            handlers: Map.empty(),
            secrets: Map.empty(),
            config: ReceiverConfig.default(),
            received_ids: LruCache.new(10000)
        }
    }
    
    fn config(cfg: ReceiverConfig) -> Self { self.config = cfg; self }
    
    /// Register handler for event type
    fn on(event: String, handler: fn(WebhookPayload) -> Result<(), WebhookError>) -> Self {
        self.handlers.set(event, handler)
        self
    }
    
    /// Register secret for a source
    fn secret(source: String, secret: String) -> Self {
        self.secrets.set(source, secret)
        self
    }
    
    /// Handle incoming webhook request
    fn handle(req: Request) -> Response {
        // Verify method
        if req.method != Method.POST {
            return Response.new(Status.new(405)).json(WebhookResponse.error("Method not allowed"))
        }
        
        // Extract webhook metadata
        let webhook_id = req.headers.get("X-Webhook-ID").unwrap_or_else(|| uuid.v4())
        let event = match req.headers.get("X-Webhook-Event") {
            Some(e) => e,
            None => return Response.bad_request().json(WebhookResponse.error("Missing event type"))
        }
        let timestamp = req.headers.get("X-Webhook-Timestamp")
            .and_then(|t| DateTime.parse_rfc3339(t).ok())
            .unwrap_or_else(|| DateTime.now())
        
        // Check for replay attacks
        if self.config.check_timestamp {
            let age = DateTime.now().timestamp() - timestamp.timestamp()
            if age > self.config.max_age_seconds || age < -self.config.max_age_seconds {
                return Response.bad_request().json(WebhookResponse.error("Timestamp too old or in future"))
            }
        }
        
        // Deduplicate
        if self.config.deduplicate {
            if self.received_ids.contains(webhook_id.clone()) {
                return Response.ok().json(WebhookResponse.success("Already processed"))
            }
            self.received_ids.put(webhook_id.clone(), DateTime.now())
        }
        
        // Verify signature if configured
        let source = req.headers.get("X-Webhook-Source").unwrap_or("default")
        if let Some(secret) = self.secrets.get(source) {
            if !self.verify_signature(req.clone(), secret) {
                return Response.new(Status.unauthorized()).json(WebhookResponse.error("Invalid signature"))
            }
        }
        
        // Parse payload
        let payload = WebhookPayload {
            id: webhook_id,
            event: event.clone(),
            data: req.json::<JsonValue>().unwrap_or(JsonValue.Null),
            timestamp: timestamp,
            headers: req.headers.clone(),
            source: source.to_string()
        }
        
        // Find and execute handler
        match self.handlers.get(event.clone()).or_else(|| self.handlers.get("*")) {
            Some(handler) => {
                match handler(payload) {
                    Ok(_) => Response.ok().json(WebhookResponse.success("Processed")),
                    Err(e) => Response.new(Status.internal_error()).json(WebhookResponse.error(e.to_string()))
                }
            }
            None => {
                if self.config.reject_unknown_events {
                    Response.bad_request().json(WebhookResponse.error(format!("Unknown event: {}", event)))
                } else {
                    Response.ok().json(WebhookResponse.success("Ignored"))
                }
            }
        }
    }
    
    fn verify_signature(req: Request, secret: String) -> Bool {
        let signature_header = req.headers.get("X-Webhook-Signature")
            .or_else(|| req.headers.get("X-Hub-Signature-256"))
            .or_else(|| req.headers.get("X-Signature"))
        
        match signature_header {
            Some(sig) => {
                let body = req.text()
                
                // Parse signature format (e.g., "sha256=abc123")
                let parts: [String] = sig.split("=").collect()
                if parts.len() != 2 {
                    return false
                }
                
                let algorithm = parts[0]
                let provided_sig = hex.decode(parts[1]).unwrap_or([])
                
                let expected_sig = match algorithm {
                    "sha256" => hmac_sha256(secret.as_bytes(), body.as_bytes()).to_vec(),
                    "sha512" => hmac_sha512(secret.as_bytes(), body.as_bytes()).to_vec(),
                    _ => return false
                }
                
                constant_time_eq(expected_sig, provided_sig)
            }
            None => false
        }
    }
    
    /// Create HTTP handler function
    fn http_handler() -> fn(Request) -> Response {
        |req| self.handle(req)
    }
}

/// Incoming webhook payload
struct WebhookPayload {
    id: String
    event: String
    data: JsonValue
    timestamp: DateTime
    headers: Headers
    source: String
}

impl WebhookPayload {
    fn get<T: Deserialize>(key: String) -> Option<T> {
        self.data.get(key).and_then(|v| json.decode::<T>(v).ok())
    }
    
    fn data<T: Deserialize>() -> Result<T, WebhookError> {
        json.decode::<T>(self.data).map_err(|e| WebhookError.ParseError(e.to_string()))
    }
}

struct WebhookResponse {
    success: Bool
    message: String
}

impl WebhookResponse {
    fn success(msg: String) -> Self { WebhookResponse { success: true, message: msg } }
    fn error(msg: String) -> Self { WebhookResponse { success: false, message: msg } }
}

// =============================================================================
// Webhook Registry
// =============================================================================

/// Manage webhook subscriptions
actor WebhookRegistry {
    state subscriptions: Map<String, [WebhookSubscription]>  // event -> subscriptions
    state endpoints: Map<String, WebhookEndpoint>  // id -> endpoint
    state sender: WebhookSender
    
    fn new() -> Self {
        WebhookRegistry {
            subscriptions: Map.empty(),
            endpoints: Map.empty(),
            sender: WebhookSender.new()
        }
    }
    
    /// Register a new webhook subscription
    fn subscribe(subscription: WebhookSubscription) -> String {
        let id = uuid.v4()
        
        self.endpoints.set(id.clone(), subscription.endpoint.clone())
        
        for event in subscription.events.iter() {
            self.subscriptions.entry(event.clone()).or_insert([]).push(WebhookSubscription {
                id: id.clone(),
                ..subscription.clone()
            })
        }
        
        id
    }
    
    /// Unsubscribe
    fn unsubscribe(id: String) -> Bool {
        if self.endpoints.remove(id.clone()).is_some() {
            for (_, subs) in self.subscriptions.iter_mut() {
                subs.retain(|s| s.id != id)
            }
            true
        } else {
            false
        }
    }
    
    /// Trigger event to all subscribers
    fn trigger<T: Serialize>(event: String, payload: T) -> [WebhookResult] {
        let subscribers = self.subscriptions.get(event.clone()).cloned().unwrap_or([])
        let wildcard_subscribers = self.subscriptions.get("*").cloned().unwrap_or([])
        
        let all_subscribers: [WebhookSubscription] = subscribers.iter()
            .chain(wildcard_subscribers.iter())
            .filter(|s| s.endpoint.enabled)
            .collect()
        
        let endpoints: [WebhookEndpoint] = all_subscribers.iter()
            .map(|s| s.endpoint.clone())
            .collect()
        
        self.sender.broadcast(endpoints, event, payload)
    }
    
    /// List all subscriptions
    fn list_subscriptions() -> [WebhookSubscription] {
        self.subscriptions.values().flatten().collect()
    }
    
    /// Get subscription by ID
    fn get_subscription(id: String) -> Option<WebhookSubscription> {
        self.subscriptions.values()
            .flatten()
            .find(|s| s.id == id)
            .cloned()
    }
    
    /// Update endpoint
    fn update_endpoint(id: String, endpoint: WebhookEndpoint) -> Bool {
        if self.endpoints.contains(id.clone()) {
            self.endpoints.set(id.clone(), endpoint.clone())
            
            for (_, subs) in self.subscriptions.iter_mut() {
                for sub in subs.iter_mut() {
                    if sub.id == id {
                        sub.endpoint = endpoint.clone()
                    }
                }
            }
            true
        } else {
            false
        }
    }
}

/// Webhook subscription
struct WebhookSubscription {
    id: String
    endpoint: WebhookEndpoint
    events: [String]
    created_at: DateTime
    metadata: Map<String, String>
}

impl WebhookSubscription {
    fn new(endpoint: WebhookEndpoint, events: [String]) -> Self {
        WebhookSubscription {
            id: "",
            endpoint: endpoint,
            events: events,
            created_at: DateTime.now(),
            metadata: Map.empty()
        }
    }
    
    fn metadata(key: String, value: String) -> Self {
        self.metadata.set(key, value)
        self
    }
}

// =============================================================================
// Configuration
// =============================================================================

struct WebhookConfig {
    max_retries: Int
    base_retry_delay_ms: Int64
    max_retry_delay_ms: Int64
    exponential_backoff: Bool
    dead_letter_queue: Bool
    enable_logging: Bool
    max_log_entries: Int
}

impl WebhookConfig {
    fn default() -> Self {
        WebhookConfig {
            max_retries: 5,
            base_retry_delay_ms: 1000,
            max_retry_delay_ms: 300000,  // 5 minutes
            exponential_backoff: true,
            dead_letter_queue: true,
            enable_logging: true,
            max_log_entries: 1000
        }
    }
    
    fn retry_delay(attempt: Int) -> Duration {
        if self.exponential_backoff {
            let delay = self.base_retry_delay_ms * (2 ** (attempt - 1))
            Duration.millis(min(delay, self.max_retry_delay_ms))
        } else {
            Duration.millis(self.base_retry_delay_ms)
        }
    }
}

struct ReceiverConfig {
    check_timestamp: Bool
    max_age_seconds: Int64
    deduplicate: Bool
    reject_unknown_events: Bool
}

impl ReceiverConfig {
    fn default() -> Self {
        ReceiverConfig {
            check_timestamp: true,
            max_age_seconds: 300,  // 5 minutes
            deduplicate: true,
            reject_unknown_events: false
        }
    }
}

enum SignatureAlgorithm { HmacSha256, HmacSha512 }
impl SignatureAlgorithm {
    fn prefix() -> String {
        match self {
            HmacSha256 => "sha256",
            HmacSha512 => "sha512"
        }
    }
}

// =============================================================================
// Events
// =============================================================================

enum WebhookEvent {
    Delivered { webhook_id: String, endpoint: String, attempt: Int, status_code: Int }
    Failed { webhook_id: String, endpoint: String, attempt: Int, error: String }
    Queued { webhook_id: String, endpoint: String }
    Expired { webhook_id: String, endpoint: String }
}

// =============================================================================
// Provider-Specific Handlers
// =============================================================================

/// GitHub webhook handler
struct GitHubWebhook;

impl GitHubWebhook {
    fn verify(req: Request, secret: String) -> Bool {
        let signature = req.headers.get("X-Hub-Signature-256").unwrap_or("")
        if !signature.starts_with("sha256=") {
            return false
        }
        
        let provided = hex.decode(signature[7..]).unwrap_or([])
        let expected = hmac_sha256(secret.as_bytes(), req.text().as_bytes())
        
        constant_time_eq(expected.to_vec(), provided)
    }
    
    fn event_type(req: Request) -> Option<String> {
        req.headers.get("X-GitHub-Event")
    }
    
    fn delivery_id(req: Request) -> Option<String> {
        req.headers.get("X-GitHub-Delivery")
    }
}

/// Stripe webhook handler
struct StripeWebhook;

impl StripeWebhook {
    fn verify(req: Request, secret: String) -> Bool {
        let signature = req.headers.get("Stripe-Signature").unwrap_or("")
        let timestamp = Self.extract_timestamp(signature)
        let sig = Self.extract_signature(signature)
        
        if timestamp.is_none() || sig.is_none() {
            return false
        }
        
        let payload = format!("{}.{}", timestamp.unwrap(), req.text())
        let expected = hmac_sha256(secret.as_bytes(), payload.as_bytes())
        
        constant_time_eq(expected.to_vec(), hex.decode(sig.unwrap()).unwrap_or([]))
    }
    
    fn extract_timestamp(sig: String) -> Option<String> {
        sig.split(",")
            .find(|p| p.starts_with("t="))
            .map(|p| p[2..].to_string())
    }
    
    fn extract_signature(sig: String) -> Option<String> {
        sig.split(",")
            .find(|p| p.starts_with("v1="))
            .map(|p| p[3..].to_string())
    }
}

/// Slack webhook handler
struct SlackWebhook;

impl SlackWebhook {
    fn verify(req: Request, signing_secret: String) -> Bool {
        let timestamp = req.headers.get("X-Slack-Request-Timestamp").unwrap_or("")
        let signature = req.headers.get("X-Slack-Signature").unwrap_or("")
        
        if !signature.starts_with("v0=") {
            return false
        }
        
        let base_string = format!("v0:{}:{}", timestamp, req.text())
        let expected = hmac_sha256(signing_secret.as_bytes(), base_string.as_bytes())
        
        constant_time_eq(
            format!("v0={}", hex.encode(expected)).as_bytes().to_vec(),
            signature.as_bytes().to_vec()
        )
    }
}

// =============================================================================
// Error Types
// =============================================================================

enum WebhookError {
    NetworkError(String)
    HttpError { status_code: Int, body: String }
    ParseError(String)
    SignatureError(String)
    Timeout
    MaxRetriesExceeded
    InvalidPayload(String)
}

impl Display for WebhookError {
    fn fmt(f: Formatter) {
        match self {
            NetworkError(msg) => f.write(format!("Network error: {}", msg)),
            HttpError { status_code, body } => f.write(format!("HTTP {}: {}", status_code, body)),
            ParseError(msg) => f.write(format!("Parse error: {}", msg)),
            SignatureError(msg) => f.write(format!("Signature error: {}", msg)),
            Timeout => f.write("Request timeout"),
            MaxRetriesExceeded => f.write("Max retries exceeded"),
            InvalidPayload(msg) => f.write(format!("Invalid payload: {}", msg))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "webhook endpoint builder" {
    let endpoint = WebhookEndpoint.new("https://example.com/webhook")
        .secret("my-secret")
        .header("X-Custom", "value")
        .events(["user.created", "user.updated"])
    
    assert_eq(endpoint.url, "https://example.com/webhook")?
    assert(endpoint.secret.is_some())?
    assert(endpoint.accepts_event("user.created"))?
    assert(!endpoint.accepts_event("order.created"))?
}

test "webhook config retry delay" {
    let config = WebhookConfig.default()
    
    assert_eq(config.retry_delay(1).as_millis(), 1000)?
    assert_eq(config.retry_delay(2).as_millis(), 2000)?
    assert_eq(config.retry_delay(3).as_millis(), 4000)?
}

test "signature generation" {
    let sender = WebhookSender.new()
    let payload = r#"{"event":"test"}"#
    let secret = "test-secret"
    
    let signature = sender.sign_payload(payload.to_string(), secret.to_string(), SignatureAlgorithm.HmacSha256)
    
    assert(signature.starts_with("sha256="))?
}

test "webhook subscription" {
    let registry = WebhookRegistry.new()
    
    let sub = WebhookSubscription.new(
        WebhookEndpoint.new("https://example.com/hook"),
        ["user.created", "user.deleted"]
    )
    
    let id = registry.subscribe(sub)
    assert(!id.is_empty())?
    
    let found = registry.get_subscription(id.clone())
    assert(found.is_some())?
    
    assert(registry.unsubscribe(id))?
}

test "receiver deduplication" {
    let receiver = WebhookReceiver.new()
        .config(ReceiverConfig { deduplicate: true, ..ReceiverConfig.default() })
        .on("test", |_| Ok(()))
    
    // First request should succeed
    // Second request with same ID should return "Already processed"
}

test "github webhook verification" {
    let secret = "test-secret"
    let payload = r#"{"action":"opened"}"#
    let signature = format!("sha256={}", hex.encode(hmac_sha256(secret.as_bytes(), payload.as_bytes())))
    
    // Would need to construct a proper request to test
}
