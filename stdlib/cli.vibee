// =============================================================================
// Vibee OS â€” CLI Module
// Command-line interface application framework
// =============================================================================

// -----------------------------------------------------------------------------
// CLI Application
// -----------------------------------------------------------------------------

/// CLI application builder
actor App {
    state name: String
    state version: String
    state description: String
    state author: String?
    state commands: Map<String, Command>
    state global_flags: [Flag]
    state default_command: String?
    state before_hook: Option<(Context) -> Result<(), Error>>
    state after_hook: Option<(Context) -> Result<(), Error>>
    
    /// Create new CLI app
    init(name: String) {
        self.name = name
        self.version = "0.1.0"
        self.description = ""
        self.commands = Map.empty()
        self.global_flags = []
    }
    
    on version(v: String) -> Self { self.version = v; self }
    on description(d: String) -> Self { self.description = d; self }
    on author(a: String) -> Self { self.author = Some(a); self }
    
    /// Add command
    on command(cmd: Command) -> Self {
        self.commands.set(cmd.name, cmd)
        self
    }
    
    /// Add global flag
    on flag(f: Flag) -> Self {
        self.global_flags.append(f)
        self
    }
    
    /// Set default command
    on default(name: String) -> Self {
        self.default_command = Some(name)
        self
    }
    
    /// Before hook (runs before any command)
    on before(hook: (Context) -> Result<(), Error>) -> Self {
        self.before_hook = Some(hook)
        self
    }
    
    /// After hook (runs after any command)
    on after(hook: (Context) -> Result<(), Error>) -> Self {
        self.after_hook = Some(hook)
        self
    }
    
    /// Run the application
    on run(args: [String] = Process.args()) -> Result<(), Error> {
        let parser = ArgParser.new(args)
        
        // Parse global flags first
        let (global_values, remaining) = parser.parse_flags(self.global_flags)?
        
        // Check for help/version
        if global_values.has("help") {
            self.print_help()
            return Ok(())
        }
        if global_values.has("version") {
            println("\(self.name) \(self.version)")
            return Ok(())
        }
        
        // Determine command
        let (cmd_name, cmd_args) = if remaining.is_empty() {
            if let default = self.default_command {
                (default, [])
            } else {
                self.print_help()
                return Ok(())
            }
        } else {
            (remaining[0], remaining[1..])
        }
        
        // Find command
        let command = self.commands.get(cmd_name).ok_or(
            Error.UnknownCommand(cmd_name)
        )?
        
        // Check for command help
        if cmd_args.contains("--help") || cmd_args.contains("-h") {
            command.print_help()
            return Ok(())
        }
        
        // Parse command flags and args
        let context = command.parse(cmd_args, global_values)?
        
        // Run hooks and command
        if let hook = self.before_hook {
            hook(context)?
        }
        
        command.execute(context)?
        
        if let hook = self.after_hook {
            hook(context)?
        }
        
        Ok(())
    }
    
    /// Print help message
    on print_help() {
        println(bold("\(self.name)") + " \(self.version)")
        
        if !self.description.is_empty() {
            println(self.description)
        }
        
        if let author = self.author {
            println(dim("by \(author)"))
        }
        
        println()
        println(yellow("USAGE:"))
        println("    \(self.name) [OPTIONS] <COMMAND>")
        
        if !self.commands.is_empty() {
            println()
            println(yellow("COMMANDS:"))
            
            let max_len = self.commands.keys()
                .map(|k| k.len())
                .max()
                .unwrap_or(10)
            
            for (name, cmd) in self.commands.sorted_by_key() {
                let padding = " ".repeat(max_len - name.len() + 2)
                println("    \(green(name))\(padding)\(cmd.description)")
            }
        }
        
        if !self.global_flags.is_empty() {
            println()
            println(yellow("OPTIONS:"))
            for flag in self.global_flags {
                flag.print_help()
            }
        }
        
        println()
        println("Use \"\(self.name) <command> --help\" for more information about a command.")
    }
}

// -----------------------------------------------------------------------------
// Command
// -----------------------------------------------------------------------------

/// CLI command
actor Command {
    state name: String
    state description: String
    state long_description: String?
    state aliases: [String]
    state flags: [Flag]
    state args: [Arg]
    state subcommands: Map<String, Command>
    state action: Option<(Context) -> Result<(), Error>>
    state hidden: Bool
    
    /// Create new command
    init(name: String) {
        self.name = name
        self.description = ""
        self.aliases = []
        self.flags = []
        self.args = []
        self.subcommands = Map.empty()
        self.hidden = false
    }
    
    on description(d: String) -> Self { self.description = d; self }
    on long_description(d: String) -> Self { self.long_description = Some(d); self }
    on alias(a: String) -> Self { self.aliases.append(a); self }
    on hidden() -> Self { self.hidden = true; self }
    
    /// Add flag
    on flag(f: Flag) -> Self {
        self.flags.append(f)
        self
    }
    
    /// Add positional argument
    on arg(a: Arg) -> Self {
        self.args.append(a)
        self
    }
    
    /// Add subcommand
    on subcommand(cmd: Command) -> Self {
        self.subcommands.set(cmd.name, cmd)
        self
    }
    
    /// Set action handler
    on action(handler: (Context) -> Result<(), Error>) -> Self {
        self.action = Some(handler)
        self
    }
    
    /// Parse arguments into context
    on parse(args: [String], global: FlagValues) -> Result<Context, Error> {
        let parser = ArgParser.new(args)
        let (flag_values, remaining) = parser.parse_flags(self.flags)?
        
        // Merge with global flags
        let merged = global.merge(flag_values)
        
        // Parse positional arguments
        let arg_values = self.parse_args(remaining)?
        
        Ok(Context.new(merged, arg_values))
    }
    
    /// Parse positional arguments
    fn parse_args(values: [String]) -> Result<ArgValues, Error> {
        let result = ArgValues.new()
        var idx = 0
        
        for arg in self.args {
            if idx >= values.len() {
                if arg.required {
                    return Err(Error.MissingArgument(arg.name))
                }
                if let default = arg.default_value {
                    result.set(arg.name, default)
                }
            } else if arg.variadic {
                result.set_many(arg.name, values[idx..])
                break
            } else {
                result.set(arg.name, values[idx])
                idx += 1
            }
        }
        
        Ok(result)
    }
    
    /// Execute command
    on execute(ctx: Context) -> Result<(), Error> {
        if let action = self.action {
            action(ctx)
        } else {
            self.print_help()
            Ok(())
        }
    }
    
    /// Print help
    on print_help() {
        println(bold(self.name))
        println(self.description)
        
        if let long = self.long_description {
            println()
            println(long)
        }
        
        println()
        println(yellow("USAGE:"))
        var usage = "    \(self.name)"
        if !self.flags.is_empty() {
            usage += " [OPTIONS]"
        }
        for arg in self.args {
            if arg.required {
                usage += " <\(arg.name.to_upper())>"
            } else {
                usage += " [\(arg.name.to_upper())]"
            }
            if arg.variadic {
                usage += "..."
            }
        }
        println(usage)
        
        if !self.args.is_empty() {
            println()
            println(yellow("ARGUMENTS:"))
            for arg in self.args {
                arg.print_help()
            }
        }
        
        if !self.flags.is_empty() {
            println()
            println(yellow("OPTIONS:"))
            for flag in self.flags {
                flag.print_help()
            }
        }
        
        if !self.subcommands.is_empty() {
            println()
            println(yellow("SUBCOMMANDS:"))
            for (name, cmd) in self.subcommands.sorted_by_key() {
                if !cmd.hidden {
                    println("    \(green(name))  \(cmd.description)")
                }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Flags
// -----------------------------------------------------------------------------

/// Command flag definition
struct Flag {
    name: String
    short: Option<Char>
    description: String
    value_name: String?
    default_value: Option<String>
    required: Bool
    multiple: Bool
    hidden: Bool
    env_var: Option<String>
    validator: Option<(String) -> Result<(), String>>
    
    /// Create boolean flag
    fn bool(name: String) -> Self {
        Flag {
            name: name,
            short: None,
            description: "",
            value_name: None,
            default_value: None,
            required: false,
            multiple: false,
            hidden: false,
            env_var: None,
            validator: None
        }
    }
    
    /// Create value flag
    fn value(name: String, value_name: String) -> Self {
        Flag {
            name: name,
            short: None,
            description: "",
            value_name: Some(value_name),
            default_value: None,
            required: false,
            multiple: false,
            hidden: false,
            env_var: None,
            validator: None
        }
    }
    
    fn short(c: Char) -> Self { self.short = Some(c); self }
    fn description(d: String) -> Self { self.description = d; self }
    fn default(v: String) -> Self { self.default_value = Some(v); self }
    fn required() -> Self { self.required = true; self }
    fn multiple() -> Self { self.multiple = true; self }
    fn hidden() -> Self { self.hidden = true; self }
    fn env(var: String) -> Self { self.env_var = Some(var); self }
    fn validate(f: (String) -> Result<(), String>) -> Self { self.validator = Some(f); self }
    
    /// Check if flag is boolean (no value)
    fn is_bool() -> Bool {
        self.value_name.is_none()
    }
    
    /// Print help line
    fn print_help() {
        var line = "    "
        
        if let s = self.short {
            line += "-\(s), "
        } else {
            line += "    "
        }
        
        line += "--\(self.name)"
        
        if let vn = self.value_name {
            line += " <\(vn)>"
        }
        
        let padding = " ".repeat(30 - line.len().max(30))
        line += padding + self.description
        
        if let default = self.default_value {
            line += dim(" [default: \(default)]")
        }
        
        if let env = self.env_var {
            line += dim(" [env: \(env)]")
        }
        
        println(line)
    }
}

/// Parsed flag values
actor FlagValues {
    state values: Map<String, [String]>
    state bools: Set<String>
    
    fn new() -> Self {
        FlagValues {
            values: Map.empty(),
            bools: Set.empty()
        }
    }
    
    /// Check if boolean flag is set
    fn has(name: String) -> Bool {
        self.bools.contains(name)
    }
    
    /// Get flag value
    fn get(name: String) -> Option<String> {
        self.values.get(name).and_then(|v| v.first())
    }
    
    /// Get all values for multiple flag
    fn get_all(name: String) -> [String] {
        self.values.get(name).unwrap_or([])
    }
    
    /// Get value or default
    fn get_or(name: String, default: String) -> String {
        self.get(name).unwrap_or(default)
    }
    
    /// Get as integer
    fn get_int(name: String) -> Option<Int> {
        self.get(name).and_then(|v| Int.parse(v).ok())
    }
    
    /// Get as boolean
    fn get_bool(name: String) -> Bool {
        self.has(name) || self.get(name).map(|v| 
            v == "true" || v == "1" || v == "yes"
        ).unwrap_or(false)
    }
    
    /// Merge with another FlagValues
    fn merge(other: FlagValues) -> FlagValues {
        let result = FlagValues.new()
        result.values = self.values.merge(other.values)
        result.bools = self.bools.union(other.bools)
        result
    }
    
    on set(name: String, value: String) {
        self.values.entry(name).or_default().append(value)
    }
    
    on set_bool(name: String) {
        self.bools.insert(name)
    }
}

// -----------------------------------------------------------------------------
// Arguments
// -----------------------------------------------------------------------------

/// Positional argument definition
struct Arg {
    name: String
    description: String
    required: Bool
    variadic: Bool
    default_value: Option<String>
    validator: Option<(String) -> Result<(), String>>
    
    /// Create required argument
    fn required(name: String) -> Self {
        Arg {
            name: name,
            description: "",
            required: true,
            variadic: false,
            default_value: None,
            validator: None
        }
    }
    
    /// Create optional argument
    fn optional(name: String) -> Self {
        Arg {
            name: name,
            description: "",
            required: false,
            variadic: false,
            default_value: None,
            validator: None
        }
    }
    
    fn description(d: String) -> Self { self.description = d; self }
    fn default(v: String) -> Self { self.default_value = Some(v); self }
    fn variadic() -> Self { self.variadic = true; self }
    fn validate(f: (String) -> Result<(), String>) -> Self { self.validator = Some(f); self }
    
    fn print_help() {
        var line = "    <\(self.name.to_upper())>"
        if self.variadic {
            line += "..."
        }
        let padding = " ".repeat(20 - line.len().max(20))
        line += padding + self.description
        
        if let default = self.default_value {
            line += dim(" [default: \(default)]")
        }
        
        println(line)
    }
}

/// Parsed argument values
actor ArgValues {
    state values: Map<String, [String]>
    
    fn new() -> Self {
        ArgValues { values: Map.empty() }
    }
    
    fn get(name: String) -> Option<String> {
        self.values.get(name).and_then(|v| v.first())
    }
    
    fn get_all(name: String) -> [String] {
        self.values.get(name).unwrap_or([])
    }
    
    fn get_or(name: String, default: String) -> String {
        self.get(name).unwrap_or(default)
    }
    
    on set(name: String, value: String) {
        self.values.set(name, [value])
    }
    
    on set_many(name: String, values: [String]) {
        self.values.set(name, values)
    }
}

// -----------------------------------------------------------------------------
// Context
// -----------------------------------------------------------------------------

/// Command execution context
actor Context {
    state flags: FlagValues
    state args: ArgValues
    state data: Map<String, Any>
    
    fn new(flags: FlagValues, args: ArgValues) -> Self {
        Context {
            flags: flags,
            args: args,
            data: Map.empty()
        }
    }
    
    // Flag accessors
    fn flag(name: String) -> Option<String> { self.flags.get(name) }
    fn flag_or(name: String, default: String) -> String { self.flags.get_or(name, default) }
    fn flag_int(name: String) -> Option<Int> { self.flags.get_int(name) }
    fn flag_bool(name: String) -> Bool { self.flags.get_bool(name) }
    fn has_flag(name: String) -> Bool { self.flags.has(name) }
    
    // Arg accessors
    fn arg(name: String) -> Option<String> { self.args.get(name) }
    fn arg_or(name: String, default: String) -> String { self.args.get_or(name, default) }
    fn args(name: String) -> [String] { self.args.get_all(name) }
    
    // Custom data
    fn set<T>(key: String, value: T) { self.data.set(key, value) }
    fn get<T>(key: String) -> Option<T> { self.data.get(key) }
}

// -----------------------------------------------------------------------------
// Argument Parser
// -----------------------------------------------------------------------------

/// Low-level argument parser
actor ArgParser {
    state args: [String]
    state pos: Int
    
    fn new(args: [String]) -> Self {
        ArgParser { args: args, pos: 0 }
    }
    
    /// Parse flags from arguments
    fn parse_flags(flags: [Flag]) -> Result<(FlagValues, [String]), Error> {
        let values = FlagValues.new()
        let remaining = []
        
        while self.pos < self.args.len() {
            let arg = self.args[self.pos]
            
            if arg == "--" {
                // Everything after -- is positional
                remaining.extend(self.args[(self.pos + 1)..])
                break
            } else if arg.starts_with("--") {
                // Long flag
                let (name, value) = self.parse_long_flag(arg)
                let flag = flags.find(|f| f.name == name)
                    .ok_or(Error.UnknownFlag(name))?
                
                if flag.is_bool() {
                    values.set_bool(name)
                } else {
                    let v = value.or_else(|| self.next_value())
                        .ok_or(Error.MissingValue(name))?
                    values.set(name, v)
                }
            } else if arg.starts_with("-") && arg.len() > 1 {
                // Short flag(s)
                self.parse_short_flags(arg, flags, values)?
            } else {
                // Positional argument
                remaining.append(arg)
            }
            
            self.pos += 1
        }
        
        // Check required flags
        for flag in flags {
            if flag.required && !values.has(flag.name) && values.get(flag.name).is_none() {
                // Check environment variable
                if let env = flag.env_var {
                    if let v = Environment.get(env) {
                        values.set(flag.name, v)
                        continue
                    }
                }
                // Use default
                if let default = flag.default_value {
                    values.set(flag.name, default)
                    continue
                }
                return Err(Error.MissingRequired(flag.name))
            }
        }
        
        Ok((values, remaining))
    }
    
    fn parse_long_flag(arg: String) -> (String, Option<String>) {
        let without_dashes = arg[2..]
        if let eq_pos = without_dashes.find("=") {
            (without_dashes[..eq_pos], Some(without_dashes[(eq_pos + 1)..]))
        } else {
            (without_dashes, None)
        }
    }
    
    fn parse_short_flags(arg: String, flags: [Flag], values: FlagValues) -> Result<(), Error> {
        let chars = arg[1..].chars()
        
        for (i, c) in chars.enumerate() {
            let flag = flags.find(|f| f.short == Some(c))
                .ok_or(Error.UnknownFlag("-\(c)"))?
            
            if flag.is_bool() {
                values.set_bool(flag.name)
            } else {
                // Value flag - rest of string or next arg
                let rest = arg[(i + 2)..]
                let v = if !rest.is_empty() {
                    rest
                } else {
                    self.next_value().ok_or(Error.MissingValue(flag.name))?
                }
                values.set(flag.name, v)
                break
            }
        }
        
        Ok(())
    }
    
    fn next_value() -> Option<String> {
        if self.pos + 1 < self.args.len() {
            let next = self.args[self.pos + 1]
            if !next.starts_with("-") {
                self.pos += 1
                return Some(next)
            }
        }
        None
    }
}

// -----------------------------------------------------------------------------
// Interactive Prompts
// -----------------------------------------------------------------------------

/// Prompt for user input
fn prompt(message: String) -> String {
    print("\(message): ")
    IO.flush()
    IO.read_line().trim()
}

/// Prompt with default value
fn prompt_default(message: String, default: String) -> String {
    print("\(message) [\(default)]: ")
    IO.flush()
    let input = IO.read_line().trim()
    if input.is_empty() { default } else { input }
}

/// Prompt for password (hidden input)
fn prompt_password(message: String) -> String {
    print("\(message): ")
    IO.flush()
    @native("cli_read_password")
}

/// Confirm yes/no
fn confirm(message: String, default: Bool = false) -> Bool {
    let hint = if default { "[Y/n]" } else { "[y/N]" }
    print("\(message) \(hint): ")
    IO.flush()
    
    let input = IO.read_line().trim().to_lower()
    match input {
        "y" | "yes" => true
        "n" | "no" => false
        "" => default
        _ => confirm(message, default)  // Ask again
    }
}

/// Select from options
fn select<T>(message: String, options: [(String, T)]) -> T {
    println(message)
    for (i, (label, _)) in options.enumerate() {
        println("  \(i + 1). \(label)")
    }
    
    loop {
        print("Enter choice (1-\(options.len())): ")
        IO.flush()
        
        if let n = Int.parse(IO.read_line().trim()) {
            if n >= 1 && n <= options.len() {
                return options[n - 1].1
            }
        }
        println(red("Invalid choice, try again"))
    }
}

/// Multi-select from options
fn multi_select<T>(message: String, options: [(String, T)]) -> [T] {
    println(message)
    println(dim("(Enter comma-separated numbers)"))
    
    for (i, (label, _)) in options.enumerate() {
        println("  \(i + 1). \(label)")
    }
    
    print("Enter choices: ")
    IO.flush()
    
    let input = IO.read_line().trim()
    let selected = []
    
    for part in input.split(",") {
        if let n = Int.parse(part.trim()) {
            if n >= 1 && n <= options.len() {
                selected.append(options[n - 1].1)
            }
        }
    }
    
    selected
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum Error {
    UnknownCommand(String)
    UnknownFlag(String)
    MissingRequired(String)
    MissingValue(String)
    MissingArgument(String)
    InvalidValue(String, String)
    
    fn message() -> String {
        match self {
            .UnknownCommand(cmd) => "Unknown command: \(cmd)"
            .UnknownFlag(flag) => "Unknown flag: \(flag)"
            .MissingRequired(name) => "Missing required flag: --\(name)"
            .MissingValue(name) => "Flag --\(name) requires a value"
            .MissingArgument(name) => "Missing required argument: \(name)"
            .InvalidValue(name, msg) => "Invalid value for \(name): \(msg)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "flag parsing" {
    let flags = [
        Flag.bool("verbose").short('v'),
        Flag.value("output", "FILE").short('o')
    ]
    
    let parser = ArgParser.new(["-v", "-o", "out.txt", "input.txt"])
    let (values, remaining) = parser.parse_flags(flags)?
    
    assert(values.has("verbose"))
    assert(values.get("output") == Some("out.txt"))
    assert(remaining == ["input.txt"])
}

test "long flag with equals" {
    let flags = [Flag.value("config", "FILE")]
    let parser = ArgParser.new(["--config=app.toml"])
    let (values, _) = parser.parse_flags(flags)?
    
    assert(values.get("config") == Some("app.toml"))
}

test "app builder" {
    let app = App.new("myapp")
        .version("1.0.0")
        .description("My CLI app")
        .command(
            Command.new("run")
                .description("Run the app")
                .flag(Flag.bool("verbose").short('v'))
        )
    
    assert(app.name == "myapp")
    assert(app.commands.contains_key("run"))
}
