// =============================================================================
// Vibee OS â€” Vector Module
// Vectors and matrices for linear algebra
// =============================================================================

// -----------------------------------------------------------------------------
// Vector Types
// -----------------------------------------------------------------------------

/// 2D Vector
struct Vec2 {
    x: Float
    y: Float
    
    fn new(x: Float, y: Float) -> Self { Vec2 { x: x, y: y } }
    fn zero() -> Self { Vec2 { x: 0.0, y: 0.0 } }
    fn one() -> Self { Vec2 { x: 1.0, y: 1.0 } }
    fn unit_x() -> Self { Vec2 { x: 1.0, y: 0.0 } }
    fn unit_y() -> Self { Vec2 { x: 0.0, y: 1.0 } }
    
    fn length() -> Float { (self.x * self.x + self.y * self.y).sqrt() }
    fn length_squared() -> Float { self.x * self.x + self.y * self.y }
    fn normalize() -> Self { let l = self.length(); Vec2 { x: self.x / l, y: self.y / l } }
    fn dot(other: Vec2) -> Float { self.x * other.x + self.y * other.y }
    fn cross(other: Vec2) -> Float { self.x * other.y - self.y * other.x }
    fn angle() -> Float { self.y.atan2(self.x) }
    fn rotate(angle: Float) -> Self {
        let c = angle.cos(); let s = angle.sin()
        Vec2 { x: self.x * c - self.y * s, y: self.x * s + self.y * c }
    }
    fn lerp(other: Vec2, t: Float) -> Self {
        Vec2 { x: self.x + (other.x - self.x) * t, y: self.y + (other.y - self.y) * t }
    }
    fn distance(other: Vec2) -> Float { (self - other).length() }
    fn reflect(normal: Vec2) -> Self { self - normal * 2.0 * self.dot(normal) }
}

impl Add for Vec2 { fn add(o: Vec2) -> Vec2 { Vec2 { x: self.x + o.x, y: self.y + o.y } } }
impl Sub for Vec2 { fn sub(o: Vec2) -> Vec2 { Vec2 { x: self.x - o.x, y: self.y - o.y } } }
impl Mul<Float> for Vec2 { fn mul(s: Float) -> Vec2 { Vec2 { x: self.x * s, y: self.y * s } } }
impl Div<Float> for Vec2 { fn div(s: Float) -> Vec2 { Vec2 { x: self.x / s, y: self.y / s } } }
impl Neg for Vec2 { fn neg() -> Vec2 { Vec2 { x: -self.x, y: -self.y } } }

/// 3D Vector
struct Vec3 {
    x: Float, y: Float, z: Float
    
    fn new(x: Float, y: Float, z: Float) -> Self { Vec3 { x: x, y: y, z: z } }
    fn zero() -> Self { Vec3 { x: 0.0, y: 0.0, z: 0.0 } }
    fn one() -> Self { Vec3 { x: 1.0, y: 1.0, z: 1.0 } }
    fn unit_x() -> Self { Vec3 { x: 1.0, y: 0.0, z: 0.0 } }
    fn unit_y() -> Self { Vec3 { x: 0.0, y: 1.0, z: 0.0 } }
    fn unit_z() -> Self { Vec3 { x: 0.0, y: 0.0, z: 1.0 } }
    
    fn length() -> Float { (self.x*self.x + self.y*self.y + self.z*self.z).sqrt() }
    fn length_squared() -> Float { self.x*self.x + self.y*self.y + self.z*self.z }
    fn normalize() -> Self { let l = self.length(); Vec3 { x: self.x/l, y: self.y/l, z: self.z/l } }
    fn dot(o: Vec3) -> Float { self.x*o.x + self.y*o.y + self.z*o.z }
    fn cross(o: Vec3) -> Vec3 {
        Vec3 { x: self.y*o.z - self.z*o.y, y: self.z*o.x - self.x*o.z, z: self.x*o.y - self.y*o.x }
    }
    fn lerp(o: Vec3, t: Float) -> Self {
        Vec3 { x: self.x + (o.x-self.x)*t, y: self.y + (o.y-self.y)*t, z: self.z + (o.z-self.z)*t }
    }
    fn distance(o: Vec3) -> Float { (self - o).length() }
    fn reflect(n: Vec3) -> Self { self - n * 2.0 * self.dot(n) }
    fn xy() -> Vec2 { Vec2 { x: self.x, y: self.y } }
}

impl Add for Vec3 { fn add(o: Vec3) -> Vec3 { Vec3 { x: self.x+o.x, y: self.y+o.y, z: self.z+o.z } } }
impl Sub for Vec3 { fn sub(o: Vec3) -> Vec3 { Vec3 { x: self.x-o.x, y: self.y-o.y, z: self.z-o.z } } }
impl Mul<Float> for Vec3 { fn mul(s: Float) -> Vec3 { Vec3 { x: self.x*s, y: self.y*s, z: self.z*s } } }
impl Neg for Vec3 { fn neg() -> Vec3 { Vec3 { x: -self.x, y: -self.y, z: -self.z } } }

/// 4D Vector
struct Vec4 {
    x: Float, y: Float, z: Float, w: Float
    
    fn new(x: Float, y: Float, z: Float, w: Float) -> Self { Vec4 { x: x, y: y, z: z, w: w } }
    fn zero() -> Self { Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 0.0 } }
    fn length() -> Float { (self.x*self.x + self.y*self.y + self.z*self.z + self.w*self.w).sqrt() }
    fn normalize() -> Self { let l = self.length(); Vec4 { x: self.x/l, y: self.y/l, z: self.z/l, w: self.w/l } }
    fn dot(o: Vec4) -> Float { self.x*o.x + self.y*o.y + self.z*o.z + self.w*o.w }
    fn xyz() -> Vec3 { Vec3 { x: self.x, y: self.y, z: self.z } }
}

// -----------------------------------------------------------------------------
// Matrices
// -----------------------------------------------------------------------------

/// 3x3 Matrix (row-major)
struct Mat3 {
    m: [Float; 9]
    
    fn identity() -> Self { Mat3 { m: [1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0] } }
    fn zero() -> Self { Mat3 { m: [0.0; 9] } }
    
    fn get(row: Int, col: Int) -> Float { self.m[row * 3 + col] }
    fn set(row: Int, col: Int, v: Float) { self.m[row * 3 + col] = v }
    
    fn transpose() -> Self {
        Mat3 { m: [self.m[0],self.m[3],self.m[6], self.m[1],self.m[4],self.m[7], self.m[2],self.m[5],self.m[8]] }
    }
    
    fn determinant() -> Float {
        self.m[0]*(self.m[4]*self.m[8]-self.m[5]*self.m[7]) -
        self.m[1]*(self.m[3]*self.m[8]-self.m[5]*self.m[6]) +
        self.m[2]*(self.m[3]*self.m[7]-self.m[4]*self.m[6])
    }
    
    fn rotation(angle: Float) -> Self {
        let c = angle.cos(); let s = angle.sin()
        Mat3 { m: [c,-s,0.0, s,c,0.0, 0.0,0.0,1.0] }
    }
    
    fn scale(sx: Float, sy: Float) -> Self {
        Mat3 { m: [sx,0.0,0.0, 0.0,sy,0.0, 0.0,0.0,1.0] }
    }
    
    fn translation(tx: Float, ty: Float) -> Self {
        Mat3 { m: [1.0,0.0,tx, 0.0,1.0,ty, 0.0,0.0,1.0] }
    }
}

impl Mul for Mat3 {
    fn mul(o: Mat3) -> Mat3 {
        var r = Mat3.zero()
        for i in 0..3 { for j in 0..3 { for k in 0..3 {
            r.m[i*3+j] += self.m[i*3+k] * o.m[k*3+j]
        }}}
        r
    }
}

impl Mul<Vec3> for Mat3 {
    fn mul(v: Vec3) -> Vec3 {
        Vec3 {
            x: self.m[0]*v.x + self.m[1]*v.y + self.m[2]*v.z,
            y: self.m[3]*v.x + self.m[4]*v.y + self.m[5]*v.z,
            z: self.m[6]*v.x + self.m[7]*v.y + self.m[8]*v.z
        }
    }
}

/// 4x4 Matrix (row-major)
struct Mat4 {
    m: [Float; 16]
    
    fn identity() -> Self {
        Mat4 { m: [1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0] }
    }
    fn zero() -> Self { Mat4 { m: [0.0; 16] } }
    
    fn get(row: Int, col: Int) -> Float { self.m[row * 4 + col] }
    fn set(row: Int, col: Int, v: Float) { self.m[row * 4 + col] = v }
    
    fn transpose() -> Self {
        var r = Mat4.zero()
        for i in 0..4 { for j in 0..4 { r.m[j*4+i] = self.m[i*4+j] } }
        r
    }
    
    fn translation(x: Float, y: Float, z: Float) -> Self {
        Mat4 { m: [1.0,0.0,0.0,x, 0.0,1.0,0.0,y, 0.0,0.0,1.0,z, 0.0,0.0,0.0,1.0] }
    }
    
    fn scale(x: Float, y: Float, z: Float) -> Self {
        Mat4 { m: [x,0.0,0.0,0.0, 0.0,y,0.0,0.0, 0.0,0.0,z,0.0, 0.0,0.0,0.0,1.0] }
    }
    
    fn rotation_x(angle: Float) -> Self {
        let c = angle.cos(); let s = angle.sin()
        Mat4 { m: [1.0,0.0,0.0,0.0, 0.0,c,-s,0.0, 0.0,s,c,0.0, 0.0,0.0,0.0,1.0] }
    }
    
    fn rotation_y(angle: Float) -> Self {
        let c = angle.cos(); let s = angle.sin()
        Mat4 { m: [c,0.0,s,0.0, 0.0,1.0,0.0,0.0, -s,0.0,c,0.0, 0.0,0.0,0.0,1.0] }
    }
    
    fn rotation_z(angle: Float) -> Self {
        let c = angle.cos(); let s = angle.sin()
        Mat4 { m: [c,-s,0.0,0.0, s,c,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0] }
    }
    
    fn perspective(fov: Float, aspect: Float, near: Float, far: Float) -> Self {
        let f = 1.0 / (fov / 2.0).tan()
        let nf = 1.0 / (near - far)
        Mat4 { m: [f/aspect,0.0,0.0,0.0, 0.0,f,0.0,0.0, 0.0,0.0,(far+near)*nf,2.0*far*near*nf, 0.0,0.0,-1.0,0.0] }
    }
    
    fn ortho(left: Float, right: Float, bottom: Float, top: Float, near: Float, far: Float) -> Self {
        let w = right - left; let h = top - bottom; let d = far - near
        Mat4 { m: [2.0/w,0.0,0.0,-(right+left)/w, 0.0,2.0/h,0.0,-(top+bottom)/h, 0.0,0.0,-2.0/d,-(far+near)/d, 0.0,0.0,0.0,1.0] }
    }
    
    fn look_at(eye: Vec3, target: Vec3, up: Vec3) -> Self {
        let f = (target - eye).normalize()
        let s = f.cross(up).normalize()
        let u = s.cross(f)
        Mat4 { m: [s.x,s.y,s.z,-s.dot(eye), u.x,u.y,u.z,-u.dot(eye), -f.x,-f.y,-f.z,f.dot(eye), 0.0,0.0,0.0,1.0] }
    }
}

impl Mul for Mat4 {
    fn mul(o: Mat4) -> Mat4 {
        var r = Mat4.zero()
        for i in 0..4 { for j in 0..4 { for k in 0..4 {
            r.m[i*4+j] += self.m[i*4+k] * o.m[k*4+j]
        }}}
        r
    }
}

impl Mul<Vec4> for Mat4 {
    fn mul(v: Vec4) -> Vec4 {
        Vec4 {
            x: self.m[0]*v.x + self.m[1]*v.y + self.m[2]*v.z + self.m[3]*v.w,
            y: self.m[4]*v.x + self.m[5]*v.y + self.m[6]*v.z + self.m[7]*v.w,
            z: self.m[8]*v.x + self.m[9]*v.y + self.m[10]*v.z + self.m[11]*v.w,
            w: self.m[12]*v.x + self.m[13]*v.y + self.m[14]*v.z + self.m[15]*v.w
        }
    }
}

// -----------------------------------------------------------------------------
// Quaternion
// -----------------------------------------------------------------------------

struct Quat {
    x: Float, y: Float, z: Float, w: Float
    
    fn identity() -> Self { Quat { x: 0.0, y: 0.0, z: 0.0, w: 1.0 } }
    fn from_axis_angle(axis: Vec3, angle: Float) -> Self {
        let half = angle / 2.0; let s = half.sin()
        Quat { x: axis.x * s, y: axis.y * s, z: axis.z * s, w: half.cos() }
    }
    fn length() -> Float { (self.x*self.x + self.y*self.y + self.z*self.z + self.w*self.w).sqrt() }
    fn normalize() -> Self { let l = self.length(); Quat { x: self.x/l, y: self.y/l, z: self.z/l, w: self.w/l } }
    fn conjugate() -> Self { Quat { x: -self.x, y: -self.y, z: -self.z, w: self.w } }
    fn inverse() -> Self { let l2 = self.length_squared(); self.conjugate() / l2 }
    fn length_squared() -> Float { self.x*self.x + self.y*self.y + self.z*self.z + self.w*self.w }
    
    fn to_mat4() -> Mat4 {
        let x2 = self.x*2.0; let y2 = self.y*2.0; let z2 = self.z*2.0
        let xx = self.x*x2; let xy = self.x*y2; let xz = self.x*z2
        let yy = self.y*y2; let yz = self.y*z2; let zz = self.z*z2
        let wx = self.w*x2; let wy = self.w*y2; let wz = self.w*z2
        Mat4 { m: [1.0-yy-zz,xy-wz,xz+wy,0.0, xy+wz,1.0-xx-zz,yz-wx,0.0, xz-wy,yz+wx,1.0-xx-yy,0.0, 0.0,0.0,0.0,1.0] }
    }
    
    fn slerp(other: Quat, t: Float) -> Quat {
        var dot = self.x*other.x + self.y*other.y + self.z*other.z + self.w*other.w
        var o = other
        if dot < 0.0 { o = Quat { x: -o.x, y: -o.y, z: -o.z, w: -o.w }; dot = -dot }
        if dot > 0.9995 { return (self * (1.0-t) + o * t).normalize() }
        let theta = dot.acos(); let sin_theta = theta.sin()
        let s1 = ((1.0-t)*theta).sin() / sin_theta
        let s2 = (t*theta).sin() / sin_theta
        Quat { x: self.x*s1 + o.x*s2, y: self.y*s1 + o.y*s2, z: self.z*s1 + o.z*s2, w: self.w*s1 + o.w*s2 }
    }
}

impl Mul for Quat {
    fn mul(o: Quat) -> Quat {
        Quat {
            x: self.w*o.x + self.x*o.w + self.y*o.z - self.z*o.y,
            y: self.w*o.y - self.x*o.z + self.y*o.w + self.z*o.x,
            z: self.w*o.z + self.x*o.y - self.y*o.x + self.z*o.w,
            w: self.w*o.w - self.x*o.x - self.y*o.y - self.z*o.z
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "vec2" {
    let v = Vec2.new(3.0, 4.0)
    assert(approx_eq(v.length(), 5.0))
}

test "vec3 cross" {
    let x = Vec3.unit_x()
    let y = Vec3.unit_y()
    let z = x.cross(y)
    assert(approx_eq(z.z, 1.0))
}

test "mat4 identity" {
    let m = Mat4.identity()
    let v = Vec4.new(1.0, 2.0, 3.0, 1.0)
    let r = m * v
    assert(approx_eq(r.x, 1.0) && approx_eq(r.y, 2.0) && approx_eq(r.z, 3.0))
}

fn approx_eq(a: Float, b: Float) -> Bool { (a - b).abs() < 0.0001 }
