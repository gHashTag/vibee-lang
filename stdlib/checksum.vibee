// =============================================================================
// Vibee OS â€” Checksum Module
// Checksum algorithms for data integrity verification
// =============================================================================
//
// This module provides various checksum algorithms:
// - CRC32 (IEEE, Castagnoli, Koopman)
// - CRC16 (CCITT, IBM, XMODEM)
// - Adler32
// - Fletcher16/32
// - Internet checksum (RFC 1071)
// - Luhn algorithm (credit cards)
// - ISBN/ISSN validation
// =============================================================================

// =============================================================================
// CRC32 Variants
// =============================================================================

/// CRC32 polynomial variants
enum Crc32Poly {
    IEEE        // 0x04C11DB7 - Standard Ethernet, ZIP, PNG
    Castagnoli  // 0x1EDC6F41 - iSCSI, Btrfs, ext4
    Koopman     // 0x741B8CD7 - Best for certain data lengths
}

impl Crc32Poly {
    fn value() -> UInt32 {
        match self {
            IEEE => 0xEDB88320       // Reflected
            Castagnoli => 0x82F63B78 // Reflected
            Koopman => 0xEB31D82E    // Reflected
        }
    }
}

/// CRC32 checksum calculator
struct Crc32 {
    table: [UInt32; 256]
    value: UInt32
    poly: Crc32Poly
}

impl Crc32 {
    /// Create with IEEE polynomial (default)
    fn new() -> Self {
        Self.with_poly(Crc32Poly.IEEE)
    }
    
    /// Create with specific polynomial
    fn with_poly(poly: Crc32Poly) -> Self {
        let table = generate_crc32_table(poly.value())
        Crc32 { table: table, value: 0xFFFFFFFF, poly: poly }
    }
    
    /// Update checksum with data
    fn update(data: [UInt8]) -> Self {
        for byte in data {
            let idx = ((self.value ^ byte as UInt32) & 0xFF) as Int
            self.value = (self.value >> 8) ^ self.table[idx]
        }
        self
    }
    
    /// Update with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Finalize and get checksum
    fn finalize() -> UInt32 {
        self.value ^ 0xFFFFFFFF
    }
    
    /// Reset for reuse
    fn reset() {
        self.value = 0xFFFFFFFF
    }
    
    /// Get checksum as hex string
    fn to_hex() -> String {
        format!("{:08x}", self.finalize())
    }
}

fn generate_crc32_table(poly: UInt32) -> [UInt32; 256] {
    var table = [0u32; 256]
    for i in 0..256 {
        var crc = i as UInt32
        for _ in 0..8 {
            crc = if crc & 1 != 0 { (crc >> 1) ^ poly } else { crc >> 1 }
        }
        table[i] = crc
    }
    table
}

/// Quick CRC32 calculation
fn crc32(data: [UInt8]) -> UInt32 {
    Crc32.new().update(data).finalize()
}

/// CRC32 of string
fn crc32_string(s: String) -> UInt32 {
    crc32(s.as_bytes())
}

/// CRC32 as hex
fn crc32_hex(data: [UInt8]) -> String {
    format!("{:08x}", crc32(data))
}

/// CRC32-C (Castagnoli)
fn crc32c(data: [UInt8]) -> UInt32 {
    Crc32.with_poly(Crc32Poly.Castagnoli).update(data).finalize()
}

// =============================================================================
// CRC16 Variants
// =============================================================================

/// CRC16 polynomial variants
enum Crc16Poly {
    CCITT   // 0x1021 - X.25, HDLC
    IBM     // 0x8005 - USB, Modbus
    XMODEM  // 0x1021 - XMODEM protocol
    DNP     // 0x3D65 - DNP3 protocol
}

impl Crc16Poly {
    fn value() -> UInt16 {
        match self {
            CCITT => 0x8408   // Reflected
            IBM => 0xA001    // Reflected
            XMODEM => 0x1021 // Not reflected
            DNP => 0xA6BC    // Reflected
        }
    }
    
    fn init() -> UInt16 {
        match self {
            CCITT => 0xFFFF
            IBM => 0x0000
            XMODEM => 0x0000
            DNP => 0x0000
        }
    }
}

/// CRC16 checksum calculator
struct Crc16 {
    table: [UInt16; 256]
    value: UInt16
    poly: Crc16Poly
}

impl Crc16 {
    fn new() -> Self {
        Self.with_poly(Crc16Poly.CCITT)
    }
    
    fn with_poly(poly: Crc16Poly) -> Self {
        let table = generate_crc16_table(poly.value())
        Crc16 { table: table, value: poly.init(), poly: poly }
    }
    
    fn update(data: [UInt8]) -> Self {
        for byte in data {
            let idx = ((self.value ^ byte as UInt16) & 0xFF) as Int
            self.value = (self.value >> 8) ^ self.table[idx]
        }
        self
    }
    
    fn finalize() -> UInt16 {
        match self.poly {
            CCITT => self.value ^ 0xFFFF
            _ => self.value
        }
    }
    
    fn to_hex() -> String {
        format!("{:04x}", self.finalize())
    }
}

fn generate_crc16_table(poly: UInt16) -> [UInt16; 256] {
    var table = [0u16; 256]
    for i in 0..256 {
        var crc = i as UInt16
        for _ in 0..8 {
            crc = if crc & 1 != 0 { (crc >> 1) ^ poly } else { crc >> 1 }
        }
        table[i] = crc
    }
    table
}

/// Quick CRC16 calculation
fn crc16(data: [UInt8]) -> UInt16 {
    Crc16.new().update(data).finalize()
}

// =============================================================================
// Adler32
// =============================================================================

/// Adler32 checksum (used in zlib)
struct Adler32 {
    a: UInt32
    b: UInt32
}

impl Adler32 {
    fn new() -> Self {
        Adler32 { a: 1, b: 0 }
    }
    
    fn update(data: [UInt8]) -> Self {
        const MOD: UInt32 = 65521
        
        for byte in data {
            self.a = (self.a + byte as UInt32) % MOD
            self.b = (self.b + self.a) % MOD
        }
        self
    }
    
    fn finalize() -> UInt32 {
        (self.b << 16) | self.a
    }
    
    fn reset() {
        self.a = 1
        self.b = 0
    }
}

/// Quick Adler32 calculation
fn adler32(data: [UInt8]) -> UInt32 {
    Adler32.new().update(data).finalize()
}

/// Adler32 of string
fn adler32_string(s: String) -> UInt32 {
    adler32(s.as_bytes())
}

// =============================================================================
// Fletcher Checksums
// =============================================================================

/// Fletcher-16 checksum
fn fletcher16(data: [UInt8]) -> UInt16 {
    var sum1: UInt16 = 0
    var sum2: UInt16 = 0
    
    for byte in data {
        sum1 = (sum1 + byte as UInt16) % 255
        sum2 = (sum2 + sum1) % 255
    }
    
    (sum2 << 8) | sum1
}

/// Fletcher-32 checksum
fn fletcher32(data: [UInt16]) -> UInt32 {
    var sum1: UInt32 = 0
    var sum2: UInt32 = 0
    
    for word in data {
        sum1 = (sum1 + word as UInt32) % 65535
        sum2 = (sum2 + sum1) % 65535
    }
    
    (sum2 << 16) | sum1
}

/// Fletcher-32 from bytes
fn fletcher32_bytes(data: [UInt8]) -> UInt32 {
    var words = []
    for i in (0..data.len()).step_by(2) {
        let lo = data[i] as UInt16
        let hi = if i + 1 < data.len() { data[i + 1] as UInt16 } else { 0 }
        words.push((hi << 8) | lo)
    }
    fletcher32(words)
}

// =============================================================================
// Internet Checksum (RFC 1071)
// =============================================================================

/// Internet checksum (used in IP, TCP, UDP headers)
fn internet_checksum(data: [UInt8]) -> UInt16 {
    var sum: UInt32 = 0
    
    // Sum 16-bit words
    for i in (0..data.len()).step_by(2) {
        let hi = data[i] as UInt32
        let lo = if i + 1 < data.len() { data[i + 1] as UInt32 } else { 0 }
        sum += (hi << 8) | lo
    }
    
    // Fold 32-bit sum to 16 bits
    while sum >> 16 != 0 {
        sum = (sum & 0xFFFF) + (sum >> 16)
    }
    
    // One's complement
    !(sum as UInt16)
}

/// Verify internet checksum
fn verify_internet_checksum(data: [UInt8]) -> Bool {
    internet_checksum(data) == 0
}

// =============================================================================
// Luhn Algorithm (Credit Cards)
// =============================================================================

/// Luhn checksum digit
fn luhn_checksum(digits: String) -> Int {
    let nums: [Int] = digits.chars()
        .filter(|c| c.is_digit())
        .map(|c| c.to_digit().unwrap())
        .collect()
    
    var sum = 0
    var double = false
    
    for i in (0..nums.len()).rev() {
        var d = nums[i]
        if double {
            d *= 2
            if d > 9 { d -= 9 }
        }
        sum += d
        double = !double
    }
    
    (10 - (sum % 10)) % 10
}

/// Validate Luhn checksum
fn luhn_valid(number: String) -> Bool {
    let digits: [Int] = number.chars()
        .filter(|c| c.is_digit())
        .map(|c| c.to_digit().unwrap())
        .collect()
    
    if digits.len() < 2 { return false }
    
    var sum = 0
    var double = false
    
    for i in (0..digits.len()).rev() {
        var d = digits[i]
        if double {
            d *= 2
            if d > 9 { d -= 9 }
        }
        sum += d
        double = !double
    }
    
    sum % 10 == 0
}

/// Generate Luhn check digit
fn luhn_generate(partial: String) -> String {
    let check = luhn_checksum(partial + "0")
    partial + check.to_string()
}

// =============================================================================
// ISBN/ISSN Validation
// =============================================================================

/// Validate ISBN-10
fn isbn10_valid(isbn: String) -> Bool {
    let digits: [Int] = isbn.chars()
        .filter(|c| c.is_digit() || c == 'X' || c == 'x')
        .map(|c| if c == 'X' || c == 'x' { 10 } else { c.to_digit().unwrap() })
        .collect()
    
    if digits.len() != 10 { return false }
    
    var sum = 0
    for i in 0..10 {
        sum += digits[i] * (10 - i)
    }
    
    sum % 11 == 0
}

/// Validate ISBN-13
fn isbn13_valid(isbn: String) -> Bool {
    let digits: [Int] = isbn.chars()
        .filter(|c| c.is_digit())
        .map(|c| c.to_digit().unwrap())
        .collect()
    
    if digits.len() != 13 { return false }
    
    var sum = 0
    for i in 0..13 {
        let weight = if i % 2 == 0 { 1 } else { 3 }
        sum += digits[i] * weight
    }
    
    sum % 10 == 0
}

/// Validate ISSN
fn issn_valid(issn: String) -> Bool {
    let digits: [Int] = issn.chars()
        .filter(|c| c.is_digit() || c == 'X' || c == 'x')
        .map(|c| if c == 'X' || c == 'x' { 10 } else { c.to_digit().unwrap() })
        .collect()
    
    if digits.len() != 8 { return false }
    
    var sum = 0
    for i in 0..8 {
        sum += digits[i] * (8 - i)
    }
    
    sum % 11 == 0
}

// =============================================================================
// XOR Checksum
// =============================================================================

/// Simple XOR checksum
fn xor_checksum(data: [UInt8]) -> UInt8 {
    var result: UInt8 = 0
    for byte in data {
        result ^= byte
    }
    result
}

/// XOR checksum with initial value
fn xor_checksum_init(data: [UInt8], init: UInt8) -> UInt8 {
    var result = init
    for byte in data {
        result ^= byte
    }
    result
}

// =============================================================================
// Sum Checksums
// =============================================================================

/// Simple sum checksum (mod 256)
fn sum8(data: [UInt8]) -> UInt8 {
    var sum: UInt32 = 0
    for byte in data {
        sum += byte as UInt32
    }
    (sum & 0xFF) as UInt8
}

/// Two's complement sum checksum
fn sum8_2c(data: [UInt8]) -> UInt8 {
    let s = sum8(data)
    (!s).wrapping_add(1)
}

/// 16-bit sum checksum
fn sum16(data: [UInt8]) -> UInt16 {
    var sum: UInt32 = 0
    for byte in data {
        sum += byte as UInt32
    }
    (sum & 0xFFFF) as UInt16
}

// =============================================================================
// Checksum Actor
// =============================================================================

/// Actor for streaming checksum computation
actor ChecksumActor {
    state crc32: Crc32
    state adler: Adler32
    state bytes_processed: Int
    
    fn new() -> Self {
        ChecksumActor { 
            crc32: Crc32.new(), 
            adler: Adler32.new(),
            bytes_processed: 0 
        }
    }
    
    /// Update with data
    fn update(data: [UInt8]) {
        self.crc32.update(data)
        self.adler.update(data)
        self.bytes_processed += data.len()
    }
    
    /// Get CRC32
    fn get_crc32() -> UInt32 {
        self.crc32.finalize()
    }
    
    /// Get Adler32
    fn get_adler32() -> UInt32 {
        self.adler.finalize()
    }
    
    /// Get all checksums
    fn get_all() -> ChecksumResult {
        ChecksumResult {
            crc32: self.crc32.finalize(),
            adler32: self.adler.finalize(),
            bytes: self.bytes_processed
        }
    }
    
    /// Reset
    fn reset() {
        self.crc32.reset()
        self.adler.reset()
        self.bytes_processed = 0
    }
}

/// Checksum result
struct ChecksumResult {
    crc32: UInt32
    adler32: UInt32
    bytes: Int
}

// =============================================================================
// File Checksums
// =============================================================================

/// Compute CRC32 of file
fn crc32_file(path: String) -> Result<UInt32, ChecksumError> {
    let data = fs.read_bytes(path).map_err(|e| ChecksumError.IoError(e.to_string()))?
    Ok(crc32(data))
}

/// Compute Adler32 of file
fn adler32_file(path: String) -> Result<UInt32, ChecksumError> {
    let data = fs.read_bytes(path).map_err(|e| ChecksumError.IoError(e.to_string()))?
    Ok(adler32(data))
}

/// Verify file checksum
fn verify_file(path: String, expected: UInt32, algorithm: ChecksumAlgorithm) -> Result<Bool, ChecksumError> {
    let computed = match algorithm {
        Crc32 => crc32_file(path)?
        Adler32 => adler32_file(path)?
    }
    Ok(computed == expected)
}

enum ChecksumAlgorithm {
    Crc32
    Adler32
}

// =============================================================================
// Errors
// =============================================================================

enum ChecksumError {
    IoError(String)
    InvalidInput(String)
}

impl Display for ChecksumError {
    fn fmt(f: Formatter) {
        match self {
            IoError(s) => f.write(format!("I/O error: {}", s))
            InvalidInput(s) => f.write(format!("Invalid input: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "crc32 empty" {
    assert_eq(crc32([]), 0x00000000)?
}

test "crc32 hello" {
    let checksum = crc32_string("hello")
    assert_eq(checksum, 0x3610a686)?
}

test "crc32 incremental" {
    var crc = Crc32.new()
    crc.update_str("hel")
    crc.update_str("lo")
    assert_eq(crc.finalize(), crc32_string("hello"))?
}

test "adler32" {
    let checksum = adler32_string("Wikipedia")
    assert_eq(checksum, 0x11E60398)?
}

test "fletcher16" {
    let data = [0x01u8, 0x02]
    let checksum = fletcher16(data)
    assert(checksum != 0)?
}

test "internet checksum" {
    let data = [0x00u8, 0x01, 0xf2, 0x03, 0xf4, 0xf5, 0xf6, 0xf7]
    let checksum = internet_checksum(data)
    assert(checksum != 0)?
}

test "luhn valid" {
    assert(luhn_valid("79927398713"))?
    assert(!luhn_valid("79927398710"))?
}

test "luhn generate" {
    let full = luhn_generate("7992739871")
    assert(luhn_valid(full))?
}

test "isbn10 valid" {
    assert(isbn10_valid("0-306-40615-2"))?
    assert(isbn10_valid("0306406152"))?
}

test "isbn13 valid" {
    assert(isbn13_valid("978-0-306-40615-7"))?
}

test "issn valid" {
    assert(issn_valid("0378-5955"))?
}

test "xor checksum" {
    assert_eq(xor_checksum([0x01, 0x02, 0x03]), 0x00)?
    assert_eq(xor_checksum([0xFF, 0x00]), 0xFF)?
}

test "sum8" {
    assert_eq(sum8([0x01, 0x02, 0x03]), 0x06)?
}

test "checksum actor" {
    var actor = ChecksumActor.new()
    actor.update("hello".as_bytes())
    let result = actor.get_all()
    assert_eq(result.bytes, 5)?
}

test "crc32c" {
    let checksum = crc32c("hello".as_bytes())
    assert(checksum != 0)?
}
