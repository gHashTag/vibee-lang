// =============================================================================
// Vibee OS â€” Prometheus Module
// Prometheus metrics collection and exposition
// =============================================================================

// -----------------------------------------------------------------------------
// Metric Types
// -----------------------------------------------------------------------------

/// Counter - monotonically increasing value
actor Counter {
    state name: String
    state help: String
    state labels: Map<String, String>
    state value: Float
    
    fn new(name: String, help: String) -> Self {
        Counter { name: name, help: help, labels: Map.empty(), value: 0.0 }
    }
    
    fn with_labels(labels: Map<String, String>) -> Self {
        Counter { name: self.name, help: self.help, labels: labels, value: 0.0 }
    }
    
    on inc() { self.value += 1.0 }
    on inc_by(v: Float) { if v >= 0.0 { self.value += v } }
    fn get() -> Float { self.value }
    
    fn collect() -> MetricFamily {
        MetricFamily {
            name: self.name,
            help: self.help,
            type_: MetricType.Counter,
            metrics: [Metric { labels: self.labels.clone(), value: self.value, timestamp: None }]
        }
    }
}

/// Gauge - value that can go up and down
actor Gauge {
    state name: String
    state help: String
    state labels: Map<String, String>
    state value: Float
    
    fn new(name: String, help: String) -> Self {
        Gauge { name: name, help: help, labels: Map.empty(), value: 0.0 }
    }
    
    fn with_labels(labels: Map<String, String>) -> Self {
        Gauge { name: self.name, help: self.help, labels: labels, value: 0.0 }
    }
    
    on inc() { self.value += 1.0 }
    on dec() { self.value -= 1.0 }
    on add(v: Float) { self.value += v }
    on sub(v: Float) { self.value -= v }
    on set(v: Float) { self.value = v }
    fn get() -> Float { self.value }
    
    /// Set to current Unix timestamp
    on set_to_current_time() { self.value = Instant.now().as_secs_f64() }
    
    /// Track in-progress operations
    fn track_inprogress<T>(f: fn() -> T) -> T {
        self.inc()
        defer { self.dec() }
        f()
    }
    
    fn collect() -> MetricFamily {
        MetricFamily {
            name: self.name,
            help: self.help,
            type_: MetricType.Gauge,
            metrics: [Metric { labels: self.labels.clone(), value: self.value, timestamp: None }]
        }
    }
}

/// Histogram - samples observations and counts them in buckets
actor Histogram {
    state name: String
    state help: String
    state labels: Map<String, String>
    state buckets: [Float]
    state bucket_counts: [Int]
    state sum: Float
    state count: Int
    
    fn new(name: String, help: String) -> Self {
        Self.with_buckets(name, help, DEFAULT_BUCKETS)
    }
    
    fn with_buckets(name: String, help: String, buckets: [Float]) -> Self {
        let sorted = buckets.sorted()
        Histogram {
            name: name,
            help: help,
            labels: Map.empty(),
            buckets: sorted,
            bucket_counts: [0].repeat(sorted.len()),
            sum: 0.0,
            count: 0
        }
    }
    
    fn with_labels(labels: Map<String, String>) -> Self {
        Histogram {
            name: self.name,
            help: self.help,
            labels: labels,
            buckets: self.buckets.clone(),
            bucket_counts: [0].repeat(self.buckets.len()),
            sum: 0.0,
            count: 0
        }
    }
    
    /// Linear buckets: start, width, count
    fn linear_buckets(start: Float, width: Float, count: Int) -> [Float] {
        (0..count).map(|i| start + width * i as Float).collect()
    }
    
    /// Exponential buckets: start, factor, count
    fn exponential_buckets(start: Float, factor: Float, count: Int) -> [Float] {
        (0..count).map(|i| start * factor.pow(i as Float)).collect()
    }
    
    on observe(v: Float) {
        self.sum += v
        self.count += 1
        for (i, bound) in self.buckets.enumerate() {
            if v <= bound {
                self.bucket_counts[i] += 1
            }
        }
    }
    
    /// Time a function and observe duration
    fn time<T>(f: fn() -> T) -> T {
        let start = Instant.now()
        let result = f()
        self.observe(start.elapsed().as_secs_f64())
        result
    }
    
    fn collect() -> MetricFamily {
        var metrics = []
        var cumulative = 0
        
        for (i, bound) in self.buckets.enumerate() {
            cumulative += self.bucket_counts[i]
            var labels = self.labels.clone()
            labels.set("le", bound.to_string())
            metrics.push(Metric { labels: labels, value: cumulative as Float, timestamp: None })
        }
        
        // +Inf bucket
        var inf_labels = self.labels.clone()
        inf_labels.set("le", "+Inf")
        metrics.push(Metric { labels: inf_labels, value: self.count as Float, timestamp: None })
        
        MetricFamily {
            name: self.name,
            help: self.help,
            type_: MetricType.Histogram,
            metrics: metrics
        }
    }
}

/// Summary - similar to histogram but calculates quantiles
actor Summary {
    state name: String
    state help: String
    state labels: Map<String, String>
    state quantiles: [(Float, Float)]  // (quantile, error)
    state observations: [Float]
    state sum: Float
    state count: Int
    state max_age_seconds: Int
    state age_buckets: Int
    
    fn new(name: String, help: String) -> Self {
        Summary {
            name: name,
            help: help,
            labels: Map.empty(),
            quantiles: [(0.5, 0.05), (0.9, 0.01), (0.99, 0.001)],
            observations: [],
            sum: 0.0,
            count: 0,
            max_age_seconds: 600,
            age_buckets: 5
        }
    }
    
    fn with_quantiles(quantiles: [(Float, Float)]) -> Self {
        Summary { ...self, quantiles: quantiles }
    }
    
    fn with_labels(labels: Map<String, String>) -> Self {
        Summary { ...self, labels: labels, observations: [], sum: 0.0, count: 0 }
    }
    
    on observe(v: Float) {
        self.observations.push(v)
        self.sum += v
        self.count += 1
    }
    
    fn time<T>(f: fn() -> T) -> T {
        let start = Instant.now()
        let result = f()
        self.observe(start.elapsed().as_secs_f64())
        result
    }
    
    fn collect() -> MetricFamily {
        let sorted = self.observations.sorted()
        var metrics = []
        
        for (q, _) in self.quantiles {
            let idx = ((sorted.len() as Float - 1.0) * q).round() as Int
            let value = if sorted.is_empty() { 0.0 } else { sorted[idx.clamp(0, sorted.len() - 1)] }
            var labels = self.labels.clone()
            labels.set("quantile", q.to_string())
            metrics.push(Metric { labels: labels, value: value, timestamp: None })
        }
        
        MetricFamily {
            name: self.name,
            help: self.help,
            type_: MetricType.Summary,
            metrics: metrics
        }
    }
}

// Default histogram buckets
const DEFAULT_BUCKETS: [Float] = [0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]

// -----------------------------------------------------------------------------
// Metric Registry
// -----------------------------------------------------------------------------

/// Registry for collecting and exposing metrics
actor Registry {
    state counters: Map<String, Counter>
    state gauges: Map<String, Gauge>
    state histograms: Map<String, Histogram>
    state summaries: Map<String, Summary>
    state collectors: [fn() -> [MetricFamily]]
    
    fn new() -> Self {
        Registry {
            counters: Map.empty(),
            gauges: Map.empty(),
            histograms: Map.empty(),
            summaries: Map.empty(),
            collectors: []
        }
    }
    
    on register_counter(counter: Counter) {
        self.counters.set(counter.name, counter)
    }
    
    on register_gauge(gauge: Gauge) {
        self.gauges.set(gauge.name, gauge)
    }
    
    on register_histogram(histogram: Histogram) {
        self.histograms.set(histogram.name, histogram)
    }
    
    on register_summary(summary: Summary) {
        self.summaries.set(summary.name, summary)
    }
    
    on register_collector(collector: fn() -> [MetricFamily]) {
        self.collectors.push(collector)
    }
    
    fn counter(name: String) -> Option<Counter> {
        self.counters.get(name)
    }
    
    fn gauge(name: String) -> Option<Gauge> {
        self.gauges.get(name)
    }
    
    fn histogram(name: String) -> Option<Histogram> {
        self.histograms.get(name)
    }
    
    fn summary(name: String) -> Option<Summary> {
        self.summaries.get(name)
    }
    
    /// Collect all metrics
    fn gather() -> [MetricFamily] {
        var families = []
        
        for (_, counter) in self.counters {
            families.push(counter.collect())
        }
        for (_, gauge) in self.gauges {
            families.push(gauge.collect())
        }
        for (_, histogram) in self.histograms {
            families.push(histogram.collect())
        }
        for (_, summary) in self.summaries {
            families.push(summary.collect())
        }
        for collector in self.collectors {
            families.extend(collector())
        }
        
        families
    }
    
    /// Encode metrics in Prometheus text format
    fn encode() -> String {
        var output = StringBuilder.new()
        
        for family in self.gather() {
            output.append("# HELP \(family.name) \(family.help)\n")
            output.append("# TYPE \(family.name) \(family.type_.to_string())\n")
            
            for metric in family.metrics {
                let labels_str = if metric.labels.is_empty() {
                    ""
                } else {
                    let pairs = metric.labels.iter()
                        .map(|(k, v)| "\(k)=\"\(escape_label_value(v))\"")
                        .join(",")
                    "{\(pairs)}"
                }
                
                let timestamp_str = match metric.timestamp {
                    Some(ts) => " \(ts)",
                    None => ""
                }
                
                output.append("\(family.name)\(labels_str) \(metric.value)\(timestamp_str)\n")
            }
        }
        
        output.build()
    }
}

fn escape_label_value(s: String) -> String {
    s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n")
}

// Global default registry
var DEFAULT_REGISTRY = Registry.new()

// -----------------------------------------------------------------------------
// Metric Types
// -----------------------------------------------------------------------------

enum MetricType {
    Counter
    Gauge
    Histogram
    Summary
    Untyped
    
    fn to_string() -> String {
        match self {
            .Counter => "counter",
            .Gauge => "gauge",
            .Histogram => "histogram",
            .Summary => "summary",
            .Untyped => "untyped"
        }
    }
}

struct MetricFamily {
    name: String
    help: String
    type_: MetricType
    metrics: [Metric]
}

struct Metric {
    labels: Map<String, String>
    value: Float
    timestamp: Option<Int64>
}

// -----------------------------------------------------------------------------
// HTTP Handler
// -----------------------------------------------------------------------------

/// Create HTTP handler for metrics endpoint
fn http_handler(registry: Registry = DEFAULT_REGISTRY) -> fn(Request) -> Response {
    |req| {
        let metrics = registry.encode()
        Response.ok()
            .header("Content-Type", "text/plain; version=0.0.4; charset=utf-8")
            .body(metrics.as_bytes())
    }
}

/// Start metrics server
fn serve(addr: String, registry: Registry = DEFAULT_REGISTRY) -> Result<(), HttpError> {
    Server.new(addr)?
        .get("/metrics", http_handler(registry))
        .run()
}

// -----------------------------------------------------------------------------
// Push Gateway
// -----------------------------------------------------------------------------

/// Push metrics to Prometheus Pushgateway
actor PushGateway {
    state url: String
    state job: String
    state instance: Option<String>
    state grouping: Map<String, String>
    
    fn new(url: String, job: String) -> Self {
        PushGateway {
            url: url,
            job: job,
            instance: None,
            grouping: Map.empty()
        }
    }
    
    on instance(inst: String) -> Self { self.instance = Some(inst); self }
    on grouping(key: String, value: String) -> Self { self.grouping.set(key, value); self }
    
    fn build_url() -> String {
        var path = "\(self.url)/metrics/job/\(url_encode(self.job))"
        
        if let inst = self.instance {
            path += "/instance/\(url_encode(inst))"
        }
        
        for (k, v) in self.grouping {
            path += "/\(url_encode(k))/\(url_encode(v))"
        }
        
        path
    }
    
    /// Push metrics (replace all metrics for this job)
    on push(registry: Registry = DEFAULT_REGISTRY) -> Result<(), PushError> {
        let body = registry.encode()
        let response = Client.new()
            .send(Request.put(self.build_url())
                .header("Content-Type", "text/plain")
                .body(body.as_bytes()))?
        
        if !response.is_success() {
            return Err(PushError.HttpError(response.status.code, response.text()))
        }
        Ok(())
    }
    
    /// Add metrics (merge with existing)
    on add(registry: Registry = DEFAULT_REGISTRY) -> Result<(), PushError> {
        let body = registry.encode()
        let response = Client.new()
            .send(Request.post(self.build_url())
                .header("Content-Type", "text/plain")
                .body(body.as_bytes()))?
        
        if !response.is_success() {
            return Err(PushError.HttpError(response.status.code, response.text()))
        }
        Ok(())
    }
    
    /// Delete metrics for this job
    on delete() -> Result<(), PushError> {
        let response = Client.new().delete(self.build_url())?
        if !response.is_success() {
            return Err(PushError.HttpError(response.status.code, response.text()))
        }
        Ok(())
    }
}

enum PushError {
    HttpError(Int, String)
    NetworkError(String)
}

fn url_encode(s: String) -> String {
    @native("url_encode", s)
}

// -----------------------------------------------------------------------------
// Built-in Collectors
// -----------------------------------------------------------------------------

/// Process metrics collector
fn process_collector() -> [MetricFamily] {
    let stats = @native("process_stats") as ProcessStats
    
    [
        MetricFamily {
            name: "process_cpu_seconds_total",
            help: "Total user and system CPU time spent in seconds",
            type_: MetricType.Counter,
            metrics: [Metric { labels: Map.empty(), value: stats.cpu_seconds, timestamp: None }]
        },
        MetricFamily {
            name: "process_resident_memory_bytes",
            help: "Resident memory size in bytes",
            type_: MetricType.Gauge,
            metrics: [Metric { labels: Map.empty(), value: stats.resident_memory as Float, timestamp: None }]
        },
        MetricFamily {
            name: "process_virtual_memory_bytes",
            help: "Virtual memory size in bytes",
            type_: MetricType.Gauge,
            metrics: [Metric { labels: Map.empty(), value: stats.virtual_memory as Float, timestamp: None }]
        },
        MetricFamily {
            name: "process_open_fds",
            help: "Number of open file descriptors",
            type_: MetricType.Gauge,
            metrics: [Metric { labels: Map.empty(), value: stats.open_fds as Float, timestamp: None }]
        },
        MetricFamily {
            name: "process_start_time_seconds",
            help: "Start time of the process since unix epoch in seconds",
            type_: MetricType.Gauge,
            metrics: [Metric { labels: Map.empty(), value: stats.start_time, timestamp: None }]
        }
    ]
}

struct ProcessStats {
    cpu_seconds: Float
    resident_memory: Int
    virtual_memory: Int
    open_fds: Int
    start_time: Float
}

/// Go-style runtime metrics collector
fn runtime_collector() -> [MetricFamily] {
    let stats = @native("runtime_stats") as RuntimeStats
    
    [
        MetricFamily {
            name: "vibee_goroutines",
            help: "Number of active actors/goroutines",
            type_: MetricType.Gauge,
            metrics: [Metric { labels: Map.empty(), value: stats.actors as Float, timestamp: None }]
        },
        MetricFamily {
            name: "vibee_gc_duration_seconds",
            help: "GC pause duration",
            type_: MetricType.Summary,
            metrics: [Metric { labels: Map.empty(), value: stats.gc_pause_seconds, timestamp: None }]
        },
        MetricFamily {
            name: "vibee_heap_bytes",
            help: "Heap memory in bytes",
            type_: MetricType.Gauge,
            metrics: [Metric { labels: Map.empty(), value: stats.heap_bytes as Float, timestamp: None }]
        }
    ]
}

struct RuntimeStats {
    actors: Int
    gc_pause_seconds: Float
    heap_bytes: Int
}

// -----------------------------------------------------------------------------
// Convenience Macros
// -----------------------------------------------------------------------------

/// Create and register a counter
macro counter!(name, help, registry = DEFAULT_REGISTRY) {
    let c = Counter.new(name, help)
    registry.register_counter(c)
    c
}

/// Create and register a gauge
macro gauge!(name, help, registry = DEFAULT_REGISTRY) {
    let g = Gauge.new(name, help)
    registry.register_gauge(g)
    g
}

/// Create and register a histogram
macro histogram!(name, help, buckets = DEFAULT_BUCKETS, registry = DEFAULT_REGISTRY) {
    let h = Histogram.with_buckets(name, help, buckets)
    registry.register_histogram(h)
    h
}

/// Create and register a summary
macro summary!(name, help, registry = DEFAULT_REGISTRY) {
    let s = Summary.new(name, help)
    registry.register_summary(s)
    s
}

/// Time a block and observe in histogram
macro time!(histogram, block) {
    let start = Instant.now()
    let result = block
    histogram.observe(start.elapsed().as_secs_f64())
    result
}

// -----------------------------------------------------------------------------
// Labels Builder
// -----------------------------------------------------------------------------

struct Labels {
    inner: Map<String, String>
    
    fn new() -> Self { Labels { inner: Map.empty() } }
    
    fn add(key: String, value: String) -> Self {
        self.inner.set(key, value)
        self
    }
    
    fn build() -> Map<String, String> { self.inner }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "counter increment" {
    let counter = Counter.new("test_counter", "A test counter")
    counter.inc()
    counter.inc_by(5.0)
    assert_eq(counter.get(), 6.0)?
}

test "gauge operations" {
    let gauge = Gauge.new("test_gauge", "A test gauge")
    gauge.set(10.0)
    gauge.inc()
    gauge.dec()
    gauge.add(5.0)
    assert_eq(gauge.get(), 15.0)?
}

test "histogram observe" {
    let histogram = Histogram.new("test_histogram", "A test histogram")
    histogram.observe(0.1)
    histogram.observe(0.5)
    histogram.observe(1.0)
    
    let family = histogram.collect()
    assert_eq(family.type_, MetricType.Histogram)?
}

test "registry encode" {
    let registry = Registry.new()
    let counter = Counter.new("http_requests_total", "Total HTTP requests")
    counter.inc()
    registry.register_counter(counter)
    
    let output = registry.encode()
    assert(output.contains("# HELP http_requests_total"))?
    assert(output.contains("# TYPE http_requests_total counter"))?
    assert(output.contains("http_requests_total 1"))?
}

test "labels builder" {
    let labels = Labels.new()
        .add("method", "GET")
        .add("path", "/api")
        .build()
    
    assert_eq(labels.get("method"), Some("GET"))?
    assert_eq(labels.get("path"), Some("/api"))?
}
