// =============================================================================
// Vibee OS — Table Module
// Terminal table rendering
// =============================================================================

use terminal::{Style, Terminal}

// -----------------------------------------------------------------------------
// Table Styles
// -----------------------------------------------------------------------------

/// Table border style
enum BorderStyle {
    None
    Ascii
    Single
    Double
    Rounded
    Heavy
    
    fn chars() -> BorderChars {
        match self {
            .None => BorderChars.none()
            .Ascii => BorderChars.ascii()
            .Single => BorderChars.single()
            .Double => BorderChars.double()
            .Rounded => BorderChars.rounded()
            .Heavy => BorderChars.heavy()
        }
    }
}

/// Border characters
struct BorderChars {
    top_left: String
    top_right: String
    bottom_left: String
    bottom_right: String
    horizontal: String
    vertical: String
    cross: String
    top_cross: String
    bottom_cross: String
    left_cross: String
    right_cross: String
    
    fn none() -> Self {
        BorderChars {
            top_left: "", top_right: "", bottom_left: "", bottom_right: "",
            horizontal: "", vertical: "", cross: "",
            top_cross: "", bottom_cross: "", left_cross: "", right_cross: ""
        }
    }
    
    fn ascii() -> Self {
        BorderChars {
            top_left: "+", top_right: "+", bottom_left: "+", bottom_right: "+",
            horizontal: "-", vertical: "|", cross: "+",
            top_cross: "+", bottom_cross: "+", left_cross: "+", right_cross: "+"
        }
    }
    
    fn single() -> Self {
        BorderChars {
            top_left: "┌", top_right: "┐", bottom_left: "└", bottom_right: "┘",
            horizontal: "─", vertical: "│", cross: "┼",
            top_cross: "┬", bottom_cross: "┴", left_cross: "├", right_cross: "┤"
        }
    }
    
    fn double() -> Self {
        BorderChars {
            top_left: "╔", top_right: "╗", bottom_left: "╚", bottom_right: "╝",
            horizontal: "═", vertical: "║", cross: "╬",
            top_cross: "╦", bottom_cross: "╩", left_cross: "╠", right_cross: "╣"
        }
    }
    
    fn rounded() -> Self {
        BorderChars {
            top_left: "╭", top_right: "╮", bottom_left: "╰", bottom_right: "╯",
            horizontal: "─", vertical: "│", cross: "┼",
            top_cross: "┬", bottom_cross: "┴", left_cross: "├", right_cross: "┤"
        }
    }
    
    fn heavy() -> Self {
        BorderChars {
            top_left: "┏", top_right: "┓", bottom_left: "┗", bottom_right: "┛",
            horizontal: "━", vertical: "┃", cross: "╋",
            top_cross: "┳", bottom_cross: "┻", left_cross: "┣", right_cross: "┫"
        }
    }
}

/// Column alignment
enum Alignment {
    Left
    Center
    Right
}

// -----------------------------------------------------------------------------
// Column Definition
// -----------------------------------------------------------------------------

/// Table column
struct Column {
    header: String
    width: Option<Int>
    min_width: Int
    max_width: Int
    alignment: Alignment
    style: Option<fn(String) -> String>
    
    fn new(header: String) -> Self {
        Column {
            header: header,
            width: None,
            min_width: 1,
            max_width: 100,
            alignment: Alignment.Left,
            style: None
        }
    }
    
    fn width(w: Int) -> Self { self.width = Some(w); self }
    fn min_width(w: Int) -> Self { self.min_width = w; self }
    fn max_width(w: Int) -> Self { self.max_width = w; self }
    fn align(a: Alignment) -> Self { self.alignment = a; self }
    fn left() -> Self { self.align(Alignment.Left) }
    fn center() -> Self { self.align(Alignment.Center) }
    fn right() -> Self { self.align(Alignment.Right) }
    fn style(f: fn(String) -> String) -> Self { self.style = Some(f); self }
}

// -----------------------------------------------------------------------------
// Table
// -----------------------------------------------------------------------------

/// Table builder and renderer
actor Table {
    state columns: [Column]
    state rows: [[String]]
    state border_style: BorderStyle
    state header_style: Option<fn(String) -> String>
    state row_styles: [fn(String) -> String]
    state padding: Int
    state show_header: Bool
    state max_width: Option<Int>
    
    init() {
        self.columns = []
        self.rows = []
        self.border_style = BorderStyle.Single
        self.header_style = None
        self.row_styles = []
        self.padding = 1
        self.show_header = true
        self.max_width = None
    }
    
    /// Add column
    on column(col: Column) -> Self {
        self.columns.push(col)
        self
    }
    
    /// Add column with just header
    on add_column(header: String) -> Self {
        self.column(Column.new(header))
    }
    
    /// Set columns from headers
    on headers(headers: [String]) -> Self {
        self.columns = headers.iter().map(|h| Column.new(h)).collect()
        self
    }
    
    /// Add row
    on row(cells: [String]) -> Self {
        self.rows.push(cells)
        self
    }
    
    /// Add multiple rows
    on rows(rows: [[String]]) -> Self {
        self.rows.extend(rows)
        self
    }
    
    /// Set border style
    on border(style: BorderStyle) -> Self {
        self.border_style = style
        self
    }
    
    /// Set header style
    on header_style(f: fn(String) -> String) -> Self {
        self.header_style = Some(f)
        self
    }
    
    /// Set padding
    on padding(p: Int) -> Self {
        self.padding = p
        self
    }
    
    /// Hide header
    on hide_header() -> Self {
        self.show_header = false
        self
    }
    
    /// Set max width
    on max_width(w: Int) -> Self {
        self.max_width = Some(w)
        self
    }
    
    /// Calculate column widths
    fn calculate_widths() -> [Int] {
        var widths = self.columns.iter().map(|c| c.header.len()).collect()
        
        for row in self.rows.iter() {
            for (i, cell) in row.iter().enumerate() {
                if i < widths.len() {
                    widths[i] = widths[i].max(cell.len())
                }
            }
        }
        
        // Apply column constraints
        for (i, col) in self.columns.iter().enumerate() {
            if let Some(w) = col.width {
                widths[i] = w
            } else {
                widths[i] = widths[i].clamp(col.min_width, col.max_width)
            }
        }
        
        // Apply max width constraint
        if let Some(max) = self.max_width {
            let total = widths.iter().sum() + (widths.len() - 1) * (self.padding * 2 + 1)
            if total > max {
                let scale = max as Float64 / total as Float64
                widths = widths.iter().map(|w| (w as Float64 * scale) as Int).collect()
            }
        }
        
        widths
    }
    
    /// Align text in cell
    fn align_cell(text: String, width: Int, alignment: Alignment) -> String {
        let text_len = text.len()
        if text_len >= width { return text[0..width].to_string() }
        
        let padding = width - text_len
        match alignment {
            Alignment.Left => format!("{}{}", text, " ".repeat(padding))
            Alignment.Right => format!("{}{}", " ".repeat(padding), text)
            Alignment.Center => {
                let left = padding / 2
                let right = padding - left
                format!("{}{}{}", " ".repeat(left), text, " ".repeat(right))
            }
        }
    }
    
    /// Render horizontal line
    fn render_line(widths: [Int], left: String, mid: String, right: String, fill: String) -> String {
        var line = left
        for (i, w) in widths.iter().enumerate() {
            line.push_str(fill.repeat(w + self.padding * 2))
            if i < widths.len() - 1 {
                line.push_str(mid)
            }
        }
        line.push_str(right)
        line
    }
    
    /// Render row
    fn render_row(cells: [String], widths: [Int], style: Option<fn(String) -> String>) -> String {
        let chars = self.border_style.chars()
        let pad = " ".repeat(self.padding)
        
        var line = chars.vertical.clone()
        for (i, cell) in cells.iter().enumerate() {
            let width = widths.get(i).unwrap_or(10)
            let alignment = self.columns.get(i).map(|c| c.alignment).unwrap_or(Alignment.Left)
            let aligned = self.align_cell(cell.clone(), width, alignment)
            
            let styled = if let Some(s) = style {
                s(aligned)
            } else if let Some(col) = self.columns.get(i) {
                if let Some(cs) = col.style {
                    cs(aligned)
                } else { aligned }
            } else { aligned }
            
            line.push_str(format!("{}{}{}", pad, styled, pad))
            line.push_str(chars.vertical)
        }
        line
    }
    
    /// Render table to string
    on render() -> String {
        if self.columns.is_empty() && self.rows.is_empty() {
            return String.new()
        }
        
        let widths = self.calculate_widths()
        let chars = self.border_style.chars()
        var output = String.new()
        
        // Top border
        if self.border_style != BorderStyle.None {
            output.push_str(self.render_line(widths, chars.top_left, chars.top_cross, chars.top_right, chars.horizontal))
            output.push('\n')
        }
        
        // Header
        if self.show_header && !self.columns.is_empty() {
            let headers: [String] = self.columns.iter().map(|c| c.header.clone()).collect()
            let header_style = self.header_style.unwrap_or(|s| Style.new(s).bold().render())
            output.push_str(self.render_row(headers, widths, Some(header_style)))
            output.push('\n')
            
            // Header separator
            if self.border_style != BorderStyle.None {
                output.push_str(self.render_line(widths, chars.left_cross, chars.cross, chars.right_cross, chars.horizontal))
                output.push('\n')
            }
        }
        
        // Rows
        for (i, row) in self.rows.iter().enumerate() {
            let row_style = self.row_styles.get(i % self.row_styles.len())
            output.push_str(self.render_row(row.clone(), widths, row_style))
            output.push('\n')
        }
        
        // Bottom border
        if self.border_style != BorderStyle.None {
            output.push_str(self.render_line(widths, chars.bottom_left, chars.bottom_cross, chars.bottom_right, chars.horizontal))
        }
        
        output
    }
    
    /// Print table to stdout
    on print() {
        print!("{}", self.render())
    }
    
    /// Print table to stderr
    on eprint() {
        eprint!("{}", self.render())
    }
}

// -----------------------------------------------------------------------------
// Simple Table
// -----------------------------------------------------------------------------

/// Simple table without explicit columns
fn simple_table(headers: [String], rows: [[String]]) -> String {
    Table.new()
        .headers(headers)
        .rows(rows)
        .render()
}

/// Print simple table
fn print_table(headers: [String], rows: [[String]]) {
    print!("{}", simple_table(headers, rows))
}

// -----------------------------------------------------------------------------
// Key-Value Table
// -----------------------------------------------------------------------------

/// Key-value pair table
actor KeyValueTable {
    state pairs: [(String, String)]
    state key_style: Option<fn(String) -> String>
    state value_style: Option<fn(String) -> String>
    state separator: String
    state border: BorderStyle
    
    init() {
        self.pairs = []
        self.key_style = Some(|s| Style.new(s).bold().render())
        self.value_style = None
        self.separator = ":"
        self.border = BorderStyle.None
    }
    
    on add(key: String, value: String) -> Self {
        self.pairs.push((key, value))
        self
    }
    
    on separator(s: String) -> Self { self.separator = s; self }
    on border(b: BorderStyle) -> Self { self.border = b; self }
    on key_style(f: fn(String) -> String) -> Self { self.key_style = Some(f); self }
    on value_style(f: fn(String) -> String) -> Self { self.value_style = Some(f); self }
    
    on render() -> String {
        if self.border == BorderStyle.None {
            let max_key_len = self.pairs.iter().map(|(k, _)| k.len()).max().unwrap_or(0)
            var output = String.new()
            for (key, value) in self.pairs.iter() {
                let styled_key = self.key_style.map(|f| f(key.clone())).unwrap_or(key.clone())
                let styled_value = self.value_style.map(|f| f(value.clone())).unwrap_or(value.clone())
                let padding = " ".repeat(max_key_len - key.len())
                output.push_str(format!("{}{}{} {}\n", styled_key, padding, self.separator, styled_value))
            }
            output
        } else {
            let rows: [[String]] = self.pairs.iter().map(|(k, v)| [k.clone(), v.clone()]).collect()
            Table.new()
                .headers(["Key", "Value"])
                .rows(rows)
                .border(self.border)
                .hide_header()
                .render()
        }
    }
    
    on print() { print!("{}", self.render()) }
}

// -----------------------------------------------------------------------------
// Grid
// -----------------------------------------------------------------------------

/// Simple grid layout
actor Grid {
    state items: [String]
    state columns: Int
    state spacing: Int
    state item_width: Option<Int>
    
    init() {
        self.items = []
        self.columns = 4
        self.spacing = 2
        self.item_width = None
    }
    
    on add(item: String) -> Self { self.items.push(item); self }
    on items(items: [String]) -> Self { self.items.extend(items); self }
    on columns(n: Int) -> Self { self.columns = n; self }
    on spacing(s: Int) -> Self { self.spacing = s; self }
    on item_width(w: Int) -> Self { self.item_width = Some(w); self }
    
    on render() -> String {
        let width = self.item_width.unwrap_or_else(|| {
            self.items.iter().map(|i| i.len()).max().unwrap_or(10)
        })
        
        var output = String.new()
        for (i, item) in self.items.iter().enumerate() {
            let padded = if item.len() < width {
                format!("{}{}", item, " ".repeat(width - item.len()))
            } else { item[0..width].to_string() }
            
            output.push_str(padded)
            
            if (i + 1) % self.columns == 0 {
                output.push('\n')
            } else {
                output.push_str(" ".repeat(self.spacing))
            }
        }
        
        if self.items.len() % self.columns != 0 {
            output.push('\n')
        }
        
        output
    }
    
    on print() { print!("{}", self.render()) }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn table() -> Table { Table.new() }
fn column(header: String) -> Column { Column.new(header) }
fn kv_table() -> KeyValueTable { KeyValueTable.new() }
fn grid() -> Grid { Grid.new() }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "simple table" {
    let output = simple_table(
        ["Name", "Age"],
        [["Alice", "30"], ["Bob", "25"]]
    )
    assert(output.contains("Alice"))?
    assert(output.contains("30"))?
}

test "column alignment" {
    let col = Column.new("Test").right()
    assert_eq(col.alignment, Alignment.Right)?
}

test "border styles" {
    let single = BorderStyle.Single.chars()
    assert_eq(single.top_left, "┌")?
    
    let double = BorderStyle.Double.chars()
    assert_eq(double.top_left, "╔")?
}

test "key value table" {
    let kv = KeyValueTable.new()
        .add("Name", "Alice")
        .add("Age", "30")
    let output = kv.render()
    assert(output.contains("Name"))?
    assert(output.contains("Alice"))?
}

test "grid layout" {
    let g = Grid.new()
        .items(["a", "b", "c", "d", "e", "f"])
        .columns(3)
    let output = g.render()
    assert(output.lines().count() >= 2)?
}
