// =============================================================================
// Vibee OS â€” Markdown Module
// Markdown parsing and rendering
// =============================================================================

// -----------------------------------------------------------------------------
// Markdown Document
// -----------------------------------------------------------------------------

/// Markdown document
struct Document {
    blocks: [Block]
    
    fn parse(markdown: String) -> Result<Document, MarkdownError> {
        Parser.new(markdown).parse()
    }
    
    fn parse_file(path: String) -> Result<Document, MarkdownError> {
        let content = File.read_string(path)?
        Self.parse(content)
    }
    
    fn to_html() -> String { HTMLRenderer.new().render(self) }
    fn to_text() -> String { TextRenderer.new().render(self) }
}

// -----------------------------------------------------------------------------
// Block Elements
// -----------------------------------------------------------------------------

enum Block {
    Paragraph([Inline])
    Heading(Int, [Inline])
    CodeBlock(Option<String>, String)
    Blockquote([Block])
    List(ListType, [[Block]])
    ThematicBreak
    Table(TableData)
    HTML(String)
    
    fn to_html() -> String {
        match self {
            .Paragraph(inlines) => "<p>\(inlines.map(|i| i.to_html()).join(""))</p>"
            .Heading(level, inlines) => "<h\(level)>\(inlines.map(|i| i.to_html()).join(""))</h\(level)>"
            .CodeBlock(lang, code) => {
                let cls = lang.map(|l| " class=\"language-\(l)\"").unwrap_or("")
                "<pre><code\(cls)>\(escape_html(code))</code></pre>"
            }
            .Blockquote(blocks) => "<blockquote>\(blocks.map(|b| b.to_html()).join("\n"))</blockquote>"
            .List(list_type, items) => {
                let tag = match list_type { .Ordered(_) => "ol", .Unordered => "ul" }
                let lis = items.map(|item| "<li>\(item.map(|b| b.to_html()).join(""))</li>").join("\n")
                "<\(tag)>\(lis)</\(tag)>"
            }
            .ThematicBreak => "<hr>"
            .Table(data) => data.to_html()
            .HTML(html) => html
        }
    }
}

enum ListType {
    Ordered(Int)
    Unordered
}

struct TableData {
    headers: [[Inline]]
    alignments: [Alignment]
    rows: [[[Inline]]]
    
    fn to_html() -> String {
        var html = "<table>\n<thead>\n<tr>"
        for (i, header) in self.headers.enumerate() {
            let align = self.alignments.get(i).map(|a| " align=\"\(a.to_string())\"").unwrap_or("")
            html += "<th\(align)>\(header.map(|i| i.to_html()).join(""))</th>"
        }
        html += "</tr>\n</thead>\n<tbody>\n"
        for row in self.rows {
            html += "<tr>"
            for (i, cell) in row.enumerate() {
                let align = self.alignments.get(i).map(|a| " align=\"\(a.to_string())\"").unwrap_or("")
                html += "<td\(align)>\(cell.map(|i| i.to_html()).join(""))</td>"
            }
            html += "</tr>\n"
        }
        html += "</tbody>\n</table>"
        html
    }
}

enum Alignment { Left, Center, Right
    fn to_string() -> String { match self { .Left => "left", .Center => "center", .Right => "right" } }
}

// -----------------------------------------------------------------------------
// Inline Elements
// -----------------------------------------------------------------------------

enum Inline {
    Text(String)
    Code(String)
    Emphasis([Inline])
    Strong([Inline])
    Strikethrough([Inline])
    Link(String, Option<String>, [Inline])
    Image(String, Option<String>, String)
    LineBreak
    SoftBreak
    HTML(String)
    
    fn to_html() -> String {
        match self {
            .Text(t) => escape_html(t)
            .Code(c) => "<code>\(escape_html(c))</code>"
            .Emphasis(i) => "<em>\(i.map(|x| x.to_html()).join(""))</em>"
            .Strong(i) => "<strong>\(i.map(|x| x.to_html()).join(""))</strong>"
            .Strikethrough(i) => "<del>\(i.map(|x| x.to_html()).join(""))</del>"
            .Link(url, title, content) => {
                let t = title.map(|t| " title=\"\(escape_html(t))\"").unwrap_or("")
                "<a href=\"\(escape_html(url))\"\(t)>\(content.map(|i| i.to_html()).join(""))</a>"
            }
            .Image(url, title, alt) => {
                let t = title.map(|t| " title=\"\(escape_html(t))\"").unwrap_or("")
                "<img src=\"\(escape_html(url))\" alt=\"\(escape_html(alt))\"\(t)>"
            }
            .LineBreak => "<br>"
            .SoftBreak => "\n"
            .HTML(h) => h
        }
    }
    
    fn to_text() -> String {
        match self {
            .Text(t) => t
            .Code(c) => c
            .Emphasis(i) | .Strong(i) | .Strikethrough(i) => i.map(|x| x.to_text()).join("")
            .Link(_, _, content) => content.map(|i| i.to_text()).join("")
            .Image(_, _, alt) => alt
            .LineBreak | .SoftBreak => " "
            .HTML(_) => ""
        }
    }
}

// -----------------------------------------------------------------------------
// Parser
// -----------------------------------------------------------------------------

actor Parser {
    state input: String
    state pos: Int
    state lines: [String]
    state line_idx: Int
    
    fn new(input: String) -> Self {
        Parser { input: input, pos: 0, lines: input.lines().collect(), line_idx: 0 }
    }
    
    fn parse() -> Result<Document, MarkdownError> {
        var blocks = []
        while self.line_idx < self.lines.len() {
            if let Some(block) = self.parse_block()? { blocks.append(block) }
        }
        Ok(Document { blocks: blocks })
    }
    
    fn parse_block() -> Result<Option<Block>, MarkdownError> {
        self.skip_blank_lines()
        if self.line_idx >= self.lines.len() { return Ok(None) }
        
        let line = self.current_line()
        
        if line.starts_with("```") || line.starts_with("~~~") { return Ok(Some(self.parse_fenced_code()?)) }
        if line.starts_with("#") { return Ok(Some(self.parse_heading()?)) }
        if line.starts_with(">") { return Ok(Some(self.parse_blockquote()?)) }
        if self.is_thematic_break(line) { self.line_idx += 1; return Ok(Some(Block.ThematicBreak)) }
        if self.is_list_item(line) { return Ok(Some(self.parse_list()?)) }
        if line.starts_with("|") { return Ok(Some(self.parse_table()?)) }
        if line.starts_with("<") { return Ok(Some(self.parse_html_block()?)) }
        if line.starts_with("    ") || line.starts_with("\t") { return Ok(Some(self.parse_indented_code()?)) }
        
        Ok(Some(self.parse_paragraph()?))
    }
    
    fn parse_heading() -> Result<Block, MarkdownError> {
        let line = self.current_line()
        var level = 0
        while level < line.len() && line[level] == '#' { level += 1 }
        level = level.min(6)
        let content = line[level..].trim()
        let content = content.trim_end("#").trim()
        self.line_idx += 1
        Ok(Block.Heading(level, self.parse_inlines(content)))
    }
    
    fn parse_fenced_code() -> Result<Block, MarkdownError> {
        let line = self.current_line()
        let fence = if line.starts_with("```") { "```" } else { "~~~" }
        let lang = line[3..].trim()
        let lang = if lang.is_empty() { None } else { Some(lang) }
        self.line_idx += 1
        
        var code = []
        while self.line_idx < self.lines.len() {
            let l = self.current_line()
            if l.starts_with(fence) { self.line_idx += 1; break }
            code.append(l)
            self.line_idx += 1
        }
        Ok(Block.CodeBlock(lang, code.join("\n")))
    }
    
    fn parse_indented_code() -> Result<Block, MarkdownError> {
        var code = []
        while self.line_idx < self.lines.len() {
            let line = self.current_line()
            if line.starts_with("    ") { code.append(line[4..]); self.line_idx += 1 }
            else if line.starts_with("\t") { code.append(line[1..]); self.line_idx += 1 }
            else if line.trim().is_empty() { code.append(""); self.line_idx += 1 }
            else { break }
        }
        Ok(Block.CodeBlock(None, code.join("\n").trim_end("\n")))
    }
    
    fn parse_blockquote() -> Result<Block, MarkdownError> {
        var lines = []
        while self.line_idx < self.lines.len() {
            let line = self.current_line()
            if line.starts_with(">") {
                let content = if line.len() > 1 && line[1] == ' ' { line[2..] } else { line[1..] }
                lines.append(content)
                self.line_idx += 1
            } else if line.trim().is_empty() { break }
            else { break }
        }
        let inner = Parser.new(lines.join("\n")).parse()?
        Ok(Block.Blockquote(inner.blocks))
    }
    
    fn parse_list() -> Result<Block, MarkdownError> {
        let first_line = self.current_line()
        let list_type = self.detect_list_type(first_line)
        var items = []
        
        while self.line_idx < self.lines.len() {
            let line = self.current_line()
            if !self.is_list_item(line) && !line.trim().is_empty() { break }
            if line.trim().is_empty() { self.line_idx += 1; continue }
            
            let content = self.strip_list_marker(line)
            var item_lines = [content]
            self.line_idx += 1
            
            while self.line_idx < self.lines.len() {
                let l = self.current_line()
                if self.is_list_item(l) { break }
                if l.trim().is_empty() { break }
                if l.starts_with("  ") || l.starts_with("\t") {
                    item_lines.append(l.trim())
                    self.line_idx += 1
                } else { break }
            }
            
            let item_doc = Parser.new(item_lines.join("\n")).parse()?
            items.append(item_doc.blocks)
        }
        Ok(Block.List(list_type, items))
    }
    
    fn parse_table() -> Result<Block, MarkdownError> {
        let header_line = self.current_line()
        self.line_idx += 1
        
        if self.line_idx >= self.lines.len() { return Err(MarkdownError.InvalidTable) }
        let sep_line = self.current_line()
        if !sep_line.contains("-") { return Err(MarkdownError.InvalidTable) }
        self.line_idx += 1
        
        let headers = self.parse_table_row(header_line)
        let alignments = self.parse_alignments(sep_line)
        var rows = []
        
        while self.line_idx < self.lines.len() {
            let line = self.current_line()
            if !line.starts_with("|") { break }
            rows.append(self.parse_table_row(line))
            self.line_idx += 1
        }
        
        Ok(Block.Table(TableData { headers: headers, alignments: alignments, rows: rows }))
    }
    
    fn parse_table_row(line: String) -> [[Inline]] {
        line.trim_start("|").trim_end("|").split("|").map(|cell| self.parse_inlines(cell.trim())).collect()
    }
    
    fn parse_alignments(line: String) -> [Alignment] {
        line.trim_start("|").trim_end("|").split("|").map(|cell| {
            let c = cell.trim()
            if c.starts_with(":") && c.ends_with(":") { Alignment.Center }
            else if c.ends_with(":") { Alignment.Right }
            else { Alignment.Left }
        }).collect()
    }
    
    fn parse_html_block() -> Result<Block, MarkdownError> {
        var html = []
        while self.line_idx < self.lines.len() {
            let line = self.current_line()
            html.append(line)
            self.line_idx += 1
            if line.trim().is_empty() { break }
        }
        Ok(Block.HTML(html.join("\n")))
    }
    
    fn parse_paragraph() -> Result<Block, MarkdownError> {
        var lines = []
        while self.line_idx < self.lines.len() {
            let line = self.current_line()
            if line.trim().is_empty() { break }
            if line.starts_with("#") || line.starts_with(">") || self.is_thematic_break(line) { break }
            lines.append(line)
            self.line_idx += 1
        }
        Ok(Block.Paragraph(self.parse_inlines(lines.join(" "))))
    }
    
    fn parse_inlines(text: String) -> [Inline] {
        InlineParser.new(text).parse()
    }
    
    fn current_line() -> String { self.lines[self.line_idx] }
    fn skip_blank_lines() { while self.line_idx < self.lines.len() && self.lines[self.line_idx].trim().is_empty() { self.line_idx += 1 } }
    fn is_thematic_break(line: String) -> Bool {
        let t = line.trim()
        (t.chars().all(|c| c == '-' || c == ' ') && t.replace(" ", "").len() >= 3) ||
        (t.chars().all(|c| c == '*' || c == ' ') && t.replace(" ", "").len() >= 3) ||
        (t.chars().all(|c| c == '_' || c == ' ') && t.replace(" ", "").len() >= 3)
    }
    fn is_list_item(line: String) -> Bool {
        let t = line.trim_start()
        t.starts_with("- ") || t.starts_with("* ") || t.starts_with("+ ") ||
        (t.len() >= 2 && t[0].is_digit() && (t[1] == '.' || t[1] == ')'))
    }
    fn detect_list_type(line: String) -> ListType {
        let t = line.trim_start()
        if t[0].is_digit() { ListType.Ordered(1) } else { ListType.Unordered }
    }
    fn strip_list_marker(line: String) -> String {
        let t = line.trim_start()
        if t.starts_with("- ") || t.starts_with("* ") || t.starts_with("+ ") { t[2..] }
        else {
            var i = 0
            while i < t.len() && t[i].is_digit() { i += 1 }
            if i < t.len() && (t[i] == '.' || t[i] == ')') { t[(i+1)..].trim_start() }
            else { t }
        }
    }
}

// -----------------------------------------------------------------------------
// Inline Parser
// -----------------------------------------------------------------------------

actor InlineParser {
    state input: String
    state pos: Int
    
    fn new(input: String) -> Self { InlineParser { input: input, pos: 0 } }
    
    fn parse() -> [Inline] {
        var result = []
        var text = StringBuilder.new()
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            match c {
                '`' => { self.flush_text(text, result); result.append(self.parse_code()); text = StringBuilder.new() }
                '*' | '_' => { self.flush_text(text, result); if let Some(i) = self.parse_emphasis() { result.append(i) } else { text.append(c); self.pos += 1 }; text = StringBuilder.new() }
                '~' if self.peek_str("~~") => { self.flush_text(text, result); result.append(self.parse_strikethrough()); text = StringBuilder.new() }
                '[' => { self.flush_text(text, result); result.append(self.parse_link()); text = StringBuilder.new() }
                '!' if self.peek_char_at(1) == Some('[') => { self.flush_text(text, result); result.append(self.parse_image()); text = StringBuilder.new() }
                '<' => { self.flush_text(text, result); result.append(self.parse_autolink()); text = StringBuilder.new() }
                '\\' if self.pos + 1 < self.input.len() => { self.pos += 1; text.append(self.input[self.pos]); self.pos += 1 }
                '\n' => { text.append(' '); self.pos += 1 }
                _ => { text.append(c); self.pos += 1 }
            }
        }
        self.flush_text(text, result)
        result
    }
    
    fn flush_text(text: StringBuilder, result: [Inline]) {
        let s = text.build()
        if !s.is_empty() { result.append(Inline.Text(s)) }
    }
    
    fn parse_code() -> Inline {
        let start = self.pos
        var backticks = 0
        while self.pos < self.input.len() && self.input[self.pos] == '`' { backticks += 1; self.pos += 1 }
        let code_start = self.pos
        while self.pos < self.input.len() {
            if self.input[self.pos..].starts_with("`".repeat(backticks)) {
                let code = self.input[code_start..self.pos].trim()
                self.pos += backticks
                return Inline.Code(code)
            }
            self.pos += 1
        }
        Inline.Text(self.input[start..self.pos])
    }
    
    fn parse_emphasis() -> Option<Inline> {
        let marker = self.input[self.pos]
        var count = 0
        while self.pos + count < self.input.len() && self.input[self.pos + count] == marker { count += 1 }
        if count > 2 { count = 2 }
        self.pos += count
        
        let start = self.pos
        var end = self.pos
        while end < self.input.len() {
            if self.input[end..].starts_with(marker.to_string().repeat(count)) {
                let content = self.input[start..end]
                self.pos = end + count
                let inlines = InlineParser.new(content).parse()
                return Some(if count == 2 { Inline.Strong(inlines) } else { Inline.Emphasis(inlines) })
            }
            end += 1
        }
        self.pos = start
        None
    }
    
    fn parse_strikethrough() -> Inline {
        self.pos += 2
        let start = self.pos
        while self.pos < self.input.len() {
            if self.peek_str("~~") {
                let content = self.input[start..self.pos]
                self.pos += 2
                return Inline.Strikethrough(InlineParser.new(content).parse())
            }
            self.pos += 1
        }
        Inline.Text("~~" + self.input[start..])
    }
    
    fn parse_link() -> Inline {
        self.pos += 1
        let text_start = self.pos
        var depth = 1
        while self.pos < self.input.len() && depth > 0 {
            if self.input[self.pos] == '[' { depth += 1 }
            if self.input[self.pos] == ']' { depth -= 1 }
            if depth > 0 { self.pos += 1 }
        }
        let text = self.input[text_start..self.pos]
        self.pos += 1
        
        if self.pos < self.input.len() && self.input[self.pos] == '(' {
            self.pos += 1
            let url_start = self.pos
            while self.pos < self.input.len() && self.input[self.pos] != ')' { self.pos += 1 }
            let url = self.input[url_start..self.pos]
            self.pos += 1
            Inline.Link(url, None, InlineParser.new(text).parse())
        } else {
            Inline.Text("[\(text)]")
        }
    }
    
    fn parse_image() -> Inline {
        self.pos += 2
        let alt_start = self.pos
        while self.pos < self.input.len() && self.input[self.pos] != ']' { self.pos += 1 }
        let alt = self.input[alt_start..self.pos]
        self.pos += 1
        
        if self.pos < self.input.len() && self.input[self.pos] == '(' {
            self.pos += 1
            let url_start = self.pos
            while self.pos < self.input.len() && self.input[self.pos] != ')' { self.pos += 1 }
            let url = self.input[url_start..self.pos]
            self.pos += 1
            Inline.Image(url, None, alt)
        } else {
            Inline.Text("![\(alt)]")
        }
    }
    
    fn parse_autolink() -> Inline {
        self.pos += 1
        let start = self.pos
        while self.pos < self.input.len() && self.input[self.pos] != '>' { self.pos += 1 }
        let content = self.input[start..self.pos]
        self.pos += 1
        if content.contains("@") { Inline.Link("mailto:\(content)", None, [Inline.Text(content)]) }
        else if content.starts_with("http") { Inline.Link(content, None, [Inline.Text(content)]) }
        else { Inline.Text("<\(content)>") }
    }
    
    fn peek_str(s: String) -> Bool { self.input[self.pos..].starts_with(s) }
    fn peek_char_at(offset: Int) -> Option<Char> {
        if self.pos + offset < self.input.len() { Some(self.input[self.pos + offset]) } else { None }
    }
}

// -----------------------------------------------------------------------------
// Renderers
// -----------------------------------------------------------------------------

actor HTMLRenderer {
    fn new() -> Self { HTMLRenderer {} }
    fn render(doc: Document) -> String { doc.blocks.map(|b| b.to_html()).join("\n") }
}

actor TextRenderer {
    fn new() -> Self { TextRenderer {} }
    fn render(doc: Document) -> String {
        doc.blocks.map(|b| match b {
            .Paragraph(i) => i.map(|x| x.to_text()).join("") + "\n"
            .Heading(_, i) => i.map(|x| x.to_text()).join("") + "\n"
            .CodeBlock(_, c) => c + "\n"
            _ => ""
        }).join("\n")
    }
}

fn escape_html(s: String) -> String {
    s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace("\"", "&quot;")
}

// -----------------------------------------------------------------------------
// Convenience & Errors
// -----------------------------------------------------------------------------

fn parse(md: String) -> Result<Document, MarkdownError> { Document.parse(md) }
fn to_html(md: String) -> Result<String, MarkdownError> { Ok(Document.parse(md)?.to_html()) }

enum MarkdownError { InvalidTable, IOError(String)
    fn message() -> String { match self { .InvalidTable => "Invalid table", .IOError(m) => m } }
}

test "parse heading" {
    let doc = parse("# Hello")?
    match doc.blocks[0] { .Heading(1, _) => assert(true), _ => assert(false) }
}

test "parse emphasis" {
    let html = to_html("*italic* and **bold**")?
    assert(html.contains("<em>italic</em>"))
    assert(html.contains("<strong>bold</strong>"))
}
