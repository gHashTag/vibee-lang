// =============================================================================
// Vibee OS â€” SMS Template Module
// SMS message templates with variable substitution and localization
// =============================================================================

use regex.{Regex}

// =============================================================================
// SMS Template
// =============================================================================

/// SMS message template
struct SmsTemplate {
    id: String
    name: String
    content: String
    variables: [TemplateVariable]
    locale: String
    category: Option<String>
    max_length: Int
    created_at: Instant
    updated_at: Instant
}

struct TemplateVariable {
    name: String
    description: Option<String>
    default_value: Option<String>
    required: Bool
    validator: Option<VariableValidator>
}

enum VariableValidator {
    Regex(String)
    MaxLength(Int)
    MinLength(Int)
    Numeric
    Alphanumeric
    Email
    Phone
    Custom(fn(String) -> Bool)
}

impl SmsTemplate {
    fn new(name: String) -> Self {
        SmsTemplate {
            id: UUID.v4(),
            name: name,
            content: "",
            variables: [],
            locale: "en",
            category: None,
            max_length: 160,
            created_at: Instant.now(),
            updated_at: Instant.now()
        }
    }
    
    fn content(text: String) -> Self { 
        self.content = text
        self.variables = self.extract_variables()
        self.updated_at = Instant.now()
        self 
    }
    
    fn locale(loc: String) -> Self { self.locale = loc; self }
    fn category(cat: String) -> Self { self.category = Some(cat); self }
    fn max_length(len: Int) -> Self { self.max_length = len; self }
    
    fn variable(name: String) -> Self {
        self.variables.push(TemplateVariable {
            name: name,
            description: None,
            default_value: None,
            required: true,
            validator: None
        })
        self
    }
    
    fn variable_with_default(name: String, default: String) -> Self {
        self.variables.push(TemplateVariable {
            name: name,
            description: None,
            default_value: Some(default),
            required: false,
            validator: None
        })
        self
    }
    
    fn optional_variable(name: String) -> Self {
        self.variables.push(TemplateVariable {
            name: name,
            description: None,
            default_value: None,
            required: false,
            validator: None
        })
        self
    }
    
    fn extract_variables() -> [TemplateVariable] {
        let pattern = Regex.new(r"\{(\w+)\}").unwrap()
        var vars = Vec.new()
        var seen = Set.new()
        
        for cap in pattern.captures_iter(self.content.as_str()) {
            let name = cap.get(1).unwrap().as_str().to_string()
            if !seen.contains(&name) {
                seen.insert(name.clone())
                vars.push(TemplateVariable {
                    name: name,
                    description: None,
                    default_value: None,
                    required: true,
                    validator: None
                })
            }
        }
        vars
    }
    
    fn render(values: Map<String, String>) -> Result<String, TemplateError> {
        self.validate_variables(values.clone())?
        
        var result = self.content.clone()
        
        for var in self.variables.iter() {
            let value = values.get(var.name.clone())
                .or(var.default_value.clone())
                .unwrap_or_default()
            
            // Validate value
            if let Some(ref validator) = var.validator {
                if !self.validate_value(value.clone(), validator) {
                    return Err(TemplateError.ValidationFailed(var.name.clone()))
                }
            }
            
            result = result.replace(format!("{{{}}}", var.name).as_str(), value.as_str())
        }
        
        // Check length
        if result.len() > self.max_length {
            return Err(TemplateError.MessageTooLong(result.len(), self.max_length))
        }
        
        Ok(result)
    }
    
    fn render_unchecked(values: Map<String, String>) -> String {
        var result = self.content.clone()
        for (key, value) in values.iter() {
            result = result.replace(format!("{{{}}}", key).as_str(), value.as_str())
        }
        result
    }
    
    fn validate_variables(values: Map<String, String>) -> Result<(), TemplateError> {
        for var in self.variables.iter() {
            if var.required && !values.contains_key(var.name.clone()) && var.default_value.is_none() {
                return Err(TemplateError.MissingVariable(var.name.clone()))
            }
        }
        Ok(())
    }
    
    fn validate_value(value: String, validator: &VariableValidator) -> Bool {
        match validator {
            VariableValidator.Regex(pattern) => {
                Regex.new(pattern).map(|r| r.is_match(value.as_str())).unwrap_or(false)
            }
            VariableValidator.MaxLength(max) => value.len() <= *max,
            VariableValidator.MinLength(min) => value.len() >= *min,
            VariableValidator.Numeric => value.chars().all(|c| c.is_digit(10)),
            VariableValidator.Alphanumeric => value.chars().all(|c| c.is_alphanumeric()),
            VariableValidator.Email => value.contains("@") && value.contains("."),
            VariableValidator.Phone => {
                let cleaned: String = value.chars().filter(|c| c.is_digit(10) || *c == '+').collect()
                cleaned.len() >= 10
            }
            VariableValidator.Custom(f) => f(value)
        }
    }
    
    fn preview(sample_values: Map<String, String>) -> String {
        self.render_unchecked(sample_values)
    }
    
    fn estimated_length(values: Map<String, String>) -> Int {
        self.render_unchecked(values).len()
    }
    
    fn segment_count(values: Map<String, String>) -> Int {
        let len = self.estimated_length(values)
        if len <= 160 { 1 } else { (len + 152) / 153 }
    }
    
    fn variable_names() -> [String] {
        self.variables.iter().map(|v| v.name.clone()).collect()
    }
    
    fn required_variables() -> [String] {
        self.variables.iter().filter(|v| v.required).map(|v| v.name.clone()).collect()
    }
}

// =============================================================================
// Template Engine
// =============================================================================

/// Template engine with caching and localization
struct TemplateEngine {
    templates: Map<String, SmsTemplate>
    localized_templates: Map<String, Map<String, SmsTemplate>>
    default_locale: String
    fallback_locale: Option<String>
}

impl TemplateEngine {
    fn new() -> Self {
        TemplateEngine {
            templates: Map.empty(),
            localized_templates: Map.empty(),
            default_locale: "en",
            fallback_locale: None
        }
    }
    
    fn default_locale(locale: String) -> Self { self.default_locale = locale; self }
    fn fallback_locale(locale: String) -> Self { self.fallback_locale = Some(locale); self }
    
    fn register(template: SmsTemplate) -> Self {
        let name = template.name.clone()
        let locale = template.locale.clone()
        
        // Store in main templates
        self.templates.set(name.clone(), template.clone())
        
        // Store in localized templates
        let locale_map = self.localized_templates.get(name.clone())
            .cloned()
            .unwrap_or(Map.empty())
        var locale_map = locale_map
        locale_map.set(locale, template)
        self.localized_templates.set(name, locale_map)
        
        self
    }
    
    fn register_localized(name: String, locale: String, content: String) -> Self {
        let template = SmsTemplate.new(name.clone()).content(content).locale(locale.clone())
        self.register(template)
    }
    
    fn get(name: String) -> Option<SmsTemplate> {
        self.templates.get(name).cloned()
    }
    
    fn get_localized(name: String, locale: String) -> Option<SmsTemplate> {
        // Try exact locale
        if let Some(locale_map) = self.localized_templates.get(name.clone()) {
            if let Some(template) = locale_map.get(locale.clone()) {
                return Some(template.clone())
            }
            
            // Try language only (e.g., "en" from "en-US")
            let lang = locale.split("-").next().unwrap_or(locale.as_str())
            if let Some(template) = locale_map.get(lang.to_string()) {
                return Some(template.clone())
            }
            
            // Try fallback locale
            if let Some(ref fallback) = self.fallback_locale {
                if let Some(template) = locale_map.get(fallback.clone()) {
                    return Some(template.clone())
                }
            }
            
            // Try default locale
            if let Some(template) = locale_map.get(self.default_locale.clone()) {
                return Some(template.clone())
            }
        }
        
        // Fall back to main template
        self.templates.get(name).cloned()
    }
    
    fn render(name: String, values: Map<String, String>) -> Result<String, TemplateError> {
        let template = self.get(name.clone()).ok_or(TemplateError.TemplateNotFound(name))?
        template.render(values)
    }
    
    fn render_localized(name: String, locale: String, values: Map<String, String>) -> Result<String, TemplateError> {
        let template = self.get_localized(name.clone(), locale)
            .ok_or(TemplateError.TemplateNotFound(name))?
        template.render(values)
    }
    
    fn list() -> [SmsTemplate] {
        self.templates.values().cloned().collect()
    }
    
    fn list_by_category(category: String) -> [SmsTemplate] {
        self.templates.values()
            .filter(|t| t.category == Some(category.clone()))
            .cloned()
            .collect()
    }
    
    fn remove(name: String) {
        self.templates.remove(name.clone())
        self.localized_templates.remove(name)
    }
}

// =============================================================================
// Template Builder
// =============================================================================

struct TemplateBuilder {
    template: SmsTemplate
}

impl TemplateBuilder {
    fn new(name: String) -> Self {
        TemplateBuilder { template: SmsTemplate.new(name) }
    }
    
    fn content(text: String) -> Self { self.template = self.template.content(text); self }
    fn locale(loc: String) -> Self { self.template = self.template.locale(loc); self }
    fn category(cat: String) -> Self { self.template = self.template.category(cat); self }
    fn max_length(len: Int) -> Self { self.template = self.template.max_length(len); self }
    
    fn var(name: String) -> Self { self.template = self.template.variable(name); self }
    fn var_default(name: String, default: String) -> Self { self.template = self.template.variable_with_default(name, default); self }
    fn var_optional(name: String) -> Self { self.template = self.template.optional_variable(name); self }
    
    fn var_validated(name: String, validator: VariableValidator) -> Self {
        self.template.variables.push(TemplateVariable {
            name: name,
            description: None,
            default_value: None,
            required: true,
            validator: Some(validator)
        })
        self
    }
    
    fn build() -> SmsTemplate { self.template.clone() }
}

// =============================================================================
// Common Templates
// =============================================================================

struct CommonTemplates;

impl CommonTemplates {
    fn verification_code() -> SmsTemplate {
        SmsTemplate.new("verification_code")
            .content("Your verification code is {code}. Valid for {expiry} minutes.")
            .category("verification")
    }
    
    fn welcome() -> SmsTemplate {
        SmsTemplate.new("welcome")
            .content("Welcome to {app_name}, {name}! Your account is ready.")
            .category("onboarding")
    }
    
    fn password_reset() -> SmsTemplate {
        SmsTemplate.new("password_reset")
            .content("Your password reset code is {code}. Do not share this code.")
            .category("security")
    }
    
    fn order_confirmation() -> SmsTemplate {
        SmsTemplate.new("order_confirmation")
            .content("Order #{order_id} confirmed! Total: {amount}. Track at {tracking_url}")
            .category("orders")
    }
    
    fn shipping_update() -> SmsTemplate {
        SmsTemplate.new("shipping_update")
            .content("Your order #{order_id} has shipped! Track: {tracking_url}")
            .category("orders")
    }
    
    fn appointment_reminder() -> SmsTemplate {
        SmsTemplate.new("appointment_reminder")
            .content("Reminder: Your appointment with {provider} is on {date} at {time}. Reply CONFIRM or CANCEL.")
            .category("appointments")
    }
    
    fn two_factor_auth() -> SmsTemplate {
        SmsTemplate.new("two_factor_auth")
            .content("{code} is your {app_name} authentication code. Never share this code.")
            .category("security")
    }
    
    fn payment_received() -> SmsTemplate {
        SmsTemplate.new("payment_received")
            .content("Payment of {amount} received. Thank you! Ref: {reference}")
            .category("payments")
    }
    
    fn low_balance_alert() -> SmsTemplate {
        SmsTemplate.new("low_balance_alert")
            .content("Alert: Your {account_type} balance is {balance}. Top up to avoid service interruption.")
            .category("alerts")
    }
    
    fn promotional() -> SmsTemplate {
        SmsTemplate.new("promotional")
            .content("{message} Use code {promo_code} for {discount}% off! Valid until {expiry}. Reply STOP to opt out.")
            .category("marketing")
            .max_length(320)
    }
}

// =============================================================================
// Template Store
// =============================================================================

trait TemplateStore {
    fn save(template: SmsTemplate) -> Result<(), TemplateError>
    fn get(id: String) -> Option<SmsTemplate>
    fn get_by_name(name: String) -> Option<SmsTemplate>
    fn list() -> [SmsTemplate]
    fn delete(id: String) -> Result<(), TemplateError>
}

struct InMemoryTemplateStore {
    templates: Map<String, SmsTemplate>
    by_name: Map<String, String>
}

impl InMemoryTemplateStore {
    fn new() -> Self {
        InMemoryTemplateStore {
            templates: Map.empty(),
            by_name: Map.empty()
        }
    }
}

impl TemplateStore for InMemoryTemplateStore {
    fn save(template: SmsTemplate) -> Result<(), TemplateError> {
        let id = template.id.clone()
        let name = template.name.clone()
        self.templates.set(id.clone(), template)
        self.by_name.set(name, id)
        Ok(())
    }
    
    fn get(id: String) -> Option<SmsTemplate> {
        self.templates.get(id).cloned()
    }
    
    fn get_by_name(name: String) -> Option<SmsTemplate> {
        self.by_name.get(name).and_then(|id| self.templates.get(id.clone())).cloned()
    }
    
    fn list() -> [SmsTemplate] {
        self.templates.values().cloned().collect()
    }
    
    fn delete(id: String) -> Result<(), TemplateError> {
        if let Some(template) = self.templates.get(id.clone()) {
            self.by_name.remove(template.name.clone())
        }
        self.templates.remove(id)
        Ok(())
    }
}

// =============================================================================
// Template Validator
// =============================================================================

struct TemplateValidator {
    max_length: Int
    allowed_variables: Option<Set<String>>
    forbidden_patterns: [Regex]
}

impl TemplateValidator {
    fn new() -> Self {
        TemplateValidator {
            max_length: 1600,
            allowed_variables: None,
            forbidden_patterns: []
        }
    }
    
    fn max_length(len: Int) -> Self { self.max_length = len; self }
    fn allowed_variables(vars: [String]) -> Self { self.allowed_variables = Some(vars.into_iter().collect()); self }
    fn forbid_pattern(pattern: String) -> Self {
        if let Ok(regex) = Regex.new(pattern.as_str()) {
            self.forbidden_patterns.push(regex)
        }
        self
    }
    
    fn validate(template: &SmsTemplate) -> Result<(), TemplateError> {
        // Check max length
        if template.content.len() > self.max_length {
            return Err(TemplateError.MessageTooLong(template.content.len(), self.max_length))
        }
        
        // Check allowed variables
        if let Some(ref allowed) = self.allowed_variables {
            for var in template.variables.iter() {
                if !allowed.contains(&var.name) {
                    return Err(TemplateError.InvalidVariable(var.name.clone()))
                }
            }
        }
        
        // Check forbidden patterns
        for pattern in self.forbidden_patterns.iter() {
            if pattern.is_match(template.content.as_str()) {
                return Err(TemplateError.ForbiddenContent)
            }
        }
        
        Ok(())
    }
}

// =============================================================================
// Errors
// =============================================================================

enum TemplateError {
    TemplateNotFound(String)
    MissingVariable(String)
    InvalidVariable(String)
    ValidationFailed(String)
    MessageTooLong(Int, Int)
    ForbiddenContent
    ParseError(String)
}

impl Display for TemplateError {
    fn fmt(f: Formatter) {
        match self {
            TemplateNotFound(name) => f.write(format!("Template not found: {}", name)),
            MissingVariable(name) => f.write(format!("Missing required variable: {}", name)),
            InvalidVariable(name) => f.write(format!("Invalid variable: {}", name)),
            ValidationFailed(name) => f.write(format!("Validation failed for variable: {}", name)),
            MessageTooLong(actual, max) => f.write(format!("Message too long: {} chars (max {})", actual, max)),
            ForbiddenContent => f.write("Template contains forbidden content"),
            ParseError(msg) => f.write(format!("Parse error: {}", msg))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "template creation" {
    let template = SmsTemplate.new("test")
        .content("Hello {name}, your code is {code}")
    
    assert_eq(template.name, "test")?
    assert_eq(template.variables.len(), 2)?
}

test "template rendering" {
    let template = SmsTemplate.new("test")
        .content("Hello {name}!")
    
    var values = Map.empty()
    values.set("name", "World")
    
    let result = template.render(values)?
    assert_eq(result, "Hello World!")?
}

test "template with default values" {
    let template = SmsTemplate.new("test")
        .content("Hello {name}!")
        .variable_with_default("name", "Guest")
    
    let result = template.render(Map.empty())?
    assert_eq(result, "Hello Guest!")?
}

test "missing required variable" {
    let template = SmsTemplate.new("test")
        .content("Hello {name}!")
    
    let result = template.render(Map.empty())
    assert(result.is_err())?
}

test "template engine" {
    let mut engine = TemplateEngine.new()
        .register(SmsTemplate.new("greeting").content("Hello {name}!").locale("en"))
        .register(SmsTemplate.new("greeting").content("Hola {name}!").locale("es"))
    
    var values = Map.empty()
    values.set("name", "World")
    
    let en = engine.render_localized("greeting", "en", values.clone())?
    assert_eq(en, "Hello World!")?
    
    let es = engine.render_localized("greeting", "es", values)?
    assert_eq(es, "Hola World!")?
}

test "template builder" {
    let template = TemplateBuilder.new("otp")
        .content("Your code: {code}")
        .category("verification")
        .max_length(160)
        .var("code")
        .build()
    
    assert_eq(template.name, "otp")?
    assert_eq(template.category, Some("verification"))?
}

test "common templates" {
    let verification = CommonTemplates.verification_code()
    assert_eq(verification.name, "verification_code")?
    assert(verification.content.contains("{code}"))?
    
    let welcome = CommonTemplates.welcome()
    assert(welcome.content.contains("{name}"))?
}

test "segment count" {
    let short_template = SmsTemplate.new("short").content("Hello {name}!")
    var values = Map.empty()
    values.set("name", "World")
    assert_eq(short_template.segment_count(values), 1)?
    
    let long_template = SmsTemplate.new("long").content("A".repeat(200))
    assert_eq(long_template.segment_count(Map.empty()), 2)?
}

test "variable extraction" {
    let template = SmsTemplate.new("test")
        .content("Hello {first_name} {last_name}, your order #{order_id} is ready!")
    
    let vars = template.variable_names()
    assert_eq(vars.len(), 3)?
    assert(vars.contains(&"first_name"))?
    assert(vars.contains(&"last_name"))?
    assert(vars.contains(&"order_id"))?
}

test "template validator" {
    let validator = TemplateValidator.new()
        .max_length(160)
        .allowed_variables(["name", "code"])
    
    let valid = SmsTemplate.new("test").content("Hello {name}!")
    assert(validator.validate(&valid).is_ok())?
    
    let invalid = SmsTemplate.new("test").content("Hello {invalid_var}!")
    assert(validator.validate(&invalid).is_err())?
}
