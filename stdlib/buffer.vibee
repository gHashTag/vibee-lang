// =============================================================================
// Vibee OS â€” Buffer Module
// Buffer utilities
// =============================================================================

/// Byte buffer
struct Buffer {
    data: [UInt8]
    pos: Int
    
    fn new() -> Self { Buffer { data: [], pos: 0 } }
    fn with_capacity(cap: Int) -> Self { Buffer { data: Vec.with_capacity(cap), pos: 0 } }
    fn from(data: [UInt8]) -> Self { Buffer { data: data, pos: 0 } }
    fn from_string(s: String) -> Self { Self.from(s.as_bytes()) }
    
    fn len() -> Int { self.data.len() }
    fn capacity() -> Int { self.data.capacity() }
    fn is_empty() -> Bool { self.data.is_empty() }
    fn remaining() -> Int { self.data.len() - self.pos }
    fn position() -> Int { self.pos }
    fn set_position(pos: Int) { self.pos = pos.clamp(0, self.data.len()) }
    fn rewind() { self.pos = 0 }
    fn clear() { self.data.clear(); self.pos = 0 }
    fn as_bytes() -> [UInt8] { self.data.clone() }
    fn as_str() -> Result<String, Utf8Error> { String.from_utf8(self.data.clone()) }
    
    // Write operations
    fn write_u8(v: UInt8) { self.data.push(v) }
    fn write_i8(v: Int8) { self.data.push(v as UInt8) }
    fn write_u16_be(v: UInt16) { self.data.push((v >> 8) as UInt8); self.data.push(v as UInt8) }
    fn write_u16_le(v: UInt16) { self.data.push(v as UInt8); self.data.push((v >> 8) as UInt8) }
    fn write_u32_be(v: UInt32) { for i in (0..4).rev() { self.data.push((v >> (i * 8)) as UInt8) } }
    fn write_u32_le(v: UInt32) { for i in 0..4 { self.data.push((v >> (i * 8)) as UInt8) } }
    fn write_u64_be(v: UInt64) { for i in (0..8).rev() { self.data.push((v >> (i * 8)) as UInt8) } }
    fn write_u64_le(v: UInt64) { for i in 0..8 { self.data.push((v >> (i * 8)) as UInt8) } }
    fn write_i16_be(v: Int16) { self.write_u16_be(v as UInt16) }
    fn write_i16_le(v: Int16) { self.write_u16_le(v as UInt16) }
    fn write_i32_be(v: Int32) { self.write_u32_be(v as UInt32) }
    fn write_i32_le(v: Int32) { self.write_u32_le(v as UInt32) }
    fn write_i64_be(v: Int64) { self.write_u64_be(v as UInt64) }
    fn write_i64_le(v: Int64) { self.write_u64_le(v as UInt64) }
    fn write_f32_be(v: Float32) { self.write_u32_be(v.to_bits()) }
    fn write_f32_le(v: Float32) { self.write_u32_le(v.to_bits()) }
    fn write_f64_be(v: Float64) { self.write_u64_be(v.to_bits()) }
    fn write_f64_le(v: Float64) { self.write_u64_le(v.to_bits()) }
    fn write_bytes(data: [UInt8]) { self.data.extend(data) }
    fn write_string(s: String) { self.data.extend(s.as_bytes()) }
    fn write_cstring(s: String) { self.write_string(s); self.write_u8(0) }
    fn write_length_prefixed(data: [UInt8]) { self.write_u32_be(data.len() as UInt32); self.write_bytes(data) }
    
    // Read operations
    fn read_u8() -> Option<UInt8> { if self.pos >= self.data.len() { None } else { let v = self.data[self.pos]; self.pos += 1; Some(v) } }
    fn read_i8() -> Option<Int8> { self.read_u8().map(|v| v as Int8) }
    fn read_u16_be() -> Option<UInt16> { if self.remaining() < 2 { return None } let v = (self.data[self.pos] as UInt16) << 8 | self.data[self.pos + 1] as UInt16; self.pos += 2; Some(v) }
    fn read_u16_le() -> Option<UInt16> { if self.remaining() < 2 { return None } let v = self.data[self.pos] as UInt16 | (self.data[self.pos + 1] as UInt16) << 8; self.pos += 2; Some(v) }
    fn read_u32_be() -> Option<UInt32> { if self.remaining() < 4 { return None } var v: UInt32 = 0; for i in 0..4 { v = (v << 8) | self.data[self.pos + i] as UInt32 } self.pos += 4; Some(v) }
    fn read_u32_le() -> Option<UInt32> { if self.remaining() < 4 { return None } var v: UInt32 = 0; for i in 0..4 { v |= (self.data[self.pos + i] as UInt32) << (i * 8) } self.pos += 4; Some(v) }
    fn read_u64_be() -> Option<UInt64> { if self.remaining() < 8 { return None } var v: UInt64 = 0; for i in 0..8 { v = (v << 8) | self.data[self.pos + i] as UInt64 } self.pos += 8; Some(v) }
    fn read_u64_le() -> Option<UInt64> { if self.remaining() < 8 { return None } var v: UInt64 = 0; for i in 0..8 { v |= (self.data[self.pos + i] as UInt64) << (i * 8) } self.pos += 8; Some(v) }
    fn read_i16_be() -> Option<Int16> { self.read_u16_be().map(|v| v as Int16) }
    fn read_i16_le() -> Option<Int16> { self.read_u16_le().map(|v| v as Int16) }
    fn read_i32_be() -> Option<Int32> { self.read_u32_be().map(|v| v as Int32) }
    fn read_i32_le() -> Option<Int32> { self.read_u32_le().map(|v| v as Int32) }
    fn read_i64_be() -> Option<Int64> { self.read_u64_be().map(|v| v as Int64) }
    fn read_i64_le() -> Option<Int64> { self.read_u64_le().map(|v| v as Int64) }
    fn read_f32_be() -> Option<Float32> { self.read_u32_be().map(|v| Float32.from_bits(v)) }
    fn read_f32_le() -> Option<Float32> { self.read_u32_le().map(|v| Float32.from_bits(v)) }
    fn read_f64_be() -> Option<Float64> { self.read_u64_be().map(|v| Float64.from_bits(v)) }
    fn read_f64_le() -> Option<Float64> { self.read_u64_le().map(|v| Float64.from_bits(v)) }
    fn read_bytes(n: Int) -> Option<[UInt8]> { if self.remaining() < n { return None } let v = self.data[self.pos..(self.pos + n)].to_vec(); self.pos += n; Some(v) }
    fn read_string(n: Int) -> Option<String> { self.read_bytes(n).and_then(|b| String.from_utf8(b).ok()) }
    fn read_cstring() -> Option<String> { let start = self.pos; while self.pos < self.data.len() && self.data[self.pos] != 0 { self.pos += 1 } if self.pos >= self.data.len() { return None } let s = String.from_utf8(self.data[start..self.pos].to_vec()).ok()?; self.pos += 1; Some(s) }
    fn read_length_prefixed() -> Option<[UInt8]> { let len = self.read_u32_be()? as Int; self.read_bytes(len) }
    fn read_remaining() -> [UInt8] { let v = self.data[self.pos..].to_vec(); self.pos = self.data.len(); v }
    fn peek_u8() -> Option<UInt8> { if self.pos >= self.data.len() { None } else { Some(self.data[self.pos]) } }
    fn skip(n: Int) { self.pos = (self.pos + n).min(self.data.len()) }
}

impl Read for Buffer { fn read(buf: [UInt8]) -> Result<Int, IoError> { let n = self.remaining().min(buf.len()); buf[0..n].copy_from(self.data[self.pos..(self.pos + n)]); self.pos += n; Ok(n) } }
impl Write for Buffer { fn write(data: [UInt8]) -> Result<Int, IoError> { self.data.extend(data); Ok(data.len()) } fn flush() -> Result<(), IoError> { Ok(()) } }

/// Growable byte buffer with chunks
struct ChunkedBuffer { chunks: [[UInt8]], chunk_size: Int, len: Int }
impl ChunkedBuffer {
    fn new() -> Self { Self.with_chunk_size(4096) }
    fn with_chunk_size(size: Int) -> Self { ChunkedBuffer { chunks: [], chunk_size: size, len: 0 } }
    fn len() -> Int { self.len }
    fn is_empty() -> Bool { self.len == 0 }
    fn write(data: [UInt8]) { for b in data { let chunk_idx = self.len / self.chunk_size; let offset = self.len % self.chunk_size; if chunk_idx >= self.chunks.len() { self.chunks.push([0u8; self.chunk_size]) } self.chunks[chunk_idx][offset] = b; self.len += 1 } }
    fn read(offset: Int, len: Int) -> [UInt8] { var result = []; for i in offset..(offset + len).min(self.len) { let chunk_idx = i / self.chunk_size; let off = i % self.chunk_size; result.push(self.chunks[chunk_idx][off]) } result }
    fn to_bytes() -> [UInt8] { self.read(0, self.len) }
    fn clear() { self.chunks.clear(); self.len = 0 }
}

/// Fixed-size buffer pool
actor BufferPool { state buffers: [[UInt8]], state size: Int, state buffer_size: Int }
impl BufferPool {
    fn new(pool_size: Int, buffer_size: Int) -> Self { BufferPool { buffers: (0..pool_size).map(|_| [0u8; buffer_size]).collect(), size: pool_size, buffer_size: buffer_size } }
    fn acquire() -> Option<[UInt8]> { self.buffers.pop() }
    fn release(buf: [UInt8]) { if self.buffers.len() < self.size { self.buffers.push(buf) } }
    fn available() -> Int { self.buffers.len() }
}

/// Slice view into buffer
struct BufferSlice<'a> { data: &'a [UInt8], start: Int, end: Int }
impl<'a> BufferSlice<'a> {
    fn new(data: &'a [UInt8]) -> Self { BufferSlice { data: data, start: 0, end: data.len() } }
    fn slice(start: Int, end: Int) -> Self { BufferSlice { data: self.data, start: self.start + start, end: (self.start + end).min(self.end) } }
    fn len() -> Int { self.end - self.start }
    fn get(i: Int) -> Option<UInt8> { if i < self.len() { Some(self.data[self.start + i]) } else { None } }
    fn to_vec() -> [UInt8] { self.data[self.start..self.end].to_vec() }
}

// Tests
test "write read" {
    var buf = Buffer.new()
    buf.write_u32_be(0x12345678)
    buf.write_string("hello")
    buf.rewind()
    assert_eq(buf.read_u32_be(), Some(0x12345678))?
    assert_eq(buf.read_string(5), Some("hello"))?
}

test "endianness" {
    var buf = Buffer.new()
    buf.write_u16_be(0x1234)
    buf.write_u16_le(0x1234)
    buf.rewind()
    assert_eq(buf.read_u8(), Some(0x12))?
    assert_eq(buf.read_u8(), Some(0x34))?
    assert_eq(buf.read_u8(), Some(0x34))?
    assert_eq(buf.read_u8(), Some(0x12))?
}

test "cstring" {
    var buf = Buffer.new()
    buf.write_cstring("hello")
    buf.write_cstring("world")
    buf.rewind()
    assert_eq(buf.read_cstring(), Some("hello"))?
    assert_eq(buf.read_cstring(), Some("world"))?
}
