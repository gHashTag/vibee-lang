// =============================================================================
// Vibee OS â€” Comment Module
// Comments, replies, and threaded discussions
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Comment Types
// =============================================================================

/// Comment target type
enum CommentTarget {
    Post(String),
    Article(String),
    Media(String),
    Comment(String),
    Product(String),
    Event(String)
}

impl CommentTarget {
    fn id() -> String {
        match self {
            CommentTarget.Post(id) => id,
            CommentTarget.Article(id) => id,
            CommentTarget.Media(id) => id,
            CommentTarget.Comment(id) => id,
            CommentTarget.Product(id) => id,
            CommentTarget.Event(id) => id
        }
    }
    
    fn type_name() -> String {
        match self {
            CommentTarget.Post(_) => "post",
            CommentTarget.Article(_) => "article",
            CommentTarget.Media(_) => "media",
            CommentTarget.Comment(_) => "comment",
            CommentTarget.Product(_) => "product",
            CommentTarget.Event(_) => "event"
        }
    }
}

/// Comment status
enum CommentStatus {
    Active,
    Hidden,
    Deleted,
    Flagged,
    PendingReview
}

impl CommentStatus {
    fn is_visible() -> Bool {
        match self {
            CommentStatus.Active => true,
            _ => false
        }
    }
    
    fn display_name() -> String {
        match self {
            CommentStatus.Active => "Active",
            CommentStatus.Hidden => "Hidden",
            CommentStatus.Deleted => "Deleted",
            CommentStatus.Flagged => "Flagged",
            CommentStatus.PendingReview => "Pending Review"
        }
    }
}

/// Comment sort order
enum CommentSort {
    Newest,
    Oldest,
    MostLiked,
    MostReplies,
    Relevance
}

// =============================================================================
// Comment Attachment
// =============================================================================

/// Comment attachment
struct CommentAttachment {
    id: String,
    attachment_type: CommentAttachmentType,
    url: String,
    thumbnail_url: Option<String>,
    metadata: Map<String, String>
}

/// Comment attachment type
enum CommentAttachmentType {
    Image,
    GIF,
    Sticker,
    Link,
    File
}

impl CommentAttachment {
    fn image(url: String) -> Self {
        CommentAttachment {
            id: generate_id(),
            attachment_type: CommentAttachmentType.Image,
            url: url,
            thumbnail_url: None,
            metadata: Map.empty()
        }
    }
    
    fn gif(url: String) -> Self {
        CommentAttachment {
            id: generate_id(),
            attachment_type: CommentAttachmentType.GIF,
            url: url,
            thumbnail_url: None,
            metadata: Map.empty()
        }
    }
    
    fn sticker(url: String) -> Self {
        CommentAttachment {
            id: generate_id(),
            attachment_type: CommentAttachmentType.Sticker,
            url: url,
            thumbnail_url: None,
            metadata: Map.empty()
        }
    }
    
    fn link(url: String, title: String) -> Self {
        var attachment = CommentAttachment {
            id: generate_id(),
            attachment_type: CommentAttachmentType.Link,
            url: url,
            thumbnail_url: None,
            metadata: Map.empty()
        }
        attachment.metadata.set("title", title)
        attachment
    }
}

// =============================================================================
// Comment Structure
// =============================================================================

/// Comment
struct Comment {
    id: String,
    target: CommentTarget,
    author_id: String,
    author_name: String,
    content: String,
    attachment: Option<CommentAttachment>,
    parent_id: Option<String>,
    root_id: Option<String>,
    depth: Int,
    status: CommentStatus,
    likes_count: Int64,
    replies_count: Int64,
    mentions: [String],
    is_pinned: Bool,
    is_author_reply: Bool,
    created_at: DateTime,
    updated_at: DateTime,
    edited_at: Option<DateTime>,
    metadata: Map<String, String>
}

impl Comment {
    fn new(target: CommentTarget, author_id: String, author_name: String, content: String) -> Self {
        let now = DateTime.now()
        Comment {
            id: generate_id(),
            target: target,
            author_id: author_id,
            author_name: author_name,
            content: content,
            attachment: None,
            parent_id: None,
            root_id: None,
            depth: 0,
            status: CommentStatus.Active,
            likes_count: 0,
            replies_count: 0,
            mentions: [],
            is_pinned: false,
            is_author_reply: false,
            created_at: now,
            updated_at: now,
            edited_at: None,
            metadata: Map.empty()
        }
    }
    
    fn reply(parent: Comment, author_id: String, author_name: String, content: String) -> Self {
        let now = DateTime.now()
        Comment {
            id: generate_id(),
            target: parent.target.clone(),
            author_id: author_id,
            author_name: author_name,
            content: content,
            attachment: None,
            parent_id: Some(parent.id.clone()),
            root_id: parent.root_id.clone().or(Some(parent.id.clone())),
            depth: parent.depth + 1,
            status: CommentStatus.Active,
            likes_count: 0,
            replies_count: 0,
            mentions: [],
            is_pinned: false,
            is_author_reply: false,
            created_at: now,
            updated_at: now,
            edited_at: None,
            metadata: Map.empty()
        }
    }
    
    fn with_attachment(attachment: CommentAttachment) -> Self {
        self.attachment = Some(attachment)
        self
    }
    
    fn with_mentions(mentions: [String]) -> Self {
        self.mentions = mentions
        self
    }
    
    fn mark_as_author_reply() -> Self {
        self.is_author_reply = true
        self
    }
    
    fn edit(new_content: String) {
        self.content = new_content
        self.edited_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
    }
    
    fn hide() {
        self.status = CommentStatus.Hidden
        self.updated_at = DateTime.now()
    }
    
    fn delete() {
        self.status = CommentStatus.Deleted
        self.content = "[deleted]"
        self.updated_at = DateTime.now()
    }
    
    fn flag() {
        self.status = CommentStatus.Flagged
        self.updated_at = DateTime.now()
    }
    
    fn pin() {
        self.is_pinned = true
        self.updated_at = DateTime.now()
    }
    
    fn unpin() {
        self.is_pinned = false
        self.updated_at = DateTime.now()
    }
    
    fn increment_likes() { self.likes_count += 1 }
    fn decrement_likes() { if self.likes_count > 0 { self.likes_count -= 1 } }
    fn increment_replies() { self.replies_count += 1 }
    fn decrement_replies() { if self.replies_count > 0 { self.replies_count -= 1 } }
    
    fn is_visible() -> Bool { self.status.is_visible() }
    fn is_reply() -> Bool { self.parent_id.is_some() }
    fn is_edited() -> Bool { self.edited_at.is_some() }
    fn has_attachment() -> Bool { self.attachment.is_some() }
    fn has_replies() -> Bool { self.replies_count > 0 }
    
    fn age() -> Duration { DateTime.now() - self.created_at }
    
    fn extract_mentions() -> [String] {
        let regex = Regex.new(r"@(\w+)")
        regex.find_all(self.content).map(|m| m.group(1)).collect()
    }
    
    fn truncated_content(max_length: Int) -> String {
        if self.content.len() <= max_length {
            self.content.clone()
        } else {
            format!("{}...", self.content.substring(0, max_length - 3))
        }
    }
}

// =============================================================================
// Comment Thread
// =============================================================================

/// Comment thread for nested discussions
struct CommentThread {
    root: Comment,
    replies: [CommentThread],
    total_count: Int,
    max_depth: Int
}

impl CommentThread {
    fn new(root: Comment) -> Self {
        CommentThread {
            root: root,
            replies: [],
            total_count: 1,
            max_depth: 0
        }
    }
    
    fn add_reply(reply: Comment) {
        self.replies.push(CommentThread.new(reply))
        self.total_count += 1
        self.root.increment_replies()
    }
    
    fn flatten() -> [Comment] {
        var result: [Comment] = [self.root.clone()]
        for thread in self.replies.iter() {
            result.extend(thread.flatten())
        }
        result
    }
    
    fn depth() -> Int {
        if self.replies.is_empty() {
            0
        } else {
            1 + self.replies.iter().map(|t| t.depth()).max().unwrap_or(0)
        }
    }
    
    fn sort_replies(order: CommentSort) {
        match order {
            CommentSort.Newest => {
                self.replies.sort_by(|a, b| b.root.created_at.cmp(a.root.created_at))
            },
            CommentSort.Oldest => {
                self.replies.sort_by(|a, b| a.root.created_at.cmp(b.root.created_at))
            },
            CommentSort.MostLiked => {
                self.replies.sort_by(|a, b| b.root.likes_count.cmp(a.root.likes_count))
            },
            CommentSort.MostReplies => {
                self.replies.sort_by(|a, b| b.total_count.cmp(a.total_count))
            },
            CommentSort.Relevance => {
                self.replies.sort_by(|a, b| {
                    let score_a = a.root.likes_count * 2 + a.total_count as Int64
                    let score_b = b.root.likes_count * 2 + b.total_count as Int64
                    score_b.cmp(score_a)
                })
            }
        }
        
        // Recursively sort nested replies
        for reply in self.replies.iter_mut() {
            reply.sort_replies(order.clone())
        }
    }
}

// =============================================================================
// Comment Service
// =============================================================================

/// Comment service actor
actor CommentService {
    state comments: Map<String, Comment>
    state target_comments: Map<String, [String]>
    state user_comments: Map<String, [String]>
    state parent_replies: Map<String, [String]>
    state pinned_comments: Map<String, String>
    
    fn new() -> Self {
        CommentService {
            comments: Map.empty(),
            target_comments: Map.empty(),
            user_comments: Map.empty(),
            parent_replies: Map.empty(),
            pinned_comments: Map.empty()
        }
    }
    
    /// Create a new comment
    on create(comment: Comment) -> Result<Comment, CommentError> {
        if comment.content.trim().is_empty() && comment.attachment.is_none() {
            return Err(CommentError.EmptyContent)
        }
        
        let comment_id = comment.id.clone()
        let target_id = comment.target.id()
        let author_id = comment.author_id.clone()
        
        self.comments.set(comment_id.clone(), comment.clone())
        self.target_comments.entry(target_id).or_insert([]).push(comment_id.clone())
        self.user_comments.entry(author_id).or_insert([]).push(comment_id.clone())
        
        // Track parent-child relationship
        if let Some(parent_id) = comment.parent_id.clone() {
            self.parent_replies.entry(parent_id.clone()).or_insert([]).push(comment_id.clone())
            
            // Increment parent's reply count
            if let Some(parent) = self.comments.get_mut(parent_id) {
                parent.increment_replies()
            }
        }
        
        Ok(comment)
    }
    
    /// Reply to a comment
    on reply(parent_id: String, author_id: String, author_name: String, content: String) -> Result<Comment, CommentError> {
        let parent = self.comments.get(parent_id.clone())
            .ok_or(CommentError.ParentNotFound)?
        
        let reply = Comment.reply(parent.clone(), author_id, author_name, content)
        self.create(reply)
    }
    
    /// Get comment by ID
    on get(comment_id: String) -> Option<Comment> {
        self.comments.get(comment_id)
    }
    
    /// Get comments for target
    on get_for_target(target_id: String, sort: CommentSort, limit: Int, offset: Int) -> [Comment] {
        var comments: [Comment] = self.target_comments.get(target_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.comments.get(id))
                    .filter(|c| c.is_visible() && c.parent_id.is_none())
                    .collect()
            })
            .unwrap_or([])
        
        // Sort comments
        match sort {
            CommentSort.Newest => {
                comments.sort_by(|a, b| b.created_at.cmp(a.created_at))
            },
            CommentSort.Oldest => {
                comments.sort_by(|a, b| a.created_at.cmp(b.created_at))
            },
            CommentSort.MostLiked => {
                comments.sort_by(|a, b| b.likes_count.cmp(a.likes_count))
            },
            CommentSort.MostReplies => {
                comments.sort_by(|a, b| b.replies_count.cmp(a.replies_count))
            },
            CommentSort.Relevance => {
                comments.sort_by(|a, b| {
                    let score_a = a.likes_count * 2 + a.replies_count as Int64
                    let score_b = b.likes_count * 2 + b.replies_count as Int64
                    score_b.cmp(score_a)
                })
            }
        }
        
        // Put pinned comment first
        if let Some(pinned_id) = self.pinned_comments.get(target_id) {
            if let Some(idx) = comments.iter().position(|c| c.id == *pinned_id) {
                let pinned = comments.remove(idx)
                comments.insert(0, pinned)
            }
        }
        
        comments.skip(offset).take(limit).collect()
    }
    
    /// Get replies to a comment
    on get_replies(parent_id: String, limit: Int, offset: Int) -> [Comment] {
        self.parent_replies.get(parent_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.comments.get(id))
                    .filter(|c| c.is_visible())
                    .skip(offset)
                    .take(limit)
                    .collect()
            })
            .unwrap_or([])
    }
    
    /// Get comment thread
    on get_thread(comment_id: String, max_depth: Int) -> Option<CommentThread> {
        let comment = self.comments.get(comment_id.clone())?
        var thread = CommentThread.new(comment.clone())
        
        if max_depth > 0 {
            let reply_ids = self.parent_replies.get(comment_id).unwrap_or([])
            for reply_id in reply_ids.iter() {
                if let Some(reply_thread) = self.get_thread(reply_id.clone(), max_depth - 1) {
                    thread.replies.push(reply_thread)
                    thread.total_count += 1
                }
            }
        }
        
        Some(thread)
    }
    
    /// Edit comment
    on edit(comment_id: String, user_id: String, new_content: String) -> Result<Comment, CommentError> {
        let comment = self.comments.get_mut(comment_id.clone())
            .ok_or(CommentError.NotFound)?
        
        if comment.author_id != user_id {
            return Err(CommentError.Unauthorized)
        }
        
        comment.edit(new_content)
        Ok(comment.clone())
    }
    
    /// Delete comment
    on delete(comment_id: String, user_id: String) -> Result<(), CommentError> {
        let comment = self.comments.get_mut(comment_id.clone())
            .ok_or(CommentError.NotFound)?
        
        if comment.author_id != user_id {
            return Err(CommentError.Unauthorized)
        }
        
        comment.delete()
        Ok(())
    }
    
    /// Pin comment
    on pin(target_id: String, comment_id: String) -> Result<(), CommentError> {
        let comment = self.comments.get_mut(comment_id.clone())
            .ok_or(CommentError.NotFound)?
        
        // Unpin previous
        if let Some(prev_id) = self.pinned_comments.get(target_id.clone()) {
            if let Some(prev) = self.comments.get_mut(prev_id.clone()) {
                prev.unpin()
            }
        }
        
        comment.pin()
        self.pinned_comments.set(target_id, comment_id)
        Ok(())
    }
    
    /// Unpin comment
    on unpin(target_id: String) -> Result<(), CommentError> {
        if let Some(comment_id) = self.pinned_comments.remove(target_id) {
            if let Some(comment) = self.comments.get_mut(comment_id) {
                comment.unpin()
            }
        }
        Ok(())
    }
    
    /// Like comment
    on like(comment_id: String) -> Result<(), CommentError> {
        let comment = self.comments.get_mut(comment_id)
            .ok_or(CommentError.NotFound)?
        comment.increment_likes()
        Ok(())
    }
    
    /// Unlike comment
    on unlike(comment_id: String) -> Result<(), CommentError> {
        let comment = self.comments.get_mut(comment_id)
            .ok_or(CommentError.NotFound)?
        comment.decrement_likes()
        Ok(())
    }
    
    /// Flag comment
    on flag(comment_id: String, reason: String) -> Result<(), CommentError> {
        let comment = self.comments.get_mut(comment_id)
            .ok_or(CommentError.NotFound)?
        comment.flag()
        comment.metadata.set("flag_reason", reason)
        Ok(())
    }
    
    /// Get comment count for target
    on get_count(target_id: String) -> Int64 {
        self.target_comments.get(target_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.comments.get(id))
                    .filter(|c| c.is_visible())
                    .count() as Int64
            })
            .unwrap_or(0)
    }
    
    /// Get user's comments
    on get_user_comments(user_id: String, limit: Int, offset: Int) -> [Comment] {
        self.user_comments.get(user_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.comments.get(id))
                    .filter(|c| c.is_visible())
                    .skip(offset)
                    .take(limit)
                    .collect()
            })
            .unwrap_or([])
    }
    
    /// Search comments
    on search(query: String, limit: Int) -> [Comment] {
        let query_lower = query.to_lowercase()
        self.comments.values()
            .filter(|c| c.is_visible() && c.content.to_lowercase().contains(query_lower.clone()))
            .take(limit)
            .collect()
    }
}

// =============================================================================
// Comment Errors
// =============================================================================

/// Comment errors
enum CommentError {
    NotFound,
    ParentNotFound,
    EmptyContent,
    Unauthorized,
    ContentTooLong,
    TooManyReplies,
    CommentingDisabled,
    RateLimited,
    Blocked
}

impl CommentError {
    fn message() -> String {
        match self {
            CommentError.NotFound => "Comment not found",
            CommentError.ParentNotFound => "Parent comment not found",
            CommentError.EmptyContent => "Comment cannot be empty",
            CommentError.Unauthorized => "Not authorized to perform this action",
            CommentError.ContentTooLong => "Comment exceeds maximum length",
            CommentError.TooManyReplies => "Maximum reply depth reached",
            CommentError.CommentingDisabled => "Commenting is disabled",
            CommentError.RateLimited => "Too many comments, please slow down",
            CommentError.Blocked => "You are blocked from commenting"
        }
    }
}

// =============================================================================
// Comment Events
// =============================================================================

/// Comment events for event sourcing
enum CommentEvent {
    Created { comment_id: String, target_id: String, author_id: String, timestamp: DateTime },
    Edited { comment_id: String, timestamp: DateTime },
    Deleted { comment_id: String, timestamp: DateTime },
    Liked { comment_id: String, user_id: String, timestamp: DateTime },
    Unliked { comment_id: String, user_id: String, timestamp: DateTime },
    Replied { comment_id: String, reply_id: String, author_id: String, timestamp: DateTime },
    Pinned { comment_id: String, target_id: String, timestamp: DateTime },
    Unpinned { comment_id: String, target_id: String, timestamp: DateTime },
    Flagged { comment_id: String, reason: String, timestamp: DateTime }
}

impl CommentEvent {
    fn timestamp() -> DateTime {
        match self {
            CommentEvent.Created { timestamp, .. } => timestamp,
            CommentEvent.Edited { timestamp, .. } => timestamp,
            CommentEvent.Deleted { timestamp, .. } => timestamp,
            CommentEvent.Liked { timestamp, .. } => timestamp,
            CommentEvent.Unliked { timestamp, .. } => timestamp,
            CommentEvent.Replied { timestamp, .. } => timestamp,
            CommentEvent.Pinned { timestamp, .. } => timestamp,
            CommentEvent.Unpinned { timestamp, .. } => timestamp,
            CommentEvent.Flagged { timestamp, .. } => timestamp
        }
    }
}

// =============================================================================
// Comment Moderation
// =============================================================================

/// Comment moderation settings
struct CommentModeration {
    enabled: Bool,
    require_approval: Bool,
    auto_hide_flagged: Bool,
    max_length: Int,
    max_depth: Int,
    blocked_words: [String],
    allowed_attachments: [CommentAttachmentType],
    rate_limit: Option<(Int, Duration)>
}

impl CommentModeration {
    fn default() -> Self {
        CommentModeration {
            enabled: true,
            require_approval: false,
            auto_hide_flagged: true,
            max_length: 2000,
            max_depth: 5,
            blocked_words: [],
            allowed_attachments: [
                CommentAttachmentType.Image,
                CommentAttachmentType.GIF,
                CommentAttachmentType.Sticker
            ],
            rate_limit: Some((10, Duration.minutes(1)))
        }
    }
    
    fn strict() -> Self {
        CommentModeration {
            enabled: true,
            require_approval: true,
            auto_hide_flagged: true,
            max_length: 500,
            max_depth: 3,
            blocked_words: [],
            allowed_attachments: [],
            rate_limit: Some((5, Duration.minutes(1)))
        }
    }
    
    fn validate(comment: Comment) -> Result<(), CommentError> {
        if !self.enabled {
            return Err(CommentError.CommentingDisabled)
        }
        
        if comment.content.len() > self.max_length {
            return Err(CommentError.ContentTooLong)
        }
        
        if comment.depth > self.max_depth {
            return Err(CommentError.TooManyReplies)
        }
        
        // Check blocked words
        let content_lower = comment.content.to_lowercase()
        for word in self.blocked_words.iter() {
            if content_lower.contains(word.to_lowercase()) {
                return Err(CommentError.Blocked)
            }
        }
        
        Ok(())
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn generate_id() -> String {
    @native("uuid_v4")
}

// =============================================================================
// Tests
// =============================================================================

test "comment creation" {
    let comment = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John Doe",
        "Great post!"
    )
    assert_eq(comment.author_id, "user1")?
    assert_eq(comment.content, "Great post!")?
    assert(!comment.is_reply())?
}

test "comment reply" {
    let parent = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John",
        "Original comment"
    )
    
    let reply = Comment.reply(parent.clone(), "user2", "Jane", "Thanks!")
    assert(reply.is_reply())?
    assert_eq(reply.parent_id, Some(parent.id))?
    assert_eq(reply.depth, 1)?
}

test "comment edit" {
    var comment = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John",
        "Original"
    )
    
    comment.edit("Edited content")
    assert_eq(comment.content, "Edited content")?
    assert(comment.is_edited())?
}

test "comment thread" {
    let root = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John",
        "Root comment"
    )
    
    var thread = CommentThread.new(root)
    
    let reply1 = Comment.new(
        CommentTarget.Post("post1"),
        "user2",
        "Jane",
        "Reply 1"
    )
    
    thread.add_reply(reply1)
    assert_eq(thread.total_count, 2)?
}

test "comment service" {
    let service = CommentService.new()
    
    let comment = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John",
        "Test comment"
    )
    
    service.create(comment.clone()).unwrap()
    
    let retrieved = service.get(comment.id.clone())
    assert(retrieved.is_some())?
    assert_eq(retrieved.unwrap().content, "Test comment")?
}

test "comment moderation" {
    let moderation = CommentModeration.default()
    
    let comment = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John",
        "Valid comment"
    )
    
    assert(moderation.validate(comment).is_ok())?
}

test "mention extraction" {
    let comment = Comment.new(
        CommentTarget.Post("post1"),
        "user1",
        "John",
        "Hey @jane and @bob!"
    )
    
    let mentions = comment.extract_mentions()
    assert_eq(mentions.len(), 2)?
    assert(mentions.contains("jane"))?
    assert(mentions.contains("bob"))?
}
