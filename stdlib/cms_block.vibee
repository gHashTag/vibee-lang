// =============================================================================
// Vibee OS â€” CMS Block Module
// Reusable content blocks for CMS
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Block Types
// =============================================================================

/// Block type
enum BlockType {
    Text,
    Html,
    Markdown,
    Image,
    Video,
    Gallery,
    Slider,
    Quote,
    Code,
    Table,
    Form,
    Map,
    Social,
    Widget,
    Custom(String)
}

impl BlockType {
    fn display_name() -> String {
        match self {
            BlockType.Text => "Text",
            BlockType.Html => "HTML",
            BlockType.Markdown => "Markdown",
            BlockType.Image => "Image",
            BlockType.Video => "Video",
            BlockType.Gallery => "Gallery",
            BlockType.Slider => "Slider",
            BlockType.Quote => "Quote",
            BlockType.Code => "Code",
            BlockType.Table => "Table",
            BlockType.Form => "Form",
            BlockType.Map => "Map",
            BlockType.Social => "Social",
            BlockType.Widget => "Widget",
            BlockType.Custom(name) => name
        }
    }
    
    fn icon() -> String {
        match self {
            BlockType.Text => "text",
            BlockType.Html => "code",
            BlockType.Markdown => "markdown",
            BlockType.Image => "image",
            BlockType.Video => "video",
            BlockType.Gallery => "images",
            BlockType.Slider => "slides",
            BlockType.Quote => "quote",
            BlockType.Code => "terminal",
            BlockType.Table => "table",
            BlockType.Form => "form",
            BlockType.Map => "map",
            BlockType.Social => "share",
            BlockType.Widget => "widget",
            BlockType.Custom(_) => "puzzle"
        }
    }
}

/// Block status
enum BlockStatus {
    Active,
    Inactive,
    Draft,
    Scheduled,
    Expired
}

impl BlockStatus {
    fn is_active() -> Bool {
        match self {
            BlockStatus.Active => true,
            _ => false
        }
    }
    
    fn display_name() -> String {
        match self {
            BlockStatus.Active => "Active",
            BlockStatus.Inactive => "Inactive",
            BlockStatus.Draft => "Draft",
            BlockStatus.Scheduled => "Scheduled",
            BlockStatus.Expired => "Expired"
        }
    }
}

/// Block position
enum BlockPosition {
    Header,
    Footer,
    Sidebar,
    Content,
    Modal,
    Banner,
    Custom(String)
}

impl BlockPosition {
    fn display_name() -> String {
        match self {
            BlockPosition.Header => "Header",
            BlockPosition.Footer => "Footer",
            BlockPosition.Sidebar => "Sidebar",
            BlockPosition.Content => "Content",
            BlockPosition.Modal => "Modal",
            BlockPosition.Banner => "Banner",
            BlockPosition.Custom(name) => name
        }
    }
}

// =============================================================================
// Block Content Types
// =============================================================================

/// Text block content
struct TextContent {
    text: String,
    format: String,
    alignment: String
}

impl TextContent {
    fn new(text: String) -> Self {
        TextContent {
            text: text,
            format: "plain",
            alignment: "left"
        }
    }
    
    fn html(text: String) -> Self {
        TextContent {
            text: text,
            format: "html",
            alignment: "left"
        }
    }
    
    fn markdown(text: String) -> Self {
        TextContent {
            text: text,
            format: "markdown",
            alignment: "left"
        }
    }
}

/// Image block content
struct ImageContent {
    url: String,
    alt: String,
    caption: Option<String>,
    width: Option<Int>,
    height: Option<Int>,
    link: Option<String>
}

impl ImageContent {
    fn new(url: String, alt: String) -> Self {
        ImageContent {
            url: url,
            alt: alt,
            caption: None,
            width: None,
            height: None,
            link: None
        }
    }
    
    fn with_caption(caption: String) -> Self {
        self.caption = Some(caption)
        self
    }
    
    fn with_dimensions(width: Int, height: Int) -> Self {
        self.width = Some(width)
        self.height = Some(height)
        self
    }
    
    fn with_link(link: String) -> Self {
        self.link = Some(link)
        self
    }
}

/// Video block content
struct VideoContent {
    url: String,
    provider: String,
    video_id: Option<String>,
    thumbnail: Option<String>,
    autoplay: Bool,
    loop_video: Bool,
    muted: Bool
}

impl VideoContent {
    fn youtube(video_id: String) -> Self {
        VideoContent {
            url: format!("https://www.youtube.com/embed/{}", video_id),
            provider: "youtube",
            video_id: Some(video_id),
            thumbnail: None,
            autoplay: false,
            loop_video: false,
            muted: false
        }
    }
    
    fn vimeo(video_id: String) -> Self {
        VideoContent {
            url: format!("https://player.vimeo.com/video/{}", video_id),
            provider: "vimeo",
            video_id: Some(video_id),
            thumbnail: None,
            autoplay: false,
            loop_video: false,
            muted: false
        }
    }
    
    fn custom(url: String) -> Self {
        VideoContent {
            url: url,
            provider: "custom",
            video_id: None,
            thumbnail: None,
            autoplay: false,
            loop_video: false,
            muted: false
        }
    }
}

/// Gallery block content
struct GalleryContent {
    images: [ImageContent],
    layout: String,
    columns: Int,
    lightbox: Bool
}

impl GalleryContent {
    fn new() -> Self {
        GalleryContent {
            images: [],
            layout: "grid",
            columns: 3,
            lightbox: true
        }
    }
    
    fn add_image(image: ImageContent) {
        self.images.push(image)
    }
    
    fn with_layout(layout: String) -> Self {
        self.layout = layout
        self
    }
    
    fn with_columns(columns: Int) -> Self {
        self.columns = columns
        self
    }
}

/// Quote block content
struct QuoteContent {
    text: String,
    author: Option<String>,
    source: Option<String>,
    style: String
}

impl QuoteContent {
    fn new(text: String) -> Self {
        QuoteContent {
            text: text,
            author: None,
            source: None,
            style: "default"
        }
    }
    
    fn with_author(author: String) -> Self {
        self.author = Some(author)
        self
    }
    
    fn with_source(source: String) -> Self {
        self.source = Some(source)
        self
    }
}

/// Code block content
struct CodeContent {
    code: String,
    language: String,
    filename: Option<String>,
    line_numbers: Bool,
    highlight_lines: [Int]
}

impl CodeContent {
    fn new(code: String, language: String) -> Self {
        CodeContent {
            code: code,
            language: language,
            filename: None,
            line_numbers: true,
            highlight_lines: []
        }
    }
    
    fn with_filename(filename: String) -> Self {
        self.filename = Some(filename)
        self
    }
    
    fn highlight(lines: [Int]) -> Self {
        self.highlight_lines = lines
        self
    }
}

/// Slider item
struct SliderItem {
    image: String,
    title: Option<String>,
    description: Option<String>,
    link: Option<String>,
    button_text: Option<String>
}

/// Slider block content
struct SliderContent {
    items: [SliderItem],
    autoplay: Bool,
    interval: Int,
    show_arrows: Bool,
    show_dots: Bool,
    transition: String
}

impl SliderContent {
    fn new() -> Self {
        SliderContent {
            items: [],
            autoplay: true,
            interval: 5000,
            show_arrows: true,
            show_dots: true,
            transition: "slide"
        }
    }
    
    fn add_item(item: SliderItem) {
        self.items.push(item)
    }
}

// =============================================================================
// Block Structure
// =============================================================================

/// CMS Block
struct Block {
    id: String,
    identifier: String,
    title: String,
    block_type: BlockType,
    content: String,
    status: BlockStatus,
    position: Option<BlockPosition>,
    store_ids: [String],
    css_class: Option<String>,
    custom_css: Option<String>,
    start_date: Option<DateTime>,
    end_date: Option<DateTime>,
    sort_order: Int,
    cache_lifetime: Option<Int>,
    created_at: DateTime,
    updated_at: DateTime,
    metadata: Map<String, String>
}

impl Block {
    fn new(identifier: String, title: String, block_type: BlockType) -> Self {
        let now = DateTime.now()
        Block {
            id: generate_id(),
            identifier: identifier,
            title: title,
            block_type: block_type,
            content: "",
            status: BlockStatus.Draft,
            position: None,
            store_ids: [],
            css_class: None,
            custom_css: None,
            start_date: None,
            end_date: None,
            sort_order: 0,
            cache_lifetime: None,
            created_at: now,
            updated_at: now,
            metadata: Map.empty()
        }
    }
    
    fn text(identifier: String, title: String, content: String) -> Self {
        var block = Block.new(identifier, title, BlockType.Text)
        block.content = content
        block
    }
    
    fn html(identifier: String, title: String, content: String) -> Self {
        var block = Block.new(identifier, title, BlockType.Html)
        block.content = content
        block
    }
    
    fn with_content(content: String) -> Self {
        self.content = content
        self.updated_at = DateTime.now()
        self
    }
    
    fn with_position(position: BlockPosition) -> Self {
        self.position = Some(position)
        self
    }
    
    fn with_css_class(css_class: String) -> Self {
        self.css_class = Some(css_class)
        self
    }
    
    fn with_custom_css(css: String) -> Self {
        self.custom_css = Some(css)
        self
    }
    
    fn with_schedule(start: DateTime, end: DateTime) -> Self {
        self.start_date = Some(start)
        self.end_date = Some(end)
        self
    }
    
    fn with_cache(lifetime: Int) -> Self {
        self.cache_lifetime = Some(lifetime)
        self
    }
    
    fn for_stores(store_ids: [String]) -> Self {
        self.store_ids = store_ids
        self
    }
    
    fn activate() {
        self.status = BlockStatus.Active
        self.updated_at = DateTime.now()
    }
    
    fn deactivate() {
        self.status = BlockStatus.Inactive
        self.updated_at = DateTime.now()
    }
    
    fn is_active() -> Bool {
        if !self.status.is_active() {
            return false
        }
        
        let now = DateTime.now()
        
        if let Some(start) = self.start_date {
            if now < start {
                return false
            }
        }
        
        if let Some(end) = self.end_date {
            if now > end {
                return false
            }
        }
        
        true
    }
    
    fn is_expired() -> Bool {
        if let Some(end) = self.end_date {
            return DateTime.now() > end
        }
        false
    }
    
    fn render() -> String {
        match self.block_type {
            BlockType.Html => self.content.clone(),
            BlockType.Markdown => markdown_to_html(self.content.clone()),
            BlockType.Text => format!("<p>{}</p>", escape_html(self.content.clone())),
            _ => self.content.clone()
        }
    }
    
    fn render_with_wrapper() -> String {
        let css = self.css_class.clone().unwrap_or("cms-block".to_string())
        let content = self.render()
        format!("<div class=\"{} block-{}\" id=\"block-{}\">{}</div>", 
            css, self.identifier, self.id, content)
    }
}

// =============================================================================
// Block Errors
// =============================================================================

/// Block errors
enum BlockError {
    NotFound,
    IdentifierExists,
    InvalidContent,
    InvalidSchedule,
    ValidationFailed(String)
}

impl BlockError {
    fn message() -> String {
        match self {
            BlockError.NotFound => "Block not found",
            BlockError.IdentifierExists => "Block with this identifier already exists",
            BlockError.InvalidContent => "Invalid block content",
            BlockError.InvalidSchedule => "Invalid schedule dates",
            BlockError.ValidationFailed(msg) => msg
        }
    }
}

// =============================================================================
// Block Service
// =============================================================================

/// Block service actor
actor BlockService {
    state blocks: Map<String, Block>
    state identifier_index: Map<String, String>
    state position_blocks: Map<String, [String]>
    state store_blocks: Map<String, Set<String>>
    state cache: Map<String, CachedBlock>
    
    fn new() -> Self {
        BlockService {
            blocks: Map.empty(),
            identifier_index: Map.empty(),
            position_blocks: Map.empty(),
            store_blocks: Map.empty(),
            cache: Map.empty()
        }
    }
    
    /// Create block
    on create(block: Block) -> Result<Block, BlockError> {
        if self.identifier_index.contains_key(block.identifier.clone()) {
            return Err(BlockError.IdentifierExists)
        }
        
        let block_id = block.id.clone()
        self.blocks.set(block_id.clone(), block.clone())
        self.identifier_index.set(block.identifier.clone(), block_id.clone())
        
        if let Some(position) = block.position.clone() {
            let pos_key = position.display_name()
            self.position_blocks.entry(pos_key).or_insert([]).push(block_id.clone())
        }
        
        for store_id in block.store_ids.iter() {
            self.store_blocks.entry(store_id.clone()).or_insert(Set.empty()).insert(block_id.clone())
        }
        
        Ok(block)
    }
    
    /// Get block by ID
    on get(block_id: String) -> Option<Block> {
        self.blocks.get(block_id)
    }
    
    /// Get block by identifier
    on get_by_identifier(identifier: String) -> Option<Block> {
        self.identifier_index.get(identifier)
            .and_then(|id| self.blocks.get(id))
    }
    
    /// Update block
    on update(block_id: String, title: Option<String>, content: Option<String>) -> Result<Block, BlockError> {
        let block = self.blocks.get_mut(block_id.clone())
            .ok_or(BlockError.NotFound)?
        
        if let Some(t) = title {
            block.title = t
        }
        
        if let Some(c) = content {
            block.content = c
        }
        
        block.updated_at = DateTime.now()
        
        // Invalidate cache
        self.cache.remove(block_id)
        
        Ok(block.clone())
    }
    
    /// Activate block
    on activate(block_id: String) -> Result<Block, BlockError> {
        let block = self.blocks.get_mut(block_id)
            .ok_or(BlockError.NotFound)?
        block.activate()
        Ok(block.clone())
    }
    
    /// Deactivate block
    on deactivate(block_id: String) -> Result<Block, BlockError> {
        let block = self.blocks.get_mut(block_id)
            .ok_or(BlockError.NotFound)?
        block.deactivate()
        Ok(block.clone())
    }
    
    /// Delete block
    on delete(block_id: String) -> Result<(), BlockError> {
        let block = self.blocks.remove(block_id.clone())
            .ok_or(BlockError.NotFound)?
        
        self.identifier_index.remove(block.identifier)
        
        if let Some(position) = block.position {
            let pos_key = position.display_name()
            if let Some(blocks) = self.position_blocks.get_mut(pos_key) {
                blocks.retain(|id| *id != block_id)
            }
        }
        
        self.cache.remove(block_id)
        
        Ok(())
    }
    
    /// Get blocks by position
    on get_by_position(position: BlockPosition) -> [Block] {
        let pos_key = position.display_name()
        var blocks: [Block] = self.position_blocks.get(pos_key)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.blocks.get(id))
                    .filter(|b| b.is_active())
                    .collect()
            })
            .unwrap_or([])
        
        blocks.sort_by(|a, b| a.sort_order.cmp(b.sort_order))
        blocks
    }
    
    /// Get blocks for store
    on get_for_store(store_id: String) -> [Block] {
        self.store_blocks.get(store_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.blocks.get(id))
                    .filter(|b| b.is_active())
                    .collect()
            })
            .unwrap_or([])
    }
    
    /// Get all active blocks
    on get_active() -> [Block] {
        self.blocks.values()
            .filter(|b| b.is_active())
            .collect()
    }
    
    /// Render block with caching
    on render(identifier: String) -> Option<String> {
        let block_id = self.identifier_index.get(identifier.clone())?
        
        // Check cache
        if let Some(cached) = self.cache.get(block_id.clone()) {
            if !cached.is_expired() {
                return Some(cached.content.clone())
            }
        }
        
        let block = self.blocks.get(block_id.clone())?
        
        if !block.is_active() {
            return None
        }
        
        let rendered = block.render()
        
        // Cache if configured
        if let Some(lifetime) = block.cache_lifetime {
            let cached = CachedBlock {
                content: rendered.clone(),
                expires_at: DateTime.now().add(Duration.seconds(lifetime))
            }
            self.cache.set(block_id, cached)
        }
        
        Some(rendered)
    }
    
    /// Clear cache
    on clear_cache() {
        self.cache.clear()
    }
    
    /// Process expired blocks
    on process_expired() -> [Block] {
        var expired: [Block] = []
        
        for block in self.blocks.values_mut() {
            if block.is_expired() && block.status != BlockStatus.Expired {
                block.status = BlockStatus.Expired
                expired.push(block.clone())
            }
        }
        
        expired
    }
}

/// Cached block
struct CachedBlock {
    content: String,
    expires_at: DateTime
}

impl CachedBlock {
    fn is_expired() -> Bool {
        DateTime.now() > self.expires_at
    }
}

// =============================================================================
// Block Builder
// =============================================================================

/// Fluent block builder
struct BlockBuilder {
    block: Block
}

impl BlockBuilder {
    fn text(identifier: String, title: String) -> Self {
        BlockBuilder { block: Block.new(identifier, title, BlockType.Text) }
    }
    
    fn html(identifier: String, title: String) -> Self {
        BlockBuilder { block: Block.new(identifier, title, BlockType.Html) }
    }
    
    fn markdown(identifier: String, title: String) -> Self {
        BlockBuilder { block: Block.new(identifier, title, BlockType.Markdown) }
    }
    
    fn image(identifier: String, title: String) -> Self {
        BlockBuilder { block: Block.new(identifier, title, BlockType.Image) }
    }
    
    fn video(identifier: String, title: String) -> Self {
        BlockBuilder { block: Block.new(identifier, title, BlockType.Video) }
    }
    
    fn slider(identifier: String, title: String) -> Self {
        BlockBuilder { block: Block.new(identifier, title, BlockType.Slider) }
    }
    
    fn content(content: String) -> Self {
        self.block.content = content
        self
    }
    
    fn position(position: BlockPosition) -> Self {
        self.block.position = Some(position)
        self
    }
    
    fn css_class(css_class: String) -> Self {
        self.block.css_class = Some(css_class)
        self
    }
    
    fn custom_css(css: String) -> Self {
        self.block.custom_css = Some(css)
        self
    }
    
    fn schedule(start: DateTime, end: DateTime) -> Self {
        self.block.start_date = Some(start)
        self.block.end_date = Some(end)
        self
    }
    
    fn cache(lifetime: Int) -> Self {
        self.block.cache_lifetime = Some(lifetime)
        self
    }
    
    fn stores(store_ids: [String]) -> Self {
        self.block.store_ids = store_ids
        self
    }
    
    fn sort_order(order: Int) -> Self {
        self.block.sort_order = order
        self
    }
    
    fn metadata(key: String, value: String) -> Self {
        self.block.metadata.set(key, value)
        self
    }
    
    fn active() -> Self {
        self.block.status = BlockStatus.Active
        self
    }
    
    fn build() -> Block {
        self.block
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn markdown_to_html(markdown: String) -> String {
    // Simplified markdown conversion
    markdown
        .replace("**", "<strong>")
        .replace("*", "<em>")
        .replace("\n\n", "</p><p>")
}

fn escape_html(text: String) -> String {
    text
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace("\"", "&quot;")
}

// =============================================================================
// Tests
// =============================================================================

test "create block" {
    let block = Block.new("header-banner", "Header Banner", BlockType.Html)
    assert_eq(block.identifier, "header-banner")?
    assert_eq(block.block_type, BlockType.Html)?
}

test "block builder" {
    let block = BlockBuilder.html("footer-info", "Footer Info")
        .content("<p>Contact us</p>")
        .position(BlockPosition.Footer)
        .cache(3600)
        .active()
        .build()
    
    assert_eq(block.identifier, "footer-info")?
    assert(block.is_active())?
}

test "block service" {
    var service = BlockService.new()
    
    let block = BlockBuilder.html("test-block", "Test")
        .content("<p>Hello</p>")
        .active()
        .build()
    
    service.create(block)?
    
    let found = service.get_by_identifier("test-block")
    assert(found.is_some())?
}

test "block rendering" {
    let block = Block.html("test", "Test", "<strong>Bold</strong>")
    let rendered = block.render()
    assert_eq(rendered, "<strong>Bold</strong>")?
}

test "block scheduling" {
    let now = DateTime.now()
    let start = now.add(Duration.hours(-1))
    let end = now.add(Duration.hours(1))
    
    var block = Block.new("scheduled", "Scheduled", BlockType.Text)
        .with_content("Scheduled content")
        .with_schedule(start, end)
    
    block.activate()
    assert(block.is_active())?
}

test "block caching" {
    var service = BlockService.new()
    
    let block = BlockBuilder.html("cached", "Cached Block")
        .content("<p>Cached</p>")
        .cache(3600)
        .active()
        .build()
    
    service.create(block)?
    
    let rendered1 = service.render("cached")
    let rendered2 = service.render("cached")
    
    assert_eq(rendered1, rendered2)?
}
