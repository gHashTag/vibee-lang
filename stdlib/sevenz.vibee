// =============================================================================
// Vibee OS â€” 7z Module
// 7-Zip archive creation and extraction (7z format)
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

const SEVENZ_SIGNATURE: [UInt8; 6] = [0x37, 0x7a, 0xbc, 0xaf, 0x27, 0x1c]
const SEVENZ_SIGNATURE_SIZE: Int = 32
const SEVENZ_END_HEADER_CRC_SIZE: Int = 4

// Property IDs
const PROP_END: UInt8 = 0x00
const PROP_HEADER: UInt8 = 0x01
const PROP_ARCHIVE_PROPERTIES: UInt8 = 0x02
const PROP_ADDITIONAL_STREAMS_INFO: UInt8 = 0x03
const PROP_MAIN_STREAMS_INFO: UInt8 = 0x04
const PROP_FILES_INFO: UInt8 = 0x05
const PROP_PACK_INFO: UInt8 = 0x06
const PROP_UNPACK_INFO: UInt8 = 0x07
const PROP_SUBSTREAMS_INFO: UInt8 = 0x08
const PROP_SIZE: UInt8 = 0x09
const PROP_CRC: UInt8 = 0x0a
const PROP_FOLDER: UInt8 = 0x0b
const PROP_CODERS_UNPACK_SIZE: UInt8 = 0x0c
const PROP_NUM_UNPACK_STREAM: UInt8 = 0x0d
const PROP_EMPTY_STREAM: UInt8 = 0x0e
const PROP_EMPTY_FILE: UInt8 = 0x0f
const PROP_ANTI: UInt8 = 0x10
const PROP_NAME: UInt8 = 0x11
const PROP_CTIME: UInt8 = 0x12
const PROP_ATIME: UInt8 = 0x13
const PROP_MTIME: UInt8 = 0x14
const PROP_WIN_ATTRIBUTES: UInt8 = 0x15
const PROP_COMMENT: UInt8 = 0x16
const PROP_ENCODED_HEADER: UInt8 = 0x17
const PROP_START_POS: UInt8 = 0x18
const PROP_DUMMY: UInt8 = 0x19

// =============================================================================
// Enums
// =============================================================================

/// 7z compression method
enum SevenZMethod {
    Copy        // No compression
    Lzma        // LZMA
    Lzma2       // LZMA2 (default)
    Ppmd        // PPMd
    BZip2       // BZip2
    Deflate     // Deflate
    Delta       // Delta filter
    Bcj         // BCJ (x86)
    Bcj2        // BCJ2 (x86)
    Arm         // ARM filter
    ArmThumb    // ARM Thumb filter
    Sparc       // SPARC filter
    Ppc         // PowerPC filter
    Ia64        // IA-64 filter
    Aes256Sha256 // AES-256 + SHA-256 encryption
}

impl SevenZMethod {
    fn id() -> [UInt8] {
        match self {
            Copy => [0x00]
            Lzma => [0x03, 0x01, 0x01]
            Lzma2 => [0x21]
            Ppmd => [0x03, 0x04, 0x01]
            BZip2 => [0x04, 0x02, 0x02]
            Deflate => [0x04, 0x01, 0x08]
            Delta => [0x03]
            Bcj => [0x03, 0x03, 0x01, 0x03]
            Bcj2 => [0x03, 0x03, 0x01, 0x1b]
            Arm => [0x03, 0x03, 0x01, 0x05]
            ArmThumb => [0x03, 0x03, 0x01, 0x07]
            Sparc => [0x03, 0x03, 0x01, 0x08]
            Ppc => [0x03, 0x03, 0x01, 0x02]
            Ia64 => [0x03, 0x03, 0x01, 0x04]
            Aes256Sha256 => [0x06, 0xf1, 0x07, 0x01]
        }
    }
    
    fn name() -> String {
        match self {
            Copy => "Copy"
            Lzma => "LZMA"
            Lzma2 => "LZMA2"
            Ppmd => "PPMd"
            BZip2 => "BZip2"
            Deflate => "Deflate"
            Delta => "Delta"
            Bcj => "BCJ"
            Bcj2 => "BCJ2"
            Arm => "ARM"
            ArmThumb => "ARM-Thumb"
            Sparc => "SPARC"
            Ppc => "PPC"
            Ia64 => "IA-64"
            Aes256Sha256 => "AES-256"
        }
    }
    
    fn is_filter() -> Bool {
        match self {
            Delta | Bcj | Bcj2 | Arm | ArmThumb | Sparc | Ppc | Ia64 => true
            _ => false
        }
    }
    
    fn is_encryption() -> Bool {
        match self { Aes256Sha256 => true, _ => false }
    }
}

/// 7z compression level
enum SevenZLevel {
    Store       // No compression (level 0)
    Fastest     // Fastest (level 1)
    Fast        // Fast (level 3)
    Normal      // Normal (level 5)
    Maximum     // Maximum (level 7)
    Ultra       // Ultra (level 9)
}

impl SevenZLevel {
    fn value() -> Int {
        match self {
            Store => 0
            Fastest => 1
            Fast => 3
            Normal => 5
            Maximum => 7
            Ultra => 9
        }
    }
}

/// 7z entry type
enum SevenZEntryType {
    File
    Directory
    AntiFile    // Marks file for deletion in differential archives
}

impl SevenZEntryType {
    fn is_file() -> Bool { match self { File => true, _ => false } }
    fn is_dir() -> Bool { match self { Directory => true, _ => false } }
}

// =============================================================================
// Structs
// =============================================================================

/// 7z archive entry
struct SevenZEntry {
    name: String
    compressed_size: UInt64
    uncompressed_size: UInt64
    crc32: Option<UInt32>
    entry_type: SevenZEntryType
    modified: Option<DateTime>
    created: Option<DateTime>
    accessed: Option<DateTime>
    attributes: UInt32
    is_encrypted: Bool
    has_stream: Bool
    method: Option<SevenZMethod>
}

impl SevenZEntry {
    fn new(name: String) -> Self {
        SevenZEntry {
            name: name
            compressed_size: 0
            uncompressed_size: 0
            crc32: None
            entry_type: if name.ends_with("/") { SevenZEntryType.Directory } else { SevenZEntryType.File }
            modified: None
            created: None
            accessed: None
            attributes: 0
            is_encrypted: false
            has_stream: true
            method: None
        }
    }
    
    fn from_file(name: String, size: UInt64) -> Self {
        let mut entry = Self.new(name)
        entry.uncompressed_size = size
        entry.entry_type = SevenZEntryType.File
        entry.has_stream = true
        entry
    }
    
    fn from_dir(name: String) -> Self {
        let dir_name = if name.ends_with("/") { name } else { name + "/" }
        let mut entry = Self.new(dir_name)
        entry.entry_type = SevenZEntryType.Directory
        entry.has_stream = false
        entry
    }
    
    fn is_file() -> Bool { self.entry_type.is_file() }
    fn is_dir() -> Bool { self.entry_type.is_dir() }
    
    fn compression_ratio() -> Float64 {
        if self.uncompressed_size == 0 { return 0.0 }
        1.0 - (self.compressed_size as Float64 / self.uncompressed_size as Float64)
    }
}

/// 7z archive information
struct SevenZInfo {
    version_major: UInt8
    version_minor: UInt8
    is_solid: Bool
    is_encrypted: Bool
    header_encrypted: Bool
    methods: [SevenZMethod]
    total_size: UInt64
    total_uncompressed: UInt64
    entry_count: Int
    file_count: Int
    dir_count: Int
}

/// 7z archive reader
struct SevenZReader {
    inner: @native("SevenZReader")
    info: SevenZInfo
    entries: [SevenZEntry]
}

impl SevenZReader {
    fn new(data: [UInt8]) -> Result<Self, SevenZError> {
        if !is_7z(data) {
            return Err(SevenZError.InvalidArchive)
        }
        let inner = @native("sevenz_reader_new", data)?
        let info = @native("sevenz_reader_info", inner)?
        let entries = @native("sevenz_reader_entries", inner)?
        Ok(SevenZReader { inner: inner, info: info, entries: entries })
    }
    
    fn open(path: String) -> Result<Self, SevenZError> {
        let data = @native("fs_read_bytes", path)?
        Self.new(data)
    }
    
    fn info() -> SevenZInfo { self.info.clone() }
    
    fn entries() -> [SevenZEntry] { self.entries.clone() }
    
    fn len() -> Int { self.entries.len() }
    
    fn is_empty() -> Bool { self.entries.is_empty() }
    
    fn list() -> [String] { self.entries.map(|e| e.name.clone()) }
    
    fn find(name: String) -> Option<SevenZEntry> {
        for e in self.entries {
            if e.name == name { return Some(e.clone()) }
        }
        None
    }
    
    fn extract(dest: String) -> Result<Int, SevenZError> {
        @native("sevenz_reader_extract", self.inner, dest)
    }
    
    fn extract_with_password(dest: String, password: String) -> Result<Int, SevenZError> {
        @native("sevenz_reader_extract_password", self.inner, dest, password)
    }
    
    fn extract_file(name: String) -> Result<[UInt8], SevenZError> {
        @native("sevenz_reader_extract_file", self.inner, name)
    }
    
    fn extract_file_with_password(name: String, password: String) -> Result<[UInt8], SevenZError> {
        @native("sevenz_reader_extract_file_password", self.inner, name, password)
    }
    
    fn test() -> Result<Bool, SevenZError> {
        @native("sevenz_reader_test", self.inner)
    }
    
    fn is_encrypted() -> Bool { self.info.is_encrypted }
    
    fn is_solid() -> Bool { self.info.is_solid }
    
    fn methods() -> [SevenZMethod] { self.info.methods.clone() }
}

impl Iterator for SevenZReader {
    type Item = SevenZEntry
    fn next() -> Option<Self.Item> {
        @native("sevenz_reader_next", self.inner)
    }
}

impl Drop for SevenZReader {
    fn drop() { @native("sevenz_reader_close", self.inner) }
}

/// 7z archive builder
struct SevenZBuilder {
    entries: [(String, [UInt8])]
    dirs: [String]
    method: SevenZMethod
    level: SevenZLevel
    solid: Bool
    password: Option<String>
    encrypt_header: Bool
    filters: [SevenZMethod]
    threads: Int
    dict_size: Option<Int>
}

impl SevenZBuilder {
    fn new() -> Self {
        SevenZBuilder {
            entries: []
            dirs: []
            method: SevenZMethod.Lzma2
            level: SevenZLevel.Normal
            solid: true
            password: None
            encrypt_header: false
            filters: []
            threads: 0  // Auto-detect
            dict_size: None
        }
    }
    
    fn with_method(method: SevenZMethod) -> Self {
        self.method = method
        self
    }
    
    fn with_level(level: SevenZLevel) -> Self {
        self.level = level
        self
    }
    
    fn solid(s: Bool) -> Self {
        self.solid = s
        self
    }
    
    fn with_password(password: String) -> Self {
        self.password = Some(password)
        self
    }
    
    fn encrypt_header(e: Bool) -> Self {
        self.encrypt_header = e
        self
    }
    
    fn with_filter(filter: SevenZMethod) -> Self {
        if filter.is_filter() {
            self.filters.push(filter)
        }
        self
    }
    
    fn with_threads(t: Int) -> Self {
        self.threads = t
        self
    }
    
    fn with_dict_size(size: Int) -> Self {
        self.dict_size = Some(size)
        self
    }
    
    fn add_file(name: String, data: [UInt8]) -> Self {
        self.entries.push((name, data))
        self
    }
    
    fn add_dir(name: String) -> Self {
        let dir_name = if name.ends_with("/") { name } else { name + "/" }
        self.dirs.push(dir_name)
        self
    }
    
    fn add_path(path: String) -> Result<Self, SevenZError> {
        @native("sevenz_builder_add_path", self, path)
    }
    
    fn add_dir_recursive(path: String) -> Result<Self, SevenZError> {
        @native("sevenz_builder_add_dir_recursive", self, path)
    }
    
    fn build() -> Result<[UInt8], SevenZError> {
        @native("sevenz_builder_build", self)
    }
    
    fn write(path: String) -> Result<(), SevenZError> {
        let data = self.build()?
        @native("fs_write_bytes", path, data)
    }
}

/// 7z compression options
struct SevenZOptions {
    method: SevenZMethod
    level: SevenZLevel
    solid: Bool
    filters: [SevenZMethod]
    threads: Int
    dict_size: Option<Int>
}

impl SevenZOptions {
    fn new() -> Self {
        SevenZOptions {
            method: SevenZMethod.Lzma2
            level: SevenZLevel.Normal
            solid: true
            filters: []
            threads: 0
            dict_size: None
        }
    }
    
    fn for_text() -> Self {
        Self.new()
            .with_method(SevenZMethod.Ppmd)
            .with_level(SevenZLevel.Maximum)
    }
    
    fn for_executables() -> Self {
        Self.new()
            .with_method(SevenZMethod.Lzma2)
            .with_filter(SevenZMethod.Bcj2)
            .with_level(SevenZLevel.Ultra)
    }
    
    fn for_speed() -> Self {
        Self.new()
            .with_method(SevenZMethod.Lzma2)
            .with_level(SevenZLevel.Fastest)
            .solid(false)
    }
    
    fn with_method(m: SevenZMethod) -> Self { self.method = m; self }
    fn with_level(l: SevenZLevel) -> Self { self.level = l; self }
    fn solid(s: Bool) -> Self { self.solid = s; self }
    fn with_filter(f: SevenZMethod) -> Self { self.filters.push(f); self }
    fn with_threads(t: Int) -> Self { self.threads = t; self }
    fn with_dict_size(s: Int) -> Self { self.dict_size = Some(s); self }
}

// =============================================================================
// Actor for async operations
// =============================================================================

actor SevenZActor {
    fn create_async(files: [(String, [UInt8])]) -> Result<[UInt8], SevenZError> {
        create(files)
    }
    
    fn extract_async(data: [UInt8], dest: String) -> Result<Int, SevenZError> {
        extract(data, dest)
    }
    
    fn compress_dir_async(path: String, dest: String) -> Result<(), SevenZError> {
        compress_dir(path, dest)
    }
    
    fn list_async(data: [UInt8]) -> Result<[String], SevenZError> {
        list(data)
    }
}

// =============================================================================
// Trait implementations
// =============================================================================

trait Archive {
    fn list() -> [String]
    fn extract(dest: String) -> Result<Int, SevenZError>
    fn extract_file(name: String) -> Result<[UInt8], SevenZError>
}

impl Archive for SevenZReader {
    fn list() -> [String] { self.list() }
    fn extract(dest: String) -> Result<Int, SevenZError> { self.extract(dest) }
    fn extract_file(name: String) -> Result<[UInt8], SevenZError> { self.extract_file(name) }
}

// =============================================================================
// Public API Functions
// =============================================================================

/// Check if data is a 7z archive
fn is_7z(data: [UInt8]) -> Bool {
    if data.len() < 6 { return false }
    data[0] == 0x37 && data[1] == 0x7a && data[2] == 0xbc && 
    data[3] == 0xaf && data[4] == 0x27 && data[5] == 0x1c
}

/// Create a 7z archive from files
fn create(files: [(String, [UInt8])]) -> Result<[UInt8], SevenZError> {
    let mut builder = SevenZBuilder.new()
    for (name, data) in files {
        builder = builder.add_file(name, data)
    }
    builder.build()
}

/// Create a 7z archive with specific options
fn create_with_options(files: [(String, [UInt8])], options: SevenZOptions) -> Result<[UInt8], SevenZError> {
    let mut builder = SevenZBuilder.new()
        .with_method(options.method)
        .with_level(options.level)
        .solid(options.solid)
    
    for f in options.filters {
        builder = builder.with_filter(f)
    }
    
    for (name, data) in files {
        builder = builder.add_file(name, data)
    }
    builder.build()
}

/// Create a password-protected 7z archive
fn create_encrypted(files: [(String, [UInt8])], password: String) -> Result<[UInt8], SevenZError> {
    let mut builder = SevenZBuilder.new().with_password(password)
    for (name, data) in files {
        builder = builder.add_file(name, data)
    }
    builder.build()
}

/// Create with encrypted header (hides file names)
fn create_encrypted_header(files: [(String, [UInt8])], password: String) -> Result<[UInt8], SevenZError> {
    let mut builder = SevenZBuilder.new()
        .with_password(password)
        .encrypt_header(true)
    for (name, data) in files {
        builder = builder.add_file(name, data)
    }
    builder.build()
}

/// Extract 7z archive to directory
fn extract(data: [UInt8], dest: String) -> Result<Int, SevenZError> {
    let reader = SevenZReader.new(data)?
    reader.extract(dest)
}

/// Extract 7z archive from file
fn extract_file(path: String, dest: String) -> Result<Int, SevenZError> {
    let reader = SevenZReader.open(path)?
    reader.extract(dest)
}

/// Extract password-protected 7z archive
fn extract_encrypted(data: [UInt8], dest: String, password: String) -> Result<Int, SevenZError> {
    let reader = SevenZReader.new(data)?
    reader.extract_with_password(dest, password)
}

/// List files in 7z archive
fn list(data: [UInt8]) -> Result<[String], SevenZError> {
    let reader = SevenZReader.new(data)?
    Ok(reader.list())
}

/// Get a single file from 7z archive
fn get_file(data: [UInt8], name: String) -> Result<[UInt8], SevenZError> {
    let reader = SevenZReader.new(data)?
    reader.extract_file(name)
}

/// Compress a directory to 7z file
fn compress_dir(path: String, dest: String) -> Result<(), SevenZError> {
    SevenZBuilder.new().add_dir_recursive(path)?.write(dest)
}

/// Compress a directory to 7z bytes
fn compress_dir_to_bytes(path: String) -> Result<[UInt8], SevenZError> {
    SevenZBuilder.new().add_dir_recursive(path)?.build()
}

/// Test 7z archive integrity
fn test(data: [UInt8]) -> Result<Bool, SevenZError> {
    let reader = SevenZReader.new(data)?
    reader.test()
}

/// Get archive information
fn info(data: [UInt8]) -> Result<SevenZInfo, SevenZError> {
    let reader = SevenZReader.new(data)?
    Ok(reader.info())
}

// =============================================================================
// Error Type
// =============================================================================

enum SevenZError {
    InvalidArchive
    InvalidHeader
    InvalidCrc
    UnsupportedMethod(String)
    UnsupportedVersion
    FileNotFound(String)
    PasswordRequired
    WrongPassword
    CorruptedData
    UnexpectedEof
    IoError(String)
    CompressionError(String)
    Other(String)
}

impl Display for SevenZError {
    fn fmt(f: Formatter) {
        match self {
            InvalidArchive => f.write("Invalid 7z archive")
            InvalidHeader => f.write("Invalid 7z header")
            InvalidCrc => f.write("CRC checksum mismatch")
            UnsupportedMethod(m) => f.write("Unsupported compression method: " + m)
            UnsupportedVersion => f.write("Unsupported 7z version")
            FileNotFound(name) => f.write("File not found in archive: " + name)
            PasswordRequired => f.write("Password required for encrypted archive")
            WrongPassword => f.write("Wrong password")
            CorruptedData => f.write("Corrupted archive data")
            UnexpectedEof => f.write("Unexpected end of archive")
            IoError(msg) => f.write("I/O error: " + msg)
            CompressionError(msg) => f.write("Compression error: " + msg)
            Other(msg) => f.write(msg)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "is_7z detection" {
    let valid_7z = [0x37, 0x7a, 0xbc, 0xaf, 0x27, 0x1c]
    assert(is_7z(valid_7z))?
    
    let invalid = [0x00, 0x00, 0x00, 0x00]
    assert(!is_7z(invalid))?
}

test "sevenz builder" {
    let data = SevenZBuilder.new()
        .with_method(SevenZMethod.Lzma2)
        .with_level(SevenZLevel.Normal)
        .solid(true)
        .add_file("test.txt", "Hello, World!".as_bytes())
        .build()?
    
    assert(is_7z(data))?
}

test "compression methods" {
    assert_eq(SevenZMethod.Lzma2.name(), "LZMA2")?
    assert(!SevenZMethod.Lzma2.is_filter())?
    assert(SevenZMethod.Bcj.is_filter())?
    assert(SevenZMethod.Aes256Sha256.is_encryption())?
}

test "compression levels" {
    assert_eq(SevenZLevel.Store.value(), 0)?
    assert_eq(SevenZLevel.Normal.value(), 5)?
    assert_eq(SevenZLevel.Ultra.value(), 9)?
}

test "entry types" {
    let file_entry = SevenZEntry.from_file("test.txt", 100)
    assert(file_entry.is_file())?
    assert(!file_entry.is_dir())?
    
    let dir_entry = SevenZEntry.from_dir("mydir")
    assert(dir_entry.is_dir())?
    assert(dir_entry.name.ends_with("/"))?
}

test "options presets" {
    let text_opts = SevenZOptions.for_text()
    assert_eq(text_opts.method, SevenZMethod.Ppmd)?
    
    let exe_opts = SevenZOptions.for_executables()
    assert(exe_opts.filters.contains(SevenZMethod.Bcj2))?
    
    let speed_opts = SevenZOptions.for_speed()
    assert(!speed_opts.solid)?
}
