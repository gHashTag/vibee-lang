// =============================================================================
// Vibee OS — Performance Profiler Module
// CPU profiling, memory analysis, and performance metrics collection
// =============================================================================

// -----------------------------------------------------------------------------
// Profiler Configuration
// -----------------------------------------------------------------------------

struct ProfilerConfig {
    sample_rate_hz: Int
    stack_depth: Int
    track_allocations: Bool
    track_gc: Bool
    track_io: Bool
    track_locks: Bool
    flame_graph: Bool
    
    fn default() -> Self {
        ProfilerConfig {
            sample_rate_hz: 1000,
            stack_depth: 64,
            track_allocations: true,
            track_gc: true,
            track_io: true,
            track_locks: true,
            flame_graph: true
        }
    }
    
    fn lightweight() -> Self {
        ProfilerConfig {
            sample_rate_hz: 100,
            stack_depth: 32,
            track_allocations: false,
            track_gc: false,
            track_io: false,
            track_locks: false,
            flame_graph: false
        }
    }
}

// -----------------------------------------------------------------------------
// Sample Types
// -----------------------------------------------------------------------------

struct CpuSample {
    timestamp: Instant
    thread_id: Int
    stack: [StackFrame]
    cpu_time: Duration
}

struct StackFrame {
    function: String
    file: String
    line: Int
    module: String
}

struct AllocationSample {
    timestamp: Instant
    address: Int
    size: Int
    stack: [StackFrame]
    type_name: String
}

struct GcEvent {
    timestamp: Instant
    generation: Int
    duration: Duration
    freed_bytes: Int
    live_bytes: Int
}

struct IoEvent {
    timestamp: Instant
    operation: IoOperation
    path: String
    bytes: Int
    duration: Duration
}

enum IoOperation { Read, Write, Open, Close, Seek }

struct LockEvent {
    timestamp: Instant
    lock_id: Int
    operation: LockOperation
    duration: Duration
    stack: [StackFrame]
}

enum LockOperation { Acquire, Release, Wait, Timeout }

// -----------------------------------------------------------------------------
// Performance Profiler
// -----------------------------------------------------------------------------

actor PerformanceProfiler {
    state config: ProfilerConfig
    state running: Bool
    state start_time: Option<Instant>
    state cpu_samples: [CpuSample]
    state allocations: [AllocationSample]
    state gc_events: [GcEvent]
    state io_events: [IoEvent]
    state lock_events: [LockEvent]
    state function_stats: Map<String, FunctionStats>
    state memory_snapshots: [MemorySnapshot]
    
    fn new() -> Self {
        Self.with_config(ProfilerConfig.default())
    }
    
    fn with_config(config: ProfilerConfig) -> Self {
        PerformanceProfiler {
            config: config,
            running: false,
            start_time: None,
            cpu_samples: [],
            allocations: [],
            gc_events: [],
            io_events: [],
            lock_events: [],
            function_stats: Map.new(),
            memory_snapshots: []
        }
    }
    
    // -------------------------------------------------------------------------
    // Profiling Control
    // -------------------------------------------------------------------------
    
    on start() {
        if self.running { return }
        
        self.running = true
        self.start_time = Some(Instant.now())
        self.clear_data()
        
        @native("profiler_start", self.config.sample_rate_hz, self.config.stack_depth)
        
        if self.config.track_allocations {
            @native("profiler_track_allocations", true)
        }
        if self.config.track_gc {
            @native("profiler_track_gc", true)
        }
        if self.config.track_io {
            @native("profiler_track_io", true)
        }
        if self.config.track_locks {
            @native("profiler_track_locks", true)
        }
    }
    
    on stop() -> ProfileReport {
        if !self.running { return self.generate_report() }
        
        self.running = false
        @native("profiler_stop")
        
        // Collect samples
        self.cpu_samples = @native("profiler_get_cpu_samples")
        if self.config.track_allocations {
            self.allocations = @native("profiler_get_allocations")
        }
        if self.config.track_gc {
            self.gc_events = @native("profiler_get_gc_events")
        }
        if self.config.track_io {
            self.io_events = @native("profiler_get_io_events")
        }
        if self.config.track_locks {
            self.lock_events = @native("profiler_get_lock_events")
        }
        
        self.analyze_samples()
        self.generate_report()
    }
    
    fn clear_data() {
        self.cpu_samples.clear()
        self.allocations.clear()
        self.gc_events.clear()
        self.io_events.clear()
        self.lock_events.clear()
        self.function_stats.clear()
        self.memory_snapshots.clear()
    }
    
    // -------------------------------------------------------------------------
    // Manual Instrumentation
    // -------------------------------------------------------------------------
    
    /// Start timing a section
    fn begin_section(name: String) -> SectionTimer {
        SectionTimer {
            name: name,
            start: Instant.now(),
            profiler: self
        }
    }
    
    /// Record custom metric
    on record_metric(name: String, value: Float, unit: String) {
        @native("profiler_record_metric", name, value, unit)
    }
    
    /// Take memory snapshot
    on take_memory_snapshot(label: String) {
        let snapshot = MemorySnapshot {
            label: label,
            timestamp: Instant.now(),
            heap_used: @native("memory_heap_used"),
            heap_total: @native("memory_heap_total"),
            stack_used: @native("memory_stack_used"),
            allocations: @native("memory_allocation_count"),
            gc_count: @native("gc_count")
        }
        self.memory_snapshots.push(snapshot)
    }
    
    // -------------------------------------------------------------------------
    // Analysis
    // -------------------------------------------------------------------------
    
    fn analyze_samples() {
        self.function_stats.clear()
        
        for sample in self.cpu_samples {
            for (i, frame) in sample.stack.enumerate() {
                let key = format!("{}:{}", frame.module, frame.function)
                let stats = self.function_stats.entry(key).or_insert(FunctionStats {
                    function: frame.function.clone(),
                    module: frame.module.clone(),
                    file: frame.file.clone(),
                    self_samples: 0,
                    total_samples: 0,
                    self_time: Duration.zero(),
                    total_time: Duration.zero()
                })
                
                stats.total_samples += 1
                if i == 0 {
                    stats.self_samples += 1
                }
            }
        }
        
        // Calculate times
        let sample_interval = Duration.from_micros(1_000_000 / self.config.sample_rate_hz)
        for (_, stats) in self.function_stats {
            stats.self_time = sample_interval * stats.self_samples
            stats.total_time = sample_interval * stats.total_samples
        }
    }
    
    /// Get hottest functions
    fn hot_functions(limit: Int) -> [FunctionStats] {
        var sorted = self.function_stats.values().collect::<Vec<_>>()
        sorted.sort_by(|a, b| b.self_samples.cmp(a.self_samples))
        sorted.into_iter().take(limit).collect()
    }
    
    /// Get call tree
    fn call_tree() -> CallTreeNode {
        var root = CallTreeNode {
            function: "<root>".to_string(),
            self_time: Duration.zero(),
            total_time: Duration.zero(),
            children: Map.new()
        }
        
        for sample in self.cpu_samples {
            self.add_to_call_tree(root, sample.stack.iter().rev().collect(), 0)
        }
        
        root
    }
    
    fn add_to_call_tree(node: CallTreeNode, stack: [StackFrame], depth: Int) {
        if depth >= stack.len() { return }
        
        let frame = stack[depth]
        let key = format!("{}:{}", frame.module, frame.function)
        
        let child = node.children.entry(key).or_insert(CallTreeNode {
            function: frame.function.clone(),
            self_time: Duration.zero(),
            total_time: Duration.zero(),
            children: Map.new()
        })
        
        let sample_interval = Duration.from_micros(1_000_000 / self.config.sample_rate_hz)
        child.total_time += sample_interval
        
        if depth == stack.len() - 1 {
            child.self_time += sample_interval
        } else {
            self.add_to_call_tree(child, stack, depth + 1)
        }
    }
    
    // -------------------------------------------------------------------------
    // Memory Analysis
    // -------------------------------------------------------------------------
    
    fn memory_stats() -> MemoryStats {
        let total_allocated = self.allocations.iter().map(|a| a.size).sum()
        let allocation_count = self.allocations.len()
        
        var by_type: Map<String, Int> = Map.new()
        for alloc in self.allocations {
            *by_type.entry(alloc.type_name.clone()).or_insert(0) += alloc.size
        }
        
        MemoryStats {
            total_allocated: total_allocated,
            allocation_count: allocation_count,
            by_type: by_type,
            gc_events: self.gc_events.len(),
            gc_time: self.gc_events.iter().map(|e| e.duration).sum()
        }
    }
    
    fn allocation_hotspots(limit: Int) -> [AllocationHotspot] {
        var by_site: Map<String, AllocationHotspot> = Map.new()
        
        for alloc in self.allocations {
            let site = alloc.stack.first()
                .map(|f| format!("{}:{}", f.file, f.line))
                .unwrap_or("<unknown>".to_string())
            
            let hotspot = by_site.entry(site.clone()).or_insert(AllocationHotspot {
                site: site,
                count: 0,
                total_bytes: 0,
                types: Map.new()
            })
            
            hotspot.count += 1
            hotspot.total_bytes += alloc.size
            *hotspot.types.entry(alloc.type_name.clone()).or_insert(0) += 1
        }
        
        var sorted = by_site.values().collect::<Vec<_>>()
        sorted.sort_by(|a, b| b.total_bytes.cmp(a.total_bytes))
        sorted.into_iter().take(limit).collect()
    }
    
    // -------------------------------------------------------------------------
    // I/O Analysis
    // -------------------------------------------------------------------------
    
    fn io_stats() -> IoStats {
        let read_bytes = self.io_events.iter()
            .filter(|e| matches!(e.operation, IoOperation.Read))
            .map(|e| e.bytes)
            .sum()
        
        let write_bytes = self.io_events.iter()
            .filter(|e| matches!(e.operation, IoOperation.Write))
            .map(|e| e.bytes)
            .sum()
        
        let io_time = self.io_events.iter().map(|e| e.duration).sum()
        
        IoStats {
            read_bytes: read_bytes,
            write_bytes: write_bytes,
            total_operations: self.io_events.len(),
            total_time: io_time
        }
    }
    
    // -------------------------------------------------------------------------
    // Report Generation
    // -------------------------------------------------------------------------
    
    fn generate_report() -> ProfileReport {
        let duration = self.start_time
            .map(|s| Instant.now() - s)
            .unwrap_or(Duration.zero())
        
        ProfileReport {
            duration: duration,
            cpu_samples: self.cpu_samples.len(),
            hot_functions: self.hot_functions(20),
            memory_stats: self.memory_stats(),
            io_stats: self.io_stats(),
            gc_events: self.gc_events.clone(),
            memory_snapshots: self.memory_snapshots.clone()
        }
    }
    
    /// Generate flame graph data
    fn flame_graph_data() -> String {
        var output = StringBuilder.new()
        
        for sample in self.cpu_samples {
            let stack_str = sample.stack.iter()
                .rev()
                .map(|f| f.function.clone())
                .join(";")
            output.append(format!("{} 1\n", stack_str))
        }
        
        output.build()
    }
    
    // -------------------------------------------------------------------------
    // Rendering
    // -------------------------------------------------------------------------
    
    fn render() -> String {
        let report = self.generate_report()
        var output = StringBuilder.new()
        
        output.append("╔══════════════════════════════════════════╗\n")
        output.append("║       Performance Profile Report         ║\n")
        output.append("╚══════════════════════════════════════════╝\n\n")
        
        output.append(format!("Duration: {:?}\n", report.duration))
        output.append(format!("CPU Samples: {}\n\n", report.cpu_samples))
        
        // Hot functions
        output.append("═══ Hot Functions ═══\n")
        output.append("Self%  │ Total% │ Function\n")
        output.append("───────┼────────┼─────────────────────\n")
        
        let total_samples = self.cpu_samples.len() as Float
        for func in report.hot_functions.iter().take(10) {
            let self_pct = (func.self_samples as Float / total_samples * 100.0).round(1)
            let total_pct = (func.total_samples as Float / total_samples * 100.0).round(1)
            output.append(format!("{:5.1}% │ {:5.1}% │ {}::{}\n", 
                self_pct, total_pct, func.module, func.function))
        }
        
        // Memory
        output.append("\n═══ Memory ═══\n")
        output.append(format!("Allocated: {} bytes ({} allocations)\n", 
            report.memory_stats.total_allocated, report.memory_stats.allocation_count))
        output.append(format!("GC Events: {}, Time: {:?}\n", 
            report.memory_stats.gc_events, report.memory_stats.gc_time))
        
        // I/O
        output.append("\n═══ I/O ═══\n")
        output.append(format!("Read: {} bytes, Write: {} bytes\n", 
            report.io_stats.read_bytes, report.io_stats.write_bytes))
        output.append(format!("Operations: {}, Time: {:?}\n", 
            report.io_stats.total_operations, report.io_stats.total_time))
        
        output.build()
    }
}

// -----------------------------------------------------------------------------
// Supporting Types
// -----------------------------------------------------------------------------

struct SectionTimer {
    name: String
    start: Instant
    profiler: PerformanceProfiler
}

impl SectionTimer {
    fn end() -> Duration {
        let elapsed = Instant.now() - self.start
        self.profiler.record_metric(self.name.clone(), elapsed.as_millis() as Float, "ms")
        elapsed
    }
}

impl Drop for SectionTimer {
    fn drop() { self.end() }
}

struct FunctionStats {
    function: String
    module: String
    file: String
    self_samples: Int
    total_samples: Int
    self_time: Duration
    total_time: Duration
}

struct CallTreeNode {
    function: String
    self_time: Duration
    total_time: Duration
    children: Map<String, CallTreeNode>
}

struct MemorySnapshot {
    label: String
    timestamp: Instant
    heap_used: Int
    heap_total: Int
    stack_used: Int
    allocations: Int
    gc_count: Int
}

struct MemoryStats {
    total_allocated: Int
    allocation_count: Int
    by_type: Map<String, Int>
    gc_events: Int
    gc_time: Duration
}

struct AllocationHotspot {
    site: String
    count: Int
    total_bytes: Int
    types: Map<String, Int>
}

struct IoStats {
    read_bytes: Int
    write_bytes: Int
    total_operations: Int
    total_time: Duration
}

struct ProfileReport {
    duration: Duration
    cpu_samples: Int
    hot_functions: [FunctionStats]
    memory_stats: MemoryStats
    io_stats: IoStats
    gc_events: [GcEvent]
    memory_snapshots: [MemorySnapshot]
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Profile a function
fn profile<T>(name: String, f: fn() -> T) -> (T, Duration) {
    let start = Instant.now()
    let result = f()
    let elapsed = Instant.now() - start
    (result, elapsed)
}

/// Benchmark function with iterations
fn benchmark(name: String, iterations: Int, f: fn() -> ()) -> BenchmarkResult {
    var times = []
    
    // Warmup
    for _ in 0..10 { f() }
    
    // Measure
    for _ in 0..iterations {
        let start = Instant.now()
        f()
        times.push(Instant.now() - start)
    }
    
    times.sort()
    
    BenchmarkResult {
        name: name,
        iterations: iterations,
        min: times.first().cloned().unwrap_or(Duration.zero()),
        max: times.last().cloned().unwrap_or(Duration.zero()),
        mean: Duration.from_nanos(times.iter().map(|d| d.as_nanos()).sum::<Int>() / iterations),
        median: times[iterations / 2].clone(),
        p95: times[(iterations * 95) / 100].clone(),
        p99: times[(iterations * 99) / 100].clone()
    }
}

struct BenchmarkResult {
    name: String
    iterations: Int
    min: Duration
    max: Duration
    mean: Duration
    median: Duration
    p95: Duration
    p99: Duration
    
    fn print() {
        println(format!("Benchmark: {}", self.name))
        println(format!("  Iterations: {}", self.iterations))
        println(format!("  Min:    {:?}", self.min))
        println(format!("  Max:    {:?}", self.max))
        println(format!("  Mean:   {:?}", self.mean))
        println(format!("  Median: {:?}", self.median))
        println(format!("  P95:    {:?}", self.p95))
        println(format!("  P99:    {:?}", self.p99))
    }
}

// -----------------------------------------------------------------------------
// Global Instance
// -----------------------------------------------------------------------------

var PROFILER = PerformanceProfiler.new()

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "profiler_config" {
    let config = ProfilerConfig.default()
    assert_eq(config.sample_rate_hz, 1000)?
    assert(config.track_allocations)?
}

test "benchmark" {
    let result = benchmark("test", 100, || {
        var sum = 0
        for i in 0..1000 { sum += i }
    })
    assert_eq(result.iterations, 100)?
}

test "memory_snapshot" {
    let profiler = PerformanceProfiler.new()
    profiler.take_memory_snapshot("test")
    assert_eq(profiler.memory_snapshots.len(), 1)?
}
