// =============================================================================
// Vibee OS â€” Event Emitter Module
// Event emitters for publish-subscribe patterns
// =============================================================================

use result::{Result, Ok, Err}

// =============================================================================
// Core Types
// =============================================================================

/// Event priority levels
enum EventPriority {
    Low,
    Normal,
    High,
    Critical
}

impl EventPriority {
    fn value() -> Int {
        match self {
            EventPriority.Low => 0,
            EventPriority.Normal => 1,
            EventPriority.High => 2,
            EventPriority.Critical => 3
        }
    }
}

/// Event metadata
struct EventMeta {
    id: String,
    timestamp: Int64,
    source: String,
    priority: EventPriority,
    tags: [String]
}

impl EventMeta {
    fn new(source: String) -> Self {
        EventMeta {
            id: @native("uuid_v4"),
            timestamp: @native("timestamp_ms"),
            source: source,
            priority: EventPriority.Normal,
            tags: []
        }
    }
    
    fn with_priority(source: String, priority: EventPriority) -> Self {
        EventMeta {
            id: @native("uuid_v4"),
            timestamp: @native("timestamp_ms"),
            source: source,
            priority: priority,
            tags: []
        }
    }
    
    fn with_tags(source: String, tags: [String]) -> Self {
        EventMeta {
            id: @native("uuid_v4"),
            timestamp: @native("timestamp_ms"),
            source: source,
            priority: EventPriority.Normal,
            tags: tags
        }
    }
}

/// Generic event wrapper
struct Event<T> {
    name: String,
    data: T,
    meta: EventMeta
}

impl<T> Event<T> {
    fn new(name: String, data: T, source: String) -> Self {
        Event {
            name: name,
            data: data,
            meta: EventMeta.new(source)
        }
    }
    
    fn with_priority(name: String, data: T, source: String, priority: EventPriority) -> Self {
        Event {
            name: name,
            data: data,
            meta: EventMeta.with_priority(source, priority)
        }
    }
}

/// Emitter error types
enum EmitterError {
    ListenerNotFound(String),
    MaxListenersExceeded(Int),
    EmitFailed(String),
    InvalidEvent(String)
}

// =============================================================================
// Emitter Trait
// =============================================================================

/// Core event emitter trait
trait Emitter {
    type EventData
    
    fn on(event: String, handler: fn(Event<Self.EventData>)) -> ListenerId
    fn once(event: String, handler: fn(Event<Self.EventData>)) -> ListenerId
    fn off(id: ListenerId) -> Bool
    fn off_all(event: String) -> Int
    fn emit(event: String, data: Self.EventData) -> Int
    fn listener_count(event: String) -> Int
    fn event_names() -> [String]
}

/// Listener identifier
struct ListenerId {
    id: Int,
    event: String
}

impl ListenerId {
    fn new(id: Int, event: String) -> Self {
        ListenerId { id: id, event: event }
    }
}

// =============================================================================
// Event Emitter Implementation
// =============================================================================

/// Listener wrapper
struct Listener<T> {
    id: Int,
    handler: fn(Event<T>),
    once: Bool,
    priority: EventPriority
}

/// Main event emitter actor
actor EventEmitter<T> {
    state listeners: Map<String, [Listener<T>]>
    state next_id: Int
    state max_listeners: Int
    state source_name: String
    state error_handler: Option<fn(EmitterError)>
    
    fn new(source: String) -> Self {
        EventEmitter {
            listeners: Map.new(),
            next_id: 0,
            max_listeners: 100,
            source_name: source,
            error_handler: None
        }
    }
    
    fn with_max_listeners(source: String, max: Int) -> Self {
        EventEmitter {
            listeners: Map.new(),
            next_id: 0,
            max_listeners: max,
            source_name: source,
            error_handler: None
        }
    }
    
    fn set_error_handler(handler: fn(EmitterError)) {
        self.error_handler = Some(handler)
    }
    
    fn on(event: String, handler: fn(Event<T>)) -> ListenerId {
        self.add_listener(event, handler, false, EventPriority.Normal)
    }
    
    fn on_priority(event: String, handler: fn(Event<T>), priority: EventPriority) -> ListenerId {
        self.add_listener(event, handler, false, priority)
    }
    
    fn once(event: String, handler: fn(Event<T>)) -> ListenerId {
        self.add_listener(event, handler, true, EventPriority.Normal)
    }
    
    fn prepend(event: String, handler: fn(Event<T>)) -> ListenerId {
        self.add_listener_at(event, handler, false, EventPriority.Critical, 0)
    }
    
    fn add_listener(event: String, handler: fn(Event<T>), once: Bool, priority: EventPriority) -> ListenerId {
        let id = self.next_id
        self.next_id += 1
        
        let listener = Listener {
            id: id,
            handler: handler,
            once: once,
            priority: priority
        }
        
        if !self.listeners.contains_key(event) {
            self.listeners.insert(event.clone(), [])
        }
        
        let list = self.listeners.get_mut(event).unwrap()
        
        if list.len() >= self.max_listeners {
            if let Some(err_handler) = self.error_handler {
                err_handler(EmitterError.MaxListenersExceeded(self.max_listeners))
            }
        }
        
        // Insert sorted by priority (higher priority first)
        var inserted = false
        for (i, l) in list.iter().enumerate() {
            if priority.value() > l.priority.value() {
                list.insert(i, listener)
                inserted = true
                break
            }
        }
        if !inserted {
            list.push(listener)
        }
        
        ListenerId.new(id, event)
    }
    
    fn add_listener_at(event: String, handler: fn(Event<T>), once: Bool, priority: EventPriority, index: Int) -> ListenerId {
        let id = self.next_id
        self.next_id += 1
        
        let listener = Listener {
            id: id,
            handler: handler,
            once: once,
            priority: priority
        }
        
        if !self.listeners.contains_key(event) {
            self.listeners.insert(event.clone(), [])
        }
        
        let list = self.listeners.get_mut(event).unwrap()
        list.insert(index.min(list.len()), listener)
        
        ListenerId.new(id, event)
    }
    
    fn off(id: ListenerId) -> Bool {
        if let Some(list) = self.listeners.get_mut(id.event) {
            for (i, l) in list.iter().enumerate() {
                if l.id == id.id {
                    list.remove(i)
                    return true
                }
            }
        }
        false
    }
    
    fn off_all(event: String) -> Int {
        if let Some(list) = self.listeners.remove(event) {
            list.len()
        } else {
            0
        }
    }
    
    fn clear() {
        self.listeners.clear()
    }
    
    fn emit(event: String, data: T) -> Int {
        self.emit_event(Event.new(event.clone(), data, self.source_name.clone()))
    }
    
    fn emit_priority(event: String, data: T, priority: EventPriority) -> Int {
        self.emit_event(Event.with_priority(event.clone(), data, self.source_name.clone(), priority))
    }
    
    fn emit_event(evt: Event<T>) -> Int {
        let event_name = evt.name.clone()
        var count = 0
        var to_remove = []
        
        if let Some(list) = self.listeners.get(event_name) {
            for (i, listener) in list.iter().enumerate() {
                (listener.handler)(evt.clone())
                count += 1
                if listener.once {
                    to_remove.push(i)
                }
            }
        }
        
        // Remove once listeners (in reverse order to maintain indices)
        if let Some(list) = self.listeners.get_mut(event_name) {
            for i in to_remove.iter().rev() {
                list.remove(*i)
            }
        }
        
        // Also emit to wildcard listeners
        if event_name != "*" {
            if let Some(list) = self.listeners.get("*") {
                for listener in list.iter() {
                    (listener.handler)(evt.clone())
                    count += 1
                }
            }
        }
        
        count
    }
    
    fn listener_count(event: String) -> Int {
        self.listeners.get(event).map(|l| l.len()).unwrap_or(0)
    }
    
    fn total_listener_count() -> Int {
        var count = 0
        for (_, list) in self.listeners.iter() {
            count += list.len()
        }
        count
    }
    
    fn event_names() -> [String] {
        self.listeners.keys().collect()
    }
    
    fn has_listeners(event: String) -> Bool {
        self.listener_count(event) > 0
    }
}

// =============================================================================
// Typed Event Emitter
// =============================================================================

/// Type-safe event emitter with predefined event types
struct TypedEmitter<E: EventType> {
    emitter: EventEmitter<E.Data>
}

trait EventType {
    type Data
    fn name() -> String
}

impl<E: EventType> TypedEmitter<E> {
    fn new(source: String) -> Self {
        TypedEmitter { emitter: EventEmitter.new(source) }
    }
    
    fn on(handler: fn(Event<E.Data>)) -> ListenerId {
        self.emitter.on(E.name(), handler)
    }
    
    fn once(handler: fn(Event<E.Data>)) -> ListenerId {
        self.emitter.once(E.name(), handler)
    }
    
    fn emit(data: E.Data) -> Int {
        self.emitter.emit(E.name(), data)
    }
    
    fn off(id: ListenerId) -> Bool {
        self.emitter.off(id)
    }
}

// =============================================================================
// Async Event Emitter
// =============================================================================

/// Async event emitter with Future-based handlers
actor AsyncEmitter<T> {
    state handlers: Map<String, [fn(Event<T>) -> Future<()>]>
    state source_name: String
    
    fn new(source: String) -> Self {
        AsyncEmitter {
            handlers: Map.new(),
            source_name: source
        }
    }
    
    fn on(event: String, handler: fn(Event<T>) -> Future<()>) {
        if !self.handlers.contains_key(event) {
            self.handlers.insert(event.clone(), [])
        }
        self.handlers.get_mut(event).unwrap().push(handler)
    }
    
    fn emit(event: String, data: T) -> Future<Int> {
        let evt = Event.new(event.clone(), data, self.source_name.clone())
        var futures = []
        
        if let Some(list) = self.handlers.get(event) {
            for handler in list.iter() {
                futures.push(handler(evt.clone()))
            }
        }
        
        Future.join_all(futures).map(|results| results.len())
    }
    
    fn emit_parallel(event: String, data: T) -> Future<[Result<(), Error>]> {
        let evt = Event.new(event.clone(), data, self.source_name.clone())
        var futures = []
        
        if let Some(list) = self.handlers.get(event) {
            for handler in list.iter() {
                futures.push(handler(evt.clone()).catch(|e| Err(e)))
            }
        }
        
        Future.join_all(futures)
    }
    
    fn emit_sequential(event: String, data: T) -> Future<Int> {
        async {
            let evt = Event.new(event.clone(), data, self.source_name.clone())
            var count = 0
            
            if let Some(list) = self.handlers.get(event) {
                for handler in list.iter() {
                    handler(evt.clone()).await
                    count += 1
                }
            }
            
            count
        }
    }
}

// =============================================================================
// Buffered Emitter
// =============================================================================

/// Emitter that buffers events when no listeners are present
actor BufferedEmitter<T: Clone> {
    state emitter: EventEmitter<T>
    state buffer: Map<String, [Event<T>]>
    state buffer_size: Int
    
    fn new(source: String, buffer_size: Int) -> Self {
        BufferedEmitter {
            emitter: EventEmitter.new(source),
            buffer: Map.new(),
            buffer_size: buffer_size
        }
    }
    
    fn on(event: String, handler: fn(Event<T>)) -> ListenerId {
        // Replay buffered events
        if let Some(buffered) = self.buffer.remove(event) {
            for evt in buffered {
                handler(evt)
            }
        }
        self.emitter.on(event, handler)
    }
    
    fn emit(event: String, data: T) -> Int {
        if self.emitter.has_listeners(event) {
            self.emitter.emit(event, data)
        } else {
            // Buffer the event
            if !self.buffer.contains_key(event) {
                self.buffer.insert(event.clone(), [])
            }
            let buf = self.buffer.get_mut(event).unwrap()
            if buf.len() < self.buffer_size {
                buf.push(Event.new(event, data, self.emitter.source_name.clone()))
            }
            0
        }
    }
    
    fn flush(event: String) {
        self.buffer.remove(event)
    }
    
    fn flush_all() {
        self.buffer.clear()
    }
}

// =============================================================================
// Namespaced Emitter
// =============================================================================

/// Emitter with namespace support (e.g., "user.created", "user.updated")
actor NamespacedEmitter<T> {
    state emitter: EventEmitter<T>
    state separator: String
    
    fn new(source: String) -> Self {
        NamespacedEmitter {
            emitter: EventEmitter.new(source),
            separator: "."
        }
    }
    
    fn with_separator(source: String, sep: String) -> Self {
        NamespacedEmitter {
            emitter: EventEmitter.new(source),
            separator: sep
        }
    }
    
    fn on(namespace: String, event: String, handler: fn(Event<T>)) -> ListenerId {
        let full_name = format!("{}{}{}", namespace, self.separator, event)
        self.emitter.on(full_name, handler)
    }
    
    fn on_namespace(namespace: String, handler: fn(Event<T>)) -> ListenerId {
        // Listen to all events in namespace using wildcard
        let pattern = format!("{}{}*", namespace, self.separator)
        self.emitter.on(pattern, handler)
    }
    
    fn emit(namespace: String, event: String, data: T) -> Int {
        let full_name = format!("{}{}{}", namespace, self.separator, event)
        var count = self.emitter.emit(full_name.clone(), data.clone())
        
        // Also notify namespace listeners
        let ns_pattern = format!("{}{}*", namespace, self.separator)
        count += self.emitter.emit(ns_pattern, data)
        
        count
    }
    
    fn off_namespace(namespace: String) -> Int {
        var count = 0
        let prefix = format!("{}{}", namespace, self.separator)
        for name in self.emitter.event_names() {
            if name.starts_with(prefix) {
                count += self.emitter.off_all(name)
            }
        }
        count
    }
}

// =============================================================================
// Event Emitter Combinators
// =============================================================================

/// Merge multiple emitters into one
fn merge<T>(emitters: [EventEmitter<T>], target: EventEmitter<T>) {
    for emitter in emitters {
        emitter.on("*", |evt| {
            target.emit_event(evt)
        })
    }
}

/// Pipe events from one emitter to another
fn pipe<T>(source: EventEmitter<T>, target: EventEmitter<T>, events: [String]) {
    for event in events {
        source.on(event.clone(), |evt| {
            target.emit_event(evt)
        })
    }
}

/// Filter events before forwarding
fn filter_pipe<T>(
    source: EventEmitter<T>,
    target: EventEmitter<T>,
    predicate: fn(Event<T>) -> Bool
) {
    source.on("*", |evt| {
        if predicate(evt.clone()) {
            target.emit_event(evt)
        }
    })
}

/// Transform events before forwarding
fn map_pipe<T, U>(
    source: EventEmitter<T>,
    target: EventEmitter<U>,
    transform: fn(Event<T>) -> Event<U>
) {
    source.on("*", |evt| {
        target.emit_event(transform(evt))
    })
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Create a simple emitter
fn emitter<T>(source: String) -> EventEmitter<T> {
    EventEmitter.new(source)
}

/// Create an async emitter
fn async_emitter<T>(source: String) -> AsyncEmitter<T> {
    AsyncEmitter.new(source)
}

/// Create a buffered emitter
fn buffered<T: Clone>(source: String, size: Int) -> BufferedEmitter<T> {
    BufferedEmitter.new(source, size)
}

/// Create a namespaced emitter
fn namespaced<T>(source: String) -> NamespacedEmitter<T> {
    NamespacedEmitter.new(source)
}

// =============================================================================
// Tests
// =============================================================================

test "basic emit and listen" {
    let em = EventEmitter::<Int>.new("test")
    var received = 0
    
    em.on("number", |evt| { received = evt.data })
    em.emit("number", 42)
    
    assert_eq(received, 42)?
}

test "once listener" {
    let em = EventEmitter::<Int>.new("test")
    var count = 0
    
    em.once("event", |_| { count += 1 })
    em.emit("event", 1)
    em.emit("event", 2)
    
    assert_eq(count, 1)?
}

test "off listener" {
    let em = EventEmitter::<Int>.new("test")
    var count = 0
    
    let id = em.on("event", |_| { count += 1 })
    em.emit("event", 1)
    em.off(id)
    em.emit("event", 2)
    
    assert_eq(count, 1)?
}

test "wildcard listener" {
    let em = EventEmitter::<String>.new("test")
    var events = []
    
    em.on("*", |evt| { events.push(evt.name.clone()) })
    em.emit("foo", "a")
    em.emit("bar", "b")
    
    assert_eq(events, ["foo", "bar"])?
}

test "priority ordering" {
    let em = EventEmitter::<Int>.new("test")
    var order = []
    
    em.on_priority("event", |_| { order.push(1) }, EventPriority.Low)
    em.on_priority("event", |_| { order.push(2) }, EventPriority.High)
    em.on_priority("event", |_| { order.push(3) }, EventPriority.Normal)
    em.emit("event", 0)
    
    assert_eq(order, [2, 3, 1])?
}

test "listener count" {
    let em = EventEmitter::<Int>.new("test")
    
    em.on("a", |_| {})
    em.on("a", |_| {})
    em.on("b", |_| {})
    
    assert_eq(em.listener_count("a"), 2)?
    assert_eq(em.listener_count("b"), 1)?
    assert_eq(em.total_listener_count(), 3)?
}

test "buffered emitter" {
    let em = BufferedEmitter::<Int>.new("test", 10)
    
    // Emit before listener
    em.emit("event", 1)
    em.emit("event", 2)
    
    var received = []
    em.on("event", |evt| { received.push(evt.data) })
    
    // Should receive buffered events
    assert_eq(received, [1, 2])?
}

test "namespaced emitter" {
    let em = NamespacedEmitter::<String>.new("test")
    var received = []
    
    em.on("user", "created", |evt| { received.push(evt.data.clone()) })
    em.emit("user", "created", "john")
    
    assert_eq(received, ["john"])?
}
