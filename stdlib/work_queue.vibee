// =============================================================================
// Vibee OS â€” Work Queue Module
// Task distribution and worker pool management
// =============================================================================

// -----------------------------------------------------------------------------
// Work Item
// -----------------------------------------------------------------------------

/// Work item with metadata
struct WorkItem<T> {
    id: String
    data: T
    created_at: Instant
    started_at: Option<Instant>
    completed_at: Option<Instant>
    worker_id: Option<String>
    retry_count: Int
    max_retries: Int
    timeout: Option<Duration>
    
    fn new(data: T) -> Self {
        WorkItem {
            id: UUID.v4(),
            data: data,
            created_at: Instant.now(),
            started_at: None,
            completed_at: None,
            worker_id: None,
            retry_count: 0,
            max_retries: 3,
            timeout: None
        }
    }
    
    fn with_timeout(timeout: Duration) -> Self {
        self.timeout = Some(timeout)
        self
    }
    
    fn with_max_retries(max: Int) -> Self {
        self.max_retries = max
        self
    }
    
    fn can_retry() -> Bool {
        self.retry_count < self.max_retries
    }
    
    fn is_timed_out() -> Bool {
        match (self.started_at, self.timeout) {
            (Some(start), Some(timeout)) => Instant.now() - start > timeout
            _ => false
        }
    }
    
    fn duration() -> Option<Duration> {
        match (self.started_at, self.completed_at) {
            (Some(start), Some(end)) => Some(end - start)
            _ => None
        }
    }
}

/// Work result
enum WorkResult<T, E> {
    Success(T)
    Failure(E)
    Retry
    Timeout
}

// -----------------------------------------------------------------------------
// Work Queue Actor
// -----------------------------------------------------------------------------

/// Distributed work queue
actor WorkQueue<T, R> {
    state pending: Deque<WorkItem<T>>
    state in_progress: Map<String, WorkItem<T>>
    state completed: Map<String, WorkResult<R, String>>
    state workers: Map<String, WorkerInfo>
    state handler: Option<fn(T) -> R>
    state metrics: WorkQueueMetrics
    state closed: Bool
    state visibility_timeout: Duration
    
    fn new() -> Self {
        WorkQueue {
            pending: Deque.new(),
            in_progress: Map.empty(),
            completed: Map.empty(),
            workers: Map.empty(),
            handler: None,
            metrics: WorkQueueMetrics.new(),
            closed: false,
            visibility_timeout: Duration.seconds(30)
        }
    }
    
    fn with_handler(handler: fn(T) -> R) -> Self {
        let mut q = Self.new()
        q.handler = Some(handler)
        q
    }
    
    fn with_visibility_timeout(timeout: Duration) -> Self {
        let mut q = Self.new()
        q.visibility_timeout = timeout
        q
    }
    
    /// Submit work item
    fn submit(data: T) -> String {
        let item = WorkItem.new(data)
        let id = item.id.clone()
        self.pending.push_back(item)
        self.metrics.submitted += 1
        id
    }
    
    /// Submit with options
    fn submit_item(item: WorkItem<T>) -> String {
        let id = item.id.clone()
        self.pending.push_back(item)
        self.metrics.submitted += 1
        id
    }
    
    /// Claim next work item (for workers)
    fn claim(worker_id: String) -> Option<WorkItem<T>> {
        self.check_timeouts()
        
        if let Some(mut item) = self.pending.pop_front() {
            item.started_at = Some(Instant.now())
            item.worker_id = Some(worker_id.clone())
            self.in_progress.set(item.id.clone(), item.clone())
            self.update_worker(worker_id, true)
            self.metrics.claimed += 1
            return Some(item)
        }
        None
    }
    
    /// Complete work item
    fn complete(item_id: String, result: R) -> Result<(), WorkQueueError> {
        match self.in_progress.remove(item_id.clone()) {
            Some(mut item) => {
                item.completed_at = Some(Instant.now())
                if let Some(wid) = item.worker_id {
                    self.update_worker(wid, false)
                }
                self.completed.set(item_id, WorkResult.Success(result))
                self.metrics.completed += 1
                Ok(())
            }
            None => Err(WorkQueueError.ItemNotFound)
        }
    }
    
    /// Fail work item
    fn fail(item_id: String, error: String, retry: Bool) -> Result<(), WorkQueueError> {
        match self.in_progress.remove(item_id.clone()) {
            Some(mut item) => {
                if let Some(wid) = item.worker_id.clone() {
                    self.update_worker(wid, false)
                }
                
                if retry && item.can_retry() {
                    item.retry_count += 1
                    item.started_at = None
                    item.worker_id = None
                    self.pending.push_back(item)
                    self.metrics.retried += 1
                } else {
                    self.completed.set(item_id, WorkResult.Failure(error))
                    self.metrics.failed += 1
                }
                Ok(())
            }
            None => Err(WorkQueueError.ItemNotFound)
        }
    }
    
    /// Get result for work item
    fn get_result(item_id: String) -> Option<WorkResult<R, String>> {
        self.completed.get(item_id)
    }
    
    /// Check for timed out items
    fn check_timeouts() {
        let now = Instant.now()
        var timed_out = []
        
        for (id, item) in self.in_progress {
            if let Some(start) = item.started_at {
                let timeout = item.timeout.unwrap_or(self.visibility_timeout)
                if now - start > timeout {
                    timed_out.push(id)
                }
            }
        }
        
        for id in timed_out {
            if let Some(mut item) = self.in_progress.remove(id) {
                if let Some(wid) = item.worker_id.clone() {
                    self.update_worker(wid, false)
                }
                
                if item.can_retry() {
                    item.retry_count += 1
                    item.started_at = None
                    item.worker_id = None
                    self.pending.push_front(item)
                    self.metrics.retried += 1
                } else {
                    self.completed.set(id, WorkResult.Timeout)
                    self.metrics.timed_out += 1
                }
            }
        }
    }
    
    fn update_worker(worker_id: String, busy: Bool) {
        let info = self.workers.entry(worker_id).or_insert(WorkerInfo.new(worker_id))
        info.busy = busy
        info.last_seen = Instant.now()
        if !busy { info.completed += 1 }
    }
    
    /// Register worker
    fn register_worker(worker_id: String) {
        self.workers.set(worker_id.clone(), WorkerInfo.new(worker_id))
    }
    
    /// Get queue metrics
    fn metrics() -> WorkQueueMetrics { self.metrics.clone() }
    
    /// Get worker info
    fn worker_info(worker_id: String) -> Option<WorkerInfo> {
        self.workers.get(worker_id)
    }
    
    fn close() { self.closed = true }
    fn pending_count() -> Int { self.pending.len() }
    fn in_progress_count() -> Int { self.in_progress.len() }
    fn worker_count() -> Int { self.workers.len() }
}

/// Worker information
struct WorkerInfo {
    id: String
    busy: Bool
    completed: Int
    last_seen: Instant
    
    fn new(id: String) -> Self {
        WorkerInfo { id: id, busy: false, completed: 0, last_seen: Instant.now() }
    }
}

/// Work queue metrics
struct WorkQueueMetrics {
    submitted: Int
    claimed: Int
    completed: Int
    failed: Int
    retried: Int
    timed_out: Int
    
    fn new() -> Self {
        WorkQueueMetrics {
            submitted: 0, claimed: 0, completed: 0,
            failed: 0, retried: 0, timed_out: 0
        }
    }
}

// -----------------------------------------------------------------------------
// Worker Pool
// -----------------------------------------------------------------------------

/// Worker pool for processing work queue
actor WorkerPool<T, R> {
    state queue: WorkQueue<T, R>
    state workers: [Worker<T, R>]
    state handler: fn(T) -> Result<R, String>
    state running: Bool
    
    fn new(queue: WorkQueue<T, R>, handler: fn(T) -> Result<R, String>, size: Int) -> Self {
        let pool = WorkerPool {
            queue: queue,
            workers: [],
            handler: handler,
            running: false
        }
        
        for i in 0..size {
            pool.workers.push(Worker.new(format!("worker-{}", i), queue, handler))
        }
        pool
    }
    
    /// Start all workers
    fn start() {
        if self.running { return }
        self.running = true
        for worker in self.workers { worker.start() }
    }
    
    /// Stop all workers
    fn stop() {
        self.running = false
        for worker in self.workers { worker.stop() }
    }
    
    /// Scale workers
    fn scale(new_size: Int) {
        let current = self.workers.len()
        
        if new_size > current {
            for i in current..new_size {
                let w = Worker.new(format!("worker-{}", i), self.queue, self.handler)
                if self.running { w.start() }
                self.workers.push(w)
            }
        } else if new_size < current {
            for _ in new_size..current {
                if let Some(w) = self.workers.pop() { w.stop() }
            }
        }
    }
    
    fn worker_count() -> Int { self.workers.len() }
    fn is_running() -> Bool { self.running }
}

/// Individual worker
actor Worker<T, R> {
    state id: String
    state queue: WorkQueue<T, R>
    state handler: fn(T) -> Result<R, String>
    state running: Bool
    
    fn new(id: String, queue: WorkQueue<T, R>, handler: fn(T) -> Result<R, String>) -> Self {
        Worker { id: id, queue: queue, handler: handler, running: false }
    }
    
    fn start() {
        if self.running { return }
        self.running = true
        self.queue.register_worker(self.id.clone())
        spawn { self.run_loop() }
    }
    
    fn stop() { self.running = false }
    
    fn run_loop() {
        while self.running {
            match self.queue.claim(self.id.clone()) {
                Some(item) => {
                    match (self.handler)(item.data) {
                        Ok(result) => self.queue.complete(item.id, result)
                        Err(e) => self.queue.fail(item.id, e, true)
                    }
                }
                None => @native("sleep", Duration.milliseconds(100))
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum WorkQueueError {
    ItemNotFound
    QueueClosed
    Timeout
    
    fn message() -> String {
        match self {
            ItemNotFound => "Work item not found"
            QueueClosed => "Queue is closed"
            Timeout => "Operation timed out"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "work queue basic" {
    let wq = WorkQueue::<Int, Int>.new()
    
    let id = wq.submit(42)
    assert_eq(wq.pending_count(), 1)?
    
    let item = wq.claim("worker-1").unwrap()
    assert_eq(item.data, 42)?
    assert_eq(wq.in_progress_count(), 1)?
    
    wq.complete(item.id, 84)?
    assert_eq(wq.get_result(id), Some(WorkResult.Success(84)))?
}

test "work queue retry" {
    let wq = WorkQueue::<Int, Int>.new()
    
    let id = wq.submit(1)
    let item = wq.claim("worker-1").unwrap()
    
    wq.fail(item.id.clone(), "error", true)?
    assert_eq(wq.pending_count(), 1)?
    
    let item2 = wq.claim("worker-1").unwrap()
    assert_eq(item2.retry_count, 1)?
}

test "worker pool" {
    let wq = WorkQueue::<Int, Int>.new()
    let pool = WorkerPool.new(wq, |x| Ok(x * 2), 2)
    
    wq.submit(1)
    wq.submit(2)
    
    pool.start()
    @native("sleep", Duration.milliseconds(100))
    pool.stop()
    
    assert(wq.metrics().completed >= 1)?
}
