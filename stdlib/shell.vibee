// =============================================================================
// Vibee OS â€” Shell Module
// Command execution, shell scripting, and command parsing
// =============================================================================

// -----------------------------------------------------------------------------
// Command Execution
// -----------------------------------------------------------------------------

/// Execute shell command
actor ShellCommand {
    state command: String
    state args: [String]
    state env: Map<String, String>
    state cwd: String?
    state stdin: Stream<Byte>?
    state timeout: Duration?
    
    /// Create command
    init(cmd: String) {
        self.command = cmd
        self.args = []
        self.env = Map.empty()
    }
    
    /// Add argument
    on arg(value: String) -> Self {
        self.args.append(value)
        self
    }
    
    /// Add multiple arguments
    on args(values: [String]) -> Self {
        self.args.extend(values)
        self
    }
    
    /// Set environment variable
    on env(key: String, value: String) -> Self {
        self.env.set(key, value)
        self
    }
    
    /// Set working directory
    on cwd(path: String) -> Self {
        self.cwd = path
        self
    }
    
    /// Set stdin
    on stdin(stream: Stream<Byte>) -> Self {
        self.stdin = stream
        self
    }
    
    /// Set timeout
    on timeout(duration: Duration) -> Self {
        self.timeout = duration
        self
    }
    
    /// Execute and wait for completion
    on run() -> Result<CommandOutput, ShellError> {
        @native("shell_run")
    }
    
    /// Execute and return immediately
    on spawn() -> Result<Process, ShellError> {
        @native("shell_spawn")
    }
    
    /// Execute and capture output
    on output() -> Result<String, ShellError> {
        let result = self.run()?
        Ok(result.stdout)
    }
    
    /// Execute and stream output
    on stream() -> Stream<OutputLine> {
        @native("shell_stream")
    }
    
    /// Pipe to another command
    on pipe(next: ShellCommand) -> Pipeline {
        Pipeline.new([self, next])
    }
}

/// Command output
struct CommandOutput {
    stdout: String
    stderr: String
    exit_code: Int
    duration: Duration
    
    /// Check if successful
    fn success() -> Bool {
        self.exit_code == 0
    }
    
    /// Get combined output
    fn combined() -> String {
        self.stdout + self.stderr
    }
    
    /// Get output lines
    fn lines() -> [String] {
        self.stdout.lines()
    }
}

/// Output line with source
enum OutputLine {
    Stdout(String)
    Stderr(String)
    Exit(Int)
}

// -----------------------------------------------------------------------------
// Shell Shortcuts
// -----------------------------------------------------------------------------

/// Quick command execution
fn sh(command: String) -> Result<String, ShellError> {
    ShellCommand.new(command).output()
}

/// Execute with shell interpretation
fn bash(script: String) -> Result<CommandOutput, ShellError> {
    ShellCommand.new("bash")
        .args(["-c", script])
        .run()
}

/// Execute silently (ignore output)
fn exec(command: String) -> Result<Int, ShellError> {
    let result = ShellCommand.new(command).run()?
    Ok(result.exit_code)
}

/// Check if command exists
fn which(command: String) -> Option<String> {
    match sh("which \(command)") {
        Ok(path) => Some(path.trim())
        Err(_) => None
    }
}

/// Check if command available
fn has_command(name: String) -> Bool {
    which(name).is_some()
}

// -----------------------------------------------------------------------------
// Pipeline
// -----------------------------------------------------------------------------

/// Command pipeline (cmd1 | cmd2 | cmd3)
actor Pipeline {
    state commands: [ShellCommand]
    
    /// Create pipeline
    init(commands: [ShellCommand]) {
        self.commands = commands
    }
    
    /// Add command to pipeline
    on pipe(cmd: ShellCommand) -> Self {
        self.commands.append(cmd)
        self
    }
    
    /// Execute pipeline
    on run() -> Result<CommandOutput, ShellError> {
        @native("pipeline_run")
    }
    
    /// Stream pipeline output
    on stream() -> Stream<OutputLine> {
        @native("pipeline_stream")
    }
}

/// Pipeline builder using | operator
operator | (left: ShellCommand, right: ShellCommand) -> Pipeline {
    Pipeline.new([left, right])
}

operator | (left: Pipeline, right: ShellCommand) -> Pipeline {
    left.pipe(right)
}

// -----------------------------------------------------------------------------
// Command Parser
// -----------------------------------------------------------------------------

/// Parse shell command string
actor CommandParser {
    /// Parse command line into parts
    fn parse(line: String) -> Result<ParsedCommand, ParseError> {
        let tokens = self.tokenize(line)?
        self.build_command(tokens)
    }
    
    /// Tokenize respecting quotes
    fn tokenize(input: String) -> Result<[Token], ParseError> {
        let tokens = []
        let current = StringBuilder.new()
        let in_single_quote = false
        let in_double_quote = false
        let escape_next = false
        
        for char in input.chars() {
            if escape_next {
                current.append(char)
                escape_next = false
                continue
            }
            
            match char {
                '\\' if !in_single_quote => {
                    escape_next = true
                }
                '\'' if !in_double_quote => {
                    in_single_quote = !in_single_quote
                }
                '"' if !in_single_quote => {
                    in_double_quote = !in_double_quote
                }
                ' ' | '\t' if !in_single_quote && !in_double_quote => {
                    if current.len() > 0 {
                        tokens.append(Token.Word(current.build()))
                        current = StringBuilder.new()
                    }
                }
                '|' if !in_single_quote && !in_double_quote => {
                    if current.len() > 0 {
                        tokens.append(Token.Word(current.build()))
                        current = StringBuilder.new()
                    }
                    tokens.append(Token.Pipe)
                }
                '>' if !in_single_quote && !in_double_quote => {
                    if current.len() > 0 {
                        tokens.append(Token.Word(current.build()))
                        current = StringBuilder.new()
                    }
                    tokens.append(Token.Redirect)
                }
                '<' if !in_single_quote && !in_double_quote => {
                    if current.len() > 0 {
                        tokens.append(Token.Word(current.build()))
                        current = StringBuilder.new()
                    }
                    tokens.append(Token.Input)
                }
                '&' if !in_single_quote && !in_double_quote => {
                    if current.len() > 0 {
                        tokens.append(Token.Word(current.build()))
                        current = StringBuilder.new()
                    }
                    tokens.append(Token.Background)
                }
                _ => {
                    current.append(char)
                }
            }
        }
        
        if in_single_quote || in_double_quote {
            return Err(ParseError.UnterminatedQuote)
        }
        
        if current.len() > 0 {
            tokens.append(Token.Word(current.build()))
        }
        
        Ok(tokens)
    }
    
    /// Build command from tokens
    fn build_command(tokens: [Token]) -> Result<ParsedCommand, ParseError> {
        // Implementation builds ParsedCommand from tokens
        @native("command_parser_build")
    }
}

/// Shell token
enum Token {
    Word(String)
    Pipe
    Redirect
    Append
    Input
    Background
    And
    Or
    Semicolon
}

/// Parsed command structure
struct ParsedCommand {
    program: String
    args: [String]
    redirects: [Redirect]
    background: Bool
    next: Option<(Connector, Box<ParsedCommand>)>
}

/// Redirect specification
struct Redirect {
    kind: RedirectKind
    target: String
}

enum RedirectKind {
    StdoutTo
    StdoutAppend
    StderrTo
    StderrAppend
    StdinFrom
    Both
}

enum Connector {
    Pipe
    And
    Or
    Sequence
}

// -----------------------------------------------------------------------------
// Variable Expansion
// -----------------------------------------------------------------------------

/// Expand shell variables in string
fn expand(template: String, vars: Map<String, String>) -> String {
    let result = template
    
    // Expand ${VAR} and $VAR patterns
    for (key, value) in vars {
        result = result
            .replace("${\(key)}", value)
            .replace("$\(key)", value)
    }
    
    result
}

/// Expand with environment variables
fn expand_env(template: String) -> String {
    let env_vars = Environment.all()
    expand(template, env_vars)
}

/// Expand glob patterns
fn glob(pattern: String) -> [String] {
    @native("shell_glob")
}

/// Expand tilde to home directory
fn expand_tilde(path: String) -> String {
    if path.starts_with("~") {
        let home = Environment.home_dir()
        path.replace_first("~", home)
    } else {
        path
    }
}

// -----------------------------------------------------------------------------
// Script Execution
// -----------------------------------------------------------------------------

/// Shell script builder
actor Script {
    state lines: [String]
    state shell: String
    state strict: Bool
    
    /// Create new script
    init() {
        self.lines = []
        self.shell = "/bin/bash"
        self.strict = true
    }
    
    /// Set shell
    on shell(path: String) -> Self {
        self.shell = path
        self
    }
    
    /// Enable/disable strict mode
    on strict(enabled: Bool) -> Self {
        self.strict = enabled
        self
    }
    
    /// Add line to script
    on line(cmd: String) -> Self {
        self.lines.append(cmd)
        self
    }
    
    /// Add conditional
    on if_then(condition: String, then_cmd: String) -> Self {
        self.lines.append("if \(condition); then")
        self.lines.append("  \(then_cmd)")
        self.lines.append("fi")
        self
    }
    
    /// Add loop
    on for_each(var: String, items: String, body: String) -> Self {
        self.lines.append("for \(var) in \(items); do")
        self.lines.append("  \(body)")
        self.lines.append("done")
        self
    }
    
    /// Build script content
    on build() -> String {
        var content = "#!\(self.shell)\n"
        
        if self.strict {
            content += "set -euo pipefail\n"
        }
        
        content += "\n"
        content += self.lines.join("\n")
        content
    }
    
    /// Execute script
    on run() -> Result<CommandOutput, ShellError> {
        let content = self.build()
        ShellCommand.new(self.shell)
            .args(["-c", content])
            .run()
    }
    
    /// Save to file
    on save(path: String) -> Result<(), IOError> {
        let content = self.build()
        File.write(path, content)?
        File.chmod(path, 0o755)
    }
}

// -----------------------------------------------------------------------------
// Interactive Shell
// -----------------------------------------------------------------------------

/// Interactive shell session
actor ShellSession {
    state process: Process?
    state shell: String
    
    /// Start shell session
    init(shell: String = "/bin/bash") {
        self.shell = shell
    }
    
    /// Start interactive session
    on start() -> Result<(), ShellError> {
        self.process = ShellCommand.new(self.shell)
            .args(["-i"])
            .spawn()?
        Ok(())
    }
    
    /// Send command to shell
    on send(command: String) -> Result<String, ShellError> {
        guard let proc = self.process else {
            return Err(ShellError.NotStarted)
        }
        
        proc.stdin.write("\(command)\n")?
        proc.read_until_prompt()
    }
    
    /// Close session
    on close() -> Result<(), ShellError> {
        if let proc = self.process {
            proc.stdin.write("exit\n")?
            proc.wait()?
        }
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Shell Errors
// -----------------------------------------------------------------------------

enum ShellError {
    CommandNotFound(String)
    ExecutionFailed(Int, String)
    Timeout
    Interrupted
    PermissionDenied
    NotStarted
    IOError(String)
    
    fn message() -> String {
        match self {
            .CommandNotFound(cmd) => "Command not found: \(cmd)"
            .ExecutionFailed(code, msg) => "Command failed (\(code)): \(msg)"
            .Timeout => "Command timed out"
            .Interrupted => "Command interrupted"
            .PermissionDenied => "Permission denied"
            .NotStarted => "Shell session not started"
            .IOError(msg) => "I/O error: \(msg)"
        }
    }
}

enum ParseError {
    UnterminatedQuote
    UnexpectedToken(String)
    EmptyCommand
    InvalidRedirect
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "basic command execution" {
    let result = sh("echo hello")?
    assert(result.trim() == "hello")
}

test "command with arguments" {
    let output = ShellCommand.new("echo")
        .args(["hello", "world"])
        .output()?
    assert(output.trim() == "hello world")
}

test "command parser" {
    let parsed = CommandParser.parse("ls -la | grep foo")?
    assert(parsed.program == "ls")
    assert(parsed.args == ["-la"])
}

test "variable expansion" {
    let vars = Map.from([("NAME", "world")])
    let result = expand("hello $NAME", vars)
    assert(result == "hello world")
}

test "script builder" {
    let script = Script.new()
        .line("echo 'Starting'")
        .line("ls -la")
        .build()
    
    assert(script.contains("#!/bin/bash"))
    assert(script.contains("set -euo pipefail"))
}
