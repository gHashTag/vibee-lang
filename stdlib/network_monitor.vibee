// =============================================================================
// Vibee OS — Network Monitor Module
// HTTP/WebSocket traffic monitoring, request inspection, and network debugging
// =============================================================================

// -----------------------------------------------------------------------------
// Network Request/Response Types
// -----------------------------------------------------------------------------

enum HttpMethod { GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS }

struct NetworkRequest {
    id: Int
    method: HttpMethod
    url: String
    headers: Map<String, String>
    body: Option<[UInt8]>
    timestamp: Instant
    initiator: Option<String>
}

struct NetworkResponse {
    request_id: Int
    status: Int
    status_text: String
    headers: Map<String, String>
    body: Option<[UInt8]>
    timestamp: Instant
    duration: Duration
}

struct NetworkEntry {
    request: NetworkRequest
    response: Option<NetworkResponse>
    error: Option<NetworkError>
    timing: RequestTiming
}

struct NetworkError {
    code: String
    message: String
    timestamp: Instant
}

struct RequestTiming {
    dns_start: Option<Instant>
    dns_end: Option<Instant>
    connect_start: Option<Instant>
    connect_end: Option<Instant>
    ssl_start: Option<Instant>
    ssl_end: Option<Instant>
    send_start: Option<Instant>
    send_end: Option<Instant>
    receive_start: Option<Instant>
    receive_end: Option<Instant>
    
    fn dns_time() -> Option<Duration> {
        match (self.dns_start, self.dns_end) {
            (Some(s), Some(e)) => Some(e - s)
            _ => None
        }
    }
    
    fn connect_time() -> Option<Duration> {
        match (self.connect_start, self.connect_end) {
            (Some(s), Some(e)) => Some(e - s)
            _ => None
        }
    }
    
    fn total_time() -> Option<Duration> {
        match (self.dns_start, self.receive_end) {
            (Some(s), Some(e)) => Some(e - s)
            _ => None
        }
    }
}

// -----------------------------------------------------------------------------
// WebSocket Types
// -----------------------------------------------------------------------------

struct WebSocketConnection {
    id: Int
    url: String
    status: WebSocketStatus
    messages: [WebSocketMessage]
    opened_at: Instant
    closed_at: Option<Instant>
}

enum WebSocketStatus { Connecting, Open, Closing, Closed }

struct WebSocketMessage {
    direction: MessageDirection
    data: WebSocketData
    timestamp: Instant
}

enum MessageDirection { Sent, Received }
enum WebSocketData { Text(String), Binary([UInt8]) }

// -----------------------------------------------------------------------------
// Network Monitor
// -----------------------------------------------------------------------------

actor NetworkMonitor {
    state entries: [NetworkEntry]
    state websockets: Map<Int, WebSocketConnection>
    state filters: NetworkFilters
    state recording: Bool
    state max_entries: Int
    state listeners: [fn(NetworkEvent) -> ()]
    state next_id: Int
    
    fn new() -> Self {
        NetworkMonitor {
            entries: [],
            websockets: Map.new(),
            filters: NetworkFilters.default(),
            recording: true,
            max_entries: 1000,
            listeners: [],
            next_id: 1
        }
    }
    
    // -------------------------------------------------------------------------
    // Recording Control
    // -------------------------------------------------------------------------
    
    on start_recording() { self.recording = true }
    on stop_recording() { self.recording = false }
    on clear() { self.entries.clear(); self.websockets.clear() }
    
    // -------------------------------------------------------------------------
    // Request Tracking
    // -------------------------------------------------------------------------
    
    on record_request(method: HttpMethod, url: String, headers: Map<String, String>, body: Option<[UInt8]>) -> Int {
        if !self.recording { return 0 }
        
        let id = self.next_id
        self.next_id += 1
        
        let request = NetworkRequest {
            id: id,
            method: method,
            url: url,
            headers: headers,
            body: body,
            timestamp: Instant.now(),
            initiator: None
        }
        
        let entry = NetworkEntry {
            request: request.clone(),
            response: None,
            error: None,
            timing: RequestTiming {
                dns_start: None, dns_end: None,
                connect_start: None, connect_end: None,
                ssl_start: None, ssl_end: None,
                send_start: Some(Instant.now()), send_end: None,
                receive_start: None, receive_end: None
            }
        }
        
        self.entries.push(entry)
        self.emit(NetworkEvent.RequestStarted(request))
        
        if self.entries.len() > self.max_entries {
            self.entries.remove(0)
        }
        
        id
    }
    
    on record_response(request_id: Int, status: Int, status_text: String, headers: Map<String, String>, body: Option<[UInt8]>) {
        if !self.recording { return }
        
        if let Some(entry) = self.entries.iter_mut().find(|e| e.request.id == request_id) {
            let now = Instant.now()
            let response = NetworkResponse {
                request_id: request_id,
                status: status,
                status_text: status_text,
                headers: headers,
                body: body,
                timestamp: now,
                duration: now - entry.request.timestamp
            }
            
            entry.response = Some(response.clone())
            entry.timing.receive_end = Some(now)
            
            self.emit(NetworkEvent.ResponseReceived(response))
        }
    }
    
    on record_error(request_id: Int, code: String, message: String) {
        if !self.recording { return }
        
        if let Some(entry) = self.entries.iter_mut().find(|e| e.request.id == request_id) {
            let error = NetworkError {
                code: code,
                message: message,
                timestamp: Instant.now()
            }
            entry.error = Some(error.clone())
            self.emit(NetworkEvent.RequestFailed(request_id, error))
        }
    }
    
    // -------------------------------------------------------------------------
    // WebSocket Tracking
    // -------------------------------------------------------------------------
    
    on record_ws_open(url: String) -> Int {
        if !self.recording { return 0 }
        
        let id = self.next_id
        self.next_id += 1
        
        let conn = WebSocketConnection {
            id: id,
            url: url,
            status: WebSocketStatus.Open,
            messages: [],
            opened_at: Instant.now(),
            closed_at: None
        }
        
        self.websockets.insert(id, conn)
        self.emit(NetworkEvent.WebSocketOpened(id))
        id
    }
    
    on record_ws_message(conn_id: Int, direction: MessageDirection, data: WebSocketData) {
        if !self.recording { return }
        
        if let Some(conn) = self.websockets.get_mut(conn_id) {
            let msg = WebSocketMessage {
                direction: direction,
                data: data,
                timestamp: Instant.now()
            }
            conn.messages.push(msg.clone())
            self.emit(NetworkEvent.WebSocketMessage(conn_id, msg))
        }
    }
    
    on record_ws_close(conn_id: Int) {
        if let Some(conn) = self.websockets.get_mut(conn_id) {
            conn.status = WebSocketStatus.Closed
            conn.closed_at = Some(Instant.now())
            self.emit(NetworkEvent.WebSocketClosed(conn_id))
        }
    }
    
    // -------------------------------------------------------------------------
    // Filtering & Querying
    // -------------------------------------------------------------------------
    
    on set_filters(filters: NetworkFilters) { self.filters = filters }
    
    fn get_entries() -> [NetworkEntry] {
        self.entries.iter().filter(|e| self.filters.matches(e)).collect()
    }
    
    fn get_entry(id: Int) -> Option<NetworkEntry> {
        self.entries.iter().find(|e| e.request.id == id).cloned()
    }
    
    fn get_websockets() -> [WebSocketConnection] {
        self.websockets.values().collect()
    }
    
    // -------------------------------------------------------------------------
    // Statistics
    // -------------------------------------------------------------------------
    
    fn stats() -> NetworkStats {
        let entries = self.get_entries()
        let total = entries.len()
        let successful = entries.iter().filter(|e| {
            e.response.map(|r| r.status >= 200 && r.status < 400).unwrap_or(false)
        }).count()
        let failed = entries.iter().filter(|e| e.error.is_some()).count()
        
        let total_size = entries.iter()
            .filter_map(|e| e.response.as_ref())
            .filter_map(|r| r.body.as_ref())
            .map(|b| b.len())
            .sum()
        
        let avg_duration = if total > 0 {
            let total_ms: Int = entries.iter()
                .filter_map(|e| e.response.as_ref())
                .map(|r| r.duration.as_millis() as Int)
                .sum()
            Duration.from_millis(total_ms / total)
        } else {
            Duration.zero()
        }
        
        NetworkStats {
            total_requests: total,
            successful_requests: successful,
            failed_requests: failed,
            total_bytes: total_size,
            average_duration: avg_duration,
            websocket_connections: self.websockets.len()
        }
    }
    
    // -------------------------------------------------------------------------
    // Events
    // -------------------------------------------------------------------------
    
    on add_listener(listener: fn(NetworkEvent) -> ()) {
        self.listeners.push(listener)
    }
    
    fn emit(event: NetworkEvent) {
        for listener in self.listeners {
            listener(event.clone())
        }
    }
    
    // -------------------------------------------------------------------------
    // Rendering
    // -------------------------------------------------------------------------
    
    fn render() -> String {
        var output = StringBuilder.new()
        output.append("═══ Network Monitor ═══\n\n")
        
        let stats = self.stats()
        output.append(format!("Requests: {} total, {} ok, {} failed\n", 
            stats.total_requests, stats.successful_requests, stats.failed_requests))
        output.append(format!("Data: {} bytes, Avg: {:?}\n\n", stats.total_bytes, stats.average_duration))
        
        output.append("ID   │ Method │ Status │ Time    │ URL\n")
        output.append("─────┼────────┼────────┼─────────┼────────────────────\n")
        
        for entry in self.get_entries().iter().take(20) {
            let status = entry.response.map(|r| r.status.to_string()).unwrap_or("...".to_string())
            let time = entry.response.map(|r| format!("{:?}", r.duration)).unwrap_or("...".to_string())
            let url = if entry.request.url.len() > 30 {
                format!("{}...", entry.request.url[..27])
            } else {
                entry.request.url.clone()
            }
            
            output.append(format!("{:4} │ {:6} │ {:6} │ {:7} │ {}\n",
                entry.request.id, format!("{:?}", entry.request.method), status, time, url))
        }
        
        output.build()
    }
}

// -----------------------------------------------------------------------------
// Supporting Types
// -----------------------------------------------------------------------------

struct NetworkFilters {
    methods: Option<[HttpMethod]>
    status_codes: Option<(Int, Int)>
    url_pattern: Option<String>
    min_duration: Option<Duration>
    
    fn default() -> Self {
        NetworkFilters { methods: None, status_codes: None, url_pattern: None, min_duration: None }
    }
    
    fn matches(entry: NetworkEntry) -> Bool {
        if let Some(methods) = self.methods {
            if !methods.contains(entry.request.method) { return false }
        }
        if let Some((min, max)) = self.status_codes {
            if let Some(resp) = entry.response {
                if resp.status < min || resp.status > max { return false }
            }
        }
        if let Some(pattern) = self.url_pattern {
            if !entry.request.url.contains(pattern) { return false }
        }
        if let Some(min_dur) = self.min_duration {
            if let Some(resp) = entry.response {
                if resp.duration < min_dur { return false }
            }
        }
        true
    }
}

struct NetworkStats {
    total_requests: Int
    successful_requests: Int
    failed_requests: Int
    total_bytes: Int
    average_duration: Duration
    websocket_connections: Int
}

enum NetworkEvent {
    RequestStarted(NetworkRequest)
    ResponseReceived(NetworkResponse)
    RequestFailed(Int, NetworkError)
    WebSocketOpened(Int)
    WebSocketMessage(Int, WebSocketMessage)
    WebSocketClosed(Int)
}

// -----------------------------------------------------------------------------
// Global Instance
// -----------------------------------------------------------------------------

var NETWORK_MONITOR = NetworkMonitor.new()

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "network_monitor" {
    let monitor = NetworkMonitor.new()
    let id = monitor.record_request(HttpMethod.GET, "https://api.example.com", Map.new(), None)
    assert(id > 0)?
}

test "filters" {
    let filters = NetworkFilters.default()
    assert(filters.methods.is_none())?
}

test "stats" {
    let monitor = NetworkMonitor.new()
    let stats = monitor.stats()
    assert_eq(stats.total_requests, 0)?
}
