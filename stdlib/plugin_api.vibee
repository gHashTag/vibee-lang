// =============================================================================
// Vibee OS â€” Plugin API Module
// Core API for plugin development and integration
// =============================================================================

use result::{Result, Ok, Err}
use option::{Option, Some, None}

// =============================================================================
// Plugin Metadata
// =============================================================================

/// Plugin version information
struct PluginVersion {
    major: Int
    minor: Int
    patch: Int
    prerelease: Option<String>
}

impl PluginVersion {
    fn new(major: Int, minor: Int, patch: Int) -> Self {
        PluginVersion {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: None
        }
    }
    
    fn with_prerelease(major: Int, minor: Int, patch: Int, pre: String) -> Self {
        PluginVersion {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: Some(pre)
        }
    }
    
    fn parse(s: String) -> Option<Self> {
        let parts: [String] = s.split(".").collect()
        if parts.len() >= 3 {
            Some(PluginVersion {
                major: parts[0].parse().ok()?,
                minor: parts[1].parse().ok()?,
                patch: parts[2].parse().ok()?,
                prerelease: if parts.len() > 3 { Some(parts[3].clone()) } else { None }
            })
        } else { None }
    }
    
    fn to_string() -> String {
        let base = format!("{}.{}.{}", self.major, self.minor, self.patch)
        match self.prerelease {
            Some(pre) => format!("{}-{}", base, pre),
            None => base
        }
    }
    
    fn is_compatible(other: PluginVersion) -> Bool {
        self.major == other.major && self.minor >= other.minor
    }
    
    fn compare(other: PluginVersion) -> Int {
        if self.major != other.major { return self.major - other.major }
        if self.minor != other.minor { return self.minor - other.minor }
        self.patch - other.patch
    }
}

/// Plugin metadata descriptor
struct PluginMetadata {
    id: String
    name: String
    version: PluginVersion
    description: String
    author: String
    license: String
    homepage: Option<String>
    repository: Option<String>
    keywords: [String]
    dependencies: [PluginDependency]
    api_version: PluginVersion
    capabilities: [PluginCapability]
}

impl PluginMetadata {
    fn new(id: String, name: String, version: PluginVersion) -> Self {
        PluginMetadata {
            id: id,
            name: name,
            version: version,
            description: "".to_string(),
            author: "".to_string(),
            license: "MIT".to_string(),
            homepage: None,
            repository: None,
            keywords: [],
            dependencies: [],
            api_version: PluginVersion.new(1, 0, 0),
            capabilities: []
        }
    }
    
    fn with_description(self, desc: String) -> Self {
        self.description = desc
        self
    }
    
    fn with_author(self, author: String) -> Self {
        self.author = author
        self
    }
    
    fn with_dependency(self, dep: PluginDependency) -> Self {
        self.dependencies.push(dep)
        self
    }
    
    fn with_capability(self, cap: PluginCapability) -> Self {
        self.capabilities.push(cap)
        self
    }
    
    fn validate() -> Result<(), PluginError> {
        if self.id.is_empty() {
            return Err(PluginError.InvalidMetadata("Plugin ID cannot be empty".to_string()))
        }
        if self.name.is_empty() {
            return Err(PluginError.InvalidMetadata("Plugin name cannot be empty".to_string()))
        }
        Ok(())
    }
}

/// Plugin dependency specification
struct PluginDependency {
    plugin_id: String
    version_requirement: VersionRequirement
    optional: Bool
}

impl PluginDependency {
    fn required(id: String, version: String) -> Self {
        PluginDependency {
            plugin_id: id,
            version_requirement: VersionRequirement.parse(version),
            optional: false
        }
    }
    
    fn optional(id: String, version: String) -> Self {
        PluginDependency {
            plugin_id: id,
            version_requirement: VersionRequirement.parse(version),
            optional: true
        }
    }
}

/// Version requirement for dependencies
enum VersionRequirement {
    Exact(PluginVersion)
    Minimum(PluginVersion)
    Range(PluginVersion, PluginVersion)
    Compatible(PluginVersion)
    Any
}

impl VersionRequirement {
    fn parse(s: String) -> Self {
        if s == "*" { return VersionRequirement.Any }
        if s.starts_with("^") {
            let v = PluginVersion.parse(s[1..].to_string())?
            return VersionRequirement.Compatible(v)
        }
        if s.starts_with(">=") {
            let v = PluginVersion.parse(s[2..].to_string())?
            return VersionRequirement.Minimum(v)
        }
        if s.starts_with("=") {
            let v = PluginVersion.parse(s[1..].to_string())?
            return VersionRequirement.Exact(v)
        }
        VersionRequirement.Any
    }
    
    fn satisfies(version: PluginVersion) -> Bool {
        match self {
            Exact(v) => version.compare(v) == 0,
            Minimum(v) => version.compare(v) >= 0,
            Range(min, max) => version.compare(min) >= 0 && version.compare(max) <= 0,
            Compatible(v) => version.major == v.major && version.compare(v) >= 0,
            Any => true
        }
    }
}

/// Plugin capabilities
enum PluginCapability {
    FileSystem
    Network
    Process
    Database
    UI
    Audio
    Video
    Crypto
    Native
    Custom(String)
}

// =============================================================================
// Plugin Trait
// =============================================================================

/// Core plugin trait that all plugins must implement
trait Plugin {
    /// Get plugin metadata
    fn metadata() -> PluginMetadata
    
    /// Initialize the plugin
    fn initialize(ctx: PluginContext) -> Result<(), PluginError>
    
    /// Start the plugin
    fn start() -> Result<(), PluginError>
    
    /// Stop the plugin
    fn stop() -> Result<(), PluginError>
    
    /// Cleanup and release resources
    fn cleanup()
    
    /// Handle plugin events
    fn on_event(event: PluginEvent) -> Result<(), PluginError> {
        // Default implementation - ignore events
        Ok(())
    }
    
    /// Get plugin health status
    fn health() -> PluginHealth {
        PluginHealth.Healthy
    }
}

/// Plugin lifecycle state
enum PluginState {
    Unloaded
    Loading
    Loaded
    Initializing
    Initialized
    Starting
    Running
    Stopping
    Stopped
    Failed(String)
    Disabled
}

impl PluginState {
    fn is_active() -> Bool {
        match self {
            Running => true,
            _ => false
        }
    }
    
    fn can_start() -> Bool {
        match self {
            Initialized | Stopped => true,
            _ => false
        }
    }
    
    fn can_stop() -> Bool {
        match self {
            Running => true,
            _ => false
        }
    }
}

/// Plugin health status
enum PluginHealth {
    Healthy
    Degraded(String)
    Unhealthy(String)
    Unknown
}

// =============================================================================
// Plugin Context
// =============================================================================

/// Context provided to plugins during initialization
struct PluginContext {
    plugin_id: String
    config: PluginConfig
    logger: PluginLogger
    services: ServiceRegistry
    data_dir: String
    cache_dir: String
    temp_dir: String
}

impl PluginContext {
    fn new(plugin_id: String) -> Self {
        PluginContext {
            plugin_id: plugin_id.clone(),
            config: PluginConfig.empty(),
            logger: PluginLogger.new(plugin_id),
            services: ServiceRegistry.new(),
            data_dir: format!("/data/plugins/{}", plugin_id),
            cache_dir: format!("/cache/plugins/{}", plugin_id),
            temp_dir: format!("/tmp/plugins/{}", plugin_id)
        }
    }
    
    fn with_config(self, config: PluginConfig) -> Self {
        self.config = config
        self
    }
    
    fn get_config<T>(key: String) -> Option<T> {
        self.config.get(key)
    }
    
    fn get_service<T: Service>(name: String) -> Option<T> {
        self.services.get(name)
    }
    
    fn log_info(message: String) {
        self.logger.info(message)
    }
    
    fn log_error(message: String) {
        self.logger.error(message)
    }
}

/// Plugin configuration
struct PluginConfig {
    values: Map<String, ConfigValue>
}

enum ConfigValue {
    String(String)
    Int(Int)
    Float(Float)
    Bool(Bool)
    Array([ConfigValue])
    Object(Map<String, ConfigValue>)
    Null
}

impl PluginConfig {
    fn empty() -> Self {
        PluginConfig { values: Map.new() }
    }
    
    fn from_map(values: Map<String, ConfigValue>) -> Self {
        PluginConfig { values: values }
    }
    
    fn get<T>(key: String) -> Option<T> {
        self.values.get(key).and_then(|v| v.as_type())
    }
    
    fn get_string(key: String) -> Option<String> {
        match self.values.get(key)? {
            ConfigValue.String(s) => Some(s.clone()),
            _ => None
        }
    }
    
    fn get_int(key: String) -> Option<Int> {
        match self.values.get(key)? {
            ConfigValue.Int(i) => Some(i),
            _ => None
        }
    }
    
    fn get_bool(key: String) -> Option<Bool> {
        match self.values.get(key)? {
            ConfigValue.Bool(b) => Some(b),
            _ => None
        }
    }
    
    fn set(key: String, value: ConfigValue) {
        self.values.insert(key, value)
    }
    
    fn merge(other: PluginConfig) {
        for (k, v) in other.values.iter() {
            self.values.insert(k.clone(), v.clone())
        }
    }
}

/// Plugin logger
struct PluginLogger {
    plugin_id: String
    level: LogLevel
}

enum LogLevel {
    Trace
    Debug
    Info
    Warn
    Error
}

impl PluginLogger {
    fn new(plugin_id: String) -> Self {
        PluginLogger {
            plugin_id: plugin_id,
            level: LogLevel.Info
        }
    }
    
    fn with_level(self, level: LogLevel) -> Self {
        self.level = level
        self
    }
    
    fn trace(message: String) {
        self.log(LogLevel.Trace, message)
    }
    
    fn debug(message: String) {
        self.log(LogLevel.Debug, message)
    }
    
    fn info(message: String) {
        self.log(LogLevel.Info, message)
    }
    
    fn warn(message: String) {
        self.log(LogLevel.Warn, message)
    }
    
    fn error(message: String) {
        self.log(LogLevel.Error, message)
    }
    
    fn log(level: LogLevel, message: String) {
        let timestamp = Time.now().format_iso8601()
        let level_str = match level {
            Trace => "TRACE",
            Debug => "DEBUG",
            Info => "INFO",
            Warn => "WARN",
            Error => "ERROR"
        }
        println!("[{}] [{}] [{}] {}", timestamp, level_str, self.plugin_id, message)
    }
}

// =============================================================================
// Plugin Events
// =============================================================================

/// Events that plugins can receive
enum PluginEvent {
    // Lifecycle events
    BeforeStart
    AfterStart
    BeforeStop
    AfterStop
    ConfigChanged(PluginConfig)
    
    // System events
    SystemShutdown
    LowMemory
    HighCPU
    
    // Inter-plugin events
    PluginLoaded(String)
    PluginUnloaded(String)
    PluginMessage(String, PluginMessage)
    
    // Custom events
    Custom(String, Map<String, ConfigValue>)
}

/// Message between plugins
struct PluginMessage {
    from: String
    to: String
    topic: String
    payload: [UInt8]
    timestamp: Int64
    correlation_id: Option<String>
}

impl PluginMessage {
    fn new(from: String, to: String, topic: String, payload: [UInt8]) -> Self {
        PluginMessage {
            from: from,
            to: to,
            topic: topic,
            payload: payload,
            timestamp: Time.now().unix_millis(),
            correlation_id: None
        }
    }
    
    fn with_correlation(self, id: String) -> Self {
        self.correlation_id = Some(id)
        self
    }
    
    fn reply(topic: String, payload: [UInt8]) -> Self {
        PluginMessage {
            from: self.to.clone(),
            to: self.from.clone(),
            topic: topic,
            payload: payload,
            timestamp: Time.now().unix_millis(),
            correlation_id: self.correlation_id.clone()
        }
    }
}

// =============================================================================
// Service Registry
// =============================================================================

/// Service trait for plugin-provided services
trait Service {
    fn name() -> String
    fn version() -> PluginVersion
}

/// Registry for plugin services
struct ServiceRegistry {
    services: Map<String, Box<dyn Service>>
}

impl ServiceRegistry {
    fn new() -> Self {
        ServiceRegistry { services: Map.new() }
    }
    
    fn register<T: Service>(service: T) {
        self.services.insert(service.name(), Box.new(service))
    }
    
    fn unregister(name: String) {
        self.services.remove(name)
    }
    
    fn get<T: Service>(name: String) -> Option<T> {
        self.services.get(name).and_then(|s| s.downcast())
    }
    
    fn has(name: String) -> Bool {
        self.services.contains_key(name)
    }
    
    fn list() -> [String] {
        self.services.keys().collect()
    }
}

// =============================================================================
// Plugin Errors
// =============================================================================

/// Plugin-related errors
enum PluginError {
    NotFound(String)
    LoadFailed(String)
    InitializationFailed(String)
    StartFailed(String)
    StopFailed(String)
    InvalidMetadata(String)
    DependencyMissing(String)
    DependencyVersionMismatch(String, String, String)
    CapabilityDenied(PluginCapability)
    ConfigurationError(String)
    CommunicationError(String)
    SandboxViolation(String)
    Timeout(String)
    InternalError(String)
}

impl PluginError {
    fn message() -> String {
        match self {
            NotFound(id) => format!("Plugin not found: {}", id),
            LoadFailed(msg) => format!("Failed to load plugin: {}", msg),
            InitializationFailed(msg) => format!("Plugin initialization failed: {}", msg),
            StartFailed(msg) => format!("Plugin start failed: {}", msg),
            StopFailed(msg) => format!("Plugin stop failed: {}", msg),
            InvalidMetadata(msg) => format!("Invalid plugin metadata: {}", msg),
            DependencyMissing(dep) => format!("Missing dependency: {}", dep),
            DependencyVersionMismatch(dep, req, got) => 
                format!("Dependency version mismatch for {}: required {}, got {}", dep, req, got),
            CapabilityDenied(cap) => format!("Capability denied: {:?}", cap),
            ConfigurationError(msg) => format!("Configuration error: {}", msg),
            CommunicationError(msg) => format!("Communication error: {}", msg),
            SandboxViolation(msg) => format!("Sandbox violation: {}", msg),
            Timeout(msg) => format!("Operation timed out: {}", msg),
            InternalError(msg) => format!("Internal error: {}", msg)
        }
    }
}

// =============================================================================
// Extension Points
// =============================================================================

/// Extension point for plugin hooks
trait ExtensionPoint {
    type Extension
    
    fn name() -> String
    fn register(extension: Self.Extension)
    fn unregister(id: String)
    fn get_extensions() -> [Self.Extension]
}

/// Hook for extending functionality
struct Hook<T> {
    name: String
    handlers: [HookHandler<T>]
    priority_sorted: Bool
}

struct HookHandler<T> {
    id: String
    plugin_id: String
    priority: Int
    handler: fn(T) -> T
}

impl<T> Hook<T> {
    fn new(name: String) -> Self {
        Hook {
            name: name,
            handlers: [],
            priority_sorted: true
        }
    }
    
    fn add(id: String, plugin_id: String, priority: Int, handler: fn(T) -> T) {
        self.handlers.push(HookHandler {
            id: id,
            plugin_id: plugin_id,
            priority: priority,
            handler: handler
        })
        self.priority_sorted = false
    }
    
    fn remove(id: String) {
        self.handlers.retain(|h| h.id != id)
    }
    
    fn remove_by_plugin(plugin_id: String) {
        self.handlers.retain(|h| h.plugin_id != plugin_id)
    }
    
    fn apply(value: T) -> T {
        if !self.priority_sorted {
            self.handlers.sort_by(|a, b| b.priority - a.priority)
            self.priority_sorted = true
        }
        
        var result = value
        for handler in self.handlers.iter() {
            result = (handler.handler)(result)
        }
        result
    }
}

/// Filter hook that can modify or reject values
struct FilterHook<T> {
    name: String
    filters: [FilterHandler<T>]
}

struct FilterHandler<T> {
    id: String
    plugin_id: String
    priority: Int
    filter: fn(T) -> Option<T>
}

impl<T> FilterHook<T> {
    fn new(name: String) -> Self {
        FilterHook {
            name: name,
            filters: []
        }
    }
    
    fn add(id: String, plugin_id: String, priority: Int, filter: fn(T) -> Option<T>) {
        self.filters.push(FilterHandler {
            id: id,
            plugin_id: plugin_id,
            priority: priority,
            filter: filter
        })
    }
    
    fn apply(value: T) -> Option<T> {
        var result = Some(value)
        for filter in self.filters.iter() {
            match result {
                Some(v) => result = (filter.filter)(v),
                None => return None
            }
        }
        result
    }
}

/// Action hook for side effects
struct ActionHook {
    name: String
    actions: [ActionHandler]
}

struct ActionHandler {
    id: String
    plugin_id: String
    priority: Int
    action: fn()
}

impl ActionHook {
    fn new(name: String) -> Self {
        ActionHook {
            name: name,
            actions: []
        }
    }
    
    fn add(id: String, plugin_id: String, priority: Int, action: fn()) {
        self.actions.push(ActionHandler {
            id: id,
            plugin_id: plugin_id,
            priority: priority,
            action: action
        })
    }
    
    fn execute() {
        for action in self.actions.iter() {
            (action.action)()
        }
    }
    
    async fn execute_async() {
        let futures: [Future<()>] = self.actions.iter()
            .map(|a| async { (a.action)() })
            .collect()
        Future.join_all(futures).await
    }
}

// =============================================================================
// Plugin Manifest
// =============================================================================

/// Plugin manifest file structure
struct PluginManifest {
    metadata: PluginMetadata
    entry_point: String
    exports: [ExportDeclaration]
    permissions: [PluginCapability]
    config_schema: Option<ConfigSchema>
    hooks: [HookDeclaration]
}

struct ExportDeclaration {
    name: String
    kind: ExportKind
    description: String
}

enum ExportKind {
    Function
    Service
    Component
    Hook
}

struct HookDeclaration {
    name: String
    hook_type: String
    priority: Int
}

struct ConfigSchema {
    properties: Map<String, PropertySchema>
    required: [String]
}

struct PropertySchema {
    property_type: String
    description: String
    default_value: Option<ConfigValue>
    validation: Option<String>
}

impl PluginManifest {
    fn from_json(json: String) -> Result<Self, PluginError> {
        // Parse JSON manifest
        Ok(PluginManifest {
            metadata: PluginMetadata.new("".to_string(), "".to_string(), PluginVersion.new(0, 0, 0)),
            entry_point: "main.vibee".to_string(),
            exports: [],
            permissions: [],
            config_schema: None,
            hooks: []
        })
    }
    
    fn to_json() -> String {
        // Serialize to JSON
        "{}".to_string()
    }
    
    fn validate() -> Result<(), PluginError> {
        self.metadata.validate()?
        if self.entry_point.is_empty() {
            return Err(PluginError.InvalidMetadata("Entry point cannot be empty".to_string()))
        }
        Ok(())
    }
}

// =============================================================================
// Tests
// =============================================================================

test "plugin version parsing" {
    let v = PluginVersion.parse("1.2.3")?
    assert_eq(v.major, 1)?
    assert_eq(v.minor, 2)?
    assert_eq(v.patch, 3)?
}

test "plugin version compatibility" {
    let v1 = PluginVersion.new(1, 2, 0)
    let v2 = PluginVersion.new(1, 3, 0)
    let v3 = PluginVersion.new(2, 0, 0)
    
    assert(v2.is_compatible(v1))?
    assert(!v3.is_compatible(v1))?
}

test "version requirement" {
    let req = VersionRequirement.Compatible(PluginVersion.new(1, 0, 0))
    
    assert(req.satisfies(PluginVersion.new(1, 0, 0)))?
    assert(req.satisfies(PluginVersion.new(1, 5, 0)))?
    assert(!req.satisfies(PluginVersion.new(2, 0, 0)))?
}

test "plugin config" {
    var config = PluginConfig.empty()
    config.set("name", ConfigValue.String("test"))
    config.set("enabled", ConfigValue.Bool(true))
    config.set("count", ConfigValue.Int(42))
    
    assert_eq(config.get_string("name"), Some("test"))?
    assert_eq(config.get_bool("enabled"), Some(true))?
    assert_eq(config.get_int("count"), Some(42))?
}

test "hook application" {
    var hook: Hook<Int> = Hook.new("test_hook")
    hook.add("h1", "plugin1", 10, |x| x + 1)
    hook.add("h2", "plugin2", 20, |x| x * 2)
    
    // Higher priority runs first: 5 * 2 = 10, then 10 + 1 = 11
    let result = hook.apply(5)
    assert_eq(result, 11)?
}

test "filter hook" {
    var filter: FilterHook<Int> = FilterHook.new("test_filter")
    filter.add("f1", "plugin1", 10, |x| if x > 0 { Some(x) } else { None })
    
    assert_eq(filter.apply(5), Some(5))?
    assert_eq(filter.apply(-1), None)?
}

test "plugin metadata validation" {
    let valid = PluginMetadata.new("my-plugin", "My Plugin", PluginVersion.new(1, 0, 0))
    assert(valid.validate().is_ok())?
    
    let invalid = PluginMetadata.new("", "My Plugin", PluginVersion.new(1, 0, 0))
    assert(invalid.validate().is_err())?
}

test "service registry" {
    var registry = ServiceRegistry.new()
    
    struct TestService {}
    impl Service for TestService {
        fn name() -> String { "test".to_string() }
        fn version() -> PluginVersion { PluginVersion.new(1, 0, 0) }
    }
    
    registry.register(TestService {})
    assert(registry.has("test"))?
    
    registry.unregister("test")
    assert(!registry.has("test"))?
}
