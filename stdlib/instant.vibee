// =============================================================================
// Vibee OS — Instant Module
// Monotonic time instants for measuring elapsed time
// =============================================================================

use duration.{Duration}

// -----------------------------------------------------------------------------
// Instant
// -----------------------------------------------------------------------------

/// A measurement of a monotonically nondecreasing clock
/// Opaque and useful only with Duration
struct Instant {
    nanos: Int64    // Nanoseconds since arbitrary epoch
    
    /// Returns an instant corresponding to "now"
    fn now() -> Self {
        Instant { nanos: @native("monotonic_nanos") }
    }
    
    /// Returns the amount of time elapsed from another instant to this one
    fn duration_since(earlier: Instant) -> Duration {
        Duration.nanos(self.nanos - earlier.nanos)
    }
    
    /// Returns the amount of time elapsed since this instant was created
    fn elapsed() -> Duration {
        Self.now().duration_since(self)
    }
    
    /// Returns Some(t) where t is the time self + duration if t can be represented
    fn checked_add(duration: Duration) -> Option<Self> {
        self.nanos.checked_add(duration.as_nanos()).map(|n| Instant { nanos: n })
    }
    
    /// Returns Some(t) where t is the time self - duration if t can be represented
    fn checked_sub(duration: Duration) -> Option<Self> {
        self.nanos.checked_sub(duration.as_nanos()).map(|n| Instant { nanos: n })
    }
    
    /// Returns the instant corresponding to self + duration
    fn saturating_add(duration: Duration) -> Self {
        Instant { nanos: self.nanos.saturating_add(duration.as_nanos()) }
    }
    
    /// Returns the instant corresponding to self - duration
    fn saturating_sub(duration: Duration) -> Self {
        Instant { nanos: self.nanos.saturating_sub(duration.as_nanos()) }
    }
    
    /// Check if this instant is before another
    fn is_before(other: Instant) -> Bool {
        self.nanos < other.nanos
    }
    
    /// Check if this instant is after another
    fn is_after(other: Instant) -> Bool {
        self.nanos > other.nanos
    }
    
    /// Returns the earlier of two instants
    fn min(other: Instant) -> Self {
        if self.nanos <= other.nanos { self } else { other }
    }
    
    /// Returns the later of two instants
    fn max(other: Instant) -> Self {
        if self.nanos >= other.nanos { self } else { other }
    }
}

impl Add<Duration> for Instant {
    fn add(duration: Duration) -> Instant {
        Instant { nanos: self.nanos + duration.as_nanos() }
    }
}

impl Sub<Duration> for Instant {
    fn sub(duration: Duration) -> Instant {
        Instant { nanos: self.nanos - duration.as_nanos() }
    }
}

impl Sub for Instant {
    fn sub(other: Instant) -> Duration {
        Duration.nanos(self.nanos - other.nanos)
    }
}

impl Eq for Instant {
    fn eq(other: Instant) -> Bool { self.nanos == other.nanos }
}

impl Ord for Instant {
    fn cmp(other: Instant) -> Ordering { self.nanos.cmp(other.nanos) }
}

impl Hash for Instant {
    fn hash() -> Int { self.nanos.hash() }
}

// -----------------------------------------------------------------------------
// SystemTime
// -----------------------------------------------------------------------------

/// A measurement of the system clock, useful for talking to external entities
/// like the file system or other processes
struct SystemTime {
    nanos: Int64    // Nanoseconds since Unix epoch
    
    /// Returns the system time corresponding to "now"
    fn now() -> Self {
        SystemTime { nanos: @native("system_time_nanos") }
    }
    
    /// Returns the Unix epoch (January 1, 1970 00:00:00 UTC)
    fn unix_epoch() -> Self {
        SystemTime { nanos: 0 }
    }
    
    /// Returns the amount of time elapsed from an earlier time
    fn duration_since(earlier: SystemTime) -> Result<Duration, SystemTimeError> {
        if self.nanos >= earlier.nanos {
            Ok(Duration.nanos(self.nanos - earlier.nanos))
        } else {
            Err(SystemTimeError.TimeWentBackwards(Duration.nanos(earlier.nanos - self.nanos)))
        }
    }
    
    /// Returns the amount of time elapsed since Unix epoch
    fn duration_since_epoch() -> Duration {
        Duration.nanos(self.nanos)
    }
    
    /// Returns the amount of time elapsed since this time was created
    fn elapsed() -> Result<Duration, SystemTimeError> {
        Self.now().duration_since(self)
    }
    
    /// Returns Some(t) where t is the time self + duration
    fn checked_add(duration: Duration) -> Option<Self> {
        self.nanos.checked_add(duration.as_nanos()).map(|n| SystemTime { nanos: n })
    }
    
    /// Returns Some(t) where t is the time self - duration
    fn checked_sub(duration: Duration) -> Option<Self> {
        self.nanos.checked_sub(duration.as_nanos()).map(|n| SystemTime { nanos: n })
    }
    
    /// Create from Unix timestamp (seconds)
    fn from_unix_secs(secs: Int64) -> Self {
        SystemTime { nanos: secs * 1_000_000_000 }
    }
    
    /// Create from Unix timestamp (milliseconds)
    fn from_unix_millis(millis: Int64) -> Self {
        SystemTime { nanos: millis * 1_000_000 }
    }
    
    /// Create from Unix timestamp (nanoseconds)
    fn from_unix_nanos(nanos: Int64) -> Self {
        SystemTime { nanos: nanos }
    }
    
    /// Get Unix timestamp in seconds
    fn as_unix_secs() -> Int64 {
        self.nanos / 1_000_000_000
    }
    
    /// Get Unix timestamp in milliseconds
    fn as_unix_millis() -> Int64 {
        self.nanos / 1_000_000
    }
    
    /// Get Unix timestamp in nanoseconds
    fn as_unix_nanos() -> Int64 {
        self.nanos
    }
}

impl Add<Duration> for SystemTime {
    fn add(duration: Duration) -> SystemTime {
        SystemTime { nanos: self.nanos + duration.as_nanos() }
    }
}

impl Sub<Duration> for SystemTime {
    fn sub(duration: Duration) -> SystemTime {
        SystemTime { nanos: self.nanos - duration.as_nanos() }
    }
}

impl Eq for SystemTime {
    fn eq(other: SystemTime) -> Bool { self.nanos == other.nanos }
}

impl Ord for SystemTime {
    fn cmp(other: SystemTime) -> Ordering { self.nanos.cmp(other.nanos) }
}

impl Hash for SystemTime {
    fn hash() -> Int { self.nanos.hash() }
}

enum SystemTimeError {
    TimeWentBackwards(Duration)
}

impl Display for SystemTimeError {
    fn fmt(f: Formatter) {
        match self {
            TimeWentBackwards(d) => f.write("System time went backwards by \(d)")
        }
    }
}

// -----------------------------------------------------------------------------
// Deadline
// -----------------------------------------------------------------------------

/// A point in time used for timeouts
struct Deadline {
    instant: Instant
    
    /// Create a deadline that expires after the given duration
    fn after(duration: Duration) -> Self {
        Deadline { instant: Instant.now() + duration }
    }
    
    /// Create a deadline at a specific instant
    fn at(instant: Instant) -> Self {
        Deadline { instant: instant }
    }
    
    /// Create a deadline that never expires
    fn never() -> Self {
        Deadline { instant: Instant { nanos: Int64.MAX } }
    }
    
    /// Create a deadline that has already expired
    fn expired() -> Self {
        Deadline { instant: Instant { nanos: 0 } }
    }
    
    /// Check if the deadline has passed
    fn is_expired() -> Bool {
        Instant.now() >= self.instant
    }
    
    /// Get the remaining time until the deadline
    fn remaining() -> Duration {
        let now = Instant.now()
        if now >= self.instant {
            Duration.zero()
        } else {
            self.instant - now
        }
    }
    
    /// Get the instant when the deadline expires
    fn instant() -> Instant {
        self.instant
    }
    
    /// Extend the deadline by a duration
    fn extend(duration: Duration) -> Self {
        Deadline { instant: self.instant + duration }
    }
    
    /// Wait until the deadline expires
    fn wait() {
        let remaining = self.remaining()
        if remaining.is_positive() {
            @native("sleep_nanos", remaining.as_nanos())
        }
    }
    
    /// Wait until the deadline expires or return false if already expired
    fn wait_if_not_expired() -> Bool {
        if self.is_expired() {
            false
        } else {
            self.wait()
            true
        }
    }
}

impl Eq for Deadline {
    fn eq(other: Deadline) -> Bool { self.instant == other.instant }
}

impl Ord for Deadline {
    fn cmp(other: Deadline) -> Ordering { self.instant.cmp(other.instant) }
}

// -----------------------------------------------------------------------------
// Timeout
// -----------------------------------------------------------------------------

/// Execute a function with a timeout
fn with_timeout<T>(duration: Duration, f: fn() -> T) -> Result<T, TimeoutError> {
    let deadline = Deadline.after(duration)
    
    // Run in separate fiber with timeout
    let result = @native("run_with_timeout", duration.as_nanos(), f)
    
    match result {
        Some(value) => Ok(value)
        None => Err(TimeoutError.Elapsed)
    }
}

/// Execute an async function with a timeout
async fn with_timeout_async<T>(duration: Duration, f: async fn() -> T) -> Result<T, TimeoutError> {
    let deadline = Deadline.after(duration)
    
    select {
        result = f() => Ok(result)
        _ = sleep_until(deadline) => Err(TimeoutError.Elapsed)
    }
}

enum TimeoutError {
    Elapsed
}

impl Display for TimeoutError {
    fn fmt(f: Formatter) {
        match self {
            Elapsed => f.write("Operation timed out")
        }
    }
}

// -----------------------------------------------------------------------------
// Sleep Functions
// -----------------------------------------------------------------------------

/// Sleep for the specified duration
fn sleep(duration: Duration) {
    @native("sleep_nanos", duration.as_nanos())
}

/// Sleep until the specified instant
fn sleep_until(instant: Instant) {
    let now = Instant.now()
    if instant > now {
        sleep(instant - now)
    }
}

/// Sleep until the specified deadline
fn sleep_until_deadline(deadline: Deadline) {
    deadline.wait()
}

// -----------------------------------------------------------------------------
// Timing Utilities
// -----------------------------------------------------------------------------

/// Measure the time it takes to execute a function
fn measure<T>(f: fn() -> T) -> (T, Duration) {
    let start = Instant.now()
    let result = f()
    let elapsed = start.elapsed()
    (result, elapsed)
}

/// Measure the time it takes to execute a function (returns only duration)
fn time_it(f: fn()) -> Duration {
    let start = Instant.now()
    f()
    start.elapsed()
}

/// Execute a function and print the elapsed time
fn timed<T>(name: String, f: fn() -> T) -> T {
    let start = Instant.now()
    let result = f()
    let elapsed = start.elapsed()
    println("\(name): \(format_duration(elapsed))")
    result
}

/// Format duration for display
fn format_duration(d: Duration) -> String {
    let nanos = d.as_nanos()
    if nanos < 1_000 {
        "\(nanos)ns"
    } else if nanos < 1_000_000 {
        "\(nanos / 1_000)µs"
    } else if nanos < 1_000_000_000 {
        "\(nanos / 1_000_000)ms"
    } else {
        "\(d.as_seconds_f().round(3))s"
    }
}

// -----------------------------------------------------------------------------
// Interval
// -----------------------------------------------------------------------------

/// An iterator that yields at regular intervals
struct Interval {
    period: Duration
    next_tick: Instant
    missed_ticks: Int
    
    /// Create a new interval that ticks every `period`
    fn new(period: Duration) -> Self {
        Interval {
            period: period,
            next_tick: Instant.now() + period,
            missed_ticks: 0
        }
    }
    
    /// Create an interval that starts immediately
    fn immediate(period: Duration) -> Self {
        Interval {
            period: period,
            next_tick: Instant.now(),
            missed_ticks: 0
        }
    }
    
    /// Wait for the next tick
    fn tick() -> Instant {
        let now = Instant.now()
        
        if now >= self.next_tick {
            // Calculate missed ticks
            let elapsed = now - self.next_tick
            self.missed_ticks = (elapsed.as_nanos() / self.period.as_nanos()) as Int
            self.next_tick = now + self.period
        } else {
            sleep_until(self.next_tick)
            self.next_tick = self.next_tick + self.period
            self.missed_ticks = 0
        }
        
        self.next_tick - self.period
    }
    
    /// Get the number of missed ticks since last call
    fn missed() -> Int {
        self.missed_ticks
    }
    
    /// Reset the interval to start from now
    fn reset() {
        self.next_tick = Instant.now() + self.period
        self.missed_ticks = 0
    }
    
    /// Get the period of this interval
    fn period() -> Duration {
        self.period
    }
}

impl Iterator for Interval {
    type Item = Instant
    
    fn next() -> Option<Instant> {
        Some(self.tick())
    }
}

// -----------------------------------------------------------------------------
// Ticker
// -----------------------------------------------------------------------------

/// A ticker that sends the current time on a channel at regular intervals
actor Ticker {
    state interval: Interval
    state running: Bool
    state channel: Channel<Instant>
    
    fn new(period: Duration) -> Self {
        Ticker {
            interval: Interval.new(period),
            running: false,
            channel: Channel.new()
        }
    }
    
    /// Start the ticker
    fn start() {
        if self.running { return }
        self.running = true
        
        spawn {
            while self.running {
                let tick = self.interval.tick()
                self.channel.send(tick)
            }
        }
    }
    
    /// Stop the ticker
    fn stop() {
        self.running = false
    }
    
    /// Get the channel to receive ticks
    fn channel() -> Channel<Instant> {
        self.channel.clone()
    }
    
    /// Reset the ticker
    fn reset() {
        self.interval.reset()
    }
    
    /// Check if the ticker is running
    fn is_running() -> Bool {
        self.running
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "instant elapsed" {
    let start = Instant.now()
    @native("sleep_ms", 10)
    let elapsed = start.elapsed()
    assert(elapsed.as_millis() >= 10)?
}

test "instant arithmetic" {
    let start = Instant.now()
    let later = start + Duration.seconds(1)
    assert(later > start)?
    assert_eq((later - start).as_seconds(), 1)?
}

test "system time" {
    let now = SystemTime.now()
    let epoch = SystemTime.unix_epoch()
    let duration = now.duration_since(epoch)?
    assert(duration.as_seconds() > 0)?
}

test "deadline" {
    let deadline = Deadline.after(Duration.millis(100))
    assert(!deadline.is_expired())?
    assert(deadline.remaining().as_millis() > 0)?
    assert(deadline.remaining().as_millis() <= 100)?
}

test "deadline expired" {
    let deadline = Deadline.expired()
    assert(deadline.is_expired())?
    assert(deadline.remaining().is_zero())?
}

test "measure" {
    let (result, duration) = measure(|| {
        var sum = 0
        for i in 0..1000 { sum += i }
        sum
    })
    assert_eq(result, 499500)?
    assert(duration.as_nanos() > 0)?
}

test "interval" {
    let mut interval = Interval.new(Duration.millis(10))
    let start = Instant.now()
    
    interval.tick()
    interval.tick()
    interval.tick()
    
    let elapsed = start.elapsed()
    assert(elapsed.as_millis() >= 30)?
}

test "format duration" {
    assert_eq(format_duration(Duration.nanos(500)), "500ns")?
    assert_eq(format_duration(Duration.micros(500)), "500µs")?
    assert_eq(format_duration(Duration.millis(500)), "500ms")?
}
