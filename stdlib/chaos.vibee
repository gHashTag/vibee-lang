// =============================================================================
// Vibee OS â€” Chaos Engineering Module
// Fault injection, resilience testing, and chaos experiments
// =============================================================================

// -----------------------------------------------------------------------------
// Chaos Runner
// -----------------------------------------------------------------------------

/// Chaos experiment runner
actor ChaosRunner {
    state experiments: [ChaosExperiment]
    state config: ChaosConfig
    state results: [ExperimentResult]
    state steady_state: Option<SteadyState>
    
    fn new() -> Self {
        ChaosRunner {
            experiments: [],
            config: ChaosConfig.default(),
            results: [],
            steady_state: None
        }
    }
    
    on config(c: ChaosConfig) -> Self { self.config = c; self }
    
    /// Define steady state hypothesis
    on steady_state(probes: [Probe]) -> Self {
        self.steady_state = Some(SteadyState { probes: probes })
        self
    }
    
    /// Add experiment
    on experiment(name: String, setup: (ExperimentBuilder) -> ExperimentBuilder) -> Self {
        let builder = ExperimentBuilder.new(name)
        let exp = setup(builder).build()
        self.experiments.append(exp)
        self
    }
    
    /// Run chaos experiments
    async on run() -> ChaosSummary {
        println("\nðŸ”¥ Starting Chaos Experiments...\n")
        
        for exp in self.experiments {
            let result = self.run_experiment(exp).await
            self.results.append(result)
            self.print_result(result)
        }
        
        self.create_summary()
    }
    
    async fn run_experiment(exp: ChaosExperiment) -> ExperimentResult {
        println("ðŸ§ª Experiment: \(exp.name)")
        let start = Instant.now()
        
        // Check steady state before
        if let ss = self.steady_state {
            if !self.verify_steady_state(ss).await {
                return ExperimentResult {
                    name: exp.name,
                    status: .Failed,
                    duration: start.elapsed(),
                    error: Some(ChaosError.SteadyStateViolation("Before injection"))
                }
            }
        }
        
        // Inject faults
        var rollback_actions = []
        for action in exp.actions {
            match action.inject().await {
                Ok(rollback) => rollback_actions.append(rollback)
                Err(e) => {
                    self.rollback_all(rollback_actions).await
                    return ExperimentResult {
                        name: exp.name,
                        status: .Failed,
                        duration: start.elapsed(),
                        error: Some(e)
                    }
                }
            }
        }
        
        // Wait for experiment duration
        sleep(exp.duration).await
        
        // Check steady state during
        let steady_during = if let ss = self.steady_state {
            self.verify_steady_state(ss).await
        } else { true }
        
        // Rollback
        self.rollback_all(rollback_actions).await
        
        // Recovery time
        sleep(exp.recovery_time).await
        
        // Check steady state after
        let steady_after = if let ss = self.steady_state {
            self.verify_steady_state(ss).await
        } else { true }
        
        let status = if steady_during && steady_after { .Passed } else { .Failed }
        
        ExperimentResult {
            name: exp.name,
            status: status,
            duration: start.elapsed(),
            error: if !steady_after { Some(ChaosError.SteadyStateViolation("After recovery")) } else { None }
        }
    }
    
    async fn verify_steady_state(ss: SteadyState) -> Bool {
        for probe in ss.probes {
            if !probe.check().await {
                return false
            }
        }
        true
    }
    
    async fn rollback_all(actions: [RollbackAction]) {
        for action in actions.rev() {
            action.execute().await
        }
    }
    
    fn print_result(result: ExperimentResult) {
        let icon = if result.status == .Passed { "âœ…" } else { "âŒ" }
        println("  \(icon) \(result.name) (\(result.duration.as_secs())s)")
        if let error = result.error {
            println("     Error: \(error.message())")
        }
    }
    
    fn create_summary() -> ChaosSummary {
        let passed = self.results.filter(|r| r.status == .Passed).len()
        let failed = self.results.filter(|r| r.status == .Failed).len()
        
        ChaosSummary {
            total: self.results.len(),
            passed: passed,
            failed: failed,
            results: self.results
        }
    }
}

struct ChaosConfig {
    dry_run: Bool
    abort_on_failure: Bool
    notification_url: Option<String>
    
    fn default() -> Self {
        ChaosConfig { dry_run: false, abort_on_failure: false, notification_url: None }
    }
}

// -----------------------------------------------------------------------------
// Experiment Builder
// -----------------------------------------------------------------------------

actor ExperimentBuilder {
    state name: String
    state actions: [FaultAction]
    state duration: Duration
    state recovery_time: Duration
    state tags: [String]
    
    fn new(name: String) -> Self {
        ExperimentBuilder {
            name: name,
            actions: [],
            duration: Duration.seconds(60),
            recovery_time: Duration.seconds(30),
            tags: []
        }
    }
    
    on duration(d: Duration) -> Self { self.duration = d; self }
    on recovery_time(d: Duration) -> Self { self.recovery_time = d; self }
    on tag(t: String) -> Self { self.tags.append(t); self }
    
    /// Add fault action
    on inject(action: FaultAction) -> Self {
        self.actions.append(action)
        self
    }
    
    /// Kill process
    on kill_process(name: String) -> Self {
        self.inject(FaultAction.KillProcess(name))
    }
    
    /// Network latency
    on network_latency(target: String, latency: Duration) -> Self {
        self.inject(FaultAction.NetworkLatency(target, latency))
    }
    
    /// Network partition
    on network_partition(targets: [String]) -> Self {
        self.inject(FaultAction.NetworkPartition(targets))
    }
    
    /// CPU stress
    on cpu_stress(percent: Int) -> Self {
        self.inject(FaultAction.CPUStress(percent))
    }
    
    /// Memory stress
    on memory_stress(percent: Int) -> Self {
        self.inject(FaultAction.MemoryStress(percent))
    }
    
    /// Disk fill
    on disk_fill(path: String, percent: Int) -> Self {
        self.inject(FaultAction.DiskFill(path, percent))
    }
    
    fn build() -> ChaosExperiment {
        ChaosExperiment {
            name: self.name,
            actions: self.actions,
            duration: self.duration,
            recovery_time: self.recovery_time,
            tags: self.tags
        }
    }
}

struct ChaosExperiment {
    name: String
    actions: [FaultAction]
    duration: Duration
    recovery_time: Duration
    tags: [String]
}

// -----------------------------------------------------------------------------
// Fault Actions
// -----------------------------------------------------------------------------

enum FaultAction {
    KillProcess(String)
    KillContainer(String)
    KillPod(String, String)
    NetworkLatency(String, Duration)
    NetworkPartition([String])
    NetworkPacketLoss(String, Int)
    NetworkBandwidth(String, Int)
    CPUStress(Int)
    MemoryStress(Int)
    DiskFill(String, Int)
    DiskIOStress(String)
    DNSFailure(String)
    TimeSkew(Duration)
    Custom(String, Map<String, Any>)
    
    async fn inject() -> Result<RollbackAction, ChaosError> {
        match self {
            .KillProcess(name) => {
                let pid = @native("find_process", name).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                @native("kill_process", pid).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.RestartProcess(name))
            }
            .KillContainer(id) => {
                @native("docker_stop", id).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.StartContainer(id))
            }
            .KillPod(namespace, name) => {
                @native("kubectl_delete_pod", namespace, name).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.None)
            }
            .NetworkLatency(target, latency) => {
                @native("tc_add_latency", target, latency.as_millis()).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.RemoveNetworkRule(target))
            }
            .NetworkPartition(targets) => {
                for t in targets {
                    @native("iptables_drop", t).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                }
                Ok(RollbackAction.RemoveIPTablesRules(targets))
            }
            .NetworkPacketLoss(target, percent) => {
                @native("tc_add_loss", target, percent).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.RemoveNetworkRule(target))
            }
            .CPUStress(percent) => {
                let pid = @native("stress_cpu", percent).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.KillPID(pid))
            }
            .MemoryStress(percent) => {
                let pid = @native("stress_memory", percent).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.KillPID(pid))
            }
            .DiskFill(path, percent) => {
                @native("fill_disk", path, percent).map_err(|e| ChaosError.InjectionFailed(e.to_string()))?
                Ok(RollbackAction.CleanupDisk(path))
            }
            _ => Ok(RollbackAction.None)
        }
    }
}

enum RollbackAction {
    None
    RestartProcess(String)
    StartContainer(String)
    RemoveNetworkRule(String)
    RemoveIPTablesRules([String])
    KillPID(Int)
    CleanupDisk(String)
    
    async fn execute() {
        match self {
            .None => {}
            .RestartProcess(name) => { @native("start_process", name) }
            .StartContainer(id) => { @native("docker_start", id) }
            .RemoveNetworkRule(target) => { @native("tc_remove", target) }
            .RemoveIPTablesRules(targets) => {
                for t in targets { @native("iptables_accept", t) }
            }
            .KillPID(pid) => { @native("kill_pid", pid) }
            .CleanupDisk(path) => { @native("cleanup_disk", path) }
        }
    }
}

// -----------------------------------------------------------------------------
// Probes
// -----------------------------------------------------------------------------

/// Steady state probe
struct Probe {
    name: String
    check_fn: () -> Bool
    tolerance: Float
}

impl Probe {
    fn new(name: String, check: () -> Bool) -> Self {
        Probe { name: name, check_fn: check, tolerance: 0.0 }
    }
    
    async fn check() -> Bool {
        (self.check_fn)()
    }
    
    /// HTTP health check
    fn http_health(url: String, expected_status: Int) -> Self {
        Probe {
            name: "HTTP health: \(url)",
            check_fn: || {
                http.get(url).map(|r| r.status.code == expected_status).unwrap_or(false)
            },
            tolerance: 0.0
        }
    }
    
    /// Response time probe
    fn response_time(url: String, max_ms: Int) -> Self {
        Probe {
            name: "Response time < \(max_ms)ms",
            check_fn: || {
                let start = Instant.now()
                http.get(url).ok()
                start.elapsed().as_millis() < max_ms
            },
            tolerance: 0.0
        }
    }
    
    /// Error rate probe
    fn error_rate(metric_url: String, max_rate: Float) -> Self {
        Probe {
            name: "Error rate < \(max_rate)%",
            check_fn: || {
                http.get(metric_url)
                    .ok()
                    .and_then(|r| r.json::<Float>().ok())
                    .map(|rate| rate < max_rate)
                    .unwrap_or(false)
            },
            tolerance: 0.0
        }
    }
    
    /// Process running probe
    fn process_running(name: String) -> Self {
        Probe {
            name: "Process running: \(name)",
            check_fn: || @native("process_exists", name),
            tolerance: 0.0
        }
    }
    
    /// Port open probe
    fn port_open(host: String, port: Int) -> Self {
        Probe {
            name: "Port open: \(host):\(port)",
            check_fn: || @native("check_port", host, port),
            tolerance: 0.0
        }
    }
    
    /// Custom metric probe
    fn metric(name: String, query: String, condition: (Float) -> Bool) -> Self {
        Probe {
            name: "Metric: \(name)",
            check_fn: || {
                @native("query_metric", query)
                    .ok()
                    .map(condition)
                    .unwrap_or(false)
            },
            tolerance: 0.0
        }
    }
}

struct SteadyState {
    probes: [Probe]
}

// -----------------------------------------------------------------------------
// Results
// -----------------------------------------------------------------------------

enum ExperimentStatus { Passed, Failed, Skipped }

struct ExperimentResult {
    name: String
    status: ExperimentStatus
    duration: Duration
    error: Option<ChaosError>
}

struct ChaosSummary {
    total: Int
    passed: Int
    failed: Int
    results: [ExperimentResult]
    
    fn print() {
        println("\n" + "=".repeat(50))
        println("ðŸ”¥ Chaos Engineering Summary")
        println("=".repeat(50))
        println("Total:  \(self.total)")
        println("Passed: \(self.passed) âœ…")
        println("Failed: \(self.failed) âŒ")
        println("=".repeat(50))
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ChaosError {
    InjectionFailed(String)
    RollbackFailed(String)
    SteadyStateViolation(String)
    Timeout
    
    fn message() -> String {
        match self {
            .InjectionFailed(m) => "Injection failed: \(m)"
            .RollbackFailed(m) => "Rollback failed: \(m)"
            .SteadyStateViolation(m) => "Steady state violation: \(m)"
            .Timeout => "Experiment timeout"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "chaos runner" {
    let runner = ChaosRunner.new()
        .steady_state([Probe.http_health("http://localhost:8080/health", 200)])
        .experiment("Kill API", |e| e.kill_process("api-server").duration(Duration.seconds(30)))
    
    assert_eq(runner.experiments.len(), 1)?
}

test "experiment builder" {
    let exp = ExperimentBuilder.new("Network Chaos")
        .network_latency("10.0.0.1", Duration.millis(500))
        .cpu_stress(80)
        .duration(Duration.minutes(5))
        .build()
    
    assert_eq(exp.actions.len(), 2)?
}

test "probes" {
    let probe = Probe.http_health("http://localhost/health", 200)
    assert_eq(probe.name, "HTTP health: http://localhost/health")?
}
