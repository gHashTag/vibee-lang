// =============================================================================
// Vibee OS â€” Fuzzy Search Module
// Approximate string matching and fuzzy search algorithms
// =============================================================================

// =============================================================================
// Distance Metrics
// =============================================================================

/// Levenshtein (edit) distance
fn levenshtein(s1: String, s2: String) -> Int {
    let m = s1.len()
    let n = s2.len()
    
    if m == 0 { return n }
    if n == 0 { return m }
    
    var prev: [Int] = (0..=n).collect()
    var curr = [0; n + 1]
    
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    for i in 1..=m {
        curr[0] = i
        for j in 1..=n {
            let cost = if chars1[i-1] == chars2[j-1] { 0 } else { 1 }
            curr[j] = min(
                prev[j] + 1,           // deletion
                min(curr[j-1] + 1,     // insertion
                    prev[j-1] + cost)  // substitution
            )
        }
        swap(prev, curr)
    }
    
    prev[n]
}

/// Damerau-Levenshtein distance (includes transpositions)
fn damerau_levenshtein(s1: String, s2: String) -> Int {
    let m = s1.len()
    let n = s2.len()
    
    if m == 0 { return n }
    if n == 0 { return m }
    
    var d = [[0; n + 2]; m + 2]
    let max_dist = m + n
    
    d[0][0] = max_dist
    for i in 0..=m { d[i+1][0] = max_dist; d[i+1][1] = i }
    for j in 0..=n { d[0][j+1] = max_dist; d[1][j+1] = j }
    
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    var da = Map.empty()
    
    for i in 1..=m {
        var db = 0
        for j in 1..=n {
            let i1 = da.get(chars2[j-1]).unwrap_or(0)
            let j1 = db
            let cost = if chars1[i-1] == chars2[j-1] { 0 } else { 1 }
            
            if cost == 0 { db = j }
            
            d[i+1][j+1] = min(
                d[i][j] + cost,                                    // substitution
                min(d[i+1][j] + 1,                                 // insertion
                    min(d[i][j+1] + 1,                             // deletion
                        d[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1))) // transposition
            )
        }
        da.set(chars1[i-1], i)
    }
    
    d[m+1][n+1]
}

/// Hamming distance (for equal length strings)
fn hamming(s1: String, s2: String) -> Option<Int> {
    if s1.len() != s2.len() { return None }
    
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    var distance = 0
    for i in 0..chars1.len() {
        if chars1[i] != chars2[i] { distance += 1 }
    }
    
    Some(distance)
}

/// Jaro similarity (0.0 to 1.0)
fn jaro(s1: String, s2: String) -> Float {
    if s1.is_empty() && s2.is_empty() { return 1.0 }
    if s1.is_empty() || s2.is_empty() { return 0.0 }
    
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    let match_distance = (max(chars1.len(), chars2.len()) / 2) - 1
    
    var s1_matches = [false; chars1.len()]
    var s2_matches = [false; chars2.len()]
    
    var matches = 0
    var transpositions = 0
    
    for i in 0..chars1.len() {
        let start = max(0, i as Int - match_distance) as Int
        let end = min(i + match_distance + 1, chars2.len())
        
        for j in start..end {
            if s2_matches[j] || chars1[i] != chars2[j] { continue }
            s1_matches[i] = true
            s2_matches[j] = true
            matches += 1
            break
        }
    }
    
    if matches == 0 { return 0.0 }
    
    var k = 0
    for i in 0..chars1.len() {
        if !s1_matches[i] { continue }
        while !s2_matches[k] { k += 1 }
        if chars1[i] != chars2[k] { transpositions += 1 }
        k += 1
    }
    
    let m = matches as Float
    ((m / chars1.len() as Float) +
     (m / chars2.len() as Float) +
     ((m - transpositions as Float / 2.0) / m)) / 3.0
}

/// Jaro-Winkler similarity (0.0 to 1.0)
fn jaro_winkler(s1: String, s2: String, prefix_scale: Float = 0.1) -> Float {
    let jaro_sim = jaro(s1.clone(), s2.clone())
    
    // Calculate common prefix length (max 4)
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    var prefix_len = 0
    for i in 0..min(4, min(chars1.len(), chars2.len())) {
        if chars1[i] == chars2[i] { prefix_len += 1 }
        else { break }
    }
    
    jaro_sim + prefix_len as Float * prefix_scale * (1.0 - jaro_sim)
}

/// Normalized Levenshtein similarity (0.0 to 1.0)
fn levenshtein_similarity(s1: String, s2: String) -> Float {
    let max_len = max(s1.len(), s2.len())
    if max_len == 0 { return 1.0 }
    1.0 - levenshtein(s1, s2) as Float / max_len as Float
}

/// Longest Common Subsequence length
fn lcs_length(s1: String, s2: String) -> Int {
    let m = s1.len()
    let n = s2.len()
    
    var dp = [[0; n + 1]; m + 1]
    
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    for i in 1..=m {
        for j in 1..=n {
            if chars1[i-1] == chars2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    dp[m][n]
}

/// LCS similarity (0.0 to 1.0)
fn lcs_similarity(s1: String, s2: String) -> Float {
    let max_len = max(s1.len(), s2.len())
    if max_len == 0 { return 1.0 }
    lcs_length(s1, s2) as Float / max_len as Float
}

/// Cosine similarity using character n-grams
fn cosine_similarity(s1: String, s2: String, n: Int = 2) -> Float {
    let ngrams1 = get_ngrams(s1, n)
    let ngrams2 = get_ngrams(s2, n)
    
    if ngrams1.is_empty() || ngrams2.is_empty() { return 0.0 }
    
    var dot_product = 0.0
    var norm1 = 0.0
    var norm2 = 0.0
    
    let all_ngrams: Set<String> = ngrams1.keys().chain(ngrams2.keys()).collect()
    
    for ngram in all_ngrams {
        let v1 = ngrams1.get(ngram).unwrap_or(0) as Float
        let v2 = ngrams2.get(ngram).unwrap_or(0) as Float
        dot_product += v1 * v2
        norm1 += v1 * v1
        norm2 += v2 * v2
    }
    
    if norm1 == 0.0 || norm2 == 0.0 { return 0.0 }
    dot_product / (norm1.sqrt() * norm2.sqrt())
}

fn get_ngrams(s: String, n: Int) -> Map<String, Int> {
    var ngrams = Map.empty()
    let chars: [Char] = s.chars().collect()
    
    if chars.len() < n { return ngrams }
    
    for i in 0..=(chars.len() - n) {
        let ngram: String = chars[i..i+n].iter().collect()
        *ngrams.entry(ngram).or_insert(0) += 1
    }
    
    ngrams
}

// =============================================================================
// Fuzzy Matcher
// =============================================================================

/// Fuzzy match result
struct FuzzyMatch {
    text: String
    score: Float
    distance: Int
    matched_indices: [Int]
}

impl FuzzyMatch {
    fn new(text: String, score: Float, distance: Int) -> Self {
        FuzzyMatch { text: text, score: score, distance: distance, matched_indices: [] }
    }
}

/// Fuzzy matching algorithm
enum FuzzyAlgorithm {
    Levenshtein
    DamerauLevenshtein
    Jaro
    JaroWinkler
    Cosine
}

/// Fuzzy matcher configuration
struct FuzzyConfig {
    algorithm: FuzzyAlgorithm
    threshold: Float
    case_sensitive: Bool
    max_distance: Option<Int>
    
    fn default() -> Self {
        FuzzyConfig {
            algorithm: FuzzyAlgorithm.Levenshtein,
            threshold: 0.6,
            case_sensitive: false,
            max_distance: None
        }
    }
    
    fn with_algorithm(algorithm: FuzzyAlgorithm) -> Self {
        self.algorithm = algorithm
        self
    }
    
    fn with_threshold(threshold: Float) -> Self {
        self.threshold = threshold
        self
    }
    
    fn case_sensitive(enabled: Bool) -> Self {
        self.case_sensitive = enabled
        self
    }
    
    fn with_max_distance(distance: Int) -> Self {
        self.max_distance = Some(distance)
        self
    }
}

/// Fuzzy matcher
struct FuzzyMatcher {
    config: FuzzyConfig
    
    fn new() -> Self {
        FuzzyMatcher { config: FuzzyConfig.default() }
    }
    
    fn with_config(config: FuzzyConfig) -> Self {
        FuzzyMatcher { config: config }
    }
    
    /// Check if two strings match within threshold
    fn matches(query: String, target: String) -> Bool {
        self.score(query, target) >= self.config.threshold
    }
    
    /// Calculate similarity score (0.0 to 1.0)
    fn score(query: String, target: String) -> Float {
        let q = if self.config.case_sensitive { query } else { query.to_lowercase() }
        let t = if self.config.case_sensitive { target } else { target.to_lowercase() }
        
        match self.config.algorithm {
            FuzzyAlgorithm.Levenshtein => levenshtein_similarity(q, t)
            FuzzyAlgorithm.DamerauLevenshtein => {
                let dist = damerau_levenshtein(q.clone(), t.clone())
                let max_len = max(q.len(), t.len())
                if max_len == 0 { 1.0 } else { 1.0 - dist as Float / max_len as Float }
            }
            FuzzyAlgorithm.Jaro => jaro(q, t)
            FuzzyAlgorithm.JaroWinkler => jaro_winkler(q, t)
            FuzzyAlgorithm.Cosine => cosine_similarity(q, t)
        }
    }
    
    /// Find best matches from a list
    fn find_matches(query: String, candidates: [String], limit: Int) -> [FuzzyMatch] {
        var matches: [FuzzyMatch] = []
        
        for candidate in candidates {
            let score = self.score(query.clone(), candidate.clone())
            
            if score >= self.config.threshold {
                let distance = levenshtein(
                    if self.config.case_sensitive { query.clone() } else { query.to_lowercase() },
                    if self.config.case_sensitive { candidate.clone() } else { candidate.to_lowercase() }
                )
                
                if let Some(max_dist) = self.config.max_distance {
                    if distance > max_dist { continue }
                }
                
                matches.push(FuzzyMatch.new(candidate, score, distance))
            }
        }
        
        matches.sort_by(|a, b| b.score.partial_cmp(a.score).unwrap_or(Ordering.Equal))
        matches.truncate(limit)
        matches
    }
    
    /// Find single best match
    fn find_best(query: String, candidates: [String]) -> Option<FuzzyMatch> {
        self.find_matches(query, candidates, 1).first().cloned()
    }
}

// =============================================================================
// Fuzzy Search Index
// =============================================================================

/// Fuzzy search index with BK-tree
struct FuzzyIndex {
    root: Option<BKNode>
    config: FuzzyConfig
    
    fn new() -> Self {
        FuzzyIndex { root: None, config: FuzzyConfig.default() }
    }
    
    fn with_config(config: FuzzyConfig) -> Self {
        FuzzyIndex { root: None, config: config }
    }
    
    /// Add word to index
    fn add(word: String) {
        let w = if self.config.case_sensitive { word } else { word.to_lowercase() }
        
        match self.root {
            None => self.root = Some(BKNode.new(w)),
            Some(ref mut root) => root.insert(w)
        }
    }
    
    /// Add multiple words
    fn add_all(words: [String]) {
        for word in words { self.add(word) }
    }
    
    /// Search for words within distance
    fn search(query: String, max_distance: Int) -> [FuzzyMatch] {
        let q = if self.config.case_sensitive { query } else { query.to_lowercase() }
        
        match self.root {
            None => [],
            Some(ref root) => {
                var results = []
                root.search(q.clone(), max_distance, results)
                
                // Calculate scores and sort
                for result in results.iter_mut() {
                    let max_len = max(q.len(), result.text.len())
                    result.score = if max_len == 0 { 1.0 } 
                        else { 1.0 - result.distance as Float / max_len as Float }
                }
                
                results.sort_by(|a, b| b.score.partial_cmp(a.score).unwrap_or(Ordering.Equal))
                results
            }
        }
    }
    
    /// Search with threshold
    fn search_threshold(query: String, threshold: Float) -> [FuzzyMatch] {
        let q = if self.config.case_sensitive { query } else { query.to_lowercase() }
        let max_distance = ((1.0 - threshold) * q.len() as Float).ceil() as Int
        
        self.search(q, max_distance)
            .into_iter()
            .filter(|m| m.score >= threshold)
            .collect()
    }
}

/// BK-tree node for efficient fuzzy search
struct BKNode {
    word: String
    children: Map<Int, BKNode>
    
    fn new(word: String) -> Self {
        BKNode { word: word, children: Map.empty() }
    }
    
    fn insert(word: String) {
        let dist = levenshtein(self.word.clone(), word.clone())
        
        match self.children.get_mut(dist) {
            Some(child) => child.insert(word),
            None => { self.children.set(dist, BKNode.new(word)); }
        }
    }
    
    fn search(query: String, max_distance: Int, results: [FuzzyMatch]) {
        let dist = levenshtein(self.word.clone(), query.clone())
        
        if dist <= max_distance {
            results.push(FuzzyMatch.new(self.word.clone(), 0.0, dist))
        }
        
        let min_dist = max(0, dist - max_distance)
        let max_dist = dist + max_distance
        
        for (d, child) in self.children.iter() {
            if d >= min_dist && d <= max_dist {
                child.search(query.clone(), max_distance, results)
            }
        }
    }
}

// =============================================================================
// Phonetic Matching
// =============================================================================

/// Soundex code
fn soundex(word: String) -> String {
    if word.is_empty() { return "" }
    
    let chars: [Char] = word.to_uppercase().chars().collect()
    var code = String.from(chars[0])
    
    let mapping = |c: Char| -> Option<Char> {
        match c {
            'B' | 'F' | 'P' | 'V' => Some('1')
            'C' | 'G' | 'J' | 'K' | 'Q' | 'S' | 'X' | 'Z' => Some('2')
            'D' | 'T' => Some('3')
            'L' => Some('4')
            'M' | 'N' => Some('5')
            'R' => Some('6')
            _ => None
        }
    }
    
    var prev_code = mapping(chars[0])
    
    for c in chars[1..].iter() {
        if code.len() >= 4 { break }
        
        let curr_code = mapping(c)
        if let Some(digit) = curr_code {
            if curr_code != prev_code {
                code.push(digit)
            }
        }
        prev_code = curr_code
    }
    
    while code.len() < 4 { code.push('0') }
    code
}

/// Metaphone code (simplified)
fn metaphone(word: String) -> String {
    if word.is_empty() { return "" }
    
    var result = ""
    let chars: [Char] = word.to_uppercase().chars().collect()
    var i = 0
    
    // Skip initial silent letters
    if chars.len() >= 2 {
        let prefix: String = chars[0..2].iter().collect()
        if ["KN", "GN", "PN", "AE", "WR"].contains(prefix) {
            i = 1
        }
    }
    
    while i < chars.len() && result.len() < 6 {
        let c = chars[i]
        let next = chars.get(i + 1)
        
        match c {
            'A' | 'E' | 'I' | 'O' | 'U' => {
                if i == 0 { result.push(c) }
            }
            'B' => {
                if i == 0 || chars.get(i - 1) != Some('M') {
                    result.push('B')
                }
            }
            'C' => {
                if next == Some('H') {
                    result.push('X')
                    i += 1
                } else if next == Some('I') || next == Some('E') || next == Some('Y') {
                    result.push('S')
                } else {
                    result.push('K')
                }
            }
            'D' => {
                if next == Some('G') {
                    let after = chars.get(i + 2)
                    if after == Some('E') || after == Some('I') || after == Some('Y') {
                        result.push('J')
                        i += 1
                    } else {
                        result.push('T')
                    }
                } else {
                    result.push('T')
                }
            }
            'F' | 'J' | 'L' | 'M' | 'N' | 'R' => result.push(c),
            'G' => {
                if next == Some('H') {
                    i += 1
                } else if next == Some('N') && chars.get(i + 2).is_none() {
                    // Silent GN at end
                } else {
                    result.push('K')
                }
            }
            'H' => {
                let prev = if i > 0 { chars.get(i - 1) } else { None }
                if !['A', 'E', 'I', 'O', 'U'].contains(prev.unwrap_or(' ')) {
                    result.push('H')
                }
            }
            'K' => {
                if i == 0 || chars.get(i - 1) != Some('C') {
                    result.push('K')
                }
            }
            'P' => {
                if next == Some('H') {
                    result.push('F')
                    i += 1
                } else {
                    result.push('P')
                }
            }
            'Q' => result.push('K'),
            'S' => {
                if next == Some('H') {
                    result.push('X')
                    i += 1
                } else {
                    result.push('S')
                }
            }
            'T' => {
                if next == Some('H') {
                    result.push('0')  // TH sound
                    i += 1
                } else if next != Some('C') || chars.get(i + 2) != Some('H') {
                    result.push('T')
                }
            }
            'V' => result.push('F'),
            'W' | 'Y' => {
                if ['A', 'E', 'I', 'O', 'U'].contains(next.unwrap_or(' ')) {
                    result.push(c)
                }
            }
            'X' => { result.push('K'); result.push('S') }
            'Z' => result.push('S'),
            _ => {}
        }
        
        i += 1
    }
    
    result
}

/// Check if two words sound similar
fn sounds_like(word1: String, word2: String) -> Bool {
    soundex(word1) == soundex(word2) || metaphone(word1.clone()) == metaphone(word2.clone())
}

// =============================================================================
// Spell Checker
// =============================================================================

/// Simple spell checker
struct SpellChecker {
    dictionary: FuzzyIndex
    word_frequencies: Map<String, Int>
    
    fn new() -> Self {
        SpellChecker {
            dictionary: FuzzyIndex.new(),
            word_frequencies: Map.empty()
        }
    }
    
    /// Add word to dictionary
    fn add_word(word: String, frequency: Int = 1) {
        let w = word.to_lowercase()
        self.dictionary.add(w.clone())
        *self.word_frequencies.entry(w).or_insert(0) += frequency
    }
    
    /// Add words from text
    fn train(text: String) {
        let words: [String] = text.to_lowercase()
            .split(|c: Char| !c.is_alphabetic())
            .filter(|s| !s.is_empty())
            .collect()
        
        for word in words {
            self.add_word(word, 1)
        }
    }
    
    /// Check if word is in dictionary
    fn is_correct(word: String) -> Bool {
        self.word_frequencies.contains(word.to_lowercase())
    }
    
    /// Get spelling suggestions
    fn suggest(word: String, limit: Int = 5) -> [String] {
        let w = word.to_lowercase()
        
        if self.is_correct(w.clone()) { return [w] }
        
        var candidates = self.dictionary.search(w, 2)
        
        // Sort by frequency then by distance
        candidates.sort_by(|a, b| {
            let freq_a = self.word_frequencies.get(a.text).unwrap_or(0)
            let freq_b = self.word_frequencies.get(b.text).unwrap_or(0)
            
            if a.distance != b.distance {
                a.distance.cmp(b.distance)
            } else {
                freq_b.cmp(freq_a)
            }
        })
        
        candidates.iter().take(limit).map(|m| m.text.clone()).collect()
    }
    
    /// Correct a word (return best suggestion or original)
    fn correct(word: String) -> String {
        self.suggest(word.clone(), 1).first().cloned().unwrap_or(word)
    }
}

// =============================================================================
// Tests
// =============================================================================

test "levenshtein distance" {
    assert_eq(levenshtein("kitten", "sitting"), 3)?
    assert_eq(levenshtein("", "abc"), 3)?
    assert_eq(levenshtein("abc", "abc"), 0)?
}

test "damerau levenshtein" {
    assert_eq(damerau_levenshtein("ca", "ac"), 1)?  // transposition
    assert_eq(levenshtein("ca", "ac"), 2)?  // no transposition
}

test "jaro similarity" {
    let sim = jaro("MARTHA", "MARHTA")
    assert(sim > 0.94)?
}

test "jaro winkler" {
    let sim = jaro_winkler("MARTHA", "MARHTA")
    assert(sim > 0.96)?  // Higher due to common prefix
}

test "fuzzy matcher" {
    let matcher = FuzzyMatcher.new()
    
    assert(matcher.matches("hello", "helo"))?
    assert(!matcher.matches("hello", "world"))?
    
    let candidates = ["apple", "application", "banana", "apply"]
    let matches = matcher.find_matches("aple", candidates, 3)
    assert_eq(matches[0].text, "apple")?
}

test "fuzzy index" {
    var index = FuzzyIndex.new()
    index.add_all(["hello", "help", "world", "held", "hero"])
    
    let results = index.search("helo", 2)
    assert(results.iter().any(|m| m.text == "hello"))?
    assert(results.iter().any(|m| m.text == "help"))?
}

test "soundex" {
    assert_eq(soundex("Robert"), "R163")?
    assert_eq(soundex("Rupert"), "R163")?
    assert_eq(soundex("Smith"), soundex("Smyth"))?
}

test "metaphone" {
    assert_eq(metaphone("phone"), metaphone("fone"))?
}

test "spell checker" {
    var checker = SpellChecker.new()
    checker.train("the quick brown fox jumps over the lazy dog")
    
    assert(checker.is_correct("quick"))?
    assert(!checker.is_correct("quik"))?
    
    let suggestions = checker.suggest("quik", 3)
    assert(suggestions.contains("quick"))?
}

test "lcs" {
    assert_eq(lcs_length("ABCDGH", "AEDFHR"), 3)?  // ADH
}

test "cosine similarity" {
    let sim = cosine_similarity("hello", "hallo")
    assert(sim > 0.5)?
}
