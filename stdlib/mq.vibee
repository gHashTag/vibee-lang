// =============================================================================
// Vibee OS â€” Message Queue Module
// Pub/Sub, message queues, and event streaming
// =============================================================================

// -----------------------------------------------------------------------------
// Message Broker Interface
// -----------------------------------------------------------------------------

/// Message broker trait
trait Broker {
    fn publish(topic: String, message: Message) -> Result<(), BrokerError>
    fn subscribe(topic: String) -> Result<Subscription, BrokerError>
    fn create_queue(name: String, options: QueueOptions) -> Result<Queue, BrokerError>
    fn close() -> Result<(), BrokerError>
}

/// Message
struct Message {
    id: String
    topic: String
    payload: [Byte]
    headers: Map<String, String>
    timestamp: Instant
    
    /// Create text message
    fn text(content: String) -> Self {
        Message {
            id: UUID.v4(),
            topic: "",
            payload: content.bytes(),
            headers: Map.empty(),
            timestamp: Instant.now()
        }
    }
    
    /// Create JSON message
    fn json<T: Serialize>(data: T) -> Self {
        Message {
            id: UUID.v4(),
            topic: "",
            payload: JSON.stringify(data).bytes(),
            headers: Map.from([("content-type", "application/json")]),
            timestamp: Instant.now()
        }
    }
    
    /// Create binary message
    fn binary(data: [Byte]) -> Self {
        Message {
            id: UUID.v4(),
            topic: "",
            payload: data,
            headers: Map.empty(),
            timestamp: Instant.now()
        }
    }
    
    /// Get payload as string
    fn as_string() -> Result<String, DecodeError> {
        String.from_utf8(self.payload)
    }
    
    /// Get payload as JSON
    fn as_json<T: Deserialize>() -> Result<T, DecodeError> {
        let text = self.as_string()?
        JSON.parse(text)
    }
    
    /// Set header
    fn with_header(key: String, value: String) -> Self {
        self.headers.set(key, value)
        self
    }
    
    /// Set correlation ID
    fn with_correlation_id(id: String) -> Self {
        self.headers.set("correlation-id", id)
        self
    }
    
    /// Set reply-to topic
    fn with_reply_to(topic: String) -> Self {
        self.headers.set("reply-to", topic)
        self
    }
}

/// Subscription
trait Subscription {
    fn receive() -> Result<Message, BrokerError>
    fn receive_timeout(timeout: Duration) -> Result<Option<Message>, BrokerError>
    fn unsubscribe() -> Result<(), BrokerError>
}

/// Queue
trait Queue {
    fn send(message: Message) -> Result<(), BrokerError>
    fn receive() -> Result<Message, BrokerError>
    fn receive_timeout(timeout: Duration) -> Result<Option<Message>, BrokerError>
    fn ack(message_id: String) -> Result<(), BrokerError>
    fn nack(message_id: String, requeue: Bool) -> Result<(), BrokerError>
    fn purge() -> Result<Int, BrokerError>
    fn delete() -> Result<(), BrokerError>
}

/// Queue options
struct QueueOptions {
    durable: Bool
    exclusive: Bool
    auto_delete: Bool
    max_length: Option<Int>
    max_size_bytes: Option<Int>
    message_ttl: Option<Duration>
    dead_letter_topic: Option<String>
    
    fn default() -> Self {
        QueueOptions {
            durable: true,
            exclusive: false,
            auto_delete: false,
            max_length: None,
            max_size_bytes: None,
            message_ttl: None,
            dead_letter_topic: None
        }
    }
    
    fn transient() -> Self {
        QueueOptions {
            durable: false,
            exclusive: true,
            auto_delete: true,
            max_length: None,
            max_size_bytes: None,
            message_ttl: None,
            dead_letter_topic: None
        }
    }
}

// -----------------------------------------------------------------------------
// In-Memory Broker
// -----------------------------------------------------------------------------

/// In-memory message broker (for testing/development)
actor MemoryBroker: Broker {
    state topics: Map<String, [MemorySubscription]>
    state queues: Map<String, MemoryQueue>
    
    fn new() -> Self {
        MemoryBroker {
            topics: Map.empty(),
            queues: Map.empty()
        }
    }
    
    fn publish(topic: String, message: Message) -> Result<(), BrokerError> {
        var msg = message
        msg.topic = topic
        
        if let subs = self.topics.get(topic) {
            for sub in subs {
                sub.deliver(msg.clone())
            }
        }
        
        // Pattern matching for wildcard subscriptions
        for (pattern, subs) in self.topics {
            if self.matches_pattern(pattern, topic) && pattern != topic {
                for sub in subs {
                    sub.deliver(msg.clone())
                }
            }
        }
        
        Ok(())
    }
    
    fn subscribe(topic: String) -> Result<Subscription, BrokerError> {
        let sub = MemorySubscription.new(topic)
        self.topics.entry(topic).or_default().append(sub)
        Ok(sub)
    }
    
    fn create_queue(name: String, options: QueueOptions) -> Result<Queue, BrokerError> {
        if self.queues.contains_key(name) {
            return Err(BrokerError.QueueExists(name))
        }
        
        let queue = MemoryQueue.new(name, options)
        self.queues.set(name, queue)
        Ok(queue)
    }
    
    fn close() -> Result<(), BrokerError> {
        self.topics.clear()
        self.queues.clear()
        Ok(())
    }
    
    fn matches_pattern(pattern: String, topic: String) -> Bool {
        if pattern == topic { return true }
        
        // Simple wildcard matching
        // * matches one segment
        // # matches zero or more segments
        let pattern_parts = pattern.split(".")
        let topic_parts = topic.split(".")
        
        self.match_parts(pattern_parts, topic_parts)
    }
    
    fn match_parts(pattern: [String], topic: [String]) -> Bool {
        if pattern.is_empty() && topic.is_empty() {
            return true
        }
        if pattern.is_empty() {
            return false
        }
        
        match pattern[0] {
            "#" => {
                // # matches everything remaining
                true
            }
            "*" => {
                // * matches exactly one segment
                if topic.is_empty() {
                    false
                } else {
                    self.match_parts(pattern[1..], topic[1..])
                }
            }
            segment => {
                if topic.is_empty() || topic[0] != segment {
                    false
                } else {
                    self.match_parts(pattern[1..], topic[1..])
                }
            }
        }
    }
}

/// In-memory subscription
actor MemorySubscription: Subscription {
    state topic: String
    state messages: Channel<Message>
    state active: Bool
    
    fn new(topic: String) -> Self {
        MemorySubscription {
            topic: topic,
            messages: Channel.unbounded(),
            active: true
        }
    }
    
    fn deliver(message: Message) {
        if self.active {
            self.messages.send(message)
        }
    }
    
    fn receive() -> Result<Message, BrokerError> {
        if !self.active {
            return Err(BrokerError.SubscriptionClosed)
        }
        self.messages.recv().map_err(|_| BrokerError.SubscriptionClosed)
    }
    
    fn receive_timeout(timeout: Duration) -> Result<Option<Message>, BrokerError> {
        if !self.active {
            return Err(BrokerError.SubscriptionClosed)
        }
        match self.messages.recv_timeout(timeout) {
            Ok(msg) => Ok(Some(msg))
            Err(RecvError.Timeout) => Ok(None)
            Err(_) => Err(BrokerError.SubscriptionClosed)
        }
    }
    
    fn unsubscribe() -> Result<(), BrokerError> {
        self.active = false
        self.messages.close()
        Ok(())
    }
}

/// In-memory queue
actor MemoryQueue: Queue {
    state name: String
    state options: QueueOptions
    state messages: Channel<Message>
    state pending_acks: Map<String, Message>
    
    fn new(name: String, options: QueueOptions) -> Self {
        let capacity = options.max_length.unwrap_or(10000)
        MemoryQueue {
            name: name,
            options: options,
            messages: Channel.bounded(capacity),
            pending_acks: Map.empty()
        }
    }
    
    fn send(message: Message) -> Result<(), BrokerError> {
        // Check TTL
        if let ttl = self.options.message_ttl {
            if message.timestamp + ttl < Instant.now() {
                return Ok(())  // Message expired, discard
            }
        }
        
        self.messages.try_send(message).map_err(|_| BrokerError.QueueFull)
    }
    
    fn receive() -> Result<Message, BrokerError> {
        let msg = self.messages.recv().map_err(|_| BrokerError.QueueClosed)?
        self.pending_acks.set(msg.id, msg.clone())
        Ok(msg)
    }
    
    fn receive_timeout(timeout: Duration) -> Result<Option<Message>, BrokerError> {
        match self.messages.recv_timeout(timeout) {
            Ok(msg) => {
                self.pending_acks.set(msg.id, msg.clone())
                Ok(Some(msg))
            }
            Err(RecvError.Timeout) => Ok(None)
            Err(_) => Err(BrokerError.QueueClosed)
        }
    }
    
    fn ack(message_id: String) -> Result<(), BrokerError> {
        self.pending_acks.remove(message_id)
        Ok(())
    }
    
    fn nack(message_id: String, requeue: Bool) -> Result<(), BrokerError> {
        if let msg = self.pending_acks.remove(message_id) {
            if requeue {
                self.messages.send(msg)
            } else if let dlq = self.options.dead_letter_topic {
                // Send to dead letter queue
                // Would need broker reference here
            }
        }
        Ok(())
    }
    
    fn purge() -> Result<Int, BrokerError> {
        var count = 0
        while self.messages.try_recv().is_ok() {
            count += 1
        }
        Ok(count)
    }
    
    fn delete() -> Result<(), BrokerError> {
        self.messages.close()
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Pub/Sub Patterns
// -----------------------------------------------------------------------------

/// Publisher
actor Publisher<B: Broker> {
    state broker: B
    state default_topic: Option<String>
    state middleware: [(Message) -> Message]
    
    fn new(broker: B) -> Self {
        Publisher {
            broker: broker,
            middleware: []
        }
    }
    
    /// Set default topic
    on topic(t: String) -> Self {
        self.default_topic = Some(t)
        self
    }
    
    /// Add middleware
    on middleware(f: (Message) -> Message) -> Self {
        self.middleware.append(f)
        self
    }
    
    /// Publish message
    on publish(message: Message) -> Result<(), BrokerError> {
        let topic = message.topic.or(self.default_topic)
            .ok_or(BrokerError.NoTopic)?
        
        var msg = message
        for mw in self.middleware {
            msg = mw(msg)
        }
        
        self.broker.publish(topic, msg)
    }
    
    /// Publish text
    on publish_text(topic: String, text: String) -> Result<(), BrokerError> {
        self.broker.publish(topic, Message.text(text))
    }
    
    /// Publish JSON
    on publish_json<T: Serialize>(topic: String, data: T) -> Result<(), BrokerError> {
        self.broker.publish(topic, Message.json(data))
    }
}

/// Subscriber
actor Subscriber<B: Broker> {
    state broker: B
    state subscriptions: [Subscription]
    state handlers: Map<String, (Message) -> ()>
    state error_handler: Option<(BrokerError) -> ()>
    state running: Bool
    
    fn new(broker: B) -> Self {
        Subscriber {
            broker: broker,
            subscriptions: [],
            handlers: Map.empty(),
            running: false
        }
    }
    
    /// Subscribe to topic with handler
    on on(topic: String, handler: (Message) -> ()) -> Result<Self, BrokerError> {
        let sub = self.broker.subscribe(topic)?
        self.subscriptions.append(sub)
        self.handlers.set(topic, handler)
        Ok(self)
    }
    
    /// Set error handler
    on on_error(handler: (BrokerError) -> ()) -> Self {
        self.error_handler = Some(handler)
        self
    }
    
    /// Start listening
    on start() {
        self.running = true
        
        for sub in self.subscriptions {
            async {
                while self.running {
                    match sub.receive() {
                        Ok(msg) => {
                            if let handler = self.handlers.get(msg.topic) {
                                handler(msg)
                            }
                        }
                        Err(e) => {
                            if let handler = self.error_handler {
                                handler(e)
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// Stop listening
    on stop() {
        self.running = false
        for sub in self.subscriptions {
            let _ = sub.unsubscribe()
        }
    }
}

// -----------------------------------------------------------------------------
// Request/Reply Pattern
// -----------------------------------------------------------------------------

/// Request/Reply client
actor RequestReply<B: Broker> {
    state broker: B
    state reply_topic: String
    state pending: Map<String, Channel<Message>>
    state timeout: Duration
    
    fn new(broker: B) -> Result<Self, BrokerError> {
        let reply_topic = "reply.\(UUID.v4())"
        let client = RequestReply {
            broker: broker,
            reply_topic: reply_topic,
            pending: Map.empty(),
            timeout: Duration.seconds(30)
        }
        
        // Subscribe to reply topic
        let sub = broker.subscribe(reply_topic)?
        async {
            while let Ok(msg) = sub.receive() {
                if let corr_id = msg.headers.get("correlation-id") {
                    if let ch = client.pending.remove(corr_id) {
                        ch.send(msg)
                    }
                }
            }
        }
        
        Ok(client)
    }
    
    /// Set timeout
    on timeout(d: Duration) -> Self {
        self.timeout = d
        self
    }
    
    /// Send request and wait for reply
    on request(topic: String, message: Message) -> Result<Message, BrokerError> {
        let corr_id = UUID.v4()
        let reply_ch = Channel.bounded(1)
        
        self.pending.set(corr_id, reply_ch)
        
        let msg = message
            .with_correlation_id(corr_id)
            .with_reply_to(self.reply_topic)
        
        self.broker.publish(topic, msg)?
        
        match reply_ch.recv_timeout(self.timeout) {
            Ok(reply) => Ok(reply)
            Err(RecvError.Timeout) => {
                self.pending.remove(corr_id)
                Err(BrokerError.Timeout)
            }
            Err(_) => Err(BrokerError.ChannelClosed)
        }
    }
}

/// Request/Reply server
actor RequestReplyServer<B: Broker> {
    state broker: B
    state handlers: Map<String, (Message) -> Result<Message, String>>
    state running: Bool
    
    fn new(broker: B) -> Self {
        RequestReplyServer {
            broker: broker,
            handlers: Map.empty(),
            running: false
        }
    }
    
    /// Register handler for topic
    on handle(topic: String, handler: (Message) -> Result<Message, String>) -> Result<Self, BrokerError> {
        self.handlers.set(topic, handler)
        
        let sub = self.broker.subscribe(topic)?
        let broker = self.broker
        let handlers = self.handlers
        
        async {
            while let Ok(msg) = sub.receive() {
                if let reply_to = msg.headers.get("reply-to") {
                    if let corr_id = msg.headers.get("correlation-id") {
                        if let handler = handlers.get(msg.topic) {
                            let reply = match handler(msg) {
                                Ok(response) => response
                                    .with_correlation_id(corr_id)
                                Err(error) => Message.text(error)
                                    .with_correlation_id(corr_id)
                                    .with_header("error", "true")
                            }
                            let _ = broker.publish(reply_to, reply)
                        }
                    }
                }
            }
        }
        
        Ok(self)
    }
}

// -----------------------------------------------------------------------------
// Work Queue Pattern
// -----------------------------------------------------------------------------

/// Work queue consumer
actor Worker<B: Broker> {
    state broker: B
    state queue: Queue
    state handler: (Message) -> Result<(), String>
    state concurrency: Int
    state running: Bool
    
    fn new(broker: B, queue_name: String) -> Result<Self, BrokerError> {
        let queue = broker.create_queue(queue_name, QueueOptions.default())?
        Ok(Worker {
            broker: broker,
            queue: queue,
            concurrency: 1,
            running: false
        })
    }
    
    /// Set handler
    on handler(f: (Message) -> Result<(), String>) -> Self {
        self.handler = f
        self
    }
    
    /// Set concurrency
    on concurrency(n: Int) -> Self {
        self.concurrency = n
        self
    }
    
    /// Start processing
    on start() {
        self.running = true
        
        for _ in 0..self.concurrency {
            async {
                while self.running {
                    match self.queue.receive() {
                        Ok(msg) => {
                            match self.handler(msg) {
                                Ok(()) => {
                                    let _ = self.queue.ack(msg.id)
                                }
                                Err(_) => {
                                    let _ = self.queue.nack(msg.id, true)
                                }
                            }
                        }
                        Err(_) => break
                    }
                }
            }
        }
    }
    
    /// Stop processing
    on stop() {
        self.running = false
    }
}

// -----------------------------------------------------------------------------
// Event Sourcing
// -----------------------------------------------------------------------------

/// Event store
actor EventStore<B: Broker> {
    state broker: B
    state events: Map<String, [StoredEvent]>  // stream_id -> events
    
    fn new(broker: B) -> Self {
        EventStore {
            broker: broker,
            events: Map.empty()
        }
    }
    
    /// Append event to stream
    on append(stream_id: String, event: Event) -> Result<Int, BrokerError> {
        let events = self.events.entry(stream_id).or_default()
        let version = events.len()
        
        let stored = StoredEvent {
            stream_id: stream_id,
            version: version,
            event_type: event.type_,
            data: event.data,
            metadata: event.metadata,
            timestamp: Instant.now()
        }
        
        events.append(stored)
        
        // Publish event
        let topic = "events.\(stream_id)"
        self.broker.publish(topic, Message.json(stored))?
        
        Ok(version)
    }
    
    /// Read events from stream
    fn read(stream_id: String, from_version: Int = 0) -> [StoredEvent] {
        self.events.get(stream_id)
            .map(|events| events[from_version..])
            .unwrap_or([])
    }
    
    /// Read all events
    fn read_all(from_position: Int = 0) -> [StoredEvent] {
        self.events.values()
            .flatten()
            .sorted_by(|a, b| a.timestamp.cmp(b.timestamp))
            .skip(from_position)
            .collect()
    }
    
    /// Subscribe to stream
    fn subscribe(stream_id: String) -> Result<Subscription, BrokerError> {
        self.broker.subscribe("events.\(stream_id)")
    }
    
    /// Subscribe to all events
    fn subscribe_all() -> Result<Subscription, BrokerError> {
        self.broker.subscribe("events.#")
    }
}

struct Event {
    type_: String
    data: [Byte]
    metadata: Map<String, String>
    
    fn new<T: Serialize>(type_: String, data: T) -> Self {
        Event {
            type_: type_,
            data: JSON.stringify(data).bytes(),
            metadata: Map.empty()
        }
    }
}

struct StoredEvent {
    stream_id: String
    version: Int
    event_type: String
    data: [Byte]
    metadata: Map<String, String>
    timestamp: Instant
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum BrokerError {
    ConnectionFailed(String)
    QueueExists(String)
    QueueNotFound(String)
    QueueFull
    QueueClosed
    SubscriptionClosed
    NoTopic
    Timeout
    ChannelClosed
    SerializationError(String)
    
    fn message() -> String {
        match self {
            .ConnectionFailed(msg) => "Connection failed: \(msg)"
            .QueueExists(name) => "Queue already exists: \(name)"
            .QueueNotFound(name) => "Queue not found: \(name)"
            .QueueFull => "Queue is full"
            .QueueClosed => "Queue is closed"
            .SubscriptionClosed => "Subscription is closed"
            .NoTopic => "No topic specified"
            .Timeout => "Operation timed out"
            .ChannelClosed => "Channel closed"
            .SerializationError(msg) => "Serialization error: \(msg)"
        }
    }
}

enum DecodeError {
    InvalidUTF8
    InvalidJSON(String)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "memory broker pub/sub" {
    let broker = MemoryBroker.new()
    
    let sub = broker.subscribe("test.topic")?
    broker.publish("test.topic", Message.text("hello"))?
    
    let msg = sub.receive()?
    assert(msg.as_string()? == "hello")
}

test "wildcard subscription" {
    let broker = MemoryBroker.new()
    
    let sub = broker.subscribe("events.*")?
    broker.publish("events.user", Message.text("user event"))?
    broker.publish("events.order", Message.text("order event"))?
    
    let msg1 = sub.receive()?
    let msg2 = sub.receive()?
    
    assert(msg1.as_string()? == "user event")
    assert(msg2.as_string()? == "order event")
}

test "queue operations" {
    let broker = MemoryBroker.new()
    let queue = broker.create_queue("work", QueueOptions.default())?
    
    queue.send(Message.text("task1"))?
    queue.send(Message.text("task2"))?
    
    let msg = queue.receive()?
    assert(msg.as_string()? == "task1")
    queue.ack(msg.id)?
}

test "message json" {
    struct TestData { name: String, value: Int }
    
    let msg = Message.json(TestData { name: "test", value: 42 })
    let data: TestData = msg.as_json()?
    
    assert(data.name == "test")
    assert(data.value == 42)
}
