// =============================================================================
// Vibee OS â€” Bloom Filter Module
// Probabilistic set membership
// =============================================================================

/// Bloom filter
struct BloomFilter {
    bits: [UInt64]
    num_bits: Int
    num_hashes: Int
    count: Int
    
    /// Create with expected items and false positive rate
    fn new(expected_items: Int, fp_rate: Float64) -> Self {
        let num_bits = optimal_bits(expected_items, fp_rate)
        let num_hashes = optimal_hashes(num_bits, expected_items)
        let words = (num_bits + 63) / 64
        BloomFilter { bits: [0u64; words], num_bits: num_bits, num_hashes: num_hashes, count: 0 }
    }
    
    /// Create with specific size
    fn with_size(num_bits: Int, num_hashes: Int) -> Self {
        let words = (num_bits + 63) / 64
        BloomFilter { bits: [0u64; words], num_bits: num_bits, num_hashes: num_hashes, count: 0 }
    }
    
    /// Add item
    fn add<T: Hash>(item: T) {
        for i in 0..self.num_hashes {
            let idx = self.hash_index(item, i)
            self.bits[idx / 64] |= 1u64 << (idx % 64)
        }
        self.count += 1
    }
    
    /// Check if item might be in set
    fn contains<T: Hash>(item: T) -> Bool {
        for i in 0..self.num_hashes {
            let idx = self.hash_index(item, i)
            if (self.bits[idx / 64] >> (idx % 64)) & 1 == 0 {
                return false
            }
        }
        true
    }
    
    /// Clear filter
    fn clear() {
        for i in 0..self.bits.len() { self.bits[i] = 0 }
        self.count = 0
    }
    
    /// Estimated false positive rate
    fn fp_rate() -> Float64 {
        let k = self.num_hashes as Float64
        let m = self.num_bits as Float64
        let n = self.count as Float64
        (1.0 - (-k * n / m).exp()).pow(k)
    }
    
    /// Union with another filter
    fn union(other: BloomFilter) -> Self {
        var result = Self.with_size(self.num_bits, self.num_hashes)
        for i in 0..self.bits.len() {
            result.bits[i] = self.bits[i] | other.bits[i]
        }
        result.count = self.count + other.count
        result
    }
    
    /// Intersection with another filter
    fn intersection(other: BloomFilter) -> Self {
        var result = Self.with_size(self.num_bits, self.num_hashes)
        for i in 0..self.bits.len() {
            result.bits[i] = self.bits[i] & other.bits[i]
        }
        result
    }
    
    fn hash_index<T: Hash>(item: T, seed: Int) -> Int {
        let h1 = item.hash()
        let h2 = item.hash() ^ (seed as UInt64 * 0x9e3779b97f4a7c15)
        ((h1 + seed as UInt64 * h2) % self.num_bits as UInt64) as Int
    }
    
    fn count() -> Int { self.count }
    fn size() -> Int { self.num_bits }
}

fn optimal_bits(n: Int, p: Float64) -> Int {
    (-(n as Float64 * p.ln()) / (2.0f64.ln().pow(2))).ceil() as Int
}

fn optimal_hashes(m: Int, n: Int) -> Int {
    ((m as Float64 / n as Float64) * 2.0f64.ln()).ceil() as Int
}

// -----------------------------------------------------------------------------
// Counting Bloom Filter
// -----------------------------------------------------------------------------

/// Counting bloom filter (supports removal)
struct CountingBloomFilter {
    counts: [UInt8]
    num_bits: Int
    num_hashes: Int
    
    fn new(expected_items: Int, fp_rate: Float64) -> Self {
        let num_bits = optimal_bits(expected_items, fp_rate)
        let num_hashes = optimal_hashes(num_bits, expected_items)
        CountingBloomFilter { counts: [0u8; num_bits], num_bits: num_bits, num_hashes: num_hashes }
    }
    
    fn add<T: Hash>(item: T) {
        for i in 0..self.num_hashes {
            let idx = self.hash_index(item, i)
            if self.counts[idx] < 255 { self.counts[idx] += 1 }
        }
    }
    
    fn remove<T: Hash>(item: T) {
        if !self.contains(item) { return }
        for i in 0..self.num_hashes {
            let idx = self.hash_index(item, i)
            if self.counts[idx] > 0 { self.counts[idx] -= 1 }
        }
    }
    
    fn contains<T: Hash>(item: T) -> Bool {
        for i in 0..self.num_hashes {
            let idx = self.hash_index(item, i)
            if self.counts[idx] == 0 { return false }
        }
        true
    }
    
    fn hash_index<T: Hash>(item: T, seed: Int) -> Int {
        let h1 = item.hash()
        let h2 = item.hash() ^ (seed as UInt64 * 0x9e3779b97f4a7c15)
        ((h1 + seed as UInt64 * h2) % self.num_bits as UInt64) as Int
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "add and contains" {
    var bf = BloomFilter.new(1000, 0.01)
    bf.add("hello")
    bf.add("world")
    assert(bf.contains("hello"))?
    assert(bf.contains("world"))?
}

test "false negatives impossible" {
    var bf = BloomFilter.new(100, 0.01)
    for i in 0..100 { bf.add(i) }
    for i in 0..100 { assert(bf.contains(i))? }
}

test "counting filter removal" {
    var bf = CountingBloomFilter.new(100, 0.01)
    bf.add("test")
    assert(bf.contains("test"))?
    bf.remove("test")
    assert(!bf.contains("test"))?
}
