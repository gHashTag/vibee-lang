// =============================================================================
// Vibee OS â€” WebSocket V2 Module
// Extended WebSocket implementation with advanced features
// =============================================================================

use http.{Request, Response, Headers}
use tls.{TlsStream, TlsConfig}
use net.{TcpStream, SocketAddr}

// -----------------------------------------------------------------------------
// WebSocket Frame
// -----------------------------------------------------------------------------

enum Opcode { Continuation, Text, Binary, Close, Ping, Pong }

impl Opcode {
    fn from_u8(v: UInt8) -> Option<Self> {
        match v { 0 => Some(Continuation), 1 => Some(Text), 2 => Some(Binary), 8 => Some(Close), 9 => Some(Ping), 10 => Some(Pong), _ => None }
    }
    fn to_u8() -> UInt8 {
        match self { Continuation => 0, Text => 1, Binary => 2, Close => 8, Ping => 9, Pong => 10 }
    }
}

struct Frame {
    fin: Bool
    opcode: Opcode
    mask: Option<[UInt8; 4]>
    payload: [UInt8]
}

impl Frame {
    fn text(data: String) -> Self { Frame { fin: true, opcode: Opcode.Text, mask: None, payload: data.as_bytes() } }
    fn binary(data: [UInt8]) -> Self { Frame { fin: true, opcode: Opcode.Binary, mask: None, payload: data } }
    fn close(code: CloseCode, reason: String) -> Self {
        var payload = [(code.to_u16() >> 8) as UInt8, code.to_u16() as UInt8]
        payload.extend(reason.as_bytes())
        Frame { fin: true, opcode: Opcode.Close, mask: None, payload: payload }
    }
    fn ping(data: [UInt8]) -> Self { Frame { fin: true, opcode: Opcode.Ping, mask: None, payload: data } }
    fn pong(data: [UInt8]) -> Self { Frame { fin: true, opcode: Opcode.Pong, mask: None, payload: data } }
    
    fn encode() -> [UInt8] {
        var buf = []
        buf.push((if self.fin { 0x80 } else { 0 }) | self.opcode.to_u8())
        let len = self.payload.len()
        let masked = self.mask.is_some()
        if len < 126 { buf.push((if masked { 0x80 } else { 0 }) | len as UInt8) }
        else if len < 65536 {
            buf.push((if masked { 0x80 } else { 0 }) | 126)
            buf.push((len >> 8) as UInt8)
            buf.push(len as UInt8)
        } else {
            buf.push((if masked { 0x80 } else { 0 }) | 127)
            for i in (0..8).rev() { buf.push((len >> (i * 8)) as UInt8) }
        }
        if let Some(mask) = self.mask {
            buf.extend(mask)
            for (i, b) in self.payload.iter().enumerate() { buf.push(b ^ mask[i % 4]) }
        } else { buf.extend(self.payload) }
        buf
    }
}

// -----------------------------------------------------------------------------
// Close Codes
// -----------------------------------------------------------------------------

enum CloseCode { Normal, GoingAway, ProtocolError, UnsupportedData, NoStatus, Abnormal, InvalidPayload, PolicyViolation, MessageTooBig, MandatoryExtension, InternalError, ServiceRestart, TryAgainLater, Custom(UInt16) }

impl CloseCode {
    fn to_u16() -> UInt16 {
        match self { Normal => 1000, GoingAway => 1001, ProtocolError => 1002, UnsupportedData => 1003, NoStatus => 1005, Abnormal => 1006, InvalidPayload => 1007, PolicyViolation => 1008, MessageTooBig => 1009, MandatoryExtension => 1010, InternalError => 1011, ServiceRestart => 1012, TryAgainLater => 1013, Custom(c) => c }
    }
}

// -----------------------------------------------------------------------------
// Message Types
// -----------------------------------------------------------------------------

enum Message { Text(String), Binary([UInt8]), Ping([UInt8]), Pong([UInt8]), Close(CloseCode, String) }

impl Message {
    fn is_text() -> Bool { matches!(self, Text(_)) }
    fn is_binary() -> Bool { matches!(self, Binary(_)) }
    fn as_text() -> Option<String> { match self { Text(s) => Some(s), _ => None } }
    fn as_binary() -> Option<[UInt8]> { match self { Binary(b) => Some(b), _ => None } }
}

// -----------------------------------------------------------------------------
// WebSocket Client V2
// -----------------------------------------------------------------------------

actor WebSocketV2 {
    state url: String
    state stream: Option<TlsStream>
    state state: WsState
    state protocols: [String]
    state extensions: [Extension]
    state config: WsConfig
    state on_message: Option<fn(Message)>
    state on_close: Option<fn(CloseCode, String)>
    state on_error: Option<fn(WsError)>
    state ping_interval: Option<Duration>
    state last_pong: Instant
    state message_queue: [Message]
    state compression: Option<PerMessageDeflate>
}

enum WsState { Connecting, Open, Closing, Closed }

struct WsConfig {
    max_message_size: Int
    max_frame_size: Int
    auto_ping: Bool
    ping_interval: Duration
    pong_timeout: Duration
    compression: Bool
    subprotocols: [String]
}

impl WsConfig {
    fn default() -> Self {
        WsConfig { max_message_size: 16777216, max_frame_size: 1048576, auto_ping: true, ping_interval: Duration.seconds(30), pong_timeout: Duration.seconds(10), compression: true, subprotocols: [] }
    }
}

impl WebSocketV2 {
    fn connect(url: String) -> Result<Self, WsError> { Self.connect_with(url, WsConfig.default()) }
    
    fn connect_with(url: String, config: WsConfig) -> Result<Self, WsError> {
        let (host, port, path, secure) = parse_ws_url(url)?
        let key = base64.encode(@native("random_bytes", 16))
        
        var req = format!("GET {} HTTP/1.1\r\nHost: {}\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: {}\r\nSec-WebSocket-Version: 13\r\n", path, host, key)
        if config.compression { req += "Sec-WebSocket-Extensions: permessage-deflate\r\n" }
        if !config.subprotocols.is_empty() { req += format!("Sec-WebSocket-Protocol: {}\r\n", config.subprotocols.join(", ")) }
        req += "\r\n"
        
        let stream = if secure { TlsStream.connect(host, port)? } else { TcpStream.connect(format!("{}:{}", host, port))? }
        stream.write_all(req.as_bytes())?
        
        var ws = WebSocketV2 { url: url, stream: Some(stream), state: WsState.Open, protocols: [], extensions: [], config: config, on_message: None, on_close: None, on_error: None, ping_interval: None, last_pong: Instant.now(), message_queue: [], compression: None }
        if config.auto_ping { ws.start_ping_loop() }
        Ok(ws)
    }
    
    fn send(msg: Message) -> Result<(), WsError> {
        if self.state != WsState.Open { return Err(WsError.NotConnected) }
        let frame = match msg {
            Message.Text(s) => Frame.text(s)
            Message.Binary(b) => Frame.binary(b)
            Message.Ping(d) => Frame.ping(d)
            Message.Pong(d) => Frame.pong(d)
            Message.Close(c, r) => Frame.close(c, r)
        }
        self.send_frame(frame)
    }
    
    fn send_text(text: String) -> Result<(), WsError> { self.send(Message.Text(text)) }
    fn send_binary(data: [UInt8]) -> Result<(), WsError> { self.send(Message.Binary(data)) }
    fn send_json<T: Serialize>(data: T) -> Result<(), WsError> { self.send_text(json.encode(data)) }
    
    fn send_frame(frame: Frame) -> Result<(), WsError> {
        let stream = self.stream.as_mut().ok_or(WsError.NotConnected)?
        var frame = frame
        frame.mask = Some(@native("random_bytes", 4))
        stream.write_all(frame.encode())?
        Ok(())
    }
    
    fn recv() -> Result<Message, WsError> {
        let frame = self.recv_frame()?
        match frame.opcode {
            Opcode.Text => Ok(Message.Text(String.from_utf8(frame.payload)?))
            Opcode.Binary => Ok(Message.Binary(frame.payload))
            Opcode.Ping => { self.send_frame(Frame.pong(frame.payload))?; self.recv() }
            Opcode.Pong => { self.last_pong = Instant.now(); self.recv() }
            Opcode.Close => {
                let code = if frame.payload.len() >= 2 { CloseCode.Custom(((frame.payload[0] as UInt16) << 8) | frame.payload[1] as UInt16) } else { CloseCode.NoStatus }
                let reason = if frame.payload.len() > 2 { String.from_utf8(frame.payload[2..].to_vec()).unwrap_or("") } else { "" }
                self.state = WsState.Closed
                Ok(Message.Close(code, reason))
            }
            _ => self.recv()
        }
    }
    
    fn recv_frame() -> Result<Frame, WsError> {
        let stream = self.stream.as_mut().ok_or(WsError.NotConnected)?
        var header = [0u8; 2]
        stream.read_exact(header)?
        let fin = header[0] & 0x80 != 0
        let opcode = Opcode.from_u8(header[0] & 0x0F).ok_or(WsError.Protocol("Invalid opcode"))?
        let masked = header[1] & 0x80 != 0
        var len = (header[1] & 0x7F) as Int
        if len == 126 { var buf = [0u8; 2]; stream.read_exact(buf)?; len = ((buf[0] as Int) << 8) | buf[1] as Int }
        else if len == 127 { var buf = [0u8; 8]; stream.read_exact(buf)?; len = 0; for b in buf { len = (len << 8) | b as Int } }
        var mask = None
        if masked { var m = [0u8; 4]; stream.read_exact(m)?; mask = Some(m) }
        var payload = [0u8; len]
        stream.read_exact(payload)?
        if let Some(m) = mask { for (i, b) in payload.iter_mut().enumerate() { *b ^= m[i % 4] } }
        Ok(Frame { fin: fin, opcode: opcode, mask: mask, payload: payload })
    }
    
    fn on_message(handler: fn(Message)) -> Self { self.on_message = Some(handler); self }
    fn on_close(handler: fn(CloseCode, String)) -> Self { self.on_close = Some(handler); self }
    fn on_error(handler: fn(WsError)) -> Self { self.on_error = Some(handler); self }
    
    fn start_ping_loop() {
        spawn {
            while self.state == WsState.Open {
                @native("sleep", self.config.ping_interval)
                if self.state != WsState.Open { break }
                self.send_frame(Frame.ping([]))
            }
        }
    }
    
    fn close(code: CloseCode, reason: String) -> Result<(), WsError> {
        self.state = WsState.Closing
        self.send_frame(Frame.close(code, reason))?
        self.state = WsState.Closed
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Extensions
// -----------------------------------------------------------------------------

trait Extension { fn name() -> String; fn encode(data: [UInt8]) -> [UInt8]; fn decode(data: [UInt8]) -> [UInt8]; }

struct PerMessageDeflate { client_no_context_takeover: Bool, server_no_context_takeover: Bool, client_max_window_bits: Int, server_max_window_bits: Int }

impl PerMessageDeflate {
    fn new() -> Self { PerMessageDeflate { client_no_context_takeover: false, server_no_context_takeover: false, client_max_window_bits: 15, server_max_window_bits: 15 } }
}

impl Extension for PerMessageDeflate {
    fn name() -> String { "permessage-deflate" }
    fn encode(data: [UInt8]) -> [UInt8] { @native("deflate", data) }
    fn decode(data: [UInt8]) -> [UInt8] { @native("inflate", data) }
}

// -----------------------------------------------------------------------------
// WebSocket Server V2
// -----------------------------------------------------------------------------

actor WebSocketServerV2 {
    state addr: SocketAddr
    state config: WsConfig
    state clients: Map<Int, WebSocketV2>
    state rooms: Map<String, [Int]>
    state on_connect: Option<fn(Int)>
    state on_disconnect: Option<fn(Int)>
    state on_message: Option<fn(Int, Message)>
    state running: Bool
    state next_id: Int
}

impl WebSocketServerV2 {
    fn new(addr: String) -> Result<Self, WsError> {
        Ok(WebSocketServerV2 { addr: SocketAddr.parse(addr)?, config: WsConfig.default(), clients: Map.new(), rooms: Map.new(), on_connect: None, on_disconnect: None, on_message: None, running: false, next_id: 0 })
    }
    
    fn on_connect(handler: fn(Int)) -> Self { self.on_connect = Some(handler); self }
    fn on_disconnect(handler: fn(Int)) -> Self { self.on_disconnect = Some(handler); self }
    fn on_message(handler: fn(Int, Message)) -> Self { self.on_message = Some(handler); self }
    
    fn broadcast(msg: Message) { for (_, client) in self.clients.iter() { client.send(msg.clone()) } }
    fn send_to(id: Int, msg: Message) -> Result<(), WsError> { self.clients.get(id).ok_or(WsError.NotConnected)?.send(msg) }
    fn broadcast_to_room(room: String, msg: Message) { if let Some(ids) = self.rooms.get(room) { for id in ids { self.send_to(id, msg.clone()) } } }
    
    fn join_room(client_id: Int, room: String) { self.rooms.entry(room).or_insert([]).push(client_id) }
    fn leave_room(client_id: Int, room: String) { if let Some(ids) = self.rooms.get_mut(room) { ids.retain(|id| *id != client_id) } }
    
    fn run() -> Result<(), WsError> { self.running = true; @native("ws_server_run", self.addr, self.config) }
    fn stop() { self.running = false }
}

// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

fn parse_ws_url(url: String) -> Result<(String, Int, String, Bool), WsError> {
    let secure = url.starts_with("wss://")
    let url = url.strip_prefix("wss://").or_else(|| url.strip_prefix("ws://")).unwrap_or(url)
    let (host_port, path) = url.split_once('/').unwrap_or((url, ""))
    let (host, port) = host_port.split_once(':').map(|(h, p)| (h, Int.parse(p).unwrap_or(if secure { 443 } else { 80 }))).unwrap_or((host_port, if secure { 443 } else { 80 }))
    Ok((host.to_string(), port, format!("/{}", path), secure))
}

enum WsError { NotConnected, Protocol(String), Io(String), Timeout, MessageTooLarge }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "frame encoding" {
    let frame = Frame.text("hello")
    let encoded = frame.encode()
    assert(encoded[0] & 0x80 != 0)
}

test "close code" {
    assert_eq(CloseCode.Normal.to_u16(), 1000)
}
