// =============================================================================
// Vibee OS â€” CRM Pipeline Module
// Sales pipeline management with stages, automation, and analytics
// =============================================================================

use datetime::{DateTime}
use uuid::{UUID}
use money::{Money}
use currency::{Currency}
use deal::{Deal, DealStage, DealStatus}

// =============================================================================
// Pipeline Types
// =============================================================================

enum PipelineType {
    Sales
    Support
    Recruitment
    Project
    Custom
}

enum PipelineStatus { Active, Archived }

// =============================================================================
// Pipeline Stage (Extended)
// =============================================================================

struct PipelineStage {
    id: String
    name: String
    order: Int
    probability: Float
    is_won: Bool
    is_lost: Bool
    color: Option<String>
    rotting_days: Option<Int>
    required_fields: [String]
    automations: [StageAutomation]
}

impl PipelineStage {
    fn new(name: String, order: Int, probability: Float) -> Self {
        PipelineStage {
            id: UUID.v4().to_string(),
            name: name,
            order: order,
            probability: probability,
            is_won: false,
            is_lost: false,
            color: None,
            rotting_days: None,
            required_fields: [],
            automations: []
        }
    }
    
    fn won(name: String, order: Int) -> Self {
        let mut stage = PipelineStage.new(name, order, 1.0)
        stage.is_won = true
        stage.color = Some("#22c55e")
        stage
    }
    
    fn lost(name: String, order: Int) -> Self {
        let mut stage = PipelineStage.new(name, order, 0.0)
        stage.is_lost = true
        stage.color = Some("#ef4444")
        stage
    }
    
    fn with_color(c: String) -> Self { self.color = Some(c); self }
    fn with_rotting(days: Int) -> Self { self.rotting_days = Some(days); self }
    fn require_field(field: String) -> Self { self.required_fields.push(field); self }
    fn add_automation(auto: StageAutomation) -> Self { self.automations.push(auto); self }
    
    fn is_terminal() -> Bool { self.is_won || self.is_lost }
}

// =============================================================================
// Stage Automation
// =============================================================================

struct StageAutomation {
    id: String
    name: String
    trigger: AutomationTrigger
    action: AutomationAction
    is_active: Bool
}

enum AutomationTrigger {
    OnEnter
    OnExit
    AfterDays(Int)
    OnFieldChange(String)
}

enum AutomationAction {
    SendEmail(String)
    CreateTask(String, String)
    AssignOwner(String)
    AddTag(String)
    UpdateField(String, String)
    Webhook(String)
    Notify(String)
}

impl StageAutomation {
    fn new(name: String, trigger: AutomationTrigger, action: AutomationAction) -> Self {
        StageAutomation { id: UUID.v4().to_string(), name: name, trigger: trigger, action: action, is_active: true }
    }
    
    fn on_enter(name: String, action: AutomationAction) -> Self {
        StageAutomation.new(name, AutomationTrigger.OnEnter, action)
    }
    
    fn on_exit(name: String, action: AutomationAction) -> Self {
        StageAutomation.new(name, AutomationTrigger.OnExit, action)
    }
    
    fn after_days(name: String, days: Int, action: AutomationAction) -> Self {
        StageAutomation.new(name, AutomationTrigger.AfterDays(days), action)
    }
    
    fn activate() -> Self { self.is_active = true; self }
    fn deactivate() -> Self { self.is_active = false; self }
}

// =============================================================================
// Pipeline
// =============================================================================

struct Pipeline {
    id: String
    name: String
    description: Option<String>
    pipeline_type: PipelineType
    status: PipelineStatus
    stages: [PipelineStage]
    default_stage_id: Option<String>
    currency: Currency
    
    // Settings
    deal_rotting_enabled: Bool
    probability_enabled: Bool
    weighted_value_enabled: Bool
    
    // Access
    owner_id: Option<String>
    team_ids: [String]
    is_default: Bool
    
    // Timestamps
    created_at: DateTime
    updated_at: DateTime
}

impl Pipeline {
    fn new(name: String) -> Self {
        let now = DateTime.now()
        Pipeline {
            id: UUID.v4().to_string(),
            name: name,
            description: None,
            pipeline_type: PipelineType.Sales,
            status: PipelineStatus.Active,
            stages: [],
            default_stage_id: None,
            currency: Currency.USD,
            deal_rotting_enabled: true,
            probability_enabled: true,
            weighted_value_enabled: true,
            owner_id: None,
            team_ids: [],
            is_default: false,
            created_at: now,
            updated_at: now
        }
    }
    
    fn sales_pipeline(name: String) -> Self {
        Pipeline.new(name)
            .with_type(PipelineType.Sales)
            .add_stage(PipelineStage.new("Lead", 1, 0.1).with_color("#94a3b8"))
            .add_stage(PipelineStage.new("Qualified", 2, 0.25).with_color("#3b82f6"))
            .add_stage(PipelineStage.new("Proposal", 3, 0.5).with_color("#8b5cf6"))
            .add_stage(PipelineStage.new("Negotiation", 4, 0.75).with_color("#f59e0b"))
            .add_stage(PipelineStage.won("Won", 5))
            .add_stage(PipelineStage.lost("Lost", 6))
            .set_default_stage(1)
    }
    
    fn support_pipeline(name: String) -> Self {
        Pipeline.new(name)
            .with_type(PipelineType.Support)
            .add_stage(PipelineStage.new("New", 1, 0.0).with_color("#ef4444"))
            .add_stage(PipelineStage.new("In Progress", 2, 0.0).with_color("#f59e0b"))
            .add_stage(PipelineStage.new("Waiting", 3, 0.0).with_color("#94a3b8"))
            .add_stage(PipelineStage.new("Resolved", 4, 1.0).with_color("#22c55e"))
            .set_default_stage(1)
    }
    
    // Builder methods
    fn with_description(d: String) -> Self { self.description = Some(d); self }
    fn with_type(t: PipelineType) -> Self { self.pipeline_type = t; self }
    fn with_currency(c: Currency) -> Self { self.currency = c; self }
    fn with_owner(id: String) -> Self { self.owner_id = Some(id); self }
    fn add_team(id: String) -> Self { self.team_ids.push(id); self }
    fn set_default() -> Self { self.is_default = true; self }
    
    // Stage management
    fn add_stage(stage: PipelineStage) -> Self {
        self.stages.push(stage)
        self.stages.sort_by(|a, b| a.order.cmp(b.order))
        if self.default_stage_id.is_none() && !self.stages.is_empty() {
            self.default_stage_id = Some(self.stages[0].id.clone())
        }
        self.updated_at = DateTime.now()
        self
    }
    
    fn remove_stage(stage_id: String) -> Result<Self, PipelineError> {
        if self.stages.len() <= 1 { return Err(PipelineError.MinimumStages) }
        self.stages.retain(|s| s.id != stage_id)
        if self.default_stage_id == Some(stage_id) {
            self.default_stage_id = self.stages.first().map(|s| s.id.clone())
        }
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn reorder_stages(stage_ids: [String]) -> Self {
        for (i, id) in stage_ids.iter().enumerate() {
            if let Some(stage) = self.stages.iter_mut().find(|s| s.id == id) {
                stage.order = i as Int + 1
            }
        }
        self.stages.sort_by(|a, b| a.order.cmp(b.order))
        self.updated_at = DateTime.now()
        self
    }
    
    fn set_default_stage(order: Int) -> Self {
        if let Some(stage) = self.stages.iter().find(|s| s.order == order) {
            self.default_stage_id = Some(stage.id.clone())
        }
        self
    }
    
    fn update_stage(stage_id: String, updater: fn(PipelineStage) -> PipelineStage) -> Self {
        if let Some(stage) = self.stages.iter_mut().find(|s| s.id == stage_id) {
            *stage = updater(stage.clone())
        }
        self.updated_at = DateTime.now()
        self
    }
    
    // Settings
    fn enable_rotting() -> Self { self.deal_rotting_enabled = true; self }
    fn disable_rotting() -> Self { self.deal_rotting_enabled = false; self }
    fn enable_probability() -> Self { self.probability_enabled = true; self }
    fn disable_probability() -> Self { self.probability_enabled = false; self }
    
    // Status
    fn archive() -> Self { self.status = PipelineStatus.Archived; self.updated_at = DateTime.now(); self }
    fn activate() -> Self { self.status = PipelineStatus.Active; self.updated_at = DateTime.now(); self }
    
    // Getters
    fn get_stage(stage_id: String) -> Option<PipelineStage> { self.stages.iter().find(|s| s.id == stage_id).cloned() }
    fn get_stage_by_order(order: Int) -> Option<PipelineStage> { self.stages.iter().find(|s| s.order == order).cloned() }
    fn get_default_stage() -> Option<PipelineStage> { self.default_stage_id.clone().and_then(|id| self.get_stage(id)) }
    fn get_won_stage() -> Option<PipelineStage> { self.stages.iter().find(|s| s.is_won).cloned() }
    fn get_lost_stage() -> Option<PipelineStage> { self.stages.iter().find(|s| s.is_lost).cloned() }
    fn get_active_stages() -> [PipelineStage] { self.stages.iter().filter(|s| !s.is_terminal()).cloned().collect() }
    
    fn stage_count() -> Int { self.stages.len() }
    fn is_active() -> Bool { self.status == PipelineStatus.Active }
    
    fn next_stage(current_stage_id: String) -> Option<PipelineStage> {
        let current = self.get_stage(current_stage_id)?
        self.stages.iter().find(|s| s.order == current.order + 1 && !s.is_lost).cloned()
    }
    
    fn prev_stage(current_stage_id: String) -> Option<PipelineStage> {
        let current = self.get_stage(current_stage_id)?
        self.stages.iter().find(|s| s.order == current.order - 1).cloned()
    }
}

// =============================================================================
// Pipeline View
// =============================================================================

struct PipelineView {
    pipeline: Pipeline
    stages: [StageView]
    total_value: Money
    weighted_value: Money
    deal_count: Int
}

struct StageView {
    stage: PipelineStage
    deals: [Deal]
    value: Money
    weighted_value: Money
    deal_count: Int
    rotting_count: Int
}

impl StageView {
    fn from_stage(stage: PipelineStage, deals: [Deal]) -> Self {
        let value = deals.iter().map(|d| d.amount.clone()).fold(Money.zero(Currency.USD), |a, b| a + b)
        let weighted = deals.iter().map(|d| d.weighted_amount.clone()).fold(Money.zero(Currency.USD), |a, b| a + b)
        let rotting = stage.rotting_days.map(|days| deals.iter().filter(|d| d.is_rotting(days)).count()).unwrap_or(0)
        
        StageView {
            stage: stage,
            deals: deals.clone(),
            value: value,
            weighted_value: weighted,
            deal_count: deals.len(),
            rotting_count: rotting
        }
    }
}

// =============================================================================
// Pipeline Analytics
// =============================================================================

struct PipelineAnalytics {
    pipeline_id: String
    period_start: DateTime
    period_end: DateTime
    
    // Conversion
    stage_conversions: Map<String, StageConversion>
    overall_conversion_rate: Float
    
    // Velocity
    avg_days_to_close: Float
    avg_days_per_stage: Map<String, Float>
    
    // Value
    total_value: Money
    won_value: Money
    lost_value: Money
    avg_deal_size: Money
    
    // Volume
    deals_created: Int
    deals_won: Int
    deals_lost: Int
    deals_in_progress: Int
}

struct StageConversion {
    stage_id: String
    stage_name: String
    entered: Int
    exited_forward: Int
    exited_won: Int
    exited_lost: Int
    conversion_rate: Float
    avg_time_in_stage: Float
}

impl PipelineAnalytics {
    fn win_rate() -> Float { if self.deals_won + self.deals_lost == 0 { 0.0 } else { self.deals_won as Float / (self.deals_won + self.deals_lost) as Float * 100.0 } }
    fn loss_rate() -> Float { 100.0 - self.win_rate() }
    fn velocity() -> Float { self.avg_days_to_close }
}

// =============================================================================
// Pipeline Service
// =============================================================================

actor PipelineService {
    state pipelines: Map<String, Pipeline>
    state default_pipeline_id: Option<String>
    
    fn new() -> Self {
        PipelineService { pipelines: Map.empty(), default_pipeline_id: None }
    }
    
    fn create(pipeline: Pipeline) -> Result<Pipeline, PipelineError> {
        if pipeline.stages.is_empty() {
            return Err(PipelineError.NoStages)
        }
        
        if pipeline.is_default {
            // Unset previous default
            for (_, p) in self.pipelines.iter_mut() {
                p.is_default = false
            }
            self.default_pipeline_id = Some(pipeline.id.clone())
        }
        
        self.pipelines.insert(pipeline.id.clone(), pipeline.clone())
        Ok(pipeline)
    }
    
    fn get(id: String) -> Option<Pipeline> { self.pipelines.get(id) }
    fn get_default() -> Option<Pipeline> { self.default_pipeline_id.clone().and_then(|id| self.pipelines.get(id)) }
    fn list() -> [Pipeline] { self.pipelines.values().collect() }
    fn list_active() -> [Pipeline] { self.pipelines.values().filter(|p| p.is_active()).collect() }
    
    fn update(pipeline: Pipeline) -> Result<Pipeline, PipelineError> {
        if !self.pipelines.contains_key(pipeline.id) { return Err(PipelineError.NotFound) }
        self.pipelines.insert(pipeline.id.clone(), pipeline.clone())
        Ok(pipeline)
    }
    
    fn delete(id: String) -> Result<(), PipelineError> {
        let pipeline = self.pipelines.get(id.clone()).ok_or(PipelineError.NotFound)?
        if pipeline.is_default { return Err(PipelineError.CannotDeleteDefault) }
        self.pipelines.remove(id)
        Ok(())
    }
    
    fn set_default(id: String) -> Result<Pipeline, PipelineError> {
        // Unset previous default
        for (_, p) in self.pipelines.iter_mut() {
            p.is_default = false
        }
        
        let mut pipeline = self.pipelines.get(id.clone()).ok_or(PipelineError.NotFound)?
        pipeline.is_default = true
        self.default_pipeline_id = Some(id.clone())
        self.pipelines.insert(id, pipeline.clone())
        Ok(pipeline)
    }
    
    fn add_stage(pipeline_id: String, stage: PipelineStage) -> Result<Pipeline, PipelineError> {
        let mut pipeline = self.pipelines.get(pipeline_id.clone()).ok_or(PipelineError.NotFound)?
        pipeline = pipeline.add_stage(stage)
        self.pipelines.insert(pipeline_id, pipeline.clone())
        Ok(pipeline)
    }
    
    fn remove_stage(pipeline_id: String, stage_id: String) -> Result<Pipeline, PipelineError> {
        let mut pipeline = self.pipelines.get(pipeline_id.clone()).ok_or(PipelineError.NotFound)?
        pipeline = pipeline.remove_stage(stage_id)?
        self.pipelines.insert(pipeline_id, pipeline.clone())
        Ok(pipeline)
    }
    
    fn duplicate(id: String, new_name: String) -> Result<Pipeline, PipelineError> {
        let original = self.pipelines.get(id).ok_or(PipelineError.NotFound)?
        let mut copy = original.clone()
        copy.id = UUID.v4().to_string()
        copy.name = new_name
        copy.is_default = false
        copy.created_at = DateTime.now()
        copy.updated_at = DateTime.now()
        
        // Generate new IDs for stages
        for stage in copy.stages.iter_mut() {
            stage.id = UUID.v4().to_string()
        }
        if let Some(first) = copy.stages.first() {
            copy.default_stage_id = Some(first.id.clone())
        }
        
        self.pipelines.insert(copy.id.clone(), copy.clone())
        Ok(copy)
    }
    
    fn count() -> Int { self.pipelines.len() }
}

// =============================================================================
// Pipeline Templates
// =============================================================================

struct PipelineTemplate {
    id: String
    name: String
    description: String
    pipeline_type: PipelineType
    stages: [PipelineStage]
}

impl PipelineTemplate {
    fn b2b_sales() -> Self {
        PipelineTemplate {
            id: "b2b-sales".to_string(),
            name: "B2B Sales Pipeline".to_string(),
            description: "Standard B2B sales process".to_string(),
            pipeline_type: PipelineType.Sales,
            stages: [
                PipelineStage.new("Prospecting", 1, 0.1).with_color("#94a3b8").with_rotting(7),
                PipelineStage.new("Discovery", 2, 0.2).with_color("#3b82f6").with_rotting(14),
                PipelineStage.new("Proposal", 3, 0.4).with_color("#8b5cf6").with_rotting(14),
                PipelineStage.new("Negotiation", 4, 0.6).with_color("#f59e0b").with_rotting(21),
                PipelineStage.new("Contract", 5, 0.8).with_color("#10b981").with_rotting(14),
                PipelineStage.won("Closed Won", 6),
                PipelineStage.lost("Closed Lost", 7)
            ]
        }
    }
    
    fn saas_sales() -> Self {
        PipelineTemplate {
            id: "saas-sales".to_string(),
            name: "SaaS Sales Pipeline".to_string(),
            description: "SaaS subscription sales process".to_string(),
            pipeline_type: PipelineType.Sales,
            stages: [
                PipelineStage.new("Lead", 1, 0.1).with_color("#94a3b8"),
                PipelineStage.new("Demo Scheduled", 2, 0.2).with_color("#3b82f6"),
                PipelineStage.new("Demo Completed", 3, 0.4).with_color("#8b5cf6"),
                PipelineStage.new("Trial", 4, 0.6).with_color("#f59e0b"),
                PipelineStage.new("Negotiation", 5, 0.8).with_color("#10b981"),
                PipelineStage.won("Customer", 6),
                PipelineStage.lost("Lost", 7)
            ]
        }
    }
    
    fn recruitment() -> Self {
        PipelineTemplate {
            id: "recruitment".to_string(),
            name: "Recruitment Pipeline".to_string(),
            description: "Hiring process pipeline".to_string(),
            pipeline_type: PipelineType.Recruitment,
            stages: [
                PipelineStage.new("Applied", 1, 0.0).with_color("#94a3b8"),
                PipelineStage.new("Screening", 2, 0.0).with_color("#3b82f6"),
                PipelineStage.new("Interview", 3, 0.0).with_color("#8b5cf6"),
                PipelineStage.new("Technical", 4, 0.0).with_color("#f59e0b"),
                PipelineStage.new("Offer", 5, 0.0).with_color("#10b981"),
                PipelineStage.won("Hired", 6),
                PipelineStage.lost("Rejected", 7)
            ]
        }
    }
    
    fn to_pipeline(name: String) -> Pipeline {
        let mut pipeline = Pipeline.new(name)
        pipeline.pipeline_type = self.pipeline_type
        pipeline.description = Some(self.description.clone())
        for stage in self.stages.iter() {
            pipeline = pipeline.add_stage(stage.clone())
        }
        pipeline
    }
}

// =============================================================================
// Errors
// =============================================================================

enum PipelineError {
    NotFound
    NoStages
    MinimumStages
    CannotDeleteDefault
    InvalidStage
    ValidationError(String)
}

impl Display for PipelineError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("Pipeline not found"),
            NoStages => f.write("Pipeline must have at least one stage"),
            MinimumStages => f.write("Cannot remove: minimum one stage required"),
            CannotDeleteDefault => f.write("Cannot delete default pipeline"),
            InvalidStage => f.write("Invalid stage"),
            ValidationError(e) => f.write("Validation error: \(e)")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "pipeline creation" {
    let pipeline = Pipeline.sales_pipeline("Main Sales")
    
    assert_eq(pipeline.name, "Main Sales")?
    assert_eq(pipeline.stage_count(), 6)?
    assert(pipeline.get_won_stage().is_some())?
    assert(pipeline.get_lost_stage().is_some())?
}

test "pipeline stages" {
    var pipeline = Pipeline.new("Test")
        .add_stage(PipelineStage.new("Stage 1", 1, 0.25))
        .add_stage(PipelineStage.new("Stage 2", 2, 0.5))
        .add_stage(PipelineStage.won("Won", 3))
    
    assert_eq(pipeline.stage_count(), 3)?
    
    let stage1 = pipeline.get_stage_by_order(1).unwrap()
    let next = pipeline.next_stage(stage1.id).unwrap()
    assert_eq(next.order, 2)?
}

test "pipeline service" {
    let service = PipelineService.new()
    let pipeline = service.create(Pipeline.sales_pipeline("Sales").set_default()).unwrap()
    
    assert(service.get_default().is_some())?
    assert_eq(service.count(), 1)?
}

test "pipeline template" {
    let template = PipelineTemplate.b2b_sales()
    let pipeline = template.to_pipeline("My B2B Pipeline")
    
    assert_eq(pipeline.name, "My B2B Pipeline")?
    assert_eq(pipeline.stage_count(), 7)?
}

test "stage automation" {
    let auto = StageAutomation.on_enter("Welcome Email", AutomationAction.SendEmail("welcome-template"))
    let stage = PipelineStage.new("New", 1, 0.1).add_automation(auto)
    
    assert_eq(stage.automations.len(), 1)?
}
