// =============================================================================
// Vibee OS — Units Module
// Unit conversion and measurement
// =============================================================================

/// Quantity with unit
struct Quantity<U: Unit> {
    value: Float64
    unit: U
    
    fn new(value: Float64, unit: U) -> Self {
        Quantity { value: value, unit: unit }
    }
    
    fn to(target: U) -> Self {
        let base = self.value * self.unit.to_base()
        Quantity { value: base / target.to_base(), unit: target }
    }
    
    fn add(other: Quantity<U>) -> Self {
        let other_converted = other.to(self.unit)
        Quantity { value: self.value + other_converted.value, unit: self.unit }
    }
    
    fn sub(other: Quantity<U>) -> Self {
        let other_converted = other.to(self.unit)
        Quantity { value: self.value - other_converted.value, unit: self.unit }
    }
    
    fn mul(scalar: Float64) -> Self {
        Quantity { value: self.value * scalar, unit: self.unit }
    }
    
    fn div(scalar: Float64) -> Self {
        Quantity { value: self.value / scalar, unit: self.unit }
    }
}

trait Unit {
    fn to_base() -> Float64
    fn symbol() -> String
}

// -----------------------------------------------------------------------------
// Length
// -----------------------------------------------------------------------------

enum Length {
    Meter, Kilometer, Centimeter, Millimeter, Micrometer, Nanometer,
    Mile, Yard, Foot, Inch, NauticalMile
}

impl Unit for Length {
    fn to_base() -> Float64 {
        match self {
            Meter => 1.0
            Kilometer => 1000.0
            Centimeter => 0.01
            Millimeter => 0.001
            Micrometer => 1e-6
            Nanometer => 1e-9
            Mile => 1609.344
            Yard => 0.9144
            Foot => 0.3048
            Inch => 0.0254
            NauticalMile => 1852.0
        }
    }
    
    fn symbol() -> String {
        match self {
            Meter => "m", Kilometer => "km", Centimeter => "cm", Millimeter => "mm",
            Micrometer => "μm", Nanometer => "nm", Mile => "mi", Yard => "yd",
            Foot => "ft", Inch => "in", NauticalMile => "nmi"
        }
    }
}

fn meters(v: Float64) -> Quantity<Length> { Quantity.new(v, Length.Meter) }
fn kilometers(v: Float64) -> Quantity<Length> { Quantity.new(v, Length.Kilometer) }
fn miles(v: Float64) -> Quantity<Length> { Quantity.new(v, Length.Mile) }
fn feet(v: Float64) -> Quantity<Length> { Quantity.new(v, Length.Foot) }
fn inches(v: Float64) -> Quantity<Length> { Quantity.new(v, Length.Inch) }

// -----------------------------------------------------------------------------
// Mass
// -----------------------------------------------------------------------------

enum Mass {
    Kilogram, Gram, Milligram, Microgram, Tonne,
    Pound, Ounce, Stone
}

impl Unit for Mass {
    fn to_base() -> Float64 {
        match self {
            Kilogram => 1.0
            Gram => 0.001
            Milligram => 1e-6
            Microgram => 1e-9
            Tonne => 1000.0
            Pound => 0.453592
            Ounce => 0.0283495
            Stone => 6.35029
        }
    }
    
    fn symbol() -> String {
        match self {
            Kilogram => "kg", Gram => "g", Milligram => "mg", Microgram => "μg",
            Tonne => "t", Pound => "lb", Ounce => "oz", Stone => "st"
        }
    }
}

fn kilograms(v: Float64) -> Quantity<Mass> { Quantity.new(v, Mass.Kilogram) }
fn grams(v: Float64) -> Quantity<Mass> { Quantity.new(v, Mass.Gram) }
fn pounds(v: Float64) -> Quantity<Mass> { Quantity.new(v, Mass.Pound) }
fn ounces(v: Float64) -> Quantity<Mass> { Quantity.new(v, Mass.Ounce) }

// -----------------------------------------------------------------------------
// Temperature
// -----------------------------------------------------------------------------

enum Temperature { Celsius, Fahrenheit, Kelvin }

fn celsius_to_kelvin(c: Float64) -> Float64 { c + 273.15 }
fn kelvin_to_celsius(k: Float64) -> Float64 { k - 273.15 }
fn fahrenheit_to_kelvin(f: Float64) -> Float64 { (f - 32.0) * 5.0/9.0 + 273.15 }
fn kelvin_to_fahrenheit(k: Float64) -> Float64 { (k - 273.15) * 9.0/5.0 + 32.0 }

fn convert_temperature(value: Float64, from: Temperature, to: Temperature) -> Float64 {
    let kelvin = match from {
        Celsius => celsius_to_kelvin(value)
        Fahrenheit => fahrenheit_to_kelvin(value)
        Kelvin => value
    }
    match to {
        Celsius => kelvin_to_celsius(kelvin)
        Fahrenheit => kelvin_to_fahrenheit(kelvin)
        Kelvin => kelvin
    }
}

fn celsius(v: Float64) -> Float64 { v }
fn fahrenheit(v: Float64) -> Float64 { convert_temperature(v, Temperature.Fahrenheit, Temperature.Celsius) }
fn kelvin(v: Float64) -> Float64 { convert_temperature(v, Temperature.Kelvin, Temperature.Celsius) }

// -----------------------------------------------------------------------------
// Time
// -----------------------------------------------------------------------------

enum Time {
    Second, Millisecond, Microsecond, Nanosecond,
    Minute, Hour, Day, Week
}

impl Unit for Time {
    fn to_base() -> Float64 {
        match self {
            Second => 1.0
            Millisecond => 0.001
            Microsecond => 1e-6
            Nanosecond => 1e-9
            Minute => 60.0
            Hour => 3600.0
            Day => 86400.0
            Week => 604800.0
        }
    }
    
    fn symbol() -> String {
        match self {
            Second => "s", Millisecond => "ms", Microsecond => "μs", Nanosecond => "ns",
            Minute => "min", Hour => "h", Day => "d", Week => "wk"
        }
    }
}

fn seconds(v: Float64) -> Quantity<Time> { Quantity.new(v, Time.Second) }
fn minutes(v: Float64) -> Quantity<Time> { Quantity.new(v, Time.Minute) }
fn hours(v: Float64) -> Quantity<Time> { Quantity.new(v, Time.Hour) }
fn days(v: Float64) -> Quantity<Time> { Quantity.new(v, Time.Day) }

// -----------------------------------------------------------------------------
// Volume
// -----------------------------------------------------------------------------

enum Volume {
    Liter, Milliliter, CubicMeter, CubicCentimeter,
    Gallon, Quart, Pint, Cup, FluidOunce
}

impl Unit for Volume {
    fn to_base() -> Float64 {
        match self {
            Liter => 1.0
            Milliliter => 0.001
            CubicMeter => 1000.0
            CubicCentimeter => 0.001
            Gallon => 3.78541
            Quart => 0.946353
            Pint => 0.473176
            Cup => 0.236588
            FluidOunce => 0.0295735
        }
    }
    
    fn symbol() -> String {
        match self {
            Liter => "L", Milliliter => "mL", CubicMeter => "m³", CubicCentimeter => "cm³",
            Gallon => "gal", Quart => "qt", Pint => "pt", Cup => "cup", FluidOunce => "fl oz"
        }
    }
}

fn liters(v: Float64) -> Quantity<Volume> { Quantity.new(v, Volume.Liter) }
fn milliliters(v: Float64) -> Quantity<Volume> { Quantity.new(v, Volume.Milliliter) }
fn gallons(v: Float64) -> Quantity<Volume> { Quantity.new(v, Volume.Gallon) }

// -----------------------------------------------------------------------------
// Area
// -----------------------------------------------------------------------------

enum Area {
    SquareMeter, SquareKilometer, SquareCentimeter, Hectare,
    SquareMile, SquareYard, SquareFoot, SquareInch, Acre
}

impl Unit for Area {
    fn to_base() -> Float64 {
        match self {
            SquareMeter => 1.0
            SquareKilometer => 1e6
            SquareCentimeter => 1e-4
            Hectare => 10000.0
            SquareMile => 2.59e6
            SquareYard => 0.836127
            SquareFoot => 0.092903
            SquareInch => 0.00064516
            Acre => 4046.86
        }
    }
    
    fn symbol() -> String {
        match self {
            SquareMeter => "m²", SquareKilometer => "km²", SquareCentimeter => "cm²",
            Hectare => "ha", SquareMile => "mi²", SquareYard => "yd²",
            SquareFoot => "ft²", SquareInch => "in²", Acre => "ac"
        }
    }
}

// -----------------------------------------------------------------------------
// Speed
// -----------------------------------------------------------------------------

enum Speed {
    MeterPerSecond, KilometerPerHour, MilePerHour, Knot, FootPerSecond
}

impl Unit for Speed {
    fn to_base() -> Float64 {
        match self {
            MeterPerSecond => 1.0
            KilometerPerHour => 0.277778
            MilePerHour => 0.44704
            Knot => 0.514444
            FootPerSecond => 0.3048
        }
    }
    
    fn symbol() -> String {
        match self {
            MeterPerSecond => "m/s", KilometerPerHour => "km/h", MilePerHour => "mph",
            Knot => "kn", FootPerSecond => "ft/s"
        }
    }
}

fn mps(v: Float64) -> Quantity<Speed> { Quantity.new(v, Speed.MeterPerSecond) }
fn kmh(v: Float64) -> Quantity<Speed> { Quantity.new(v, Speed.KilometerPerHour) }
fn mph(v: Float64) -> Quantity<Speed> { Quantity.new(v, Speed.MilePerHour) }
fn knots(v: Float64) -> Quantity<Speed> { Quantity.new(v, Speed.Knot) }

// -----------------------------------------------------------------------------
// Pressure
// -----------------------------------------------------------------------------

enum Pressure {
    Pascal, Kilopascal, Bar, Atmosphere, PSI, Torr
}

impl Unit for Pressure {
    fn to_base() -> Float64 {
        match self {
            Pascal => 1.0
            Kilopascal => 1000.0
            Bar => 100000.0
            Atmosphere => 101325.0
            PSI => 6894.76
            Torr => 133.322
        }
    }
    
    fn symbol() -> String {
        match self {
            Pascal => "Pa", Kilopascal => "kPa", Bar => "bar",
            Atmosphere => "atm", PSI => "psi", Torr => "Torr"
        }
    }
}

// -----------------------------------------------------------------------------
// Energy
// -----------------------------------------------------------------------------

enum Energy {
    Joule, Kilojoule, Calorie, Kilocalorie, WattHour, KilowattHour, BTU, Electronvolt
}

impl Unit for Energy {
    fn to_base() -> Float64 {
        match self {
            Joule => 1.0
            Kilojoule => 1000.0
            Calorie => 4.184
            Kilocalorie => 4184.0
            WattHour => 3600.0
            KilowattHour => 3.6e6
            BTU => 1055.06
            Electronvolt => 1.602e-19
        }
    }
    
    fn symbol() -> String {
        match self {
            Joule => "J", Kilojoule => "kJ", Calorie => "cal", Kilocalorie => "kcal",
            WattHour => "Wh", KilowattHour => "kWh", BTU => "BTU", Electronvolt => "eV"
        }
    }
}

// -----------------------------------------------------------------------------
// Data
// -----------------------------------------------------------------------------

enum Data {
    Bit, Byte, Kilobyte, Megabyte, Gigabyte, Terabyte, Petabyte,
    Kibibyte, Mebibyte, Gibibyte, Tebibyte
}

impl Unit for Data {
    fn to_base() -> Float64 {
        match self {
            Bit => 0.125
            Byte => 1.0
            Kilobyte => 1000.0
            Megabyte => 1e6
            Gigabyte => 1e9
            Terabyte => 1e12
            Petabyte => 1e15
            Kibibyte => 1024.0
            Mebibyte => 1048576.0
            Gibibyte => 1073741824.0
            Tebibyte => 1099511627776.0
        }
    }
    
    fn symbol() -> String {
        match self {
            Bit => "b", Byte => "B", Kilobyte => "KB", Megabyte => "MB",
            Gigabyte => "GB", Terabyte => "TB", Petabyte => "PB",
            Kibibyte => "KiB", Mebibyte => "MiB", Gibibyte => "GiB", Tebibyte => "TiB"
        }
    }
}

fn bytes(v: Float64) -> Quantity<Data> { Quantity.new(v, Data.Byte) }
fn kilobytes(v: Float64) -> Quantity<Data> { Quantity.new(v, Data.Kilobyte) }
fn megabytes(v: Float64) -> Quantity<Data> { Quantity.new(v, Data.Megabyte) }
fn gigabytes(v: Float64) -> Quantity<Data> { Quantity.new(v, Data.Gigabyte) }

// -----------------------------------------------------------------------------
// Angle
// -----------------------------------------------------------------------------

enum Angle { Degree, Radian, Gradian, Turn }

impl Unit for Angle {
    fn to_base() -> Float64 {
        match self {
            Degree => 1.0
            Radian => 57.2958
            Gradian => 0.9
            Turn => 360.0
        }
    }
    
    fn symbol() -> String {
        match self { Degree => "°", Radian => "rad", Gradian => "gon", Turn => "turn" }
    }
}

fn degrees(v: Float64) -> Quantity<Angle> { Quantity.new(v, Angle.Degree) }
fn radians(v: Float64) -> Quantity<Angle> { Quantity.new(v, Angle.Radian) }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "length conversion" {
    let m = kilometers(1.0).to(Length.Meter)
    assert_eq(m.value, 1000.0)?
    
    let ft = meters(1.0).to(Length.Foot)
    assert((ft.value - 3.28084).abs() < 0.001)?
}

test "mass conversion" {
    let kg = pounds(1.0).to(Mass.Kilogram)
    assert((kg.value - 0.453592).abs() < 0.001)?
}

test "temperature conversion" {
    let c = convert_temperature(32.0, Temperature.Fahrenheit, Temperature.Celsius)
    assert((c - 0.0).abs() < 0.001)?
    
    let k = convert_temperature(0.0, Temperature.Celsius, Temperature.Kelvin)
    assert((k - 273.15).abs() < 0.001)?
}

test "speed conversion" {
    let mps = kmh(100.0).to(Speed.MeterPerSecond)
    assert((mps.value - 27.7778).abs() < 0.01)?
}

test "data conversion" {
    let mb = gigabytes(1.0).to(Data.Megabyte)
    assert_eq(mb.value, 1000.0)?
    
    let gib = Quantity.new(1.0, Data.Gibibyte).to(Data.Mebibyte)
    assert_eq(gib.value, 1024.0)?
}
