// =============================================================================
// Vibee OS â€” PDF Form Module
// PDF forms: reading, filling, and creating interactive forms
// =============================================================================

use fs::{File, IoError}
use pdf_reader::{PdfDocument, PdfRect, PdfColor, PdfError}

// =============================================================================
// PDF Form
// =============================================================================

/// PDF form handler
struct PdfForm {
    handle: @native("PdfFormHandle")
    document: PdfDocument
    fields: [FormField]
}

impl PdfForm {
    /// Open PDF with forms
    fn open(path: String) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(path)?
        let handle = @native("pdf_form_open", doc.handle)?
        let fields = @native("pdf_form_get_fields", handle)?
        Ok(PdfForm { handle: handle, document: doc, fields: fields })
    }
    
    /// Get all form fields
    fn fields() -> [FormField] { self.fields.clone() }
    
    /// Get field by name
    fn field(name: String) -> Option<FormField> {
        self.fields.iter().find(|f| f.name == name).cloned()
    }
    
    /// Get field value
    fn get_value(name: String) -> Option<String> {
        self.field(name).and_then(|f| f.value.clone())
    }
    
    /// Set field value
    fn set_value(name: String, value: String) -> Result<Self, PdfError> {
        @native("pdf_form_set_value", self.handle, name, value)?
        for f in self.fields.iter_mut() {
            if f.name == name { f.value = Some(value.clone()) }
        }
        Ok(self)
    }
    
    /// Fill multiple fields
    fn fill(values: Map<String, String>) -> Result<Self, PdfError> {
        for (name, value) in values {
            self.set_value(name, value)?
        }
        Ok(self)
    }
    
    /// Check checkbox
    fn check(name: String) -> Result<Self, PdfError> {
        self.set_value(name, "Yes")
    }
    
    /// Uncheck checkbox
    fn uncheck(name: String) -> Result<Self, PdfError> {
        self.set_value(name, "Off")
    }
    
    /// Select radio button
    fn select_radio(name: String, value: String) -> Result<Self, PdfError> {
        self.set_value(name, value)
    }
    
    /// Select dropdown option
    fn select_option(name: String, value: String) -> Result<Self, PdfError> {
        self.set_value(name, value)
    }
    
    /// Flatten form (make fields non-editable)
    fn flatten() -> Result<Self, PdfError> {
        @native("pdf_form_flatten", self.handle)?
        Ok(self)
    }
    
    /// Save filled form
    fn save(path: String) -> Result<(), PdfError> {
        @native("pdf_form_save", self.handle, path)
    }
    
    /// Save as bytes
    fn to_bytes() -> Result<[UInt8], PdfError> {
        @native("pdf_form_to_bytes", self.handle)
    }
    
    /// Validate all required fields
    fn validate() -> ValidationResult {
        let mut errors = []
        for field in self.fields {
            if field.required && field.value.is_none() {
                errors.push(ValidationError.Required(field.name.clone()))
            }
        }
        ValidationResult { valid: errors.is_empty(), errors: errors }
    }
}

// =============================================================================
// Form Field
// =============================================================================

/// Form field
struct FormField {
    name: String
    field_type: FieldType
    value: Option<String>
    default_value: Option<String>
    rect: PdfRect
    page_index: Int
    required: Bool
    read_only: Bool
    options: [String]  // For dropdowns/listboxes
    max_length: Option<Int>
    tooltip: Option<String>
}

impl FormField {
    fn is_text() -> Bool { matches!(self.field_type, FieldType.Text) }
    fn is_checkbox() -> Bool { matches!(self.field_type, FieldType.Checkbox) }
    fn is_radio() -> Bool { matches!(self.field_type, FieldType.Radio) }
    fn is_dropdown() -> Bool { matches!(self.field_type, FieldType.Dropdown) }
    fn is_button() -> Bool { matches!(self.field_type, FieldType.Button) }
    fn is_signature() -> Bool { matches!(self.field_type, FieldType.Signature) }
    
    fn is_checked() -> Bool {
        self.value.as_ref().map(|v| v == "Yes" || v == "On").unwrap_or(false)
    }
}

/// Field types
enum FieldType {
    Text,
    Checkbox,
    Radio,
    Dropdown,
    Listbox,
    Button,
    Signature,
    Unknown(String)
}

// =============================================================================
// Form Builder
// =============================================================================

/// Build PDF forms
struct FormBuilder {
    handle: @native("FormBuilderHandle")
    fields: [FormFieldDef]
    page_size: (Float64, Float64)
}

impl FormBuilder {
    fn new() -> Self {
        FormBuilder {
            handle: @native("form_builder_new"),
            fields: [],
            page_size: (595.0, 842.0)  // A4
        }
    }
    
    fn page_size(w: Float64, h: Float64) -> Self {
        self.page_size = (w, h)
        self
    }
    
    /// Add text field
    fn text_field(name: String, rect: PdfRect) -> Self {
        self.fields.push(FormFieldDef {
            name: name,
            field_type: FieldType.Text,
            rect: rect,
            page: 0,
            options: TextFieldOptions.default()
        })
        self
    }
    
    /// Add multiline text field
    fn multiline_field(name: String, rect: PdfRect) -> Self {
        let mut opts = TextFieldOptions.default()
        opts.multiline = true
        self.fields.push(FormFieldDef {
            name: name,
            field_type: FieldType.Text,
            rect: rect,
            page: 0,
            options: opts
        })
        self
    }
    
    /// Add checkbox
    fn checkbox(name: String, rect: PdfRect) -> Self {
        self.fields.push(FormFieldDef {
            name: name,
            field_type: FieldType.Checkbox,
            rect: rect,
            page: 0,
            options: TextFieldOptions.default()
        })
        self
    }
    
    /// Add radio button group
    fn radio_group(name: String, buttons: [(String, PdfRect)]) -> Self {
        for (value, rect) in buttons {
            self.fields.push(FormFieldDef {
                name: format!("{}_{}", name, value),
                field_type: FieldType.Radio,
                rect: rect,
                page: 0,
                options: TextFieldOptions { group: Some(name.clone()), ..TextFieldOptions.default() }
            })
        }
        self
    }
    
    /// Add dropdown
    fn dropdown(name: String, rect: PdfRect, options: [String]) -> Self {
        self.fields.push(FormFieldDef {
            name: name,
            field_type: FieldType.Dropdown,
            rect: rect,
            page: 0,
            options: TextFieldOptions { choices: options, ..TextFieldOptions.default() }
        })
        self
    }
    
    /// Add signature field
    fn signature_field(name: String, rect: PdfRect) -> Self {
        self.fields.push(FormFieldDef {
            name: name,
            field_type: FieldType.Signature,
            rect: rect,
            page: 0,
            options: TextFieldOptions.default()
        })
        self
    }
    
    /// Build form and save
    fn save(path: String) -> Result<(), PdfError> {
        @native("form_builder_build", self.handle, self.fields, self.page_size)?
        @native("form_builder_save", self.handle, path)
    }
}

struct FormFieldDef {
    name: String
    field_type: FieldType
    rect: PdfRect
    page: Int
    options: TextFieldOptions
}

struct TextFieldOptions {
    multiline: Bool
    password: Bool
    required: Bool
    max_length: Option<Int>
    default_value: Option<String>
    choices: [String]
    group: Option<String>
}

impl TextFieldOptions {
    fn default() -> Self {
        TextFieldOptions {
            multiline: false, password: false, required: false,
            max_length: None, default_value: None, choices: [], group: None
        }
    }
}

// =============================================================================
// Validation
// =============================================================================

struct ValidationResult { valid: Bool, errors: [ValidationError] }
enum ValidationError { Required(String), InvalidFormat(String, String), TooLong(String, Int) }

// =============================================================================
// Convenience Functions
// =============================================================================

/// Fill form from map
fn fill_form(path: String, values: Map<String, String>, output: String) -> Result<(), PdfError> {
    PdfForm.open(path)?.fill(values)?.save(output)
}

/// Get form field names
fn get_field_names(path: String) -> Result<[String], PdfError> {
    Ok(PdfForm.open(path)?.fields.iter().map(|f| f.name.clone()).collect())
}

/// Flatten form
fn flatten_form(path: String, output: String) -> Result<(), PdfError> {
    PdfForm.open(path)?.flatten()?.save(output)
}

// =============================================================================
// Tests
// =============================================================================

test "open form" {
    let form = PdfForm.open("form.pdf")?
    assert(form.fields.len() >= 0)?
}

test "fill form" {
    let mut values = Map.new()
    values.insert("name", "John")
    fill_form("form.pdf", values, "filled.pdf")?
}

test "form builder" {
    FormBuilder.new()
        .text_field("name", PdfRect.new(50.0, 700.0, 200.0, 20.0))
        .checkbox("agree", PdfRect.new(50.0, 650.0, 20.0, 20.0))
        .save("new_form.pdf")?
}

test "validation" {
    let form = PdfForm.open("form.pdf")?
    let result = form.validate()
    // Result depends on form content
}
