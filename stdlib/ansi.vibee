// =============================================================================
// Vibee OS â€” ANSI Module
// ANSI escape codes for colored terminal output
// =============================================================================

// -----------------------------------------------------------------------------
// ANSI Escape Codes
// -----------------------------------------------------------------------------

/// ANSI escape code constants
module ANSI {
    const ESC = "\x1b"
    const CSI = "\x1b["
    const RESET = "\x1b[0m"
    
    // Text styles
    const BOLD = "\x1b[1m"
    const DIM = "\x1b[2m"
    const ITALIC = "\x1b[3m"
    const UNDERLINE = "\x1b[4m"
    const BLINK = "\x1b[5m"
    const RAPID_BLINK = "\x1b[6m"
    const REVERSE = "\x1b[7m"
    const HIDDEN = "\x1b[8m"
    const STRIKETHROUGH = "\x1b[9m"
    
    // Foreground colors
    const BLACK = "\x1b[30m"
    const RED = "\x1b[31m"
    const GREEN = "\x1b[32m"
    const YELLOW = "\x1b[33m"
    const BLUE = "\x1b[34m"
    const MAGENTA = "\x1b[35m"
    const CYAN = "\x1b[36m"
    const WHITE = "\x1b[37m"
    const DEFAULT = "\x1b[39m"
    
    // Bright foreground colors
    const BRIGHT_BLACK = "\x1b[90m"
    const BRIGHT_RED = "\x1b[91m"
    const BRIGHT_GREEN = "\x1b[92m"
    const BRIGHT_YELLOW = "\x1b[93m"
    const BRIGHT_BLUE = "\x1b[94m"
    const BRIGHT_MAGENTA = "\x1b[95m"
    const BRIGHT_CYAN = "\x1b[96m"
    const BRIGHT_WHITE = "\x1b[97m"
    
    // Background colors
    const BG_BLACK = "\x1b[40m"
    const BG_RED = "\x1b[41m"
    const BG_GREEN = "\x1b[42m"
    const BG_YELLOW = "\x1b[43m"
    const BG_BLUE = "\x1b[44m"
    const BG_MAGENTA = "\x1b[45m"
    const BG_CYAN = "\x1b[46m"
    const BG_WHITE = "\x1b[47m"
    const BG_DEFAULT = "\x1b[49m"
    
    // Bright background colors
    const BG_BRIGHT_BLACK = "\x1b[100m"
    const BG_BRIGHT_RED = "\x1b[101m"
    const BG_BRIGHT_GREEN = "\x1b[102m"
    const BG_BRIGHT_YELLOW = "\x1b[103m"
    const BG_BRIGHT_BLUE = "\x1b[104m"
    const BG_BRIGHT_MAGENTA = "\x1b[105m"
    const BG_BRIGHT_CYAN = "\x1b[106m"
    const BG_BRIGHT_WHITE = "\x1b[107m"
    
    /// 256 color foreground
    fn fg256(code: Int) -> String {
        format!("\x1b[38;5;{}m", code)
    }
    
    /// 256 color background
    fn bg256(code: Int) -> String {
        format!("\x1b[48;5;{}m", code)
    }
    
    /// RGB foreground (true color)
    fn fg_rgb(r: Int, g: Int, b: Int) -> String {
        format!("\x1b[38;2;{};{};{}m", r, g, b)
    }
    
    /// RGB background (true color)
    fn bg_rgb(r: Int, g: Int, b: Int) -> String {
        format!("\x1b[48;2;{};{};{}m", r, g, b)
    }
    
    /// Hex color foreground
    fn fg_hex(hex: String) -> String {
        let (r, g, b) = parse_hex(hex)
        fg_rgb(r, g, b)
    }
    
    /// Hex color background
    fn bg_hex(hex: String) -> String {
        let (r, g, b) = parse_hex(hex)
        bg_rgb(r, g, b)
    }
}

/// Parse hex color to RGB
fn parse_hex(hex: String) -> (Int, Int, Int) {
    let h = hex.trim_start("#")
    let r = Int.parse_hex(h[0..2]).unwrap_or(0)
    let g = Int.parse_hex(h[2..4]).unwrap_or(0)
    let b = Int.parse_hex(h[4..6]).unwrap_or(0)
    (r, g, b)
}

// -----------------------------------------------------------------------------
// Color Enum
// -----------------------------------------------------------------------------

/// Terminal color
enum Color {
    Black
    Red
    Green
    Yellow
    Blue
    Magenta
    Cyan
    White
    BrightBlack
    BrightRed
    BrightGreen
    BrightYellow
    BrightBlue
    BrightMagenta
    BrightCyan
    BrightWhite
    Palette(Int)
    RGB(Int, Int, Int)
    Hex(String)
    
    /// Get foreground escape code
    fn fg() -> String {
        match self {
            .Black => ANSI.BLACK
            .Red => ANSI.RED
            .Green => ANSI.GREEN
            .Yellow => ANSI.YELLOW
            .Blue => ANSI.BLUE
            .Magenta => ANSI.MAGENTA
            .Cyan => ANSI.CYAN
            .White => ANSI.WHITE
            .BrightBlack => ANSI.BRIGHT_BLACK
            .BrightRed => ANSI.BRIGHT_RED
            .BrightGreen => ANSI.BRIGHT_GREEN
            .BrightYellow => ANSI.BRIGHT_YELLOW
            .BrightBlue => ANSI.BRIGHT_BLUE
            .BrightMagenta => ANSI.BRIGHT_MAGENTA
            .BrightCyan => ANSI.BRIGHT_CYAN
            .BrightWhite => ANSI.BRIGHT_WHITE
            .Palette(n) => ANSI.fg256(n)
            .RGB(r, g, b) => ANSI.fg_rgb(r, g, b)
            .Hex(h) => ANSI.fg_hex(h)
        }
    }
    
    /// Get background escape code
    fn bg() -> String {
        match self {
            .Black => ANSI.BG_BLACK
            .Red => ANSI.BG_RED
            .Green => ANSI.BG_GREEN
            .Yellow => ANSI.BG_YELLOW
            .Blue => ANSI.BG_BLUE
            .Magenta => ANSI.BG_MAGENTA
            .Cyan => ANSI.BG_CYAN
            .White => ANSI.BG_WHITE
            .BrightBlack => ANSI.BG_BRIGHT_BLACK
            .BrightRed => ANSI.BG_BRIGHT_RED
            .BrightGreen => ANSI.BG_BRIGHT_GREEN
            .BrightYellow => ANSI.BG_BRIGHT_YELLOW
            .BrightBlue => ANSI.BG_BRIGHT_BLUE
            .BrightMagenta => ANSI.BG_BRIGHT_MAGENTA
            .BrightCyan => ANSI.BG_BRIGHT_CYAN
            .BrightWhite => ANSI.BG_BRIGHT_WHITE
            .Palette(n) => ANSI.bg256(n)
            .RGB(r, g, b) => ANSI.bg_rgb(r, g, b)
            .Hex(h) => ANSI.bg_hex(h)
        }
    }
}

// -----------------------------------------------------------------------------
// Styled Text
// -----------------------------------------------------------------------------

/// Styled text builder
actor Styled {
    state text: String
    state fg_color: Option<Color>
    state bg_color: Option<Color>
    state bold: Bool
    state dim: Bool
    state italic: Bool
    state underline: Bool
    state blink: Bool
    state reverse: Bool
    state strikethrough: Bool
    state hidden: Bool
    
    /// Create styled text
    init(text: String) {
        self.text = text
        self.fg_color = None
        self.bg_color = None
        self.bold = false
        self.dim = false
        self.italic = false
        self.underline = false
        self.blink = false
        self.reverse = false
        self.strikethrough = false
        self.hidden = false
    }
    
    // Foreground colors
    on black() -> Self { self.fg_color = Some(Color.Black); self }
    on red() -> Self { self.fg_color = Some(Color.Red); self }
    on green() -> Self { self.fg_color = Some(Color.Green); self }
    on yellow() -> Self { self.fg_color = Some(Color.Yellow); self }
    on blue() -> Self { self.fg_color = Some(Color.Blue); self }
    on magenta() -> Self { self.fg_color = Some(Color.Magenta); self }
    on cyan() -> Self { self.fg_color = Some(Color.Cyan); self }
    on white() -> Self { self.fg_color = Some(Color.White); self }
    
    // Bright foreground colors
    on bright_black() -> Self { self.fg_color = Some(Color.BrightBlack); self }
    on bright_red() -> Self { self.fg_color = Some(Color.BrightRed); self }
    on bright_green() -> Self { self.fg_color = Some(Color.BrightGreen); self }
    on bright_yellow() -> Self { self.fg_color = Some(Color.BrightYellow); self }
    on bright_blue() -> Self { self.fg_color = Some(Color.BrightBlue); self }
    on bright_magenta() -> Self { self.fg_color = Some(Color.BrightMagenta); self }
    on bright_cyan() -> Self { self.fg_color = Some(Color.BrightCyan); self }
    on bright_white() -> Self { self.fg_color = Some(Color.BrightWhite); self }
    
    // Background colors
    on on_black() -> Self { self.bg_color = Some(Color.Black); self }
    on on_red() -> Self { self.bg_color = Some(Color.Red); self }
    on on_green() -> Self { self.bg_color = Some(Color.Green); self }
    on on_yellow() -> Self { self.bg_color = Some(Color.Yellow); self }
    on on_blue() -> Self { self.bg_color = Some(Color.Blue); self }
    on on_magenta() -> Self { self.bg_color = Some(Color.Magenta); self }
    on on_cyan() -> Self { self.bg_color = Some(Color.Cyan); self }
    on on_white() -> Self { self.bg_color = Some(Color.White); self }
    
    // Custom colors
    on fg(color: Color) -> Self { self.fg_color = Some(color); self }
    on bg(color: Color) -> Self { self.bg_color = Some(color); self }
    on rgb(r: Int, g: Int, b: Int) -> Self { self.fg_color = Some(Color.RGB(r, g, b)); self }
    on on_rgb(r: Int, g: Int, b: Int) -> Self { self.bg_color = Some(Color.RGB(r, g, b)); self }
    on hex(h: String) -> Self { self.fg_color = Some(Color.Hex(h)); self }
    on on_hex(h: String) -> Self { self.bg_color = Some(Color.Hex(h)); self }
    on palette(n: Int) -> Self { self.fg_color = Some(Color.Palette(n)); self }
    on on_palette(n: Int) -> Self { self.bg_color = Some(Color.Palette(n)); self }
    
    // Text styles
    on bold() -> Self { self.bold = true; self }
    on dim() -> Self { self.dim = true; self }
    on italic() -> Self { self.italic = true; self }
    on underline() -> Self { self.underline = true; self }
    on blink() -> Self { self.blink = true; self }
    on reverse() -> Self { self.reverse = true; self }
    on strikethrough() -> Self { self.strikethrough = true; self }
    on hidden() -> Self { self.hidden = true; self }
    
    /// Render to string with ANSI codes
    on render() -> String {
        if !is_color_enabled() {
            return self.text.clone()
        }
        
        var codes = String.new()
        
        if self.bold { codes.push_str(ANSI.BOLD) }
        if self.dim { codes.push_str(ANSI.DIM) }
        if self.italic { codes.push_str(ANSI.ITALIC) }
        if self.underline { codes.push_str(ANSI.UNDERLINE) }
        if self.blink { codes.push_str(ANSI.BLINK) }
        if self.reverse { codes.push_str(ANSI.REVERSE) }
        if self.strikethrough { codes.push_str(ANSI.STRIKETHROUGH) }
        if self.hidden { codes.push_str(ANSI.HIDDEN) }
        
        if let Some(fg) = self.fg_color {
            codes.push_str(fg.fg())
        }
        if let Some(bg) = self.bg_color {
            codes.push_str(bg.bg())
        }
        
        if codes.is_empty() {
            self.text.clone()
        } else {
            format!("{}{}{}", codes, self.text, ANSI.RESET)
        }
    }
    
    /// Convert to string (alias for render)
    fn to_string() -> String {
        self.render()
    }
}

// -----------------------------------------------------------------------------
// Color Detection
// -----------------------------------------------------------------------------

/// Check if color output is enabled
fn is_color_enabled() -> Bool {
    // Check NO_COLOR environment variable
    if Environment.get("NO_COLOR").is_some() {
        return false
    }
    
    // Check FORCE_COLOR environment variable
    if Environment.get("FORCE_COLOR").is_some() {
        return true
    }
    
    // Check if stdout is a TTY
    @native("is_tty")
}

/// Check if 256 colors are supported
fn supports_256_colors() -> Bool {
    let term = Environment.get("TERM").unwrap_or("")
    term.contains("256color")
}

/// Check if true color (24-bit) is supported
fn supports_true_color() -> Bool {
    let colorterm = Environment.get("COLORTERM").unwrap_or("")
    colorterm == "truecolor" || colorterm == "24bit"
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Create styled text
fn styled(text: String) -> Styled {
    Styled.new(text)
}

/// Quick color functions
fn black(text: String) -> String { styled(text).black().render() }
fn red(text: String) -> String { styled(text).red().render() }
fn green(text: String) -> String { styled(text).green().render() }
fn yellow(text: String) -> String { styled(text).yellow().render() }
fn blue(text: String) -> String { styled(text).blue().render() }
fn magenta(text: String) -> String { styled(text).magenta().render() }
fn cyan(text: String) -> String { styled(text).cyan().render() }
fn white(text: String) -> String { styled(text).white().render() }

/// Quick style functions
fn bold(text: String) -> String { styled(text).bold().render() }
fn dim(text: String) -> String { styled(text).dim().render() }
fn italic(text: String) -> String { styled(text).italic().render() }
fn underline(text: String) -> String { styled(text).underline().render() }
fn strikethrough(text: String) -> String { styled(text).strikethrough().render() }

/// Semantic colors
fn success(text: String) -> String { styled(text).green().bold().render() }
fn error(text: String) -> String { styled(text).red().bold().render() }
fn warning(text: String) -> String { styled(text).yellow().bold().render() }
fn info(text: String) -> String { styled(text).blue().bold().render() }
fn hint(text: String) -> String { styled(text).dim().render() }

/// Print colored text
fn print_colored(text: String, color: Color) {
    print!("{}", styled(text).fg(color).render())
}

/// Print with newline
fn println_colored(text: String, color: Color) {
    println!("{}", styled(text).fg(color).render())
}

// -----------------------------------------------------------------------------
// Gradient
// -----------------------------------------------------------------------------

/// Create gradient text
fn gradient(text: String, start: (Int, Int, Int), end: (Int, Int, Int)) -> String {
    if !supports_true_color() {
        return text
    }
    
    let chars: [Char] = text.chars().collect()
    let len = chars.len()
    if len == 0 { return text }
    
    var result = String.new()
    for (i, c) in chars.iter().enumerate() {
        let t = i as Float64 / (len - 1).max(1) as Float64
        let r = (start.0 as Float64 + (end.0 - start.0) as Float64 * t) as Int
        let g = (start.1 as Float64 + (end.1 - start.1) as Float64 * t) as Int
        let b = (start.2 as Float64 + (end.2 - start.2) as Float64 * t) as Int
        result.push_str(ANSI.fg_rgb(r, g, b))
        result.push(c)
    }
    result.push_str(ANSI.RESET)
    result
}

/// Rainbow gradient
fn rainbow(text: String) -> String {
    if !supports_true_color() {
        return text
    }
    
    let colors = [
        (255, 0, 0),    // Red
        (255, 127, 0),  // Orange
        (255, 255, 0),  // Yellow
        (0, 255, 0),    // Green
        (0, 0, 255),    // Blue
        (75, 0, 130),   // Indigo
        (148, 0, 211),  // Violet
    ]
    
    let chars: [Char] = text.chars().collect()
    let len = chars.len()
    if len == 0 { return text }
    
    var result = String.new()
    for (i, c) in chars.iter().enumerate() {
        let t = (i as Float64 / len as Float64) * (colors.len() - 1) as Float64
        let idx = t.floor() as Int
        let frac = t - idx as Float64
        
        let (r1, g1, b1) = colors[idx]
        let (r2, g2, b2) = colors[(idx + 1).min(colors.len() - 1)]
        
        let r = (r1 as Float64 + (r2 - r1) as Float64 * frac) as Int
        let g = (g1 as Float64 + (g2 - g1) as Float64 * frac) as Int
        let b = (b1 as Float64 + (b2 - b1) as Float64 * frac) as Int
        
        result.push_str(ANSI.fg_rgb(r, g, b))
        result.push(c)
    }
    result.push_str(ANSI.RESET)
    result
}

// -----------------------------------------------------------------------------
// Strip ANSI
// -----------------------------------------------------------------------------

/// Remove ANSI escape codes from string
fn strip_ansi(text: String) -> String {
    // Simple regex-like removal of ANSI codes
    var result = String.new()
    var in_escape = false
    
    for c in text.chars() {
        if c == '\x1b' {
            in_escape = true
        } else if in_escape {
            if c == 'm' {
                in_escape = false
            }
        } else {
            result.push(c)
        }
    }
    
    result
}

/// Get visible length (without ANSI codes)
fn visible_len(text: String) -> Int {
    strip_ansi(text).len()
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "styled text" {
    let s = styled("Hello").red().bold().render()
    assert(s.contains("\x1b["))?
    assert(s.contains("Hello"))?
}

test "color enum" {
    assert_eq(Color.Red.fg(), "\x1b[31m")?
    assert_eq(Color.Blue.bg(), "\x1b[44m")?
}

test "rgb color" {
    let code = ANSI.fg_rgb(255, 128, 0)
    assert_eq(code, "\x1b[38;2;255;128;0m")?
}

test "256 color" {
    let code = ANSI.fg256(196)
    assert_eq(code, "\x1b[38;5;196m")?
}

test "strip ansi" {
    let colored = styled("Hello").red().render()
    let plain = strip_ansi(colored)
    assert_eq(plain, "Hello")?
}

test "gradient" {
    let g = gradient("Test", (255, 0, 0), (0, 0, 255))
    assert(g.contains("Test"))?
}
