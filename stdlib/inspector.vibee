// =============================================================================
// Vibee OS — Inspector Module
// Object inspection, reflection, and runtime type introspection
// =============================================================================

// -----------------------------------------------------------------------------
// Type Information
// -----------------------------------------------------------------------------

/// Type kind enumeration
enum TypeKind {
    Primitive
    Struct
    Enum
    Actor
    Trait
    Function
    Array
    Map
    Option
    Result
    Tuple
    Reference
    Unknown
}

/// Complete type information
struct TypeInfo {
    name: String
    kind: TypeKind
    size: Int
    alignment: Int
    generics: [TypeInfo]
    module: String
    
    fn is_primitive() -> Bool {
        match self.kind {
            TypeKind.Primitive => true
            _ => false
        }
    }
    
    fn is_composite() -> Bool {
        match self.kind {
            TypeKind.Struct | TypeKind.Enum | TypeKind.Actor => true
            _ => false
        }
    }
    
    fn is_collection() -> Bool {
        match self.kind {
            TypeKind.Array | TypeKind.Map => true
            _ => false
        }
    }
    
    fn full_name() -> String {
        if self.generics.is_empty() {
            self.name.clone()
        } else {
            let generic_names = self.generics.iter().map(|g| g.full_name()).join(", ")
            format!("{}<{}>", self.name, generic_names)
        }
    }
}

/// Field information for structs
struct FieldInfo {
    name: String
    type_info: TypeInfo
    offset: Int
    is_public: Bool
    is_mutable: Bool
    attributes: [String]
}

/// Method information
struct MethodInfo {
    name: String
    return_type: Option<TypeInfo>
    parameters: [ParameterInfo]
    is_public: Bool
    is_static: Bool
    is_async: Bool
}

struct ParameterInfo {
    name: String
    type_info: TypeInfo
    has_default: Bool
}

/// Variant information for enums
struct VariantInfo {
    name: String
    index: Int
    fields: [FieldInfo]
    is_unit: Bool
}

// -----------------------------------------------------------------------------
// Object Inspector
// -----------------------------------------------------------------------------

/// Main object inspector
actor Inspector<T> {
    state value: T
    state type_info: TypeInfo
    state cached_fields: Option<[FieldInfo]>
    state cached_methods: Option<[MethodInfo]>
    
    fn new(value: T) -> Self {
        Inspector {
            value: value,
            type_info: @native("type_info_of", value),
            cached_fields: None,
            cached_methods: None
        }
    }
    
    // -------------------------------------------------------------------------
    // Basic Information
    // -------------------------------------------------------------------------
    
    /// Get type name
    fn type_name() -> String {
        self.type_info.name.clone()
    }
    
    /// Get full type name with generics
    fn full_type_name() -> String {
        self.type_info.full_name()
    }
    
    /// Get type kind
    fn kind() -> TypeKind {
        self.type_info.kind.clone()
    }
    
    /// Get size in bytes
    fn size() -> Int {
        self.type_info.size
    }
    
    /// Get alignment
    fn alignment() -> Int {
        self.type_info.alignment
    }
    
    /// Get memory address
    fn address() -> Int {
        @native("address_of", self.value)
    }
    
    /// Get module name
    fn module() -> String {
        self.type_info.module.clone()
    }
    
    // -------------------------------------------------------------------------
    // Field Inspection
    // -------------------------------------------------------------------------
    
    /// Get all fields
    fn fields() -> [FieldInfo] {
        if let Some(fields) = self.cached_fields.clone() {
            return fields
        }
        
        let fields: [FieldInfo] = @native("get_fields", self.value)
        self.cached_fields = Some(fields.clone())
        fields
    }
    
    /// Get field by name
    fn field(name: String) -> Option<FieldInfo> {
        self.fields().iter().find(|f| f.name == name).cloned()
    }
    
    /// Get field value by name
    fn get_field_value(name: String) -> Option<Any> {
        @native("get_field_value", self.value, name)
    }
    
    /// Get field value as specific type
    fn get_field<U>(name: String) -> Option<U> {
        self.get_field_value(name).and_then(|v| v.downcast::<U>())
    }
    
    /// Check if field exists
    fn has_field(name: String) -> Bool {
        self.fields().iter().any(|f| f.name == name)
    }
    
    /// Get public fields only
    fn public_fields() -> [FieldInfo] {
        self.fields().iter().filter(|f| f.is_public).collect()
    }
    
    // -------------------------------------------------------------------------
    // Method Inspection
    // -------------------------------------------------------------------------
    
    /// Get all methods
    fn methods() -> [MethodInfo] {
        if let Some(methods) = self.cached_methods.clone() {
            return methods
        }
        
        let methods: [MethodInfo] = @native("get_methods", self.value)
        self.cached_methods = Some(methods.clone())
        methods
    }
    
    /// Get method by name
    fn method(name: String) -> Option<MethodInfo> {
        self.methods().iter().find(|m| m.name == name).cloned()
    }
    
    /// Check if method exists
    fn has_method(name: String) -> Bool {
        self.methods().iter().any(|m| m.name == name)
    }
    
    /// Get public methods only
    fn public_methods() -> [MethodInfo] {
        self.methods().iter().filter(|m| m.is_public).collect()
    }
    
    /// Get static methods
    fn static_methods() -> [MethodInfo] {
        self.methods().iter().filter(|m| m.is_static).collect()
    }
    
    // -------------------------------------------------------------------------
    // Enum Inspection
    // -------------------------------------------------------------------------
    
    /// Get enum variants (for enum types)
    fn variants() -> [VariantInfo] {
        @native("get_variants", self.value)
    }
    
    /// Get current variant (for enum values)
    fn current_variant() -> Option<VariantInfo> {
        @native("get_current_variant", self.value)
    }
    
    /// Get variant name
    fn variant_name() -> Option<String> {
        self.current_variant().map(|v| v.name)
    }
    
    // -------------------------------------------------------------------------
    // Trait Inspection
    // -------------------------------------------------------------------------
    
    /// Get implemented traits
    fn traits() -> [String] {
        @native("get_traits", self.value)
    }
    
    /// Check if implements trait
    fn implements(trait_name: String) -> Bool {
        self.traits().contains(trait_name)
    }
    
    // -------------------------------------------------------------------------
    // Value Inspection
    // -------------------------------------------------------------------------
    
    /// Get debug representation
    fn debug_string() -> String {
        @native("debug_format", self.value)
    }
    
    /// Get display representation
    fn display_string() -> String {
        @native("display_format", self.value)
    }
    
    /// Check if value is default
    fn is_default() -> Bool where T: Default {
        self.value == T.default()
    }
    
    /// Check if value is zero/empty
    fn is_zero() -> Bool {
        @native("is_zero", self.value)
    }
    
    /// Clone the value
    fn clone_value() -> T where T: Clone {
        self.value.clone()
    }
    
    // -------------------------------------------------------------------------
    // Memory Inspection
    // -------------------------------------------------------------------------
    
    /// Get raw bytes
    fn as_bytes() -> [UInt8] {
        @native("value_as_bytes", self.value)
    }
    
    /// Get hex dump
    fn hex_dump() -> String {
        let bytes = self.as_bytes()
        var result = StringBuilder.new()
        
        for (i, chunk) in bytes.chunks(16).enumerate() {
            result.append(format!("{:08x}  ", i * 16))
            
            for (j, byte) in chunk.enumerate() {
                result.append(format!("{:02x} ", byte))
                if j == 7 { result.append(" ") }
            }
            
            for _ in chunk.len()..16 {
                result.append("   ")
            }
            
            result.append(" |")
            for byte in chunk {
                let c = if byte >= 32 && byte < 127 { byte as Char } else { '.' }
                result.append(c)
            }
            result.append("|\n")
        }
        
        result.build()
    }
    
    // -------------------------------------------------------------------------
    // Comparison
    // -------------------------------------------------------------------------
    
    /// Compare with another value
    fn compare<U>(other: U) -> ComparisonResult {
        let other_inspector = Inspector.new(other)
        
        ComparisonResult {
            same_type: self.type_name() == other_inspector.type_name(),
            same_size: self.size() == other_inspector.size(),
            same_fields: self.compare_fields(other_inspector),
            differences: self.find_differences(other_inspector)
        }
    }
    
    fn compare_fields<U>(other: Inspector<U>) -> Bool {
        let my_fields = self.fields()
        let other_fields = other.fields()
        
        if my_fields.len() != other_fields.len() { return false }
        
        for (a, b) in my_fields.iter().zip(other_fields.iter()) {
            if a.name != b.name || a.type_info.name != b.type_info.name {
                return false
            }
        }
        
        true
    }
    
    fn find_differences<U>(other: Inspector<U>) -> [FieldDifference] {
        var diffs = []
        
        let my_fields = self.fields()
        let other_fields = other.fields()
        
        for field in my_fields {
            let my_value = self.get_field_value(field.name.clone())
            let other_value = other.get_field_value(field.name.clone())
            
            match (my_value, other_value) {
                (Some(a), Some(b)) => {
                    if @native("debug_format", a) != @native("debug_format", b) {
                        diffs.push(FieldDifference {
                            field_name: field.name,
                            left_value: @native("debug_format", a),
                            right_value: @native("debug_format", b)
                        })
                    }
                }
                (Some(a), None) => {
                    diffs.push(FieldDifference {
                        field_name: field.name,
                        left_value: @native("debug_format", a),
                        right_value: "<missing>".to_string()
                    })
                }
                (None, Some(b)) => {
                    diffs.push(FieldDifference {
                        field_name: field.name,
                        left_value: "<missing>".to_string(),
                        right_value: @native("debug_format", b)
                    })
                }
                _ => {}
            }
        }
        
        diffs
    }
    
    // -------------------------------------------------------------------------
    // Report Generation
    // -------------------------------------------------------------------------
    
    /// Generate full inspection report
    fn report() -> InspectionReport {
        InspectionReport {
            type_name: self.full_type_name(),
            kind: self.kind(),
            size: self.size(),
            alignment: self.alignment(),
            address: self.address(),
            module: self.module(),
            fields: self.fields(),
            methods: self.public_methods(),
            traits: self.traits(),
            debug_value: self.debug_string()
        }
    }
    
    /// Print inspection report
    fn print_report() {
        let report = self.report()
        
        println("╔══════════════════════════════════════════╗")
        println("║         Object Inspection Report         ║")
        println("╚══════════════════════════════════════════╝")
        println()
        println(format!("Type:      {}", report.type_name))
        println(format!("Kind:      {:?}", report.kind))
        println(format!("Size:      {} bytes", report.size))
        println(format!("Alignment: {} bytes", report.alignment))
        println(format!("Address:   0x{:x}", report.address))
        println(format!("Module:    {}", report.module))
        println()
        
        if !report.fields.is_empty() {
            println("Fields:")
            for field in report.fields {
                let vis = if field.is_public { "pub" } else { "priv" }
                let mutability = if field.is_mutable { "mut" } else { "" }
                println(format!("  {} {} {}: {}", vis, mutability, field.name, field.type_info.full_name()))
            }
            println()
        }
        
        if !report.methods.is_empty() {
            println("Methods:")
            for method in report.methods {
                let params = method.parameters.iter()
                    .map(|p| format!("{}: {}", p.name, p.type_info.full_name()))
                    .join(", ")
                let ret = method.return_type.map(|t| format!(" -> {}", t.full_name())).unwrap_or("")
                println(format!("  fn {}({}){}", method.name, params, ret))
            }
            println()
        }
        
        if !report.traits.is_empty() {
            println(format!("Traits: {}", report.traits.join(", ")))
            println()
        }
        
        println(format!("Value: {}", report.debug_value))
    }
}

struct ComparisonResult {
    same_type: Bool
    same_size: Bool
    same_fields: Bool
    differences: [FieldDifference]
}

struct FieldDifference {
    field_name: String
    left_value: String
    right_value: String
}

struct InspectionReport {
    type_name: String
    kind: TypeKind
    size: Int
    alignment: Int
    address: Int
    module: String
    fields: [FieldInfo]
    methods: [MethodInfo]
    traits: [String]
    debug_value: String
}

// -----------------------------------------------------------------------------
// Object Graph Inspector
// -----------------------------------------------------------------------------

/// Inspect object reference graph
actor ObjectGraphInspector {
    state nodes: Map<Int, ObjectNode>
    state edges: [(Int, Int)]
    state max_depth: Int
    
    fn new() -> Self {
        ObjectGraphInspector {
            nodes: Map.new(),
            edges: [],
            max_depth: 10
        }
    }
    
    fn with_max_depth(depth: Int) -> Self {
        self.max_depth = depth
        self
    }
    
    /// Build object graph from root
    fn build<T>(root: T) -> Self {
        self.nodes.clear()
        self.edges.clear()
        self.traverse(root, 0)
        self
    }
    
    fn traverse<T>(obj: T, depth: Int) {
        if depth >= self.max_depth { return }
        
        let addr = @native("address_of", obj)
        if self.nodes.contains_key(addr) { return }
        
        let inspector = Inspector.new(obj)
        let node = ObjectNode {
            address: addr,
            type_name: inspector.full_type_name(),
            size: inspector.size(),
            fields: inspector.fields().iter().map(|f| {
                ObjectFieldNode {
                    name: f.name.clone(),
                    type_name: f.type_info.full_name(),
                    value: inspector.get_field_value(f.name.clone())
                        .map(|v| @native("debug_format", v))
                        .unwrap_or("<unknown>".to_string()),
                    is_reference: f.type_info.kind == TypeKind.Reference
                }
            }).collect()
        }
        
        self.nodes.insert(addr, node.clone())
        
        // Traverse references
        for field in node.fields {
            if field.is_reference {
                if let Some(ref_addr) = @native("get_reference_address", obj, field.name) {
                    self.edges.push((addr, ref_addr))
                    if let Some(ref_obj) = @native("deref_address", ref_addr) {
                        self.traverse(ref_obj, depth + 1)
                    }
                }
            }
        }
    }
    
    /// Get all nodes
    fn get_nodes() -> [ObjectNode] {
        self.nodes.values().collect()
    }
    
    /// Get all edges
    fn get_edges() -> [(Int, Int)] {
        self.edges.clone()
    }
    
    /// Find cycles in the graph
    fn find_cycles() -> [[Int]] {
        var cycles = []
        var visited = Set.new()
        var stack = []
        
        for addr in self.nodes.keys() {
            if !visited.contains(addr) {
                self.dfs_cycles(addr, visited, stack, cycles)
            }
        }
        
        cycles
    }
    
    fn dfs_cycles(addr: Int, visited: Set<Int>, stack: [Int], cycles: [[Int]]) {
        visited.insert(addr)
        stack.push(addr)
        
        for (from, to) in self.edges {
            if from == addr {
                if stack.contains(to) {
                    // Found cycle
                    let cycle_start = stack.iter().position(|a| a == to).unwrap()
                    cycles.push(stack[cycle_start..].to_vec())
                } else if !visited.contains(to) {
                    self.dfs_cycles(to, visited, stack, cycles)
                }
            }
        }
        
        stack.pop()
    }
    
    /// Generate DOT graph representation
    fn to_dot() -> String {
        var output = StringBuilder.new()
        output.append("digraph ObjectGraph {\n")
        output.append("  rankdir=LR;\n")
        output.append("  node [shape=record];\n\n")
        
        for (addr, node) in self.nodes {
            let fields = node.fields.iter()
                .map(|f| format!("{}: {}", f.name, f.type_name))
                .join("\\l")
            output.append(format!("  n{} [label=\"{{{}|{}}}\"];\n", addr, node.type_name, fields))
        }
        
        output.append("\n")
        
        for (from, to) in self.edges {
            output.append(format!("  n{} -> n{};\n", from, to))
        }
        
        output.append("}\n")
        output.build()
    }
    
    /// Print graph summary
    fn print_summary() {
        println("═══ Object Graph Summary ═══")
        println(format!("Nodes: {}", self.nodes.len()))
        println(format!("Edges: {}", self.edges.len()))
        
        let cycles = self.find_cycles()
        if !cycles.is_empty() {
            println(format!("Cycles detected: {}", cycles.len()))
        }
        
        let total_size = self.nodes.values().map(|n| n.size).sum()
        println(format!("Total size: {} bytes", total_size))
    }
}

struct ObjectNode {
    address: Int
    type_name: String
    size: Int
    fields: [ObjectFieldNode]
}

struct ObjectFieldNode {
    name: String
    type_name: String
    value: String
    is_reference: Bool
}

// -----------------------------------------------------------------------------
// Quick Inspection Functions
// -----------------------------------------------------------------------------

/// Quick inspect function
fn inspect<T>(value: T) -> Inspector<T> {
    Inspector.new(value)
}

/// Print type info
fn print_type<T>(value: T) {
    let i = inspect(value)
    println(format!("Type: {} ({:?})", i.full_type_name(), i.kind()))
    println(format!("Size: {} bytes, Align: {} bytes", i.size(), i.alignment()))
}

/// Print fields
fn print_fields<T>(value: T) {
    let i = inspect(value)
    println(format!("Fields of {}:", i.type_name()))
    for field in i.fields() {
        let value = i.get_field_value(field.name.clone())
            .map(|v| @native("debug_format", v))
            .unwrap_or("<unknown>".to_string())
        println(format!("  {}: {} = {}", field.name, field.type_info.full_name(), value))
    }
}

/// Print methods
fn print_methods<T>(value: T) {
    let i = inspect(value)
    println(format!("Methods of {}:", i.type_name()))
    for method in i.public_methods() {
        let params = method.parameters.iter()
            .map(|p| format!("{}: {}", p.name, p.type_info.full_name()))
            .join(", ")
        let ret = method.return_type.map(|t| format!(" -> {}", t.full_name())).unwrap_or("")
        println(format!("  fn {}({}){}", method.name, params, ret))
    }
}

/// Compare two values
fn compare<T, U>(a: T, b: U) -> ComparisonResult {
    inspect(a).compare(b)
}

// -----------------------------------------------------------------------------
// Trait for Inspectable Types
// -----------------------------------------------------------------------------

trait Inspectable {
    fn inspect() -> Inspector<Self>
    fn type_info() -> TypeInfo
    fn field_names() -> [String]
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "type_info" {
    struct Point { x: Int, y: Int }
    let p = Point { x: 10, y: 20 }
    let i = inspect(p)
    
    assert(i.type_name().contains("Point"))?
    assert_eq(i.kind(), TypeKind.Struct)?
}

test "field_inspection" {
    struct Person { name: String, age: Int }
    let person = Person { name: "Alice", age: 30 }
    let i = inspect(person)
    
    assert(i.has_field("name"))?
    assert(i.has_field("age"))?
    assert(!i.has_field("unknown"))?
}

test "object_graph" {
    struct Node { value: Int, next: Option<Node> }
    let node = Node { value: 1, next: Some(Node { value: 2, next: None }) }
    
    let graph = ObjectGraphInspector.new().build(node)
    assert(graph.get_nodes().len() >= 1)?
}

test "comparison" {
    struct Data { x: Int }
    let a = Data { x: 10 }
    let b = Data { x: 20 }
    
    let result = compare(a, b)
    assert(result.same_type)?
    assert(result.same_size)?
}
