// =============================================================================
// Vibee OS — Data Extractor Module
// Structured data extraction from web pages
// =============================================================================

use html_parser::{HtmlDocument, HtmlElement}
use scraper::{ScrapedPage, ScrapeError}
use regex::{Regex}
use result::{Result, Ok, Err}
use option::{Option, Some, None}

// =============================================================================
// Data Extractor
// =============================================================================

/// Data extractor for structured extraction
struct DataExtractor {
    rules: [ExtractionRule]
    post_processors: [fn(Map<String, Value>) -> Map<String, Value>]
    
    fn new() -> Self {
        DataExtractor { rules: [], post_processors: [] }
    }
    
    /// Add extraction rule
    fn rule(rule: ExtractionRule) -> Self {
        self.rules.push(rule)
        self
    }
    
    /// Add text extraction
    fn text(name: String, selector: String) -> Self {
        self.rule(ExtractionRule.text(name, selector))
    }
    
    /// Add attribute extraction
    fn attr(name: String, selector: String, attr: String) -> Self {
        self.rule(ExtractionRule.attr(name, selector, attr))
    }
    
    /// Add list extraction
    fn list(name: String, selector: String) -> Self {
        self.rule(ExtractionRule.list(name, selector))
    }
    
    /// Add nested extraction
    fn nested(name: String, selector: String, extractor: DataExtractor) -> Self {
        self.rule(ExtractionRule.nested(name, selector, extractor))
    }
    
    /// Add post processor
    fn post_process(f: fn(Map<String, Value>) -> Map<String, Value>) -> Self {
        self.post_processors.push(f)
        self
    }
    
    /// Extract from document
    fn extract(doc: HtmlDocument) -> Result<Map<String, Value>, ExtractionError> {
        var result = Map.empty()
        
        for rule in self.rules {
            let value = rule.extract(doc)?
            result.set(rule.name, value)
        }
        
        for processor in self.post_processors {
            result = processor(result)
        }
        
        Ok(result)
    }
    
    /// Extract from page
    fn extract_page(page: ScrapedPage) -> Result<Map<String, Value>, ExtractionError> {
        self.extract(page.document)
    }
    
    /// Extract list of items
    fn extract_items(doc: HtmlDocument, item_selector: String) -> Result<[Map<String, Value>], ExtractionError> {
        var items = []
        
        for element in doc.query_selector_all(item_selector) {
            var item = Map.empty()
            for rule in self.rules {
                let value = rule.extract_from_element(element)?
                item.set(rule.name, value)
            }
            items.push(item)
        }
        
        Ok(items)
    }
}

// =============================================================================
// Extraction Rule
// =============================================================================

/// Extraction rule
struct ExtractionRule {
    name: String
    selector: String
    rule_type: RuleType
    required: Bool
    default_value: Option<Value>
    transforms: [Transform]
    
    fn text(name: String, selector: String) -> Self {
        ExtractionRule {
            name: name,
            selector: selector,
            rule_type: RuleType.Text,
            required: false,
            default_value: None,
            transforms: []
        }
    }
    
    fn attr(name: String, selector: String, attr: String) -> Self {
        ExtractionRule {
            name: name,
            selector: selector,
            rule_type: RuleType.Attribute(attr),
            required: false,
            default_value: None,
            transforms: []
        }
    }
    
    fn html(name: String, selector: String) -> Self {
        ExtractionRule {
            name: name,
            selector: selector,
            rule_type: RuleType.Html,
            required: false,
            default_value: None,
            transforms: []
        }
    }
    
    fn list(name: String, selector: String) -> Self {
        ExtractionRule {
            name: name,
            selector: selector,
            rule_type: RuleType.List,
            required: false,
            default_value: None,
            transforms: []
        }
    }
    
    fn nested(name: String, selector: String, extractor: DataExtractor) -> Self {
        ExtractionRule {
            name: name,
            selector: selector,
            rule_type: RuleType.Nested(extractor),
            required: false,
            default_value: None,
            transforms: []
        }
    }
    
    fn required() -> Self {
        ExtractionRule { required: true, ..self }
    }
    
    fn default(value: Value) -> Self {
        ExtractionRule { default_value: Some(value), ..self }
    }
    
    fn transform(t: Transform) -> Self {
        self.transforms.push(t)
        self
    }
    
    fn extract(doc: HtmlDocument) -> Result<Value, ExtractionError> {
        let raw = match self.rule_type {
            RuleType.Text => self.extract_text(doc)
            RuleType.Attribute(attr) => self.extract_attr(doc, attr)
            RuleType.Html => self.extract_html(doc)
            RuleType.List => self.extract_list(doc)
            RuleType.Nested(extractor) => self.extract_nested(doc, extractor)
            RuleType.Regex(pattern) => self.extract_regex(doc, pattern)
        }?
        
        self.apply_transforms(raw)
    }
    
    fn extract_from_element(elem: HtmlElement) -> Result<Value, ExtractionError> {
        let target = if self.selector.is_empty() {
            Some(elem)
        } else {
            elem.query_selector(self.selector)
        }
        
        match target {
            Some(e) => {
                let raw = match self.rule_type {
                    RuleType.Text => Value.String(e.text_content().trim())
                    RuleType.Attribute(attr) => {
                        match e.get_attribute(attr) {
                            Some(v) => Value.String(v)
                            None => Value.Null
                        }
                    }
                    RuleType.Html => Value.String(e.inner_html())
                    _ => Value.Null
                }
                self.apply_transforms(raw)
            }
            None => self.handle_missing()
        }
    }
    
    fn extract_text(doc: HtmlDocument) -> Result<Value, ExtractionError> {
        match doc.query_selector(self.selector) {
            Some(e) => Ok(Value.String(e.text_content().trim()))
            None => self.handle_missing()
        }
    }
    
    fn extract_attr(doc: HtmlDocument, attr: String) -> Result<Value, ExtractionError> {
        match doc.query_selector(self.selector) {
            Some(e) => match e.get_attribute(attr) {
                Some(v) => Ok(Value.String(v))
                None => self.handle_missing()
            }
            None => self.handle_missing()
        }
    }
    
    fn extract_html(doc: HtmlDocument) -> Result<Value, ExtractionError> {
        match doc.query_selector(self.selector) {
            Some(e) => Ok(Value.String(e.inner_html()))
            None => self.handle_missing()
        }
    }
    
    fn extract_list(doc: HtmlDocument) -> Result<Value, ExtractionError> {
        let elements = doc.query_selector_all(self.selector)
        let values = elements.iter()
            .map(|e| Value.String(e.text_content().trim()))
            .filter(|v| match v { Value.String(s) => !s.is_empty(), _ => true })
            .collect()
        Ok(Value.Array(values))
    }
    
    fn extract_nested(doc: HtmlDocument, extractor: DataExtractor) -> Result<Value, ExtractionError> {
        match doc.query_selector(self.selector) {
            Some(e) => {
                let nested_doc = HtmlDocument { root: HtmlNode.Element(e), doctype: None }
                let map = extractor.extract(nested_doc)?
                Ok(Value.Object(map))
            }
            None => self.handle_missing()
        }
    }
    
    fn extract_regex(doc: HtmlDocument, pattern: String) -> Result<Value, ExtractionError> {
        let text = match doc.query_selector(self.selector) {
            Some(e) => e.text_content()
            None => return self.handle_missing()
        }
        
        let re = Regex.new(pattern).map_err(|e| ExtractionError.InvalidPattern(e.to_string()))?
        match re.captures(text) {
            Some(caps) => {
                if caps.len() > 1 {
                    Ok(Value.String(caps.get(1)?.text))
                } else {
                    Ok(Value.String(caps.full()?.text))
                }
            }
            None => self.handle_missing()
        }
    }
    
    fn handle_missing() -> Result<Value, ExtractionError> {
        if self.required {
            Err(ExtractionError.RequiredFieldMissing(self.name.clone()))
        } else {
            Ok(self.default_value.clone().unwrap_or(Value.Null))
        }
    }
    
    fn apply_transforms(value: Value) -> Result<Value, ExtractionError> {
        var result = value
        for t in self.transforms {
            result = t.apply(result)?
        }
        Ok(result)
    }
}

/// Rule type
enum RuleType {
    Text
    Attribute(String)
    Html
    List
    Nested(DataExtractor)
    Regex(String)
}

// =============================================================================
// Value Type
// =============================================================================

/// Extracted value
enum Value {
    Null
    String(String)
    Int(Int)
    Float(Float)
    Bool(Bool)
    Array([Value])
    Object(Map<String, Value>)
    
    fn as_string() -> Option<String> {
        match self {
            String(s) => Some(s)
            Int(i) => Some(i.to_string())
            Float(f) => Some(f.to_string())
            Bool(b) => Some(b.to_string())
            _ => None
        }
    }
    
    fn as_int() -> Option<Int> {
        match self {
            Int(i) => Some(i)
            String(s) => Int.parse(s).ok()
            Float(f) => Some(f as Int)
            _ => None
        }
    }
    
    fn as_float() -> Option<Float> {
        match self {
            Float(f) => Some(f)
            Int(i) => Some(i as Float)
            String(s) => Float.parse(s).ok()
            _ => None
        }
    }
    
    fn as_bool() -> Option<Bool> {
        match self {
            Bool(b) => Some(b)
            String(s) => match s.to_lower() {
                "true" | "yes" | "1" => Some(true)
                "false" | "no" | "0" => Some(false)
                _ => None
            }
            Int(i) => Some(i != 0)
            _ => None
        }
    }
    
    fn as_array() -> Option<[Value]> {
        match self {
            Array(a) => Some(a)
            _ => None
        }
    }
    
    fn as_object() -> Option<Map<String, Value>> {
        match self {
            Object(o) => Some(o)
            _ => None
        }
    }
    
    fn is_null() -> Bool {
        match self { Null => true, _ => false }
    }
}

// =============================================================================
// Transforms
// =============================================================================

/// Value transform
enum Transform {
    Trim
    ToLower
    ToUpper
    Replace(String, String)
    RegexReplace(String, String)
    ParseInt
    ParseFloat
    ParseBool
    Split(String)
    Join(String)
    Take(Int)
    Skip(Int)
    Default(Value)
    Custom(fn(Value) -> Result<Value, ExtractionError>)
    
    fn apply(value: Value) -> Result<Value, ExtractionError> {
        match self {
            Trim => match value {
                Value.String(s) => Ok(Value.String(s.trim()))
                _ => Ok(value)
            }
            ToLower => match value {
                Value.String(s) => Ok(Value.String(s.to_lower()))
                _ => Ok(value)
            }
            ToUpper => match value {
                Value.String(s) => Ok(Value.String(s.to_upper()))
                _ => Ok(value)
            }
            Replace(from, to) => match value {
                Value.String(s) => Ok(Value.String(s.replace(from, to)))
                _ => Ok(value)
            }
            RegexReplace(pattern, replacement) => match value {
                Value.String(s) => {
                    let re = Regex.new(pattern)?
                    Ok(Value.String(re.replace_all(s, replacement)))
                }
                _ => Ok(value)
            }
            ParseInt => match value {
                Value.String(s) => match Int.parse(s.trim()) {
                    Ok(i) => Ok(Value.Int(i))
                    Err(_) => Ok(Value.Null)
                }
                _ => Ok(value)
            }
            ParseFloat => match value {
                Value.String(s) => match Float.parse(s.trim()) {
                    Ok(f) => Ok(Value.Float(f))
                    Err(_) => Ok(Value.Null)
                }
                _ => Ok(value)
            }
            ParseBool => Ok(Value.Bool(value.as_bool().unwrap_or(false)))
            Split(sep) => match value {
                Value.String(s) => {
                    let parts = s.split(sep).map(|p| Value.String(p.trim())).collect()
                    Ok(Value.Array(parts))
                }
                _ => Ok(value)
            }
            Join(sep) => match value {
                Value.Array(arr) => {
                    let strings = arr.iter().filter_map(|v| v.as_string()).collect()
                    Ok(Value.String(strings.join(sep)))
                }
                _ => Ok(value)
            }
            Take(n) => match value {
                Value.Array(arr) => Ok(Value.Array(arr.iter().take(n).collect()))
                Value.String(s) => Ok(Value.String(s.chars().take(n).collect()))
                _ => Ok(value)
            }
            Skip(n) => match value {
                Value.Array(arr) => Ok(Value.Array(arr.iter().skip(n).collect()))
                Value.String(s) => Ok(Value.String(s.chars().skip(n).collect()))
                _ => Ok(value)
            }
            Default(def) => match value {
                Value.Null => Ok(def)
                _ => Ok(value)
            }
            Custom(f) => f(value)
        }
    }
}

// =============================================================================
// Schema Extractor
// =============================================================================

/// Schema-based extractor
struct SchemaExtractor {
    schema: ExtractionSchema
    
    fn new(schema: ExtractionSchema) -> Self {
        SchemaExtractor { schema: schema }
    }
    
    fn extract(doc: HtmlDocument) -> Result<Map<String, Value>, ExtractionError> {
        var result = Map.empty()
        
        for (name, field) in self.schema.fields.iter() {
            let value = field.extract(doc)?
            result.set(name, value)
        }
        
        Ok(result)
    }
}

/// Extraction schema
struct ExtractionSchema {
    fields: Map<String, SchemaField>
    
    fn new() -> Self {
        ExtractionSchema { fields: Map.empty() }
    }
    
    fn field(name: String, field: SchemaField) -> Self {
        self.fields.set(name, field)
        self
    }
}

/// Schema field
struct SchemaField {
    selector: String
    field_type: FieldType
    required: Bool
    
    fn text(selector: String) -> Self {
        SchemaField { selector: selector, field_type: FieldType.Text, required: false }
    }
    
    fn number(selector: String) -> Self {
        SchemaField { selector: selector, field_type: FieldType.Number, required: false }
    }
    
    fn required() -> Self {
        SchemaField { required: true, ..self }
    }
    
    fn extract(doc: HtmlDocument) -> Result<Value, ExtractionError> {
        match doc.query_selector(self.selector) {
            Some(e) => {
                let text = e.text_content().trim()
                match self.field_type {
                    FieldType.Text => Ok(Value.String(text))
                    FieldType.Number => {
                        match Float.parse(text) {
                            Ok(f) => Ok(Value.Float(f))
                            Err(_) => Ok(Value.Null)
                        }
                    }
                    FieldType.Boolean => Ok(Value.Bool(!text.is_empty()))
                    FieldType.List => Ok(Value.Array([Value.String(text)]))
                }
            }
            None => {
                if self.required {
                    Err(ExtractionError.RequiredFieldMissing(self.selector.clone()))
                } else {
                    Ok(Value.Null)
                }
            }
        }
    }
}

/// Field type
enum FieldType {
    Text
    Number
    Boolean
    List
}

// =============================================================================
// Pattern Extractors
// =============================================================================

/// Extract emails from text
fn extract_emails(text: String) -> [String] {
    let re = Regex.new(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}").unwrap()
    re.find_all(text).iter().map(|m| m.text).collect()
}

/// Extract phone numbers
fn extract_phones(text: String) -> [String] {
    let re = Regex.new(r"\+?[\d\s\-\(\)]{10,}").unwrap()
    re.find_all(text).iter().map(|m| m.text.trim()).collect()
}

/// Extract URLs
fn extract_urls(text: String) -> [String] {
    let re = Regex.new(r"https?://[^\s]+").unwrap()
    re.find_all(text).iter().map(|m| m.text).collect()
}

/// Extract prices
fn extract_prices(text: String) -> [Price] {
    let re = Regex.new(r"([$€£¥])\s*(\d+(?:[.,]\d{2})?)").unwrap()
    re.captures_all(text).iter().filter_map(|caps| {
        let currency = caps.get(1)?.text
        let amount = caps.get(2)?.text.replace(",", ".")
        Some(Price { currency: currency, amount: Float.parse(amount).ok()? })
    }).collect()
}

/// Price
struct Price {
    currency: String
    amount: Float
}

/// Extract dates
fn extract_dates(text: String) -> [String] {
    let patterns = [
        r"\d{4}-\d{2}-\d{2}",
        r"\d{2}/\d{2}/\d{4}",
        r"\d{2}\.\d{2}\.\d{4}"
    ]
    var dates = []
    for pattern in patterns {
        if let Ok(re) = Regex.new(pattern) {
            dates.extend(re.find_all(text).iter().map(|m| m.text))
        }
    }
    dates
}

// =============================================================================
// Errors
// =============================================================================

/// Extraction error
enum ExtractionError {
    RequiredFieldMissing(String)
    InvalidPattern(String)
    TransformError(String)
    ParseError(String)
}

impl Display for ExtractionError {
    fn fmt(f: Formatter) {
        match self {
            RequiredFieldMissing(s) => f.write(format!("Required field missing: {}", s))
            InvalidPattern(s) => f.write(format!("Invalid pattern: {}", s))
            TransformError(s) => f.write(format!("Transform error: {}", s))
            ParseError(s) => f.write(format!("Parse error: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "value conversions" {
    let s = Value.String("42")
    assert_eq(s.as_int(), Some(42))?
    
    let i = Value.Int(100)
    assert_eq(i.as_string(), Some("100"))?
}

test "transforms" {
    let value = Value.String("  Hello World  ")
    let trimmed = Transform.Trim.apply(value)?
    assert_eq(trimmed.as_string(), Some("Hello World"))?
}

test "extract emails" {
    let text = "Contact us at info@example.com or support@test.org"
    let emails = extract_emails(text)
    assert_eq(emails.len(), 2)?
}

test "extract prices" {
    let text = "Price: $19.99 or €15.50"
    let prices = extract_prices(text)
    assert_eq(prices.len(), 2)?
    assert_eq(prices[0].currency, "$")?
}
