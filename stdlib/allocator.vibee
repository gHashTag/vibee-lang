// =============================================================================
// Vibee OS â€” Allocator Module
// Custom memory allocators and allocation strategies
// =============================================================================

// -----------------------------------------------------------------------------
// Allocator Trait
// -----------------------------------------------------------------------------

/// Base allocator trait
trait Allocator {
    /// Allocate memory
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError>
    
    /// Deallocate memory
    fn deallocate(ptr: *UInt8, size: Int, align: Int)
    
    /// Reallocate memory
    fn reallocate(ptr: *UInt8, old_size: Int, new_size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let new_ptr = self.allocate(new_size, align)?
        @native("memcpy", new_ptr, ptr, old_size.min(new_size))
        self.deallocate(ptr, old_size, align)
        Ok(new_ptr)
    }
    
    /// Allocate zeroed memory
    fn allocate_zeroed(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let ptr = self.allocate(size, align)?
        @native("memset", ptr, 0, size)
        Ok(ptr)
    }
}

/// Allocation error
enum AllocError {
    OutOfMemory
    InvalidSize
    InvalidAlignment
    AllocationFailed(String)
    
    fn message() -> String {
        match self {
            OutOfMemory => "Out of memory"
            InvalidSize => "Invalid allocation size"
            InvalidAlignment => "Invalid alignment"
            AllocationFailed(msg) => msg
        }
    }
}

// -----------------------------------------------------------------------------
// System Allocator
// -----------------------------------------------------------------------------

/// Default system allocator
struct SystemAllocator {}

impl Allocator for SystemAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        if size <= 0 { return Err(AllocError.InvalidSize) }
        if align <= 0 || (align & (align - 1)) != 0 {
            return Err(AllocError.InvalidAlignment)
        }
        
        let ptr = @native("aligned_alloc", align, size)
        if ptr.is_null() {
            Err(AllocError.OutOfMemory)
        } else {
            Ok(ptr)
        }
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        if !ptr.is_null() {
            @native("aligned_free", ptr)
        }
    }
}

impl SystemAllocator {
    fn new() -> Self { SystemAllocator {} }
    fn global() -> Self { SystemAllocator {} }
}

// -----------------------------------------------------------------------------
// Bump Allocator
// -----------------------------------------------------------------------------

/// Fast bump allocator (no individual deallocation)
struct BumpAllocator {
    memory: *UInt8
    size: Int
    offset: Int
    
    fn new(size: Int) -> Self {
        BumpAllocator {
            memory: @native("allocate_raw", size),
            size: size,
            offset: 0
        }
    }
    
    fn with_memory(memory: *UInt8, size: Int) -> Self {
        BumpAllocator {
            memory: memory,
            size: size,
            offset: 0
        }
    }
    
    fn used() -> Int { self.offset }
    fn available() -> Int { self.size - self.offset }
    
    fn reset() { self.offset = 0 }
}

impl Allocator for BumpAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let aligned_offset = (self.offset + align - 1) & !(align - 1)
        
        if aligned_offset + size > self.size {
            return Err(AllocError.OutOfMemory)
        }
        
        let ptr = (self.memory as Int + aligned_offset) as *UInt8
        self.offset = aligned_offset + size
        Ok(ptr)
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        // Bump allocator doesn't support individual deallocation
    }
}

impl Drop for BumpAllocator {
    fn drop() {
        @native("deallocate_raw", self.memory, self.size)
    }
}

// -----------------------------------------------------------------------------
// Stack Allocator
// -----------------------------------------------------------------------------

/// Stack-based allocator (LIFO deallocation)
struct StackAllocator {
    memory: *UInt8
    size: Int
    offset: Int
    markers: [Int]
    
    fn new(size: Int) -> Self {
        StackAllocator {
            memory: @native("allocate_raw", size),
            size: size,
            offset: 0,
            markers: []
        }
    }
    
    /// Push marker for later rollback
    fn push_marker() -> Int {
        let marker = self.offset
        self.markers.push(marker)
        marker
    }
    
    /// Pop to last marker
    fn pop_marker() {
        if let Some(marker) = self.markers.pop() {
            self.offset = marker
        }
    }
    
    /// Pop to specific marker
    fn pop_to(marker: Int) {
        if marker <= self.offset {
            self.offset = marker
            self.markers.retain(|m| *m < marker)
        }
    }
    
    fn used() -> Int { self.offset }
    fn available() -> Int { self.size - self.offset }
    fn reset() { self.offset = 0; self.markers.clear() }
}

impl Allocator for StackAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let aligned_offset = (self.offset + align - 1) & !(align - 1)
        
        if aligned_offset + size > self.size {
            return Err(AllocError.OutOfMemory)
        }
        
        let ptr = (self.memory as Int + aligned_offset) as *UInt8
        self.offset = aligned_offset + size
        Ok(ptr)
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        // Stack allocator uses markers for deallocation
        let addr = ptr as Int - self.memory as Int
        if addr + size == self.offset {
            self.offset = addr
        }
    }
}

impl Drop for StackAllocator {
    fn drop() {
        @native("deallocate_raw", self.memory, self.size)
    }
}

// -----------------------------------------------------------------------------
// Free List Allocator
// -----------------------------------------------------------------------------

/// Free list allocator with first-fit strategy
struct FreeListAllocator {
    memory: *UInt8
    size: Int
    free_list: *FreeBlock
    stats: AllocStats
    
    fn new(size: Int) -> Self {
        let memory = @native("allocate_raw", size)
        let free_block = memory as *FreeBlock
        (*free_block).size = size
        (*free_block).next = null()
        
        FreeListAllocator {
            memory: memory,
            size: size,
            free_list: free_block,
            stats: AllocStats.new()
        }
    }
    
    fn stats() -> AllocStats { self.stats }
}

struct FreeBlock {
    size: Int
    next: *FreeBlock
}

impl Allocator for FreeListAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let total_size = size + @native("size_of", FreeBlock)
        let aligned_size = (total_size + align - 1) & !(align - 1)
        
        // First-fit search
        var prev: *FreeBlock = null()
        var current = self.free_list
        
        while !current.is_null() {
            if (*current).size >= aligned_size {
                // Found suitable block
                let remaining = (*current).size - aligned_size
                
                if remaining >= @native("size_of", FreeBlock) + 16 {
                    // Split block
                    let new_block = (current as Int + aligned_size) as *FreeBlock
                    (*new_block).size = remaining
                    (*new_block).next = (*current).next
                    
                    if prev.is_null() {
                        self.free_list = new_block
                    } else {
                        (*prev).next = new_block
                    }
                } else {
                    // Use entire block
                    if prev.is_null() {
                        self.free_list = (*current).next
                    } else {
                        (*prev).next = (*current).next
                    }
                }
                
                self.stats.allocations += 1
                self.stats.bytes_allocated += aligned_size
                
                return Ok((current as Int + @native("size_of", FreeBlock)) as *UInt8)
            }
            
            prev = current
            current = (*current).next
        }
        
        self.stats.allocation_failures += 1
        Err(AllocError.OutOfMemory)
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        if ptr.is_null() { return }
        
        let block = (ptr as Int - @native("size_of", FreeBlock)) as *FreeBlock
        let total_size = size + @native("size_of", FreeBlock)
        let aligned_size = (total_size + align - 1) & !(align - 1)
        
        (*block).size = aligned_size
        (*block).next = self.free_list
        self.free_list = block
        
        self.stats.deallocations += 1
        self.stats.bytes_freed += aligned_size
        
        // Coalesce adjacent free blocks
        self.coalesce()
    }
}

impl FreeListAllocator {
    fn coalesce() {
        var current = self.free_list
        
        while !current.is_null() && !(*current).next.is_null() {
            let next = (*current).next
            let current_end = current as Int + (*current).size
            
            if current_end == next as Int {
                // Merge blocks
                (*current).size += (*next).size
                (*current).next = (*next).next
            } else {
                current = next
            }
        }
    }
}

impl Drop for FreeListAllocator {
    fn drop() {
        @native("deallocate_raw", self.memory, self.size)
    }
}

// -----------------------------------------------------------------------------
// Buddy Allocator
// -----------------------------------------------------------------------------

/// Buddy allocator for power-of-2 allocations
struct BuddyAllocator {
    memory: *UInt8
    size: Int
    min_block: Int
    max_order: Int
    free_lists: [*BuddyBlock]
    stats: AllocStats
    
    fn new(size: Int) -> Self {
        Self.with_min_block(size, 16)
    }
    
    fn with_min_block(size: Int, min_block: Int) -> Self {
        let size = next_power_of_2(size)
        let max_order = log2(size / min_block)
        
        var free_lists = []
        for _ in 0..=max_order {
            free_lists.push(null())
        }
        
        let memory = @native("allocate_raw", size)
        let block = memory as *BuddyBlock
        (*block).order = max_order
        (*block).free = true
        (*block).next = null()
        free_lists[max_order] = block
        
        BuddyAllocator {
            memory: memory,
            size: size,
            min_block: min_block,
            max_order: max_order,
            free_lists: free_lists,
            stats: AllocStats.new()
        }
    }
    
    fn block_size(order: Int) -> Int {
        self.min_block << order
    }
    
    fn order_for_size(size: Int) -> Int {
        var order = 0
        var block_size = self.min_block
        while block_size < size && order < self.max_order {
            block_size <<= 1
            order += 1
        }
        order
    }
    
    fn buddy_of(block: *BuddyBlock, order: Int) -> *BuddyBlock {
        let offset = block as Int - self.memory as Int
        let buddy_offset = offset ^ self.block_size(order)
        (self.memory as Int + buddy_offset) as *BuddyBlock
    }
    
    fn stats() -> AllocStats { self.stats }
}

struct BuddyBlock {
    order: Int
    free: Bool
    next: *BuddyBlock
}

impl Allocator for BuddyAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let total_size = size + @native("size_of", BuddyBlock)
        let order = self.order_for_size(total_size)
        
        if order > self.max_order {
            return Err(AllocError.OutOfMemory)
        }
        
        // Find free block of sufficient size
        var found_order = order
        while found_order <= self.max_order && self.free_lists[found_order].is_null() {
            found_order += 1
        }
        
        if found_order > self.max_order {
            self.stats.allocation_failures += 1
            return Err(AllocError.OutOfMemory)
        }
        
        // Remove block from free list
        let block = self.free_lists[found_order]
        self.free_lists[found_order] = (*block).next
        
        // Split block if necessary
        while found_order > order {
            found_order -= 1
            let buddy = self.buddy_of(block, found_order)
            (*buddy).order = found_order
            (*buddy).free = true
            (*buddy).next = self.free_lists[found_order]
            self.free_lists[found_order] = buddy
        }
        
        (*block).free = false
        (*block).order = order
        
        self.stats.allocations += 1
        self.stats.bytes_allocated += self.block_size(order)
        
        Ok((block as Int + @native("size_of", BuddyBlock)) as *UInt8)
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        if ptr.is_null() { return }
        
        let block = (ptr as Int - @native("size_of", BuddyBlock)) as *BuddyBlock
        var order = (*block).order
        (*block).free = true
        
        self.stats.deallocations += 1
        self.stats.bytes_freed += self.block_size(order)
        
        // Coalesce with buddy
        while order < self.max_order {
            let buddy = self.buddy_of(block, order)
            
            if !(*buddy).free || (*buddy).order != order {
                break
            }
            
            // Remove buddy from free list
            self.remove_from_free_list(buddy, order)
            
            // Merge with lower address block
            let merged = if block as Int < buddy as Int { block } else { buddy }
            order += 1
            (*merged).order = order
        }
        
        // Add to free list
        (*block).next = self.free_lists[order]
        self.free_lists[order] = block
    }
}

impl BuddyAllocator {
    fn remove_from_free_list(block: *BuddyBlock, order: Int) {
        var prev: *BuddyBlock = null()
        var current = self.free_lists[order]
        
        while !current.is_null() {
            if current == block {
                if prev.is_null() {
                    self.free_lists[order] = (*current).next
                } else {
                    (*prev).next = (*current).next
                }
                return
            }
            prev = current
            current = (*current).next
        }
    }
}

impl Drop for BuddyAllocator {
    fn drop() {
        @native("deallocate_raw", self.memory, self.size)
    }
}

// -----------------------------------------------------------------------------
// Pool Allocator
// -----------------------------------------------------------------------------

/// Pool allocator for fixed-size objects
struct PoolAllocator {
    memory: *UInt8
    size: Int
    block_size: Int
    free_list: *PoolBlock
    stats: AllocStats
    
    fn new(block_size: Int, count: Int) -> Self {
        let block_size = block_size.max(@native("size_of", PoolBlock))
        let size = block_size * count
        let memory = @native("allocate_raw", size)
        
        // Initialize free list
        var free_list: *PoolBlock = null()
        for i in (0..count).rev() {
            let block = (memory as Int + i * block_size) as *PoolBlock
            (*block).next = free_list
            free_list = block
        }
        
        PoolAllocator {
            memory: memory,
            size: size,
            block_size: block_size,
            free_list: free_list,
            stats: AllocStats.new()
        }
    }
    
    fn stats() -> AllocStats { self.stats }
}

struct PoolBlock {
    next: *PoolBlock
}

impl Allocator for PoolAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        if size > self.block_size {
            return Err(AllocError.InvalidSize)
        }
        
        if self.free_list.is_null() {
            self.stats.allocation_failures += 1
            return Err(AllocError.OutOfMemory)
        }
        
        let block = self.free_list
        self.free_list = (*block).next
        
        self.stats.allocations += 1
        self.stats.bytes_allocated += self.block_size
        
        Ok(block as *UInt8)
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        if ptr.is_null() { return }
        
        let block = ptr as *PoolBlock
        (*block).next = self.free_list
        self.free_list = block
        
        self.stats.deallocations += 1
        self.stats.bytes_freed += self.block_size
    }
}

impl Drop for PoolAllocator {
    fn drop() {
        @native("deallocate_raw", self.memory, self.size)
    }
}

// -----------------------------------------------------------------------------
// Tracking Allocator
// -----------------------------------------------------------------------------

/// Allocator that tracks all allocations
struct TrackingAllocator<A: Allocator> {
    inner: A
    allocations: Map<Int, AllocationInfo>
    stats: AllocStats
    
    fn new(inner: A) -> Self {
        TrackingAllocator {
            inner: inner,
            allocations: Map.new(),
            stats: AllocStats.new()
        }
    }
    
    fn stats() -> AllocStats { self.stats }
    
    fn allocations() -> [AllocationInfo] {
        self.allocations.values().collect()
    }
    
    fn check_leaks() -> [AllocationInfo] {
        self.allocations.values().collect()
    }
    
    fn print_leaks() {
        let leaks = self.check_leaks()
        if leaks.is_empty() {
            println("No memory leaks detected")
        } else {
            println("Memory leaks detected: \(leaks.len())")
            for leak in leaks {
                println("  \(leak.size) bytes at 0x\(leak.address.to_hex())")
            }
        }
    }
}

struct AllocationInfo {
    address: Int
    size: Int
    align: Int
    timestamp: Instant
}

impl<A: Allocator> Allocator for TrackingAllocator<A> {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        let ptr = self.inner.allocate(size, align)?
        
        self.allocations.insert(ptr as Int, AllocationInfo {
            address: ptr as Int,
            size: size,
            align: align,
            timestamp: Instant.now()
        })
        
        self.stats.allocations += 1
        self.stats.bytes_allocated += size
        
        Ok(ptr)
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        self.allocations.remove(ptr as Int)
        self.inner.deallocate(ptr, size, align)
        
        self.stats.deallocations += 1
        self.stats.bytes_freed += size
    }
}

// -----------------------------------------------------------------------------
// Fallback Allocator
// -----------------------------------------------------------------------------

/// Allocator that falls back to secondary on failure
struct FallbackAllocator<P: Allocator, S: Allocator> {
    primary: P
    secondary: S
    
    fn new(primary: P, secondary: S) -> Self {
        FallbackAllocator { primary: primary, secondary: secondary }
    }
}

impl<P: Allocator, S: Allocator> Allocator for FallbackAllocator<P, S> {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        match self.primary.allocate(size, align) {
            Ok(ptr) => Ok(ptr)
            Err(_) => self.secondary.allocate(size, align)
        }
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        // Try primary first, then secondary
        self.primary.deallocate(ptr, size, align)
    }
}

// -----------------------------------------------------------------------------
// Segregated Allocator
// -----------------------------------------------------------------------------

/// Allocator that uses different allocators for different sizes
struct SegregatedAllocator {
    small: PoolAllocator
    medium: FreeListAllocator
    large: SystemAllocator
    small_threshold: Int
    medium_threshold: Int
    
    fn new() -> Self {
        SegregatedAllocator {
            small: PoolAllocator.new(64, 1024),
            medium: FreeListAllocator.new(64 * 1024),
            large: SystemAllocator.new(),
            small_threshold: 64,
            medium_threshold: 4096
        }
    }
}

impl Allocator for SegregatedAllocator {
    fn allocate(size: Int, align: Int) -> Result<*UInt8, AllocError> {
        if size <= self.small_threshold {
            self.small.allocate(size, align)
        } else if size <= self.medium_threshold {
            self.medium.allocate(size, align)
        } else {
            self.large.allocate(size, align)
        }
    }
    
    fn deallocate(ptr: *UInt8, size: Int, align: Int) {
        if size <= self.small_threshold {
            self.small.deallocate(ptr, size, align)
        } else if size <= self.medium_threshold {
            self.medium.deallocate(ptr, size, align)
        } else {
            self.large.deallocate(ptr, size, align)
        }
    }
}

// -----------------------------------------------------------------------------
// Statistics
// -----------------------------------------------------------------------------

struct AllocStats {
    allocations: Int
    deallocations: Int
    allocation_failures: Int
    bytes_allocated: Int
    bytes_freed: Int
    
    fn new() -> Self {
        AllocStats {
            allocations: 0,
            deallocations: 0,
            allocation_failures: 0,
            bytes_allocated: 0,
            bytes_freed: 0
        }
    }
    
    fn bytes_in_use() -> Int {
        self.bytes_allocated - self.bytes_freed
    }
    
    fn print() {
        println("=== Allocator Statistics ===")
        println("Allocations:   \(self.allocations)")
        println("Deallocations: \(self.deallocations)")
        println("Failures:      \(self.allocation_failures)")
        println("Allocated:     \(format_bytes(self.bytes_allocated))")
        println("Freed:         \(format_bytes(self.bytes_freed))")
        println("In use:        \(format_bytes(self.bytes_in_use()))")
        println("============================")
    }
}

// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

fn next_power_of_2(n: Int) -> Int {
    var v = n - 1
    v |= v >> 1
    v |= v >> 2
    v |= v >> 4
    v |= v >> 8
    v |= v >> 16
    v |= v >> 32
    v + 1
}

fn log2(n: Int) -> Int {
    var result = 0
    var v = n
    while v > 1 {
        v >>= 1
        result += 1
    }
    result
}

fn format_bytes(bytes: Int) -> String {
    if bytes < 1024 { "\(bytes) B" }
    else if bytes < 1024 * 1024 { "\((bytes as Float / 1024.0).round(2)) KB" }
    else if bytes < 1024 * 1024 * 1024 { "\((bytes as Float / (1024.0 * 1024.0)).round(2)) MB" }
    else { "\((bytes as Float / (1024.0 * 1024.0 * 1024.0)).round(2)) GB" }
}

// -----------------------------------------------------------------------------
// Global Allocator
// -----------------------------------------------------------------------------

var GLOBAL_ALLOCATOR: Option<Box<dyn Allocator>> = None

fn set_global_allocator<A: Allocator>(alloc: A) {
    GLOBAL_ALLOCATOR = Some(Box.new(alloc))
}

fn global_allocator() -> &dyn Allocator {
    match GLOBAL_ALLOCATOR {
        Some(ref alloc) => alloc.as_ref(),
        None => &SystemAllocator.global()
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "bump allocator" {
    let alloc = BumpAllocator.new(1024)
    
    let ptr1 = alloc.allocate(100, 8).unwrap()
    let ptr2 = alloc.allocate(200, 8).unwrap()
    
    assert_eq(alloc.used(), 300)?
    
    alloc.reset()
    assert_eq(alloc.used(), 0)?
}

test "stack allocator" {
    let alloc = StackAllocator.new(1024)
    
    let marker = alloc.push_marker()
    let ptr1 = alloc.allocate(100, 8).unwrap()
    let ptr2 = alloc.allocate(200, 8).unwrap()
    
    alloc.pop_marker()
    assert_eq(alloc.used(), 0)?
}

test "free list allocator" {
    let alloc = FreeListAllocator.new(4096)
    
    let ptr1 = alloc.allocate(100, 8).unwrap()
    let ptr2 = alloc.allocate(200, 8).unwrap()
    
    alloc.deallocate(ptr1, 100, 8)
    
    let ptr3 = alloc.allocate(50, 8).unwrap()
    assert(!ptr3.is_null())?
}

test "buddy allocator" {
    let alloc = BuddyAllocator.new(4096)
    
    let ptr1 = alloc.allocate(100, 8).unwrap()
    let ptr2 = alloc.allocate(200, 8).unwrap()
    
    alloc.deallocate(ptr1, 100, 8)
    alloc.deallocate(ptr2, 200, 8)
}

test "pool allocator" {
    let alloc = PoolAllocator.new(64, 100)
    
    let ptr1 = alloc.allocate(32, 8).unwrap()
    let ptr2 = alloc.allocate(64, 8).unwrap()
    
    alloc.deallocate(ptr1, 32, 8)
    
    let ptr3 = alloc.allocate(32, 8).unwrap()
    assert_eq(ptr3, ptr1)?  // Should reuse freed block
}

test "tracking allocator" {
    let inner = BumpAllocator.new(1024)
    let alloc = TrackingAllocator.new(inner)
    
    let ptr = alloc.allocate(100, 8).unwrap()
    assert_eq(alloc.allocations().len(), 1)?
    
    alloc.deallocate(ptr, 100, 8)
    assert_eq(alloc.check_leaks().len(), 0)?
}
