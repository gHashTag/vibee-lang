// =============================================================================
// Vibee OS â€” Push Notification Module
// Unified push notification abstraction for all platforms
// =============================================================================

use json.{JsonValue, Serialize, Deserialize}

// =============================================================================
// Push Notification
// =============================================================================

struct PushNotification {
    id: String
    title: String
    body: String
    icon: Option<String>
    image: Option<String>
    badge: Option<Int>
    sound: Option<String>
    tag: Option<String>
    data: Map<String, JsonValue>
    actions: [NotificationAction]
    priority: NotificationPriority
    ttl: Duration
    collapse_key: Option<String>
    channel_id: Option<String>
    category: Option<String>
    thread_id: Option<String>
    created_at: Instant
}

impl PushNotification {
    fn new(title: String, body: String) -> Self {
        PushNotification {
            id: UUID.v4(),
            title: title,
            body: body,
            icon: None,
            image: None,
            badge: None,
            sound: None,
            tag: None,
            data: Map.empty(),
            actions: [],
            priority: NotificationPriority.Normal,
            ttl: Duration.from_hours(24),
            collapse_key: None,
            channel_id: None,
            category: None,
            thread_id: None,
            created_at: Instant.now()
        }
    }
    
    fn icon(url: String) -> Self { self.icon = Some(url); self }
    fn image(url: String) -> Self { self.image = Some(url); self }
    fn badge(count: Int) -> Self { self.badge = Some(count); self }
    fn sound(name: String) -> Self { self.sound = Some(name); self }
    fn sound_default() -> Self { self.sound = Some("default"); self }
    fn tag(t: String) -> Self { self.tag = Some(t); self }
    fn data(key: String, value: JsonValue) -> Self { self.data.set(key, value); self }
    fn data_string(key: String, value: String) -> Self { self.data.set(key, JsonValue.string(value)); self }
    fn action(id: String, title: String) -> Self {
        self.actions.push(NotificationAction { id: id, title: title, icon: None }); self
    }
    fn priority(p: NotificationPriority) -> Self { self.priority = p; self }
    fn ttl(duration: Duration) -> Self { self.ttl = duration; self }
    fn collapse_key(key: String) -> Self { self.collapse_key = Some(key); self }
    fn channel_id(id: String) -> Self { self.channel_id = Some(id); self }
    fn category(cat: String) -> Self { self.category = Some(cat); self }
    fn thread_id(id: String) -> Self { self.thread_id = Some(id); self }
    
    fn silent() -> SilentNotification {
        SilentNotification { data: self.data.clone(), ttl: self.ttl, priority: NotificationPriority.Normal }
    }
}

struct NotificationAction {
    id: String
    title: String
    icon: Option<String>
}

enum NotificationPriority { Low, Normal, High, Critical }

// =============================================================================
// Silent Notification
// =============================================================================

struct SilentNotification {
    data: Map<String, JsonValue>
    ttl: Duration
    priority: NotificationPriority
}

impl SilentNotification {
    fn new() -> Self {
        SilentNotification { data: Map.empty(), ttl: Duration.from_hours(24), priority: NotificationPriority.Normal }
    }
    
    fn data(key: String, value: JsonValue) -> Self { self.data.set(key, value); self }
    fn ttl(duration: Duration) -> Self { self.ttl = duration; self }
    fn priority(p: NotificationPriority) -> Self { self.priority = p; self }
}

// =============================================================================
// Push Provider Trait
// =============================================================================

trait PushProvider {
    fn name() -> String
    fn send(token: String, notification: PushNotification) -> Result<PushResult, PushError>
    fn send_silent(token: String, data: Map<String, JsonValue>) -> Result<PushResult, PushError>
    fn send_batch(tokens: [String], notification: PushNotification) -> BatchResult
}

// =============================================================================
// Push Service
// =============================================================================

struct PushService {
    providers: Map<Platform, Box<dyn PushProvider>>
    default_ttl: Duration
    retry_count: Int
}

enum Platform { Android, iOS, Web, All }

impl PushService {
    fn new() -> Self {
        PushService { providers: Map.empty(), default_ttl: Duration.from_hours(24), retry_count: 3 }
    }
    
    fn register(platform: Platform, provider: Box<dyn PushProvider>) -> Self {
        self.providers.set(platform, provider); self
    }
    
    fn send(target: PushTarget, notification: PushNotification) -> Result<PushResult, PushError> {
        let provider = self.providers.get(target.platform)
            .ok_or(PushError.ProviderNotFound(target.platform))?
        
        var last_error: Option<PushError> = None
        for _ in 0..self.retry_count {
            match provider.send(target.token.clone(), notification.clone()) {
                Ok(result) => return Ok(result),
                Err(e) if e.is_retryable() => { last_error = Some(e); continue },
                Err(e) => return Err(e)
            }
        }
        Err(last_error.unwrap_or(PushError.Unknown))
    }
    
    fn send_to_user(user_id: String, notification: PushNotification, registry: DeviceRegistry) -> BatchResult {
        let devices = registry.get_devices(user_id)
        self.send_to_devices(devices, notification)
    }
    
    fn send_to_devices(devices: [DeviceInfo], notification: PushNotification) -> BatchResult {
        let mut results = []
        let mut success = 0
        let mut failure = 0
        
        for device in devices {
            let target = PushTarget { token: device.token.clone(), platform: device.platform }
            match self.send(target, notification.clone()) {
                Ok(r) => { success += 1; results.push(SendResult.success(device.token, r.message_id)) },
                Err(e) => { failure += 1; results.push(SendResult.failure(device.token, e)) }
            }
        }
        
        BatchResult { results: results, success_count: success, failure_count: failure }
    }
    
    fn broadcast(notification: PushNotification, registry: DeviceRegistry) -> BatchResult {
        self.send_to_devices(registry.all_devices(), notification)
    }
}

struct PushTarget {
    token: String
    platform: Platform
}

// =============================================================================
// Device Registry
// =============================================================================

actor DeviceRegistry {
    state devices: Map<String, DeviceInfo>
    state user_devices: Map<String, [String]>
    
    fn new() -> Self {
        DeviceRegistry { devices: Map.empty(), user_devices: Map.empty() }
    }
    
    on register(user_id: String, device: DeviceInfo) {
        self.devices.set(device.token.clone(), device.clone())
        let mut tokens = self.user_devices.get(user_id.clone()).unwrap_or([])
        if !tokens.contains(device.token.clone()) {
            tokens.push(device.token)
            self.user_devices.set(user_id, tokens)
        }
    }
    
    on unregister(token: String) {
        self.devices.remove(token.clone())
        for (_, tokens) in self.user_devices.iter_mut() {
            tokens.retain(|t| *t != token)
        }
    }
    
    fn get_devices(user_id: String) -> [DeviceInfo] {
        self.user_devices.get(user_id).unwrap_or([])
            .iter().filter_map(|t| self.devices.get(t.clone())).collect()
    }
    
    fn all_devices() -> [DeviceInfo] { self.devices.values().collect() }
}

struct DeviceInfo {
    token: String
    platform: Platform
    user_id: String
    app_version: Option<String>
    os_version: Option<String>
    device_model: Option<String>
    registered_at: Instant
    last_active: Instant
}

impl DeviceInfo {
    fn new(token: String, platform: Platform, user_id: String) -> Self {
        DeviceInfo {
            token: token, platform: platform, user_id: user_id,
            app_version: None, os_version: None, device_model: None,
            registered_at: Instant.now(), last_active: Instant.now()
        }
    }
}

// =============================================================================
// Results
// =============================================================================

struct PushResult {
    message_id: String
    success: Bool
}

struct BatchResult {
    results: [SendResult]
    success_count: Int
    failure_count: Int
}

impl BatchResult {
    fn success_rate() -> Float {
        let total = self.success_count + self.failure_count
        if total == 0 { 0.0 } else { self.success_count as Float / total as Float }
    }
    
    fn failed_tokens() -> [String] {
        self.results.filter(|r| !r.success).map(|r| r.token.clone()).collect()
    }
}

struct SendResult {
    token: String
    success: Bool
    message_id: Option<String>
    error: Option<PushError>
}

impl SendResult {
    fn success(token: String, message_id: String) -> Self {
        SendResult { token: token, success: true, message_id: Some(message_id), error: None }
    }
    fn failure(token: String, error: PushError) -> Self {
        SendResult { token: token, success: false, message_id: None, error: Some(error) }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum PushError {
    InvalidToken(String)
    ProviderNotFound(Platform)
    NetworkError(String)
    RateLimited
    PayloadTooLarge
    ServerError(String)
    Timeout
    Unknown
}

impl PushError {
    fn is_retryable() -> Bool {
        match self {
            .NetworkError(_) | .RateLimited | .ServerError(_) | .Timeout => true,
            _ => false
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "push notification creation" {
    let notification = PushNotification.new("Hello", "World")
        .icon("/icon.png")
        .badge(5)
        .sound_default()
        .action("view", "View")
    
    assert_eq(notification.title, "Hello")?
    assert_eq(notification.badge, Some(5))?
    assert_eq(notification.actions.len(), 1)?
}

test "batch result" {
    let batch = BatchResult {
        results: [SendResult.success("t1", "m1"), SendResult.failure("t2", PushError.InvalidToken("bad"))],
        success_count: 1, failure_count: 1
    }
    assert_eq(batch.success_rate(), 0.5)?
    assert_eq(batch.failed_tokens(), ["t2"])?
}

test "device info" {
    let device = DeviceInfo.new("token123", Platform.iOS, "user1")
    assert_eq(device.platform, Platform.iOS)?
}
