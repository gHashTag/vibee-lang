// =============================================================================
// Vibee OS â€” Semver Module
// Semantic versioning (SemVer 2.0.0)
// =============================================================================

/// Semantic version
struct Version {
    major: Int
    minor: Int
    patch: Int
    prerelease: [String]
    build: [String]
    
    /// Create new version
    fn new(major: Int, minor: Int, patch: Int) -> Self {
        Version { major: major, minor: minor, patch: patch, prerelease: [], build: [] }
    }
    
    /// Parse version string
    fn parse(s: String) -> Result<Self, SemverError> {
        let s = s.trim().trim_start("v").trim_start("V")
        
        // Split build metadata
        let (version_pre, build) = match s.split_once("+") {
            Some((v, b)) => (v, b.split(".").collect())
            None => (s, [])
        }
        
        // Split prerelease
        let (version, prerelease) = match version_pre.split_once("-") {
            Some((v, p)) => (v, p.split(".").collect())
            None => (version_pre, [])
        }
        
        // Parse major.minor.patch
        let parts = version.split(".")
        if parts.len() < 1 || parts.len() > 3 {
            return Err(SemverError.InvalidFormat)
        }
        
        let major = Int.parse(parts[0]).map_err(|_| SemverError.InvalidNumber)?
        let minor = parts.get(1).map(|s| Int.parse(s)).transpose()
            .map_err(|_| SemverError.InvalidNumber)?.unwrap_or(0)
        let patch = parts.get(2).map(|s| Int.parse(s)).transpose()
            .map_err(|_| SemverError.InvalidNumber)?.unwrap_or(0)
        
        if major < 0 || minor < 0 || patch < 0 {
            return Err(SemverError.NegativeNumber)
        }
        
        // Validate prerelease identifiers
        for id in prerelease {
            if id.is_empty() {
                return Err(SemverError.EmptyIdentifier)
            }
            if id.chars().all(|c| c.is_digit()) && id.len() > 1 && id.starts_with("0") {
                return Err(SemverError.LeadingZero)
            }
        }
        
        Ok(Version { major: major, minor: minor, patch: patch, prerelease: prerelease, build: build })
    }
    
    /// Create with prerelease
    fn with_prerelease(self, pre: [String]) -> Self {
        Version { prerelease: pre, ..self }
    }
    
    /// Create with build metadata
    fn with_build(self, build: [String]) -> Self {
        Version { build: build, ..self }
    }
    
    /// Increment major version
    fn inc_major() -> Self {
        Version { major: self.major + 1, minor: 0, patch: 0, prerelease: [], build: [] }
    }
    
    /// Increment minor version
    fn inc_minor() -> Self {
        Version { major: self.major, minor: self.minor + 1, patch: 0, prerelease: [], build: [] }
    }
    
    /// Increment patch version
    fn inc_patch() -> Self {
        Version { major: self.major, minor: self.minor, patch: self.patch + 1, prerelease: [], build: [] }
    }
    
    /// Check if prerelease
    fn is_prerelease() -> Bool {
        !self.prerelease.is_empty()
    }
    
    /// Check if stable (>= 1.0.0)
    fn is_stable() -> Bool {
        self.major >= 1 && self.prerelease.is_empty()
    }
    
    /// Convert to string
    fn to_string() -> String {
        var s = format!("{}.{}.{}", self.major, self.minor, self.patch)
        if !self.prerelease.is_empty() {
            s.push_str("-")
            s.push_str(self.prerelease.join("."))
        }
        if !self.build.is_empty() {
            s.push_str("+")
            s.push_str(self.build.join("."))
        }
        s
    }
}

impl Eq for Version {
    fn eq(other: Version) -> Bool {
        // Build metadata is ignored in equality
        self.major == other.major &&
        self.minor == other.minor &&
        self.patch == other.patch &&
        self.prerelease == other.prerelease
    }
}

impl Ord for Version {
    fn cmp(other: Version) -> Ordering {
        // Compare major.minor.patch
        match self.major.cmp(other.major) {
            Ordering.Equal => {}
            ord => return ord
        }
        match self.minor.cmp(other.minor) {
            Ordering.Equal => {}
            ord => return ord
        }
        match self.patch.cmp(other.patch) {
            Ordering.Equal => {}
            ord => return ord
        }
        
        // Prerelease has lower precedence than normal
        match (self.prerelease.is_empty(), other.prerelease.is_empty()) {
            (true, false) => return Ordering.Greater
            (false, true) => return Ordering.Less
            (true, true) => return Ordering.Equal
            _ => {}
        }
        
        // Compare prerelease identifiers
        let len = self.prerelease.len().min(other.prerelease.len())
        for i in 0..len {
            let a = self.prerelease[i]
            let b = other.prerelease[i]
            
            let a_num = Int.parse(a).ok()
            let b_num = Int.parse(b).ok()
            
            match (a_num, b_num) {
                (Some(an), Some(bn)) => {
                    match an.cmp(bn) {
                        Ordering.Equal => continue
                        ord => return ord
                    }
                }
                (Some(_), None) => return Ordering.Less
                (None, Some(_)) => return Ordering.Greater
                (None, None) => {
                    match a.cmp(b) {
                        Ordering.Equal => continue
                        ord => return ord
                    }
                }
            }
        }
        
        self.prerelease.len().cmp(other.prerelease.len())
    }
}

impl Display for Version {
    fn fmt(f: Formatter) {
        f.write(self.to_string())
    }
}

// -----------------------------------------------------------------------------
// Version Range
// -----------------------------------------------------------------------------

/// Version requirement/range
enum VersionReq {
    Exact(Version)
    Greater(Version)
    GreaterEq(Version)
    Less(Version)
    LessEq(Version)
    Caret(Version)      // ^1.2.3 - compatible with
    Tilde(Version)      // ~1.2.3 - approximately equivalent
    Wildcard(Int, Option<Int>)  // 1.* or 1.2.*
    Range(Version, Version)     // >=1.0.0 <2.0.0
    And([VersionReq])
    Or([VersionReq])
    Any
}

impl VersionReq {
    /// Parse version requirement
    fn parse(s: String) -> Result<Self, SemverError> {
        let s = s.trim()
        
        if s == "*" || s.is_empty() {
            return Ok(VersionReq.Any)
        }
        
        // Handle OR (||)
        if s.contains("||") {
            let parts = s.split("||").map(|p| VersionReq.parse(p.trim())).collect::<Result<_, _>>()?
            return Ok(VersionReq.Or(parts))
        }
        
        // Handle AND (space or comma)
        if s.contains(" ") && !s.starts_with(">=") && !s.starts_with("<=") {
            let parts = s.split_whitespace()
                .filter(|p| !p.is_empty())
                .map(|p| VersionReq.parse(p))
                .collect::<Result<_, _>>()?
            if parts.len() > 1 {
                return Ok(VersionReq.And(parts))
            }
        }
        
        // Handle operators
        if s.starts_with("^") {
            let v = Version.parse(s[1..])?
            return Ok(VersionReq.Caret(v))
        }
        if s.starts_with("~") {
            let v = Version.parse(s[1..])?
            return Ok(VersionReq.Tilde(v))
        }
        if s.starts_with(">=") {
            let v = Version.parse(s[2..].trim())?
            return Ok(VersionReq.GreaterEq(v))
        }
        if s.starts_with("<=") {
            let v = Version.parse(s[2..].trim())?
            return Ok(VersionReq.LessEq(v))
        }
        if s.starts_with(">") {
            let v = Version.parse(s[1..].trim())?
            return Ok(VersionReq.Greater(v))
        }
        if s.starts_with("<") {
            let v = Version.parse(s[1..].trim())?
            return Ok(VersionReq.Less(v))
        }
        if s.starts_with("=") {
            let v = Version.parse(s[1..].trim())?
            return Ok(VersionReq.Exact(v))
        }
        
        // Handle wildcards
        if s.contains("*") || s.contains("x") || s.contains("X") {
            let parts = s.split(".")
            let major = Int.parse(parts[0]).map_err(|_| SemverError.InvalidNumber)?
            let minor = parts.get(1).and_then(|p| {
                if p == "*" || p == "x" || p == "X" { None }
                else { Int.parse(p).ok() }
            })
            return Ok(VersionReq.Wildcard(major, minor))
        }
        
        // Exact version
        let v = Version.parse(s)?
        Ok(VersionReq.Exact(v))
    }
    
    /// Check if version matches requirement
    fn matches(version: Version) -> Bool {
        match self {
            Any => true
            Exact(v) => version == v
            Greater(v) => version > v
            GreaterEq(v) => version >= v
            Less(v) => version < v
            LessEq(v) => version <= v
            
            Caret(v) => {
                // ^1.2.3 := >=1.2.3 <2.0.0
                // ^0.2.3 := >=0.2.3 <0.3.0
                // ^0.0.3 := >=0.0.3 <0.0.4
                if version < v { return false }
                if v.major == 0 {
                    if v.minor == 0 {
                        version.major == 0 && version.minor == 0 && version.patch == v.patch
                    } else {
                        version.major == 0 && version.minor == v.minor
                    }
                } else {
                    version.major == v.major
                }
            }
            
            Tilde(v) => {
                // ~1.2.3 := >=1.2.3 <1.3.0
                version >= v && version.major == v.major && version.minor == v.minor
            }
            
            Wildcard(major, minor) => {
                if version.major != major { return false }
                match minor {
                    Some(m) => version.minor == m
                    None => true
                }
            }
            
            Range(min, max) => version >= min && version < max
            And(reqs) => reqs.iter().all(|r| r.matches(version))
            Or(reqs) => reqs.iter().any(|r| r.matches(version))
        }
    }
    
    fn to_string() -> String {
        match self {
            Any => "*"
            Exact(v) => v.to_string()
            Greater(v) => format!(">{}", v)
            GreaterEq(v) => format!(">={}", v)
            Less(v) => format!("<{}", v)
            LessEq(v) => format!("<={}", v)
            Caret(v) => format!("^{}", v)
            Tilde(v) => format!("~{}", v)
            Wildcard(major, Some(minor)) => format!("{}.{}.*", major, minor)
            Wildcard(major, None) => format!("{}.*", major)
            Range(min, max) => format!(">={} <{}", min, max)
            And(reqs) => reqs.iter().map(|r| r.to_string()).join(" ")
            Or(reqs) => reqs.iter().map(|r| r.to_string()).join(" || ")
        }
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum SemverError {
    InvalidFormat
    InvalidNumber
    NegativeNumber
    EmptyIdentifier
    LeadingZero
}

impl Display for SemverError {
    fn fmt(f: Formatter) {
        match self {
            InvalidFormat => f.write("Invalid version format")
            InvalidNumber => f.write("Invalid number in version")
            NegativeNumber => f.write("Negative numbers not allowed")
            EmptyIdentifier => f.write("Empty identifier")
            LeadingZero => f.write("Leading zeros not allowed in numeric identifiers")
        }
    }
}

// -----------------------------------------------------------------------------
// Utility Functions
// -----------------------------------------------------------------------------

/// Parse version string
fn parse(s: String) -> Result<Version, SemverError> {
    Version.parse(s)
}

/// Check if version satisfies requirement
fn satisfies(version: String, requirement: String) -> Result<Bool, SemverError> {
    let v = Version.parse(version)?
    let req = VersionReq.parse(requirement)?
    Ok(req.matches(v))
}

/// Find maximum version satisfying requirement
fn max_satisfying(versions: [String], requirement: String) -> Option<Version> {
    let req = VersionReq.parse(requirement).ok()?
    versions.iter()
        .filter_map(|s| Version.parse(s).ok())
        .filter(|v| req.matches(v))
        .max()
}

/// Find minimum version satisfying requirement
fn min_satisfying(versions: [String], requirement: String) -> Option<Version> {
    let req = VersionReq.parse(requirement).ok()?
    versions.iter()
        .filter_map(|s| Version.parse(s).ok())
        .filter(|v| req.matches(v))
        .min()
}

/// Sort versions
fn sort(versions: [String]) -> [Version] {
    versions.iter()
        .filter_map(|s| Version.parse(s).ok())
        .sorted()
        .collect()
}

/// Compare two versions
fn compare(a: String, b: String) -> Result<Ordering, SemverError> {
    let va = Version.parse(a)?
    let vb = Version.parse(b)?
    Ok(va.cmp(vb))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse version" {
    let v = Version.parse("1.2.3")?
    assert_eq(v.major, 1)?
    assert_eq(v.minor, 2)?
    assert_eq(v.patch, 3)?
}

test "parse with prerelease" {
    let v = Version.parse("1.0.0-alpha.1")?
    assert_eq(v.prerelease, ["alpha", "1"])?
}

test "parse with build" {
    let v = Version.parse("1.0.0+build.123")?
    assert_eq(v.build, ["build", "123"])?
}

test "version comparison" {
    assert(Version.parse("1.0.0")? < Version.parse("2.0.0")?)?
    assert(Version.parse("1.0.0")? < Version.parse("1.1.0")?)?
    assert(Version.parse("1.0.0")? < Version.parse("1.0.1")?)?
    assert(Version.parse("1.0.0-alpha")? < Version.parse("1.0.0")?)?
    assert(Version.parse("1.0.0-alpha")? < Version.parse("1.0.0-beta")?)?
}

test "increment" {
    let v = Version.new(1, 2, 3)
    assert_eq(v.inc_major(), Version.new(2, 0, 0))?
    assert_eq(v.inc_minor(), Version.new(1, 3, 0))?
    assert_eq(v.inc_patch(), Version.new(1, 2, 4))?
}

test "caret requirement" {
    let req = VersionReq.parse("^1.2.3")?
    assert(req.matches(Version.parse("1.2.3")?))?
    assert(req.matches(Version.parse("1.9.9")?))?
    assert(!req.matches(Version.parse("2.0.0")?))?
    assert(!req.matches(Version.parse("1.2.2")?))?
}

test "tilde requirement" {
    let req = VersionReq.parse("~1.2.3")?
    assert(req.matches(Version.parse("1.2.3")?))?
    assert(req.matches(Version.parse("1.2.9")?))?
    assert(!req.matches(Version.parse("1.3.0")?))?
}

test "wildcard requirement" {
    let req = VersionReq.parse("1.*")?
    assert(req.matches(Version.parse("1.0.0")?))?
    assert(req.matches(Version.parse("1.9.9")?))?
    assert(!req.matches(Version.parse("2.0.0")?))?
}
