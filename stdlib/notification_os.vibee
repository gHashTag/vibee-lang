// =============================================================================
// Vibee OS â€” OS Notification Module
// Native operating system notifications (desktop notifications)
// =============================================================================

use image.{Image, ImageFormat}
use datetime.{DateTime, Duration}

// =============================================================================
// Notification Urgency
// =============================================================================

enum NotificationUrgency {
    Low,
    Normal,
    Critical
    
    fn to_int() -> Int {
        match self {
            .Low => 0,
            .Normal => 1,
            .Critical => 2
        }
    }
}

// =============================================================================
// Notification Category
// =============================================================================

enum NotificationCategory {
    // Communication
    Email,
    EmailArrived,
    InstantMessage,
    Call,
    CallMissed,
    Voicemail,
    
    // Social
    SocialNetwork,
    SocialNetworkMessage,
    
    // System
    DeviceAdded,
    DeviceRemoved,
    DeviceError,
    NetworkConnected,
    NetworkDisconnected,
    NetworkError,
    BatteryLow,
    BatteryCritical,
    
    // Transfer
    TransferComplete,
    TransferError,
    
    // Updates
    SoftwareUpdate,
    SecurityUpdate,
    
    // Media
    MediaPlayback,
    MediaPaused,
    
    // Reminders
    Reminder,
    Alarm,
    Event,
    
    // Custom
    Custom(String)
    
    fn hint_name() -> String {
        match self {
            .Email => "email",
            .EmailArrived => "email.arrived",
            .InstantMessage => "im",
            .Call => "call",
            .CallMissed => "call.missed",
            .Voicemail => "voicemail",
            .SocialNetwork => "social",
            .SocialNetworkMessage => "social.message",
            .DeviceAdded => "device.added",
            .DeviceRemoved => "device.removed",
            .DeviceError => "device.error",
            .NetworkConnected => "network.connected",
            .NetworkDisconnected => "network.disconnected",
            .NetworkError => "network.error",
            .BatteryLow => "battery.low",
            .BatteryCritical => "battery.critical",
            .TransferComplete => "transfer.complete",
            .TransferError => "transfer.error",
            .SoftwareUpdate => "software.update",
            .SecurityUpdate => "security.update",
            .MediaPlayback => "media.playback",
            .MediaPaused => "media.paused",
            .Reminder => "reminder",
            .Alarm => "alarm",
            .Event => "event",
            .Custom(name) => name
        }
    }
}

// =============================================================================
// Notification Action
// =============================================================================

struct NotificationAction {
    id: String
    label: String
    icon: Option<String>
    is_default: Bool
    callback: Option<fn()>
}

impl NotificationAction {
    fn new(id: String, label: String) -> Self {
        NotificationAction {
            id: id,
            label: label,
            icon: None,
            is_default: false,
            callback: None
        }
    }
    
    fn icon(path: String) -> Self { self.icon = Some(path); self }
    fn default() -> Self { self.is_default = true; self }
    fn on_click(cb: fn()) -> Self { self.callback = Some(cb); self }
}

// =============================================================================
// Notification Hint
// =============================================================================

enum NotificationHint {
    ActionIcons(Bool),
    Category(String),
    DesktopEntry(String),
    ImageData(Image),
    ImagePath(String),
    Resident(Bool),
    SoundFile(String),
    SoundName(String),
    SuppressSound(Bool),
    Transient(Bool),
    Urgency(NotificationUrgency),
    X(Int),
    Y(Int),
    Custom { key: String, value: String }
}

impl NotificationHint {
    fn key() -> String {
        match self {
            .ActionIcons(_) => "action-icons",
            .Category(_) => "category",
            .DesktopEntry(_) => "desktop-entry",
            .ImageData(_) => "image-data",
            .ImagePath(_) => "image-path",
            .Resident(_) => "resident",
            .SoundFile(_) => "sound-file",
            .SoundName(_) => "sound-name",
            .SuppressSound(_) => "suppress-sound",
            .Transient(_) => "transient",
            .Urgency(_) => "urgency",
            .X(_) => "x",
            .Y(_) => "y",
            .Custom { key, .. } => key
        }
    }
}

// =============================================================================
// OS Notification
// =============================================================================

struct OSNotification {
    id: Option<Int>
    app_name: String
    replaces_id: Option<Int>
    icon: NotificationIcon
    title: String
    body: String
    actions: [NotificationAction]
    hints: [NotificationHint]
    timeout: NotificationTimeout
    category: Option<NotificationCategory>
    urgency: NotificationUrgency
    sound: Option<NotificationSound>
    on_click: Option<fn()>
    on_close: Option<fn(CloseReason)>
}

enum NotificationIcon {
    None,
    Path(String),
    Name(String),  // System icon name
    Image(Image),
    Url(String)
}

enum NotificationTimeout {
    Default,
    Never,
    Milliseconds(Int)
}

impl NotificationTimeout {
    fn to_ms() -> Int {
        match self {
            .Default => -1,
            .Never => 0,
            .Milliseconds(ms) => ms
        }
    }
    
    fn seconds(s: Int) -> Self {
        NotificationTimeout.Milliseconds(s * 1000)
    }
}

struct NotificationSound {
    name: Option<String>
    file: Option<String>
    suppress: Bool
}

impl NotificationSound {
    fn default() -> Self {
        NotificationSound { name: Some("message"), file: None, suppress: false }
    }
    
    fn named(name: String) -> Self {
        NotificationSound { name: Some(name), file: None, suppress: false }
    }
    
    fn file(path: String) -> Self {
        NotificationSound { name: None, file: Some(path), suppress: false }
    }
    
    fn silent() -> Self {
        NotificationSound { name: None, file: None, suppress: true }
    }
}

impl OSNotification {
    fn new(title: String, body: String) -> Self {
        OSNotification {
            id: None,
            app_name: @native("app_name"),
            replaces_id: None,
            icon: NotificationIcon.None,
            title: title,
            body: body,
            actions: [],
            hints: [],
            timeout: NotificationTimeout.Default,
            category: None,
            urgency: NotificationUrgency.Normal,
            sound: None,
            on_click: None,
            on_close: None
        }
    }
    
    fn simple(title: String, body: String) -> Self {
        OSNotification.new(title, body)
    }
    
    // --- Builder Methods ---
    
    fn app_name(name: String) -> Self { self.app_name = name; self }
    fn replaces(id: Int) -> Self { self.replaces_id = Some(id); self }
    
    fn icon_path(path: String) -> Self { 
        self.icon = NotificationIcon.Path(path); self 
    }
    fn icon_name(name: String) -> Self { 
        self.icon = NotificationIcon.Name(name); self 
    }
    fn icon_image(img: Image) -> Self { 
        self.icon = NotificationIcon.Image(img); self 
    }
    fn icon_url(url: String) -> Self {
        self.icon = NotificationIcon.Url(url); self
    }
    
    fn title(t: String) -> Self { self.title = t; self }
    fn body(b: String) -> Self { self.body = b; self }
    fn subtitle(s: String) -> Self { 
        self.body = f"{s}\n{self.body}"; self 
    }
    
    fn action(id: String, label: String) -> Self {
        self.actions.push(NotificationAction.new(id, label)); self
    }
    
    fn action_with_callback(id: String, label: String, callback: fn()) -> Self {
        self.actions.push(NotificationAction.new(id, label).on_click(callback)); self
    }
    
    fn default_action(label: String, callback: fn()) -> Self {
        self.actions.push(NotificationAction.new("default", label).default().on_click(callback)); self
    }
    
    fn hint(h: NotificationHint) -> Self { self.hints.push(h); self }
    
    fn timeout(t: NotificationTimeout) -> Self { self.timeout = t; self }
    fn timeout_seconds(s: Int) -> Self { 
        self.timeout = NotificationTimeout.seconds(s); self 
    }
    fn persistent() -> Self { self.timeout = NotificationTimeout.Never; self }
    
    fn category(c: NotificationCategory) -> Self { 
        self.category = Some(c); 
        self.hints.push(NotificationHint.Category(c.hint_name()));
        self 
    }
    
    fn urgency(u: NotificationUrgency) -> Self { 
        self.urgency = u;
        self.hints.push(NotificationHint.Urgency(u));
        self 
    }
    fn low_urgency() -> Self { self.urgency(NotificationUrgency.Low) }
    fn normal_urgency() -> Self { self.urgency(NotificationUrgency.Normal) }
    fn critical() -> Self { self.urgency(NotificationUrgency.Critical) }
    
    fn sound(s: NotificationSound) -> Self { self.sound = Some(s); self }
    fn sound_name(name: String) -> Self { 
        self.sound = Some(NotificationSound.named(name)); self 
    }
    fn sound_file(path: String) -> Self { 
        self.sound = Some(NotificationSound.file(path)); self 
    }
    fn silent() -> Self { 
        self.sound = Some(NotificationSound.silent()); 
        self.hints.push(NotificationHint.SuppressSound(true));
        self 
    }
    
    fn transient() -> Self { 
        self.hints.push(NotificationHint.Transient(true)); self 
    }
    fn resident() -> Self { 
        self.hints.push(NotificationHint.Resident(true)); self 
    }
    
    fn position(x: Int, y: Int) -> Self {
        self.hints.push(NotificationHint.X(x));
        self.hints.push(NotificationHint.Y(y));
        self
    }
    
    fn on_click(callback: fn()) -> Self { self.on_click = Some(callback); self }
    fn on_close(callback: fn(CloseReason)) -> Self { self.on_close = Some(callback); self }
    
    // --- Show ---
    
    fn show() -> Result<Int, NotificationError> {
        @native("notification_show", self)
    }
    
    fn show_and_wait() -> Result<NotificationResult, NotificationError> {
        let id = self.show()?;
        @native("notification_wait", id)
    }
}

// =============================================================================
// Close Reason
// =============================================================================

enum CloseReason {
    Expired,
    Dismissed,
    ActionInvoked(String),
    Closed,
    Unknown
}

// =============================================================================
// Notification Result
// =============================================================================

struct NotificationResult {
    id: Int
    action_invoked: Option<String>
    close_reason: CloseReason
    duration_shown: Duration
}

impl NotificationResult {
    fn was_clicked() -> Bool {
        match self.close_reason {
            CloseReason.ActionInvoked(_) => true,
            _ => false
        }
    }
    
    fn was_dismissed() -> Bool {
        match self.close_reason {
            CloseReason.Dismissed => true,
            _ => false
        }
    }
    
    fn was_expired() -> Bool {
        match self.close_reason {
            CloseReason.Expired => true,
            _ => false
        }
    }
}

// =============================================================================
// Notification Manager Actor
// =============================================================================

actor NotificationManager {
    state active_notifications: Map<Int, OSNotification>
    state history: [NotificationHistoryEntry]
    state max_history: Int
    state settings: NotificationSettings
    state action_handlers: Map<Int, Map<String, fn()>>
    state server_capabilities: [String]
    
    fn new() -> Self {
        NotificationManager {
            active_notifications: Map.empty(),
            history: [],
            max_history: 100,
            settings: NotificationSettings.default(),
            action_handlers: Map.empty(),
            server_capabilities: []
        }
    }
    
    fn with_settings(settings: NotificationSettings) -> Self {
        let mut mgr = NotificationManager.new();
        mgr.settings = settings;
        mgr.max_history = settings.max_history;
        mgr
    }
    
    // --- Initialization ---
    
    on init() -> Result<(), NotificationError> {
        self.server_capabilities = @native("notification_get_capabilities")?;
        Ok(())
    }
    
    fn capabilities() -> [String] {
        self.server_capabilities.clone()
    }
    
    fn supports(capability: String) -> Bool {
        self.server_capabilities.contains(capability)
    }
    
    fn supports_actions() -> Bool { self.supports("actions") }
    fn supports_body_markup() -> Bool { self.supports("body-markup") }
    fn supports_body_images() -> Bool { self.supports("body-images") }
    fn supports_persistence() -> Bool { self.supports("persistence") }
    fn supports_sound() -> Bool { self.supports("sound") }
    
    // --- Show Notifications ---
    
    on show(notification: OSNotification) -> Result<Int, NotificationError> {
        // Check if notifications are enabled
        if !self.settings.enabled {
            return Err(NotificationError.Disabled)
        }
        
        // Check Do Not Disturb
        if self.settings.do_not_disturb && notification.urgency != NotificationUrgency.Critical {
            return Err(NotificationError.DoNotDisturb)
        }
        
        // Show notification
        let id = notification.show()?;
        
        // Store active notification
        let mut notif = notification.clone();
        notif.id = Some(id);
        self.active_notifications.set(id, notif.clone());
        
        // Store action handlers
        if !notification.actions.is_empty() {
            let mut handlers: Map<String, fn()> = Map.empty();
            for action in notification.actions.iter() {
                if let Some(cb) = action.callback {
                    handlers.set(action.id.clone(), cb);
                }
            }
            self.action_handlers.set(id, handlers);
        }
        
        // Add to history
        self.add_to_history(notif, id);
        
        Ok(id)
    }
    
    on show_simple(title: String, body: String) -> Result<Int, NotificationError> {
        self.show(OSNotification.new(title, body))
    }
    
    on show_with_icon(title: String, body: String, icon: String) -> Result<Int, NotificationError> {
        self.show(OSNotification.new(title, body).icon_path(icon))
    }
    
    // --- Close Notifications ---
    
    on close(id: Int) -> Result<(), NotificationError> {
        @native("notification_close", id)?;
        self.active_notifications.remove(id);
        self.action_handlers.remove(id);
        Ok(())
    }
    
    on close_all() {
        for (id, _) in self.active_notifications.iter() {
            @native("notification_close", *id);
        }
        self.active_notifications.clear();
        self.action_handlers.clear();
    }
    
    // --- Event Handling ---
    
    on handle_action(id: Int, action_id: String) {
        if let Some(handlers) = self.action_handlers.get(id) {
            if let Some(handler) = handlers.get(action_id) {
                handler();
            }
        }
        
        // Also check notification's on_click
        if action_id == "default" {
            if let Some(notif) = self.active_notifications.get(id) {
                if let Some(cb) = notif.on_click {
                    cb();
                }
            }
        }
    }
    
    on handle_close(id: Int, reason: CloseReason) {
        if let Some(notif) = self.active_notifications.get(id) {
            if let Some(cb) = notif.on_close {
                cb(reason);
            }
        }
        
        self.active_notifications.remove(id);
        self.action_handlers.remove(id);
    }
    
    // --- History ---
    
    fn add_to_history(notification: OSNotification, id: Int) {
        let entry = NotificationHistoryEntry {
            id: id,
            title: notification.title.clone(),
            body: notification.body.clone(),
            category: notification.category.clone(),
            shown_at: Instant.now(),
            closed_at: None,
            close_reason: None
        };
        
        self.history.insert(0, entry);
        if self.history.len() > self.max_history {
            self.history.pop();
        }
    }
    
    fn history() -> [NotificationHistoryEntry] {
        self.history.clone()
    }
    
    on clear_history() {
        self.history.clear()
    }
    
    // --- Settings ---
    
    on enable() { self.settings.enabled = true }
    on disable() { self.settings.enabled = false }
    on set_do_not_disturb(enabled: Bool) { self.settings.do_not_disturb = enabled }
}

// =============================================================================
// Notification History Entry
// =============================================================================

struct NotificationHistoryEntry {
    id: Int
    title: String
    body: String
    category: Option<NotificationCategory>
    shown_at: Instant
    closed_at: Option<Instant>
    close_reason: Option<CloseReason>
}

impl NotificationHistoryEntry {
    fn age() -> Duration {
        Instant.now().duration_since(self.shown_at)
    }
    
    fn duration_shown() -> Option<Duration> {
        self.closed_at.map(|closed| closed.duration_since(self.shown_at))
    }
}

// =============================================================================
// Notification Settings
// =============================================================================

struct NotificationSettings {
    enabled: Bool
    do_not_disturb: Bool
    do_not_disturb_schedule: Option<DoNotDisturbSchedule>
    default_timeout: NotificationTimeout
    default_sound: Option<NotificationSound>
    max_history: Int
    group_similar: Bool
    show_preview: Bool
}

struct DoNotDisturbSchedule {
    start_hour: Int
    start_minute: Int
    end_hour: Int
    end_minute: Int
    days: [Weekday]
}

enum Weekday {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
}

impl NotificationSettings {
    fn default() -> Self {
        NotificationSettings {
            enabled: true,
            do_not_disturb: false,
            do_not_disturb_schedule: None,
            default_timeout: NotificationTimeout.Default,
            default_sound: None,
            max_history: 100,
            group_similar: true,
            show_preview: true
        }
    }
    
    fn disabled() -> Self { self.enabled = false; self }
    fn do_not_disturb() -> Self { self.do_not_disturb = true; self }
    fn schedule_dnd(start_hour: Int, end_hour: Int) -> Self {
        self.do_not_disturb_schedule = Some(DoNotDisturbSchedule {
            start_hour: start_hour,
            start_minute: 0,
            end_hour: end_hour,
            end_minute: 0,
            days: [Weekday.Monday, Weekday.Tuesday, Weekday.Wednesday, 
                   Weekday.Thursday, Weekday.Friday, Weekday.Saturday, Weekday.Sunday]
        });
        self
    }
    fn default_timeout(t: NotificationTimeout) -> Self { self.default_timeout = t; self }
    fn default_sound(s: NotificationSound) -> Self { self.default_sound = Some(s); self }
    fn max_history(n: Int) -> Self { self.max_history = n; self }
    fn no_grouping() -> Self { self.group_similar = false; self }
    fn no_preview() -> Self { self.show_preview = false; self }
}

// =============================================================================
// Notification Errors
// =============================================================================

enum NotificationError {
    Disabled,
    DoNotDisturb,
    ServerNotRunning,
    ServerError(String),
    InvalidNotification(String),
    NotFound(Int),
    PermissionDenied,
    Timeout,
    UnsupportedFeature(String)
    
    fn message() -> String {
        match self {
            .Disabled => "Notifications are disabled",
            .DoNotDisturb => "Do Not Disturb mode is active",
            .ServerNotRunning => "Notification server is not running",
            .ServerError(msg) => f"Server error: {msg}",
            .InvalidNotification(msg) => f"Invalid notification: {msg}",
            .NotFound(id) => f"Notification not found: {id}",
            .PermissionDenied => "Permission denied for notifications",
            .Timeout => "Notification operation timed out",
            .UnsupportedFeature(feature) => f"Unsupported feature: {feature}"
        }
    }
}

// =============================================================================
// Global Notification Manager Instance
// =============================================================================

static NOTIFICATIONS: NotificationManager = NotificationManager.new()

/// Show a simple notification
fn notify(title: String, body: String) -> Result<Int, NotificationError> {
    NOTIFICATIONS.show_simple(title, body)
}

/// Show a notification with icon
fn notify_with_icon(title: String, body: String, icon: String) -> Result<Int, NotificationError> {
    NOTIFICATIONS.show_with_icon(title, body, icon)
}

/// Show an info notification
fn info(title: String, body: String) -> Result<Int, NotificationError> {
    NOTIFICATIONS.show(OSNotification.new(title, body)
        .icon_name("dialog-information")
        .low_urgency())
}

/// Show a warning notification
fn warning(title: String, body: String) -> Result<Int, NotificationError> {
    NOTIFICATIONS.show(OSNotification.new(title, body)
        .icon_name("dialog-warning")
        .normal_urgency())
}

/// Show an error notification
fn error(title: String, body: String) -> Result<Int, NotificationError> {
    NOTIFICATIONS.show(OSNotification.new(title, body)
        .icon_name("dialog-error")
        .critical())
}

/// Show a critical notification
fn critical(title: String, body: String) -> Result<Int, NotificationError> {
    NOTIFICATIONS.show(OSNotification.new(title, body)
        .critical()
        .persistent())
}

/// Close a notification
fn close(id: Int) -> Result<(), NotificationError> {
    NOTIFICATIONS.close(id)
}

// =============================================================================
// Tests
// =============================================================================

test "notification creation" {
    let notif = OSNotification.new("Test", "This is a test notification")
        .icon_name("dialog-information")
        .timeout_seconds(5)
        .action("view", "View")
        .action("dismiss", "Dismiss");
    
    assert_eq(notif.title, "Test")?
    assert_eq(notif.actions.len(), 2)?
}

test "notification urgency" {
    let low = OSNotification.new("Low", "Low urgency").low_urgency();
    let critical = OSNotification.new("Critical", "Critical").critical();
    
    assert_eq(low.urgency, NotificationUrgency.Low)?
    assert_eq(critical.urgency, NotificationUrgency.Critical)?
}

test "notification timeout" {
    assert_eq(NotificationTimeout.Default.to_ms(), -1)?
    assert_eq(NotificationTimeout.Never.to_ms(), 0)?
    assert_eq(NotificationTimeout.seconds(5).to_ms(), 5000)?
}

test "notification category" {
    let notif = OSNotification.new("Email", "New email")
        .category(NotificationCategory.EmailArrived);
    
    assert_eq(notif.category, Some(NotificationCategory.EmailArrived))?
}

test "notification sound" {
    let silent = NotificationSound.silent();
    assert(silent.suppress)?
    
    let named = NotificationSound.named("message-new-instant");
    assert_eq(named.name, Some("message-new-instant"))?
}

test "notification action" {
    let action = NotificationAction.new("reply", "Reply")
        .icon("/icons/reply.png")
        .default();
    
    assert_eq(action.id, "reply")?
    assert(action.is_default)?
}

test "notification settings" {
    let settings = NotificationSettings.default()
        .do_not_disturb()
        .schedule_dnd(22, 8)
        .max_history(50);
    
    assert(settings.do_not_disturb)?
    assert_eq(settings.max_history, 50)?
}

test "close reason" {
    let result = NotificationResult {
        id: 1,
        action_invoked: Some("view"),
        close_reason: CloseReason.ActionInvoked("view"),
        duration_shown: Duration.from_seconds(3)
    };
    
    assert(result.was_clicked())?
    assert(!result.was_dismissed())?
}
