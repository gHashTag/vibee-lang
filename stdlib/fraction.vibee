// =============================================================================
// Vibee OS — Fraction Module
// Rational number arithmetic with exact precision
// =============================================================================

use math::{abs_int, gcd, lcm}

// -----------------------------------------------------------------------------
// Fraction Type
// -----------------------------------------------------------------------------

/// Rational number represented as numerator/denominator
struct Fraction {
    num: Int    // Numerator
    den: Int    // Denominator (always positive)
    
    /// Create new fraction (automatically reduces)
    fn new(numerator: Int, denominator: Int) -> Self {
        if denominator == 0 { panic("Division by zero: denominator cannot be zero") }
        
        let sign = if (numerator < 0) != (denominator < 0) { -1 } else { 1 }
        let n = abs_int(numerator)
        let d = abs_int(denominator)
        let g = gcd(n, d)
        
        Fraction { num: sign * (n / g), den: d / g }
    }
    
    /// Create from integer
    fn from_int(n: Int) -> Self {
        Fraction { num: n, den: 1 }
    }
    
    /// Create from float (approximate)
    fn from_float(f: Float, max_denominator: Int = 1000000) -> Self {
        if f == 0.0 { return Fraction.zero() }
        
        let negative = f < 0.0
        let f = if negative { -f } else { f }
        
        // Continued fraction algorithm
        var a = f.floor() as Int
        var h1 = 1; var h2 = 0
        var k1 = 0; var k2 = 1
        var b = f
        
        loop {
            let h = a * h1 + h2
            let k = a * k1 + k2
            
            if k > max_denominator { break }
            
            h2 = h1; h1 = h
            k2 = k1; k1 = k
            
            let remainder = b - a as Float
            if remainder < 1e-10 { break }
            
            b = 1.0 / remainder
            a = b.floor() as Int
        }
        
        Fraction.new(if negative { -h1 } else { h1 }, k1)
    }
    
    /// Parse from string "a/b" or "a"
    fn from_string(s: String) -> Result<Self, ParseError> {
        let s = s.trim()
        
        match s.find('/') {
            Some(pos) => {
                let num = Int.parse(s[..pos].trim())?
                let den = Int.parse(s[pos+1..].trim())?
                if den == 0 { return Err(ParseError.DivisionByZero) }
                Ok(Fraction.new(num, den))
            }
            None => {
                let num = Int.parse(s)?
                Ok(Fraction.from_int(num))
            }
        }
    }
    
    /// Zero
    fn zero() -> Self { Fraction { num: 0, den: 1 } }
    
    /// One
    fn one() -> Self { Fraction { num: 1, den: 1 } }
    
    /// One half
    fn half() -> Self { Fraction { num: 1, den: 2 } }
    
    /// One third
    fn third() -> Self { Fraction { num: 1, den: 3 } }
    
    /// One quarter
    fn quarter() -> Self { Fraction { num: 1, den: 4 } }
    
    // -------------------------------------------------------------------------
    // Properties
    // -------------------------------------------------------------------------
    
    /// Get numerator
    fn numerator() -> Int { self.num }
    
    /// Get denominator
    fn denominator() -> Int { self.den }
    
    /// Check if zero
    fn is_zero() -> Bool { self.num == 0 }
    
    /// Check if one
    fn is_one() -> Bool { self.num == 1 && self.den == 1 }
    
    /// Check if negative
    fn is_negative() -> Bool { self.num < 0 }
    
    /// Check if positive
    fn is_positive() -> Bool { self.num > 0 }
    
    /// Check if integer (denominator is 1)
    fn is_integer() -> Bool { self.den == 1 }
    
    /// Check if proper fraction (|num| < den)
    fn is_proper() -> Bool { abs_int(self.num) < self.den }
    
    /// Check if unit fraction (numerator is 1)
    fn is_unit() -> Bool { self.num == 1 }
    
    /// Sign (-1, 0, or 1)
    fn signum() -> Int {
        if self.num > 0 { 1 }
        else if self.num < 0 { -1 }
        else { 0 }
    }
    
    // -------------------------------------------------------------------------
    // Basic Operations
    // -------------------------------------------------------------------------
    
    /// Absolute value
    fn abs() -> Self {
        Fraction { num: abs_int(self.num), den: self.den }
    }
    
    /// Negate
    fn negate() -> Self {
        Fraction { num: -self.num, den: self.den }
    }
    
    /// Reciprocal (1/x)
    fn recip() -> Self {
        if self.num == 0 { panic("Cannot take reciprocal of zero") }
        Fraction.new(self.den, self.num)
    }
    
    /// Reduce to lowest terms (already done in constructor)
    fn reduce() -> Self { self.clone() }
    
    /// Get integer and fractional parts
    fn mixed() -> (Int, Fraction) {
        let whole = self.num / self.den
        let remainder = self.num % self.den
        (whole, Fraction { num: remainder, den: self.den })
    }
    
    /// Create from mixed number
    fn from_mixed(whole: Int, num: Int, den: Int) -> Self {
        let sign = if whole < 0 { -1 } else { 1 }
        Fraction.new(abs_int(whole) * den + num, den).scale(sign)
    }
    
    /// Scale by integer
    fn scale(n: Int) -> Self {
        Fraction.new(self.num * n, self.den)
    }
    
    // -------------------------------------------------------------------------
    // Power Operations
    // -------------------------------------------------------------------------
    
    /// Integer power
    fn pow(n: Int) -> Self {
        if n == 0 { return Fraction.one() }
        if n < 0 { return self.recip().pow(-n) }
        
        var result = Fraction.one()
        var base = self.clone()
        var exp = n
        
        while exp > 0 {
            if exp & 1 == 1 { result = result * base }
            base = base * base
            exp >>= 1
        }
        result
    }
    
    /// Square
    fn square() -> Self {
        Fraction.new(self.num * self.num, self.den * self.den)
    }
    
    /// Cube
    fn cube() -> Self {
        Fraction.new(self.num * self.num * self.num, self.den * self.den * self.den)
    }
    
    // -------------------------------------------------------------------------
    // Conversion
    // -------------------------------------------------------------------------
    
    /// Convert to float
    fn to_float() -> Float {
        self.num as Float / self.den as Float
    }
    
    /// Convert to integer (truncates)
    fn to_int() -> Int {
        self.num / self.den
    }
    
    /// Floor (largest integer ≤ fraction)
    fn floor() -> Int {
        if self.num >= 0 { self.num / self.den }
        else { (self.num - self.den + 1) / self.den }
    }
    
    /// Ceiling (smallest integer ≥ fraction)
    fn ceil() -> Int {
        if self.num <= 0 { self.num / self.den }
        else { (self.num + self.den - 1) / self.den }
    }
    
    /// Round to nearest integer
    fn round() -> Int {
        let (whole, frac) = self.mixed()
        if frac.num * 2 >= frac.den { whole + 1 }
        else if frac.num * 2 <= -frac.den { whole - 1 }
        else { whole }
    }
    
    /// Truncate toward zero
    fn trunc() -> Int {
        self.num / self.den
    }
    
    // -------------------------------------------------------------------------
    // Display
    // -------------------------------------------------------------------------
    
    /// Convert to string
    fn to_string() -> String {
        if self.den == 1 { format!("{}", self.num) }
        else { format!("{}/{}", self.num, self.den) }
    }
    
    /// Convert to mixed number string
    fn to_mixed_string() -> String {
        if self.is_integer() { return format!("{}", self.num) }
        if self.is_proper() { return self.to_string() }
        
        let (whole, frac) = self.mixed()
        if frac.is_zero() { format!("{}", whole) }
        else { format!("{} {}/{}", whole, abs_int(frac.num), frac.den) }
    }
    
    /// Convert to decimal string with precision
    fn to_decimal_string(precision: Int) -> String {
        format!("{:.prec$}", self.to_float(), prec = precision)
    }
}

// -----------------------------------------------------------------------------
// Arithmetic Operators
// -----------------------------------------------------------------------------

impl Add for Fraction {
    fn add(other: Fraction) -> Fraction {
        let num = self.num * other.den + other.num * self.den
        let den = self.den * other.den
        Fraction.new(num, den)
    }
}

impl Sub for Fraction {
    fn sub(other: Fraction) -> Fraction {
        let num = self.num * other.den - other.num * self.den
        let den = self.den * other.den
        Fraction.new(num, den)
    }
}

impl Mul for Fraction {
    fn mul(other: Fraction) -> Fraction {
        Fraction.new(self.num * other.num, self.den * other.den)
    }
}

impl Div for Fraction {
    fn div(other: Fraction) -> Fraction {
        if other.is_zero() { panic("Division by zero") }
        Fraction.new(self.num * other.den, self.den * other.num)
    }
}

impl Neg for Fraction {
    fn neg() -> Fraction {
        Fraction { num: -self.num, den: self.den }
    }
}

impl Rem for Fraction {
    fn rem(other: Fraction) -> Fraction {
        let quotient = (self / other).trunc()
        self - other.scale(quotient)
    }
}

// -----------------------------------------------------------------------------
// Comparison
// -----------------------------------------------------------------------------

impl Eq for Fraction {
    fn eq(other: Fraction) -> Bool {
        self.num == other.num && self.den == other.den
    }
}

impl Ord for Fraction {
    fn cmp(other: Fraction) -> Ordering {
        let diff = self.num * other.den - other.num * self.den
        if diff > 0 { Ordering.Greater }
        else if diff < 0 { Ordering.Less }
        else { Ordering.Equal }
    }
}

// -----------------------------------------------------------------------------
// Utility Functions
// -----------------------------------------------------------------------------

/// Sum of fractions
fn sum(fractions: [Fraction]) -> Fraction {
    fractions.fold(Fraction.zero(), |acc, f| acc + f)
}

/// Product of fractions
fn product(fractions: [Fraction]) -> Fraction {
    fractions.fold(Fraction.one(), |acc, f| acc * f)
}

/// Average of fractions
fn average(fractions: [Fraction]) -> Fraction {
    if fractions.is_empty() { return Fraction.zero() }
    sum(fractions) / Fraction.from_int(fractions.len())
}

/// Mediant of two fractions (a/b ⊕ c/d = (a+c)/(b+d))
fn mediant(a: Fraction, b: Fraction) -> Fraction {
    Fraction.new(a.num + b.num, a.den + b.den)
}

/// Harmonic mean of fractions
fn harmonic_mean(fractions: [Fraction]) -> Fraction {
    if fractions.is_empty() { return Fraction.zero() }
    let n = Fraction.from_int(fractions.len())
    let sum_recip = fractions.fold(Fraction.zero(), |acc, f| acc + f.recip())
    n / sum_recip
}

/// Continued fraction representation
fn to_continued_fraction(f: Fraction) -> [Int] {
    var result = []
    var num = f.num
    var den = f.den
    
    while den != 0 {
        result.append(num / den)
        let temp = num % den
        num = den
        den = temp
    }
    result
}

/// Create fraction from continued fraction
fn from_continued_fraction(cf: [Int]) -> Fraction {
    if cf.is_empty() { return Fraction.zero() }
    
    var result = Fraction.from_int(cf.last().unwrap())
    for i in (0..cf.len()-1).rev() {
        result = Fraction.from_int(cf[i]) + result.recip()
    }
    result
}

/// Egyptian fraction decomposition (sum of unit fractions)
fn to_egyptian(f: Fraction) -> [Fraction] {
    if f.is_zero() { return [] }
    if f.is_negative() { panic("Egyptian fractions require positive input") }
    
    var result = []
    var remaining = f.clone()
    
    while !remaining.is_zero() && remaining.num > 0 {
        // Find smallest unit fraction ≤ remaining
        let unit_den = (remaining.den + remaining.num - 1) / remaining.num
        let unit = Fraction.new(1, unit_den)
        result.append(unit)
        remaining = remaining - unit
    }
    result
}

/// Farey sequence of order n
fn farey_sequence(n: Int) -> [Fraction] {
    var result = [Fraction.new(0, 1)]
    
    var a = 0; var b = 1
    var c = 1; var d = n
    
    while c <= n {
        let k = (n + b) / d
        let (a_new, b_new) = (c, d)
        let (c_new, d_new) = (k * c - a, k * d - b)
        a = a_new; b = b_new
        c = c_new; d = d_new
        result.append(Fraction.new(a, b))
    }
    result
}

/// Stern-Brocot tree path to fraction
fn stern_brocot_path(f: Fraction) -> String {
    var path = ""
    var left = Fraction.new(0, 1)
    var right = Fraction.new(1, 0)  // Represents infinity
    
    while true {
        let med = mediant(left, right)
        if med == f { break }
        if f < med {
            path += "L"
            right = med
        } else {
            path += "R"
            left = med
        }
    }
    path
}

// -----------------------------------------------------------------------------
// Common Fractions
// -----------------------------------------------------------------------------

module CommonFractions {
    fn pi_approx() -> Fraction { Fraction.new(355, 113) }  // 3.14159292...
    fn e_approx() -> Fraction { Fraction.new(2721, 1001) } // 2.71828171...
    fn phi_approx() -> Fraction { Fraction.new(987, 610) } // Golden ratio
    fn sqrt2_approx() -> Fraction { Fraction.new(99, 70) } // √2 ≈ 1.4142857
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ParseError {
    Empty
    InvalidFormat
    DivisionByZero
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "creation" {
    let f = Fraction.new(4, 6)
    assert_eq(f.num, 2)?  // Reduced
    assert_eq(f.den, 3)?
}

test "from_float" {
    let f = Fraction.from_float(0.5)
    assert_eq(f, Fraction.half())?
    
    let f2 = Fraction.from_float(0.333333, 100)
    assert_eq(f2, Fraction.third())?
}

test "arithmetic" {
    let a = Fraction.new(1, 2)
    let b = Fraction.new(1, 3)
    
    assert_eq(a + b, Fraction.new(5, 6))?
    assert_eq(a - b, Fraction.new(1, 6))?
    assert_eq(a * b, Fraction.new(1, 6))?
    assert_eq(a / b, Fraction.new(3, 2))?
}

test "comparison" {
    let a = Fraction.new(1, 2)
    let b = Fraction.new(2, 3)
    
    assert(a < b)
    assert(b > a)
    assert(a != b)
}

test "mixed numbers" {
    let f = Fraction.new(7, 3)
    let (whole, frac) = f.mixed()
    assert_eq(whole, 2)?
    assert_eq(frac, Fraction.new(1, 3))?
}

test "continued fraction" {
    let f = Fraction.new(355, 113)
    let cf = to_continued_fraction(f)
    let reconstructed = from_continued_fraction(cf)
    assert_eq(f, reconstructed)?
}

test "egyptian fractions" {
    let f = Fraction.new(5, 6)
    let egyptian = to_egyptian(f)
    let reconstructed = sum(egyptian)
    assert_eq(f, reconstructed)?
}

test "mediant" {
    let a = Fraction.new(1, 2)
    let b = Fraction.new(2, 3)
    let m = mediant(a, b)
    assert_eq(m, Fraction.new(3, 5))?
}

test "power" {
    let f = Fraction.new(2, 3)
    assert_eq(f.pow(2), Fraction.new(4, 9))?
    assert_eq(f.pow(-1), Fraction.new(3, 2))?
}
