// =============================================================================
// Vibee OS â€” Recurrence Module
// Recurring event patterns and scheduling (RFC 5545 compatible)
// =============================================================================

use datetime::{DateTime, Duration, Weekday, Month}
use uuid::{UUID}

// =============================================================================
// Recurrence Types & Enums
// =============================================================================

enum Frequency { Secondly, Minutely, Hourly, Daily, Weekly, Monthly, Yearly }
enum WeekStart { Sunday, Monday }
enum OrdinalWeek { First, Second, Third, Fourth, Last }

// =============================================================================
// Recurrence Rule (RRULE)
// =============================================================================

struct RecurrenceRule {
    frequency: Frequency
    interval: Int
    count: Option<Int>
    until: Option<DateTime>
    by_second: [Int]
    by_minute: [Int]
    by_hour: [Int]
    by_day: [ByDay]
    by_month_day: [Int]
    by_year_day: [Int]
    by_week_no: [Int]
    by_month: [Int]
    by_set_pos: [Int]
    week_start: WeekStart
}

struct ByDay {
    weekday: Weekday
    ordinal: Option<Int>  // -1 = last, 1 = first, etc.
}

impl ByDay {
    fn new(weekday: Weekday) -> Self {
        ByDay { weekday: weekday, ordinal: None }
    }
    
    fn with_ordinal(weekday: Weekday, ordinal: Int) -> Self {
        ByDay { weekday: weekday, ordinal: Some(ordinal) }
    }
    
    fn first(weekday: Weekday) -> Self { ByDay.with_ordinal(weekday, 1) }
    fn second(weekday: Weekday) -> Self { ByDay.with_ordinal(weekday, 2) }
    fn third(weekday: Weekday) -> Self { ByDay.with_ordinal(weekday, 3) }
    fn fourth(weekday: Weekday) -> Self { ByDay.with_ordinal(weekday, 4) }
    fn last(weekday: Weekday) -> Self { ByDay.with_ordinal(weekday, -1) }
    
    fn to_string() -> String {
        let day_str = match self.weekday {
            Weekday.Monday => "MO"
            Weekday.Tuesday => "TU"
            Weekday.Wednesday => "WE"
            Weekday.Thursday => "TH"
            Weekday.Friday => "FR"
            Weekday.Saturday => "SA"
            Weekday.Sunday => "SU"
        }
        
        if let Some(ord) = self.ordinal {
            "\(ord)\(day_str)"
        } else {
            day_str
        }
    }
}

impl RecurrenceRule {
    fn new(frequency: Frequency) -> Self {
        RecurrenceRule {
            frequency: frequency,
            interval: 1,
            count: None,
            until: None,
            by_second: [],
            by_minute: [],
            by_hour: [],
            by_day: [],
            by_month_day: [],
            by_year_day: [],
            by_week_no: [],
            by_month: [],
            by_set_pos: [],
            week_start: WeekStart.Monday
        }
    }
    
    // Preset patterns
    fn daily() -> Self { RecurrenceRule.new(Frequency.Daily) }
    fn weekly() -> Self { RecurrenceRule.new(Frequency.Weekly) }
    fn monthly() -> Self { RecurrenceRule.new(Frequency.Monthly) }
    fn yearly() -> Self { RecurrenceRule.new(Frequency.Yearly) }
    
    fn every_weekday() -> Self {
        RecurrenceRule.new(Frequency.Weekly)
            .on_days([
                ByDay.new(Weekday.Monday),
                ByDay.new(Weekday.Tuesday),
                ByDay.new(Weekday.Wednesday),
                ByDay.new(Weekday.Thursday),
                ByDay.new(Weekday.Friday)
            ])
    }
    
    fn every_weekend() -> Self {
        RecurrenceRule.new(Frequency.Weekly)
            .on_days([
                ByDay.new(Weekday.Saturday),
                ByDay.new(Weekday.Sunday)
            ])
    }
    
    fn first_weekday_of_month(weekday: Weekday) -> Self {
        RecurrenceRule.new(Frequency.Monthly)
            .on_days([ByDay.first(weekday)])
    }
    
    fn last_weekday_of_month(weekday: Weekday) -> Self {
        RecurrenceRule.new(Frequency.Monthly)
            .on_days([ByDay.last(weekday)])
    }
    
    // Builder methods
    fn every(n: Int) -> Self { self.interval = n; self }
    fn times(n: Int) -> Self { self.count = Some(n); self }
    fn until(dt: DateTime) -> Self { self.until = Some(dt); self }
    fn starting_week(ws: WeekStart) -> Self { self.week_start = ws; self }
    
    fn on_days(days: [ByDay]) -> Self { self.by_day = days; self }
    fn on_weekday(weekday: Weekday) -> Self { self.by_day.push(ByDay.new(weekday)); self }
    fn on_month_days(days: [Int]) -> Self { self.by_month_day = days; self }
    fn on_months(months: [Int]) -> Self { self.by_month = months; self }
    fn on_year_days(days: [Int]) -> Self { self.by_year_day = days; self }
    fn on_weeks(weeks: [Int]) -> Self { self.by_week_no = weeks; self }
    fn at_hours(hours: [Int]) -> Self { self.by_hour = hours; self }
    fn at_minutes(minutes: [Int]) -> Self { self.by_minute = minutes; self }
    fn at_positions(positions: [Int]) -> Self { self.by_set_pos = positions; self }
    
    // Validation
    fn is_valid() -> Bool {
        if self.interval < 1 { return false }
        if let Some(count) = self.count {
            if count < 1 { return false }
        }
        
        // Validate by_month_day
        for day in self.by_month_day.iter() {
            if day < -31 || day > 31 || day == 0 { return false }
        }
        
        // Validate by_month
        for month in self.by_month.iter() {
            if month < 1 || month > 12 { return false }
        }
        
        // Validate by_hour
        for hour in self.by_hour.iter() {
            if hour < 0 || hour > 23 { return false }
        }
        
        // Validate by_minute
        for minute in self.by_minute.iter() {
            if minute < 0 || minute > 59 { return false }
        }
        
        true
    }
    
    // Generate occurrences
    fn occurrences(start: DateTime, limit: Int) -> [DateTime] {
        var results = []
        var current = start
        var count = 0
        let max_iterations = limit * 100  // Safety limit
        var iterations = 0
        
        while count < limit && iterations < max_iterations {
            iterations += 1
            
            if self.matches(current) {
                // Check until constraint
                if let Some(until) = self.until {
                    if current.is_after(until) { break }
                }
                
                // Check count constraint
                if let Some(max_count) = self.count {
                    if count >= max_count { break }
                }
                
                results.push(current)
                count += 1
            }
            
            current = self.next_candidate(current)
        }
        
        results
    }
    
    fn next_occurrence(after: DateTime) -> Option<DateTime> {
        var current = after
        let max_iterations = 366 * 24  // Max 1 year of hourly checks
        
        for _ in 0..max_iterations {
            current = self.next_candidate(current)
            
            if self.matches(current) {
                // Check until constraint
                if let Some(until) = self.until {
                    if current.is_after(until) { return None }
                }
                return Some(current)
            }
        }
        
        None
    }
    
    fn matches(dt: DateTime) -> Bool {
        // Check by_month
        if !self.by_month.is_empty() && !self.by_month.contains(dt.month()) {
            return false
        }
        
        // Check by_month_day
        if !self.by_month_day.is_empty() {
            let day = dt.day()
            let days_in_month = dt.days_in_month()
            var matches = false
            for md in self.by_month_day.iter() {
                let actual_day = if md < 0 { days_in_month + md + 1 } else { md }
                if day == actual_day { matches = true; break }
            }
            if !matches { return false }
        }
        
        // Check by_day
        if !self.by_day.is_empty() {
            let weekday = dt.weekday()
            var matches = false
            for bd in self.by_day.iter() {
                if bd.weekday == weekday {
                    if let Some(ordinal) = bd.ordinal {
                        let week_of_month = (dt.day() - 1) / 7 + 1
                        let last_week = (dt.days_in_month() - 1) / 7 + 1
                        let actual_ordinal = if ordinal < 0 { last_week + ordinal + 1 } else { ordinal }
                        if week_of_month == actual_ordinal { matches = true; break }
                    } else {
                        matches = true
                        break
                    }
                }
            }
            if !matches { return false }
        }
        
        // Check by_hour
        if !self.by_hour.is_empty() && !self.by_hour.contains(dt.hour()) {
            return false
        }
        
        // Check by_minute
        if !self.by_minute.is_empty() && !self.by_minute.contains(dt.minute()) {
            return false
        }
        
        true
    }
    
    fn next_candidate(current: DateTime) -> DateTime {
        match self.frequency {
            Frequency.Secondly => current.add(Duration.seconds(self.interval as Int64))
            Frequency.Minutely => current.add(Duration.minutes(self.interval as Int64))
            Frequency.Hourly => current.add(Duration.hours(self.interval as Int64))
            Frequency.Daily => current.add(Duration.days(self.interval as Int64))
            Frequency.Weekly => current.add(Duration.weeks(self.interval as Int64))
            Frequency.Monthly => current.add_months(self.interval)
            Frequency.Yearly => current.add_years(self.interval)
        }
    }
    
    // Serialization (RFC 5545 RRULE format)
    fn to_rrule() -> String {
        var parts = []
        
        parts.push("FREQ=" + match self.frequency {
            Frequency.Secondly => "SECONDLY"
            Frequency.Minutely => "MINUTELY"
            Frequency.Hourly => "HOURLY"
            Frequency.Daily => "DAILY"
            Frequency.Weekly => "WEEKLY"
            Frequency.Monthly => "MONTHLY"
            Frequency.Yearly => "YEARLY"
        })
        
        if self.interval != 1 {
            parts.push("INTERVAL=\(self.interval)")
        }
        
        if let Some(count) = self.count {
            parts.push("COUNT=\(count)")
        }
        
        if let Some(until) = self.until {
            parts.push("UNTIL=\(until.format(\"%Y%m%dT%H%M%SZ\"))")
        }
        
        if !self.by_day.is_empty() {
            let days = self.by_day.iter().map(|d| d.to_string()).join(",")
            parts.push("BYDAY=\(days)")
        }
        
        if !self.by_month_day.is_empty() {
            parts.push("BYMONTHDAY=\(self.by_month_day.iter().map(|d| d.to_string()).join(\",\"))")
        }
        
        if !self.by_month.is_empty() {
            parts.push("BYMONTH=\(self.by_month.iter().map(|m| m.to_string()).join(\",\"))")
        }
        
        if !self.by_hour.is_empty() {
            parts.push("BYHOUR=\(self.by_hour.iter().map(|h| h.to_string()).join(\",\"))")
        }
        
        if !self.by_minute.is_empty() {
            parts.push("BYMINUTE=\(self.by_minute.iter().map(|m| m.to_string()).join(\",\"))")
        }
        
        if self.week_start == WeekStart.Sunday {
            parts.push("WKST=SU")
        }
        
        parts.join(";")
    }
    
    fn parse(s: String) -> Result<Self, RecurrenceError> {
        var rule = RecurrenceRule.new(Frequency.Daily)
        
        for part in s.split(";") {
            let kv = part.split("=")
            if kv.len() != 2 { continue }
            
            let key = kv[0].trim().to_upper()
            let value = kv[1].trim()
            
            match key.as_str() {
                "FREQ" => {
                    rule.frequency = match value.to_upper().as_str() {
                        "SECONDLY" => Frequency.Secondly
                        "MINUTELY" => Frequency.Minutely
                        "HOURLY" => Frequency.Hourly
                        "DAILY" => Frequency.Daily
                        "WEEKLY" => Frequency.Weekly
                        "MONTHLY" => Frequency.Monthly
                        "YEARLY" => Frequency.Yearly
                        _ => return Err(RecurrenceError.InvalidFrequency)
                    }
                }
                "INTERVAL" => {
                    rule.interval = Int.parse(value).map_err(|_| RecurrenceError.InvalidInterval)?
                }
                "COUNT" => {
                    rule.count = Some(Int.parse(value).map_err(|_| RecurrenceError.InvalidCount)?)
                }
                "UNTIL" => {
                    rule.until = Some(DateTime.parse(value).map_err(|_| RecurrenceError.InvalidUntil)?)
                }
                "BYDAY" => {
                    rule.by_day = parse_by_day(value)?
                }
                "BYMONTHDAY" => {
                    rule.by_month_day = value.split(",").map(|v| Int.parse(v.trim())).collect::<Result<_, _>>().map_err(|_| RecurrenceError.InvalidByMonthDay)?
                }
                "BYMONTH" => {
                    rule.by_month = value.split(",").map(|v| Int.parse(v.trim())).collect::<Result<_, _>>().map_err(|_| RecurrenceError.InvalidByMonth)?
                }
                "BYHOUR" => {
                    rule.by_hour = value.split(",").map(|v| Int.parse(v.trim())).collect::<Result<_, _>>().map_err(|_| RecurrenceError.InvalidByHour)?
                }
                "BYMINUTE" => {
                    rule.by_minute = value.split(",").map(|v| Int.parse(v.trim())).collect::<Result<_, _>>().map_err(|_| RecurrenceError.InvalidByMinute)?
                }
                "WKST" => {
                    rule.week_start = match value.to_upper().as_str() {
                        "SU" => WeekStart.Sunday
                        _ => WeekStart.Monday
                    }
                }
                _ => {}
            }
        }
        
        if !rule.is_valid() {
            return Err(RecurrenceError.InvalidRule)
        }
        
        Ok(rule)
    }
    
    // Human-readable description
    fn describe() -> String {
        var desc = match self.frequency {
            Frequency.Secondly => "Every second"
            Frequency.Minutely => "Every minute"
            Frequency.Hourly => "Every hour"
            Frequency.Daily => "Daily"
            Frequency.Weekly => "Weekly"
            Frequency.Monthly => "Monthly"
            Frequency.Yearly => "Yearly"
        }
        
        if self.interval > 1 {
            desc = match self.frequency {
                Frequency.Daily => "Every \(self.interval) days"
                Frequency.Weekly => "Every \(self.interval) weeks"
                Frequency.Monthly => "Every \(self.interval) months"
                Frequency.Yearly => "Every \(self.interval) years"
                _ => desc
            }
        }
        
        if !self.by_day.is_empty() {
            let days = self.by_day.iter().map(|d| d.weekday.name()).join(", ")
            desc += " on \(days)"
        }
        
        if !self.by_month_day.is_empty() {
            let days = self.by_month_day.iter().map(|d| ordinal_suffix(d)).join(", ")
            desc += " on the \(days)"
        }
        
        if let Some(count) = self.count {
            desc += ", \(count) times"
        }
        
        if let Some(until) = self.until {
            desc += ", until \(until.format(\"%Y-%m-%d\"))"
        }
        
        desc
    }
}

fn parse_by_day(s: String) -> Result<[ByDay], RecurrenceError> {
    var result = []
    
    for part in s.split(",") {
        let part = part.trim().to_upper()
        var ordinal: Option<Int> = None
        var day_str = part.clone()
        
        // Check for ordinal prefix
        if part.len() > 2 {
            let prefix = part[..part.len()-2]
            if let Ok(ord) = Int.parse(prefix) {
                ordinal = Some(ord)
                day_str = part[part.len()-2..]
            }
        }
        
        let weekday = match day_str.as_str() {
            "MO" => Weekday.Monday
            "TU" => Weekday.Tuesday
            "WE" => Weekday.Wednesday
            "TH" => Weekday.Thursday
            "FR" => Weekday.Friday
            "SA" => Weekday.Saturday
            "SU" => Weekday.Sunday
            _ => return Err(RecurrenceError.InvalidByDay)
        }
        
        result.push(ByDay { weekday: weekday, ordinal: ordinal })
    }
    
    Ok(result)
}

fn ordinal_suffix(n: Int) -> String {
    let abs_n = n.abs()
    let suffix = match abs_n % 10 {
        1 if abs_n % 100 != 11 => "st"
        2 if abs_n % 100 != 12 => "nd"
        3 if abs_n % 100 != 13 => "rd"
        _ => "th"
    }
    "\(n)\(suffix)"
}

// =============================================================================
// Recurrence Set
// =============================================================================

struct RecurrenceSet {
    rrules: [RecurrenceRule]
    rdates: [DateTime]
    exrules: [RecurrenceRule]
    exdates: [DateTime]
}

impl RecurrenceSet {
    fn new() -> Self {
        RecurrenceSet {
            rrules: [],
            rdates: [],
            exrules: [],
            exdates: []
        }
    }
    
    fn with_rule(rule: RecurrenceRule) -> Self {
        self.rrules.push(rule)
        self
    }
    
    fn with_date(dt: DateTime) -> Self {
        self.rdates.push(dt)
        self
    }
    
    fn exclude_rule(rule: RecurrenceRule) -> Self {
        self.exrules.push(rule)
        self
    }
    
    fn exclude_date(dt: DateTime) -> Self {
        self.exdates.push(dt)
        self
    }
    
    fn occurrences(start: DateTime, limit: Int) -> [DateTime] {
        var all_dates: [DateTime] = []
        
        // Add dates from rrules
        for rule in self.rrules.iter() {
            all_dates.extend(rule.occurrences(start, limit))
        }
        
        // Add explicit rdates
        for dt in self.rdates.iter() {
            if dt.is_after(start) || dt.is_same(start) {
                all_dates.push(dt.clone())
            }
        }
        
        // Remove excluded dates
        all_dates.retain(|dt| !self.exdates.contains(dt))
        
        // Remove dates matching exrules
        for exrule in self.exrules.iter() {
            let excluded = exrule.occurrences(start, limit * 2)
            all_dates.retain(|dt| !excluded.contains(dt))
        }
        
        // Sort and deduplicate
        all_dates.sort()
        all_dates.dedup()
        
        // Limit results
        all_dates.into_iter().take(limit).collect()
    }
    
    fn is_excluded(dt: DateTime) -> Bool {
        if self.exdates.contains(dt) { return true }
        
        for exrule in self.exrules.iter() {
            if exrule.matches(dt) { return true }
        }
        
        false
    }
}

// =============================================================================
// Recurring Event Instance
// =============================================================================

struct RecurringInstance {
    id: String
    parent_event_id: String
    occurrence_date: DateTime
    is_exception: Bool
    exception_data: Option<Map<String, String>>
}

impl RecurringInstance {
    fn new(parent_id: String, date: DateTime) -> Self {
        RecurringInstance {
            id: UUID.v4().to_string(),
            parent_event_id: parent_id,
            occurrence_date: date,
            is_exception: false,
            exception_data: None
        }
    }
    
    fn as_exception(data: Map<String, String>) -> Self {
        self.is_exception = true
        self.exception_data = Some(data)
        self
    }
}

// =============================================================================
// Recurrence Expander
// =============================================================================

actor RecurrenceExpander {
    state cache: Map<String, [DateTime]>
    state cache_ttl: Duration
    
    fn new() -> Self {
        RecurrenceExpander {
            cache: Map.empty(),
            cache_ttl: Duration.hours(1)
        }
    }
    
    fn expand(rule: RecurrenceRule, start: DateTime, end: DateTime) -> [DateTime] {
        let cache_key = "\(rule.to_rrule())_\(start.timestamp())_\(end.timestamp())"
        
        if let Some(cached) = self.cache.get(cache_key.clone()) {
            return cached.clone()
        }
        
        var results = []
        var current = start
        let max_iterations = 10000
        var iterations = 0
        
        while current.is_before(end) && iterations < max_iterations {
            iterations += 1
            
            if rule.matches(current) {
                results.push(current)
                
                // Check count limit
                if let Some(count) = rule.count {
                    if results.len() >= count { break }
                }
            }
            
            current = rule.next_candidate(current)
        }
        
        self.cache.insert(cache_key, results.clone())
        results
    }
    
    fn expand_set(set: RecurrenceSet, start: DateTime, end: DateTime) -> [DateTime] {
        set.occurrences(start, 1000)
            .into_iter()
            .filter(|dt| dt.is_before(end))
            .collect()
    }
    
    fn clear_cache() {
        self.cache.clear()
    }
}

// =============================================================================
// Errors
// =============================================================================

enum RecurrenceError {
    InvalidRule
    InvalidFrequency
    InvalidInterval
    InvalidCount
    InvalidUntil
    InvalidByDay
    InvalidByMonthDay
    InvalidByMonth
    InvalidByHour
    InvalidByMinute
    ParseError(String)
}

impl Display for RecurrenceError {
    fn fmt(f: Formatter) {
        match self {
            InvalidRule => f.write("Invalid recurrence rule")
            InvalidFrequency => f.write("Invalid frequency")
            InvalidInterval => f.write("Invalid interval")
            InvalidCount => f.write("Invalid count")
            InvalidUntil => f.write("Invalid until date")
            InvalidByDay => f.write("Invalid BYDAY value")
            InvalidByMonthDay => f.write("Invalid BYMONTHDAY value")
            InvalidByMonth => f.write("Invalid BYMONTH value")
            InvalidByHour => f.write("Invalid BYHOUR value")
            InvalidByMinute => f.write("Invalid BYMINUTE value")
            ParseError(msg) => f.write("Parse error: \(msg)")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "daily recurrence" {
    let rule = RecurrenceRule.daily()
    let start = DateTime.new(2024, 1, 1, 9, 0, 0)
    let occurrences = rule.occurrences(start, 5)
    
    assert_eq(occurrences.len(), 5)?
    assert_eq(occurrences[0].day(), 1)?
    assert_eq(occurrences[1].day(), 2)?
}

test "weekly recurrence on specific days" {
    let rule = RecurrenceRule.weekly()
        .on_days([ByDay.new(Weekday.Monday), ByDay.new(Weekday.Wednesday), ByDay.new(Weekday.Friday)])
    
    let start = DateTime.new(2024, 1, 1, 9, 0, 0)  // Monday
    let occurrences = rule.occurrences(start, 6)
    
    assert_eq(occurrences.len(), 6)?
}

test "monthly on specific day" {
    let rule = RecurrenceRule.monthly()
        .on_month_days([15])
    
    let start = DateTime.new(2024, 1, 15, 9, 0, 0)
    let occurrences = rule.occurrences(start, 3)
    
    assert_eq(occurrences.len(), 3)?
    assert_eq(occurrences[0].day(), 15)?
    assert_eq(occurrences[1].month(), 2)?
}

test "first monday of month" {
    let rule = RecurrenceRule.first_weekday_of_month(Weekday.Monday)
    
    let start = DateTime.new(2024, 1, 1, 9, 0, 0)
    let occurrences = rule.occurrences(start, 3)
    
    for occ in occurrences.iter() {
        assert_eq(occ.weekday(), Weekday.Monday)?
        assert(occ.day() <= 7)?
    }
}

test "rrule serialization" {
    let rule = RecurrenceRule.weekly()
        .every(2)
        .on_days([ByDay.new(Weekday.Monday), ByDay.new(Weekday.Friday)])
        .times(10)
    
    let rrule = rule.to_rrule()
    assert(rrule.contains("FREQ=WEEKLY"))?
    assert(rrule.contains("INTERVAL=2"))?
    assert(rrule.contains("COUNT=10"))?
    assert(rrule.contains("BYDAY=MO,FR"))?
}

test "rrule parsing" {
    let rule = RecurrenceRule.parse("FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR;COUNT=10").unwrap()
    
    assert_eq(rule.frequency, Frequency.Weekly)?
    assert_eq(rule.interval, 2)?
    assert_eq(rule.count, Some(10))?
    assert_eq(rule.by_day.len(), 3)?
}

test "recurrence set with exclusions" {
    let set = RecurrenceSet.new()
        .with_rule(RecurrenceRule.daily())
        .exclude_date(DateTime.new(2024, 1, 3, 0, 0, 0))
    
    let start = DateTime.new(2024, 1, 1, 0, 0, 0)
    let occurrences = set.occurrences(start, 5)
    
    // Should skip Jan 3
    assert(!occurrences.iter().any(|d| d.day() == 3))?
}

test "describe recurrence" {
    let rule = RecurrenceRule.weekly()
        .every(2)
        .on_days([ByDay.new(Weekday.Monday)])
        .times(10)
    
    let desc = rule.describe()
    assert(desc.contains("Every 2 weeks"))?
    assert(desc.contains("Monday"))?
    assert(desc.contains("10 times"))?
}
