// =============================================================================
// Vibee OS ‚Äî Unicode Module
// Unicode utilities, normalization, and character properties
// =============================================================================

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const MAX_CODEPOINT: UInt32 = 0x10FFFF
const REPLACEMENT_CHAR: Char = '\u{FFFD}'
const BOM: Char = '\u{FEFF}'

// Surrogate range
const SURROGATE_MIN: UInt32 = 0xD800
const SURROGATE_MAX: UInt32 = 0xDFFF
const HIGH_SURROGATE_MIN: UInt32 = 0xD800
const HIGH_SURROGATE_MAX: UInt32 = 0xDBFF
const LOW_SURROGATE_MIN: UInt32 = 0xDC00
const LOW_SURROGATE_MAX: UInt32 = 0xDFFF

// -----------------------------------------------------------------------------
// Codepoint Operations
// -----------------------------------------------------------------------------

/// Get Unicode codepoint from character
fn codepoint(c: Char) -> UInt32 {
    c as UInt32
}

/// Create character from codepoint
fn from_codepoint(cp: UInt32) -> Option<Char> {
    if is_valid_codepoint(cp) {
        Char.from_u32(cp)
    } else {
        None
    }
}

/// Check if codepoint is valid Unicode
fn is_valid_codepoint(cp: UInt32) -> Bool {
    cp <= MAX_CODEPOINT && !is_surrogate(cp)
}

/// Check if codepoint is surrogate
fn is_surrogate(cp: UInt32) -> Bool {
    cp >= SURROGATE_MIN && cp <= SURROGATE_MAX
}

/// Check if codepoint is high surrogate
fn is_high_surrogate(cp: UInt32) -> Bool {
    cp >= HIGH_SURROGATE_MIN && cp <= HIGH_SURROGATE_MAX
}

/// Check if codepoint is low surrogate
fn is_low_surrogate(cp: UInt32) -> Bool {
    cp >= LOW_SURROGATE_MIN && cp <= LOW_SURROGATE_MAX
}

/// Format codepoint as U+XXXX
fn format_codepoint(cp: UInt32) -> String {
    if cp <= 0xFFFF {
        format!("U+{:04X}", cp)
    } else {
        format!("U+{:X}", cp)
    }
}

// -----------------------------------------------------------------------------
// Character Categories
// -----------------------------------------------------------------------------

enum GeneralCategory {
    UppercaseLetter    // Lu
    LowercaseLetter    // Ll
    TitlecaseLetter    // Lt
    ModifierLetter     // Lm
    OtherLetter        // Lo
    NonspacingMark     // Mn
    SpacingMark        // Mc
    EnclosingMark      // Me
    DecimalNumber      // Nd
    LetterNumber       // Nl
    OtherNumber        // No
    ConnectorPunct     // Pc
    DashPunct          // Pd
    OpenPunct          // Ps
    ClosePunct         // Pe
    InitialPunct       // Pi
    FinalPunct         // Pf
    OtherPunct         // Po
    MathSymbol         // Sm
    CurrencySymbol     // Sc
    ModifierSymbol     // Sk
    OtherSymbol        // So
    SpaceSeparator     // Zs
    LineSeparator      // Zl
    ParagraphSeparator // Zp
    Control            // Cc
    Format             // Cf
    Surrogate          // Cs
    PrivateUse         // Co
    Unassigned         // Cn
}

/// Get general category of character
fn category(c: Char) -> GeneralCategory {
    let cp = c as UInt32
    
    // Simplified category detection
    if cp < 0x20 || (cp >= 0x7F && cp < 0xA0) {
        GeneralCategory.Control
    } else if c.is_uppercase() {
        GeneralCategory.UppercaseLetter
    } else if c.is_lowercase() {
        GeneralCategory.LowercaseLetter
    } else if c.is_numeric() {
        GeneralCategory.DecimalNumber
    } else if c.is_whitespace() {
        GeneralCategory.SpaceSeparator
    } else if is_surrogate(cp) {
        GeneralCategory.Surrogate
    } else if cp >= 0xE000 && cp <= 0xF8FF {
        GeneralCategory.PrivateUse
    } else {
        GeneralCategory.OtherLetter
    }
}

// -----------------------------------------------------------------------------
// Character Properties
// -----------------------------------------------------------------------------

/// Check if character is letter
fn is_letter(c: Char) -> Bool {
    c.is_alphabetic()
}

/// Check if character is mark (combining)
fn is_mark(c: Char) -> Bool {
    let cp = c as UInt32
    (cp >= 0x0300 && cp <= 0x036F) ||  // Combining Diacritical Marks
    (cp >= 0x1AB0 && cp <= 0x1AFF) ||  // Combining Diacritical Marks Extended
    (cp >= 0x1DC0 && cp <= 0x1DFF) ||  // Combining Diacritical Marks Supplement
    (cp >= 0x20D0 && cp <= 0x20FF) ||  // Combining Diacritical Marks for Symbols
    (cp >= 0xFE20 && cp <= 0xFE2F)     // Combining Half Marks
}

/// Check if character is number
fn is_number(c: Char) -> Bool {
    c.is_numeric()
}

/// Check if character is punctuation
fn is_punctuation(c: Char) -> Bool {
    let cp = c as UInt32
    (cp >= 0x21 && cp <= 0x2F) ||
    (cp >= 0x3A && cp <= 0x40) ||
    (cp >= 0x5B && cp <= 0x60) ||
    (cp >= 0x7B && cp <= 0x7E) ||
    (cp >= 0x2000 && cp <= 0x206F)
}

/// Check if character is symbol
fn is_symbol(c: Char) -> Bool {
    let cp = c as UInt32
    (cp >= 0x2100 && cp <= 0x27FF) ||
    (cp >= 0x2900 && cp <= 0x2BFF)
}

/// Check if character is separator
fn is_separator(c: Char) -> Bool {
    c.is_whitespace()
}

/// Check if character is control
fn is_control(c: Char) -> Bool {
    let cp = c as UInt32
    cp < 0x20 || (cp >= 0x7F && cp < 0xA0)
}

/// Check if character is emoji
fn is_emoji(c: Char) -> Bool {
    let cp = c as UInt32
    (cp >= 0x1F600 && cp <= 0x1F64F) ||  // Emoticons
    (cp >= 0x1F300 && cp <= 0x1F5FF) ||  // Misc Symbols and Pictographs
    (cp >= 0x1F680 && cp <= 0x1F6FF) ||  // Transport and Map
    (cp >= 0x1F1E0 && cp <= 0x1F1FF) ||  // Flags
    (cp >= 0x2600 && cp <= 0x26FF) ||    // Misc symbols
    (cp >= 0x2700 && cp <= 0x27BF) ||    // Dingbats
    (cp >= 0x1F900 && cp <= 0x1F9FF)     // Supplemental Symbols
}

// -----------------------------------------------------------------------------
// Unicode Blocks
// -----------------------------------------------------------------------------

enum UnicodeBlock {
    BasicLatin
    Latin1Supplement
    LatinExtendedA
    LatinExtendedB
    Cyrillic
    Greek
    Arabic
    Hebrew
    CJKUnified
    Hiragana
    Katakana
    Hangul
    Emoji
    PrivateUse
    Other
}

/// Get Unicode block for character
fn block(c: Char) -> UnicodeBlock {
    let cp = c as UInt32
    
    match cp {
        0x0000..=0x007F => UnicodeBlock.BasicLatin
        0x0080..=0x00FF => UnicodeBlock.Latin1Supplement
        0x0100..=0x017F => UnicodeBlock.LatinExtendedA
        0x0180..=0x024F => UnicodeBlock.LatinExtendedB
        0x0400..=0x04FF => UnicodeBlock.Cyrillic
        0x0370..=0x03FF => UnicodeBlock.Greek
        0x0600..=0x06FF => UnicodeBlock.Arabic
        0x0590..=0x05FF => UnicodeBlock.Hebrew
        0x4E00..=0x9FFF => UnicodeBlock.CJKUnified
        0x3040..=0x309F => UnicodeBlock.Hiragana
        0x30A0..=0x30FF => UnicodeBlock.Katakana
        0xAC00..=0xD7AF => UnicodeBlock.Hangul
        0x1F600..=0x1F9FF => UnicodeBlock.Emoji
        0xE000..=0xF8FF => UnicodeBlock.PrivateUse
        _ => UnicodeBlock.Other
    }
}

// -----------------------------------------------------------------------------
// Case Conversion
// -----------------------------------------------------------------------------

/// Convert to uppercase
fn to_uppercase(s: String) -> String {
    s.to_uppercase()
}

/// Convert to lowercase
fn to_lowercase(s: String) -> String {
    s.to_lowercase()
}

/// Convert to titlecase
fn to_titlecase(s: String) -> String {
    var result = ""
    var capitalize_next = true
    
    for c in s.chars() {
        if c.is_whitespace() || is_punctuation(c) {
            result.push(c)
            capitalize_next = true
        } else if capitalize_next {
            result.push_str(c.to_uppercase())
            capitalize_next = false
        } else {
            result.push_str(c.to_lowercase())
        }
    }
    
    result
}

/// Case fold for case-insensitive comparison
fn case_fold(s: String) -> String {
    s.to_lowercase()
}

// -----------------------------------------------------------------------------
// Normalization (Simplified)
// -----------------------------------------------------------------------------

enum NormalizationForm {
    NFD   // Canonical Decomposition
    NFC   // Canonical Decomposition + Composition
    NFKD  // Compatibility Decomposition
    NFKC  // Compatibility Decomposition + Composition
}

/// Normalize string (simplified - removes combining marks)
fn normalize(s: String, form: NormalizationForm) -> String {
    match form {
        NFD | NFKD => decompose(s)
        NFC | NFKC => compose(decompose(s))
    }
}

fn decompose(s: String) -> String {
    // Simplified: just return as-is
    s
}

fn compose(s: String) -> String {
    // Simplified: remove combining marks
    s.chars().filter(|c| !is_mark(c)).collect()
}

/// Remove diacritics/accents
fn strip_diacritics(s: String) -> String {
    s.chars().filter(|c| !is_mark(c)).collect()
}

// -----------------------------------------------------------------------------
// Grapheme Clusters
// -----------------------------------------------------------------------------

/// Count grapheme clusters (user-perceived characters)
fn grapheme_count(s: String) -> Int {
    var count = 0
    var prev_was_mark = false
    
    for c in s.chars() {
        if is_mark(c) {
            prev_was_mark = true
        } else {
            count += 1
            prev_was_mark = false
        }
    }
    
    count
}

/// Split into grapheme clusters
fn graphemes(s: String) -> [String] {
    var result = []
    var current = ""
    
    for c in s.chars() {
        if is_mark(c) {
            current.push(c)
        } else {
            if !current.is_empty() {
                result.push(current)
            }
            current = c.to_string()
        }
    }
    
    if !current.is_empty() {
        result.push(current)
    }
    
    result
}

// -----------------------------------------------------------------------------
// Width Calculation
// -----------------------------------------------------------------------------

/// Get display width of character
fn char_width(c: Char) -> Int {
    let cp = c as UInt32
    
    if cp == 0 { 0 }
    else if is_control(c) { 0 }
    else if is_mark(c) { 0 }
    else if is_wide_char(c) { 2 }
    else { 1 }
}

/// Check if character is wide (CJK, etc.)
fn is_wide_char(c: Char) -> Bool {
    let cp = c as UInt32
    
    (cp >= 0x1100 && cp <= 0x115F) ||   // Hangul Jamo
    (cp >= 0x2E80 && cp <= 0x9FFF) ||   // CJK
    (cp >= 0xAC00 && cp <= 0xD7A3) ||   // Hangul Syllables
    (cp >= 0xF900 && cp <= 0xFAFF) ||   // CJK Compatibility
    (cp >= 0xFE10 && cp <= 0xFE1F) ||   // Vertical forms
    (cp >= 0xFF00 && cp <= 0xFF60) ||   // Fullwidth forms
    (cp >= 0x20000 && cp <= 0x2FFFF)    // CJK Extension B+
}

/// Get display width of string
fn string_width(s: String) -> Int {
    s.chars().map(|c| char_width(c)).sum()
}

// -----------------------------------------------------------------------------
// Bidirectional Text
// -----------------------------------------------------------------------------

enum BidiClass {
    LeftToRight
    RightToLeft
    ArabicLetter
    Neutral
}

/// Get bidirectional class
fn bidi_class(c: Char) -> BidiClass {
    let cp = c as UInt32
    
    if (cp >= 0x0600 && cp <= 0x06FF) || (cp >= 0x0750 && cp <= 0x077F) {
        BidiClass.ArabicLetter
    } else if (cp >= 0x0590 && cp <= 0x05FF) || (cp >= 0xFB1D && cp <= 0xFB4F) {
        BidiClass.RightToLeft
    } else if cp < 0x0590 {
        BidiClass.LeftToRight
    } else {
        BidiClass.Neutral
    }
}

/// Check if string contains RTL characters
fn has_rtl(s: String) -> Bool {
    s.chars().any(|c| {
        let bc = bidi_class(c)
        bc == BidiClass.RightToLeft || bc == BidiClass.ArabicLetter
    })
}

// -----------------------------------------------------------------------------
// Script Detection
// -----------------------------------------------------------------------------

enum Script {
    Latin
    Cyrillic
    Greek
    Arabic
    Hebrew
    Han
    Hiragana
    Katakana
    Hangul
    Common
    Unknown
}

/// Detect script of character
fn script(c: Char) -> Script {
    let cp = c as UInt32
    
    match cp {
        0x0041..=0x007A | 0x00C0..=0x024F => Script.Latin
        0x0400..=0x04FF => Script.Cyrillic
        0x0370..=0x03FF => Script.Greek
        0x0600..=0x06FF => Script.Arabic
        0x0590..=0x05FF => Script.Hebrew
        0x4E00..=0x9FFF => Script.Han
        0x3040..=0x309F => Script.Hiragana
        0x30A0..=0x30FF => Script.Katakana
        0xAC00..=0xD7AF => Script.Hangul
        0x0000..=0x0040 | 0x005B..=0x0060 => Script.Common
        _ => Script.Unknown
    }
}

/// Detect dominant script in string
fn detect_script(s: String) -> Script {
    var counts = Map.empty()
    
    for c in s.chars() {
        let sc = script(c)
        if sc != Script.Common && sc != Script.Unknown {
            let count = counts.get(sc).unwrap_or(0)
            counts.set(sc, count + 1)
        }
    }
    
    counts.iter()
        .max_by(|(_, a), (_, b)| a.cmp(b))
        .map(|(s, _)| s)
        .unwrap_or(Script.Unknown)
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum UnicodeError {
    InvalidCodepoint(UInt32)
    SurrogateCodepoint(UInt32)
    InvalidSequence
}

impl Display for UnicodeError {
    fn fmt(f: Formatter) {
        match self {
            InvalidCodepoint(cp) => f.write(format!("Invalid codepoint: U+{:04X}", cp))
            SurrogateCodepoint(cp) => f.write(format!("Surrogate codepoint: U+{:04X}", cp))
            InvalidSequence => f.write("Invalid Unicode sequence")
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "codepoint" {
    assert_eq(codepoint('A'), 0x41)?
    assert_eq(codepoint('Êó•'), 0x65E5)?
    assert_eq(format_codepoint(0x41), "U+0041")?
}

test "from_codepoint" {
    assert_eq(from_codepoint(0x41), Some('A'))?
    assert_eq(from_codepoint(0xD800), None)?  // Surrogate
}

test "is_valid_codepoint" {
    assert(is_valid_codepoint(0x41))?
    assert(is_valid_codepoint(0x10FFFF))?
    assert(!is_valid_codepoint(0x110000))?
    assert(!is_valid_codepoint(0xD800))?
}

test "is_emoji" {
    assert(is_emoji('üòÄ'))?
    assert(is_emoji('üéâ'))?
    assert(!is_emoji('A'))?
}

test "block" {
    assert_eq(block('A'), UnicodeBlock.BasicLatin)?
    assert_eq(block('Êó•'), UnicodeBlock.CJKUnified)?
    assert_eq(block('„ÅÇ'), UnicodeBlock.Hiragana)?
}

test "to_titlecase" {
    assert_eq(to_titlecase("hello world"), "Hello World")?
}

test "char_width" {
    assert_eq(char_width('A'), 1)?
    assert_eq(char_width('Êó•'), 2)?
    assert_eq(string_width("HelloÊó•Êú¨"), 9)?  // 5 + 2*2
}

test "script" {
    assert_eq(script('A'), Script.Latin)?
    assert_eq(script('–ë'), Script.Cyrillic)?
    assert_eq(script('Êó•'), Script.Han)?
}

test "has_rtl" {
    assert(!has_rtl("Hello"))?
    assert(has_rtl("◊©◊ú◊ï◊ù"))?
    assert(has_rtl("ŸÖÿ±ÿ≠ÿ®ÿß"))?
}
