// =============================================================================
// Vibee OS â€” Availability Module
// Availability management for scheduling and booking
// =============================================================================

use datetime::{DateTime, Duration, Weekday}
use uuid::{UUID}

// =============================================================================
// Availability Types & Enums
// =============================================================================

enum AvailabilityStatus { Available, Busy, Tentative, OutOfOffice }
enum BlockReason { Meeting, Personal, Holiday, Sick, Travel, Focus, Other }
enum ScheduleType { Regular, Override, Exception }

// =============================================================================
// Time Slot
// =============================================================================

struct TimeSlot {
    start: DateTime
    end: DateTime
    status: AvailabilityStatus
    label: Option<String>
}

impl TimeSlot {
    fn new(start: DateTime, end: DateTime) -> Self {
        TimeSlot {
            start: start,
            end: end,
            status: AvailabilityStatus.Available,
            label: None
        }
    }
    
    fn available(start: DateTime, end: DateTime) -> Self {
        TimeSlot.new(start, end)
    }
    
    fn busy(start: DateTime, end: DateTime) -> Self {
        var slot = TimeSlot.new(start, end)
        slot.status = AvailabilityStatus.Busy
        slot
    }
    
    fn with_label(l: String) -> Self { self.label = Some(l); self }
    fn with_status(s: AvailabilityStatus) -> Self { self.status = s; self }
    
    fn duration() -> Duration {
        self.end.diff(self.start)
    }
    
    fn duration_minutes() -> Int {
        self.duration().as_minutes() as Int
    }
    
    fn contains(dt: DateTime) -> Bool {
        (dt.is_after(self.start) || dt.is_same(self.start)) &&
        dt.is_before(self.end)
    }
    
    fn overlaps(other: TimeSlot) -> Bool {
        self.start.is_before(other.end) && self.end.is_after(other.start)
    }
    
    fn is_available() -> Bool {
        self.status == AvailabilityStatus.Available
    }
    
    fn split_at(dt: DateTime) -> Option<(TimeSlot, TimeSlot)> {
        if !self.contains(dt) { return None }
        
        let first = TimeSlot {
            start: self.start,
            end: dt,
            status: self.status,
            label: self.label.clone()
        }
        
        let second = TimeSlot {
            start: dt,
            end: self.end,
            status: self.status,
            label: self.label.clone()
        }
        
        Some((first, second))
    }
    
    fn merge(other: TimeSlot) -> Option<TimeSlot> {
        if self.status != other.status { return None }
        if !self.end.is_same(other.start) && !self.overlaps(other) { return None }
        
        Some(TimeSlot {
            start: if self.start.is_before(other.start) { self.start } else { other.start },
            end: if self.end.is_after(other.end) { self.end } else { other.end },
            status: self.status,
            label: self.label.clone()
        })
    }
}

// =============================================================================
// Working Hours
// =============================================================================

struct WorkingHours {
    weekday: Weekday
    start_time: Time
    end_time: Time
    is_working_day: Bool
}

struct Time {
    hour: Int
    minute: Int
}

impl Time {
    fn new(hour: Int, minute: Int) -> Self {
        Time { hour: hour, minute: minute }
    }
    
    fn from_string(s: String) -> Result<Self, AvailabilityError> {
        let parts = s.split(":")
        if parts.len() != 2 {
            return Err(AvailabilityError.InvalidTimeFormat)
        }
        
        let hour = Int.parse(parts[0]).map_err(|_| AvailabilityError.InvalidTimeFormat)?
        let minute = Int.parse(parts[1]).map_err(|_| AvailabilityError.InvalidTimeFormat)?
        
        if hour < 0 || hour > 23 || minute < 0 || minute > 59 {
            return Err(AvailabilityError.InvalidTimeFormat)
        }
        
        Ok(Time { hour: hour, minute: minute })
    }
    
    fn to_string() -> String {
        format!("{:02}:{:02}", self.hour, self.minute)
    }
    
    fn to_minutes() -> Int {
        self.hour * 60 + self.minute
    }
    
    fn is_before(other: Time) -> Bool {
        self.to_minutes() < other.to_minutes()
    }
    
    fn is_after(other: Time) -> Bool {
        self.to_minutes() > other.to_minutes()
    }
}

impl WorkingHours {
    fn new(weekday: Weekday, start: Time, end: Time) -> Self {
        WorkingHours {
            weekday: weekday,
            start_time: start,
            end_time: end,
            is_working_day: true
        }
    }
    
    fn day_off(weekday: Weekday) -> Self {
        WorkingHours {
            weekday: weekday,
            start_time: Time.new(0, 0),
            end_time: Time.new(0, 0),
            is_working_day: false
        }
    }
    
    fn standard_day(weekday: Weekday) -> Self {
        WorkingHours.new(weekday, Time.new(9, 0), Time.new(17, 0))
    }
    
    fn duration_minutes() -> Int {
        if !self.is_working_day { return 0 }
        self.end_time.to_minutes() - self.start_time.to_minutes()
    }
}

// =============================================================================
// Weekly Schedule
// =============================================================================

struct WeeklySchedule {
    id: String
    name: String
    timezone: String
    hours: Map<Weekday, WorkingHours>
    breaks: [BreakPeriod]
}

struct BreakPeriod {
    name: String
    start_time: Time
    end_time: Time
    weekdays: [Weekday]
}

impl BreakPeriod {
    fn lunch(start: Time, end: Time) -> Self {
        BreakPeriod {
            name: "Lunch",
            start_time: start,
            end_time: end,
            weekdays: [Weekday.Monday, Weekday.Tuesday, Weekday.Wednesday, Weekday.Thursday, Weekday.Friday]
        }
    }
    
    fn on_days(days: [Weekday]) -> Self { self.weekdays = days; self }
}

impl WeeklySchedule {
    fn new(name: String) -> Self {
        WeeklySchedule {
            id: UUID.v4().to_string(),
            name: name,
            timezone: "UTC",
            hours: Map.empty(),
            breaks: []
        }
    }
    
    fn standard_business_hours() -> Self {
        var schedule = WeeklySchedule.new("Standard Business Hours")
        
        // Monday to Friday: 9 AM - 5 PM
        for day in [Weekday.Monday, Weekday.Tuesday, Weekday.Wednesday, Weekday.Thursday, Weekday.Friday] {
            schedule.hours.insert(day, WorkingHours.standard_day(day))
        }
        
        // Weekend off
        schedule.hours.insert(Weekday.Saturday, WorkingHours.day_off(Weekday.Saturday))
        schedule.hours.insert(Weekday.Sunday, WorkingHours.day_off(Weekday.Sunday))
        
        schedule
    }
    
    fn with_timezone(tz: String) -> Self { self.timezone = tz; self }
    
    fn set_hours(weekday: Weekday, hours: WorkingHours) -> Self {
        self.hours.insert(weekday, hours)
        self
    }
    
    fn add_break(break_period: BreakPeriod) -> Self {
        self.breaks.push(break_period)
        self
    }
    
    fn is_working_day(weekday: Weekday) -> Bool {
        self.hours.get(weekday).map(|h| h.is_working_day).unwrap_or(false)
    }
    
    fn get_working_hours(weekday: Weekday) -> Option<WorkingHours> {
        self.hours.get(weekday).filter(|h| h.is_working_day)
    }
    
    fn total_weekly_hours() -> Float {
        var total = 0
        for (_, hours) in self.hours.iter() {
            total += hours.duration_minutes()
        }
        total as Float / 60.0
    }
    
    fn get_available_slots(date: DateTime, slot_duration: Duration) -> [TimeSlot] {
        let weekday = date.weekday()
        
        let working_hours = match self.get_working_hours(weekday) {
            Some(h) => h
            None => return []
        }
        
        var slots = []
        var current = date.with_time(working_hours.start_time.hour, working_hours.start_time.minute, 0)
        let end = date.with_time(working_hours.end_time.hour, working_hours.end_time.minute, 0)
        
        while current.add(slot_duration).is_before(end) || current.add(slot_duration).is_same(end) {
            let slot_end = current.add(slot_duration)
            
            // Check if slot overlaps with any break
            var is_break = false
            for break_period in self.breaks.iter() {
                if !break_period.weekdays.contains(weekday) { continue }
                
                let break_start = date.with_time(break_period.start_time.hour, break_period.start_time.minute, 0)
                let break_end = date.with_time(break_period.end_time.hour, break_period.end_time.minute, 0)
                
                if current.is_before(break_end) && slot_end.is_after(break_start) {
                    is_break = true
                    break
                }
            }
            
            if !is_break {
                slots.push(TimeSlot.available(current, slot_end))
            }
            
            current = slot_end
        }
        
        slots
    }
}

// =============================================================================
// Availability Block
// =============================================================================

struct AvailabilityBlock {
    id: String
    user_id: String
    start_time: DateTime
    end_time: DateTime
    status: AvailabilityStatus
    reason: Option<BlockReason>
    title: Option<String>
    description: Option<String>
    is_recurring: Bool
    recurrence_rule: Option<String>
    created_at: DateTime
}

impl AvailabilityBlock {
    fn new(user_id: String, start: DateTime, end: DateTime, status: AvailabilityStatus) -> Self {
        AvailabilityBlock {
            id: UUID.v4().to_string(),
            user_id: user_id,
            start_time: start,
            end_time: end,
            status: status,
            reason: None,
            title: None,
            description: None,
            is_recurring: false,
            recurrence_rule: None,
            created_at: DateTime.now()
        }
    }
    
    fn busy(user_id: String, start: DateTime, end: DateTime) -> Self {
        AvailabilityBlock.new(user_id, start, end, AvailabilityStatus.Busy)
    }
    
    fn available(user_id: String, start: DateTime, end: DateTime) -> Self {
        AvailabilityBlock.new(user_id, start, end, AvailabilityStatus.Available)
    }
    
    fn out_of_office(user_id: String, start: DateTime, end: DateTime) -> Self {
        AvailabilityBlock.new(user_id, start, end, AvailabilityStatus.OutOfOffice)
    }
    
    fn with_reason(r: BlockReason) -> Self { self.reason = Some(r); self }
    fn with_title(t: String) -> Self { self.title = Some(t); self }
    fn with_description(d: String) -> Self { self.description = Some(d); self }
    fn with_recurrence(rule: String) -> Self {
        self.is_recurring = true
        self.recurrence_rule = Some(rule)
        self
    }
    
    fn duration() -> Duration {
        self.end_time.diff(self.start_time)
    }
    
    fn overlaps(other: AvailabilityBlock) -> Bool {
        self.start_time.is_before(other.end_time) && self.end_time.is_after(other.start_time)
    }
    
    fn contains(dt: DateTime) -> Bool {
        (dt.is_after(self.start_time) || dt.is_same(self.start_time)) &&
        dt.is_before(self.end_time)
    }
}

// =============================================================================
// User Availability
// =============================================================================

struct UserAvailability {
    user_id: String
    schedule: WeeklySchedule
    blocks: [AvailabilityBlock]
    buffer_before: Duration
    buffer_after: Duration
    min_notice: Duration
    max_days_ahead: Int
}

impl UserAvailability {
    fn new(user_id: String) -> Self {
        UserAvailability {
            user_id: user_id,
            schedule: WeeklySchedule.standard_business_hours(),
            blocks: [],
            buffer_before: Duration.minutes(0),
            buffer_after: Duration.minutes(0),
            min_notice: Duration.hours(1),
            max_days_ahead: 60
        }
    }
    
    fn with_schedule(s: WeeklySchedule) -> Self { self.schedule = s; self }
    fn with_buffer_before(d: Duration) -> Self { self.buffer_before = d; self }
    fn with_buffer_after(d: Duration) -> Self { self.buffer_after = d; self }
    fn with_min_notice(d: Duration) -> Self { self.min_notice = d; self }
    fn with_max_days_ahead(n: Int) -> Self { self.max_days_ahead = n; self }
    
    fn add_block(block: AvailabilityBlock) -> Self {
        self.blocks.push(block)
        self
    }
    
    fn remove_block(block_id: String) -> Self {
        self.blocks.retain(|b| b.id != block_id)
        self
    }
    
    fn is_available_at(dt: DateTime) -> Bool {
        // Check minimum notice
        if dt.diff(DateTime.now()).as_hours() < self.min_notice.as_hours() {
            return false
        }
        
        // Check max days ahead
        if dt.diff(DateTime.now()).as_days() > self.max_days_ahead as Float {
            return false
        }
        
        // Check if within working hours
        let weekday = dt.weekday()
        let working_hours = match self.schedule.get_working_hours(weekday) {
            Some(h) => h
            None => return false
        }
        
        let time = Time.new(dt.hour(), dt.minute())
        if time.is_before(working_hours.start_time) || time.is_after(working_hours.end_time) {
            return false
        }
        
        // Check blocks
        for block in self.blocks.iter() {
            if block.contains(dt) && block.status != AvailabilityStatus.Available {
                return false
            }
        }
        
        true
    }
    
    fn get_available_slots(date: DateTime, slot_duration: Duration) -> [TimeSlot] {
        var slots = self.schedule.get_available_slots(date, slot_duration)
        
        // Filter out slots that overlap with busy blocks
        slots.retain(|slot| {
            for block in self.blocks.iter() {
                if block.status != AvailabilityStatus.Available {
                    let block_slot = TimeSlot.new(block.start_time, block.end_time)
                    if slot.overlaps(block_slot) {
                        return false
                    }
                }
            }
            true
        })
        
        // Apply buffers
        if self.buffer_before.as_minutes() > 0 || self.buffer_after.as_minutes() > 0 {
            slots = slots.iter().map(|slot| {
                TimeSlot.new(
                    slot.start.add(self.buffer_before),
                    slot.end.sub(self.buffer_after)
                )
            }).filter(|slot| slot.duration().as_minutes() >= slot_duration.as_minutes()).collect()
        }
        
        // Filter by minimum notice
        let min_start = DateTime.now().add(self.min_notice)
        slots.retain(|slot| slot.start.is_after(min_start) || slot.start.is_same(min_start))
        
        slots
    }
    
    fn get_busy_times(start: DateTime, end: DateTime) -> [TimeSlot] {
        self.blocks.iter()
            .filter(|b| b.status != AvailabilityStatus.Available)
            .filter(|b| b.start_time.is_before(end) && b.end_time.is_after(start))
            .map(|b| TimeSlot.busy(b.start_time, b.end_time).with_label(b.title.clone().unwrap_or("Busy")))
            .collect()
    }
    
    fn find_next_available(duration: Duration, after: DateTime) -> Option<TimeSlot> {
        var current = after
        let max_date = after.add(Duration.days(self.max_days_ahead as Int64))
        
        while current.is_before(max_date) {
            let slots = self.get_available_slots(current, duration)
            
            for slot in slots.iter() {
                if slot.start.is_after(after) || slot.start.is_same(after) {
                    return Some(slot.clone())
                }
            }
            
            current = current.add(Duration.days(1)).start_of_day()
        }
        
        None
    }
}

// =============================================================================
// Availability Service
// =============================================================================

actor AvailabilityService {
    state user_availability: Map<String, UserAvailability>
    state schedules: Map<String, WeeklySchedule>
    
    fn new() -> Self {
        AvailabilityService {
            user_availability: Map.empty(),
            schedules: Map.empty()
        }
    }
    
    fn set_user_availability(availability: UserAvailability) {
        self.user_availability.insert(availability.user_id.clone(), availability)
    }
    
    fn get_user_availability(user_id: String) -> Option<UserAvailability> {
        self.user_availability.get(user_id)
    }
    
    fn add_block(user_id: String, block: AvailabilityBlock) -> Result<(), AvailabilityError> {
        let availability = self.user_availability.get_mut(user_id.clone())
            .ok_or(AvailabilityError.UserNotFound)?
        
        availability.add_block(block)
        Ok(())
    }
    
    fn remove_block(user_id: String, block_id: String) -> Result<(), AvailabilityError> {
        let availability = self.user_availability.get_mut(user_id.clone())
            .ok_or(AvailabilityError.UserNotFound)?
        
        availability.remove_block(block_id)
        Ok(())
    }
    
    fn check_availability(user_id: String, start: DateTime, end: DateTime) -> Result<Bool, AvailabilityError> {
        let availability = self.user_availability.get(user_id.clone())
            .ok_or(AvailabilityError.UserNotFound)?
        
        // Check every 15 minutes in the range
        var current = start
        while current.is_before(end) {
            if !availability.is_available_at(current) {
                return Ok(false)
            }
            current = current.add(Duration.minutes(15))
        }
        
        Ok(true)
    }
    
    fn get_available_slots(user_id: String, date: DateTime, duration: Duration) -> Result<[TimeSlot], AvailabilityError> {
        let availability = self.user_availability.get(user_id.clone())
            .ok_or(AvailabilityError.UserNotFound)?
        
        Ok(availability.get_available_slots(date, duration))
    }
    
    fn find_common_availability(user_ids: [String], date: DateTime, duration: Duration) -> [TimeSlot] {
        if user_ids.is_empty() { return [] }
        
        // Get slots for first user
        var common_slots = match self.user_availability.get(user_ids[0].clone()) {
            Some(a) => a.get_available_slots(date, duration)
            None => return []
        }
        
        // Intersect with other users' slots
        for user_id in user_ids.iter().skip(1) {
            if let Some(availability) = self.user_availability.get(user_id.clone()) {
                let user_slots = availability.get_available_slots(date, duration)
                common_slots = intersect_slots(common_slots, user_slots)
            }
        }
        
        common_slots
    }
    
    fn find_next_common_slot(user_ids: [String], duration: Duration, after: DateTime) -> Option<TimeSlot> {
        var current = after
        let max_date = after.add(Duration.days(60))
        
        while current.is_before(max_date) {
            let slots = self.find_common_availability(user_ids.clone(), current, duration)
            
            for slot in slots.iter() {
                if slot.start.is_after(after) || slot.start.is_same(after) {
                    return Some(slot.clone())
                }
            }
            
            current = current.add(Duration.days(1)).start_of_day()
        }
        
        None
    }
    
    fn save_schedule(schedule: WeeklySchedule) {
        self.schedules.insert(schedule.id.clone(), schedule)
    }
    
    fn get_schedule(id: String) -> Option<WeeklySchedule> {
        self.schedules.get(id)
    }
}

fn intersect_slots(a: [TimeSlot], b: [TimeSlot]) -> [TimeSlot] {
    var result = []
    
    for slot_a in a.iter() {
        for slot_b in b.iter() {
            if slot_a.overlaps(slot_b.clone()) {
                let start = if slot_a.start.is_after(slot_b.start) { slot_a.start } else { slot_b.start }
                let end = if slot_a.end.is_before(slot_b.end) { slot_a.end } else { slot_b.end }
                
                if start.is_before(end) {
                    result.push(TimeSlot.available(start, end))
                }
            }
        }
    }
    
    result
}

// =============================================================================
// Errors
// =============================================================================

enum AvailabilityError {
    UserNotFound
    InvalidTimeFormat
    InvalidTimeRange
    SlotNotAvailable
    OverlappingBlock
}

impl Display for AvailabilityError {
    fn fmt(f: Formatter) {
        match self {
            UserNotFound => f.write("User not found")
            InvalidTimeFormat => f.write("Invalid time format")
            InvalidTimeRange => f.write("Invalid time range")
            SlotNotAvailable => f.write("Time slot not available")
            OverlappingBlock => f.write("Overlapping availability block")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "time slot creation" {
    let start = DateTime.new(2024, 1, 15, 9, 0, 0)
    let end = DateTime.new(2024, 1, 15, 10, 0, 0)
    let slot = TimeSlot.available(start, end)
    
    assert_eq(slot.duration_minutes(), 60)?
    assert(slot.is_available())?
}

test "time slot overlap" {
    let slot1 = TimeSlot.new(
        DateTime.new(2024, 1, 15, 9, 0, 0),
        DateTime.new(2024, 1, 15, 11, 0, 0)
    )
    let slot2 = TimeSlot.new(
        DateTime.new(2024, 1, 15, 10, 0, 0),
        DateTime.new(2024, 1, 15, 12, 0, 0)
    )
    let slot3 = TimeSlot.new(
        DateTime.new(2024, 1, 15, 12, 0, 0),
        DateTime.new(2024, 1, 15, 13, 0, 0)
    )
    
    assert(slot1.overlaps(slot2))?
    assert(!slot1.overlaps(slot3))?
}

test "weekly schedule" {
    let schedule = WeeklySchedule.standard_business_hours()
    
    assert(schedule.is_working_day(Weekday.Monday))?
    assert(!schedule.is_working_day(Weekday.Saturday))?
    assert_eq(schedule.total_weekly_hours(), 40.0)?
}

test "user availability" {
    let availability = UserAvailability.new("user1")
        .with_min_notice(Duration.hours(1))
        .with_buffer_before(Duration.minutes(5))
    
    let tomorrow = DateTime.now().add(Duration.days(1)).start_of_day().add(Duration.hours(10))
    
    // Should be available during working hours
    if tomorrow.weekday().is_weekday() {
        assert(availability.is_available_at(tomorrow))?
    }
}

test "availability service" {
    let svc = AvailabilityService.new()
    
    svc.set_user_availability(UserAvailability.new("user1"))
    svc.set_user_availability(UserAvailability.new("user2"))
    
    let tomorrow = DateTime.now().add(Duration.days(1)).start_of_day()
    let slots = svc.find_common_availability(["user1", "user2"], tomorrow, Duration.hours(1))
    
    // Should find common slots on a weekday
    if tomorrow.weekday().is_weekday() {
        assert(!slots.is_empty())?
    }
}

test "time parsing" {
    let time = Time.from_string("14:30").unwrap()
    assert_eq(time.hour, 14)?
    assert_eq(time.minute, 30)?
    assert_eq(time.to_minutes(), 870)?
}
