// =============================================================================
// Vibee OS â€” RNG Module
// Random Number Generators
// =============================================================================

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

/// Default seed for reproducible sequences
const DEFAULT_SEED: UInt64 = 0xDEADBEEF_CAFEBABE

// -----------------------------------------------------------------------------
// RNG Trait
// -----------------------------------------------------------------------------

/// Base trait for all random number generators
trait Rng {
    /// Generate next random UInt64
    fn next_u64() -> UInt64
    
    /// Generate next random UInt32
    fn next_u32() -> UInt32 {
        (self.next_u64() >> 32) as UInt32
    }
    
    /// Generate random float in [0, 1)
    fn next_float() -> Float {
        (self.next_u64() >> 11) as Float * (1.0 / 9007199254740992.0)
    }
    
    /// Generate random float in [0, 1]
    fn next_float_inclusive() -> Float {
        (self.next_u64() >> 11) as Float * (1.0 / 9007199254740991.0)
    }
    
    /// Generate random bool
    fn next_bool() -> Bool {
        self.next_u64() & 1 == 1
    }
    
    /// Generate random bool with probability p
    fn next_bool_with_prob(p: Float) -> Bool {
        self.next_float() < p
    }
    
    /// Generate random Int in range [min, max)
    fn next_range(min: Int, max: Int) -> Int {
        if min >= max { return min }
        let range = (max - min) as UInt64
        min + (self.next_u64() % range) as Int
    }
    
    /// Generate random Int in range [min, max]
    fn next_range_inclusive(min: Int, max: Int) -> Int {
        self.next_range(min, max + 1)
    }
    
    /// Generate random Float in range [min, max)
    fn next_float_range(min: Float, max: Float) -> Float {
        min + self.next_float() * (max - min)
    }
    
    /// Fill buffer with random bytes
    fn fill_bytes(buf: [UInt8]) {
        var i = 0
        while i < buf.len() {
            let val = self.next_u64()
            for j in 0..8 {
                if i + j >= buf.len() { break }
                buf[i + j] = ((val >> (j * 8)) & 0xFF) as UInt8
            }
            i += 8
        }
    }
    
    /// Generate random bytes
    fn bytes(n: Int) -> [UInt8] {
        var buf = [0u8; n]
        self.fill_bytes(buf)
        buf
    }
}

// -----------------------------------------------------------------------------
// Xorshift64 - Fast, simple PRNG
// -----------------------------------------------------------------------------

/// Xorshift64 random number generator
/// Fast and simple, good for games and simulations
struct Xorshift64 {
    state: UInt64
    
    fn new(seed: UInt64) -> Self {
        let s = if seed == 0 { DEFAULT_SEED } else { seed }
        Xorshift64 { state: s }
    }
    
    fn from_time() -> Self {
        Self.new(@native("time_nanos") as UInt64)
    }
}

impl Rng for Xorshift64 {
    fn next_u64() -> UInt64 {
        var x = self.state
        x ^= x << 13
        x ^= x >> 7
        x ^= x << 17
        self.state = x
        x
    }
}

// -----------------------------------------------------------------------------
// Xorshift128+ - High quality, fast PRNG
// -----------------------------------------------------------------------------

/// Xorshift128+ random number generator
/// Better statistical properties than Xorshift64
struct Xorshift128Plus {
    state0: UInt64
    state1: UInt64
    
    fn new(seed: UInt64) -> Self {
        let s = if seed == 0 { DEFAULT_SEED } else { seed }
        // Initialize with splitmix64 to spread the seed
        var sm = SplitMix64.new(s)
        Xorshift128Plus {
            state0: sm.next_u64(),
            state1: sm.next_u64()
        }
    }
    
    fn from_time() -> Self {
        Self.new(@native("time_nanos") as UInt64)
    }
}

impl Rng for Xorshift128Plus {
    fn next_u64() -> UInt64 {
        var s1 = self.state0
        let s0 = self.state1
        let result = s0 + s1
        self.state0 = s0
        s1 ^= s1 << 23
        self.state1 = s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5)
        result
    }
}

// -----------------------------------------------------------------------------
// Xoshiro256** - State of the art PRNG
// -----------------------------------------------------------------------------

/// Xoshiro256** random number generator
/// Excellent statistical properties, recommended for most uses
struct Xoshiro256StarStar {
    s0: UInt64
    s1: UInt64
    s2: UInt64
    s3: UInt64
    
    fn new(seed: UInt64) -> Self {
        let s = if seed == 0 { DEFAULT_SEED } else { seed }
        var sm = SplitMix64.new(s)
        Xoshiro256StarStar {
            s0: sm.next_u64(),
            s1: sm.next_u64(),
            s2: sm.next_u64(),
            s3: sm.next_u64()
        }
    }
    
    fn from_time() -> Self {
        Self.new(@native("time_nanos") as UInt64)
    }
    
    /// Jump function - equivalent to 2^128 calls to next()
    fn jump() {
        let jump_table: [UInt64; 4] = [
            0x180ec6d33cfd0aba, 0xd5a61266f0c9392c,
            0xa9582618e03fc9aa, 0x39abdc4529b1661c
        ]
        
        var s0: UInt64 = 0
        var s1: UInt64 = 0
        var s2: UInt64 = 0
        var s3: UInt64 = 0
        
        for jmp in jump_table {
            for b in 0..64 {
                if (jmp >> b) & 1 != 0 {
                    s0 ^= self.s0
                    s1 ^= self.s1
                    s2 ^= self.s2
                    s3 ^= self.s3
                }
                self.next_u64()
            }
        }
        
        self.s0 = s0
        self.s1 = s1
        self.s2 = s2
        self.s3 = s3
    }
    
    /// Long jump - equivalent to 2^192 calls to next()
    fn long_jump() {
        let jump_table: [UInt64; 4] = [
            0x76e15d3efefdcbbf, 0xc5004e441c522fb3,
            0x77710069854ee241, 0x39109bb02acbe635
        ]
        
        var s0: UInt64 = 0
        var s1: UInt64 = 0
        var s2: UInt64 = 0
        var s3: UInt64 = 0
        
        for jmp in jump_table {
            for b in 0..64 {
                if (jmp >> b) & 1 != 0 {
                    s0 ^= self.s0
                    s1 ^= self.s1
                    s2 ^= self.s2
                    s3 ^= self.s3
                }
                self.next_u64()
            }
        }
        
        self.s0 = s0
        self.s1 = s1
        self.s2 = s2
        self.s3 = s3
    }
}

impl Rng for Xoshiro256StarStar {
    fn next_u64() -> UInt64 {
        let result = rotl(self.s1 * 5, 7) * 9
        let t = self.s1 << 17
        
        self.s2 ^= self.s0
        self.s3 ^= self.s1
        self.s1 ^= self.s2
        self.s0 ^= self.s3
        self.s2 ^= t
        self.s3 = rotl(self.s3, 45)
        
        result
    }
}

// -----------------------------------------------------------------------------
// SplitMix64 - Seeding helper
// -----------------------------------------------------------------------------

/// SplitMix64 - used for seeding other generators
struct SplitMix64 {
    state: UInt64
    
    fn new(seed: UInt64) -> Self {
        SplitMix64 { state: seed }
    }
}

impl Rng for SplitMix64 {
    fn next_u64() -> UInt64 {
        self.state += 0x9e3779b97f4a7c15
        var z = self.state
        z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9
        z = (z ^ (z >> 27)) * 0x94d049bb133111eb
        z ^ (z >> 31)
    }
}

// -----------------------------------------------------------------------------
// PCG32 - Permuted Congruential Generator
// -----------------------------------------------------------------------------

/// PCG32 random number generator
/// Excellent statistical properties with small state
struct Pcg32 {
    state: UInt64
    inc: UInt64
    
    fn new(seed: UInt64, seq: UInt64) -> Self {
        var rng = Pcg32 { state: 0, inc: (seq << 1) | 1 }
        rng.next_u32()
        rng.state += seed
        rng.next_u32()
        rng
    }
    
    fn from_seed(seed: UInt64) -> Self {
        Self.new(seed, 0xda3e39cb94b95bdb)
    }
    
    fn from_time() -> Self {
        Self.from_seed(@native("time_nanos") as UInt64)
    }
}

impl Rng for Pcg32 {
    fn next_u64() -> UInt64 {
        (self.next_u32() as UInt64) << 32 | self.next_u32() as UInt64
    }
    
    fn next_u32() -> UInt32 {
        let old_state = self.state
        self.state = old_state * 6364136223846793005 + self.inc
        let xorshifted = (((old_state >> 18) ^ old_state) >> 27) as UInt32
        let rot = (old_state >> 59) as Int
        (xorshifted >> rot) | (xorshifted << ((-rot) & 31))
    }
}

// -----------------------------------------------------------------------------
// Mersenne Twister (MT19937-64)
// -----------------------------------------------------------------------------

/// Mersenne Twister 64-bit
/// Classic PRNG with very long period (2^19937 - 1)
struct MersenneTwister {
    mt: [UInt64; 312]
    mti: Int
    
    fn new(seed: UInt64) -> Self {
        var rng = MersenneTwister {
            mt: [0u64; 312],
            mti: 313
        }
        rng.mt[0] = seed
        for i in 1..312 {
            rng.mt[i] = 6364136223846793005 * (rng.mt[i-1] ^ (rng.mt[i-1] >> 62)) + i as UInt64
        }
        rng
    }
    
    fn from_time() -> Self {
        Self.new(@native("time_nanos") as UInt64)
    }
    
    fn twist() {
        const LOWER_MASK: UInt64 = 0x7FFFFFFF
        const UPPER_MASK: UInt64 = !LOWER_MASK
        const MATRIX_A: UInt64 = 0xB5026F5AA96619E9
        
        for i in 0..312 {
            let x = (self.mt[i] & UPPER_MASK) | (self.mt[(i + 1) % 312] & LOWER_MASK)
            var xa = x >> 1
            if x & 1 != 0 { xa ^= MATRIX_A }
            self.mt[i] = self.mt[(i + 156) % 312] ^ xa
        }
        self.mti = 0
    }
}

impl Rng for MersenneTwister {
    fn next_u64() -> UInt64 {
        if self.mti >= 312 { self.twist() }
        
        var y = self.mt[self.mti]
        self.mti += 1
        
        y ^= (y >> 29) & 0x5555555555555555
        y ^= (y << 17) & 0x71D67FFFEDA60000
        y ^= (y << 37) & 0xFFF7EEE000000000
        y ^= y >> 43
        
        y
    }
}

// -----------------------------------------------------------------------------
// Linear Congruential Generator (LCG)
// -----------------------------------------------------------------------------

/// Simple Linear Congruential Generator
/// Fast but lower quality, use for non-critical applications
struct Lcg {
    state: UInt64
    
    fn new(seed: UInt64) -> Self {
        Lcg { state: if seed == 0 { DEFAULT_SEED } else { seed } }
    }
    
    fn from_time() -> Self {
        Self.new(@native("time_nanos") as UInt64)
    }
}

impl Rng for Lcg {
    fn next_u64() -> UInt64 {
        // MMIX LCG parameters by Donald Knuth
        self.state = self.state * 6364136223846793005 + 1442695040888963407
        self.state
    }
}

// -----------------------------------------------------------------------------
// WELL512 - Well Equidistributed Long-period Linear
// -----------------------------------------------------------------------------

/// WELL512 random number generator
/// Good statistical properties with moderate state size
struct Well512 {
    state: [UInt32; 16]
    index: Int
    
    fn new(seed: UInt64) -> Self {
        var rng = Well512 {
            state: [0u32; 16],
            index: 0
        }
        var sm = SplitMix64.new(seed)
        for i in 0..16 {
            rng.state[i] = sm.next_u32()
        }
        rng
    }
    
    fn from_time() -> Self {
        Self.new(@native("time_nanos") as UInt64)
    }
}

impl Rng for Well512 {
    fn next_u64() -> UInt64 {
        (self.next_u32() as UInt64) << 32 | self.next_u32() as UInt64
    }
    
    fn next_u32() -> UInt32 {
        var a = self.state[self.index]
        var c = self.state[(self.index + 13) & 15]
        var b = a ^ c ^ (a << 16) ^ (c << 15)
        c = self.state[(self.index + 9) & 15]
        c ^= c >> 11
        a = self.state[self.index] = b ^ c
        var d = a ^ ((a << 5) & 0xDA442D24)
        self.index = (self.index + 15) & 15
        a = self.state[self.index]
        self.state[self.index] = a ^ b ^ d ^ (a << 2) ^ (b << 18) ^ (c << 28)
        self.state[self.index]
    }
}

// -----------------------------------------------------------------------------
// Cryptographically Secure RNG
// -----------------------------------------------------------------------------

/// Cryptographically secure random number generator
/// Uses system entropy source
struct SecureRng {}

impl SecureRng {
    fn new() -> Self { SecureRng {} }
}

impl Rng for SecureRng {
    fn next_u64() -> UInt64 {
        @native("crypto_random_u64")
    }
    
    fn next_u32() -> UInt32 {
        @native("crypto_random_u32")
    }
    
    fn fill_bytes(buf: [UInt8]) {
        @native("crypto_random_fill", buf)
    }
}

// -----------------------------------------------------------------------------
// Thread-local RNG
// -----------------------------------------------------------------------------

/// Thread-local random number generator
actor ThreadRng {
    rng: Xoshiro256StarStar
    
    fn new() -> Self {
        ThreadRng { rng: Xoshiro256StarStar.from_time() }
    }
    
    fn next_u64() -> UInt64 { self.rng.next_u64() }
    fn next_u32() -> UInt32 { self.rng.next_u32() }
    fn next_float() -> Float { self.rng.next_float() }
    fn next_bool() -> Bool { self.rng.next_bool() }
    fn next_range(min: Int, max: Int) -> Int { self.rng.next_range(min, max) }
    fn next_float_range(min: Float, max: Float) -> Float { self.rng.next_float_range(min, max) }
}

/// Global thread-local RNG instance
var thread_rng: ThreadRng = ThreadRng.new()

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Generate random UInt64
fn random_u64() -> UInt64 { thread_rng.next_u64() }

/// Generate random UInt32
fn random_u32() -> UInt32 { thread_rng.next_u32() }

/// Generate random Float in [0, 1)
fn random_float() -> Float { thread_rng.next_float() }

/// Generate random Bool
fn random_bool() -> Bool { thread_rng.next_bool() }

/// Generate random Int in range [min, max)
fn random_range(min: Int, max: Int) -> Int { thread_rng.next_range(min, max) }

/// Generate random Int in range [min, max]
fn random_range_inclusive(min: Int, max: Int) -> Int { thread_rng.next_range(min, max + 1) }

/// Generate random Float in range [min, max)
fn random_float_range(min: Float, max: Float) -> Float { thread_rng.next_float_range(min, max) }

/// Seed the thread-local RNG
fn seed(s: UInt64) {
    thread_rng = ThreadRng { rng: Xoshiro256StarStar.new(s) }
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

fn rotl(x: UInt64, k: Int) -> UInt64 {
    (x << k) | (x >> (64 - k))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "xorshift64 deterministic" {
    let rng1 = Xorshift64.new(12345)
    let rng2 = Xorshift64.new(12345)
    assert_eq(rng1.next_u64(), rng2.next_u64())?
}

test "xoshiro256 range" {
    var rng = Xoshiro256StarStar.new(42)
    for _ in 0..1000 {
        let val = rng.next_range(10, 20)
        assert(val >= 10 && val < 20)?
    }
}

test "pcg32 float range" {
    var rng = Pcg32.from_seed(42)
    for _ in 0..1000 {
        let val = rng.next_float()
        assert(val >= 0.0 && val < 1.0)?
    }
}

test "mersenne twister period" {
    var rng = MersenneTwister.new(42)
    let first = rng.next_u64()
    // Just verify it produces different values
    var different = false
    for _ in 0..100 {
        if rng.next_u64() != first { different = true; break }
    }
    assert(different)?
}

test "secure rng" {
    let rng = SecureRng.new()
    let a = rng.next_u64()
    let b = rng.next_u64()
    // Extremely unlikely to be equal
    assert(a != b)?
}
