// =============================================================================
// Vibee OS â€” CMS Menu Module
// Navigation menus for CMS
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime}

// =============================================================================
// Menu Types
// =============================================================================

/// Menu type
enum MenuType {
    Main,
    Footer,
    Sidebar,
    Mobile,
    Dropdown,
    Mega,
    Custom(String)
}

/// Menu item type
enum MenuItemType {
    Page,
    Category,
    Product,
    Url,
    Anchor,
    Separator,
    Submenu
}

/// Menu item target
enum MenuTarget {
    Self,
    Blank,
    Parent,
    Top
}

impl MenuTarget {
    fn to_html() -> String {
        match self {
            MenuTarget.Self => "_self",
            MenuTarget.Blank => "_blank",
            MenuTarget.Parent => "_parent",
            MenuTarget.Top => "_top"
        }
    }
}

// =============================================================================
// Menu Item
// =============================================================================

/// Menu item
struct MenuItem {
    id: String,
    menu_id: String,
    parent_id: Option<String>,
    title: String,
    url: String,
    item_type: MenuItemType,
    target: MenuTarget,
    icon: Option<String>,
    css_class: Option<String>,
    position: Int,
    is_active: Bool,
    children: [MenuItem],
    metadata: Map<String, String>
}

impl MenuItem {
    fn new(menu_id: String, title: String, url: String) -> Self {
        MenuItem {
            id: generate_id(),
            menu_id: menu_id,
            parent_id: None,
            title: title,
            url: url,
            item_type: MenuItemType.Url,
            target: MenuTarget.Self,
            icon: None,
            css_class: None,
            position: 0,
            is_active: true,
            children: [],
            metadata: Map.empty()
        }
    }
    
    fn page(menu_id: String, title: String, page_slug: String) -> Self {
        var item = MenuItem.new(menu_id, title, format!("/{}", page_slug))
        item.item_type = MenuItemType.Page
        item
    }
    
    fn external(menu_id: String, title: String, url: String) -> Self {
        var item = MenuItem.new(menu_id, title, url)
        item.target = MenuTarget.Blank
        item
    }
    
    fn separator(menu_id: String) -> Self {
        var item = MenuItem.new(menu_id, "", "")
        item.item_type = MenuItemType.Separator
        item
    }
    
    fn with_icon(icon: String) -> Self {
        self.icon = Some(icon)
        self
    }
    
    fn with_css_class(css: String) -> Self {
        self.css_class = Some(css)
        self
    }
    
    fn with_position(pos: Int) -> Self {
        self.position = pos
        self
    }
    
    fn add_child(child: MenuItem) {
        var child = child
        child.parent_id = Some(self.id.clone())
        self.children.push(child)
    }
    
    fn has_children() -> Bool {
        !self.children.is_empty()
    }
    
    fn render_html() -> String {
        if !self.is_active {
            return ""
        }
        
        match self.item_type {
            MenuItemType.Separator => "<li class=\"separator\"></li>",
            _ => {
                let icon_html = self.icon.map(|i| format!("<i class=\"{}\"></i> ", i)).unwrap_or("")
                let css = self.css_class.clone().unwrap_or("")
                let target = self.target.to_html()
                
                if self.has_children() {
                    let children_html = self.children.iter()
                        .map(|c| c.render_html())
                        .join("")
                    format!("<li class=\"has-submenu {}\"><a href=\"{}\" target=\"{}\">{}{}</a><ul>{}</ul></li>",
                        css, self.url, target, icon_html, self.title, children_html)
                } else {
                    format!("<li class=\"{}\"><a href=\"{}\" target=\"{}\">{}{}</a></li>",
                        css, self.url, target, icon_html, self.title)
                }
            }
        }
    }
}

// =============================================================================
// Menu Structure
// =============================================================================

/// Navigation menu
struct Menu {
    id: String,
    identifier: String,
    title: String,
    menu_type: MenuType,
    items: [MenuItem],
    css_class: Option<String>,
    is_active: Bool,
    created_at: DateTime,
    updated_at: DateTime
}

impl Menu {
    fn new(identifier: String, title: String, menu_type: MenuType) -> Self {
        let now = DateTime.now()
        Menu {
            id: generate_id(),
            identifier: identifier,
            title: title,
            menu_type: menu_type,
            items: [],
            css_class: None,
            is_active: true,
            created_at: now,
            updated_at: now
        }
    }
    
    fn add_item(item: MenuItem) {
        self.items.push(item)
        self.updated_at = DateTime.now()
    }
    
    fn remove_item(item_id: String) {
        self.items.retain(|i| i.id != item_id)
        self.updated_at = DateTime.now()
    }
    
    fn reorder_items() {
        self.items.sort_by(|a, b| a.position.cmp(b.position))
        for item in self.items.iter_mut() {
            item.children.sort_by(|a, b| a.position.cmp(b.position))
        }
    }
    
    fn render_html() -> String {
        if !self.is_active {
            return ""
        }
        
        let css = self.css_class.clone().unwrap_or("nav-menu")
        let items_html = self.items.iter()
            .filter(|i| i.is_active)
            .map(|i| i.render_html())
            .join("")
        
        format!("<nav class=\"{}\"><ul>{}</ul></nav>", css, items_html)
    }
}

// =============================================================================
// Menu Service
// =============================================================================

/// Menu service actor
actor MenuService {
    state menus: Map<String, Menu>
    state identifier_index: Map<String, String>
    
    fn new() -> Self {
        MenuService {
            menus: Map.empty(),
            identifier_index: Map.empty()
        }
    }
    
    on create(menu: Menu) -> Result<Menu, MenuError> {
        if self.identifier_index.contains_key(menu.identifier.clone()) {
            return Err(MenuError.IdentifierExists)
        }
        
        self.menus.set(menu.id.clone(), menu.clone())
        self.identifier_index.set(menu.identifier.clone(), menu.id.clone())
        Ok(menu)
    }
    
    on get(menu_id: String) -> Option<Menu> {
        self.menus.get(menu_id)
    }
    
    on get_by_identifier(identifier: String) -> Option<Menu> {
        self.identifier_index.get(identifier)
            .and_then(|id| self.menus.get(id))
    }
    
    on add_item(menu_id: String, item: MenuItem) -> Result<Menu, MenuError> {
        let menu = self.menus.get_mut(menu_id)
            .ok_or(MenuError.NotFound)?
        menu.add_item(item)
        Ok(menu.clone())
    }
    
    on render(identifier: String) -> Option<String> {
        self.get_by_identifier(identifier).map(|m| m.render_html())
    }
    
    on delete(menu_id: String) -> Result<(), MenuError> {
        let menu = self.menus.remove(menu_id)
            .ok_or(MenuError.NotFound)?
        self.identifier_index.remove(menu.identifier)
        Ok(())
    }
}

/// Menu errors
enum MenuError {
    NotFound,
    IdentifierExists,
    ItemNotFound
}

// =============================================================================
// Tests
// =============================================================================

test "create menu" {
    let menu = Menu.new("main-nav", "Main Navigation", MenuType.Main)
    assert_eq(menu.identifier, "main-nav")?
}

test "add menu items" {
    var menu = Menu.new("test", "Test", MenuType.Main)
    
    let item = MenuItem.new(menu.id.clone(), "Home", "/")
    menu.add_item(item)
    
    assert_eq(menu.items.len(), 1)?
}

test "render menu" {
    var menu = Menu.new("nav", "Nav", MenuType.Main)
    menu.add_item(MenuItem.new(menu.id.clone(), "Home", "/"))
    
    let html = menu.render_html()
    assert(html.contains("Home"))?
}
