// =============================================================================
// Vibee OS â€” Validator Module
// Data validation utilities and validators
// =============================================================================

use schema::{Schema, SchemaError}

// =============================================================================
// Validator Trait
// =============================================================================

/// Trait for types that can validate values
trait Validator<T> {
    fn validate(value: T) -> ValidationResult
    fn is_valid(value: T) -> Bool { self.validate(value).is_ok() }
}

/// Validation result with multiple errors
struct ValidationResult {
    errors: [ValidationError]
}

impl ValidationResult {
    fn ok() -> Self { ValidationResult { errors: [] } }
    fn error(err: ValidationError) -> Self { ValidationResult { errors: [err] } }
    fn errors(errs: [ValidationError]) -> Self { ValidationResult { errors: errs } }
    
    fn is_ok() -> Bool { self.errors.is_empty() }
    fn is_err() -> Bool { !self.errors.is_empty() }
    
    fn merge(other: ValidationResult) -> Self {
        var errors = self.errors.clone()
        errors.extend(other.errors)
        ValidationResult { errors: errors }
    }
    
    fn with_path(path: String) -> Self {
        ValidationResult {
            errors: self.errors.iter().map(|e| e.with_path(path.clone())).collect()
        }
    }
    
    fn first_error() -> Option<ValidationError> { self.errors.first().cloned() }
    fn to_result() -> Result<(), ValidationError> {
        if self.is_ok() { Ok(()) }
        else { Err(self.errors[0].clone()) }
    }
}

/// Validation error with path and message
struct ValidationError {
    path: String
    message: String
    code: String
    params: Map<String, String>
}

impl ValidationError {
    fn new(message: String) -> Self {
        ValidationError { path: "", message: message, code: "validation_error", params: Map.new() }
    }
    
    fn with_code(code: String, message: String) -> Self {
        ValidationError { path: "", message: message, code: code, params: Map.new() }
    }
    
    fn with_path(path: String) -> Self {
        ValidationError { path: path, ..self }
    }
    
    fn with_param(key: String, value: String) -> Self {
        self.params.insert(key, value)
        self
    }
}

impl Display for ValidationError {
    fn fmt(f: Formatter) {
        if self.path.is_empty() {
            f.write(self.message)
        } else {
            f.write(format!("{}: {}", self.path, self.message))
        }
    }
}

// =============================================================================
// Built-in Validators
// =============================================================================

/// String validators
struct StringValidator {
    rules: [fn(String) -> Option<ValidationError>]
}

impl StringValidator {
    fn new() -> Self { StringValidator { rules: [] } }
    
    fn required() -> Self {
        self.rules.push(|s| {
            if s.is_empty() { Some(ValidationError.with_code("required", "This field is required")) }
            else { None }
        })
        self
    }
    
    fn min_length(min: Int) -> Self {
        self.rules.push(|s| {
            if s.len() < min {
                Some(ValidationError.with_code("min_length", format!("Must be at least {} characters", min))
                    .with_param("min", min.to_string()))
            } else { None }
        })
        self
    }
    
    fn max_length(max: Int) -> Self {
        self.rules.push(|s| {
            if s.len() > max {
                Some(ValidationError.with_code("max_length", format!("Must be at most {} characters", max))
                    .with_param("max", max.to_string()))
            } else { None }
        })
        self
    }
    
    fn length(exact: Int) -> Self {
        self.rules.push(|s| {
            if s.len() != exact {
                Some(ValidationError.with_code("length", format!("Must be exactly {} characters", exact)))
            } else { None }
        })
        self
    }
    
    fn pattern(regex: String, message: String) -> Self {
        let re = Regex.new(regex).ok()
        self.rules.push(move |s| {
            match re {
                Some(r) if r.is_match(s) => None
                _ => Some(ValidationError.with_code("pattern", message.clone()))
            }
        })
        self
    }
    
    fn email() -> Self {
        self.pattern(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", "Invalid email address")
    }
    
    fn url() -> Self {
        self.pattern(r"^https?://[^\s]+$", "Invalid URL")
    }
    
    fn alphanumeric() -> Self {
        self.pattern(r"^[a-zA-Z0-9]+$", "Must contain only letters and numbers")
    }
    
    fn alpha() -> Self {
        self.pattern(r"^[a-zA-Z]+$", "Must contain only letters")
    }
    
    fn numeric() -> Self {
        self.pattern(r"^\d+$", "Must contain only numbers")
    }
    
    fn slug() -> Self {
        self.pattern(r"^[a-z0-9]+(?:-[a-z0-9]+)*$", "Invalid slug format")
    }
    
    fn uuid() -> Self {
        self.pattern(r"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", "Invalid UUID")
    }
    
    fn ip_v4() -> Self {
        self.rules.push(|s| {
            let parts = s.split(".")
            if parts.len() != 4 { return Some(ValidationError.with_code("ip_v4", "Invalid IPv4 address")) }
            for part in parts {
                match Int.parse(part) {
                    Ok(n) if n >= 0 && n <= 255 => {}
                    _ => return Some(ValidationError.with_code("ip_v4", "Invalid IPv4 address"))
                }
            }
            None
        })
        self
    }
    
    fn credit_card() -> Self {
        self.rules.push(|s| {
            let digits = s.chars().filter(|c| c.is_digit()).collect::<String>()
            if digits.len() < 13 || digits.len() > 19 {
                return Some(ValidationError.with_code("credit_card", "Invalid credit card number"))
            }
            
            // Luhn algorithm
            var sum = 0
            var double = false
            for c in digits.chars().rev() {
                var digit = c.to_digit().unwrap()
                if double {
                    digit *= 2
                    if digit > 9 { digit -= 9 }
                }
                sum += digit
                double = !double
            }
            
            if sum % 10 != 0 {
                Some(ValidationError.with_code("credit_card", "Invalid credit card number"))
            } else { None }
        })
        self
    }
    
    fn one_of(values: [String]) -> Self {
        self.rules.push(move |s| {
            if values.contains(s) { None }
            else { Some(ValidationError.with_code("one_of", format!("Must be one of: {}", values.join(", ")))) }
        })
        self
    }
    
    fn not_one_of(values: [String]) -> Self {
        self.rules.push(move |s| {
            if !values.contains(s) { None }
            else { Some(ValidationError.with_code("not_one_of", "This value is not allowed")) }
        })
        self
    }
    
    fn starts_with(prefix: String) -> Self {
        self.rules.push(move |s| {
            if s.starts_with(prefix) { None }
            else { Some(ValidationError.with_code("starts_with", format!("Must start with '{}'", prefix))) }
        })
        self
    }
    
    fn ends_with(suffix: String) -> Self {
        self.rules.push(move |s| {
            if s.ends_with(suffix) { None }
            else { Some(ValidationError.with_code("ends_with", format!("Must end with '{}'", suffix))) }
        })
        self
    }
    
    fn contains(substring: String) -> Self {
        self.rules.push(move |s| {
            if s.contains(substring) { None }
            else { Some(ValidationError.with_code("contains", format!("Must contain '{}'", substring))) }
        })
        self
    }
    
    fn custom(validator: fn(String) -> Option<ValidationError>) -> Self {
        self.rules.push(validator)
        self
    }
}

impl Validator<String> for StringValidator {
    fn validate(value: String) -> ValidationResult {
        var errors = []
        for rule in self.rules {
            if let Some(err) = rule(value.clone()) {
                errors.push(err)
            }
        }
        ValidationResult { errors: errors }
    }
}

// =============================================================================
// Number Validators
// =============================================================================

struct NumberValidator {
    rules: [fn(Float) -> Option<ValidationError>]
}

impl NumberValidator {
    fn new() -> Self { NumberValidator { rules: [] } }
    
    fn min(min: Float) -> Self {
        self.rules.push(move |n| {
            if n < min { Some(ValidationError.with_code("min", format!("Must be at least {}", min))) }
            else { None }
        })
        self
    }
    
    fn max(max: Float) -> Self {
        self.rules.push(move |n| {
            if n > max { Some(ValidationError.with_code("max", format!("Must be at most {}", max))) }
            else { None }
        })
        self
    }
    
    fn between(min: Float, max: Float) -> Self {
        self.min(min).max(max)
    }
    
    fn positive() -> Self {
        self.rules.push(|n| {
            if n > 0.0 { None }
            else { Some(ValidationError.with_code("positive", "Must be positive")) }
        })
        self
    }
    
    fn negative() -> Self {
        self.rules.push(|n| {
            if n < 0.0 { None }
            else { Some(ValidationError.with_code("negative", "Must be negative")) }
        })
        self
    }
    
    fn non_negative() -> Self {
        self.rules.push(|n| {
            if n >= 0.0 { None }
            else { Some(ValidationError.with_code("non_negative", "Must be non-negative")) }
        })
        self
    }
    
    fn integer() -> Self {
        self.rules.push(|n| {
            if n.fract() == 0.0 { None }
            else { Some(ValidationError.with_code("integer", "Must be an integer")) }
        })
        self
    }
    
    fn finite() -> Self {
        self.rules.push(|n| {
            if n.is_finite() { None }
            else { Some(ValidationError.with_code("finite", "Must be a finite number")) }
        })
        self
    }
    
    fn multiple_of(divisor: Float) -> Self {
        self.rules.push(move |n| {
            if n % divisor == 0.0 { None }
            else { Some(ValidationError.with_code("multiple_of", format!("Must be a multiple of {}", divisor))) }
        })
        self
    }
}

impl Validator<Float> for NumberValidator {
    fn validate(value: Float) -> ValidationResult {
        var errors = []
        for rule in self.rules {
            if let Some(err) = rule(value) {
                errors.push(err)
            }
        }
        ValidationResult { errors: errors }
    }
}

// =============================================================================
// Integer Validator
// =============================================================================

struct IntegerValidator {
    rules: [fn(Int) -> Option<ValidationError>]
}

impl IntegerValidator {
    fn new() -> Self { IntegerValidator { rules: [] } }
    
    fn min(min: Int) -> Self {
        self.rules.push(move |n| {
            if n < min { Some(ValidationError.with_code("min", format!("Must be at least {}", min))) }
            else { None }
        })
        self
    }
    
    fn max(max: Int) -> Self {
        self.rules.push(move |n| {
            if n > max { Some(ValidationError.with_code("max", format!("Must be at most {}", max))) }
            else { None }
        })
        self
    }
    
    fn between(min: Int, max: Int) -> Self { self.min(min).max(max) }
    fn positive() -> Self { self.min(1) }
    fn non_negative() -> Self { self.min(0) }
    fn port() -> Self { self.between(1, 65535) }
    
    fn one_of(values: [Int]) -> Self {
        self.rules.push(move |n| {
            if values.contains(n) { None }
            else { Some(ValidationError.with_code("one_of", "Invalid value")) }
        })
        self
    }
}

impl Validator<Int> for IntegerValidator {
    fn validate(value: Int) -> ValidationResult {
        var errors = []
        for rule in self.rules {
            if let Some(err) = rule(value) {
                errors.push(err)
            }
        }
        ValidationResult { errors: errors }
    }
}

// =============================================================================
// Array Validator
// =============================================================================

struct ArrayValidator<T> {
    item_validator: Option<Box<dyn Validator<T>>>
    min_items: Option<Int>
    max_items: Option<Int>
    unique: Bool
}

impl<T> ArrayValidator<T> {
    fn new() -> Self {
        ArrayValidator { item_validator: None, min_items: None, max_items: None, unique: false }
    }
    
    fn items(validator: impl Validator<T>) -> Self {
        self.item_validator = Some(Box.new(validator))
        self
    }
    
    fn min(count: Int) -> Self { self.min_items = Some(count); self }
    fn max(count: Int) -> Self { self.max_items = Some(count); self }
    fn length(exact: Int) -> Self { self.min_items = Some(exact); self.max_items = Some(exact); self }
    fn non_empty() -> Self { self.min_items = Some(1); self }
    fn unique() -> Self { self.unique = true; self }
}

impl<T: Eq + Hash> Validator<[T]> for ArrayValidator<T> {
    fn validate(value: [T]) -> ValidationResult {
        var errors = []
        
        if let Some(min) = self.min_items {
            if value.len() < min {
                errors.push(ValidationError.with_code("min_items", format!("Must have at least {} items", min)))
            }
        }
        
        if let Some(max) = self.max_items {
            if value.len() > max {
                errors.push(ValidationError.with_code("max_items", format!("Must have at most {} items", max)))
            }
        }
        
        if self.unique {
            var seen = Set.new()
            for (i, item) in value.iter().enumerate() {
                if seen.contains(item) {
                    errors.push(ValidationError.with_code("unique", format!("Duplicate item at index {}", i)))
                }
                seen.insert(item.clone())
            }
        }
        
        if let Some(validator) = self.item_validator {
            for (i, item) in value.iter().enumerate() {
                let result = validator.validate(item.clone())
                for err in result.errors {
                    errors.push(err.with_path(format!("[{}]", i)))
                }
            }
        }
        
        ValidationResult { errors: errors }
    }
}

// =============================================================================
// Object Validator
// =============================================================================

struct ObjectValidator {
    field_validators: Map<String, Box<dyn Validator<JsonValue>>>
    required_fields: Set<String>
    allow_unknown: Bool
}

impl ObjectValidator {
    fn new() -> Self {
        ObjectValidator {
            field_validators: Map.new(),
            required_fields: Set.new(),
            allow_unknown: true
        }
    }
    
    fn field(name: String, validator: impl Validator<JsonValue>) -> Self {
        self.field_validators.insert(name, Box.new(validator))
        self
    }
    
    fn required(name: String, validator: impl Validator<JsonValue>) -> Self {
        self.field_validators.insert(name.clone(), Box.new(validator))
        self.required_fields.insert(name)
        self
    }
    
    fn strict() -> Self { self.allow_unknown = false; self }
}

impl Validator<Map<String, JsonValue>> for ObjectValidator {
    fn validate(value: Map<String, JsonValue>) -> ValidationResult {
        var errors = []
        
        // Check required fields
        for name in self.required_fields {
            if !value.contains_key(name) {
                errors.push(ValidationError.with_code("required", format!("Field '{}' is required", name))
                    .with_path(name))
            }
        }
        
        // Validate fields
        for (name, val) in value {
            if let Some(validator) = self.field_validators.get(name) {
                let result = validator.validate(val)
                for err in result.errors {
                    errors.push(err.with_path(name.clone()))
                }
            } else if !self.allow_unknown {
                errors.push(ValidationError.with_code("unknown_field", format!("Unknown field: {}", name))
                    .with_path(name))
            }
        }
        
        ValidationResult { errors: errors }
    }
}

// =============================================================================
// Composite Validators
// =============================================================================

/// Combine multiple validators with AND logic
struct AllOf<T> {
    validators: [Box<dyn Validator<T>>]
}

impl<T: Clone> AllOf<T> {
    fn new(validators: [impl Validator<T>]) -> Self {
        AllOf { validators: validators.iter().map(|v| Box.new(v)).collect() }
    }
}

impl<T: Clone> Validator<T> for AllOf<T> {
    fn validate(value: T) -> ValidationResult {
        var result = ValidationResult.ok()
        for validator in self.validators {
            result = result.merge(validator.validate(value.clone()))
        }
        result
    }
}

/// Combine multiple validators with OR logic
struct AnyOf<T> {
    validators: [Box<dyn Validator<T>>]
}

impl<T: Clone> AnyOf<T> {
    fn new(validators: [impl Validator<T>]) -> Self {
        AnyOf { validators: validators.iter().map(|v| Box.new(v)).collect() }
    }
}

impl<T: Clone> Validator<T> for AnyOf<T> {
    fn validate(value: T) -> ValidationResult {
        for validator in self.validators {
            if validator.validate(value.clone()).is_ok() {
                return ValidationResult.ok()
            }
        }
        ValidationResult.error(ValidationError.with_code("any_of", "None of the validators passed"))
    }
}

/// Negate a validator
struct Not<T> {
    validator: Box<dyn Validator<T>>
}

impl<T: Clone> Not<T> {
    fn new(validator: impl Validator<T>) -> Self {
        Not { validator: Box.new(validator) }
    }
}

impl<T: Clone> Validator<T> for Not<T> {
    fn validate(value: T) -> ValidationResult {
        if self.validator.validate(value).is_ok() {
            ValidationResult.error(ValidationError.with_code("not", "Validation should have failed"))
        } else {
            ValidationResult.ok()
        }
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Validate a value with a validator
fn validate<T>(value: T, validator: impl Validator<T>) -> ValidationResult {
    validator.validate(value)
}

/// Check if a value is valid
fn is_valid<T>(value: T, validator: impl Validator<T>) -> Bool {
    validator.is_valid(value)
}

/// Validate and return Result
fn validate_result<T>(value: T, validator: impl Validator<T>) -> Result<T, ValidationError> {
    let result = validator.validate(value.clone())
    if result.is_ok() { Ok(value) }
    else { Err(result.errors[0].clone()) }
}

// =============================================================================
// Common Validators
// =============================================================================

/// Email validator
fn email() -> StringValidator { StringValidator.new().email() }

/// URL validator
fn url() -> StringValidator { StringValidator.new().url() }

/// UUID validator
fn uuid() -> StringValidator { StringValidator.new().uuid() }

/// Required string validator
fn required_string() -> StringValidator { StringValidator.new().required() }

/// Positive number validator
fn positive_number() -> NumberValidator { NumberValidator.new().positive() }

/// Port number validator
fn port() -> IntegerValidator { IntegerValidator.new().port() }

// =============================================================================
// Tests
// =============================================================================

test "string validator" {
    let validator = StringValidator.new().required().min_length(3).max_length(20)
    assert(validator.is_valid("hello"))?
    assert(!validator.is_valid(""))?
    assert(!validator.is_valid("hi"))?
}

test "email validator" {
    let validator = email()
    assert(validator.is_valid("test@example.com"))?
    assert(!validator.is_valid("invalid"))?
}

test "number validator" {
    let validator = NumberValidator.new().min(0.0).max(100.0)
    assert(validator.is_valid(50.0))?
    assert(!validator.is_valid(-10.0))?
    assert(!validator.is_valid(150.0))?
}

test "integer validator" {
    let validator = IntegerValidator.new().port()
    assert(validator.is_valid(8080))?
    assert(!validator.is_valid(0))?
    assert(!validator.is_valid(70000))?
}

test "validation result merge" {
    let r1 = ValidationResult.error(ValidationError.new("Error 1"))
    let r2 = ValidationResult.error(ValidationError.new("Error 2"))
    let merged = r1.merge(r2)
    assert_eq(merged.errors.len(), 2)?
}

test "credit card validator" {
    let validator = StringValidator.new().credit_card()
    assert(validator.is_valid("4111111111111111"))?  // Valid test card
    assert(!validator.is_valid("1234567890123456"))?  // Invalid
}

test "composite validators" {
    let v1 = StringValidator.new().min_length(3)
    let v2 = StringValidator.new().max_length(10)
    let combined = AllOf.new([v1, v2])
    
    assert(combined.is_valid("hello"))?
    assert(!combined.is_valid("hi"))?
    assert(!combined.is_valid("this is too long"))?
}
