// =============================================================================
// Vibee OS â€” ACL Module
// Access Control Lists
// =============================================================================

// =============================================================================
// Core Types
// =============================================================================

/// Access Control Entry
struct AclEntry {
    id: String
    principal: Principal
    resource: Resource
    permissions: Set<AclPermission>
    effect: AclEffect
    conditions: [AclCondition]
    priority: Int
    expires_at: Option<DateTime>
    created_at: DateTime
    created_by: String
}

impl AclEntry {
    fn new(principal: Principal, resource: Resource, permissions: Set<AclPermission>, effect: AclEffect) -> Self {
        AclEntry {
            id: uuid.v4(),
            principal: principal,
            resource: resource,
            permissions: permissions,
            effect: effect,
            conditions: [],
            priority: 0,
            expires_at: None,
            created_at: DateTime.now(),
            created_by: ""
        }
    }
    
    fn allow(principal: Principal, resource: Resource, permissions: Set<AclPermission>) -> Self {
        Self.new(principal, resource, permissions, AclEffect.Allow)
    }
    
    fn deny(principal: Principal, resource: Resource, permissions: Set<AclPermission>) -> Self {
        Self.new(principal, resource, permissions, AclEffect.Deny)
    }
    
    fn with_priority(priority: Int) -> Self { self.priority = priority; self }
    fn with_expiry(expires_at: DateTime) -> Self { self.expires_at = Some(expires_at); self }
    fn with_condition(condition: AclCondition) -> Self { self.conditions.push(condition); self }
    fn with_creator(creator: String) -> Self { self.created_by = creator; self }
    
    fn is_expired() -> Bool { self.expires_at.map(|t| DateTime.now() > t).unwrap_or(false) }
    fn is_valid() -> Bool { !self.is_expired() }
    
    fn matches_principal(p: Principal) -> Bool {
        match (self.principal.clone(), p) {
            (Principal.Anyone, _) => true
            (Principal.User(id1), Principal.User(id2)) => id1 == id2
            (Principal.Group(id1), Principal.Group(id2)) => id1 == id2
            (Principal.Role(r1), Principal.Role(r2)) => r1 == r2
            _ => false
        }
    }
    
    fn matches_resource(r: Resource) -> Bool {
        match (self.resource.clone(), r) {
            (Resource.All, _) => true
            (Resource.Type(t1), Resource.Type(t2)) => t1 == t2
            (Resource.Type(t1), Resource.Instance(t2, _)) => t1 == t2
            (Resource.Instance(t1, id1), Resource.Instance(t2, id2)) => t1 == t2 && id1 == id2
            (Resource.Pattern(p), Resource.Instance(t, id)) => self.pattern_matches(p, format!("{}:{}", t, id))
            (Resource.Pattern(p), Resource.Type(t)) => self.pattern_matches(p, t)
            _ => false
        }
    }
    
    fn pattern_matches(pattern: String, value: String) -> Bool {
        if pattern == "*" { return true }
        if pattern.ends_with("*") {
            let prefix = pattern.trim_end("*")
            return value.starts_with(prefix)
        }
        if pattern.starts_with("*") {
            let suffix = pattern.trim_start("*")
            return value.ends_with(suffix)
        }
        pattern == value
    }
    
    fn has_permission(perm: AclPermission) -> Bool {
        self.permissions.contains(perm) || self.permissions.contains(AclPermission.Full)
    }
    
    fn evaluate_conditions(context: AclContext) -> Bool {
        if self.conditions.is_empty() { return true }
        self.conditions.iter().all(|c| c.evaluate(context.clone()))
    }
}

/// Principal (who)
enum Principal {
    Anyone
    Authenticated
    User(String)
    Group(String)
    Role(String)
    ServiceAccount(String)
}

impl Principal {
    fn user(id: String) -> Self { Principal.User(id) }
    fn group(id: String) -> Self { Principal.Group(id) }
    fn role(name: String) -> Self { Principal.Role(name) }
    fn anyone() -> Self { Principal.Anyone }
    fn authenticated() -> Self { Principal.Authenticated }
}

/// Resource (what)
enum Resource {
    All
    Type(String)
    Instance(String, String)
    Pattern(String)
}

impl Resource {
    fn all() -> Self { Resource.All }
    fn of_type(t: String) -> Self { Resource.Type(t) }
    fn instance(t: String, id: String) -> Self { Resource.Instance(t, id) }
    fn pattern(p: String) -> Self { Resource.Pattern(p) }
}

/// ACL Permission
enum AclPermission {
    Read
    Write
    Create
    Delete
    Execute
    Admin
    Full
    Custom(String)
}

impl AclPermission {
    fn from_string(s: String) -> Self {
        match s.to_lower() {
            "read" => AclPermission.Read
            "write" => AclPermission.Write
            "create" => AclPermission.Create
            "delete" => AclPermission.Delete
            "execute" => AclPermission.Execute
            "admin" => AclPermission.Admin
            "full" | "*" => AclPermission.Full
            _ => AclPermission.Custom(s)
        }
    }
    
    fn to_string() -> String {
        match self {
            Read => "read"
            Write => "write"
            Create => "create"
            Delete => "delete"
            Execute => "execute"
            Admin => "admin"
            Full => "full"
            Custom(s) => s
        }
    }
}

/// ACL Effect
enum AclEffect { Allow, Deny }

/// ACL Condition
enum AclCondition {
    TimeRange { start: Time, end: Time }
    DateRange { start: Date, end: Date }
    IpAddress { cidr: String }
    Attribute { key: String, op: ConditionOp, value: String }
    Environment { key: String, value: String }
    Custom { name: String, evaluator: fn(AclContext) -> Bool }
}

enum ConditionOp { Eq, Ne, Gt, Lt, Gte, Lte, Contains, StartsWith, EndsWith, In, NotIn }

impl AclCondition {
    fn evaluate(context: AclContext) -> Bool {
        match self {
            TimeRange { start, end } => {
                let now = Time.now()
                now >= start && now <= end
            }
            DateRange { start, end } => {
                let today = Date.today()
                today >= start && today <= end
            }
            IpAddress { cidr } => {
                context.ip_address.map(|ip| ip_in_cidr(ip, cidr)).unwrap_or(false)
            }
            Attribute { key, op, value } => {
                let attr_value = context.attributes.get(key).unwrap_or("")
                match op {
                    Eq => attr_value == value
                    Ne => attr_value != value
                    Contains => attr_value.contains(value)
                    StartsWith => attr_value.starts_with(value)
                    EndsWith => attr_value.ends_with(value)
                    _ => false
                }
            }
            Environment { key, value } => {
                context.environment.get(key).map(|v| v == value).unwrap_or(false)
            }
            Custom { evaluator, .. } => evaluator(context)
        }
    }
}

fn ip_in_cidr(ip: String, cidr: String) -> Bool {
    @native("ip_in_cidr", ip, cidr)
}

/// ACL Context for condition evaluation
struct AclContext {
    principal: Principal
    resource: Resource
    permission: AclPermission
    ip_address: Option<String>
    user_agent: Option<String>
    attributes: Map<String, String>
    environment: Map<String, String>
    timestamp: DateTime
}

impl AclContext {
    fn new(principal: Principal, resource: Resource, permission: AclPermission) -> Self {
        AclContext {
            principal: principal,
            resource: resource,
            permission: permission,
            ip_address: None,
            user_agent: None,
            attributes: Map.empty(),
            environment: Map.empty(),
            timestamp: DateTime.now()
        }
    }
    
    fn with_ip(ip: String) -> Self { self.ip_address = Some(ip); self }
    fn with_user_agent(ua: String) -> Self { self.user_agent = Some(ua); self }
    fn with_attribute(key: String, value: String) -> Self { self.attributes.set(key, value); self }
    fn with_environment(key: String, value: String) -> Self { self.environment.set(key, value); self }
}

// =============================================================================
// ACL Manager
// =============================================================================

/// ACL Manager
struct AclManager<S: AclStore> {
    store: S
    config: AclConfig
    cache: AclCache
}

struct AclConfig {
    default_effect: AclEffect
    enable_caching: Bool
    cache_ttl: Int64
    deny_takes_precedence: Bool
    enable_inheritance: Bool
}

impl AclConfig {
    fn default() -> Self {
        AclConfig {
            default_effect: AclEffect.Deny,
            enable_caching: true,
            cache_ttl: 300,
            deny_takes_precedence: true,
            enable_inheritance: true
        }
    }
    
    fn permissive() -> Self {
        AclConfig {
            default_effect: AclEffect.Allow,
            enable_caching: true,
            cache_ttl: 300,
            deny_takes_precedence: true,
            enable_inheritance: true
        }
    }
}

impl<S: AclStore> AclManager<S> {
    fn new(store: S) -> Self {
        AclManager { store: store, config: AclConfig.default(), cache: AclCache.new() }
    }
    
    fn with_config(config: AclConfig) -> Self { self.config = config; self }
    
    // -------------------------------------------------------------------------
    // Entry Management
    // -------------------------------------------------------------------------
    
    fn add_entry(entry: AclEntry) -> Result<AclEntry, AclError> {
        let created = self.store.create_entry(entry)?
        if self.config.enable_caching {
            self.cache.invalidate_principal(created.principal.clone())
        }
        Ok(created)
    }
    
    fn allow(principal: Principal, resource: Resource, permissions: [AclPermission]) -> Result<AclEntry, AclError> {
        let entry = AclEntry.allow(principal, resource, permissions.iter().collect())
        self.add_entry(entry)
    }
    
    fn deny(principal: Principal, resource: Resource, permissions: [AclPermission]) -> Result<AclEntry, AclError> {
        let entry = AclEntry.deny(principal, resource, permissions.iter().collect())
        self.add_entry(entry)
    }
    
    fn remove_entry(entry_id: String) -> Result<(), AclError> {
        let entry = self.store.find_entry(entry_id.clone()).ok_or(AclError.EntryNotFound(entry_id.clone()))?
        self.store.delete_entry(entry_id)?
        if self.config.enable_caching {
            self.cache.invalidate_principal(entry.principal)
        }
        Ok(())
    }
    
    fn get_entry(entry_id: String) -> Option<AclEntry> {
        self.store.find_entry(entry_id)
    }
    
    fn list_entries_for_resource(resource: Resource) -> [AclEntry] {
        self.store.list_entries_by_resource(resource)
    }
    
    fn list_entries_for_principal(principal: Principal) -> [AclEntry] {
        self.store.list_entries_by_principal(principal)
    }
    
    // -------------------------------------------------------------------------
    // Authorization
    // -------------------------------------------------------------------------
    
    fn check(principal: Principal, resource: Resource, permission: AclPermission) -> AclDecision {
        let context = AclContext.new(principal.clone(), resource.clone(), permission.clone())
        self.check_with_context(context)
    }
    
    fn check_with_context(context: AclContext) -> AclDecision {
        // Get all applicable entries
        let entries = self.get_applicable_entries(context.principal.clone(), context.resource.clone())
        
        // Filter valid entries
        let valid_entries: [AclEntry] = entries.iter()
            .filter(|e| e.is_valid())
            .filter(|e| e.has_permission(context.permission.clone()))
            .filter(|e| e.evaluate_conditions(context.clone()))
            .collect()
        
        if valid_entries.is_empty() {
            return AclDecision {
                allowed: self.config.default_effect == AclEffect.Allow,
                effect: self.config.default_effect.clone(),
                matched_entry: None,
                reason: "No matching ACL entries"
            }
        }
        
        // Sort by priority (higher first)
        var sorted = valid_entries.clone()
        sorted.sort_by(|a, b| b.priority.cmp(a.priority))
        
        // Apply deny-takes-precedence if configured
        if self.config.deny_takes_precedence {
            for entry in sorted.iter() {
                if entry.effect == AclEffect.Deny {
                    return AclDecision {
                        allowed: false,
                        effect: AclEffect.Deny,
                        matched_entry: Some(entry.id.clone()),
                        reason: "Explicit deny"
                    }
                }
            }
        }
        
        // Return first matching entry
        let first = sorted[0].clone()
        AclDecision {
            allowed: first.effect == AclEffect.Allow,
            effect: first.effect,
            matched_entry: Some(first.id),
            reason: if first.effect == AclEffect.Allow { "Explicit allow" } else { "Explicit deny" }
        }
    }
    
    fn is_allowed(principal: Principal, resource: Resource, permission: AclPermission) -> Bool {
        self.check(principal, resource, permission).allowed
    }
    
    fn require(principal: Principal, resource: Resource, permission: AclPermission) -> Result<(), AclError> {
        let decision = self.check(principal.clone(), resource.clone(), permission.clone())
        if decision.allowed {
            Ok(())
        } else {
            Err(AclError.AccessDenied {
                principal: principal,
                resource: resource,
                permission: permission,
                reason: decision.reason
            })
        }
    }
    
    fn get_applicable_entries(principal: Principal, resource: Resource) -> [AclEntry] {
        var entries = []
        
        // Direct entries for principal
        entries.extend(self.store.list_entries_by_principal(principal.clone()))
        
        // Entries for "Anyone"
        entries.extend(self.store.list_entries_by_principal(Principal.Anyone))
        
        // Entries for "Authenticated" if principal is not Anyone
        match principal {
            Principal.Anyone => {}
            _ => entries.extend(self.store.list_entries_by_principal(Principal.Authenticated))
        }
        
        // Filter by resource
        entries.iter()
            .filter(|e| e.matches_resource(resource.clone()))
            .collect()
    }
    
    // -------------------------------------------------------------------------
    // Bulk Operations
    // -------------------------------------------------------------------------
    
    fn grant_full_access(principal: Principal, resource: Resource) -> Result<AclEntry, AclError> {
        self.allow(principal, resource, [AclPermission.Full])
    }
    
    fn revoke_all_access(principal: Principal, resource: Resource) -> Result<(), AclError> {
        let entries = self.store.list_entries_by_principal(principal)
        for entry in entries {
            if entry.matches_resource(resource.clone()) {
                self.remove_entry(entry.id)?
            }
        }
        Ok(())
    }
    
    fn copy_permissions(from_principal: Principal, to_principal: Principal) -> Result<Int, AclError> {
        let entries = self.store.list_entries_by_principal(from_principal)
        var count = 0
        
        for entry in entries {
            let new_entry = AclEntry.new(
                to_principal.clone(),
                entry.resource.clone(),
                entry.permissions.clone(),
                entry.effect.clone()
            )
            self.add_entry(new_entry)?
            count += 1
        }
        
        Ok(count)
    }
    
    // -------------------------------------------------------------------------
    // Cleanup
    // -------------------------------------------------------------------------
    
    fn cleanup_expired() -> Int {
        self.store.delete_expired_entries()
    }
}

/// ACL Decision
struct AclDecision {
    allowed: Bool
    effect: AclEffect
    matched_entry: Option<String>
    reason: String
}

impl AclDecision {
    fn is_allowed() -> Bool { self.allowed }
    fn is_denied() -> Bool { !self.allowed }
}

// =============================================================================
// ACL Store Trait
// =============================================================================

trait AclStore {
    fn find_entry(id: String) -> Option<AclEntry>
    fn create_entry(entry: AclEntry) -> Result<AclEntry, AclError>
    fn update_entry(entry: AclEntry) -> Result<AclEntry, AclError>
    fn delete_entry(id: String) -> Result<(), AclError>
    fn list_entries_by_principal(principal: Principal) -> [AclEntry]
    fn list_entries_by_resource(resource: Resource) -> [AclEntry]
    fn delete_expired_entries() -> Int
}

// =============================================================================
// In-Memory ACL Store
// =============================================================================

struct InMemoryAclStore {
    entries: Map<String, AclEntry>
}

impl InMemoryAclStore {
    fn new() -> Self { InMemoryAclStore { entries: Map.empty() } }
}

impl AclStore for InMemoryAclStore {
    fn find_entry(id: String) -> Option<AclEntry> { self.entries.get(id) }
    
    fn create_entry(entry: AclEntry) -> Result<AclEntry, AclError> {
        self.entries.set(entry.id.clone(), entry.clone())
        Ok(entry)
    }
    
    fn update_entry(entry: AclEntry) -> Result<AclEntry, AclError> {
        if !self.entries.contains_key(entry.id.clone()) {
            return Err(AclError.EntryNotFound(entry.id))
        }
        self.entries.set(entry.id.clone(), entry.clone())
        Ok(entry)
    }
    
    fn delete_entry(id: String) -> Result<(), AclError> {
        self.entries.remove(id)
        Ok(())
    }
    
    fn list_entries_by_principal(principal: Principal) -> [AclEntry] {
        self.entries.values().filter(|e| e.matches_principal(principal.clone())).collect()
    }
    
    fn list_entries_by_resource(resource: Resource) -> [AclEntry] {
        self.entries.values().filter(|e| e.matches_resource(resource.clone())).collect()
    }
    
    fn delete_expired_entries() -> Int {
        let expired: [String] = self.entries.iter()
            .filter(|(_, e)| e.is_expired())
            .map(|(id, _)| id.clone())
            .collect()
        
        for id in expired.iter() { self.entries.remove(id.clone()) }
        expired.len()
    }
}

// =============================================================================
// ACL Cache
// =============================================================================

struct AclCache {
    decisions: Map<String, CachedDecision>
    ttl: Int64
}

struct CachedDecision { decision: AclDecision, cached_at: Int64 }

impl AclCache {
    fn new() -> Self { AclCache { decisions: Map.empty(), ttl: 300 } }
    
    fn cache_key(principal: Principal, resource: Resource, permission: AclPermission) -> String {
        format!("{:?}:{:?}:{:?}", principal, resource, permission)
    }
    
    fn get(principal: Principal, resource: Resource, permission: AclPermission) -> Option<AclDecision> {
        let key = Self.cache_key(principal, resource, permission)
        let cached = self.decisions.get(key)?
        if DateTime.now().timestamp() - cached.cached_at > self.ttl { return None }
        Some(cached.decision.clone())
    }
    
    fn set(principal: Principal, resource: Resource, permission: AclPermission, decision: AclDecision) {
        let key = Self.cache_key(principal, resource, permission)
        self.decisions.set(key, CachedDecision { decision: decision, cached_at: DateTime.now().timestamp() })
    }
    
    fn invalidate_principal(principal: Principal) {
        let prefix = format!("{:?}:", principal)
        let keys: [String] = self.decisions.keys().filter(|k| k.starts_with(prefix.clone())).collect()
        for key in keys { self.decisions.remove(key) }
    }
    
    fn clear() { self.decisions.clear() }
}

// =============================================================================
// ACL Actor
// =============================================================================

actor AclActor {
    state manager: AclManager<InMemoryAclStore>
    
    fn new() -> Self {
        AclActor { manager: AclManager.new(InMemoryAclStore.new()) }
    }
    
    fn allow(principal: Principal, resource: Resource, permissions: [AclPermission]) -> Result<AclEntry, AclError> {
        self.manager.allow(principal, resource, permissions)
    }
    
    fn deny(principal: Principal, resource: Resource, permissions: [AclPermission]) -> Result<AclEntry, AclError> {
        self.manager.deny(principal, resource, permissions)
    }
    
    fn check(principal: Principal, resource: Resource, permission: AclPermission) -> AclDecision {
        self.manager.check(principal, resource, permission)
    }
    
    fn is_allowed(principal: Principal, resource: Resource, permission: AclPermission) -> Bool {
        self.manager.is_allowed(principal, resource, permission)
    }
    
    fn require(principal: Principal, resource: Resource, permission: AclPermission) -> Result<(), AclError> {
        self.manager.require(principal, resource, permission)
    }
}

// =============================================================================
// Errors
// =============================================================================

enum AclError {
    EntryNotFound(String)
    AccessDenied { principal: Principal, resource: Resource, permission: AclPermission, reason: String }
    InvalidEntry(String)
    Other(String)
}

impl Display for AclError {
    fn fmt(f: Formatter) {
        match self {
            EntryNotFound(id) => f.write(format!("ACL entry not found: {}", id))
            AccessDenied { principal, resource, permission, reason } => {
                f.write(format!("Access denied: {:?} cannot {:?} on {:?} - {}", principal, permission, resource, reason))
            }
            InvalidEntry(msg) => f.write(format!("Invalid ACL entry: {}", msg))
            Other(msg) => f.write(msg)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "allow and check" {
    let store = InMemoryAclStore.new()
    var manager = AclManager.new(store)
    
    manager.allow(Principal.user("user-1"), Resource.of_type("document"), [AclPermission.Read])?
    
    assert(manager.is_allowed(Principal.user("user-1"), Resource.instance("document", "doc-1"), AclPermission.Read))?
    assert(!manager.is_allowed(Principal.user("user-1"), Resource.instance("document", "doc-1"), AclPermission.Write))?
}

test "deny takes precedence" {
    let store = InMemoryAclStore.new()
    var manager = AclManager.new(store)
    
    manager.allow(Principal.user("user-1"), Resource.of_type("document"), [AclPermission.Read, AclPermission.Write])?
    manager.deny(Principal.user("user-1"), Resource.instance("document", "secret"), [AclPermission.Read])?
    
    assert(manager.is_allowed(Principal.user("user-1"), Resource.instance("document", "public"), AclPermission.Read))?
    assert(!manager.is_allowed(Principal.user("user-1"), Resource.instance("document", "secret"), AclPermission.Read))?
}

test "anyone principal" {
    let store = InMemoryAclStore.new()
    var manager = AclManager.new(store)
    
    manager.allow(Principal.Anyone, Resource.of_type("public"), [AclPermission.Read])?
    
    assert(manager.is_allowed(Principal.user("any-user"), Resource.instance("public", "page-1"), AclPermission.Read))?
}

test "pattern matching" {
    let store = InMemoryAclStore.new()
    var manager = AclManager.new(store)
    
    manager.allow(Principal.user("user-1"), Resource.pattern("project/*"), [AclPermission.Read])?
    
    assert(manager.is_allowed(Principal.user("user-1"), Resource.instance("project", "123"), AclPermission.Read))?
    assert(!manager.is_allowed(Principal.user("user-1"), Resource.instance("other", "123"), AclPermission.Read))?
}

test "full permission" {
    let store = InMemoryAclStore.new()
    var manager = AclManager.new(store)
    
    manager.allow(Principal.user("admin"), Resource.All, [AclPermission.Full])?
    
    assert(manager.is_allowed(Principal.user("admin"), Resource.instance("anything", "123"), AclPermission.Read))?
    assert(manager.is_allowed(Principal.user("admin"), Resource.instance("anything", "123"), AclPermission.Delete))?
}
