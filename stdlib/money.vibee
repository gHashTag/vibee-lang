// =============================================================================
// Vibee OS — Money Module
// Type-safe monetary amounts with currency support
// =============================================================================

// -----------------------------------------------------------------------------
// Money Type
// -----------------------------------------------------------------------------

/// Represents a monetary amount with currency
struct Money {
    amount: Decimal
    currency: Currency
    
    /// Create money from integer (minor units, e.g., cents)
    fn from_minor(minor_units: Int, currency: Currency) -> Self {
        let scale = currency.decimal_places()
        let amount = Decimal.from_int_scale(minor_units, scale)
        Money { amount: amount, currency: currency }
    }
    
    /// Create money from major units (e.g., dollars)
    fn from_major(major_units: Int, currency: Currency) -> Self {
        Money { amount: Decimal.from_int(major_units), currency: currency }
    }
    
    /// Create money from decimal
    fn from_decimal(amount: Decimal, currency: Currency) -> Self {
        Money { amount: amount.round(currency.decimal_places()), currency: currency }
    }
    
    /// Create money from string
    fn from_string(s: String, currency: Currency) -> Result<Self, MoneyError> {
        let amount = Decimal.from_string(s).map_err(|_| MoneyError.InvalidAmount)?
        Ok(Money.from_decimal(amount, currency))
    }
    
    /// Parse money with currency symbol (e.g., "$100.50", "€50.00")
    fn parse(s: String) -> Result<Self, MoneyError> {
        let s = s.trim()
        if s.is_empty() { return Err(MoneyError.InvalidFormat) }
        
        // Try to detect currency from symbol
        let (currency, amount_str) = if s.starts_with("$") {
            (Currency.USD, s[1..])
        } else if s.starts_with("€") {
            (Currency.EUR, s[1..])
        } else if s.starts_with("£") {
            (Currency.GBP, s[1..])
        } else if s.starts_with("¥") {
            (Currency.JPY, s[1..])
        } else if s.starts_with("₽") {
            (Currency.RUB, s[1..])
        } else if s.ends_with(" USD") {
            (Currency.USD, s[..s.len()-4])
        } else if s.ends_with(" EUR") {
            (Currency.EUR, s[..s.len()-4])
        } else {
            return Err(MoneyError.UnknownCurrency)
        }
        
        // Remove thousand separators
        let clean = amount_str.replace(",", "").trim()
        Self.from_string(clean, currency)
    }
    
    /// Zero amount in given currency
    fn zero(currency: Currency) -> Self {
        Money { amount: Decimal.zero(), currency: currency }
    }
    
    /// Check if zero
    fn is_zero() -> Bool { self.amount.is_zero() }
    
    /// Check if negative
    fn is_negative() -> Bool { self.amount.is_negative() }
    
    /// Check if positive
    fn is_positive() -> Bool { self.amount.is_positive() }
    
    /// Get absolute value
    fn abs() -> Self {
        Money { amount: self.amount.abs(), currency: self.currency }
    }
    
    /// Negate amount
    fn negate() -> Self {
        Money { amount: self.amount.negate(), currency: self.currency }
    }
    
    /// Get amount as decimal
    fn as_decimal() -> Decimal { self.amount }
    
    /// Get amount in minor units (e.g., cents)
    fn minor_units() -> Int {
        let scale = self.currency.decimal_places()
        self.amount.rescale(scale).coefficient.to_int().unwrap_or(0)
    }
    
    /// Round to currency precision
    fn round() -> Self {
        Money { 
            amount: self.amount.round(self.currency.decimal_places()), 
            currency: self.currency 
        }
    }
    
    /// Round with specific mode
    fn round_with_mode(mode: RoundingMode) -> Self {
        Money { 
            amount: self.amount.round_with_mode(self.currency.decimal_places(), mode), 
            currency: self.currency 
        }
    }
    
    /// Format as string
    fn to_string() -> String {
        self.amount.format(self.currency.decimal_places())
    }
    
    /// Format with currency symbol
    fn format() -> String {
        let symbol = self.currency.symbol()
        let formatted = self.amount.format_currency(symbol, self.currency.decimal_places())
        formatted
    }
    
    /// Format with ISO code
    fn format_iso() -> String {
        let code = self.currency.code()
        "\(self.amount.format(self.currency.decimal_places())) \(code)"
    }
}

// -----------------------------------------------------------------------------
// Arithmetic Operations
// -----------------------------------------------------------------------------

impl Add for Money {
    fn add(other: Money) -> Money {
        if self.currency != other.currency {
            panic("Cannot add money with different currencies")
        }
        Money { amount: self.amount + other.amount, currency: self.currency }
    }
}

impl Sub for Money {
    fn sub(other: Money) -> Money {
        if self.currency != other.currency {
            panic("Cannot subtract money with different currencies")
        }
        Money { amount: self.amount - other.amount, currency: self.currency }
    }
}

impl Money {
    /// Multiply by scalar
    fn mul(factor: Decimal) -> Self {
        Money { amount: self.amount * factor, currency: self.currency }.round()
    }
    
    /// Multiply by integer
    fn mul_int(factor: Int) -> Self {
        self.mul(Decimal.from_int(factor))
    }
    
    /// Multiply by float (use with caution)
    fn mul_float(factor: Float) -> Self {
        self.mul(Decimal.from_float(factor))
    }
    
    /// Divide by scalar
    fn div(divisor: Decimal) -> Self {
        Money { amount: self.amount / divisor, currency: self.currency }.round()
    }
    
    /// Divide by integer
    fn div_int(divisor: Int) -> Self {
        self.div(Decimal.from_int(divisor))
    }
    
    /// Calculate percentage
    fn percent(percentage: Decimal) -> Self {
        self.mul(percentage / Decimal.from_int(100))
    }
    
    /// Add percentage
    fn add_percent(percentage: Decimal) -> Self {
        self + self.percent(percentage)
    }
    
    /// Subtract percentage
    fn sub_percent(percentage: Decimal) -> Self {
        self - self.percent(percentage)
    }
}

// -----------------------------------------------------------------------------
// Comparison
// -----------------------------------------------------------------------------

impl Eq for Money {
    fn eq(other: Money) -> Bool {
        self.currency == other.currency && self.amount == other.amount
    }
}

impl Ord for Money {
    fn cmp(other: Money) -> Ordering {
        if self.currency != other.currency {
            panic("Cannot compare money with different currencies")
        }
        self.amount.cmp(other.amount)
    }
}

// -----------------------------------------------------------------------------
// Allocation (Fair Division)
// -----------------------------------------------------------------------------

impl Money {
    /// Split money into n equal parts (handles remainders)
    fn split(n: Int) -> [Money] {
        if n <= 0 { return [] }
        
        let total_minor = self.minor_units()
        let base = total_minor / n
        let remainder = total_minor % n
        
        var result = []
        for i in 0..n {
            let extra = if i < remainder { 1 } else { 0 }
            result.push(Money.from_minor(base + extra, self.currency))
        }
        result
    }
    
    /// Allocate money by ratios
    fn allocate(ratios: [Int]) -> [Money] {
        if ratios.is_empty() { return [] }
        
        let total_ratio = ratios.sum()
        if total_ratio == 0 { return ratios.map(|_| Money.zero(self.currency)) }
        
        let total_minor = self.minor_units()
        var allocated = 0
        var result = []
        
        for (i, ratio) in ratios.enumerate() {
            let share = if i == ratios.len() - 1 {
                total_minor - allocated  // Last one gets remainder
            } else {
                total_minor * ratio / total_ratio
            }
            allocated += share
            result.push(Money.from_minor(share, self.currency))
        }
        result
    }
    
    /// Allocate by percentages (must sum to 100)
    fn allocate_percent(percentages: [Decimal]) -> Result<[Money], MoneyError> {
        let sum = percentages.fold(Decimal.zero(), |acc, p| acc + p)
        if sum != Decimal.from_int(100) {
            return Err(MoneyError.InvalidAllocation)
        }
        
        let total_minor = self.minor_units()
        var allocated = 0
        var result = []
        
        for (i, pct) in percentages.enumerate() {
            let share = if i == percentages.len() - 1 {
                total_minor - allocated
            } else {
                (Decimal.from_int(total_minor) * pct / Decimal.from_int(100))
                    .truncate(0).to_int().unwrap_or(0)
            }
            allocated += share
            result.push(Money.from_minor(share, self.currency))
        }
        Ok(result)
    }
}

// -----------------------------------------------------------------------------
// Money Bag (Multi-Currency)
// -----------------------------------------------------------------------------

/// Collection of money in different currencies
struct MoneyBag {
    amounts: Map<Currency, Money>
    
    fn empty() -> Self {
        MoneyBag { amounts: Map.empty() }
    }
    
    fn from_money(money: Money) -> Self {
        var bag = Self.empty()
        bag.add(money)
        bag
    }
    
    fn add(money: Money) {
        let existing = self.amounts.get(money.currency).unwrap_or(Money.zero(money.currency))
        self.amounts.insert(money.currency, existing + money)
    }
    
    fn subtract(money: Money) {
        let existing = self.amounts.get(money.currency).unwrap_or(Money.zero(money.currency))
        self.amounts.insert(money.currency, existing - money)
    }
    
    fn get(currency: Currency) -> Money {
        self.amounts.get(currency).unwrap_or(Money.zero(currency))
    }
    
    fn currencies() -> [Currency] {
        self.amounts.keys().collect()
    }
    
    fn is_empty() -> Bool {
        self.amounts.values().all(|m| m.is_zero())
    }
    
    /// Convert all to single currency using exchange rates
    fn to_currency(target: Currency, rates: ExchangeRates) -> Result<Money, MoneyError> {
        var total = Money.zero(target)
        for (currency, money) in self.amounts {
            let converted = rates.convert(money, target)?
            total = total + converted
        }
        Ok(total)
    }
}

// -----------------------------------------------------------------------------
// Money Operations
// -----------------------------------------------------------------------------

/// Sum of money amounts (must be same currency)
fn sum(amounts: [Money]) -> Result<Money, MoneyError> {
    if amounts.is_empty() { return Err(MoneyError.EmptyList) }
    
    let currency = amounts[0].currency
    var total = Money.zero(currency)
    
    for m in amounts {
        if m.currency != currency {
            return Err(MoneyError.CurrencyMismatch)
        }
        total = total + m
    }
    Ok(total)
}

/// Average of money amounts
fn average(amounts: [Money]) -> Result<Money, MoneyError> {
    let total = sum(amounts)?
    Ok(total.div_int(amounts.len()))
}

/// Minimum amount
fn min(amounts: [Money]) -> Result<Money, MoneyError> {
    if amounts.is_empty() { return Err(MoneyError.EmptyList) }
    amounts.reduce(|a, b| if a < b { a } else { b }).ok_or(MoneyError.EmptyList)
}

/// Maximum amount
fn max(amounts: [Money]) -> Result<Money, MoneyError> {
    if amounts.is_empty() { return Err(MoneyError.EmptyList) }
    amounts.reduce(|a, b| if a > b { a } else { b }).ok_or(MoneyError.EmptyList)
}

// -----------------------------------------------------------------------------
// Convenience Constructors
// -----------------------------------------------------------------------------

fn usd(amount: Float) -> Money { Money.from_decimal(Decimal.from_float(amount), Currency.USD) }
fn eur(amount: Float) -> Money { Money.from_decimal(Decimal.from_float(amount), Currency.EUR) }
fn gbp(amount: Float) -> Money { Money.from_decimal(Decimal.from_float(amount), Currency.GBP) }
fn jpy(amount: Int) -> Money { Money.from_major(amount, Currency.JPY) }
fn rub(amount: Float) -> Money { Money.from_decimal(Decimal.from_float(amount), Currency.RUB) }
fn cny(amount: Float) -> Money { Money.from_decimal(Decimal.from_float(amount), Currency.CNY) }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum MoneyError {
    InvalidAmount
    InvalidFormat
    UnknownCurrency
    CurrencyMismatch
    InvalidAllocation
    EmptyList
    ConversionFailed
}

impl Display for MoneyError {
    fn fmt(f: Formatter) {
        f.write(match self {
            InvalidAmount => "Invalid amount"
            InvalidFormat => "Invalid format"
            UnknownCurrency => "Unknown currency"
            CurrencyMismatch => "Currency mismatch"
            InvalidAllocation => "Invalid allocation (must sum to 100%)"
            EmptyList => "Empty list"
            ConversionFailed => "Currency conversion failed"
        })
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "create money" {
    let m = usd(100.50)
    assert_eq(m.format(), "$100.50")?
    assert_eq(m.minor_units(), 10050)?
}

test "arithmetic" {
    let a = usd(100.00)
    let b = usd(50.25)
    
    assert_eq((a + b).format(), "$150.25")?
    assert_eq((a - b).format(), "$49.75")?
    assert_eq(a.mul_int(2).format(), "$200.00")?
}

test "percentage" {
    let price = usd(100.00)
    let tax = price.percent(Decimal.from_int(8))
    assert_eq(tax.format(), "$8.00")?
    
    let total = price.add_percent(Decimal.from_int(8))
    assert_eq(total.format(), "$108.00")?
}

test "split" {
    let total = usd(100.00)
    let parts = total.split(3)
    
    assert_eq(parts.len(), 3)?
    assert_eq(parts[0].format(), "$33.34")?
    assert_eq(parts[1].format(), "$33.33")?
    assert_eq(parts[2].format(), "$33.33")?
    
    // Verify sum equals original
    let sum = parts[0] + parts[1] + parts[2]
    assert_eq(sum.format(), "$100.00")?
}

test "allocate" {
    let total = usd(100.00)
    let parts = total.allocate([50, 30, 20])
    
    assert_eq(parts[0].format(), "$50.00")?
    assert_eq(parts[1].format(), "$30.00")?
    assert_eq(parts[2].format(), "$20.00")?
}

test "comparison" {
    let a = usd(100.00)
    let b = usd(50.00)
    
    assert(a > b)?
    assert(b < a)?
    assert(a == usd(100.00))?
}

test "money bag" {
    var bag = MoneyBag.empty()
    bag.add(usd(100.00))
    bag.add(eur(50.00))
    bag.add(usd(25.00))
    
    assert_eq(bag.get(Currency.USD).format(), "$125.00")?
    assert_eq(bag.get(Currency.EUR).format(), "€50.00")?
}
