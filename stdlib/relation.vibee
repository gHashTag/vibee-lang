// =============================================================================
// Vibee OS â€” Relation Module
// ORM Entity relationships
// =============================================================================

use entity::{Entity, EntityError, Value, Row}
use repository::{Repository, RepositoryQuery, Connection}
use query_builder::{SelectBuilder, WhereClause}

// =============================================================================
// Relation Types
// =============================================================================

/// Types of entity relationships
enum RelationType {
    HasOne
    HasMany
    BelongsTo
    BelongsToMany
    MorphOne
    MorphMany
    MorphTo
}

// =============================================================================
// Relation Trait
// =============================================================================

/// Core trait for entity relations
trait Relation<T: Entity, R: Entity> {
    fn relation_type() -> RelationType
    fn foreign_key() -> String
    fn local_key() -> String { "id" }
    fn load(entity: T, conn: Box<dyn Connection>) -> Result<RelationResult<R>, EntityError>
}

/// Relation result wrapper
enum RelationResult<R> {
    One(Option<R>)
    Many([R])
}

// =============================================================================
// HasOne Relation
// =============================================================================

/// One-to-one relationship (parent side)
struct HasOne<T: Entity, R: Entity> {
    related_table: String
    foreign_key: String
    local_key: String
    
    fn new(related_table: String, foreign_key: String) -> Self {
        HasOne {
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: "id"
        }
    }
    
    fn with_local_key(related_table: String, foreign_key: String, local_key: String) -> Self {
        HasOne {
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: local_key
        }
    }
}

impl<T: Entity, R: Entity> Relation<T, R> for HasOne<T, R> {
    fn relation_type() -> RelationType { RelationType.HasOne }
    fn foreign_key() -> String { self.foreign_key.clone() }
    fn local_key() -> String { self.local_key.clone() }
    
    fn load(entity: T, conn: Box<dyn Connection>) -> Result<RelationResult<R>, EntityError> {
        let local_value = entity.to_row().get(self.local_key.clone())
            .ok_or(EntityError.ColumnNotFound(self.local_key.clone()))?
        
        let query = SelectBuilder.new(self.related_table.clone())
            .where_eq(self.foreign_key.clone(), local_value.clone())
            .limit(1)
            .build()
        
        let rows = conn.query(query.sql, query.params)?
        match rows.first() {
            Some(row) => Ok(RelationResult.One(Some(R.from_row(row)?))),
            None => Ok(RelationResult.One(None))
        }
    }
}

// =============================================================================
// HasMany Relation
// =============================================================================

/// One-to-many relationship
struct HasMany<T: Entity, R: Entity> {
    related_table: String
    foreign_key: String
    local_key: String
    
    fn new(related_table: String, foreign_key: String) -> Self {
        HasMany {
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: "id"
        }
    }
}

impl<T: Entity, R: Entity> Relation<T, R> for HasMany<T, R> {
    fn relation_type() -> RelationType { RelationType.HasMany }
    fn foreign_key() -> String { self.foreign_key.clone() }
    fn local_key() -> String { self.local_key.clone() }
    
    fn load(entity: T, conn: Box<dyn Connection>) -> Result<RelationResult<R>, EntityError> {
        let local_value = entity.to_row().get(self.local_key.clone())
            .ok_or(EntityError.ColumnNotFound(self.local_key.clone()))?
        
        let query = SelectBuilder.new(self.related_table.clone())
            .where_eq(self.foreign_key.clone(), local_value.clone())
            .build()
        
        let rows = conn.query(query.sql, query.params)?
        let entities = rows.iter().map(|row| R.from_row(row)).collect::<Result<[R], _>>()?
        Ok(RelationResult.Many(entities))
    }
}

// =============================================================================
// BelongsTo Relation
// =============================================================================

/// Inverse one-to-one/many relationship
struct BelongsTo<T: Entity, R: Entity> {
    related_table: String
    foreign_key: String
    owner_key: String
    
    fn new(related_table: String, foreign_key: String) -> Self {
        BelongsTo {
            related_table: related_table,
            foreign_key: foreign_key,
            owner_key: "id"
        }
    }
}

impl<T: Entity, R: Entity> Relation<T, R> for BelongsTo<T, R> {
    fn relation_type() -> RelationType { RelationType.BelongsTo }
    fn foreign_key() -> String { self.foreign_key.clone() }
    fn local_key() -> String { self.owner_key.clone() }
    
    fn load(entity: T, conn: Box<dyn Connection>) -> Result<RelationResult<R>, EntityError> {
        let foreign_value = entity.to_row().get(self.foreign_key.clone())
            .ok_or(EntityError.ColumnNotFound(self.foreign_key.clone()))?
        
        if foreign_value.is_null() {
            return Ok(RelationResult.One(None))
        }
        
        let query = SelectBuilder.new(self.related_table.clone())
            .where_eq(self.owner_key.clone(), foreign_value.clone())
            .limit(1)
            .build()
        
        let rows = conn.query(query.sql, query.params)?
        match rows.first() {
            Some(row) => Ok(RelationResult.One(Some(R.from_row(row)?))),
            None => Ok(RelationResult.One(None))
        }
    }
}

// =============================================================================
// BelongsToMany Relation
// =============================================================================

/// Many-to-many relationship
struct BelongsToMany<T: Entity, R: Entity> {
    related_table: String
    pivot_table: String
    foreign_pivot_key: String
    related_pivot_key: String
    local_key: String
    related_key: String
    pivot_columns: [String]
    
    fn new(related_table: String, pivot_table: String) -> Self {
        BelongsToMany {
            related_table: related_table,
            pivot_table: pivot_table,
            foreign_pivot_key: "",
            related_pivot_key: "",
            local_key: "id",
            related_key: "id",
            pivot_columns: []
        }
    }
    
    fn with_keys(foreign_key: String, related_key: String) -> Self {
        self.foreign_pivot_key = foreign_key
        self.related_pivot_key = related_key
        self
    }
    
    fn with_pivot(columns: [String]) -> Self {
        self.pivot_columns = columns
        self
    }
}

impl<T: Entity, R: Entity> Relation<T, R> for BelongsToMany<T, R> {
    fn relation_type() -> RelationType { RelationType.BelongsToMany }
    fn foreign_key() -> String { self.foreign_pivot_key.clone() }
    fn local_key() -> String { self.local_key.clone() }
    
    fn load(entity: T, conn: Box<dyn Connection>) -> Result<RelationResult<R>, EntityError> {
        let local_value = entity.to_row().get(self.local_key.clone())
            .ok_or(EntityError.ColumnNotFound(self.local_key.clone()))?
        
        let query = SelectBuilder.new(self.related_table.clone())
            .join(self.pivot_table.clone(),
                format!("{}.{}", self.related_table, self.related_key),
                format!("{}.{}", self.pivot_table, self.related_pivot_key))
            .where_eq(format!("{}.{}", self.pivot_table, self.foreign_pivot_key), local_value.clone())
            .build()
        
        let rows = conn.query(query.sql, query.params)?
        let entities = rows.iter().map(|row| R.from_row(row)).collect::<Result<[R], _>>()?
        Ok(RelationResult.Many(entities))
    }
}

// =============================================================================
// Eager Loading
// =============================================================================

/// Eager loading configuration
struct Eager {
    relations: [String]
    constraints: Map<String, fn(RepositoryQuery<dyn Entity>) -> RepositoryQuery<dyn Entity>>
    
    fn new() -> Self {
        Eager { relations: [], constraints: Map.empty() }
    }
    
    fn with(relation: String) -> Self {
        self.relations.push(relation)
        self
    }
    
    fn with_constraint(relation: String, constraint: fn(RepositoryQuery<dyn Entity>) -> RepositoryQuery<dyn Entity>) -> Self {
        self.relations.push(relation.clone())
        self.constraints.insert(relation, constraint)
        self
    }
}

/// Eager loader for batch loading relations
struct EagerLoader<T: Entity> {
    entities: [T]
    connection: Box<dyn Connection>
    loaded: Map<String, Map<String, RelationResult<dyn Entity>>>
    
    fn new(entities: [T], connection: Box<dyn Connection>) -> Self {
        EagerLoader {
            entities: entities,
            connection: connection,
            loaded: Map.empty()
        }
    }
    
    fn load_has_many<R: Entity>(relation_name: String, foreign_key: String, related_table: String) -> Result<Self, EntityError> {
        let ids: [Value] = self.entities.iter()
            .filter_map(|e| e.id())
            .collect()
        
        if ids.is_empty() {
            return Ok(self)
        }
        
        let query = SelectBuilder.new(related_table)
            .where_in(foreign_key.clone(), ids)
            .build()
        
        let rows = self.connection.query(query.sql, query.params)?
        
        var grouped: Map<String, [R]> = Map.empty()
        for row in rows {
            let fk_value = row.get::<Value>(foreign_key.clone())?
            let key = format!("{}", fk_value)
            let entity = R.from_row(row)?
            grouped.entry(key).or_insert([]).push(entity)
        }
        
        var relation_map: Map<String, RelationResult<dyn Entity>> = Map.empty()
        for (key, entities) in grouped {
            relation_map.insert(key, RelationResult.Many(entities))
        }
        
        self.loaded.insert(relation_name, relation_map)
        Ok(self)
    }
    
    fn get_loaded(entity_id: Value, relation_name: String) -> Option<RelationResult<dyn Entity>> {
        let key = format!("{}", entity_id)
        self.loaded.get(relation_name)?.get(key).cloned()
    }
}

// =============================================================================
// Lazy Loading
// =============================================================================

/// Lazy loader for on-demand relation loading
struct LazyLoader<T: Entity, R: Entity> {
    entity: T
    relation: Box<dyn Relation<T, R>>
    connection: Box<dyn Connection>
    loaded: Option<RelationResult<R>>
    
    fn new(entity: T, relation: Box<dyn Relation<T, R>>, connection: Box<dyn Connection>) -> Self {
        LazyLoader {
            entity: entity,
            relation: relation,
            connection: connection,
            loaded: None
        }
    }
    
    fn get() -> Result<RelationResult<R>, EntityError> {
        if let Some(result) = self.loaded.clone() {
            return Ok(result)
        }
        
        let result = self.relation.load(self.entity.clone(), self.connection.clone())?
        self.loaded = Some(result.clone())
        Ok(result)
    }
    
    fn is_loaded() -> Bool {
        self.loaded.is_some()
    }
}

// =============================================================================
// Relation Builder
// =============================================================================

/// Builder for defining relations
struct RelationBuilder<T: Entity> {
    relations: Map<String, RelationDef>
    
    fn new() -> Self {
        RelationBuilder { relations: Map.empty() }
    }
    
    fn has_one<R: Entity>(name: String, related_table: String, foreign_key: String) -> Self {
        self.relations.insert(name, RelationDef {
            relation_type: RelationType.HasOne,
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: "id",
            pivot_table: None
        })
        self
    }
    
    fn has_many<R: Entity>(name: String, related_table: String, foreign_key: String) -> Self {
        self.relations.insert(name, RelationDef {
            relation_type: RelationType.HasMany,
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: "id",
            pivot_table: None
        })
        self
    }
    
    fn belongs_to<R: Entity>(name: String, related_table: String, foreign_key: String) -> Self {
        self.relations.insert(name, RelationDef {
            relation_type: RelationType.BelongsTo,
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: "id",
            pivot_table: None
        })
        self
    }
    
    fn belongs_to_many<R: Entity>(name: String, related_table: String, pivot_table: String, foreign_key: String, related_key: String) -> Self {
        self.relations.insert(name, RelationDef {
            relation_type: RelationType.BelongsToMany,
            related_table: related_table,
            foreign_key: foreign_key,
            local_key: related_key,
            pivot_table: Some(pivot_table)
        })
        self
    }
    
    fn get(name: String) -> Option<RelationDef> {
        self.relations.get(name).cloned()
    }
}

/// Relation definition
struct RelationDef {
    relation_type: RelationType
    related_table: String
    foreign_key: String
    local_key: String
    pivot_table: Option<String>
}

// =============================================================================
// Pivot Table
// =============================================================================

/// Pivot table for many-to-many relations
struct Pivot {
    table: String
    data: Map<String, Value>
    
    fn new(table: String) -> Self {
        Pivot { table: table, data: Map.empty() }
    }
    
    fn set(key: String, value: Value) -> Self {
        self.data.insert(key, value)
        self
    }
    
    fn get(key: String) -> Option<Value> {
        self.data.get(key).cloned()
    }
}

// =============================================================================
// Tests
// =============================================================================

test "relation_types" {
    assert_eq(RelationType.HasOne as Int, 0)?
    assert_eq(RelationType.HasMany as Int, 1)?
    assert_eq(RelationType.BelongsTo as Int, 2)?
}

test "has_one_creation" {
    let relation = HasOne::<User, Profile>.new("profiles", "user_id")
    assert_eq(relation.foreign_key, "user_id")?
    assert_eq(relation.local_key, "id")?
}

test "has_many_creation" {
    let relation = HasMany::<User, Post>.new("posts", "user_id")
    assert_eq(relation.related_table, "posts")?
}

test "belongs_to_many_creation" {
    let relation = BelongsToMany::<User, Role>.new("roles", "user_roles")
        .with_keys("user_id", "role_id")
    assert_eq(relation.pivot_table, "user_roles")?
}

test "relation_builder" {
    let builder = RelationBuilder::<User>.new()
        .has_many::<Post>("posts", "posts", "user_id")
        .belongs_to::<Company>("company", "companies", "company_id")
    
    assert(builder.get("posts").is_some())?
    assert(builder.get("company").is_some())?
    assert(builder.get("unknown").is_none())?
}

test "eager_loading" {
    let eager = Eager.new()
        .with("posts")
        .with("comments")
    
    assert_eq(eager.relations.len(), 2)?
}
