// =============================================================================
// Vibee OS â€” Integration Testing Module
// Testing interactions between components, services, and external systems
// =============================================================================

// -----------------------------------------------------------------------------
// Integration Test Runner
// -----------------------------------------------------------------------------

/// Integration test runner
actor IntegrationRunner {
    state suites: [IntegrationSuite]
    state config: IntegrationConfig
    state results: [SuiteResult]
    state services: ServiceManager
    state database: Option<TestDatabase>
    state message_queue: Option<TestMessageQueue>
    
    fn new() -> Self {
        IntegrationRunner {
            suites: [],
            config: IntegrationConfig.default(),
            results: [],
            services: ServiceManager.new(),
            database: None,
            message_queue: None
        }
    }
    
    on config(c: IntegrationConfig) -> Self { self.config = c; self }
    
    /// Add test suite
    on suite(name: String, setup: (SuiteBuilder) -> SuiteBuilder) -> Self {
        let builder = SuiteBuilder.new(name)
        let suite = setup(builder).build()
        self.suites.append(suite)
        self
    }
    
    /// Setup database for tests
    async on with_database(config: DatabaseConfig) -> Result<Self, IntegrationError> {
        self.database = Some(TestDatabase.setup(config).await?)
        Ok(self)
    }
    
    /// Setup message queue for tests
    async on with_message_queue(config: MQConfig) -> Result<Self, IntegrationError> {
        self.message_queue = Some(TestMessageQueue.setup(config).await?)
        Ok(self)
    }
    
    /// Register service
    on register_service(name: String, service: Box<dyn Service>) -> Self {
        self.services.register(name, service)
        self
    }
    
    /// Run all integration tests
    async on run() -> IntegrationSummary {
        println("\nðŸ”— Running Integration Tests...\n")
        
        // Start services
        self.services.start_all().await
        
        for suite in self.suites {
            let result = self.run_suite(suite).await
            self.results.append(result)
        }
        
        // Stop services
        self.services.stop_all().await
        
        // Cleanup
        if let db = self.database { db.cleanup().await }
        if let mq = self.message_queue { mq.cleanup().await }
        
        self.create_summary()
    }
    
    async fn run_suite(suite: IntegrationSuite) -> SuiteResult {
        println("ðŸ“¦ Suite: \(suite.name)")
        
        var test_results = []
        let start = Instant.now()
        
        // Suite setup
        if let setup = suite.before_all {
            let ctx = self.create_context()
            if let Err(e) = setup(ctx).await {
                return SuiteResult {
                    name: suite.name,
                    status: .Failed,
                    tests: [],
                    duration: start.elapsed(),
                    error: Some(e)
                }
            }
        }
        
        for test in suite.tests {
            // Test setup
            if let before = suite.before_each {
                let ctx = self.create_context()
                before(ctx).await
            }
            
            let result = self.run_test(test).await
            test_results.append(result)
            
            // Test teardown
            if let after = suite.after_each {
                let ctx = self.create_context()
                after(ctx).await
            }
        }
        
        // Suite teardown
        if let teardown = suite.after_all {
            let ctx = self.create_context()
            teardown(ctx).await
        }
        
        let passed = test_results.all(|r| r.status == .Passed)
        
        SuiteResult {
            name: suite.name,
            status: if passed { .Passed } else { .Failed },
            tests: test_results,
            duration: start.elapsed(),
            error: None
        }
    }
    
    async fn run_test(test: IntegrationTest) -> TestResult {
        let ctx = self.create_context()
        let start = Instant.now()
        
        match timeout(test.timeout, test.func(ctx)).await {
            Ok(Ok(())) => {
                println("  âœ… \(test.name)")
                TestResult {
                    name: test.name,
                    status: .Passed,
                    duration: start.elapsed(),
                    error: None
                }
            }
            Ok(Err(e)) => {
                println("  âŒ \(test.name): \(e.message())")
                TestResult {
                    name: test.name,
                    status: .Failed,
                    duration: start.elapsed(),
                    error: Some(e)
                }
            }
            Err(_) => {
                println("  â±ï¸ \(test.name): Timeout")
                TestResult {
                    name: test.name,
                    status: .Failed,
                    duration: start.elapsed(),
                    error: Some(IntegrationError.Timeout)
                }
            }
        }
    }
    
    fn create_context() -> IntegrationContext {
        IntegrationContext {
            services: self.services,
            database: self.database,
            message_queue: self.message_queue,
            config: self.config
        }
    }
    
    fn create_summary() -> IntegrationSummary {
        var total = 0
        var passed = 0
        var failed = 0
        
        for suite in self.results {
            for test in suite.tests {
                total += 1
                match test.status {
                    .Passed => passed += 1
                    .Failed => failed += 1
                    _ => {}
                }
            }
        }
        
        IntegrationSummary {
            total: total,
            passed: passed,
            failed: failed,
            suites: self.results,
            duration: self.results.map(|s| s.duration).sum()
        }
    }
}

/// Integration test configuration
struct IntegrationConfig {
    default_timeout: Duration
    parallel_suites: Bool
    cleanup_on_failure: Bool
    retry_count: Int
    database_config: Option<DatabaseConfig>
    mq_config: Option<MQConfig>
    
    fn default() -> Self {
        IntegrationConfig {
            default_timeout: Duration.seconds(60),
            parallel_suites: false,
            cleanup_on_failure: true,
            retry_count: 0,
            database_config: None,
            mq_config: None
        }
    }
}

// -----------------------------------------------------------------------------
// Suite Builder
// -----------------------------------------------------------------------------

/// Builder for integration test suites
actor SuiteBuilder {
    state name: String
    state tests: [IntegrationTest]
    state before_all: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    state after_all: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    state before_each: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    state after_each: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    state timeout: Duration
    
    fn new(name: String) -> Self {
        SuiteBuilder {
            name: name,
            tests: [],
            before_all: None,
            after_all: None,
            before_each: None,
            after_each: None,
            timeout: Duration.seconds(30)
        }
    }
    
    /// Add test to suite
    on test(name: String, f: (IntegrationContext) -> Result<(), IntegrationError>) -> Self {
        self.tests.append(IntegrationTest {
            name: name,
            func: f,
            timeout: self.timeout,
            tags: []
        })
        self
    }
    
    /// Add tagged test
    on test_tagged(name: String, tags: [String], f: (IntegrationContext) -> Result<(), IntegrationError>) -> Self {
        self.tests.append(IntegrationTest {
            name: name,
            func: f,
            timeout: self.timeout,
            tags: tags
        })
        self
    }
    
    /// Set before all hook
    on before_all(f: (IntegrationContext) -> Result<(), IntegrationError>) -> Self {
        self.before_all = Some(f)
        self
    }
    
    /// Set after all hook
    on after_all(f: (IntegrationContext) -> Result<(), IntegrationError>) -> Self {
        self.after_all = Some(f)
        self
    }
    
    /// Set before each hook
    on before_each(f: (IntegrationContext) -> Result<(), IntegrationError>) -> Self {
        self.before_each = Some(f)
        self
    }
    
    /// Set after each hook
    on after_each(f: (IntegrationContext) -> Result<(), IntegrationError>) -> Self {
        self.after_each = Some(f)
        self
    }
    
    /// Set default timeout
    on timeout(d: Duration) -> Self {
        self.timeout = d
        self
    }
    
    fn build() -> IntegrationSuite {
        IntegrationSuite {
            name: self.name,
            tests: self.tests,
            before_all: self.before_all,
            after_all: self.after_all,
            before_each: self.before_each,
            after_each: self.after_each
        }
    }
}

struct IntegrationSuite {
    name: String
    tests: [IntegrationTest]
    before_all: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    after_all: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    before_each: Option<(IntegrationContext) -> Result<(), IntegrationError>>
    after_each: Option<(IntegrationContext) -> Result<(), IntegrationError>>
}

struct IntegrationTest {
    name: String
    func: (IntegrationContext) -> Result<(), IntegrationError>
    timeout: Duration
    tags: [String]
}

// -----------------------------------------------------------------------------
// Integration Context
// -----------------------------------------------------------------------------

/// Context for integration tests
struct IntegrationContext {
    services: ServiceManager
    database: Option<TestDatabase>
    message_queue: Option<TestMessageQueue>
    config: IntegrationConfig
}

impl IntegrationContext {
    /// Get service by name
    fn service<T: Service>(name: String) -> Result<T, IntegrationError> {
        self.services.get::<T>(name).ok_or(IntegrationError.ServiceNotFound(name))
    }
    
    /// Get database connection
    fn db() -> Result<TestDatabase, IntegrationError> {
        self.database.ok_or(IntegrationError.NoDatabaseConfigured)
    }
    
    /// Get message queue
    fn mq() -> Result<TestMessageQueue, IntegrationError> {
        self.message_queue.ok_or(IntegrationError.NoMessageQueueConfigured)
    }
    
    /// Make HTTP request to service
    async fn http_get(service: String, path: String) -> Result<Response, IntegrationError> {
        let svc = self.services.get_http_service(service)?
        svc.get(path).await.map_err(IntegrationError.HTTP)
    }
    
    async fn http_post<T: Serialize>(service: String, path: String, body: T) -> Result<Response, IntegrationError> {
        let svc = self.services.get_http_service(service)?
        svc.post(path, body).await.map_err(IntegrationError.HTTP)
    }
    
    /// Execute database query
    async fn query<T: FromRow>(sql: String, params: [Any]) -> Result<[T], IntegrationError> {
        let db = self.db()?
        db.query(sql, params).await.map_err(IntegrationError.Database)
    }
    
    /// Execute database command
    async fn execute(sql: String, params: [Any]) -> Result<Int, IntegrationError> {
        let db = self.db()?
        db.execute(sql, params).await.map_err(IntegrationError.Database)
    }
    
    /// Publish message
    async fn publish(topic: String, message: Any) -> Result<(), IntegrationError> {
        let mq = self.mq()?
        mq.publish(topic, message).await.map_err(IntegrationError.MessageQueue)
    }
    
    /// Consume messages
    async fn consume(topic: String, count: Int, timeout: Duration) -> Result<[Message], IntegrationError> {
        let mq = self.mq()?
        mq.consume(topic, count, timeout).await.map_err(IntegrationError.MessageQueue)
    }
    
    /// Wait for condition
    async fn wait_until<T>(condition: () -> Option<T>, timeout: Duration) -> Result<T, IntegrationError> {
        let start = Instant.now()
        while start.elapsed() < timeout {
            if let result = condition() {
                return Ok(result)
            }
            sleep(Duration.millis(100)).await
        }
        Err(IntegrationError.WaitTimeout)
    }
    
    /// Assert eventually
    async fn assert_eventually(condition: () -> Bool, timeout: Duration) -> Result<(), IntegrationError> {
        self.wait_until(|| if condition() { Some(()) } else { None }, timeout).await
    }
}

// -----------------------------------------------------------------------------
// Service Management
// -----------------------------------------------------------------------------

/// Service trait
trait Service {
    async fn start() -> Result<(), ServiceError>
    async fn stop() -> Result<(), ServiceError>
    fn is_healthy() -> Bool
    fn base_url() -> Option<String> { None }
}

/// Service manager
actor ServiceManager {
    state services: Map<String, Box<dyn Service>>
    state started: Set<String>
    
    fn new() -> Self {
        ServiceManager { services: Map.empty(), started: Set.empty() }
    }
    
    on register(name: String, service: Box<dyn Service>) {
        self.services.set(name, service)
    }
    
    fn get<T: Service>(name: String) -> Option<T> {
        self.services.get(name)?.downcast::<T>()
    }
    
    fn get_http_service(name: String) -> Result<HTTPService, IntegrationError> {
        let service = self.services.get(name).ok_or(IntegrationError.ServiceNotFound(name))?
        let url = service.base_url().ok_or(IntegrationError.ServiceNotHTTP(name))?
        Ok(HTTPService { base_url: url })
    }
    
    async on start_all() -> Result<(), ServiceError> {
        for (name, service) in self.services {
            service.start().await?
            self.started.insert(name)
        }
        Ok(())
    }
    
    async on stop_all() -> Result<(), ServiceError> {
        for name in self.started.iter().rev() {
            if let service = self.services.get(name) {
                service.stop().await?
            }
        }
        self.started.clear()
        Ok(())
    }
    
    async fn wait_for_healthy(timeout: Duration) -> Result<(), ServiceError> {
        let start = Instant.now()
        while start.elapsed() < timeout {
            let all_healthy = self.services.values().all(|s| s.is_healthy())
            if all_healthy { return Ok(()) }
            sleep(Duration.millis(500)).await
        }
        Err(ServiceError.HealthCheckFailed)
    }
}

/// HTTP service wrapper
struct HTTPService {
    base_url: String
}

impl HTTPService {
    async fn get(path: String) -> Result<Response, HttpError> {
        http.get("\(self.base_url)\(path)")
    }
    
    async fn post<T: Serialize>(path: String, body: T) -> Result<Response, HttpError> {
        http.Client.new()
            .send(http.Request.post("\(self.base_url)\(path)").json(body))
    }
}

enum ServiceError {
    StartFailed(String)
    StopFailed(String)
    HealthCheckFailed
}

// -----------------------------------------------------------------------------
// Test Database
// -----------------------------------------------------------------------------

/// Test database with transaction isolation
actor TestDatabase {
    state connection: @native("DbConnection")
    state config: DatabaseConfig
    state transaction: Option<@native("DbTransaction")>
    
    async fn setup(config: DatabaseConfig) -> Result<Self, DatabaseError> {
        let conn = @native("db_connect", config.url)
            .map_err(|e| DatabaseError.ConnectionFailed(e.to_string()))?
        
        // Run migrations if needed
        if config.run_migrations {
            @native("db_migrate", conn, config.migrations_path)
                .map_err(|e| DatabaseError.MigrationFailed(e.to_string()))?
        }
        
        Ok(TestDatabase { connection: conn, config: config, transaction: None })
    }
    
    /// Begin transaction for test isolation
    async on begin_transaction() -> Result<(), DatabaseError> {
        let tx = @native("db_begin", self.connection)
            .map_err(|e| DatabaseError.TransactionFailed(e.to_string()))?
        self.transaction = Some(tx)
        Ok(())
    }
    
    /// Rollback transaction
    async on rollback() -> Result<(), DatabaseError> {
        if let tx = self.transaction {
            @native("db_rollback", tx)
                .map_err(|e| DatabaseError.TransactionFailed(e.to_string()))?
            self.transaction = None
        }
        Ok(())
    }
    
    /// Execute query
    async fn query<T: FromRow>(sql: String, params: [Any]) -> Result<[T], DatabaseError> {
        let conn = self.transaction.unwrap_or(self.connection)
        @native("db_query", conn, sql, params)
            .map_err(|e| DatabaseError.QueryFailed(e.to_string()))
    }
    
    /// Execute command
    async fn execute(sql: String, params: [Any]) -> Result<Int, DatabaseError> {
        let conn = self.transaction.unwrap_or(self.connection)
        @native("db_execute", conn, sql, params)
            .map_err(|e| DatabaseError.ExecuteFailed(e.to_string()))
    }
    
    /// Seed data
    async fn seed(table: String, data: [Map<String, Any>]) -> Result<(), DatabaseError> {
        for row in data {
            let columns = row.keys().join(", ")
            let placeholders = (0..row.len()).map(|i| "$\(i + 1)").join(", ")
            let sql = "INSERT INTO \(table) (\(columns)) VALUES (\(placeholders))"
            self.execute(sql, row.values().collect()).await?
        }
        Ok(())
    }
    
    /// Truncate tables
    async fn truncate(tables: [String]) -> Result<(), DatabaseError> {
        for table in tables {
            self.execute("TRUNCATE TABLE \(table) CASCADE", []).await?
        }
        Ok(())
    }
    
    /// Cleanup
    async fn cleanup() -> Result<(), DatabaseError> {
        self.rollback().await?
        @native("db_close", self.connection)
            .map_err(|e| DatabaseError.ConnectionFailed(e.to_string()))
    }
}

struct DatabaseConfig {
    url: String
    run_migrations: Bool
    migrations_path: String
    pool_size: Int
    
    fn default() -> Self {
        DatabaseConfig {
            url: "postgres://localhost/test",
            run_migrations: true,
            migrations_path: "./migrations",
            pool_size: 5
        }
    }
}

enum DatabaseError {
    ConnectionFailed(String)
    MigrationFailed(String)
    TransactionFailed(String)
    QueryFailed(String)
    ExecuteFailed(String)
}

trait FromRow {
    fn from_row(row: @native("DbRow")) -> Result<Self, DatabaseError>
}

// -----------------------------------------------------------------------------
// Test Message Queue
// -----------------------------------------------------------------------------

/// Test message queue
actor TestMessageQueue {
    state connection: @native("MQConnection")
    state config: MQConfig
    state published: [Message]
    
    async fn setup(config: MQConfig) -> Result<Self, MQError> {
        let conn = @native("mq_connect", config.url)
            .map_err(|e| MQError.ConnectionFailed(e.to_string()))?
        Ok(TestMessageQueue { connection: conn, config: config, published: [] })
    }
    
    /// Publish message
    async fn publish(topic: String, payload: Any) -> Result<(), MQError> {
        let message = Message {
            id: uuid.v4(),
            topic: topic,
            payload: payload,
            timestamp: Instant.now()
        }
        @native("mq_publish", self.connection, topic, json.encode(payload))
            .map_err(|e| MQError.PublishFailed(e.to_string()))?
        self.published.append(message)
        Ok(())
    }
    
    /// Consume messages
    async fn consume(topic: String, count: Int, timeout: Duration) -> Result<[Message], MQError> {
        @native("mq_consume", self.connection, topic, count, timeout.as_millis())
            .map_err(|e| MQError.ConsumeFailed(e.to_string()))
    }
    
    /// Get published messages (for assertions)
    fn get_published(topic: String) -> [Message] {
        self.published.filter(|m| m.topic == topic)
    }
    
    /// Clear published messages
    on clear_published() {
        self.published.clear()
    }
    
    /// Cleanup
    async fn cleanup() -> Result<(), MQError> {
        @native("mq_close", self.connection)
            .map_err(|e| MQError.ConnectionFailed(e.to_string()))
    }
}

struct MQConfig {
    url: String
    prefetch: Int
    
    fn default() -> Self {
        MQConfig { url: "amqp://localhost", prefetch: 10 }
    }
}

struct Message {
    id: String
    topic: String
    payload: Any
    timestamp: Instant
}

enum MQError {
    ConnectionFailed(String)
    PublishFailed(String)
    ConsumeFailed(String)
}

// -----------------------------------------------------------------------------
// Assertions
// -----------------------------------------------------------------------------

/// Integration test assertions
impl IntegrationContext {
    /// Assert HTTP response status
    fn assert_status(response: Response, expected: Int) -> Result<(), IntegrationError> {
        if response.status.code != expected {
            return Err(IntegrationError.AssertionFailed(
                "Expected status \(expected), got \(response.status.code)"
            ))
        }
        Ok(())
    }
    
    /// Assert JSON response
    fn assert_json<T: Deserialize + Eq>(response: Response, expected: T) -> Result<(), IntegrationError> {
        let actual: T = response.json().map_err(|e| IntegrationError.AssertionFailed(e.to_string()))?
        if actual != expected {
            return Err(IntegrationError.AssertionFailed("JSON mismatch"))
        }
        Ok(())
    }
    
    /// Assert database row exists
    async fn assert_row_exists(table: String, conditions: Map<String, Any>) -> Result<(), IntegrationError> {
        let where_clause = conditions.keys().enumerate().map(|(i, k)| "\(k) = $\(i + 1)").join(" AND ")
        let sql = "SELECT 1 FROM \(table) WHERE \(where_clause) LIMIT 1"
        let rows: [Any] = self.query(sql, conditions.values().collect()).await?
        if rows.is_empty() {
            return Err(IntegrationError.AssertionFailed("Row not found in \(table)"))
        }
        Ok(())
    }
    
    /// Assert message published
    fn assert_message_published(topic: String, predicate: (Message) -> Bool) -> Result<(), IntegrationError> {
        let mq = self.mq()?
        let messages = mq.get_published(topic)
        if !messages.any(predicate) {
            return Err(IntegrationError.AssertionFailed("Expected message not found in \(topic)"))
        }
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Results
// -----------------------------------------------------------------------------

enum TestStatus { Passed, Failed, Skipped }

struct TestResult {
    name: String
    status: TestStatus
    duration: Duration
    error: Option<IntegrationError>
}

struct SuiteResult {
    name: String
    status: TestStatus
    tests: [TestResult]
    duration: Duration
    error: Option<IntegrationError>
}

struct IntegrationSummary {
    total: Int
    passed: Int
    failed: Int
    suites: [SuiteResult]
    duration: Duration
    
    fn print() {
        println("\n" + "=".repeat(50))
        println("ðŸ”— Integration Test Summary")
        println("=".repeat(50))
        println("Total:  \(self.total)")
        println("Passed: \(self.passed) âœ…")
        println("Failed: \(self.failed) âŒ")
        println("Duration: \(self.duration.as_millis())ms")
        println("=".repeat(50) + "\n")
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum IntegrationError {
    ServiceNotFound(String)
    ServiceNotHTTP(String)
    NoDatabaseConfigured
    NoMessageQueueConfigured
    HTTP(HttpError)
    Database(DatabaseError)
    MessageQueue(MQError)
    Timeout
    WaitTimeout
    AssertionFailed(String)
    SetupFailed(String)
    
    fn message() -> String {
        match self {
            .ServiceNotFound(n) => "Service not found: \(n)"
            .ServiceNotHTTP(n) => "Service '\(n)' is not HTTP"
            .NoDatabaseConfigured => "No database configured"
            .NoMessageQueueConfigured => "No message queue configured"
            .HTTP(e) => "HTTP error"
            .Database(e) => "Database error"
            .MessageQueue(e) => "Message queue error"
            .Timeout => "Test timeout"
            .WaitTimeout => "Wait condition timeout"
            .AssertionFailed(m) => "Assertion failed: \(m)"
            .SetupFailed(m) => "Setup failed: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "integration runner" {
    let runner = IntegrationRunner.new()
        .suite("User Service", |s| {
            s.before_all(|ctx| Ok(()))
             .test("create user", |ctx| Ok(()))
             .test("get user", |ctx| Ok(()))
        })
    
    assert_eq(runner.suites.len(), 1)?
    assert_eq(runner.suites[0].tests.len(), 2)?
}

test "suite builder" {
    let suite = SuiteBuilder.new("API Tests")
        .timeout(Duration.seconds(10))
        .before_each(|ctx| Ok(()))
        .test("test 1", |ctx| Ok(()))
        .test("test 2", |ctx| Ok(()))
        .build()
    
    assert_eq(suite.name, "API Tests")?
    assert_eq(suite.tests.len(), 2)?
}

test "database config" {
    let config = DatabaseConfig.default()
    assert_eq(config.run_migrations, true)?
    assert_eq(config.pool_size, 5)?
}

test "message queue config" {
    let config = MQConfig.default()
    assert_eq(config.prefetch, 10)?
}
