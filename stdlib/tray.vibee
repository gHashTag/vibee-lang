// =============================================================================
// Vibee OS â€” System Tray Module
// System tray icon and menu management
// =============================================================================

use image.{Image, ImageFormat}

// =============================================================================
// Tray Icon
// =============================================================================

struct TrayIcon {
    id: String
    tooltip: String
    icon: TrayIconSource
    visible: Bool
    menu: Option<TrayMenu>
}

enum TrayIconSource {
    Path(String),
    Image(Image),
    SystemIcon(SystemIconType),
    Embedded(String)  // Resource name
}

enum SystemIconType {
    Application,
    Information,
    Warning,
    Error,
    Question,
    Shield,
    User,
    Settings,
    Network,
    NetworkOffline,
    Battery,
    BatteryLow,
    BatteryCharging,
    Volume,
    VolumeMute,
    Mail,
    MailNew,
    Calendar,
    Clock,
    Sync,
    SyncError,
    Update,
    Download,
    Upload,
    Pause,
    Play,
    Stop
    
    fn name() -> String {
        match self {
            .Application => "application",
            .Information => "info",
            .Warning => "warning",
            .Error => "error",
            .Question => "question",
            .Shield => "shield",
            .User => "user",
            .Settings => "settings",
            .Network => "network",
            .NetworkOffline => "network-offline",
            .Battery => "battery",
            .BatteryLow => "battery-low",
            .BatteryCharging => "battery-charging",
            .Volume => "volume",
            .VolumeMute => "volume-mute",
            .Mail => "mail",
            .MailNew => "mail-new",
            .Calendar => "calendar",
            .Clock => "clock",
            .Sync => "sync",
            .SyncError => "sync-error",
            .Update => "update",
            .Download => "download",
            .Upload => "upload",
            .Pause => "pause",
            .Play => "play",
            .Stop => "stop"
        }
    }
}

impl TrayIcon {
    fn new(id: String) -> Self {
        TrayIcon {
            id: id,
            tooltip: "",
            icon: TrayIconSource.SystemIcon(SystemIconType.Application),
            visible: true,
            menu: None
        }
    }
    
    fn tooltip(text: String) -> Self { self.tooltip = text; self }
    fn icon_path(path: String) -> Self { self.icon = TrayIconSource.Path(path); self }
    fn icon_image(img: Image) -> Self { self.icon = TrayIconSource.Image(img); self }
    fn icon_system(icon_type: SystemIconType) -> Self { self.icon = TrayIconSource.SystemIcon(icon_type); self }
    fn icon_embedded(name: String) -> Self { self.icon = TrayIconSource.Embedded(name); self }
    fn menu(m: TrayMenu) -> Self { self.menu = Some(m); self }
    fn hidden() -> Self { self.visible = false; self }
    
    fn show() -> Self { self.visible = true; self }
    fn hide() -> Self { self.visible = false; self }
    fn toggle_visibility() -> Self { self.visible = !self.visible; self }
}

// =============================================================================
// Tray Menu
// =============================================================================

struct TrayMenu {
    items: [TrayMenuItem]
}

impl TrayMenu {
    fn new() -> Self {
        TrayMenu { items: [] }
    }
    
    fn item(item: TrayMenuItem) -> Self {
        self.items.push(item); self
    }
    
    fn action(id: String, label: String, callback: fn()) -> Self {
        self.items.push(TrayMenuItem.action(id, label, callback)); self
    }
    
    fn checkbox(id: String, label: String, checked: Bool, callback: fn(Bool)) -> Self {
        self.items.push(TrayMenuItem.checkbox(id, label, checked, callback)); self
    }
    
    fn submenu(label: String, menu: TrayMenu) -> Self {
        self.items.push(TrayMenuItem.submenu(label, menu)); self
    }
    
    fn separator() -> Self {
        self.items.push(TrayMenuItem.Separator); self
    }
    
    fn quit(label: String) -> Self {
        self.items.push(TrayMenuItem.action("quit", label, || { @native("app_quit") })); self
    }
    
    fn quit_default() -> Self {
        self.quit("Quit")
    }
}

// =============================================================================
// Tray Menu Item
// =============================================================================

enum TrayMenuItem {
    Action {
        id: String,
        label: String,
        icon: Option<TrayIconSource>,
        enabled: Bool,
        shortcut: Option<String>,
        callback: fn()
    },
    Checkbox {
        id: String,
        label: String,
        checked: Bool,
        enabled: Bool,
        callback: fn(Bool)
    },
    Radio {
        id: String,
        label: String,
        group: String,
        selected: Bool,
        enabled: Bool,
        callback: fn()
    },
    Submenu {
        label: String,
        icon: Option<TrayIconSource>,
        enabled: Bool,
        menu: TrayMenu
    },
    Separator,
    Label(String),
    Custom {
        id: String,
        widget: Box<dyn TrayWidget>
    }
}

impl TrayMenuItem {
    fn action(id: String, label: String, callback: fn()) -> Self {
        TrayMenuItem.Action {
            id: id,
            label: label,
            icon: None,
            enabled: true,
            shortcut: None,
            callback: callback
        }
    }
    
    fn action_with_icon(id: String, label: String, icon: TrayIconSource, callback: fn()) -> Self {
        TrayMenuItem.Action {
            id: id,
            label: label,
            icon: Some(icon),
            enabled: true,
            shortcut: None,
            callback: callback
        }
    }
    
    fn checkbox(id: String, label: String, checked: Bool, callback: fn(Bool)) -> Self {
        TrayMenuItem.Checkbox {
            id: id,
            label: label,
            checked: checked,
            enabled: true,
            callback: callback
        }
    }
    
    fn radio(id: String, label: String, group: String, selected: Bool, callback: fn()) -> Self {
        TrayMenuItem.Radio {
            id: id,
            label: label,
            group: group,
            selected: selected,
            enabled: true,
            callback: callback
        }
    }
    
    fn submenu(label: String, menu: TrayMenu) -> Self {
        TrayMenuItem.Submenu {
            label: label,
            icon: None,
            enabled: true,
            menu: menu
        }
    }
    
    fn label(text: String) -> Self {
        TrayMenuItem.Label(text)
    }
    
    fn is_separator() -> Bool {
        match self {
            TrayMenuItem.Separator => true,
            _ => false
        }
    }
    
    fn id() -> Option<String> {
        match self {
            TrayMenuItem.Action { id, .. } => Some(id),
            TrayMenuItem.Checkbox { id, .. } => Some(id),
            TrayMenuItem.Radio { id, .. } => Some(id),
            TrayMenuItem.Custom { id, .. } => Some(id),
            _ => None
        }
    }
}

// =============================================================================
// Tray Widget Trait
// =============================================================================

trait TrayWidget {
    fn render() -> TrayWidgetContent
    fn on_click(x: Int, y: Int)
    fn preferred_size() -> (Int, Int)
}

enum TrayWidgetContent {
    Text(String),
    Image(Image),
    Progress { value: Float, max: Float },
    Slider { value: Float, min: Float, max: Float }
}

// =============================================================================
// Tray Event
// =============================================================================

enum TrayEvent {
    Click { x: Int, y: Int, button: MouseButton },
    DoubleClick { x: Int, y: Int },
    RightClick { x: Int, y: Int },
    MiddleClick { x: Int, y: Int },
    MouseEnter,
    MouseLeave,
    MenuItemClicked(String),
    BalloonClicked,
    BalloonClosed
}

enum MouseButton {
    Left,
    Right,
    Middle
}

// =============================================================================
// Tray Manager Actor
// =============================================================================

actor TrayManager {
    state icons: Map<String, TrayIcon>
    state event_handlers: Map<String, [fn(TrayEvent)]>
    state balloon_queue: [BalloonNotification]
    state settings: TraySettings
    
    fn new() -> Self {
        TrayManager {
            icons: Map.empty(),
            event_handlers: Map.empty(),
            balloon_queue: [],
            settings: TraySettings.default()
        }
    }
    
    fn with_settings(settings: TraySettings) -> Self {
        let mut mgr = TrayManager.new();
        mgr.settings = settings;
        mgr
    }
    
    // --- Icon Management ---
    
    on add(icon: TrayIcon) -> Result<(), TrayError> {
        if self.icons.contains_key(icon.id.clone()) {
            return Err(TrayError.IconAlreadyExists(icon.id))
        }
        
        @native("tray_add_icon", icon.clone())?;
        self.icons.set(icon.id.clone(), icon);
        Ok(())
    }
    
    on remove(id: String) -> Result<(), TrayError> {
        if !self.icons.contains_key(id.clone()) {
            return Err(TrayError.IconNotFound(id))
        }
        
        @native("tray_remove_icon", id.clone())?;
        self.icons.remove(id.clone());
        self.event_handlers.remove(id);
        Ok(())
    }
    
    on update(id: String, updater: fn(TrayIcon) -> TrayIcon) -> Result<(), TrayError> {
        match self.icons.get(id.clone()) {
            Some(icon) => {
                let updated = updater(icon.clone());
                @native("tray_update_icon", updated.clone())?;
                self.icons.set(id, updated);
                Ok(())
            },
            None => Err(TrayError.IconNotFound(id))
        }
    }
    
    fn get(id: String) -> Option<TrayIcon> {
        self.icons.get(id)
    }
    
    fn all() -> [TrayIcon] {
        self.icons.values().collect()
    }
    
    // --- Tooltip ---
    
    on set_tooltip(id: String, tooltip: String) -> Result<(), TrayError> {
        self.update(id, |icon| {
            let mut i = icon;
            i.tooltip = tooltip;
            i
        })
    }
    
    // --- Icon Updates ---
    
    on set_icon(id: String, source: TrayIconSource) -> Result<(), TrayError> {
        self.update(id, |icon| {
            let mut i = icon;
            i.icon = source;
            i
        })
    }
    
    // --- Visibility ---
    
    on show(id: String) -> Result<(), TrayError> {
        self.update(id, |icon| icon.show())
    }
    
    on hide(id: String) -> Result<(), TrayError> {
        self.update(id, |icon| icon.hide())
    }
    
    on show_all() {
        for (id, _) in self.icons.iter() {
            self.show(id.clone());
        }
    }
    
    on hide_all() {
        for (id, _) in self.icons.iter() {
            self.hide(id.clone());
        }
    }
    
    // --- Menu ---
    
    on set_menu(id: String, menu: TrayMenu) -> Result<(), TrayError> {
        self.update(id, |icon| {
            let mut i = icon;
            i.menu = Some(menu);
            i
        })
    }
    
    on update_menu_item(icon_id: String, item_id: String, updater: fn(TrayMenuItem) -> TrayMenuItem) -> Result<(), TrayError> {
        match self.icons.get(icon_id.clone()) {
            Some(icon) => {
                if let Some(menu) = icon.menu.clone() {
                    let updated_menu = self.update_menu_item_recursive(menu, item_id, updater);
                    self.set_menu(icon_id, updated_menu)
                } else {
                    Err(TrayError.NoMenu(icon_id))
                }
            },
            None => Err(TrayError.IconNotFound(icon_id))
        }
    }
    
    fn update_menu_item_recursive(menu: TrayMenu, item_id: String, updater: fn(TrayMenuItem) -> TrayMenuItem) -> TrayMenu {
        let mut new_items: [TrayMenuItem] = [];
        for item in menu.items.iter() {
            let new_item = match item.id() {
                Some(id) if id == item_id => updater(item.clone()),
                _ => {
                    match item {
                        TrayMenuItem.Submenu { label, icon, enabled, menu: sub } => {
                            TrayMenuItem.Submenu {
                                label: label.clone(),
                                icon: icon.clone(),
                                enabled: *enabled,
                                menu: self.update_menu_item_recursive(sub.clone(), item_id.clone(), updater)
                            }
                        },
                        _ => item.clone()
                    }
                }
            };
            new_items.push(new_item);
        }
        TrayMenu { items: new_items }
    }
    
    // --- Event Handling ---
    
    on on_event(id: String, handler: fn(TrayEvent)) {
        let mut handlers = self.event_handlers.get(id.clone()).unwrap_or([]);
        handlers.push(handler);
        self.event_handlers.set(id, handlers);
    }
    
    on on_click(id: String, handler: fn()) {
        self.on_event(id, |event| {
            match event {
                TrayEvent.Click { button: MouseButton.Left, .. } => handler(),
                _ => {}
            }
        })
    }
    
    on on_double_click(id: String, handler: fn()) {
        self.on_event(id, |event| {
            match event {
                TrayEvent.DoubleClick { .. } => handler(),
                _ => {}
            }
        })
    }
    
    on on_right_click(id: String, handler: fn()) {
        self.on_event(id, |event| {
            match event {
                TrayEvent.RightClick { .. } => handler(),
                _ => {}
            }
        })
    }
    
    on dispatch_event(id: String, event: TrayEvent) {
        if let Some(handlers) = self.event_handlers.get(id) {
            for handler in handlers.iter() {
                handler(event.clone());
            }
        }
    }
    
    // --- Balloon Notifications ---
    
    on show_balloon(id: String, notification: BalloonNotification) -> Result<(), TrayError> {
        if !self.icons.contains_key(id.clone()) {
            return Err(TrayError.IconNotFound(id))
        }
        
        @native("tray_show_balloon", id, notification)?;
        Ok(())
    }
    
    on hide_balloon(id: String) -> Result<(), TrayError> {
        @native("tray_hide_balloon", id)?;
        Ok(())
    }
}

// =============================================================================
// Balloon Notification
// =============================================================================

struct BalloonNotification {
    title: String
    message: String
    icon: BalloonIcon
    timeout: Duration
    sound: Bool
}

enum BalloonIcon {
    None,
    Info,
    Warning,
    Error,
    Custom(TrayIconSource)
}

impl BalloonNotification {
    fn new(title: String, message: String) -> Self {
        BalloonNotification {
            title: title,
            message: message,
            icon: BalloonIcon.Info,
            timeout: Duration.from_seconds(5),
            sound: true
        }
    }
    
    fn info(title: String, message: String) -> Self {
        BalloonNotification.new(title, message).icon(BalloonIcon.Info)
    }
    
    fn warning(title: String, message: String) -> Self {
        BalloonNotification.new(title, message).icon(BalloonIcon.Warning)
    }
    
    fn error(title: String, message: String) -> Self {
        BalloonNotification.new(title, message).icon(BalloonIcon.Error)
    }
    
    fn icon(i: BalloonIcon) -> Self { self.icon = i; self }
    fn timeout(d: Duration) -> Self { self.timeout = d; self }
    fn timeout_seconds(s: Int) -> Self { self.timeout = Duration.from_seconds(s); self }
    fn silent() -> Self { self.sound = false; self }
}

// =============================================================================
// Tray Settings
// =============================================================================

struct TraySettings {
    auto_hide_on_close: Bool
    show_on_startup: Bool
    single_click_action: SingleClickAction
    animate_icon: Bool
    balloon_timeout: Duration
}

enum SingleClickAction {
    ShowMenu,
    ToggleWindow,
    Custom(fn())
}

impl TraySettings {
    fn default() -> Self {
        TraySettings {
            auto_hide_on_close: true,
            show_on_startup: true,
            single_click_action: SingleClickAction.ShowMenu,
            animate_icon: false,
            balloon_timeout: Duration.from_seconds(5)
        }
    }
    
    fn hide_on_close() -> Self { self.auto_hide_on_close = true; self }
    fn close_on_close() -> Self { self.auto_hide_on_close = false; self }
    fn hide_on_startup() -> Self { self.show_on_startup = false; self }
    fn click_shows_menu() -> Self { self.single_click_action = SingleClickAction.ShowMenu; self }
    fn click_toggles_window() -> Self { self.single_click_action = SingleClickAction.ToggleWindow; self }
    fn click_action(action: fn()) -> Self { self.single_click_action = SingleClickAction.Custom(action); self }
    fn animate() -> Self { self.animate_icon = true; self }
    fn balloon_timeout(d: Duration) -> Self { self.balloon_timeout = d; self }
}

// =============================================================================
// Tray Errors
// =============================================================================

enum TrayError {
    IconNotFound(String),
    IconAlreadyExists(String),
    NoMenu(String),
    SystemError(String),
    InvalidIcon,
    NotSupported,
    PermissionDenied
    
    fn message() -> String {
        match self {
            .IconNotFound(id) => f"Tray icon not found: {id}",
            .IconAlreadyExists(id) => f"Tray icon already exists: {id}",
            .NoMenu(id) => f"No menu attached to icon: {id}",
            .SystemError(msg) => f"System error: {msg}",
            .InvalidIcon => "Invalid icon format or path",
            .NotSupported => "System tray not supported on this platform",
            .PermissionDenied => "Permission denied for system tray access"
        }
    }
}

// =============================================================================
// Animated Tray Icon
// =============================================================================

struct AnimatedTrayIcon {
    id: String
    frames: [TrayIconSource]
    frame_duration: Duration
    current_frame: Int
    playing: Bool
    loop_count: Int  // 0 = infinite
    loops_completed: Int
}

impl AnimatedTrayIcon {
    fn new(id: String, frames: [TrayIconSource]) -> Self {
        AnimatedTrayIcon {
            id: id,
            frames: frames,
            frame_duration: Duration.from_millis(100),
            current_frame: 0,
            playing: false,
            loop_count: 0,
            loops_completed: 0
        }
    }
    
    fn frame_duration(d: Duration) -> Self { self.frame_duration = d; self }
    fn fps(fps: Int) -> Self { 
        self.frame_duration = Duration.from_millis(1000 / fps); 
        self 
    }
    fn loop_count(n: Int) -> Self { self.loop_count = n; self }
    fn once() -> Self { self.loop_count = 1; self }
    
    fn play(manager: TrayManager) {
        self.playing = true;
        self.loops_completed = 0;
        self.animate_loop(manager);
    }
    
    fn stop() {
        self.playing = false;
    }
    
    fn pause() {
        self.playing = false;
    }
    
    fn resume(manager: TrayManager) {
        self.playing = true;
        self.animate_loop(manager);
    }
    
    fn animate_loop(manager: TrayManager) {
        while self.playing {
            // Update icon
            let frame = self.frames[self.current_frame].clone();
            manager.set_icon(self.id.clone(), frame);
            
            // Next frame
            self.current_frame = (self.current_frame + 1) % self.frames.len();
            
            // Check loop completion
            if self.current_frame == 0 {
                self.loops_completed += 1;
                if self.loop_count > 0 && self.loops_completed >= self.loop_count {
                    self.playing = false;
                    break;
                }
            }
            
            sleep(self.frame_duration);
        }
    }
}

// =============================================================================
// Global Tray Manager Instance
// =============================================================================

static TRAY: TrayManager = TrayManager.new()

/// Add a tray icon
fn add(icon: TrayIcon) -> Result<(), TrayError> {
    TRAY.add(icon)
}

/// Remove a tray icon
fn remove(id: String) -> Result<(), TrayError> {
    TRAY.remove(id)
}

/// Create and add a simple tray icon
fn create(id: String, tooltip: String, icon_path: String) -> Result<(), TrayError> {
    let icon = TrayIcon.new(id)
        .tooltip(tooltip)
        .icon_path(icon_path);
    TRAY.add(icon)
}

/// Show a balloon notification
fn notify(icon_id: String, title: String, message: String) -> Result<(), TrayError> {
    let balloon = BalloonNotification.new(title, message);
    TRAY.show_balloon(icon_id, balloon)
}

// =============================================================================
// Tests
// =============================================================================

test "tray icon creation" {
    let icon = TrayIcon.new("test")
        .tooltip("Test Application")
        .icon_system(SystemIconType.Application);
    
    assert_eq(icon.id, "test")?
    assert_eq(icon.tooltip, "Test Application")?
    assert(icon.visible)?
}

test "tray menu creation" {
    let menu = TrayMenu.new()
        .action("open", "Open", || {})
        .separator()
        .checkbox("auto_start", "Start on boot", false, |_| {})
        .submenu("Settings", TrayMenu.new()
            .action("prefs", "Preferences", || {}))
        .separator()
        .quit_default();
    
    assert_eq(menu.items.len(), 6)?
}

test "balloon notification" {
    let balloon = BalloonNotification.info("Update", "New version available")
        .timeout_seconds(10)
        .silent();
    
    assert_eq(balloon.title, "Update")?
    assert(!balloon.sound)?
}

test "tray settings" {
    let settings = TraySettings.default()
        .hide_on_close()
        .click_toggles_window()
        .animate();
    
    assert(settings.auto_hide_on_close)?
    assert(settings.animate_icon)?
}

test "system icon types" {
    assert_eq(SystemIconType.Warning.name(), "warning")?
    assert_eq(SystemIconType.Network.name(), "network")?
    assert_eq(SystemIconType.BatteryCharging.name(), "battery-charging")?
}

test "menu item id" {
    let action = TrayMenuItem.action("test_action", "Test", || {});
    assert_eq(action.id(), Some("test_action"))?
    
    let sep = TrayMenuItem.Separator;
    assert_eq(sep.id(), None)?
}
