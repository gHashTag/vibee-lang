// =============================================================================
// Vibee OS â€” KV Module
// Key-Value Storage with multiple backends support
// =============================================================================

// =============================================================================
// KV Store Trait
// =============================================================================

/// Generic Key-Value store trait
trait KVStore<K: Hash + Eq, V> {
    fn get(key: K) -> Result<Option<V>, KVError>
    fn set(key: K, value: V) -> Result<(), KVError>
    fn delete(key: K) -> Result<Bool, KVError>
    fn exists(key: K) -> Result<Bool, KVError>
    fn keys() -> Result<[K], KVError>
    fn clear() -> Result<(), KVError>
    fn len() -> Result<Int, KVError>
}

// =============================================================================
// KV Error
// =============================================================================

enum KVError {
    NotFound
    ConnectionFailed(String)
    SerializationError(String)
    DeserializationError(String)
    StorageFull
    KeyTooLarge
    ValueTooLarge
    Timeout
    PermissionDenied
    Corrupted(String)
    Other(String)
}

impl Display for KVError {
    fn fmt(f: Formatter) {
        match self {
            .NotFound => f.write("Key not found")
            .ConnectionFailed(msg) => f.write("Connection failed: \(msg)")
            .SerializationError(msg) => f.write("Serialization error: \(msg)")
            .DeserializationError(msg) => f.write("Deserialization error: \(msg)")
            .StorageFull => f.write("Storage is full")
            .KeyTooLarge => f.write("Key is too large")
            .ValueTooLarge => f.write("Value is too large")
            .Timeout => f.write("Operation timed out")
            .PermissionDenied => f.write("Permission denied")
            .Corrupted(msg) => f.write("Data corrupted: \(msg)")
            .Other(msg) => f.write(msg)
        }
    }
}

// =============================================================================
// In-Memory KV Store
// =============================================================================

/// Thread-safe in-memory key-value store
actor MemoryKV<K: Hash + Eq + Clone, V: Clone> {
    state data: Map<K, V>
    state max_size: Option<Int>
    
    init() {
        self.data = Map.empty()
        self.max_size = None
    }
    
    init(max_size: Int) {
        self.data = Map.empty()
        self.max_size = Some(max_size)
    }
    
    on get(key: K) -> Result<Option<V>, KVError> {
        Ok(self.data.get(key).cloned())
    }
    
    on set(key: K, value: V) -> Result<(), KVError> {
        if let Some(max) = self.max_size {
            if !self.data.contains(key) && self.data.len() >= max {
                return Err(KVError.StorageFull)
            }
        }
        self.data.set(key, value)
        Ok(())
    }
    
    on delete(key: K) -> Result<Bool, KVError> {
        Ok(self.data.remove(key).is_some())
    }
    
    on exists(key: K) -> Result<Bool, KVError> {
        Ok(self.data.contains(key))
    }
    
    on keys() -> Result<[K], KVError> {
        Ok(self.data.keys().collect())
    }
    
    on values() -> Result<[V], KVError> {
        Ok(self.data.values().collect())
    }
    
    on entries() -> Result<[(K, V)], KVError> {
        Ok(self.data.iter().collect())
    }
    
    on clear() -> Result<(), KVError> {
        self.data.clear()
        Ok(())
    }
    
    on len() -> Result<Int, KVError> {
        Ok(self.data.len())
    }
    
    on is_empty() -> Result<Bool, KVError> {
        Ok(self.data.is_empty())
    }
    
    /// Get or insert with default value
    on get_or_insert(key: K, default: V) -> Result<V, KVError> {
        if let Some(v) = self.data.get(key) {
            Ok(v.clone())
        } else {
            self.set(key.clone(), default.clone())?
            Ok(default)
        }
    }
    
    /// Get or insert with function
    on get_or_insert_with(key: K, f: fn() -> V) -> Result<V, KVError> {
        if let Some(v) = self.data.get(key) {
            Ok(v.clone())
        } else {
            let value = f()
            self.set(key.clone(), value.clone())?
            Ok(value)
        }
    }
    
    /// Update value with function
    on update(key: K, f: fn(V) -> V) -> Result<Option<V>, KVError> {
        if let Some(v) = self.data.get(key) {
            let new_value = f(v.clone())
            self.data.set(key, new_value.clone())
            Ok(Some(new_value))
        } else {
            Ok(None)
        }
    }
    
    /// Increment numeric value
    on incr(key: K, delta: Int) -> Result<Int, KVError> where V: Into<Int> + From<Int> {
        let current = self.data.get(key).map(|v| v.into()).unwrap_or(0)
        let new_value = current + delta
        self.data.set(key, V.from(new_value))
        Ok(new_value)
    }
    
    /// Batch get
    on mget(keys: [K]) -> Result<[Option<V>], KVError> {
        Ok(keys.iter().map(|k| self.data.get(*k).cloned()).collect())
    }
    
    /// Batch set
    on mset(entries: [(K, V)]) -> Result<(), KVError> {
        for (k, v) in entries {
            self.set(k, v)?
        }
        Ok(())
    }
    
    /// Batch delete
    on mdel(keys: [K]) -> Result<Int, KVError> {
        var deleted = 0
        for k in keys {
            if self.data.remove(k).is_some() {
                deleted += 1
            }
        }
        Ok(deleted)
    }
}

impl<K: Hash + Eq + Clone, V: Clone> KVStore<K, V> for MemoryKV<K, V> {
    fn get(key: K) -> Result<Option<V>, KVError> { self.get(key) }
    fn set(key: K, value: V) -> Result<(), KVError> { self.set(key, value) }
    fn delete(key: K) -> Result<Bool, KVError> { self.delete(key) }
    fn exists(key: K) -> Result<Bool, KVError> { self.exists(key) }
    fn keys() -> Result<[K], KVError> { self.keys() }
    fn clear() -> Result<(), KVError> { self.clear() }
    fn len() -> Result<Int, KVError> { self.len() }
}

// =============================================================================
// TTL KV Store
// =============================================================================

/// Key-value store with TTL support
actor TTLKV<K: Hash + Eq + Clone, V: Clone> {
    state data: Map<K, (V, Int64)>
    state default_ttl_ms: Int64
    
    init(default_ttl_ms: Int64) {
        self.data = Map.empty()
        self.default_ttl_ms = default_ttl_ms
    }
    
    on get(key: K) -> Result<Option<V>, KVError> {
        let now = @native("timestamp_ms")
        if let Some((value, expires)) = self.data.get(key) {
            if now < *expires {
                return Ok(Some(value.clone()))
            }
            self.data.remove(key)
        }
        Ok(None)
    }
    
    on set(key: K, value: V) -> Result<(), KVError> {
        self.set_with_ttl(key, value, self.default_ttl_ms)
    }
    
    on set_with_ttl(key: K, value: V, ttl_ms: Int64) -> Result<(), KVError> {
        let expires = @native("timestamp_ms") + ttl_ms
        self.data.set(key, (value, expires))
        Ok(())
    }
    
    on delete(key: K) -> Result<Bool, KVError> {
        Ok(self.data.remove(key).is_some())
    }
    
    on exists(key: K) -> Result<Bool, KVError> {
        self.get(key).map(|v| v.is_some())
    }
    
    on ttl(key: K) -> Result<Option<Int64>, KVError> {
        let now = @native("timestamp_ms")
        if let Some((_, expires)) = self.data.get(key) {
            if now < *expires {
                return Ok(Some(*expires - now))
            }
        }
        Ok(None)
    }
    
    on expire(key: K, ttl_ms: Int64) -> Result<Bool, KVError> {
        if let Some((value, _)) = self.data.get(key) {
            let expires = @native("timestamp_ms") + ttl_ms
            self.data.set(key, (value.clone(), expires))
            Ok(true)
        } else {
            Ok(false)
        }
    }
    
    on persist(key: K) -> Result<Bool, KVError> {
        if let Some((value, _)) = self.data.get(key) {
            self.data.set(key, (value.clone(), Int64.MAX))
            Ok(true)
        } else {
            Ok(false)
        }
    }
    
    on keys() -> Result<[K], KVError> {
        let now = @native("timestamp_ms")
        Ok(self.data.iter()
            .filter(|(_, (_, expires))| now < *expires)
            .map(|(k, _)| k.clone())
            .collect())
    }
    
    on clear() -> Result<(), KVError> {
        self.data.clear()
        Ok(())
    }
    
    on len() -> Result<Int, KVError> {
        let now = @native("timestamp_ms")
        Ok(self.data.iter().filter(|(_, (_, expires))| now < *expires).count())
    }
    
    /// Remove expired entries
    on cleanup() -> Int {
        let now = @native("timestamp_ms")
        let expired: [K] = self.data.iter()
            .filter(|(_, (_, expires))| now >= *expires)
            .map(|(k, _)| k.clone())
            .collect()
        let count = expired.len()
        for k in expired {
            self.data.remove(k)
        }
        count
    }
    
    /// Touch key (reset TTL)
    on touch(key: K) -> Result<Bool, KVError> {
        self.expire(key, self.default_ttl_ms)
    }
}

// =============================================================================
// Persistent KV Store (File-based)
// =============================================================================

/// File-based persistent key-value store
actor PersistentKV<K: Hash + Eq + Clone + Serialize + Deserialize, V: Clone + Serialize + Deserialize> {
    state path: String
    state data: Map<K, V>
    state auto_save: Bool
    state dirty: Bool
    
    init(path: String) {
        self.path = path
        self.data = Map.empty()
        self.auto_save = true
        self.dirty = false
        self.load()
    }
    
    fn load() {
        if fs.exists(self.path) {
            match fs.read_string(self.path) {
                Ok(content) => {
                    match json.decode::<Map<K, V>>(content) {
                        Ok(data) => self.data = data
                        Err(_) => {}
                    }
                }
                Err(_) => {}
            }
        }
    }
    
    on save() -> Result<(), KVError> {
        let content = json.encode(self.data)
        fs.write_string(self.path, content)
            .map_err(|e| KVError.Other(e.to_string()))?
        self.dirty = false
        Ok(())
    }
    
    on get(key: K) -> Result<Option<V>, KVError> {
        Ok(self.data.get(key).cloned())
    }
    
    on set(key: K, value: V) -> Result<(), KVError> {
        self.data.set(key, value)
        self.dirty = true
        if self.auto_save {
            self.save()?
        }
        Ok(())
    }
    
    on delete(key: K) -> Result<Bool, KVError> {
        let existed = self.data.remove(key).is_some()
        if existed {
            self.dirty = true
            if self.auto_save {
                self.save()?
            }
        }
        Ok(existed)
    }
    
    on exists(key: K) -> Result<Bool, KVError> {
        Ok(self.data.contains(key))
    }
    
    on keys() -> Result<[K], KVError> {
        Ok(self.data.keys().collect())
    }
    
    on clear() -> Result<(), KVError> {
        self.data.clear()
        self.dirty = true
        if self.auto_save {
            self.save()?
        }
        Ok(())
    }
    
    on len() -> Result<Int, KVError> {
        Ok(self.data.len())
    }
    
    on set_auto_save(enabled: Bool) {
        self.auto_save = enabled
    }
    
    on is_dirty() -> Bool {
        self.dirty
    }
    
    on reload() -> Result<(), KVError> {
        self.load()
        self.dirty = false
        Ok(())
    }
}

// =============================================================================
// Namespaced KV Store
// =============================================================================

/// KV store with namespace/prefix support
struct NamespacedKV<K: Hash + Eq + Clone, V: Clone, S: KVStore<String, V>> {
    store: S
    namespace: String
    separator: String
}

impl<K: Hash + Eq + Clone + Display, V: Clone, S: KVStore<String, V>> NamespacedKV<K, V, S> {
    fn new(store: S, namespace: String) -> Self {
        NamespacedKV { store: store, namespace: namespace, separator: ":" }
    }
    
    fn with_separator(store: S, namespace: String, separator: String) -> Self {
        NamespacedKV { store: store, namespace: namespace, separator: separator }
    }
    
    fn make_key(key: K) -> String {
        "\(self.namespace)\(self.separator)\(key)"
    }
    
    fn get(key: K) -> Result<Option<V>, KVError> {
        self.store.get(self.make_key(key))
    }
    
    fn set(key: K, value: V) -> Result<(), KVError> {
        self.store.set(self.make_key(key), value)
    }
    
    fn delete(key: K) -> Result<Bool, KVError> {
        self.store.delete(self.make_key(key))
    }
    
    fn exists(key: K) -> Result<Bool, KVError> {
        self.store.exists(self.make_key(key))
    }
    
    /// Create sub-namespace
    fn namespace(sub: String) -> NamespacedKV<K, V, S> {
        NamespacedKV {
            store: self.store,
            namespace: "\(self.namespace)\(self.separator)\(sub)",
            separator: self.separator
        }
    }
}

// =============================================================================
// Typed KV Store
// =============================================================================

/// Type-safe wrapper for string-based KV stores
struct TypedKV<V: Serialize + Deserialize, S: KVStore<String, String>> {
    store: S
}

impl<V: Serialize + Deserialize, S: KVStore<String, String>> TypedKV<V, S> {
    fn new(store: S) -> Self {
        TypedKV { store: store }
    }
    
    fn get(key: String) -> Result<Option<V>, KVError> {
        match self.store.get(key)? {
            Some(s) => {
                json.decode::<V>(s)
                    .map(|v| Some(v))
                    .map_err(|e| KVError.DeserializationError(e.to_string()))
            }
            None => Ok(None)
        }
    }
    
    fn set(key: String, value: V) -> Result<(), KVError> {
        let s = json.encode(value)
        self.store.set(key, s)
    }
    
    fn delete(key: String) -> Result<Bool, KVError> {
        self.store.delete(key)
    }
    
    fn exists(key: String) -> Result<Bool, KVError> {
        self.store.exists(key)
    }
}

// =============================================================================
// KV Transaction
// =============================================================================

/// Transaction for batch operations
struct KVTransaction<K: Hash + Eq + Clone, V: Clone> {
    operations: [KVOperation<K, V>]
}

enum KVOperation<K, V> {
    Set(K, V)
    Delete(K)
    Clear
}

impl<K: Hash + Eq + Clone, V: Clone> KVTransaction<K, V> {
    fn new() -> Self {
        KVTransaction { operations: [] }
    }
    
    fn set(key: K, value: V) -> Self {
        self.operations.push(KVOperation.Set(key, value))
        self
    }
    
    fn delete(key: K) -> Self {
        self.operations.push(KVOperation.Delete(key))
        self
    }
    
    fn clear() -> Self {
        self.operations.push(KVOperation.Clear)
        self
    }
    
    fn execute<S: KVStore<K, V>>(store: S) -> Result<(), KVError> {
        for op in self.operations {
            match op {
                .Set(k, v) => store.set(k, v)?
                .Delete(k) => { store.delete(k)?; }
                .Clear => store.clear()?
            }
        }
        Ok(())
    }
}

// =============================================================================
// KV Watcher
// =============================================================================

/// Watch for key changes
actor KVWatcher<K: Hash + Eq + Clone, V: Clone> {
    state callbacks: Map<K, [fn(K, Option<V>, Option<V>)]>
    state global_callbacks: [fn(K, Option<V>, Option<V>)]
    
    init() {
        self.callbacks = Map.empty()
        self.global_callbacks = []
    }
    
    on watch(key: K, callback: fn(K, Option<V>, Option<V>)) {
        if !self.callbacks.contains(key) {
            self.callbacks.set(key.clone(), [])
        }
        self.callbacks.get_mut(key).unwrap().push(callback)
    }
    
    on watch_all(callback: fn(K, Option<V>, Option<V>)) {
        self.global_callbacks.push(callback)
    }
    
    on unwatch(key: K) {
        self.callbacks.remove(key)
    }
    
    on notify(key: K, old_value: Option<V>, new_value: Option<V>) {
        if let Some(cbs) = self.callbacks.get(key) {
            for cb in cbs {
                cb(key.clone(), old_value.clone(), new_value.clone())
            }
        }
        for cb in self.global_callbacks {
            cb(key.clone(), old_value.clone(), new_value.clone())
        }
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Create in-memory KV store
fn memory<K: Hash + Eq + Clone, V: Clone>() -> MemoryKV<K, V> {
    MemoryKV.new()
}

/// Create TTL KV store
fn ttl<K: Hash + Eq + Clone, V: Clone>(default_ttl_ms: Int64) -> TTLKV<K, V> {
    TTLKV.new(default_ttl_ms)
}

/// Create persistent KV store
fn persistent<K: Hash + Eq + Clone + Serialize + Deserialize, V: Clone + Serialize + Deserialize>(path: String) -> PersistentKV<K, V> {
    PersistentKV.new(path)
}

// =============================================================================
// Tests
// =============================================================================

test "memory kv basic operations" {
    let kv = MemoryKV::<String, Int>.new()
    
    kv.set("a", 1)?
    kv.set("b", 2)?
    
    assert_eq(kv.get("a")?, Some(1))?
    assert_eq(kv.get("b")?, Some(2))?
    assert_eq(kv.get("c")?, None)?
    
    assert_eq(kv.len()?, 2)?
    assert(kv.exists("a")?)?
    
    kv.delete("a")?
    assert_eq(kv.get("a")?, None)?
}

test "memory kv batch operations" {
    let kv = MemoryKV::<String, Int>.new()
    
    kv.mset([("a", 1), ("b", 2), ("c", 3)])?
    
    let values = kv.mget(["a", "b", "d"])?
    assert_eq(values, [Some(1), Some(2), None])?
    
    let deleted = kv.mdel(["a", "b", "x"])?
    assert_eq(deleted, 2)?
}

test "memory kv max size" {
    let kv = MemoryKV::<String, Int>.new(2)
    
    kv.set("a", 1)?
    kv.set("b", 2)?
    
    let result = kv.set("c", 3)
    assert(result.is_err())?
}

test "ttl kv expiration" {
    let kv = TTLKV::<String, Int>.new(100)
    
    kv.set("a", 1)?
    assert_eq(kv.get("a")?, Some(1))?
    
    // Simulate time passing
    @native("sleep_ms", 150)
    
    assert_eq(kv.get("a")?, None)?
}

test "ttl kv custom ttl" {
    let kv = TTLKV::<String, Int>.new(1000)
    
    kv.set_with_ttl("short", 50, 50)?
    kv.set_with_ttl("long", 100, 500)?
    
    @native("sleep_ms", 100)
    
    assert_eq(kv.get("short")?, None)?
    assert_eq(kv.get("long")?, Some(100))?
}

test "kv transaction" {
    let kv = MemoryKV::<String, Int>.new()
    
    let tx = KVTransaction::<String, Int>.new()
        .set("a", 1)
        .set("b", 2)
        .delete("a")
    
    tx.execute(kv)?
    
    assert_eq(kv.get("a")?, None)?
    assert_eq(kv.get("b")?, Some(2))?
}

test "get or insert" {
    let kv = MemoryKV::<String, Int>.new()
    
    let v1 = kv.get_or_insert("a", 42)?
    assert_eq(v1, 42)?
    
    kv.set("a", 100)?
    let v2 = kv.get_or_insert("a", 42)?
    assert_eq(v2, 100)?
}
