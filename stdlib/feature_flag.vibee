// =============================================================================
// Vibee OS â€” Feature Flag Module
// Feature flags and A/B testing
// =============================================================================

// =============================================================================
// Feature Flag Value
// =============================================================================

/// Feature flag value types
enum FlagValue {
    Bool(Bool)
    String(String)
    Int(Int)
    Float(Float)
    Json(ConfigValue)
}

impl FlagValue {
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_int() -> Option<Int> { match self { .Int(i) => Some(i), _ => None } }
    fn as_float() -> Option<Float> { match self { .Float(f) => Some(f), _ => None } }
    fn as_json() -> Option<ConfigValue> { match self { .Json(j) => Some(j), _ => None } }
    
    fn is_enabled() -> Bool { self.as_bool().unwrap_or(false) }
}

// =============================================================================
// Feature Flag
// =============================================================================

/// Feature flag definition
struct FeatureFlag {
    key: String
    default_value: FlagValue
    description: String
    enabled: Bool
    rules: [FlagRule]
    variants: [FlagVariant]
    rollout_percentage: Option<Int>
    created_at: DateTime
    updated_at: DateTime
}

impl FeatureFlag {
    fn new(key: String, default_value: FlagValue) -> Self {
        FeatureFlag {
            key: key,
            default_value: default_value,
            description: "",
            enabled: true,
            rules: [],
            variants: [],
            rollout_percentage: None,
            created_at: DateTime.now(),
            updated_at: DateTime.now()
        }
    }
    
    fn bool_flag(key: String, default: Bool) -> Self {
        Self.new(key, FlagValue.Bool(default))
    }
    
    fn string_flag(key: String, default: String) -> Self {
        Self.new(key, FlagValue.String(default))
    }
    
    fn description(desc: String) -> Self { self.description = desc; self }
    fn disabled() -> Self { self.enabled = false; self }
    fn rollout(percentage: Int) -> Self { self.rollout_percentage = Some(percentage); self }
    
    fn add_rule(rule: FlagRule) -> Self {
        self.rules.push(rule)
        self
    }
    
    fn add_variant(variant: FlagVariant) -> Self {
        self.variants.push(variant)
        self
    }
}

// =============================================================================
// Flag Rules
// =============================================================================

/// Rule for conditional flag evaluation
struct FlagRule {
    id: String
    conditions: [RuleCondition]
    value: FlagValue
    priority: Int
}

impl FlagRule {
    fn new(id: String, value: FlagValue) -> Self {
        FlagRule { id: id, conditions: [], value: value, priority: 0 }
    }
    
    fn condition(cond: RuleCondition) -> Self {
        self.conditions.push(cond)
        self
    }
    
    fn priority(p: Int) -> Self { self.priority = p; self }
    
    fn matches(context: EvalContext) -> Bool {
        self.conditions.iter().all(|c| c.evaluate(context))
    }
}

/// Rule condition
enum RuleCondition {
    Equals { attribute: String, value: String }
    NotEquals { attribute: String, value: String }
    Contains { attribute: String, value: String }
    StartsWith { attribute: String, value: String }
    EndsWith { attribute: String, value: String }
    In { attribute: String, values: [String] }
    NotIn { attribute: String, values: [String] }
    GreaterThan { attribute: String, value: Float }
    LessThan { attribute: String, value: Float }
    Regex { attribute: String, pattern: String }
    Percentage { attribute: String, percentage: Int }
    DateBefore { attribute: String, date: DateTime }
    DateAfter { attribute: String, date: DateTime }
    And([RuleCondition])
    Or([RuleCondition])
    Not(Box<RuleCondition>)
}

impl RuleCondition {
    fn evaluate(context: EvalContext) -> Bool {
        match self {
            .Equals { attribute, value } => {
                context.get_str(attribute) == Some(value)
            }
            .NotEquals { attribute, value } => {
                context.get_str(attribute) != Some(value)
            }
            .Contains { attribute, value } => {
                context.get_str(attribute).map(|s| s.contains(value)).unwrap_or(false)
            }
            .StartsWith { attribute, value } => {
                context.get_str(attribute).map(|s| s.starts_with(value)).unwrap_or(false)
            }
            .EndsWith { attribute, value } => {
                context.get_str(attribute).map(|s| s.ends_with(value)).unwrap_or(false)
            }
            .In { attribute, values } => {
                context.get_str(attribute).map(|s| values.contains(s)).unwrap_or(false)
            }
            .NotIn { attribute, values } => {
                context.get_str(attribute).map(|s| !values.contains(s)).unwrap_or(true)
            }
            .GreaterThan { attribute, value } => {
                context.get_float(attribute).map(|f| f > value).unwrap_or(false)
            }
            .LessThan { attribute, value } => {
                context.get_float(attribute).map(|f| f < value).unwrap_or(false)
            }
            .Regex { attribute, pattern } => {
                context.get_str(attribute).map(|s| regex.is_match(pattern, s)).unwrap_or(false)
            }
            .Percentage { attribute, percentage } => {
                context.get_str(attribute).map(|s| {
                    let hash = hash_string(s) % 100
                    hash < percentage as UInt64
                }).unwrap_or(false)
            }
            .DateBefore { attribute, date } => {
                context.get_datetime(attribute).map(|d| d < date).unwrap_or(false)
            }
            .DateAfter { attribute, date } => {
                context.get_datetime(attribute).map(|d| d > date).unwrap_or(false)
            }
            .And(conditions) => conditions.iter().all(|c| c.evaluate(context))
            .Or(conditions) => conditions.iter().any(|c| c.evaluate(context))
            .Not(condition) => !condition.evaluate(context)
        }
    }
}

fn hash_string(s: String) -> UInt64 {
    var hash: UInt64 = 5381
    for c in s.chars() {
        hash = ((hash << 5) + hash) + c as UInt64
    }
    hash
}

// =============================================================================
// Flag Variants (A/B Testing)
// =============================================================================

/// Variant for A/B testing
struct FlagVariant {
    key: String
    value: FlagValue
    weight: Int
    description: String
}

impl FlagVariant {
    fn new(key: String, value: FlagValue, weight: Int) -> Self {
        FlagVariant { key: key, value: value, weight: weight, description: "" }
    }
    
    fn description(desc: String) -> Self { self.description = desc; self }
}

// =============================================================================
// Evaluation Context
// =============================================================================

/// Context for flag evaluation
struct EvalContext {
    user_id: Option<String>
    attributes: Map<String, ContextValue>
}

enum ContextValue {
    String(String)
    Int(Int)
    Float(Float)
    Bool(Bool)
    DateTime(DateTime)
    List([String])
}

impl EvalContext {
    fn new() -> Self {
        EvalContext { user_id: None, attributes: Map.empty() }
    }
    
    fn user(id: String) -> Self { self.user_id = Some(id); self }
    fn attr(key: String, value: ContextValue) -> Self { self.attributes.set(key, value); self }
    fn str_attr(key: String, value: String) -> Self { self.attr(key, ContextValue.String(value)) }
    fn int_attr(key: String, value: Int) -> Self { self.attr(key, ContextValue.Int(value)) }
    fn float_attr(key: String, value: Float) -> Self { self.attr(key, ContextValue.Float(value)) }
    fn bool_attr(key: String, value: Bool) -> Self { self.attr(key, ContextValue.Bool(value)) }
    
    fn get_str(key: String) -> Option<String> {
        if key == "user_id" { return self.user_id.clone() }
        match self.attributes.get(key) {
            Some(ContextValue.String(s)) => Some(s.clone())
            _ => None
        }
    }
    
    fn get_int(key: String) -> Option<Int> {
        match self.attributes.get(key) {
            Some(ContextValue.Int(i)) => Some(*i)
            _ => None
        }
    }
    
    fn get_float(key: String) -> Option<Float> {
        match self.attributes.get(key) {
            Some(ContextValue.Float(f)) => Some(*f)
            Some(ContextValue.Int(i)) => Some(*i as Float)
            _ => None
        }
    }
    
    fn get_datetime(key: String) -> Option<DateTime> {
        match self.attributes.get(key) {
            Some(ContextValue.DateTime(dt)) => Some(*dt)
            _ => None
        }
    }
}

// =============================================================================
// Feature Flag Provider Trait
// =============================================================================

trait FlagProvider {
    fn get_flag(key: String) -> Result<Option<FeatureFlag>, FlagError>
    fn get_all_flags() -> Result<[FeatureFlag], FlagError>
    fn set_flag(flag: FeatureFlag) -> Result<(), FlagError>
    fn delete_flag(key: String) -> Result<(), FlagError>
}

// =============================================================================
// Memory Provider
// =============================================================================

struct MemoryFlagProvider {
    flags: Map<String, FeatureFlag>
}

impl MemoryFlagProvider {
    fn new() -> Self { MemoryFlagProvider { flags: Map.empty() } }
    
    fn with_flags(flags: [FeatureFlag]) -> Self {
        var provider = Self.new()
        for flag in flags {
            provider.flags.set(flag.key.clone(), flag)
        }
        provider
    }
}

impl FlagProvider for MemoryFlagProvider {
    fn get_flag(key: String) -> Result<Option<FeatureFlag>, FlagError> {
        Ok(self.flags.get(key).cloned())
    }
    
    fn get_all_flags() -> Result<[FeatureFlag], FlagError> {
        Ok(self.flags.values().cloned().collect())
    }
    
    fn set_flag(flag: FeatureFlag) -> Result<(), FlagError> {
        self.flags.set(flag.key.clone(), flag)
        Ok(())
    }
    
    fn delete_flag(key: String) -> Result<(), FlagError> {
        self.flags.remove(key)
        Ok(())
    }
}

// =============================================================================
// Feature Flag Client
// =============================================================================

/// Main feature flag client
actor FeatureFlags {
    state provider: Box<dyn FlagProvider>
    state cache: Map<String, CachedFlag>
    state cache_ttl_ms: Int64
    state default_context: EvalContext
    state listeners: [fn(String, FlagValue)]
}

struct CachedFlag {
    flag: FeatureFlag
    cached_at: Int64
}

impl FeatureFlags {
    fn new<P: FlagProvider>(provider: P) -> Self {
        FeatureFlags {
            provider: Box.new(provider),
            cache: Map.empty(),
            cache_ttl_ms: 60000,
            default_context: EvalContext.new(),
            listeners: []
        }
    }
    
    fn memory() -> Self { Self.new(MemoryFlagProvider.new()) }
    
    fn cache_ttl(ms: Int64) -> Self { self.cache_ttl_ms = ms; self }
    fn default_context(ctx: EvalContext) -> Self { self.default_context = ctx; self }
    
    /// Check if flag is enabled
    fn is_enabled(key: String) -> Bool {
        self.is_enabled_for(key, self.default_context.clone())
    }
    
    fn is_enabled_for(key: String, context: EvalContext) -> Bool {
        self.evaluate(key, context).is_enabled()
    }
    
    /// Evaluate flag value
    fn evaluate(key: String, context: EvalContext) -> FlagValue {
        match self.get_flag(key.clone()) {
            Ok(Some(flag)) => self.evaluate_flag(flag, context)
            _ => FlagValue.Bool(false)
        }
    }
    
    fn evaluate_flag(flag: FeatureFlag, context: EvalContext) -> FlagValue {
        if !flag.enabled { return flag.default_value.clone() }
        
        // Check rollout percentage
        if let Some(percentage) = flag.rollout_percentage {
            if let Some(user_id) = context.user_id.clone() {
                let hash = hash_string(format!("{}:{}", flag.key, user_id)) % 100
                if hash >= percentage as UInt64 {
                    return flag.default_value.clone()
                }
            }
        }
        
        // Evaluate rules (sorted by priority)
        var rules = flag.rules.clone()
        rules.sort_by(|a, b| b.priority.cmp(a.priority))
        
        for rule in rules {
            if rule.matches(context.clone()) {
                return rule.value.clone()
            }
        }
        
        // Select variant if available
        if !flag.variants.is_empty() {
            return self.select_variant(flag.variants, context)
        }
        
        flag.default_value.clone()
    }
    
    fn select_variant(variants: [FlagVariant], context: EvalContext) -> FlagValue {
        let total_weight: Int = variants.iter().map(|v| v.weight).sum()
        if total_weight == 0 { return variants[0].value.clone() }
        
        let hash = match context.user_id {
            Some(id) => hash_string(id) % total_weight as UInt64
            None => crypto.random_u64() % total_weight as UInt64
        }
        
        var cumulative = 0
        for variant in variants {
            cumulative += variant.weight
            if hash < cumulative as UInt64 {
                return variant.value.clone()
            }
        }
        
        variants.last().unwrap().value.clone()
    }
    
    fn get_flag(key: String) -> Result<Option<FeatureFlag>, FlagError> {
        let now = @native("time_now_millis")
        
        if let Some(cached) = self.cache.get(key.clone()) {
            if now - cached.cached_at < self.cache_ttl_ms {
                return Ok(Some(cached.flag.clone()))
            }
        }
        
        let flag = self.provider.get_flag(key.clone())?
        if let Some(f) = flag.clone() {
            self.cache.set(key, CachedFlag { flag: f, cached_at: now })
        }
        
        Ok(flag)
    }
    
    /// Register flag
    fn register(flag: FeatureFlag) -> Result<(), FlagError> {
        self.provider.set_flag(flag)
    }
    
    /// Update flag
    fn update(key: String, updater: fn(FeatureFlag) -> FeatureFlag) -> Result<(), FlagError> {
        let flag = self.provider.get_flag(key.clone())?
            .ok_or(FlagError.NotFound(key.clone()))?
        
        var updated = updater(flag)
        updated.updated_at = DateTime.now()
        
        self.provider.set_flag(updated.clone())?
        self.cache.remove(key.clone())
        
        // Notify listeners
        let value = self.evaluate_flag(updated, self.default_context.clone())
        for listener in self.listeners {
            listener(key.clone(), value.clone())
        }
        
        Ok(())
    }
    
    /// Toggle flag
    fn toggle(key: String) -> Result<(), FlagError> {
        self.update(key, |f| {
            var flag = f
            flag.enabled = !flag.enabled
            flag
        })
    }
    
    /// Delete flag
    fn delete(key: String) -> Result<(), FlagError> {
        self.provider.delete_flag(key.clone())?
        self.cache.remove(key)
        Ok(())
    }
    
    /// Get all flags
    fn all() -> Result<[FeatureFlag], FlagError> {
        self.provider.get_all_flags()
    }
    
    /// Listen for flag changes
    fn on_change(listener: fn(String, FlagValue)) -> Self {
        self.listeners.push(listener)
        self
    }
    
    /// Clear cache
    fn clear_cache() { self.cache.clear() }
    
    /// Refresh flag from provider
    fn refresh(key: String) -> Result<(), FlagError> {
        self.cache.remove(key.clone())
        self.get_flag(key)?;
        Ok(())
    }
}

// =============================================================================
// Errors
// =============================================================================

enum FlagError {
    NotFound(String)
    ProviderError(String)
    InvalidRule(String)
}

impl Display for FlagError {
    fn fmt(f: Formatter) {
        match self {
            .NotFound(key) => f.write(format!("Flag not found: {}", key))
            .ProviderError(msg) => f.write(format!("Provider error: {}", msg))
            .InvalidRule(msg) => f.write(format!("Invalid rule: {}", msg))
        }
    }
}

// =============================================================================
// Builder Helpers
// =============================================================================

fn bool_flag(key: String, default: Bool) -> FeatureFlag {
    FeatureFlag.bool_flag(key, default)
}

fn string_flag(key: String, default: String) -> FeatureFlag {
    FeatureFlag.string_flag(key, default)
}

fn context() -> EvalContext { EvalContext.new() }

// =============================================================================
// Tests
// =============================================================================

test "simple bool flag" {
    let flags = FeatureFlags.memory()
    flags.register(bool_flag("feature_x", true))?
    
    assert(flags.is_enabled("feature_x"))?
    assert(!flags.is_enabled("unknown_flag"))?
}

test "flag with rules" {
    let flags = FeatureFlags.memory()
    
    let flag = bool_flag("premium_feature", false)
        .add_rule(FlagRule.new("premium_users", FlagValue.Bool(true))
            .condition(RuleCondition.Equals { 
                attribute: "plan", 
                value: "premium" 
            }))
    
    flags.register(flag)?
    
    let free_ctx = context().str_attr("plan", "free")
    let premium_ctx = context().str_attr("plan", "premium")
    
    assert(!flags.is_enabled_for("premium_feature", free_ctx))?
    assert(flags.is_enabled_for("premium_feature", premium_ctx))?
}

test "percentage rollout" {
    let flags = FeatureFlags.memory()
    
    let flag = bool_flag("gradual_rollout", true).rollout(50)
    flags.register(flag)?
    
    // With user_id, result is deterministic
    let ctx = context().user("user123")
    let result = flags.is_enabled_for("gradual_rollout", ctx)
    // Result depends on hash
}

test "variants" {
    let flags = FeatureFlags.memory()
    
    let flag = FeatureFlag.new("button_color", FlagValue.String("blue"))
        .add_variant(FlagVariant.new("control", FlagValue.String("blue"), 50))
        .add_variant(FlagVariant.new("variant_a", FlagValue.String("green"), 50))
    
    flags.register(flag)?
    
    let ctx = context().user("user123")
    let value = flags.evaluate("button_color", ctx)
    assert(value.as_str().is_some())?
}

test "toggle flag" {
    let flags = FeatureFlags.memory()
    flags.register(bool_flag("toggleable", true))?
    
    assert(flags.is_enabled("toggleable"))?
    flags.toggle("toggleable")?
    assert(!flags.is_enabled("toggleable"))?
}
