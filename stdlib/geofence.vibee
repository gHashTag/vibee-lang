// =============================================================================
// Vibee OS â€” Geofence Module
// Geographic boundaries, zones, and spatial containment
// =============================================================================

use math::{PI, sin, cos, sqrt, abs, min, max}
use coordinate::{GeoCoord}
use geo_distance::{haversine_distance, bearing}

// -----------------------------------------------------------------------------
// Geofence Types
// -----------------------------------------------------------------------------

/// Geofence shape type
enum GeofenceShape {
    Circle
    Polygon
    Rectangle
    Corridor
}

/// Geofence trigger type
enum GeofenceTrigger {
    Enter
    Exit
    Dwell(Int)  // Dwell time in seconds
    Both
}

// -----------------------------------------------------------------------------
// Circular Geofence
// -----------------------------------------------------------------------------

/// Circular geofence defined by center and radius
struct CircularFence {
    id: String
    name: String
    center: GeoCoord
    radius: Float64  // meters
    metadata: Map<String, String>
    
    fn new(id: String, center: GeoCoord, radius: Float64) -> Self {
        CircularFence {
            id: id,
            name: "",
            center: center,
            radius: radius,
            metadata: Map.empty()
        }
    }
    
    fn with_name(name: String) -> Self {
        self.name = name
        self
    }
    
    fn with_metadata(key: String, value: String) -> Self {
        self.metadata.set(key, value)
        self
    }
    
    /// Check if point is inside fence
    fn contains(point: GeoCoord) -> Bool {
        haversine_distance(self.center, point) <= self.radius
    }
    
    /// Distance from point to fence boundary (negative if inside)
    fn distance_to_boundary(point: GeoCoord) -> Float64 {
        haversine_distance(self.center, point) - self.radius
    }
    
    /// Get bounding box
    fn bounding_box() -> RectangularFence {
        let north = destination_point(self.center, 0.0, self.radius)
        let south = destination_point(self.center, 180.0, self.radius)
        let east = destination_point(self.center, 90.0, self.radius)
        let west = destination_point(self.center, 270.0, self.radius)
        
        RectangularFence.new(
            "bbox_" + self.id,
            GeoCoord.unchecked(south.lat, west.lon),
            GeoCoord.unchecked(north.lat, east.lon)
        )
    }
    
    /// Area in square meters
    fn area() -> Float64 {
        PI * self.radius * self.radius
    }
    
    /// Perimeter in meters
    fn perimeter() -> Float64 {
        2.0 * PI * self.radius
    }
}

// -----------------------------------------------------------------------------
// Polygonal Geofence
// -----------------------------------------------------------------------------

/// Polygonal geofence defined by vertices
struct PolygonalFence {
    id: String
    name: String
    vertices: [GeoCoord]
    metadata: Map<String, String>
    
    fn new(id: String, vertices: [GeoCoord]) -> Result<Self, GeofenceError> {
        if vertices.len() < 3 {
            return Err(GeofenceError.InvalidGeometry("Polygon needs at least 3 vertices"))
        }
        Ok(PolygonalFence {
            id: id,
            name: "",
            vertices: vertices,
            metadata: Map.empty()
        })
    }
    
    fn with_name(name: String) -> Self {
        self.name = name
        self
    }
    
    /// Check if point is inside polygon (ray casting algorithm)
    fn contains(point: GeoCoord) -> Bool {
        var inside = false
        var j = self.vertices.len() - 1
        
        for i in 0..self.vertices.len() {
            let vi = self.vertices[i]
            let vj = self.vertices[j]
            
            if ((vi.lat > point.lat) != (vj.lat > point.lat)) &&
               (point.lon < (vj.lon - vi.lon) * (point.lat - vi.lat) / (vj.lat - vi.lat) + vi.lon) {
                inside = !inside
            }
            j = i
        }
        inside
    }
    
    /// Distance to nearest edge (negative if inside)
    fn distance_to_boundary(point: GeoCoord) -> Float64 {
        var min_dist = Float64.MAX
        let n = self.vertices.len()
        
        for i in 0..n {
            let j = (i + 1) % n
            let dist = point_to_segment_distance(point, self.vertices[i], self.vertices[j])
            min_dist = min(min_dist, dist)
        }
        
        if self.contains(point) { -min_dist } else { min_dist }
    }
    
    /// Get centroid
    fn centroid() -> GeoCoord {
        var lat_sum = 0.0
        var lon_sum = 0.0
        for v in self.vertices {
            lat_sum += v.lat
            lon_sum += v.lon
        }
        let n = self.vertices.len() as Float64
        GeoCoord.unchecked(lat_sum / n, lon_sum / n)
    }
    
    /// Calculate area using shoelace formula (approximate)
    fn area() -> Float64 {
        var sum = 0.0
        let n = self.vertices.len()
        
        for i in 0..n {
            let j = (i + 1) % n
            sum += self.vertices[i].lon * self.vertices[j].lat
            sum -= self.vertices[j].lon * self.vertices[i].lat
        }
        
        let avg_lat = self.centroid().lat.to_radians()
        let meters_per_deg_lat = 111132.92
        let meters_per_deg_lon = 111132.92 * cos(avg_lat)
        
        abs(sum) / 2.0 * meters_per_deg_lat * meters_per_deg_lon
    }
    
    /// Calculate perimeter
    fn perimeter() -> Float64 {
        var total = 0.0
        let n = self.vertices.len()
        for i in 0..n {
            total += haversine_distance(self.vertices[i], self.vertices[(i + 1) % n])
        }
        total
    }
    
    /// Get bounding box
    fn bounding_box() -> RectangularFence {
        var min_lat = 90.0
        var max_lat = -90.0
        var min_lon = 180.0
        var max_lon = -180.0
        
        for v in self.vertices {
            min_lat = min(min_lat, v.lat)
            max_lat = max(max_lat, v.lat)
            min_lon = min(min_lon, v.lon)
            max_lon = max(max_lon, v.lon)
        }
        
        RectangularFence.new(
            "bbox_" + self.id,
            GeoCoord.unchecked(min_lat, min_lon),
            GeoCoord.unchecked(max_lat, max_lon)
        )
    }
}

// -----------------------------------------------------------------------------
// Rectangular Geofence
// -----------------------------------------------------------------------------

/// Rectangular geofence (bounding box)
struct RectangularFence {
    id: String
    name: String
    southwest: GeoCoord
    northeast: GeoCoord
    metadata: Map<String, String>
    
    fn new(id: String, southwest: GeoCoord, northeast: GeoCoord) -> Self {
        RectangularFence {
            id: id,
            name: "",
            southwest: southwest,
            northeast: northeast,
            metadata: Map.empty()
        }
    }
    
    fn from_center(id: String, center: GeoCoord, width: Float64, height: Float64) -> Self {
        let half_w = width / 2.0
        let half_h = height / 2.0
        
        let sw = GeoCoord.unchecked(
            center.lat - meters_to_lat(half_h),
            center.lon - meters_to_lon(half_w, center.lat)
        )
        let ne = GeoCoord.unchecked(
            center.lat + meters_to_lat(half_h),
            center.lon + meters_to_lon(half_w, center.lat)
        )
        
        RectangularFence.new(id, sw, ne)
    }
    
    fn contains(point: GeoCoord) -> Bool {
        point.lat >= self.southwest.lat && point.lat <= self.northeast.lat &&
        point.lon >= self.southwest.lon && point.lon <= self.northeast.lon
    }
    
    fn center() -> GeoCoord {
        GeoCoord.unchecked(
            (self.southwest.lat + self.northeast.lat) / 2.0,
            (self.southwest.lon + self.northeast.lon) / 2.0
        )
    }
    
    fn width() -> Float64 {
        let center = self.center()
        haversine_distance(
            GeoCoord.unchecked(center.lat, self.southwest.lon),
            GeoCoord.unchecked(center.lat, self.northeast.lon)
        )
    }
    
    fn height() -> Float64 {
        haversine_distance(
            GeoCoord.unchecked(self.southwest.lat, self.southwest.lon),
            GeoCoord.unchecked(self.northeast.lat, self.southwest.lon)
        )
    }
    
    fn area() -> Float64 {
        self.width() * self.height()
    }
    
    fn intersects(other: RectangularFence) -> Bool {
        !(other.northeast.lat < self.southwest.lat ||
          other.southwest.lat > self.northeast.lat ||
          other.northeast.lon < self.southwest.lon ||
          other.southwest.lon > self.northeast.lon)
    }
    
    fn to_polygon() -> PolygonalFence {
        PolygonalFence.new(self.id.clone(), [
            self.southwest,
            GeoCoord.unchecked(self.southwest.lat, self.northeast.lon),
            self.northeast,
            GeoCoord.unchecked(self.northeast.lat, self.southwest.lon)
        ]).unwrap()
    }
}

// -----------------------------------------------------------------------------
// Corridor Geofence
// -----------------------------------------------------------------------------

/// Corridor geofence (path with buffer)
struct CorridorFence {
    id: String
    name: String
    path: [GeoCoord]
    width: Float64  // Buffer width in meters
    metadata: Map<String, String>
    
    fn new(id: String, path: [GeoCoord], width: Float64) -> Result<Self, GeofenceError> {
        if path.len() < 2 {
            return Err(GeofenceError.InvalidGeometry("Corridor needs at least 2 points"))
        }
        Ok(CorridorFence {
            id: id,
            name: "",
            path: path,
            width: width,
            metadata: Map.empty()
        })
    }
    
    fn contains(point: GeoCoord) -> Bool {
        let half_width = self.width / 2.0
        for i in 0..(self.path.len() - 1) {
            let dist = point_to_segment_distance(point, self.path[i], self.path[i + 1])
            if dist <= half_width {
                return true
            }
        }
        false
    }
    
    fn length() -> Float64 {
        var total = 0.0
        for i in 0..(self.path.len() - 1) {
            total += haversine_distance(self.path[i], self.path[i + 1])
        }
        total
    }
    
    fn area() -> Float64 {
        self.length() * self.width
    }
}

// -----------------------------------------------------------------------------
// Geofence Manager
// -----------------------------------------------------------------------------

/// Manages multiple geofences
actor GeofenceManager {
    state circular: Map<String, CircularFence>
    state polygonal: Map<String, PolygonalFence>
    state rectangular: Map<String, RectangularFence>
    state corridors: Map<String, CorridorFence>
    state listeners: [fn(GeofenceEvent)]
    
    fn new() -> Self {
        GeofenceManager {
            circular: Map.empty(),
            polygonal: Map.empty(),
            rectangular: Map.empty(),
            corridors: Map.empty(),
            listeners: []
        }
    }
    
    fn add_circular(fence: CircularFence) {
        self.circular.set(fence.id.clone(), fence)
    }
    
    fn add_polygonal(fence: PolygonalFence) {
        self.polygonal.set(fence.id.clone(), fence)
    }
    
    fn add_rectangular(fence: RectangularFence) {
        self.rectangular.set(fence.id.clone(), fence)
    }
    
    fn add_corridor(fence: CorridorFence) {
        self.corridors.set(fence.id.clone(), fence)
    }
    
    fn remove(id: String) {
        self.circular.remove(id.clone())
        self.polygonal.remove(id.clone())
        self.rectangular.remove(id.clone())
        self.corridors.remove(id)
    }
    
    /// Check which fences contain the point
    fn check_point(point: GeoCoord) -> [String] {
        var inside = []
        
        for (id, fence) in self.circular {
            if fence.contains(point) { inside.push(id.clone()) }
        }
        for (id, fence) in self.polygonal {
            if fence.contains(point) { inside.push(id.clone()) }
        }
        for (id, fence) in self.rectangular {
            if fence.contains(point) { inside.push(id.clone()) }
        }
        for (id, fence) in self.corridors {
            if fence.contains(point) { inside.push(id.clone()) }
        }
        
        inside
    }
    
    fn on_event(listener: fn(GeofenceEvent)) {
        self.listeners.push(listener)
    }
    
    fn emit(event: GeofenceEvent) {
        for listener in self.listeners {
            listener(event)
        }
    }
}

// -----------------------------------------------------------------------------
// Geofence Tracker
// -----------------------------------------------------------------------------

/// Tracks entity position relative to geofences
struct GeofenceTracker {
    entity_id: String
    manager: GeofenceManager
    current_fences: Set<String>
    last_position: Option<GeoCoord>
    
    fn new(entity_id: String, manager: GeofenceManager) -> Self {
        GeofenceTracker {
            entity_id: entity_id,
            manager: manager,
            current_fences: Set.empty(),
            last_position: None
        }
    }
    
    /// Update position and detect transitions
    fn update(position: GeoCoord) -> [GeofenceEvent] {
        var events = []
        let new_fences = Set.from(self.manager.check_point(position))
        
        // Detect entries
        for fence_id in new_fences.difference(self.current_fences) {
            events.push(GeofenceEvent.Enter {
                entity_id: self.entity_id.clone(),
                fence_id: fence_id.clone(),
                position: position,
                timestamp: Instant.now()
            })
        }
        
        // Detect exits
        for fence_id in self.current_fences.difference(new_fences) {
            events.push(GeofenceEvent.Exit {
                entity_id: self.entity_id.clone(),
                fence_id: fence_id.clone(),
                position: position,
                timestamp: Instant.now()
            })
        }
        
        self.current_fences = new_fences
        self.last_position = Some(position)
        
        for event in events.clone() {
            self.manager.emit(event)
        }
        
        events
    }
    
    fn is_inside(fence_id: String) -> Bool {
        self.current_fences.contains(fence_id)
    }
}

// -----------------------------------------------------------------------------
// Events
// -----------------------------------------------------------------------------

enum GeofenceEvent {
    Enter { entity_id: String, fence_id: String, position: GeoCoord, timestamp: Instant }
    Exit { entity_id: String, fence_id: String, position: GeoCoord, timestamp: Instant }
    Dwell { entity_id: String, fence_id: String, duration: Duration, position: GeoCoord }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum GeofenceError {
    InvalidGeometry(String)
    FenceNotFound(String)
    InvalidOperation(String)
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

fn destination_point(from: GeoCoord, bearing_deg: Float64, distance_m: Float64) -> GeoCoord {
    let lat1 = from.lat.to_radians()
    let lon1 = from.lon.to_radians()
    let brng = bearing_deg.to_radians()
    let d = distance_m / 6371008.8
    
    let lat2 = (sin(lat1) * cos(d) + cos(lat1) * sin(d) * cos(brng)).asin()
    let lon2 = lon1 + (sin(brng) * sin(d) * cos(lat1)).atan2(cos(d) - sin(lat1) * sin(lat2))
    
    GeoCoord.unchecked(lat2.to_degrees(), lon2.to_degrees())
}

fn point_to_segment_distance(point: GeoCoord, seg_start: GeoCoord, seg_end: GeoCoord) -> Float64 {
    let d_total = haversine_distance(seg_start, seg_end)
    if d_total == 0.0 {
        return haversine_distance(point, seg_start)
    }
    
    let d1 = haversine_distance(seg_start, point)
    let d2 = haversine_distance(seg_end, point)
    let s = (d_total + d1 + d2) / 2.0
    let area = sqrt(s * (s - d_total) * (s - d1) * (s - d2))
    
    2.0 * area / d_total
}

fn meters_to_lat(meters: Float64) -> Float64 {
    meters / 111132.92
}

fn meters_to_lon(meters: Float64, lat: Float64) -> Float64 {
    meters / (111132.92 * cos(lat.to_radians()))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "circular fence contains" {
    let fence = CircularFence.new("test", GeoCoord.unchecked(40.0, -74.0), 1000.0)
    assert(fence.contains(GeoCoord.unchecked(40.0, -74.0)))?
    assert(!fence.contains(GeoCoord.unchecked(41.0, -74.0)))?
}

test "polygon fence contains" {
    let fence = PolygonalFence.new("test", [
        GeoCoord.unchecked(0.0, 0.0),
        GeoCoord.unchecked(0.0, 10.0),
        GeoCoord.unchecked(10.0, 10.0),
        GeoCoord.unchecked(10.0, 0.0)
    ])?
    assert(fence.contains(GeoCoord.unchecked(5.0, 5.0)))?
    assert(!fence.contains(GeoCoord.unchecked(15.0, 5.0)))?
}

test "rectangular fence" {
    let fence = RectangularFence.new(
        "test",
        GeoCoord.unchecked(40.0, -75.0),
        GeoCoord.unchecked(41.0, -74.0)
    )
    assert(fence.contains(GeoCoord.unchecked(40.5, -74.5)))?
}
