// =============================================================================
// Vibee OS â€” Make (Integromat) Integration Module
// Make.com (formerly Integromat) scenarios and modules integration
// =============================================================================

use http::{Request, Response, Method, Status, Headers, Client as HttpClient}
use json::{JsonValue, Serialize, Deserialize}
use crypto::{hmac_sha256, constant_time_eq}
use uuid::{uuid}

// =============================================================================
// Make Client
// =============================================================================

/// Make.com API client for triggering scenarios and managing webhooks
actor MakeClient {
    state api_token: String
    state team_id: Option<String>
    state organization_id: Option<String>
    state http_client: HttpClient
    state base_url: String
    state retry_config: RetryConfig
    
    fn new(api_token: String) -> Self {
        MakeClient {
            api_token: api_token,
            team_id: None,
            organization_id: None,
            http_client: HttpClient.new().timeout(30000),
            base_url: "https://hook.make.com",
            retry_config: RetryConfig.default()
        }
    }
    
    fn with_team(team_id: String) -> Self {
        self.team_id = Some(team_id)
        self
    }
    
    fn with_organization(org_id: String) -> Self {
        self.organization_id = Some(org_id)
        self
    }
    
    fn with_retry(config: RetryConfig) -> Self {
        self.retry_config = config
        self
    }
    
    /// Trigger a Make webhook
    fn trigger_webhook(webhook_url: String, data: JsonValue) -> Result<MakeResponse, MakeError> {
        self.send_webhook(webhook_url, data)
    }
    
    /// Trigger a Make webhook with custom headers
    fn trigger_webhook_with_headers(webhook_url: String, data: JsonValue, headers: Map<String, String>) -> Result<MakeResponse, MakeError> {
        self.send_webhook_with_headers(webhook_url, data, headers)
    }
    
    /// Trigger multiple items to a webhook
    fn trigger_batch(webhook_url: String, items: [JsonValue]) -> Result<MakeResponse, MakeError> {
        // Make supports array of items
        self.send_webhook(webhook_url, JsonValue.array(items))
    }
    
    fn send_webhook(url: String, data: JsonValue) -> Result<MakeResponse, MakeError> {
        self.send_webhook_with_headers(url, data, Map.empty())
    }
    
    fn send_webhook_with_headers(url: String, data: JsonValue, custom_headers: Map<String, String>) -> Result<MakeResponse, MakeError> {
        var attempts = 0
        var last_error: Option<MakeError> = None
        
        while attempts < self.retry_config.max_retries {
            var request = Request.post(url.clone())
                .header("Content-Type", "application/json")
                .header("Authorization", format!("Token {}", self.api_token))
            
            for (key, value) in custom_headers.iter() {
                request = request.header(key, value)
            }
            
            request = request.json(data.clone())
            
            match self.http_client.send(request) {
                Ok(response) => {
                    if response.is_success() {
                        return Ok(MakeResponse {
                            status: response.status.code,
                            execution_id: response.headers.get("X-Execution-Id"),
                            data: response.json().ok()
                        })
                    }
                    if response.status.code >= 500 {
                        last_error = Some(MakeError.ServerError(response.status.code))
                        attempts += 1
                        @native("sleep_ms", self.retry_config.delay_ms * (2 ** attempts))
                        continue
                    }
                    return Err(MakeError.ApiError(response.status.code, response.text()))
                }
                Err(e) => {
                    last_error = Some(MakeError.NetworkError(e.to_string()))
                    attempts += 1
                    @native("sleep_ms", self.retry_config.delay_ms * (2 ** attempts))
                }
            }
        }
        
        Err(last_error.unwrap_or(MakeError.MaxRetriesExceeded))
    }
}

// =============================================================================
// Make Scenarios API
// =============================================================================

/// Make Scenarios management client
actor MakeScenariosClient {
    state api_token: String
    state http_client: HttpClient
    state base_url: String
    
    fn new(api_token: String) -> Self {
        MakeScenariosClient {
            api_token: api_token,
            http_client: HttpClient.new().timeout(30000),
            base_url: "https://eu1.make.com/api/v2"
        }
    }
    
    fn with_region(region: MakeRegion) -> Self {
        self.base_url = format!("https://{}.make.com/api/v2", region.to_string())
        self
    }
    
    /// List all scenarios
    fn list_scenarios(team_id: Int) -> Result<[MakeScenario], MakeError> {
        let url = format!("{}/scenarios?teamId={}", self.base_url, team_id)
        let response = self.api_request(Method.GET, url, None)?
        
        let data = response.get("scenarios").ok_or(MakeError.InvalidResponse)?
        json.decode(data.to_string()).map_err(|_| MakeError.InvalidResponse)
    }
    
    /// Get scenario details
    fn get_scenario(scenario_id: Int) -> Result<MakeScenario, MakeError> {
        let url = format!("{}/scenarios/{}", self.base_url, scenario_id)
        let response = self.api_request(Method.GET, url, None)?
        
        let data = response.get("scenario").ok_or(MakeError.InvalidResponse)?
        json.decode(data.to_string()).map_err(|_| MakeError.InvalidResponse)
    }
    
    /// Run a scenario
    fn run_scenario(scenario_id: Int) -> Result<MakeExecution, MakeError> {
        let url = format!("{}/scenarios/{}/run", self.base_url, scenario_id)
        let response = self.api_request(Method.POST, url, None)?
        
        let data = response.get("execution").ok_or(MakeError.InvalidResponse)?
        json.decode(data.to_string()).map_err(|_| MakeError.InvalidResponse)
    }
    
    /// Run a scenario with input data
    fn run_scenario_with_data(scenario_id: Int, data: JsonValue) -> Result<MakeExecution, MakeError> {
        let url = format!("{}/scenarios/{}/run", self.base_url, scenario_id)
        let response = self.api_request(Method.POST, url, Some(data))?
        
        let exec_data = response.get("execution").ok_or(MakeError.InvalidResponse)?
        json.decode(exec_data.to_string()).map_err(|_| MakeError.InvalidResponse)
    }
    
    /// Activate a scenario
    fn activate_scenario(scenario_id: Int) -> Result<(), MakeError> {
        let url = format!("{}/scenarios/{}/activate", self.base_url, scenario_id)
        self.api_request(Method.POST, url, None)?
        Ok(())
    }
    
    /// Deactivate a scenario
    fn deactivate_scenario(scenario_id: Int) -> Result<(), MakeError> {
        let url = format!("{}/scenarios/{}/deactivate", self.base_url, scenario_id)
        self.api_request(Method.POST, url, None)?
        Ok(())
    }
    
    /// Get scenario executions
    fn get_executions(scenario_id: Int, limit: Option<Int>) -> Result<[MakeExecution], MakeError> {
        let limit_param = limit.unwrap_or(50)
        let url = format!("{}/scenarios/{}/executions?limit={}", self.base_url, scenario_id, limit_param)
        let response = self.api_request(Method.GET, url, None)?
        
        let data = response.get("executions").ok_or(MakeError.InvalidResponse)?
        json.decode(data.to_string()).map_err(|_| MakeError.InvalidResponse)
    }
    
    fn api_request(method: Method, url: String, body: Option<JsonValue>) -> Result<JsonValue, MakeError> {
        var request = Request.new(method, url)
            .header("Authorization", format!("Token {}", self.api_token))
            .header("Content-Type", "application/json")
        
        if let Some(data) = body {
            request = request.json(data)
        }
        
        let response = self.http_client.send(request)
            .map_err(|e| MakeError.NetworkError(e.to_string()))?
        
        if !response.is_success() {
            return Err(MakeError.ApiError(response.status.code, response.text()))
        }
        
        response.json().map_err(|_| MakeError.InvalidResponse)
    }
}

// =============================================================================
// Make Module Builder (for custom apps)
// =============================================================================

/// Builder for creating Make custom app modules
struct MakeModule {
    name: String
    label: String
    description: String
    module_type: MakeModuleType
    parameters: [MakeParameter]
    interface: [MakeInterface]
    mappable_parameters: [String]
    expect: Option<[MakeExpect]>
}

impl MakeModule {
    fn new(name: String, label: String, module_type: MakeModuleType) -> Self {
        MakeModule {
            name: name,
            label: label,
            description: "",
            module_type: module_type,
            parameters: [],
            interface: [],
            mappable_parameters: [],
            expect: None
        }
    }
    
    fn trigger(name: String, label: String) -> Self {
        Self.new(name, label, MakeModuleType.Trigger)
    }
    
    fn action(name: String, label: String) -> Self {
        Self.new(name, label, MakeModuleType.Action)
    }
    
    fn search(name: String, label: String) -> Self {
        Self.new(name, label, MakeModuleType.Search)
    }
    
    fn instant_trigger(name: String, label: String) -> Self {
        Self.new(name, label, MakeModuleType.InstantTrigger)
    }
    
    fn description(desc: String) -> Self {
        self.description = desc
        self
    }
    
    fn add_parameter(param: MakeParameter) -> Self {
        self.parameters.push(param)
        self
    }
    
    fn add_interface(iface: MakeInterface) -> Self {
        self.interface.push(iface)
        self
    }
    
    fn mappable(param_name: String) -> Self {
        self.mappable_parameters.push(param_name)
        self
    }
    
    fn expect_output(expects: [MakeExpect]) -> Self {
        self.expect = Some(expects)
        self
    }
    
    fn to_json() -> JsonValue {
        var obj = Map.empty()
        obj.set("name", JsonValue.string(self.name.clone()))
        obj.set("label", JsonValue.string(self.label.clone()))
        obj.set("description", JsonValue.string(self.description.clone()))
        obj.set("type", JsonValue.string(self.module_type.to_string()))
        
        if !self.parameters.is_empty() {
            obj.set("parameters", JsonValue.array(self.parameters.iter().map(|p| p.to_json()).collect()))
        }
        
        if !self.interface.is_empty() {
            obj.set("interface", JsonValue.array(self.interface.iter().map(|i| i.to_json()).collect()))
        }
        
        if !self.mappable_parameters.is_empty() {
            obj.set("mappable", JsonValue.array(self.mappable_parameters.iter().map(|m| JsonValue.string(m.clone())).collect()))
        }
        
        if let Some(expects) = self.expect.clone() {
            obj.set("expect", JsonValue.array(expects.iter().map(|e| e.to_json()).collect()))
        }
        
        JsonValue.from_map(obj)
    }
}

enum MakeModuleType {
    Trigger,
    InstantTrigger,
    Action,
    Search,
    Aggregator,
    Iterator,
    Transformer
}

impl MakeModuleType {
    fn to_string() -> String {
        match self {
            Trigger => "trigger",
            InstantTrigger => "instant_trigger",
            Action => "action",
            Search => "search",
            Aggregator => "aggregator",
            Iterator => "iterator",
            Transformer => "transformer"
        }
    }
}

// =============================================================================
// Make Parameter Definition
// =============================================================================

/// Make module parameter definition
struct MakeParameter {
    name: String
    label: String
    param_type: MakeParamType
    required: Bool
    help: Option<String>
    default_value: Option<JsonValue>
    options: Option<[MakeOption]>
    nested: Option<[MakeParameter]>
}

impl MakeParameter {
    fn new(name: String, label: String) -> Self {
        MakeParameter {
            name: name,
            label: label,
            param_type: MakeParamType.Text,
            required: false,
            help: None,
            default_value: None,
            options: None,
            nested: None
        }
    }
    
    fn text(name: String, label: String) -> Self { Self.new(name, label).of_type(MakeParamType.Text) }
    fn number(name: String, label: String) -> Self { Self.new(name, label).of_type(MakeParamType.Number) }
    fn boolean(name: String, label: String) -> Self { Self.new(name, label).of_type(MakeParamType.Boolean) }
    fn select(name: String, label: String, options: [MakeOption]) -> Self { Self.new(name, label).of_type(MakeParamType.Select).with_options(options) }
    fn date(name: String, label: String) -> Self { Self.new(name, label).of_type(MakeParamType.Date) }
    fn time(name: String, label: String) -> Self { Self.new(name, label).of_type(MakeParamType.Time) }
    fn array(name: String, label: String, items: [MakeParameter]) -> Self { Self.new(name, label).of_type(MakeParamType.Array).with_nested(items) }
    fn collection(name: String, label: String, fields: [MakeParameter]) -> Self { Self.new(name, label).of_type(MakeParamType.Collection).with_nested(fields) }
    fn file(name: String, label: String) -> Self { Self.new(name, label).of_type(MakeParamType.Buffer) }
    
    fn of_type(t: MakeParamType) -> Self {
        self.param_type = t
        self
    }
    
    fn required() -> Self {
        self.required = true
        self
    }
    
    fn help_text(text: String) -> Self {
        self.help = Some(text)
        self
    }
    
    fn default(value: JsonValue) -> Self {
        self.default_value = Some(value)
        self
    }
    
    fn with_options(options: [MakeOption]) -> Self {
        self.options = Some(options)
        self
    }
    
    fn with_nested(params: [MakeParameter]) -> Self {
        self.nested = Some(params)
        self
    }
    
    fn to_json() -> JsonValue {
        var obj = Map.empty()
        obj.set("name", JsonValue.string(self.name.clone()))
        obj.set("label", JsonValue.string(self.label.clone()))
        obj.set("type", JsonValue.string(self.param_type.to_string()))
        obj.set("required", JsonValue.bool(self.required))
        
        if let Some(help) = self.help.clone() {
            obj.set("help", JsonValue.string(help))
        }
        if let Some(default) = self.default_value.clone() {
            obj.set("default", default)
        }
        if let Some(options) = self.options.clone() {
            obj.set("options", JsonValue.array(options.iter().map(|o| o.to_json()).collect()))
        }
        if let Some(nested) = self.nested.clone() {
            obj.set("spec", JsonValue.array(nested.iter().map(|n| n.to_json()).collect()))
        }
        
        JsonValue.from_map(obj)
    }
}

enum MakeParamType {
    Text,
    Number,
    Boolean,
    Select,
    Date,
    Time,
    Timestamp,
    Buffer,
    Array,
    Collection,
    Filename,
    Url,
    Email,
    Color,
    Hidden
}

impl MakeParamType {
    fn to_string() -> String {
        match self {
            Text => "text",
            Number => "number",
            Boolean => "boolean",
            Select => "select",
            Date => "date",
            Time => "time",
            Timestamp => "timestamp",
            Buffer => "buffer",
            Array => "array",
            Collection => "collection",
            Filename => "filename",
            Url => "url",
            Email => "email",
            Color => "color",
            Hidden => "hidden"
        }
    }
}

struct MakeOption {
    value: String
    label: String
    nested: Option<[MakeParameter]>
}

impl MakeOption {
    fn new(value: String, label: String) -> Self {
        MakeOption { value: value, label: label, nested: None }
    }
    
    fn with_nested(params: [MakeParameter]) -> Self {
        self.nested = Some(params)
        self
    }
    
    fn to_json() -> JsonValue {
        var obj = Map.empty()
        obj.set("value", JsonValue.string(self.value.clone()))
        obj.set("label", JsonValue.string(self.label.clone()))
        
        if let Some(nested) = self.nested.clone() {
            obj.set("nested", JsonValue.array(nested.iter().map(|n| n.to_json()).collect()))
        }
        
        JsonValue.from_map(obj)
    }
}

// =============================================================================
// Make Interface and Expect
// =============================================================================

/// Make module interface (output specification)
struct MakeInterface {
    name: String
    label: String
    interface_type: MakeParamType
}

impl MakeInterface {
    fn new(name: String, label: String, interface_type: MakeParamType) -> Self {
        MakeInterface { name: name, label: label, interface_type: interface_type }
    }
    
    fn to_json() -> JsonValue {
        JsonValue.object([
            ("name", JsonValue.string(self.name.clone())),
            ("label", JsonValue.string(self.label.clone())),
            ("type", JsonValue.string(self.interface_type.to_string()))
        ])
    }
}

/// Make module expect (expected output)
struct MakeExpect {
    name: String
    expect_type: MakeParamType
    label: Option<String>
}

impl MakeExpect {
    fn new(name: String, expect_type: MakeParamType) -> Self {
        MakeExpect { name: name, expect_type: expect_type, label: None }
    }
    
    fn with_label(label: String) -> Self {
        self.label = Some(label)
        self
    }
    
    fn to_json() -> JsonValue {
        var obj = Map.empty()
        obj.set("name", JsonValue.string(self.name.clone()))
        obj.set("type", JsonValue.string(self.expect_type.to_string()))
        
        if let Some(label) = self.label.clone() {
            obj.set("label", JsonValue.string(label))
        }
        
        JsonValue.from_map(obj)
    }
}

// =============================================================================
// Make Webhook Handler
// =============================================================================

/// Handler for incoming Make webhooks
struct MakeWebhookHandler {
    secret: Option<String>
    handlers: Map<String, fn(MakeWebhookEvent) -> Result<JsonValue, MakeError>>
}

impl MakeWebhookHandler {
    fn new() -> Self {
        MakeWebhookHandler {
            secret: None,
            handlers: Map.empty()
        }
    }
    
    fn with_secret(secret: String) -> Self {
        self.secret = Some(secret)
        self
    }
    
    fn on(event_type: String, handler: fn(MakeWebhookEvent) -> Result<JsonValue, MakeError>) -> Self {
        self.handlers.set(event_type, handler)
        self
    }
    
    fn handle(request: Request) -> Result<Response, MakeError> {
        // Verify signature if secret is configured
        if let Some(secret) = self.secret.clone() {
            let signature = request.headers.get("X-Make-Signature")
                .ok_or(MakeError.InvalidSignature)?
            
            let body_str = String.from_utf8(request.body.clone())
                .map_err(|_| MakeError.InvalidPayload)?
            
            let expected = hex.encode(hmac_sha256(secret.as_bytes(), body_str.as_bytes()))
            if !constant_time_eq(signature.as_bytes(), expected.as_bytes()) {
                return Err(MakeError.InvalidSignature)
            }
        }
        
        let event: MakeWebhookEvent = json.decode(String.from_utf8(request.body.clone())
            .map_err(|_| MakeError.InvalidPayload)?)
            .map_err(|_| MakeError.InvalidPayload)?
        
        let event_type = event.event_type.clone().unwrap_or("default".to_string())
        let handler = self.handlers.get(event_type.clone())
            .or_else(|| self.handlers.get("default"))
            .ok_or(MakeError.UnknownEvent(event_type))?
        
        let result = handler(event)?
        
        Ok(Response.ok().json(result))
    }
}

/// Make webhook event
struct MakeWebhookEvent {
    event_type: Option<String>
    scenario_id: Option<Int>
    execution_id: Option<String>
    data: JsonValue
    timestamp: Option<Int64>
}

// =============================================================================
// Make Data Types
// =============================================================================

/// Make scenario
struct MakeScenario {
    id: Int
    name: String
    team_id: Int
    is_enabled: Bool
    is_paused: Bool
    scheduling: Option<MakeScheduling>
    created_at: String
    updated_at: String
}

/// Make scenario scheduling
struct MakeScheduling {
    schedule_type: String
    interval: Option<Int>
    time: Option<String>
    days: Option<[Int]>
}

/// Make execution
struct MakeExecution {
    id: String
    scenario_id: Int
    status: MakeExecutionStatus
    started_at: String
    finished_at: Option<String>
    operations: Int
    transfer: Int
    duration: Option<Int>
}

enum MakeExecutionStatus {
    Running,
    Success,
    Warning,
    Error,
    Cancelled
}

impl MakeExecutionStatus {
    fn from_string(s: String) -> Option<Self> {
        match s.to_lower() {
            "running" => Some(Running),
            "success" => Some(Success),
            "warning" => Some(Warning),
            "error" => Some(Error),
            "cancelled" => Some(Cancelled),
            _ => None
        }
    }
}

// =============================================================================
// Make Regions
// =============================================================================

enum MakeRegion {
    EU1,
    EU2,
    US1,
    US2
}

impl MakeRegion {
    fn to_string() -> String {
        match self {
            EU1 => "eu1",
            EU2 => "eu2",
            US1 => "us1",
            US2 => "us2"
        }
    }
}

// =============================================================================
// Response and Error Types
// =============================================================================

struct MakeResponse {
    status: Int
    execution_id: Option<String>
    data: Option<JsonValue>
}

struct RetryConfig {
    max_retries: Int
    delay_ms: Int64
}

impl RetryConfig {
    fn default() -> Self {
        RetryConfig { max_retries: 3, delay_ms: 1000 }
    }
    
    fn new(max_retries: Int, delay_ms: Int64) -> Self {
        RetryConfig { max_retries: max_retries, delay_ms: delay_ms }
    }
}

enum MakeError {
    NetworkError(String),
    ApiError(Int, String),
    ServerError(Int),
    MaxRetriesExceeded,
    InvalidSignature,
    InvalidPayload,
    InvalidResponse,
    UnknownEvent(String),
    ScenarioNotFound(Int),
    Other(String)
}

impl Display for MakeError {
    fn fmt(f: Formatter) {
        match self {
            NetworkError(s) => f.write(format!("Network error: {}", s)),
            ApiError(code, msg) => f.write(format!("API error {}: {}", code, msg)),
            ServerError(code) => f.write(format!("Server error: {}", code)),
            MaxRetriesExceeded => f.write("Max retries exceeded"),
            InvalidSignature => f.write("Invalid webhook signature"),
            InvalidPayload => f.write("Invalid payload"),
            InvalidResponse => f.write("Invalid response"),
            UnknownEvent(e) => f.write(format!("Unknown event: {}", e)),
            ScenarioNotFound(id) => f.write(format!("Scenario not found: {}", id)),
            Other(s) => f.write(s)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "make parameter builder" {
    let param = MakeParameter.text("message", "Message")
        .required()
        .help_text("Enter your message")
    
    let json = param.to_json()
    assert_eq(json.get("name").as_string(), Some("message"))?
    assert_eq(json.get("required").as_bool(), Some(true))?
}

test "make module builder" {
    let module = MakeModule.action("create_record", "Create Record")
        .description("Creates a new record")
        .add_parameter(MakeParameter.text("name", "Name").required())
        .add_parameter(MakeParameter.text("email", "Email"))
        .add_interface(MakeInterface.new("id", "Record ID", MakeParamType.Text))
    
    let json = module.to_json()
    assert_eq(json.get("name").as_string(), Some("create_record"))?
    assert_eq(json.get("type").as_string(), Some("action"))?
}

test "make select parameter" {
    let param = MakeParameter.select("status", "Status", [
        MakeOption.new("active", "Active"),
        MakeOption.new("inactive", "Inactive")
    ])
    
    let json = param.to_json()
    assert_eq(json.get("type").as_string(), Some("select"))?
}

test "make collection parameter" {
    let param = MakeParameter.collection("address", "Address", [
        MakeParameter.text("street", "Street"),
        MakeParameter.text("city", "City"),
        MakeParameter.text("country", "Country")
    ])
    
    let json = param.to_json()
    assert_eq(json.get("type").as_string(), Some("collection"))?
}

test "make region" {
    assert_eq(MakeRegion.EU1.to_string(), "eu1")?
    assert_eq(MakeRegion.US1.to_string(), "us1")?
}

test "retry config" {
    let config = RetryConfig.default()
    assert_eq(config.max_retries, 3)?
    assert_eq(config.delay_ms, 1000)?
}
