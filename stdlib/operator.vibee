// =============================================================================
// Vibee OS â€” Operator Module
// Reactive operators for Observable transformation
// =============================================================================

use observable::{Observable, Observer, Subscription, create, observer}

// =============================================================================
// Transformation Operators
// =============================================================================

/// Map operator - transform each value
struct MapOp<S, T, U> {
    source: S
    mapper: fn(T) -> U
}

impl<S: Observable, U> Observable for MapOp<S, S.Item, U> {
    type Item = U
    fn subscribe(obs: impl Observer<U>) -> Subscription {
        self.source.subscribe(MapObserver { downstream: obs, mapper: self.mapper })
    }
}

struct MapObserver<O, T, U> { downstream: O, mapper: fn(T) -> U }
impl<O: Observer<U>, T, U> Observer<T> for MapObserver<O, T, U> {
    fn on_next(value: T) { self.downstream.on_next((self.mapper)(value)) }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn map<S: Observable, U>(source: S, mapper: fn(S.Item) -> U) -> MapOp<S, S.Item, U> {
    MapOp { source: source, mapper: mapper }
}

/// Filter operator - emit only matching values
struct FilterOp<S> {
    source: S
    predicate: fn(S.Item) -> Bool
}

impl<S: Observable> Observable for FilterOp<S> where S.Item: Clone {
    type Item = S.Item
    fn subscribe(obs: impl Observer<S.Item>) -> Subscription {
        self.source.subscribe(FilterObserver { downstream: obs, predicate: self.predicate })
    }
}

struct FilterObserver<O, T> { downstream: O, predicate: fn(T) -> Bool }
impl<O: Observer<T>, T: Clone> Observer<T> for FilterObserver<O, T> {
    fn on_next(value: T) { if (self.predicate)(value.clone()) { self.downstream.on_next(value) } }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn filter<S: Observable>(source: S, predicate: fn(S.Item) -> Bool) -> FilterOp<S> {
    FilterOp { source: source, predicate: predicate }
}

/// Scan operator - accumulate values
struct ScanOp<S, A> {
    source: S
    initial: A
    accumulator: fn(A, S.Item) -> A
}

impl<S: Observable, A: Clone> Observable for ScanOp<S, A> {
    type Item = A
    fn subscribe(obs: impl Observer<A>) -> Subscription {
        self.source.subscribe(ScanObserver {
            downstream: obs,
            acc: self.initial.clone(),
            accumulator: self.accumulator
        })
    }
}

struct ScanObserver<O, A, T> { downstream: O, acc: A, accumulator: fn(A, T) -> A }
impl<O: Observer<A>, A: Clone, T> Observer<T> for ScanObserver<O, A, T> {
    fn on_next(value: T) {
        self.acc = (self.accumulator)(self.acc.clone(), value)
        self.downstream.on_next(self.acc.clone())
    }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn scan<S: Observable, A>(source: S, initial: A, acc: fn(A, S.Item) -> A) -> ScanOp<S, A> {
    ScanOp { source: source, initial: initial, accumulator: acc }
}

/// Reduce operator - emit final accumulated value
fn reduce<S: Observable, A: Clone>(source: S, initial: A, acc: fn(A, S.Item) -> A) -> impl Observable<Item = A> {
    create(|obs| {
        var result = initial.clone()
        source.subscribe(observer(
            |v| result = acc(result.clone(), v),
            |e| obs.on_error(e),
            || { obs.on_next(result); obs.on_complete() }
        ))
    })
}

// =============================================================================
// Filtering Operators
// =============================================================================

/// Take operator - emit first n values
struct TakeOp<S> { source: S, count: Int }

impl<S: Observable> Observable for TakeOp<S> {
    type Item = S.Item
    fn subscribe(obs: impl Observer<S.Item>) -> Subscription {
        self.source.subscribe(TakeObserver { downstream: obs, remaining: self.count })
    }
}

struct TakeObserver<O> { downstream: O, remaining: Int }
impl<O: Observer<T>, T> Observer<T> for TakeObserver<O> {
    fn on_next(value: T) {
        if self.remaining > 0 {
            self.remaining -= 1
            self.downstream.on_next(value)
            if self.remaining == 0 { self.downstream.on_complete() }
        }
    }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn take<S: Observable>(source: S, count: Int) -> TakeOp<S> {
    TakeOp { source: source, count: count }
}

/// Skip operator - skip first n values
struct SkipOp<S> { source: S, count: Int }

impl<S: Observable> Observable for SkipOp<S> {
    type Item = S.Item
    fn subscribe(obs: impl Observer<S.Item>) -> Subscription {
        self.source.subscribe(SkipObserver { downstream: obs, remaining: self.count })
    }
}

struct SkipObserver<O> { downstream: O, remaining: Int }
impl<O: Observer<T>, T> Observer<T> for SkipObserver<O> {
    fn on_next(value: T) {
        if self.remaining > 0 { self.remaining -= 1 }
        else { self.downstream.on_next(value) }
    }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn skip<S: Observable>(source: S, count: Int) -> SkipOp<S> {
    SkipOp { source: source, count: count }
}

/// Distinct operator - emit only distinct values
struct DistinctOp<S> { source: S }

impl<S: Observable> Observable for DistinctOp<S> where S.Item: Hash + Eq + Clone {
    type Item = S.Item
    fn subscribe(obs: impl Observer<S.Item>) -> Subscription {
        self.source.subscribe(DistinctObserver { downstream: obs, seen: Set.new() })
    }
}

struct DistinctObserver<O, T> { downstream: O, seen: Set<T> }
impl<O: Observer<T>, T: Hash + Eq + Clone> Observer<T> for DistinctObserver<O, T> {
    fn on_next(value: T) {
        if self.seen.insert(value.clone()) { self.downstream.on_next(value) }
    }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn distinct<S: Observable>(source: S) -> DistinctOp<S> {
    DistinctOp { source: source }
}

/// DistinctUntilChanged - emit when value changes
struct DistinctUntilChangedOp<S> { source: S }

impl<S: Observable> Observable for DistinctUntilChangedOp<S> where S.Item: Eq + Clone {
    type Item = S.Item
    fn subscribe(obs: impl Observer<S.Item>) -> Subscription {
        self.source.subscribe(DistinctUntilChangedObserver { downstream: obs, last: None })
    }
}

struct DistinctUntilChangedObserver<O, T> { downstream: O, last: Option<T> }
impl<O: Observer<T>, T: Eq + Clone> Observer<T> for DistinctUntilChangedObserver<O, T> {
    fn on_next(value: T) {
        let should_emit = match self.last {
            Some(ref last) => *last != value,
            None => true
        }
        if should_emit {
            self.last = Some(value.clone())
            self.downstream.on_next(value)
        }
    }
    fn on_error(err: Error) { self.downstream.on_error(err) }
    fn on_complete() { self.downstream.on_complete() }
}

fn distinct_until_changed<S: Observable>(source: S) -> DistinctUntilChangedOp<S> {
    DistinctUntilChangedOp { source: source }
}

// =============================================================================
// Combination Operators
// =============================================================================

/// Merge operator - combine multiple observables
fn merge<T: Clone>(sources: [impl Observable<Item = T>]) -> impl Observable<Item = T> {
    create(|obs| {
        var completed_count = 0
        let total = sources.len()
        var subscriptions = []
        
        for source in sources {
            let sub = source.subscribe(observer(
                |v| obs.on_next(v),
                |e| obs.on_error(e),
                || {
                    completed_count += 1
                    if completed_count == total { obs.on_complete() }
                }
            ))
            subscriptions.push(sub)
        }
        
        Subscription.new(|| {
            for sub in subscriptions { sub.unsubscribe() }
        })
    })
}

/// Concat operator - emit from sources sequentially
fn concat<T: Clone>(sources: [impl Observable<Item = T>]) -> impl Observable<Item = T> {
    create(|obs| {
        var index = 0
        var current_sub: Option<Subscription> = None
        
        fn subscribe_next() {
            if index >= sources.len() {
                obs.on_complete()
                return
            }
            current_sub = Some(sources[index].subscribe(observer(
                |v| obs.on_next(v),
                |e| obs.on_error(e),
                || { index += 1; subscribe_next() }
            )))
        }
        
        subscribe_next()
        
        Subscription.new(|| {
            if let Some(sub) = current_sub { sub.unsubscribe() }
        })
    })
}

/// CombineLatest - emit combined latest values
fn combine_latest<A: Clone, B: Clone>(
    a: impl Observable<Item = A>,
    b: impl Observable<Item = B>
) -> impl Observable<Item = (A, B)> {
    create(|obs| {
        var latest_a: Option<A> = None
        var latest_b: Option<B> = None
        var completed_a = false
        var completed_b = false
        
        fn try_emit() {
            if let (Some(va), Some(vb)) = (latest_a.clone(), latest_b.clone()) {
                obs.on_next((va, vb))
            }
        }
        
        let sub_a = a.subscribe(observer(
            |v| { latest_a = Some(v); try_emit() },
            |e| obs.on_error(e),
            || { completed_a = true; if completed_b { obs.on_complete() } }
        ))
        
        let sub_b = b.subscribe(observer(
            |v| { latest_b = Some(v); try_emit() },
            |e| obs.on_error(e),
            || { completed_b = true; if completed_a { obs.on_complete() } }
        ))
        
        Subscription.new(|| { sub_a.unsubscribe(); sub_b.unsubscribe() })
    })
}

/// Zip operator - pair values by index
fn zip<A: Clone, B: Clone>(
    a: impl Observable<Item = A>,
    b: impl Observable<Item = B>
) -> impl Observable<Item = (A, B)> {
    create(|obs| {
        var queue_a: [A] = []
        var queue_b: [B] = []
        var completed_a = false
        var completed_b = false
        
        fn try_emit() {
            while !queue_a.is_empty() && !queue_b.is_empty() {
                obs.on_next((queue_a.remove(0), queue_b.remove(0)))
            }
            if (completed_a && queue_a.is_empty()) || (completed_b && queue_b.is_empty()) {
                obs.on_complete()
            }
        }
        
        let sub_a = a.subscribe(observer(
            |v| { queue_a.push(v); try_emit() },
            |e| obs.on_error(e),
            || { completed_a = true; try_emit() }
        ))
        
        let sub_b = b.subscribe(observer(
            |v| { queue_b.push(v); try_emit() },
            |e| obs.on_error(e),
            || { completed_b = true; try_emit() }
        ))
        
        Subscription.new(|| { sub_a.unsubscribe(); sub_b.unsubscribe() })
    })
}

/// WithLatestFrom - combine with latest from another
fn with_latest_from<A: Clone, B: Clone>(
    source: impl Observable<Item = A>,
    other: impl Observable<Item = B>
) -> impl Observable<Item = (A, B)> {
    create(|obs| {
        var latest_b: Option<B> = None
        
        let sub_b = other.subscribe(observer(
            |v| latest_b = Some(v),
            |_| {},
            || {}
        ))
        
        let sub_a = source.subscribe(observer(
            |v| { if let Some(b) = latest_b.clone() { obs.on_next((v, b)) } },
            |e| obs.on_error(e),
            || obs.on_complete()
        ))
        
        Subscription.new(|| { sub_a.unsubscribe(); sub_b.unsubscribe() })
    })
}

// =============================================================================
// Time-based Operators
// =============================================================================

/// Debounce - emit after quiet period
fn debounce<S: Observable>(source: S, ms: Int64) -> impl Observable<Item = S.Item> where S.Item: Clone {
    create(|obs| {
        var timer_id: Option<Int64> = None
        var latest: Option<S.Item> = None
        
        let sub = source.subscribe(observer(
            |v| {
                latest = Some(v)
                if let Some(id) = timer_id { @native("clear_timeout", id) }
                timer_id = Some(@native("set_timeout", ms, || {
                    if let Some(val) = latest.take() { obs.on_next(val) }
                }))
            },
            |e| obs.on_error(e),
            || {
                if let Some(id) = timer_id { @native("clear_timeout", id) }
                if let Some(val) = latest.take() { obs.on_next(val) }
                obs.on_complete()
            }
        ))
        
        Subscription.new(|| {
            if let Some(id) = timer_id { @native("clear_timeout", id) }
            sub.unsubscribe()
        })
    })
}

/// Throttle - emit at most once per interval
fn throttle<S: Observable>(source: S, ms: Int64) -> impl Observable<Item = S.Item> where S.Item: Clone {
    create(|obs| {
        var last_emit: Int64 = 0
        
        source.subscribe(observer(
            |v| {
                let now = @native("timestamp_ms")
                if now - last_emit >= ms {
                    last_emit = now
                    obs.on_next(v)
                }
            },
            |e| obs.on_error(e),
            || obs.on_complete()
        ))
    })
}

/// Delay - delay all emissions
fn delay<S: Observable>(source: S, ms: Int64) -> impl Observable<Item = S.Item> {
    create(|obs| {
        source.subscribe(observer(
            |v| @native("set_timeout", ms, || obs.on_next(v)),
            |e| @native("set_timeout", ms, || obs.on_error(e)),
            || @native("set_timeout", ms, || obs.on_complete())
        ))
    })
}

/// Timeout - error if no emission within time
fn timeout<S: Observable>(source: S, ms: Int64) -> impl Observable<Item = S.Item> {
    create(|obs| {
        var timer_id = @native("set_timeout", ms, || obs.on_error(Error.Timeout))
        
        source.subscribe(observer(
            |v| {
                @native("clear_timeout", timer_id)
                timer_id = @native("set_timeout", ms, || obs.on_error(Error.Timeout))
                obs.on_next(v)
            },
            |e| { @native("clear_timeout", timer_id); obs.on_error(e) },
            || { @native("clear_timeout", timer_id); obs.on_complete() }
        ))
    })
}

// =============================================================================
// Utility Operators
// =============================================================================

/// Tap - side effect without modifying
fn tap<S: Observable>(source: S, action: fn(S.Item)) -> impl Observable<Item = S.Item> where S.Item: Clone {
    create(|obs| {
        source.subscribe(observer(
            |v| { action(v.clone()); obs.on_next(v) },
            |e| obs.on_error(e),
            || obs.on_complete()
        ))
    })
}

/// StartWith - prepend values
fn start_with<S: Observable>(source: S, values: [S.Item]) -> impl Observable<Item = S.Item> where S.Item: Clone {
    create(|obs| {
        for v in values { obs.on_next(v) }
        source.subscribe(obs)
    })
}

/// DefaultIfEmpty - emit default if empty
fn default_if_empty<S: Observable>(source: S, default: S.Item) -> impl Observable<Item = S.Item> where S.Item: Clone {
    create(|obs| {
        var has_value = false
        source.subscribe(observer(
            |v| { has_value = true; obs.on_next(v) },
            |e| obs.on_error(e),
            || { if !has_value { obs.on_next(default) }; obs.on_complete() }
        ))
    })
}

/// Buffer - collect into arrays
fn buffer<S: Observable>(source: S, size: Int) -> impl Observable<Item = [S.Item]> {
    create(|obs| {
        var buf = []
        source.subscribe(observer(
            |v| {
                buf.push(v)
                if buf.len() >= size {
                    obs.on_next(buf.clone())
                    buf.clear()
                }
            },
            |e| obs.on_error(e),
            || { if !buf.is_empty() { obs.on_next(buf) }; obs.on_complete() }
        ))
    })
}

// =============================================================================
// Error Handling Operators
// =============================================================================

/// CatchError - handle errors
fn catch_error<S: Observable>(source: S, handler: fn(Error) -> impl Observable<Item = S.Item>) -> impl Observable<Item = S.Item> {
    create(|obs| {
        source.subscribe(observer(
            |v| obs.on_next(v),
            |e| handler(e).subscribe(obs),
            || obs.on_complete()
        ))
    })
}

/// Retry - retry on error
fn retry<S: Observable + Clone>(source: S, count: Int) -> impl Observable<Item = S.Item> {
    create(|obs| {
        var attempts = 0
        fn try_subscribe() {
            source.clone().subscribe(observer(
                |v| obs.on_next(v),
                |e| {
                    attempts += 1
                    if attempts < count { try_subscribe() }
                    else { obs.on_error(e) }
                },
                || obs.on_complete()
            ))
        }
        try_subscribe()
        Subscription.empty()
    })
}

// =============================================================================
// Tests
// =============================================================================

test "map" {
    var result = []
    let source = observable::from_values([1, 2, 3])
    map(source, |x| x * 2).subscribe(observable::next_observer(|v| result.push(v)))
    assert_eq(result, [2, 4, 6])?
}

test "filter" {
    var result = []
    let source = observable::from_values([1, 2, 3, 4, 5])
    filter(source, |x| x % 2 == 0).subscribe(observable::next_observer(|v| result.push(v)))
    assert_eq(result, [2, 4])?
}

test "take" {
    var result = []
    let source = observable::from_values([1, 2, 3, 4, 5])
    take(source, 3).subscribe(observable::next_observer(|v| result.push(v)))
    assert_eq(result, [1, 2, 3])?
}

test "scan" {
    var result = []
    let source = observable::from_values([1, 2, 3])
    scan(source, 0, |acc, x| acc + x).subscribe(observable::next_observer(|v| result.push(v)))
    assert_eq(result, [1, 3, 6])?
}

test "distinct_until_changed" {
    var result = []
    let source = observable::from_values([1, 1, 2, 2, 3, 1])
    distinct_until_changed(source).subscribe(observable::next_observer(|v| result.push(v)))
    assert_eq(result, [1, 2, 3, 1])?
}
