// =============================================================================
// Vibee OS â€” Lead Module
// CRM lead management with scoring, qualification, and conversion
// =============================================================================

use datetime::{DateTime}
use uuid::{UUID}
use contact::{Contact, ContactEmail, ContactPhone}

// =============================================================================
// Lead Types & Enums
// =============================================================================

enum LeadStatus {
    New
    Contacted
    Qualified
    Unqualified
    Nurturing
    Converted
    Lost
}

impl LeadStatus {
    fn is_open() -> Bool {
        match self {
            LeadStatus.New | LeadStatus.Contacted | LeadStatus.Qualified | LeadStatus.Nurturing => true
            _ => false
        }
    }
    
    fn is_closed() -> Bool { !self.is_open() }
    
    fn display_name() -> String {
        match self {
            LeadStatus.New => "New"
            LeadStatus.Contacted => "Contacted"
            LeadStatus.Qualified => "Qualified"
            LeadStatus.Unqualified => "Unqualified"
            LeadStatus.Nurturing => "Nurturing"
            LeadStatus.Converted => "Converted"
            LeadStatus.Lost => "Lost"
        }
    }
}

enum LeadSource {
    Website
    Referral
    Advertisement
    ColdCall
    Email
    SocialMedia
    TradeShow
    Partner
    Other
}

enum LeadRating { Hot, Warm, Cold }

enum LeadPriority { Low, Medium, High, Urgent }

// =============================================================================
// Lead
// =============================================================================

struct Lead {
    id: String
    status: LeadStatus
    source: LeadSource
    rating: LeadRating
    priority: LeadPriority
    
    // Contact info
    first_name: String
    last_name: String
    email: Option<String>
    phone: Option<String>
    company: Option<String>
    job_title: Option<String>
    website: Option<String>
    
    // Lead details
    description: Option<String>
    industry: Option<String>
    annual_revenue: Option<Float>
    employee_count: Option<Int>
    
    // Scoring
    score: Int
    score_breakdown: Map<String, Int>
    
    // Assignment
    owner_id: Option<String>
    assigned_at: Option<DateTime>
    
    // Tracking
    campaign_id: Option<String>
    utm_source: Option<String>
    utm_medium: Option<String>
    utm_campaign: Option<String>
    referrer_url: Option<String>
    landing_page: Option<String>
    
    // Qualification
    budget: Option<Float>
    authority: Option<String>
    need: Option<String>
    timeline: Option<String>
    
    // Conversion
    converted_contact_id: Option<String>
    converted_deal_id: Option<String>
    converted_at: Option<DateTime>
    conversion_notes: Option<String>
    
    // Loss
    lost_reason: Option<String>
    lost_at: Option<DateTime>
    
    // Custom
    tags: [String]
    custom_fields: Map<String, String>
    
    // Timestamps
    created_at: DateTime
    updated_at: DateTime
    last_activity_at: Option<DateTime>
}

impl Lead {
    fn new(first_name: String, last_name: String) -> Self {
        let now = DateTime.now()
        Lead {
            id: UUID.v4().to_string(),
            status: LeadStatus.New,
            source: LeadSource.Website,
            rating: LeadRating.Cold,
            priority: LeadPriority.Medium,
            first_name: first_name,
            last_name: last_name,
            email: None,
            phone: None,
            company: None,
            job_title: None,
            website: None,
            description: None,
            industry: None,
            annual_revenue: None,
            employee_count: None,
            score: 0,
            score_breakdown: Map.empty(),
            owner_id: None,
            assigned_at: None,
            campaign_id: None,
            utm_source: None,
            utm_medium: None,
            utm_campaign: None,
            referrer_url: None,
            landing_page: None,
            budget: None,
            authority: None,
            need: None,
            timeline: None,
            converted_contact_id: None,
            converted_deal_id: None,
            converted_at: None,
            conversion_notes: None,
            lost_reason: None,
            lost_at: None,
            tags: [],
            custom_fields: Map.empty(),
            created_at: now,
            updated_at: now,
            last_activity_at: None
        }
    }
    
    // Builder methods
    fn with_email(e: String) -> Self { self.email = Some(e); self }
    fn with_phone(p: String) -> Self { self.phone = Some(p); self }
    fn with_company(c: String) -> Self { self.company = Some(c); self }
    fn with_job_title(j: String) -> Self { self.job_title = Some(j); self }
    fn with_source(s: LeadSource) -> Self { self.source = s; self }
    fn with_rating(r: LeadRating) -> Self { self.rating = r; self }
    fn with_priority(p: LeadPriority) -> Self { self.priority = p; self }
    fn with_owner(id: String) -> Self { self.owner_id = Some(id); self.assigned_at = Some(DateTime.now()); self }
    fn with_campaign(id: String) -> Self { self.campaign_id = Some(id); self }
    fn with_description(d: String) -> Self { self.description = Some(d); self }
    fn with_industry(i: String) -> Self { self.industry = Some(i); self }
    fn with_revenue(r: Float) -> Self { self.annual_revenue = Some(r); self }
    fn with_employees(n: Int) -> Self { self.employee_count = Some(n); self }
    
    // UTM tracking
    fn with_utm(source: String, medium: String, campaign: String) -> Self {
        self.utm_source = Some(source)
        self.utm_medium = Some(medium)
        self.utm_campaign = Some(campaign)
        self
    }
    
    // BANT qualification
    fn set_budget(b: Float) -> Self { self.budget = Some(b); self }
    fn set_authority(a: String) -> Self { self.authority = Some(a); self }
    fn set_need(n: String) -> Self { self.need = Some(n); self }
    fn set_timeline(t: String) -> Self { self.timeline = Some(t); self }
    
    // Tags
    fn add_tag(t: String) -> Self { if !self.tags.contains(t) { self.tags.push(t) }; self }
    fn remove_tag(t: String) -> Self { self.tags.retain(|x| x != t); self }
    fn has_tag(t: String) -> Bool { self.tags.contains(t) }
    
    // Status transitions
    fn mark_contacted() -> Result<Self, LeadError> {
        if self.status != LeadStatus.New { return Err(LeadError.InvalidTransition) }
        self.status = LeadStatus.Contacted
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn qualify() -> Result<Self, LeadError> {
        if self.status == LeadStatus.Converted || self.status == LeadStatus.Lost {
            return Err(LeadError.InvalidTransition)
        }
        self.status = LeadStatus.Qualified
        self.rating = LeadRating.Hot
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn disqualify(reason: String) -> Result<Self, LeadError> {
        if self.status.is_closed() { return Err(LeadError.InvalidTransition) }
        self.status = LeadStatus.Unqualified
        self.lost_reason = Some(reason)
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn nurture() -> Result<Self, LeadError> {
        if self.status.is_closed() { return Err(LeadError.InvalidTransition) }
        self.status = LeadStatus.Nurturing
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn convert(contact_id: String, deal_id: Option<String>, notes: Option<String>) -> Result<Self, LeadError> {
        if self.status != LeadStatus.Qualified { return Err(LeadError.NotQualified) }
        self.status = LeadStatus.Converted
        self.converted_contact_id = Some(contact_id)
        self.converted_deal_id = deal_id
        self.conversion_notes = notes
        self.converted_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn mark_lost(reason: String) -> Result<Self, LeadError> {
        if self.status.is_closed() { return Err(LeadError.InvalidTransition) }
        self.status = LeadStatus.Lost
        self.lost_reason = Some(reason)
        self.lost_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    // Scoring
    fn add_score(category: String, points: Int) -> Self {
        self.score_breakdown.insert(category.clone(), self.score_breakdown.get(category).unwrap_or(0) + points)
        self.score = self.score_breakdown.values().sum()
        self.updated_at = DateTime.now()
        self
    }
    
    fn set_score(points: Int) -> Self {
        self.score = points
        self.updated_at = DateTime.now()
        self
    }
    
    fn recalculate_score() -> Self {
        self.score = self.score_breakdown.values().sum()
        self
    }
    
    // Activity tracking
    fn record_activity() -> Self {
        self.last_activity_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        self
    }
    
    // Getters
    fn full_name() -> String { "\(self.first_name) \(self.last_name)".trim() }
    fn is_open() -> Bool { self.status.is_open() }
    fn is_converted() -> Bool { self.status == LeadStatus.Converted }
    fn is_lost() -> Bool { self.status == LeadStatus.Lost }
    fn is_hot() -> Bool { self.rating == LeadRating.Hot }
    fn is_qualified() -> Bool { self.status == LeadStatus.Qualified }
    fn has_bant() -> Bool { self.budget.is_some() && self.authority.is_some() && self.need.is_some() && self.timeline.is_some() }
    
    fn days_since_created() -> Int { DateTime.now().days_since(self.created_at) }
    fn days_since_activity() -> Option<Int> { self.last_activity_at.map(|dt| DateTime.now().days_since(dt)) }
    
    // Convert to Contact
    fn to_contact() -> Contact {
        let mut contact = Contact.new(self.first_name.clone(), self.last_name.clone())
        if let Some(e) = self.email.clone() { contact = contact.add_email(ContactEmail.work(e)) }
        if let Some(p) = self.phone.clone() { contact = contact.add_phone(ContactPhone.work(p)) }
        if let Some(c) = self.company.clone() { contact = contact.with_company(c) }
        if let Some(j) = self.job_title.clone() { contact = contact.with_job_title(j) }
        contact
    }
}

// =============================================================================
// Lead Scoring Rules
// =============================================================================

struct LeadScoringRule {
    id: String
    name: String
    category: String
    condition: ScoringCondition
    points: Int
    is_active: Bool
}

enum ScoringCondition {
    HasEmail
    HasPhone
    HasCompany
    CompanySize(Int, Int)
    Industry(String)
    Source(LeadSource)
    PageVisit(String)
    EmailOpened
    FormSubmitted
    Custom(String)
}

impl LeadScoringRule {
    fn new(name: String, category: String, condition: ScoringCondition, points: Int) -> Self {
        LeadScoringRule { id: UUID.v4().to_string(), name: name, category: category, condition: condition, points: points, is_active: true }
    }
    
    fn evaluate(lead: &Lead) -> Option<Int> {
        if !self.is_active { return None }
        
        let matches = match self.condition {
            ScoringCondition.HasEmail => lead.email.is_some(),
            ScoringCondition.HasPhone => lead.phone.is_some(),
            ScoringCondition.HasCompany => lead.company.is_some(),
            ScoringCondition.CompanySize(min, max) => lead.employee_count.map(|n| n >= min && n <= max).unwrap_or(false),
            ScoringCondition.Industry(ind) => lead.industry == Some(ind),
            ScoringCondition.Source(src) => lead.source == src,
            _ => false
        }
        
        if matches { Some(self.points) } else { None }
    }
}

// =============================================================================
// Lead Query
// =============================================================================

struct LeadQuery {
    search: Option<String>
    status: Option<LeadStatus>
    statuses: [LeadStatus]
    source: Option<LeadSource>
    rating: Option<LeadRating>
    priority: Option<LeadPriority>
    owner_id: Option<String>
    campaign_id: Option<String>
    tags: [String]
    min_score: Option<Int>
    max_score: Option<Int>
    created_after: Option<DateTime>
    created_before: Option<DateTime>
    unassigned_only: Bool
    sort_by: LeadSortField
    sort_order: SortOrder
    limit: Int
    offset: Int
}

enum LeadSortField { Name, CreatedAt, Score, LastActivity, Priority }
enum SortOrder { Asc, Desc }

impl LeadQuery {
    fn new() -> Self {
        LeadQuery {
            search: None, status: None, statuses: [], source: None, rating: None, priority: None,
            owner_id: None, campaign_id: None, tags: [], min_score: None, max_score: None,
            created_after: None, created_before: None, unassigned_only: false,
            sort_by: LeadSortField.CreatedAt, sort_order: SortOrder.Desc, limit: 50, offset: 0
        }
    }
    
    fn with_search(s: String) -> Self { self.search = Some(s); self }
    fn with_status(s: LeadStatus) -> Self { self.status = Some(s); self }
    fn with_statuses(s: [LeadStatus]) -> Self { self.statuses = s; self }
    fn with_source(s: LeadSource) -> Self { self.source = Some(s); self }
    fn with_rating(r: LeadRating) -> Self { self.rating = Some(r); self }
    fn with_owner(id: String) -> Self { self.owner_id = Some(id); self }
    fn with_campaign(id: String) -> Self { self.campaign_id = Some(id); self }
    fn with_tag(t: String) -> Self { self.tags.push(t); self }
    fn open_only() -> Self { self.statuses = [LeadStatus.New, LeadStatus.Contacted, LeadStatus.Qualified, LeadStatus.Nurturing]; self }
    fn hot_only() -> Self { self.rating = Some(LeadRating.Hot); self }
    fn unassigned() -> Self { self.unassigned_only = true; self }
    fn min_score(s: Int) -> Self { self.min_score = Some(s); self }
    fn sort_by_score() -> Self { self.sort_by = LeadSortField.Score; self.sort_order = SortOrder.Desc; self }
    fn sort_by_priority() -> Self { self.sort_by = LeadSortField.Priority; self }
    fn limit(n: Int) -> Self { self.limit = n; self }
    fn page(p: Int, per: Int) -> Self { self.limit = per; self.offset = (p - 1) * per; self }
}

// =============================================================================
// Lead Service
// =============================================================================

actor LeadService {
    state leads: Map<String, Lead>
    state by_email: Map<String, String>
    state by_owner: Map<String, [String]>
    state by_campaign: Map<String, [String]>
    state scoring_rules: [LeadScoringRule]
    
    fn new() -> Self {
        LeadService {
            leads: Map.empty(),
            by_email: Map.empty(),
            by_owner: Map.empty(),
            by_campaign: Map.empty(),
            scoring_rules: []
        }
    }
    
    fn create(lead: Lead) -> Result<Lead, LeadError> {
        // Check duplicate email
        if let Some(email) = lead.email.clone() {
            if self.by_email.contains_key(email) {
                return Err(LeadError.DuplicateEmail(email))
            }
            self.by_email.insert(email, lead.id.clone())
        }
        
        // Apply scoring rules
        var scored_lead = lead.clone()
        for rule in self.scoring_rules.iter() {
            if let Some(points) = rule.evaluate(&scored_lead) {
                scored_lead = scored_lead.add_score(rule.category.clone(), points)
            }
        }
        
        // Index
        if let Some(owner) = scored_lead.owner_id.clone() {
            let ids = self.by_owner.get(owner.clone()).unwrap_or([])
            ids.push(scored_lead.id.clone())
            self.by_owner.insert(owner, ids)
        }
        
        if let Some(campaign) = scored_lead.campaign_id.clone() {
            let ids = self.by_campaign.get(campaign.clone()).unwrap_or([])
            ids.push(scored_lead.id.clone())
            self.by_campaign.insert(campaign, ids)
        }
        
        self.leads.insert(scored_lead.id.clone(), scored_lead.clone())
        Ok(scored_lead)
    }
    
    fn get(id: String) -> Option<Lead> { self.leads.get(id) }
    fn get_by_email(email: String) -> Option<Lead> { self.by_email.get(email).and_then(|id| self.leads.get(id)) }
    fn get_by_owner(owner_id: String) -> [Lead] { self.by_owner.get(owner_id).unwrap_or([]).iter().filter_map(|id| self.leads.get(id)).collect() }
    fn get_by_campaign(campaign_id: String) -> [Lead] { self.by_campaign.get(campaign_id).unwrap_or([]).iter().filter_map(|id| self.leads.get(id)).collect() }
    
    fn update(lead: Lead) -> Result<Lead, LeadError> {
        if !self.leads.contains_key(lead.id) { return Err(LeadError.NotFound) }
        self.leads.insert(lead.id.clone(), lead.clone())
        Ok(lead)
    }
    
    fn delete(id: String) -> Result<(), LeadError> {
        self.leads.remove(id).ok_or(LeadError.NotFound)?
        Ok(())
    }
    
    fn assign(lead_id: String, owner_id: String) -> Result<Lead, LeadError> {
        let mut lead = self.leads.get(lead_id.clone()).ok_or(LeadError.NotFound)?
        lead.owner_id = Some(owner_id.clone())
        lead.assigned_at = Some(DateTime.now())
        lead.updated_at = DateTime.now()
        self.leads.insert(lead_id, lead.clone())
        Ok(lead)
    }
    
    fn convert_lead(lead_id: String, contact_id: String, deal_id: Option<String>) -> Result<Lead, LeadError> {
        let mut lead = self.leads.get(lead_id.clone()).ok_or(LeadError.NotFound)?
        lead = lead.convert(contact_id, deal_id, None)?
        self.leads.insert(lead_id, lead.clone())
        Ok(lead)
    }
    
    fn add_scoring_rule(rule: LeadScoringRule) { self.scoring_rules.push(rule) }
    
    fn rescore_all() {
        for (id, lead) in self.leads.iter_mut() {
            lead.score_breakdown = Map.empty()
            for rule in self.scoring_rules.iter() {
                if let Some(points) = rule.evaluate(lead) {
                    lead.add_score(rule.category.clone(), points)
                }
            }
        }
    }
    
    fn search(query: LeadQuery) -> [Lead] {
        self.leads.values().filter(|l| {
            if let Some(s) = query.status { if l.status != s { return false } }
            if !query.statuses.is_empty() { if !query.statuses.contains(l.status) { return false } }
            if let Some(r) = query.rating { if l.rating != r { return false } }
            if let Some(o) = query.owner_id.clone() { if l.owner_id != Some(o) { return false } }
            if query.unassigned_only { if l.owner_id.is_some() { return false } }
            if let Some(min) = query.min_score { if l.score < min { return false } }
            true
        }).take(query.limit).collect()
    }
    
    fn count() -> Int { self.leads.len() }
    fn count_open() -> Int { self.leads.values().filter(|l| l.is_open()).count() }
    fn count_by_status(status: LeadStatus) -> Int { self.leads.values().filter(|l| l.status == status).count() }
    
    fn get_stats() -> LeadStats {
        let all: [Lead] = self.leads.values().collect()
        LeadStats {
            total: all.len(),
            new: all.iter().filter(|l| l.status == LeadStatus.New).count(),
            contacted: all.iter().filter(|l| l.status == LeadStatus.Contacted).count(),
            qualified: all.iter().filter(|l| l.status == LeadStatus.Qualified).count(),
            converted: all.iter().filter(|l| l.status == LeadStatus.Converted).count(),
            lost: all.iter().filter(|l| l.status == LeadStatus.Lost).count(),
            avg_score: if all.is_empty() { 0.0 } else { all.iter().map(|l| l.score).sum() as Float / all.len() as Float }
        }
    }
}

// =============================================================================
// Lead Stats
// =============================================================================

struct LeadStats {
    total: Int
    new: Int
    contacted: Int
    qualified: Int
    converted: Int
    lost: Int
    avg_score: Float
}

impl LeadStats {
    fn conversion_rate() -> Float { if self.total == 0 { 0.0 } else { self.converted as Float / self.total as Float * 100.0 } }
    fn qualification_rate() -> Float { if self.total == 0 { 0.0 } else { (self.qualified + self.converted) as Float / self.total as Float * 100.0 } }
}

// =============================================================================
// Errors
// =============================================================================

enum LeadError {
    NotFound
    DuplicateEmail(String)
    InvalidTransition
    NotQualified
    ValidationError(String)
}

impl Display for LeadError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("Lead not found"),
            DuplicateEmail(e) => f.write("Duplicate email: \(e)"),
            InvalidTransition => f.write("Invalid status transition"),
            NotQualified => f.write("Lead must be qualified before conversion"),
            ValidationError(e) => f.write("Validation error: \(e)")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "lead creation" {
    let lead = Lead.new("John", "Doe")
        .with_email("john@example.com")
        .with_company("Acme Inc")
        .with_source(LeadSource.Website)
    
    assert_eq(lead.full_name(), "John Doe")?
    assert_eq(lead.status, LeadStatus.New)?
}

test "lead qualification" {
    var lead = Lead.new("Jane", "Smith").with_email("jane@test.com")
    lead = lead.mark_contacted().unwrap()
    lead = lead.qualify().unwrap()
    
    assert_eq(lead.status, LeadStatus.Qualified)?
    assert(lead.is_hot())?
}

test "lead conversion" {
    var lead = Lead.new("Bob", "Brown").qualify().unwrap()
    lead = lead.convert("contact-123", Some("deal-456"), None).unwrap()
    
    assert(lead.is_converted())?
    assert_eq(lead.converted_contact_id, Some("contact-123"))?
}

test "lead scoring" {
    let service = LeadService.new()
    service.add_scoring_rule(LeadScoringRule.new("Has Email", "profile", ScoringCondition.HasEmail, 10))
    service.add_scoring_rule(LeadScoringRule.new("Has Company", "profile", ScoringCondition.HasCompany, 15))
    
    let lead = service.create(Lead.new("Test", "User").with_email("test@test.com").with_company("Test Co")).unwrap()
    assert_eq(lead.score, 25)?
}

test "lead service stats" {
    let service = LeadService.new()
    service.create(Lead.new("A", "A")).unwrap()
    service.create(Lead.new("B", "B")).unwrap()
    
    let stats = service.get_stats()
    assert_eq(stats.total, 2)?
    assert_eq(stats.new, 2)?
}
