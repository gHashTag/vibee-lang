// =============================================================================
// Vibee OS â€” TCP Module
// Advanced TCP socket operations and utilities
// =============================================================================

use net.{IpAddr, SocketAddr, TcpStream, TcpListener, NetError, Shutdown}
use io.{Read, Write, BufReader, BufWriter}
use tls.{TlsConfig, TlsStream}

/// TCP Connection with advanced features
struct TcpConnection {
    stream: TcpStream
    read_timeout: Option<Int64>
    write_timeout: Option<Int64>
    nodelay: Bool
    keepalive: Option<Int64>
}

impl TcpConnection {
    /// Connect to a remote address
    fn connect(addr: String) -> Result<Self, TcpError> {
        let socket_addr = SocketAddr.parse(addr)?
        let stream = TcpStream.connect(socket_addr)?
        Ok(TcpConnection {
            stream: stream,
            read_timeout: None,
            write_timeout: None,
            nodelay: false,
            keepalive: None
        })
    }
    
    /// Connect with timeout
    fn connect_timeout(addr: String, timeout_ms: Int64) -> Result<Self, TcpError> {
        let socket_addr = SocketAddr.parse(addr)?
        let stream = TcpStream.connect_timeout(socket_addr, timeout_ms)?
        Ok(TcpConnection {
            stream: stream,
            read_timeout: None,
            write_timeout: None,
            nodelay: false,
            keepalive: None
        })
    }
    
    /// Set read timeout
    fn read_timeout(timeout_ms: Int64) -> Self {
        self.read_timeout = Some(timeout_ms)
        self.stream.set_read_timeout(Some(timeout_ms))
        self
    }
    
    /// Set write timeout
    fn write_timeout(timeout_ms: Int64) -> Self {
        self.write_timeout = Some(timeout_ms)
        self.stream.set_write_timeout(Some(timeout_ms))
        self
    }
    
    /// Enable TCP_NODELAY (disable Nagle's algorithm)
    fn nodelay(enabled: Bool) -> Self {
        self.nodelay = enabled
        self.stream.set_nodelay(enabled)
        self
    }
    
    /// Set keepalive interval
    fn keepalive(interval_ms: Int64) -> Self {
        self.keepalive = Some(interval_ms)
        self.stream.set_keepalive(Some(interval_ms))
        self
    }
    
    /// Read data into buffer
    fn read(buf: [UInt8]) -> Result<Int, TcpError> {
        self.stream.read(buf).map_err(TcpError.from_net)
    }
    
    /// Write data
    fn write(data: [UInt8]) -> Result<Int, TcpError> {
        self.stream.write(data).map_err(TcpError.from_net)
    }
    
    /// Read exact number of bytes
    fn read_exact(buf: [UInt8]) -> Result<(), TcpError> {
        self.stream.read_exact(buf).map_err(TcpError.from_net)
    }
    
    /// Write all data
    fn write_all(data: [UInt8]) -> Result<(), TcpError> {
        self.stream.write_all(data).map_err(TcpError.from_net)
    }
    
    /// Read a line (until \n)
    fn read_line() -> Result<String, TcpError> {
        var buf = []
        var byte = [0u8]
        loop {
            let n = self.stream.read(byte)?
            if n == 0 { break }
            if byte[0] == '\n' as UInt8 { break }
            buf.push(byte[0])
        }
        String.from_utf8(buf).map_err(|_| TcpError.InvalidData)
    }
    
    /// Write a line (append \r\n)
    fn write_line(line: String) -> Result<(), TcpError> {
        self.write_all(format!("{}\r\n", line).as_bytes())
    }
    
    /// Flush the stream
    fn flush() -> Result<(), TcpError> {
        self.stream.flush().map_err(TcpError.from_net)
    }
    
    /// Shutdown the connection
    fn shutdown(how: Shutdown) -> Result<(), TcpError> {
        self.stream.shutdown(how).map_err(TcpError.from_net)
    }
    
    /// Close the connection
    fn close() {
        self.stream.close()
    }
    
    /// Get local address
    fn local_addr() -> Result<SocketAddr, TcpError> {
        self.stream.local_addr().map_err(TcpError.from_net)
    }
    
    /// Get peer address
    fn peer_addr() -> Result<SocketAddr, TcpError> {
        self.stream.peer_addr().map_err(TcpError.from_net)
    }
    
    /// Upgrade to TLS
    fn upgrade_tls(config: TlsConfig) -> Result<TlsStream, TcpError> {
        TlsStream.from_tcp(self.stream, config).map_err(|e| TcpError.TlsError(e.to_string()))
    }
    
    /// Get buffered reader
    fn buffered_reader() -> BufReader<TcpStream> {
        BufReader.new(self.stream)
    }
    
    /// Get buffered writer
    fn buffered_writer() -> BufWriter<TcpStream> {
        BufWriter.new(self.stream)
    }
}

impl Read for TcpConnection {
    fn read(buf: [UInt8]) -> Result<Int, IoError> {
        self.stream.read(buf).map_err(|e| IoError.Other(e.to_string()))
    }
}

impl Write for TcpConnection {
    fn write(data: [UInt8]) -> Result<Int, IoError> {
        self.stream.write(data).map_err(|e| IoError.Other(e.to_string()))
    }
    fn flush() -> Result<(), IoError> {
        self.stream.flush().map_err(|e| IoError.Other(e.to_string()))
    }
}

impl Drop for TcpConnection {
    fn drop() { self.close() }
}

/// TCP Server with connection handling
actor TcpServer {
    state listener: TcpListener
    state addr: SocketAddr
    state max_connections: Int
    state active_connections: Int
    state running: Bool
    state on_connect: Option<fn(TcpConnection)>
    state on_error: Option<fn(TcpError)>
}

impl TcpServer {
    /// Create a new TCP server
    fn new(addr: String) -> Result<Self, TcpError> {
        let socket_addr = SocketAddr.parse(addr)?
        let listener = TcpListener.bind(socket_addr)?
        Ok(TcpServer {
            listener: listener,
            addr: socket_addr,
            max_connections: 1000,
            active_connections: 0,
            running: false,
            on_connect: None,
            on_error: None
        })
    }
    
    /// Set maximum concurrent connections
    fn max_connections(max: Int) -> Self {
        self.max_connections = max
        self
    }
    
    /// Set connection handler
    fn on_connect(handler: fn(TcpConnection)) -> Self {
        self.on_connect = Some(handler)
        self
    }
    
    /// Set error handler
    fn on_error(handler: fn(TcpError)) -> Self {
        self.on_error = Some(handler)
        self
    }
    
    /// Start accepting connections
    fn run() -> Result<(), TcpError> {
        self.running = true
        while self.running {
            if self.active_connections >= self.max_connections {
                @native("sleep_ms", 10)
                continue
            }
            
            match self.listener.accept() {
                Ok((stream, addr)) => {
                    self.active_connections += 1
                    let conn = TcpConnection {
                        stream: stream,
                        read_timeout: None,
                        write_timeout: None,
                        nodelay: false,
                        keepalive: None
                    }
                    if let Some(handler) = self.on_connect {
                        spawn { handler(conn); self.active_connections -= 1 }
                    }
                }
                Err(e) => {
                    if let Some(handler) = self.on_error {
                        handler(TcpError.from_net(e))
                    }
                }
            }
        }
        Ok(())
    }
    
    /// Stop the server
    fn stop() {
        self.running = false
    }
    
    /// Get server address
    fn addr() -> SocketAddr {
        self.addr
    }
    
    /// Get active connection count
    fn connection_count() -> Int {
        self.active_connections
    }
}

/// TCP Client pool for connection reuse
actor TcpPool {
    state addr: String
    state pool: [TcpConnection]
    state max_size: Int
    state timeout_ms: Int64
    state nodelay: Bool
}

impl TcpPool {
    /// Create a new connection pool
    fn new(addr: String) -> Self {
        TcpPool {
            addr: addr,
            pool: [],
            max_size: 10,
            timeout_ms: 30000,
            nodelay: true
        }
    }
    
    /// Set maximum pool size
    fn max_size(size: Int) -> Self {
        self.max_size = size
        self
    }
    
    /// Set connection timeout
    fn timeout(ms: Int64) -> Self {
        self.timeout_ms = ms
        self
    }
    
    /// Set nodelay option
    fn nodelay(enabled: Bool) -> Self {
        self.nodelay = enabled
        self
    }
    
    /// Get a connection from the pool
    fn get() -> Result<TcpConnection, TcpError> {
        if let Some(conn) = self.pool.pop() {
            return Ok(conn)
        }
        TcpConnection.connect_timeout(self.addr, self.timeout_ms)?
            .nodelay(self.nodelay)
    }
    
    /// Return a connection to the pool
    fn put(conn: TcpConnection) {
        if self.pool.len() < self.max_size {
            self.pool.push(conn)
        }
    }
    
    /// Execute a function with a pooled connection
    fn with<T>(f: fn(TcpConnection) -> Result<T, TcpError>) -> Result<T, TcpError> {
        let conn = self.get()?
        let result = f(conn)
        if result.is_ok() {
            self.put(conn)
        }
        result
    }
    
    /// Clear all connections
    fn clear() {
        self.pool.clear()
    }
    
    /// Get pool size
    fn size() -> Int {
        self.pool.len()
    }
}

/// TCP Socket options
struct TcpOptions {
    nodelay: Bool
    keepalive: Option<Int64>
    recv_buffer_size: Option<Int>
    send_buffer_size: Option<Int>
    linger: Option<Int>
    reuse_addr: Bool
    reuse_port: Bool
}

impl TcpOptions {
    fn default() -> Self {
        TcpOptions {
            nodelay: false,
            keepalive: None,
            recv_buffer_size: None,
            send_buffer_size: None,
            linger: None,
            reuse_addr: false,
            reuse_port: false
        }
    }
    
    fn nodelay(enabled: Bool) -> Self { self.nodelay = enabled; self }
    fn keepalive(interval_ms: Int64) -> Self { self.keepalive = Some(interval_ms); self }
    fn recv_buffer(size: Int) -> Self { self.recv_buffer_size = Some(size); self }
    fn send_buffer(size: Int) -> Self { self.send_buffer_size = Some(size); self }
    fn linger(seconds: Int) -> Self { self.linger = Some(seconds); self }
    fn reuse_addr(enabled: Bool) -> Self { self.reuse_addr = enabled; self }
    fn reuse_port(enabled: Bool) -> Self { self.reuse_port = enabled; self }
    
    fn apply(stream: TcpStream) {
        stream.set_nodelay(self.nodelay)
        if let Some(ka) = self.keepalive { stream.set_keepalive(Some(ka)) }
        if let Some(size) = self.recv_buffer_size { @native("tcp_set_recv_buffer", stream, size) }
        if let Some(size) = self.send_buffer_size { @native("tcp_set_send_buffer", stream, size) }
        if let Some(secs) = self.linger { @native("tcp_set_linger", stream, secs) }
    }
}

/// Line-based protocol helper
struct LineProtocol {
    conn: TcpConnection
    delimiter: String
}

impl LineProtocol {
    fn new(conn: TcpConnection) -> Self {
        LineProtocol { conn: conn, delimiter: "\r\n" }
    }
    
    fn delimiter(delim: String) -> Self {
        self.delimiter = delim
        self
    }
    
    fn send(line: String) -> Result<(), TcpError> {
        self.conn.write_all(format!("{}{}", line, self.delimiter).as_bytes())
    }
    
    fn recv() -> Result<String, TcpError> {
        var buf = []
        var byte = [0u8]
        let delim_bytes = self.delimiter.as_bytes()
        
        loop {
            let n = self.conn.read(byte)?
            if n == 0 { break }
            buf.push(byte[0])
            
            if buf.len() >= delim_bytes.len() {
                let tail = buf[(buf.len() - delim_bytes.len())..]
                if tail == delim_bytes {
                    buf.truncate(buf.len() - delim_bytes.len())
                    break
                }
            }
        }
        
        String.from_utf8(buf).map_err(|_| TcpError.InvalidData)
    }
    
    fn request(line: String) -> Result<String, TcpError> {
        self.send(line)?
        self.recv()
    }
}

/// Length-prefixed protocol helper
struct LengthPrefixProtocol {
    conn: TcpConnection
    prefix_size: Int  // 1, 2, or 4 bytes
    big_endian: Bool
}

impl LengthPrefixProtocol {
    fn new(conn: TcpConnection) -> Self {
        LengthPrefixProtocol { conn: conn, prefix_size: 4, big_endian: true }
    }
    
    fn prefix_size(size: Int) -> Self {
        self.prefix_size = size
        self
    }
    
    fn little_endian() -> Self {
        self.big_endian = false
        self
    }
    
    fn send(data: [UInt8]) -> Result<(), TcpError> {
        let len = data.len()
        var prefix = []
        
        match self.prefix_size {
            1 => prefix = [len as UInt8]
            2 => {
                if self.big_endian {
                    prefix = [(len >> 8) as UInt8, len as UInt8]
                } else {
                    prefix = [len as UInt8, (len >> 8) as UInt8]
                }
            }
            4 => {
                if self.big_endian {
                    prefix = [(len >> 24) as UInt8, (len >> 16) as UInt8, (len >> 8) as UInt8, len as UInt8]
                } else {
                    prefix = [len as UInt8, (len >> 8) as UInt8, (len >> 16) as UInt8, (len >> 24) as UInt8]
                }
            }
            _ => return Err(TcpError.InvalidData)
        }
        
        self.conn.write_all(prefix)?
        self.conn.write_all(data)
    }
    
    fn recv() -> Result<[UInt8], TcpError> {
        var prefix = [0u8; self.prefix_size]
        self.conn.read_exact(prefix)?
        
        let len = match self.prefix_size {
            1 => prefix[0] as Int
            2 => {
                if self.big_endian {
                    ((prefix[0] as Int) << 8) | (prefix[1] as Int)
                } else {
                    (prefix[0] as Int) | ((prefix[1] as Int) << 8)
                }
            }
            4 => {
                if self.big_endian {
                    ((prefix[0] as Int) << 24) | ((prefix[1] as Int) << 16) | ((prefix[2] as Int) << 8) | (prefix[3] as Int)
                } else {
                    (prefix[0] as Int) | ((prefix[1] as Int) << 8) | ((prefix[2] as Int) << 16) | ((prefix[3] as Int) << 24)
                }
            }
            _ => return Err(TcpError.InvalidData)
        }
        
        var data = [0u8; len]
        self.conn.read_exact(data)?
        Ok(data)
    }
}

/// TCP Error types
enum TcpError {
    ConnectionRefused
    ConnectionReset
    ConnectionAborted
    NotConnected
    AddrInUse
    AddrNotAvailable
    Timeout
    InvalidAddress
    InvalidData
    TlsError(String)
    Io(String)
    Other(String)
}

impl TcpError {
    fn from_net(e: NetError) -> Self {
        match e {
            NetError.ConnectionRefused => TcpError.ConnectionRefused
            NetError.ConnectionReset => TcpError.ConnectionReset
            NetError.ConnectionAborted => TcpError.ConnectionAborted
            NetError.NotConnected => TcpError.NotConnected
            NetError.AddrInUse => TcpError.AddrInUse
            NetError.AddrNotAvailable => TcpError.AddrNotAvailable
            NetError.Timeout => TcpError.Timeout
            NetError.InvalidAddress => TcpError.InvalidAddress
            NetError.Other(s) => TcpError.Other(s)
            _ => TcpError.Other(e.to_string())
        }
    }
}

impl Display for TcpError {
    fn fmt(f: Formatter) {
        match self {
            ConnectionRefused => f.write("Connection refused")
            ConnectionReset => f.write("Connection reset by peer")
            ConnectionAborted => f.write("Connection aborted")
            NotConnected => f.write("Not connected")
            AddrInUse => f.write("Address already in use")
            AddrNotAvailable => f.write("Address not available")
            Timeout => f.write("Connection timed out")
            InvalidAddress => f.write("Invalid address")
            InvalidData => f.write("Invalid data")
            TlsError(s) => f.write(format!("TLS error: {}", s))
            Io(s) => f.write(format!("IO error: {}", s))
            Other(s) => f.write(s)
        }
    }
}

/// Quick connect function
fn connect(addr: String) -> Result<TcpConnection, TcpError> {
    TcpConnection.connect(addr)
}

/// Quick connect with timeout
fn connect_timeout(addr: String, timeout_ms: Int64) -> Result<TcpConnection, TcpError> {
    TcpConnection.connect_timeout(addr, timeout_ms)
}

/// Create a TCP server
fn listen(addr: String) -> Result<TcpServer, TcpError> {
    TcpServer.new(addr)
}

// Tests
test "tcp connection" {
    let conn = TcpConnection.connect("127.0.0.1:80")
    // Connection may fail if no server is running
}

test "tcp options" {
    let opts = TcpOptions.default()
        .nodelay(true)
        .keepalive(60000)
        .reuse_addr(true)
    assert(opts.nodelay)?
    assert_eq(opts.keepalive, Some(60000))?
}

test "line protocol" {
    // Would need actual connection for full test
}

test "length prefix protocol" {
    // Would need actual connection for full test
}
