// =============================================================================
// Vibee OS â€” Session Store Module
// Session storage with multiple backends
// =============================================================================

// =============================================================================
// Session Store Configuration
// =============================================================================

struct SessionStoreConfig {
    ttl_ms: Int64
    max_sessions: Option<Int>
    cleanup_interval_ms: Int64
    id_generator: fn() -> String
}

impl SessionStoreConfig {
    fn default() -> Self {
        SessionStoreConfig {
            ttl_ms: 3600000,  // 1 hour
            max_sessions: None,
            cleanup_interval_ms: 60000,
            id_generator: || uuid.v4()
        }
    }
    
    fn with_ttl(ttl_ms: Int64) -> Self { self.ttl_ms = ttl_ms; self }
    fn with_max_sessions(max: Int) -> Self { self.max_sessions = Some(max); self }
}

// =============================================================================
// Session Data
// =============================================================================

struct SessionData {
    id: String
    data: Map<String, SessionValue>
    created_at: Int64
    last_accessed: Int64
    expires_at: Int64
    user_id: Option<String>
    ip_address: Option<String>
    user_agent: Option<String>
}

impl SessionData {
    fn new(id: String, ttl_ms: Int64) -> Self {
        let now = @native("timestamp_ms")
        SessionData {
            id: id,
            data: Map.empty(),
            created_at: now,
            last_accessed: now,
            expires_at: now + ttl_ms,
            user_id: None,
            ip_address: None,
            user_agent: None
        }
    }
    
    fn is_expired() -> Bool { @native("timestamp_ms") >= self.expires_at }
    fn touch(ttl_ms: Int64) {
        let now = @native("timestamp_ms")
        self.last_accessed = now
        self.expires_at = now + ttl_ms
    }
    
    fn get<T: Deserialize>(key: String) -> Option<T> {
        self.data.get(key).and_then(|v| v.as::<T>())
    }
    
    fn set<T: Serialize>(key: String, value: T) {
        self.data.set(key, SessionValue.from(value))
    }
    
    fn remove(key: String) -> Bool { self.data.remove(key).is_some() }
    fn clear() { self.data.clear() }
    fn keys() -> [String] { self.data.keys().collect() }
}

enum SessionValue {
    Null
    Bool(Bool)
    Int(Int64)
    Float(Float64)
    String(String)
    Array([SessionValue])
    Object(Map<String, SessionValue>)
}

impl SessionValue {
    fn from<T: Serialize>(value: T) -> Self { @native("session_value_from", value) }
    fn as<T: Deserialize>() -> Option<T> { @native("session_value_as", self) }
}

// =============================================================================
// Session Store Error
// =============================================================================

enum SessionStoreError {
    NotFound
    Expired
    Full
    InvalidId
    BackendError(String)
}

impl Display for SessionStoreError {
    fn fmt(f: Formatter) {
        match self {
            .NotFound => f.write("Session not found")
            .Expired => f.write("Session expired")
            .Full => f.write("Session store full")
            .InvalidId => f.write("Invalid session ID")
            .BackendError(msg) => f.write("Backend error: \(msg)")
        }
    }
}

// =============================================================================
// Memory Session Store
// =============================================================================

actor MemorySessionStore {
    state config: SessionStoreConfig
    state sessions: Map<String, SessionData>
    
    init(config: SessionStoreConfig) {
        self.config = config
        self.sessions = Map.empty()
    }
    
    on create() -> Result<SessionData, SessionStoreError> {
        if let Some(max) = self.config.max_sessions {
            if self.sessions.len() >= max {
                return Err(SessionStoreError.Full)
            }
        }
        let id = (self.config.id_generator)()
        let session = SessionData.new(id.clone(), self.config.ttl_ms)
        self.sessions.set(id, session.clone())
        Ok(session)
    }
    
    on get(id: String) -> Result<SessionData, SessionStoreError> {
        match self.sessions.get_mut(id) {
            Some(session) if !session.is_expired() => {
                session.touch(self.config.ttl_ms)
                Ok(session.clone())
            }
            Some(_) => {
                self.sessions.remove(id)
                Err(SessionStoreError.Expired)
            }
            None => Err(SessionStoreError.NotFound)
        }
    }
    
    on save(session: SessionData) -> Result<(), SessionStoreError> {
        self.sessions.set(session.id.clone(), session)
        Ok(())
    }
    
    on destroy(id: String) -> Result<(), SessionStoreError> {
        self.sessions.remove(id)
        Ok(())
    }
    
    on exists(id: String) -> Bool {
        self.sessions.get(id).map(|s| !s.is_expired()).unwrap_or(false)
    }
    
    on touch(id: String) -> Result<(), SessionStoreError> {
        match self.sessions.get_mut(id) {
            Some(session) if !session.is_expired() => {
                session.touch(self.config.ttl_ms)
                Ok(())
            }
            _ => Err(SessionStoreError.NotFound)
        }
    }
    
    on cleanup() -> Int {
        let expired: [String] = self.sessions.iter()
            .filter(|(_, s)| s.is_expired())
            .map(|(id, _)| id.clone())
            .collect()
        let count = expired.len()
        for id in expired { self.sessions.remove(id) }
        count
    }
    
    on count() -> Int { self.sessions.len() }
    on active_count() -> Int {
        self.sessions.iter().filter(|(_, s)| !s.is_expired()).count()
    }
}

// =============================================================================
// Redis Session Store
// =============================================================================

actor RedisSessionStore {
    state config: SessionStoreConfig
    state redis: RedisConnection
    state prefix: String
    
    init(config: SessionStoreConfig, redis: RedisConnection) {
        self.config = config
        self.redis = redis
        self.prefix = "session:"
    }
    
    fn key(id: String) -> String { "\(self.prefix)\(id)" }
    
    on create() -> Result<SessionData, SessionStoreError> {
        let id = (self.config.id_generator)()
        let session = SessionData.new(id.clone(), self.config.ttl_ms)
        let data = json.encode(session)
        self.redis.setex(self.key(id), self.config.ttl_ms / 1000, data)
            .map_err(|e| SessionStoreError.BackendError(e.to_string()))?
        Ok(session)
    }
    
    on get(id: String) -> Result<SessionData, SessionStoreError> {
        match self.redis.get(self.key(id.clone())) {
            Ok(Some(data)) => {
                let mut session: SessionData = json.decode(data)
                    .map_err(|e| SessionStoreError.BackendError(e.to_string()))?
                session.touch(self.config.ttl_ms)
                self.save(session.clone())?
                Ok(session)
            }
            Ok(None) => Err(SessionStoreError.NotFound)
            Err(e) => Err(SessionStoreError.BackendError(e.to_string()))
        }
    }
    
    on save(session: SessionData) -> Result<(), SessionStoreError> {
        let data = json.encode(session)
        let ttl_sec = (session.expires_at - @native("timestamp_ms")) / 1000
        self.redis.setex(self.key(session.id), ttl_sec, data)
            .map_err(|e| SessionStoreError.BackendError(e.to_string()))
    }
    
    on destroy(id: String) -> Result<(), SessionStoreError> {
        self.redis.del(self.key(id))
            .map_err(|e| SessionStoreError.BackendError(e.to_string()))?
        Ok(())
    }
    
    on exists(id: String) -> Bool {
        self.redis.exists(self.key(id)).unwrap_or(false)
    }
}

// =============================================================================
// Session Manager
// =============================================================================

actor SessionManager<S: SessionStore> {
    state store: S
    state config: SessionStoreConfig
    
    init(store: S, config: SessionStoreConfig) {
        self.store = store
        self.config = config
    }
    
    on start(session: SessionData) -> Result<SessionData, SessionStoreError> {
        self.store.create()
    }
    
    on get(id: String) -> Result<SessionData, SessionStoreError> {
        self.store.get(id)
    }
    
    on end(id: String) -> Result<(), SessionStoreError> {
        self.store.destroy(id)
    }
    
    on regenerate(id: String) -> Result<SessionData, SessionStoreError> {
        let old = self.store.get(id.clone())?
        self.store.destroy(id)?
        let mut new_session = self.store.create()?
        new_session.data = old.data
        new_session.user_id = old.user_id
        self.store.save(new_session.clone())?
        Ok(new_session)
    }
}

// =============================================================================
// Session Store Trait
// =============================================================================

trait SessionStore {
    fn create() -> Result<SessionData, SessionStoreError>
    fn get(id: String) -> Result<SessionData, SessionStoreError>
    fn save(session: SessionData) -> Result<(), SessionStoreError>
    fn destroy(id: String) -> Result<(), SessionStoreError>
    fn exists(id: String) -> Bool
}

impl SessionStore for MemorySessionStore {
    fn create() -> Result<SessionData, SessionStoreError> { self.create() }
    fn get(id: String) -> Result<SessionData, SessionStoreError> { self.get(id) }
    fn save(session: SessionData) -> Result<(), SessionStoreError> { self.save(session) }
    fn destroy(id: String) -> Result<(), SessionStoreError> { self.destroy(id) }
    fn exists(id: String) -> Bool { self.exists(id) }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn memory() -> MemorySessionStore {
    MemorySessionStore.new(SessionStoreConfig.default())
}

fn memory_with_config(config: SessionStoreConfig) -> MemorySessionStore {
    MemorySessionStore.new(config)
}

// =============================================================================
// Tests
// =============================================================================

test "memory session store" {
    let store = memory()
    let session = store.create()?
    assert(!session.id.is_empty())?
    
    let retrieved = store.get(session.id.clone())?
    assert_eq(retrieved.id, session.id)?
    
    store.destroy(session.id.clone())?
    assert(!store.exists(session.id))?
}

test "session data operations" {
    let store = memory()
    var session = store.create()?
    
    session.set("user", "john")
    session.set("count", 42)
    store.save(session.clone())?
    
    let loaded = store.get(session.id)?
    assert_eq(loaded.get::<String>("user"), Some("john"))?
    assert_eq(loaded.get::<Int>("count"), Some(42))?
}
