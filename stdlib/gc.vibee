// =============================================================================
// Vibee OS â€” Garbage Collector Module
// Automatic memory management and garbage collection
// =============================================================================

// -----------------------------------------------------------------------------
// GC Configuration
// -----------------------------------------------------------------------------

/// GC configuration
struct GCConfig {
    heap_size: Int
    threshold: Int
    generation_sizes: [Int]
    concurrent: Bool
    incremental: Bool
    pause_target_ms: Int
    
    fn default() -> Self {
        GCConfig {
            heap_size: 256 * 1024 * 1024,  // 256 MB
            threshold: 1024 * 1024,         // 1 MB
            generation_sizes: [2 * 1024 * 1024, 16 * 1024 * 1024, 128 * 1024 * 1024],
            concurrent: true,
            incremental: true,
            pause_target_ms: 10
        }
    }
    
    fn low_latency() -> Self {
        GCConfig {
            heap_size: 512 * 1024 * 1024,
            threshold: 512 * 1024,
            generation_sizes: [1 * 1024 * 1024, 8 * 1024 * 1024, 64 * 1024 * 1024],
            concurrent: true,
            incremental: true,
            pause_target_ms: 1
        }
    }
    
    fn high_throughput() -> Self {
        GCConfig {
            heap_size: 1024 * 1024 * 1024,
            threshold: 4 * 1024 * 1024,
            generation_sizes: [8 * 1024 * 1024, 64 * 1024 * 1024, 512 * 1024 * 1024],
            concurrent: false,
            incremental: false,
            pause_target_ms: 100
        }
    }
}

/// GC algorithm type
enum GCAlgorithm {
    MarkSweep
    MarkCompact
    Copying
    Generational
    Concurrent
    Incremental
    Reference
}

// -----------------------------------------------------------------------------
// GC Statistics
// -----------------------------------------------------------------------------

/// GC statistics
struct GCStats {
    collections: Int
    total_collected: Int
    total_time_ns: Int
    last_pause_ns: Int
    max_pause_ns: Int
    avg_pause_ns: Int
    heap_used: Int
    heap_total: Int
    generation_stats: [GenerationStats]
    
    fn utilization() -> Float {
        (self.heap_used as Float / self.heap_total as Float) * 100.0
    }
    
    fn avg_collection_time() -> Duration {
        if self.collections == 0 { Duration.zero() }
        else { Duration.nanos(self.total_time_ns / self.collections) }
    }
    
    fn print() {
        println("=== GC Statistics ===")
        println("Collections:     \(self.collections)")
        println("Total collected: \(format_bytes(self.total_collected))")
        println("Total GC time:   \(Duration.nanos(self.total_time_ns))")
        println("Last pause:      \(Duration.nanos(self.last_pause_ns))")
        println("Max pause:       \(Duration.nanos(self.max_pause_ns))")
        println("Avg pause:       \(Duration.nanos(self.avg_pause_ns))")
        println("Heap used:       \(format_bytes(self.heap_used))")
        println("Heap total:      \(format_bytes(self.heap_total))")
        println("Utilization:     \(self.utilization().round(2))%")
        println("=====================")
    }
}

struct GenerationStats {
    generation: Int
    collections: Int
    objects: Int
    bytes_used: Int
    bytes_total: Int
    promotion_rate: Float
}

// -----------------------------------------------------------------------------
// GC Controller
// -----------------------------------------------------------------------------

/// Main GC controller
actor GC {
    state config: GCConfig
    state stats: GCStats
    state enabled: Bool
    state roots: [GCRoot]
    state generations: [Generation]
    state finalizers: [(Any) -> ()]
    state weak_refs: [WeakRef<Any>]
    
    fn new() -> Self {
        Self.with_config(GCConfig.default())
    }
    
    fn with_config(config: GCConfig) -> Self {
        let gc = GC {
            config: config,
            stats: GCStats {
                collections: 0,
                total_collected: 0,
                total_time_ns: 0,
                last_pause_ns: 0,
                max_pause_ns: 0,
                avg_pause_ns: 0,
                heap_used: 0,
                heap_total: config.heap_size,
                generation_stats: []
            },
            enabled: true,
            roots: [],
            generations: [],
            finalizers: [],
            weak_refs: []
        }
        
        // Initialize generations
        for (i, size) in config.generation_sizes.enumerate() {
            gc.generations.push(Generation.new(i, size))
        }
        
        gc
    }
    
    /// Trigger garbage collection
    on collect() -> GCResult {
        if !self.enabled { return GCResult.disabled() }
        
        let start = Instant.now()
        var collected = 0
        
        // Mark phase
        self.mark_roots()
        
        // Sweep phase
        for gen in self.generations {
            collected += gen.sweep()
        }
        
        // Run finalizers
        self.run_finalizers()
        
        // Clear dead weak references
        self.clear_weak_refs()
        
        let elapsed = start.elapsed()
        self.update_stats(collected, elapsed)
        
        GCResult {
            collected: collected,
            duration: elapsed,
            generation: -1
        }
    }
    
    /// Collect specific generation
    on collect_generation(gen: Int) -> GCResult {
        if !self.enabled { return GCResult.disabled() }
        if gen >= self.generations.len() { return GCResult.error("Invalid generation") }
        
        let start = Instant.now()
        
        self.mark_roots()
        let collected = self.generations[gen].sweep()
        
        // Promote survivors to next generation
        if gen + 1 < self.generations.len() {
            self.generations[gen].promote_to(self.generations[gen + 1])
        }
        
        let elapsed = start.elapsed()
        self.update_stats(collected, elapsed)
        
        GCResult {
            collected: collected,
            duration: elapsed,
            generation: gen
        }
    }
    
    /// Minor collection (young generation only)
    on minor_collect() -> GCResult {
        self.collect_generation(0)
    }
    
    /// Major collection (all generations)
    on major_collect() -> GCResult {
        self.collect()
    }
    
    /// Full collection with compaction
    on full_collect() -> GCResult {
        let result = self.collect()
        self.compact()
        result
    }
    
    /// Compact heap
    on compact() {
        for gen in self.generations {
            gen.compact()
        }
    }
    
    fn mark_roots() {
        for root in self.roots {
            self.mark(root.ptr)
        }
        
        // Mark stack roots
        let stack_roots = @native("gc_get_stack_roots")
        for ptr in stack_roots {
            self.mark(ptr)
        }
        
        // Mark global roots
        let global_roots = @native("gc_get_global_roots")
        for ptr in global_roots {
            self.mark(ptr)
        }
    }
    
    fn mark(ptr: *Any) {
        if ptr.is_null() { return }
        
        let header = GCHeader.from_ptr(ptr)
        if header.marked { return }
        
        header.marked = true
        
        // Mark children
        let children = @native("gc_get_children", ptr)
        for child in children {
            self.mark(child)
        }
    }
    
    fn run_finalizers() {
        let dead_objects = @native("gc_get_dead_with_finalizers")
        for obj in dead_objects {
            for finalizer in self.finalizers {
                finalizer(obj)
            }
        }
    }
    
    fn clear_weak_refs() {
        for weak in self.weak_refs {
            if !weak.is_alive() {
                weak.clear()
            }
        }
        self.weak_refs.retain(|w| w.is_alive())
    }
    
    fn update_stats(collected: Int, duration: Duration) {
        self.stats.collections += 1
        self.stats.total_collected += collected
        self.stats.total_time_ns += duration.as_nanos()
        self.stats.last_pause_ns = duration.as_nanos()
        self.stats.max_pause_ns = self.stats.max_pause_ns.max(duration.as_nanos())
        self.stats.avg_pause_ns = self.stats.total_time_ns / self.stats.collections
        self.stats.heap_used = self.calculate_heap_used()
    }
    
    fn calculate_heap_used() -> Int {
        self.generations.iter().map(|g| g.used()).sum()
    }
    
    /// Enable GC
    on enable() { self.enabled = true }
    
    /// Disable GC
    on disable() { self.enabled = false }
    
    /// Check if GC is enabled
    fn is_enabled() -> Bool { self.enabled }
    
    /// Get GC statistics
    fn stats() -> GCStats { self.stats }
    
    /// Add GC root
    on add_root(ptr: *Any) {
        self.roots.push(GCRoot { ptr: ptr })
    }
    
    /// Remove GC root
    on remove_root(ptr: *Any) {
        self.roots.retain(|r| r.ptr != ptr)
    }
    
    /// Register finalizer
    on register_finalizer(f: (Any) -> ()) {
        self.finalizers.push(f)
    }
    
    /// Register weak reference
    on register_weak<T>(weak: WeakRef<T>) {
        self.weak_refs.push(weak as WeakRef<Any>)
    }
    
    /// Set GC threshold
    on set_threshold(bytes: Int) {
        self.config.threshold = bytes
    }
    
    /// Force GC if threshold exceeded
    on check_threshold() {
        if self.stats.heap_used > self.config.threshold {
            self.collect()
        }
    }
}

/// GC root reference
struct GCRoot {
    ptr: *Any
}

/// GC object header
struct GCHeader {
    marked: Bool
    generation: Int
    size: Int
    type_id: Int
    finalizer: Option<(*Any) -> ()>
    
    fn from_ptr(ptr: *Any) -> *GCHeader {
        @native("gc_header_from_ptr", ptr)
    }
}

/// GC result
struct GCResult {
    collected: Int
    duration: Duration
    generation: Int
    error: Option<String>
    
    fn disabled() -> Self {
        GCResult { collected: 0, duration: Duration.zero(), generation: -1, error: Some("GC disabled") }
    }
    
    fn error(msg: String) -> Self {
        GCResult { collected: 0, duration: Duration.zero(), generation: -1, error: Some(msg) }
    }
    
    fn is_ok() -> Bool { self.error.is_none() }
}

// -----------------------------------------------------------------------------
// Generations
// -----------------------------------------------------------------------------

/// Generation in generational GC
actor Generation {
    state id: Int
    state capacity: Int
    state objects: [*Any]
    state used_bytes: Int
    state collections: Int
    state promotions: Int
    
    fn new(id: Int, capacity: Int) -> Self {
        Generation {
            id: id,
            capacity: capacity,
            objects: [],
            used_bytes: 0,
            collections: 0,
            promotions: 0
        }
    }
    
    fn used() -> Int { self.used_bytes }
    fn available() -> Int { self.capacity - self.used_bytes }
    fn object_count() -> Int { self.objects.len() }
    
    /// Allocate in this generation
    on allocate(size: Int) -> Option<*Any> {
        if self.used_bytes + size > self.capacity {
            return None
        }
        
        let ptr = @native("gc_allocate", size, self.id)
        if !ptr.is_null() {
            self.objects.push(ptr)
            self.used_bytes += size
        }
        
        if ptr.is_null() { None } else { Some(ptr) }
    }
    
    /// Sweep dead objects
    on sweep() -> Int {
        self.collections += 1
        var collected = 0
        var new_objects = []
        
        for ptr in self.objects {
            let header = GCHeader.from_ptr(ptr)
            if (*header).marked {
                (*header).marked = false
                new_objects.push(ptr)
            } else {
                collected += (*header).size
                self.used_bytes -= (*header).size
                @native("gc_free", ptr)
            }
        }
        
        self.objects = new_objects
        collected
    }
    
    /// Promote survivors to next generation
    on promote_to(next: Generation) {
        var to_promote = []
        
        for ptr in self.objects {
            let header = GCHeader.from_ptr(ptr)
            if (*header).generation == self.id {
                // Object survived, promote it
                (*header).generation = next.id
                to_promote.push(ptr)
                self.promotions += 1
            }
        }
        
        for ptr in to_promote {
            self.objects.retain(|p| p != ptr)
            let header = GCHeader.from_ptr(ptr)
            self.used_bytes -= (*header).size
            next.objects.push(ptr)
            next.used_bytes += (*header).size
        }
    }
    
    /// Compact generation
    on compact() {
        @native("gc_compact_generation", self.id)
    }
}

// -----------------------------------------------------------------------------
// Weak References
// -----------------------------------------------------------------------------

/// Weak reference that doesn't prevent GC
struct WeakRef<T> {
    ptr: *T
    id: Int
    
    fn new(value: T) -> Self {
        let ptr = @native("gc_weak_ref_create", value)
        let id = @native("gc_weak_ref_id", ptr)
        WeakRef { ptr: ptr, id: id }
    }
    
    fn get() -> Option<T> {
        if self.is_alive() {
            Some(*self.ptr)
        } else {
            None
        }
    }
    
    fn is_alive() -> Bool {
        @native("gc_weak_ref_is_alive", self.id)
    }
    
    fn clear() {
        @native("gc_weak_ref_clear", self.id)
        self.ptr = null()
    }
    
    fn upgrade() -> Option<Rc<T>> {
        if self.is_alive() {
            Some(Rc.from_raw(self.ptr))
        } else {
            None
        }
    }
}

// -----------------------------------------------------------------------------
// Reference Counting
// -----------------------------------------------------------------------------

/// Reference counted pointer
struct Rc<T> {
    ptr: *RcInner<T>
    
    fn new(value: T) -> Self {
        let inner = Box.new(RcInner { value: value, count: 1 })
        Rc { ptr: inner.into_raw() }
    }
    
    fn from_raw(ptr: *T) -> Self {
        Rc { ptr: ptr as *RcInner<T> }
    }
    
    fn get() -> T { (*self.ptr).value }
    fn get_ref() -> &T { &(*self.ptr).value }
    fn get_mut() -> &mut T { &mut (*self.ptr).value }
    
    fn strong_count() -> Int { (*self.ptr).count }
    
    fn clone() -> Self {
        (*self.ptr).count += 1
        Rc { ptr: self.ptr }
    }
    
    fn downgrade() -> WeakRef<T> {
        WeakRef.new(self.get())
    }
}

impl<T> Drop for Rc<T> {
    fn drop() {
        (*self.ptr).count -= 1
        if (*self.ptr).count == 0 {
            drop(Box.from_raw(self.ptr))
        }
    }
}

struct RcInner<T> {
    value: T
    count: Int
}

/// Atomic reference counted pointer
struct Arc<T> {
    ptr: *ArcInner<T>
    
    fn new(value: T) -> Self {
        let inner = Box.new(ArcInner { value: value, count: AtomicInt.new(1) })
        Arc { ptr: inner.into_raw() }
    }
    
    fn get() -> T { (*self.ptr).value }
    fn get_ref() -> &T { &(*self.ptr).value }
    
    fn strong_count() -> Int { (*self.ptr).count.load() }
    
    fn clone() -> Self {
        (*self.ptr).count.increment()
        Arc { ptr: self.ptr }
    }
}

impl<T> Drop for Arc<T> {
    fn drop() {
        if (*self.ptr).count.decrement() == 0 {
            drop(Box.from_raw(self.ptr))
        }
    }
}

struct ArcInner<T> {
    value: T
    count: AtomicInt
}

// -----------------------------------------------------------------------------
// Finalizers
// -----------------------------------------------------------------------------

/// Object with custom finalizer
trait Finalizable {
    fn finalize()
}

/// Register finalizer for object
fn register_finalizer<T: Finalizable>(obj: T) {
    GC.global().register_finalizer(|o| {
        if let Some(t) = o.downcast::<T>() {
            t.finalize()
        }
    })
}

/// Guard that runs cleanup on drop
struct DropGuard<T> {
    value: T
    cleanup: (T) -> ()
    
    fn new(value: T, cleanup: (T) -> ()) -> Self {
        DropGuard { value: value, cleanup: cleanup }
    }
}

impl<T> Drop for DropGuard<T> {
    fn drop() {
        (self.cleanup)(self.value)
    }
}

// -----------------------------------------------------------------------------
// GC Barriers
// -----------------------------------------------------------------------------

/// Write barrier for generational GC
fn write_barrier<T>(obj: *T, field: *Any, new_value: *Any) {
    let obj_gen = GCHeader.from_ptr(obj as *Any).generation
    let val_gen = GCHeader.from_ptr(new_value).generation
    
    // If writing young pointer to old object, add to remembered set
    if val_gen < obj_gen {
        @native("gc_remember", obj)
    }
    
    *field = new_value
}

/// Read barrier for concurrent GC
fn read_barrier<T>(ptr: *T) -> *T {
    @native("gc_read_barrier", ptr)
}

// -----------------------------------------------------------------------------
// Global GC Instance
// -----------------------------------------------------------------------------

var GLOBAL_GC: Option<GC> = None

impl GC {
    fn global() -> GC {
        if GLOBAL_GC.is_none() {
            GLOBAL_GC = Some(GC.new())
        }
        GLOBAL_GC.unwrap()
    }
    
    fn init(config: GCConfig) {
        GLOBAL_GC = Some(GC.with_config(config))
    }
}

/// Convenience functions
fn gc_collect() -> GCResult { GC.global().collect() }
fn gc_stats() -> GCStats { GC.global().stats() }
fn gc_enable() { GC.global().enable() }
fn gc_disable() { GC.global().disable() }

// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

fn format_bytes(bytes: Int) -> String {
    if bytes < 1024 { "\(bytes) B" }
    else if bytes < 1024 * 1024 { "\((bytes as Float / 1024.0).round(2)) KB" }
    else if bytes < 1024 * 1024 * 1024 { "\((bytes as Float / (1024.0 * 1024.0)).round(2)) MB" }
    else { "\((bytes as Float / (1024.0 * 1024.0 * 1024.0)).round(2)) GB" }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "gc collect" {
    let gc = GC.new()
    let result = gc.collect()
    assert(result.is_ok())?
}

test "weak ref" {
    let value = 42
    let weak = WeakRef.new(value)
    assert(weak.is_alive())?
    assert_eq(weak.get(), Some(42))?
}

test "rc" {
    let rc1 = Rc.new(42)
    assert_eq(rc1.strong_count(), 1)?
    
    let rc2 = rc1.clone()
    assert_eq(rc1.strong_count(), 2)?
    assert_eq(rc2.get(), 42)?
}

test "arc" {
    let arc1 = Arc.new("hello")
    let arc2 = arc1.clone()
    
    assert_eq(arc1.strong_count(), 2)?
    assert_eq(arc2.get(), "hello")?
}

test "gc stats" {
    let gc = GC.new()
    gc.collect()
    
    let stats = gc.stats()
    assert(stats.collections >= 1)?
}
