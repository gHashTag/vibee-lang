// =============================================================================
// Vibee OS — Percent Encoding Module
// URL percent-encoding (RFC 3986)
// =============================================================================

// -----------------------------------------------------------------------------
// Character Sets
// -----------------------------------------------------------------------------

/// Unreserved characters (RFC 3986)
/// ALPHA / DIGIT / "-" / "." / "_" / "~"
const UNRESERVED: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"

/// General delimiters (RFC 3986)
const GEN_DELIMS: String = ":/?#[]@"

/// Sub-delimiters (RFC 3986)
const SUB_DELIMS: String = "!$&'()*+,;="

/// Reserved characters
const RESERVED: String = ":/?#[]@!$&'()*+,;="

/// Path characters (unreserved + sub-delims + : + @)
const PATH_CHARS: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&'()*+,;=:@"

/// Query characters (path + / + ?)
const QUERY_CHARS: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&'()*+,;=:@/?"

/// Fragment characters (same as query)
const FRAGMENT_CHARS: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&'()*+,;=:@/?"

/// Form URL encoding safe characters
const FORM_SAFE: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._*"

// -----------------------------------------------------------------------------
// Encoding Configuration
// -----------------------------------------------------------------------------

/// Encoding configuration
struct EncodeConfig {
    safe_chars: String
    space_as_plus: Bool
    uppercase: Bool
    
    fn default() -> Self {
        EncodeConfig {
            safe_chars: UNRESERVED,
            space_as_plus: false,
            uppercase: true
        }
    }
    
    fn path() -> Self {
        EncodeConfig {
            safe_chars: PATH_CHARS,
            space_as_plus: false,
            uppercase: true
        }
    }
    
    fn query() -> Self {
        EncodeConfig {
            safe_chars: QUERY_CHARS,
            space_as_plus: false,
            uppercase: true
        }
    }
    
    fn query_component() -> Self {
        EncodeConfig {
            safe_chars: UNRESERVED,
            space_as_plus: false,
            uppercase: true
        }
    }
    
    fn form() -> Self {
        EncodeConfig {
            safe_chars: FORM_SAFE,
            space_as_plus: true,
            uppercase: true
        }
    }
    
    fn fragment() -> Self {
        EncodeConfig {
            safe_chars: FRAGMENT_CHARS,
            space_as_plus: false,
            uppercase: true
        }
    }
}

// -----------------------------------------------------------------------------
// Encoding
// -----------------------------------------------------------------------------

/// Percent-encode string with default config (unreserved chars safe)
fn encode(s: String) -> String {
    encode_with(s, EncodeConfig.default())
}

/// Percent-encode with custom configuration
fn encode_with(s: String, config: EncodeConfig) -> String {
    var result = ""
    
    for c in s.chars() {
        if c == ' ' && config.space_as_plus {
            result.push('+')
        } else if config.safe_chars.contains(c) {
            result.push(c)
        } else {
            // Encode each byte of UTF-8 representation
            for b in c.to_string().as_bytes() {
                if config.uppercase {
                    result.push_str(format!("%{:02X}", b))
                } else {
                    result.push_str(format!("%{:02x}", b))
                }
            }
        }
    }
    
    result
}

/// Encode bytes directly
fn encode_bytes(bytes: [UInt8]) -> String {
    encode_bytes_with(bytes, EncodeConfig.default())
}

/// Encode bytes with configuration
fn encode_bytes_with(bytes: [UInt8], config: EncodeConfig) -> String {
    var result = ""
    
    for b in bytes {
        let c = b as Char
        if b < 128 && config.safe_chars.contains(c) {
            result.push(c)
        } else {
            if config.uppercase {
                result.push_str(format!("%{:02X}", b))
            } else {
                result.push_str(format!("%{:02x}", b))
            }
        }
    }
    
    result
}

// -----------------------------------------------------------------------------
// Specialized Encoders
// -----------------------------------------------------------------------------

/// Encode URI component (strict encoding)
fn encode_component(s: String) -> String {
    encode_with(s, EncodeConfig.default())
}

/// Encode path segment
fn encode_path(s: String) -> String {
    encode_with(s, EncodeConfig.path())
}

/// Encode path segment (strict - encodes slashes)
fn encode_path_segment(s: String) -> String {
    encode_with(s, EncodeConfig.default())
}

/// Encode query string (preserves & and =)
fn encode_query(s: String) -> String {
    encode_with(s, EncodeConfig.query())
}

/// Encode query key or value
fn encode_query_component(s: String) -> String {
    encode_with(s, EncodeConfig.query_component())
}

/// Encode for application/x-www-form-urlencoded
fn encode_form(s: String) -> String {
    encode_with(s, EncodeConfig.form())
}

/// Encode fragment
fn encode_fragment(s: String) -> String {
    encode_with(s, EncodeConfig.fragment())
}

/// Encode user info (username or password)
fn encode_userinfo(s: String) -> String {
    var config = EncodeConfig.default()
    config.safe_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&'()*+,;="
    encode_with(s, config)
}

// -----------------------------------------------------------------------------
// Decoding
// -----------------------------------------------------------------------------

/// Decode percent-encoded string
fn decode(s: String) -> Result<String, PercentError> {
    let bytes = decode_bytes(s)?
    String.from_utf8(bytes).map_err(|_| PercentError.InvalidUtf8)
}

/// Decode percent-encoded string, replacing invalid UTF-8
fn decode_lossy(s: String) -> String {
    match decode_bytes(s) {
        Ok(bytes) => String.from_utf8_lossy(bytes),
        Err(_) => s
    }
}

/// Decode to bytes
fn decode_bytes(s: String) -> Result<[UInt8], PercentError> {
    var result = []
    var chars = s.chars().peekable()
    
    while let Some(c) = chars.next() {
        if c == '%' {
            let h1 = chars.next().ok_or(PercentError.IncompleteSequence)?
            let h2 = chars.next().ok_or(PercentError.IncompleteSequence)?
            
            let hex = format!("{}{}", h1, h2)
            let byte = UInt8.parse_hex(hex).map_err(|_| PercentError.InvalidHex(hex))?
            result.push(byte)
        } else if c == '+' {
            // Plus can mean space in form encoding
            result.push(' ' as UInt8)
        } else {
            // Regular character - encode as UTF-8
            for b in c.to_string().as_bytes() {
                result.push(b)
            }
        }
    }
    
    Ok(result)
}

/// Decode without converting + to space
fn decode_strict(s: String) -> Result<String, PercentError> {
    var result = []
    var chars = s.chars().peekable()
    
    while let Some(c) = chars.next() {
        if c == '%' {
            let h1 = chars.next().ok_or(PercentError.IncompleteSequence)?
            let h2 = chars.next().ok_or(PercentError.IncompleteSequence)?
            
            let hex = format!("{}{}", h1, h2)
            let byte = UInt8.parse_hex(hex).map_err(|_| PercentError.InvalidHex(hex))?
            result.push(byte)
        } else {
            for b in c.to_string().as_bytes() {
                result.push(b)
            }
        }
    }
    
    String.from_utf8(result).map_err(|_| PercentError.InvalidUtf8)
}

// -----------------------------------------------------------------------------
// Query String Utilities
// -----------------------------------------------------------------------------

/// Parse query string to map
fn parse_query(s: String) -> Result<Map<String, String>, PercentError> {
    var params = Map.empty()
    
    // Remove leading ?
    let s = if s.starts_with("?") { s[1..] } else { s }
    
    if s.is_empty() {
        return Ok(params)
    }
    
    for pair in s.split("&") {
        if pair.is_empty() { continue }
        
        match pair.find("=") {
            Some(idx) => {
                let key = decode(pair[0..idx])?
                let value = decode(pair[(idx + 1)..])?
                params.set(key, value)
            }
            None => {
                let key = decode(pair)?
                params.set(key, "")
            }
        }
    }
    
    Ok(params)
}

/// Parse query string to list (preserves duplicates and order)
fn parse_query_list(s: String) -> Result<[(String, String)], PercentError> {
    var params = []
    
    let s = if s.starts_with("?") { s[1..] } else { s }
    
    if s.is_empty() {
        return Ok(params)
    }
    
    for pair in s.split("&") {
        if pair.is_empty() { continue }
        
        match pair.find("=") {
            Some(idx) => {
                let key = decode(pair[0..idx])?
                let value = decode(pair[(idx + 1)..])?
                params.push((key, value))
            }
            None => {
                let key = decode(pair)?
                params.push((key, ""))
            }
        }
    }
    
    Ok(params)
}

/// Build query string from map
fn build_query(params: Map<String, String>) -> String {
    params.iter()
        .map(|(k, v)| format!("{}={}", encode_query_component(k), encode_query_component(v)))
        .join("&")
}

/// Build query string from list
fn build_query_list(params: [(String, String)]) -> String {
    params.iter()
        .map(|(k, v)| format!("{}={}", encode_query_component(k), encode_query_component(v)))
        .join("&")
}

// -----------------------------------------------------------------------------
// Form Data
// -----------------------------------------------------------------------------

/// Parse application/x-www-form-urlencoded data
fn parse_form(s: String) -> Result<Map<String, String>, PercentError> {
    var params = Map.empty()
    
    for pair in s.split("&") {
        if pair.is_empty() { continue }
        
        match pair.find("=") {
            Some(idx) => {
                let key = decode(pair[0..idx])?
                let value = decode(pair[(idx + 1)..])?
                params.set(key, value)
            }
            None => {
                let key = decode(pair)?
                params.set(key, "")
            }
        }
    }
    
    Ok(params)
}

/// Build application/x-www-form-urlencoded data
fn build_form(params: Map<String, String>) -> String {
    params.iter()
        .map(|(k, v)| format!("{}={}", encode_form(k), encode_form(v)))
        .join("&")
}

// -----------------------------------------------------------------------------
// URL Utilities
// -----------------------------------------------------------------------------

/// Encode full URL (only encodes unsafe characters)
fn encode_url(url: String) -> String {
    var result = ""
    var in_query = false
    var in_fragment = false
    
    for c in url.chars() {
        if c == '?' {
            in_query = true
            result.push(c)
        } else if c == '#' {
            in_fragment = true
            result.push(c)
        } else if in_fragment {
            if FRAGMENT_CHARS.contains(c) {
                result.push(c)
            } else {
                result.push_str(encode_char(c))
            }
        } else if in_query {
            if QUERY_CHARS.contains(c) {
                result.push(c)
            } else {
                result.push_str(encode_char(c))
            }
        } else {
            if PATH_CHARS.contains(c) || c == '/' {
                result.push(c)
            } else {
                result.push_str(encode_char(c))
            }
        }
    }
    
    result
}

fn encode_char(c: Char) -> String {
    var result = ""
    for b in c.to_string().as_bytes() {
        result.push_str(format!("%{:02X}", b))
    }
    result
}

/// Normalize URL encoding (decode safe chars, uppercase hex)
fn normalize(s: String) -> String {
    var result = ""
    var chars = s.chars().peekable()
    
    while let Some(c) = chars.next() {
        if c == '%' {
            let h1 = chars.next().unwrap_or('0')
            let h2 = chars.next().unwrap_or('0')
            
            let hex = format!("{}{}", h1, h2)
            if let Ok(byte) = UInt8.parse_hex(hex) {
                let decoded = byte as Char
                if UNRESERVED.contains(decoded) {
                    result.push(decoded)
                } else {
                    result.push_str(format!("%{:02X}", byte))
                }
            } else {
                result.push('%')
                result.push(h1)
                result.push(h2)
            }
        } else {
            result.push(c)
        }
    }
    
    result
}

// -----------------------------------------------------------------------------
// Validation
// -----------------------------------------------------------------------------

/// Check if string is properly percent-encoded
fn is_valid(s: String) -> Bool {
    var chars = s.chars().peekable()
    
    while let Some(c) = chars.next() {
        if c == '%' {
            let h1 = match chars.next() {
                Some(c) if c.is_ascii_hexdigit() => c,
                _ => return false
            }
            let h2 = match chars.next() {
                Some(c) if c.is_ascii_hexdigit() => c,
                _ => return false
            }
        }
    }
    
    true
}

/// Check if string needs encoding
fn needs_encoding(s: String) -> Bool {
    s.chars().any(|c| !UNRESERVED.contains(c))
}

/// Check if string needs encoding for path
fn needs_path_encoding(s: String) -> Bool {
    s.chars().any(|c| !PATH_CHARS.contains(c) && c != '/')
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum PercentError {
    IncompleteSequence
    InvalidHex(String)
    InvalidUtf8
}

impl Display for PercentError {
    fn fmt(f: Formatter) {
        match self {
            IncompleteSequence => f.write("Incomplete percent-encoding sequence")
            InvalidHex(s) => f.write(format!("Invalid hex in percent-encoding: {}", s))
            InvalidUtf8 => f.write("Invalid UTF-8 in decoded data")
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "encode basic" {
    assert_eq(encode("hello world"), "hello%20world")?
    assert_eq(encode("foo=bar"), "foo%3Dbar")?
}

test "encode unicode" {
    assert_eq(encode("日本"), "%E6%97%A5%E6%9C%AC")?
    assert_eq(encode("café"), "caf%C3%A9")?
}

test "encode unreserved" {
    // Unreserved characters should not be encoded
    assert_eq(encode("abc-._~"), "abc-._~")?
}

test "decode basic" {
    assert_eq(decode("hello%20world")?, "hello world")?
    assert_eq(decode("foo%3Dbar")?, "foo=bar")?
}

test "decode unicode" {
    assert_eq(decode("%E6%97%A5%E6%9C%AC")?, "日本")?
}

test "decode plus" {
    assert_eq(decode("hello+world")?, "hello world")?
}

test "decode strict" {
    assert_eq(decode_strict("hello+world")?, "hello+world")?
}

test "roundtrip" {
    let original = "Hello, 世界! foo=bar&baz=qux"
    let encoded = encode(original)
    let decoded = decode(encoded)?
    assert_eq(decoded, original)?
}

test "encode_component" {
    assert_eq(encode_component("foo/bar"), "foo%2Fbar")?
}

test "encode_path" {
    // Path encoding preserves /
    assert_eq(encode_path("foo/bar"), "foo/bar")?
    assert_eq(encode_path("foo bar"), "foo%20bar")?
}

test "encode_form" {
    // Form encoding uses + for space
    assert_eq(encode_form("hello world"), "hello+world")?
}

test "parse_query" {
    let params = parse_query("foo=bar&baz=qux")?
    assert_eq(params.get("foo"), Some("bar"))?
    assert_eq(params.get("baz"), Some("qux"))?
}

test "parse_query_encoded" {
    let params = parse_query("name=John%20Doe&city=New%20York")?
    assert_eq(params.get("name"), Some("John Doe"))?
    assert_eq(params.get("city"), Some("New York"))?
}

test "build_query" {
    var params = Map.empty()
    params.set("foo", "bar")
    params.set("baz", "hello world")
    
    let query = build_query(params)
    assert(query.contains("foo=bar"))?
    assert(query.contains("baz=hello%20world"))?
}

test "parse_form" {
    let params = parse_form("name=John+Doe&city=New+York")?
    assert_eq(params.get("name"), Some("John Doe"))?
}

test "build_form" {
    var params = Map.empty()
    params.set("name", "John Doe")
    
    let form = build_form(params)
    assert_eq(form, "name=John+Doe")?
}

test "is_valid" {
    assert(is_valid("hello%20world"))?
    assert(is_valid("foo"))?
    assert(!is_valid("hello%2"))?   // Incomplete
    assert(!is_valid("hello%GG"))?  // Invalid hex
}

test "needs_encoding" {
    assert(needs_encoding("hello world"))?
    assert(needs_encoding("foo=bar"))?
    assert(!needs_encoding("hello"))?
    assert(!needs_encoding("foo-bar_baz.qux~"))?
}

test "normalize" {
    // Uppercase hex digits
    assert_eq(normalize("hello%2f"), "hello%2F")?
    // Decode unreserved
    assert_eq(normalize("%41%42%43"), "ABC")?
}

test "encode_url" {
    let url = "https://example.com/path with spaces?q=hello world#section"
    let encoded = encode_url(url)
    assert(encoded.contains("/path%20with%20spaces"))?
    assert(encoded.contains("q=hello%20world"))?
}
