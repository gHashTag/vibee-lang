// =============================================================================
// Vibee OS â€” User Profile Module
// User profiles, settings, and social identity management
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Profile Visibility
// =============================================================================

/// Profile visibility settings
enum ProfileVisibility {
    Public,
    FriendsOnly,
    Private,
    Custom([String])
}

impl ProfileVisibility {
    fn is_public() -> Bool {
        match self {
            ProfileVisibility.Public => true,
            _ => false
        }
    }
    
    fn can_view(viewer_id: String, is_friend: Bool) -> Bool {
        match self {
            ProfileVisibility.Public => true,
            ProfileVisibility.FriendsOnly => is_friend,
            ProfileVisibility.Private => false,
            ProfileVisibility.Custom(allowed) => allowed.contains(viewer_id)
        }
    }
    
    fn display_name() -> String {
        match self {
            ProfileVisibility.Public => "Public",
            ProfileVisibility.FriendsOnly => "Friends Only",
            ProfileVisibility.Private => "Private",
            ProfileVisibility.Custom(_) => "Custom"
        }
    }
}

// =============================================================================
// Profile Status
// =============================================================================

/// Account status
enum AccountStatus {
    Active,
    Suspended(String),
    Deactivated,
    Banned(DateTime),
    PendingVerification
}

impl AccountStatus {
    fn is_active() -> Bool {
        match self {
            AccountStatus.Active => true,
            _ => false
        }
    }
    
    fn can_login() -> Bool {
        match self {
            AccountStatus.Active | AccountStatus.PendingVerification => true,
            _ => false
        }
    }
    
    fn reason() -> Option<String> {
        match self {
            AccountStatus.Suspended(reason) => Some(reason),
            _ => None
        }
    }
}

// =============================================================================
// User Profile
// =============================================================================

/// User profile data
struct UserProfile {
    id: String,
    username: String,
    display_name: String,
    email: Option<String>,
    phone: Option<String>,
    avatar_url: Option<String>,
    cover_url: Option<String>,
    bio: Option<String>,
    website: Option<String>,
    location: Option<String>,
    birthday: Option<DateTime>,
    gender: Option<Gender>,
    verified: Bool,
    status: AccountStatus,
    visibility: ProfileVisibility,
    created_at: DateTime,
    updated_at: DateTime,
    last_active: Option<DateTime>,
    metadata: Map<String, String>
}

impl UserProfile {
    /// Create new user profile
    fn new(id: String, username: String) -> Self {
        UserProfile {
            id: id,
            username: username,
            display_name: username,
            email: None,
            phone: None,
            avatar_url: None,
            cover_url: None,
            bio: None,
            website: None,
            location: None,
            birthday: None,
            gender: None,
            verified: false,
            status: AccountStatus.Active,
            visibility: ProfileVisibility.Public,
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            last_active: None,
            metadata: Map.empty()
        }
    }
    
    /// Create with display name
    fn with_display_name(id: String, username: String, display_name: String) -> Self {
        var profile = Self.new(id, username)
        profile.display_name = display_name
        profile
    }
    
    /// Set avatar
    fn set_avatar(url: String) {
        self.avatar_url = Some(url)
        self.updated_at = DateTime.now()
    }
    
    /// Set cover image
    fn set_cover(url: String) {
        self.cover_url = Some(url)
        self.updated_at = DateTime.now()
    }
    
    /// Set bio
    fn set_bio(bio: String) {
        self.bio = Some(bio.truncate(500))
        self.updated_at = DateTime.now()
    }
    
    /// Set location
    fn set_location(location: String) {
        self.location = Some(location)
        self.updated_at = DateTime.now()
    }
    
    /// Set website
    fn set_website(url: String) -> Result<(), ProfileError> {
        if !url.starts_with("http://") && !url.starts_with("https://") {
            return Err(ProfileError.InvalidUrl(url))
        }
        self.website = Some(url)
        self.updated_at = DateTime.now()
        Ok(())
    }
    
    /// Set birthday
    fn set_birthday(date: DateTime) -> Result<(), ProfileError> {
        if date > DateTime.now() {
            return Err(ProfileError.InvalidBirthday)
        }
        self.birthday = Some(date)
        self.updated_at = DateTime.now()
        Ok(())
    }
    
    /// Get age if birthday is set
    fn age() -> Option<Int> {
        self.birthday.map(|bd| {
            let now = DateTime.now()
            let years = now.year() - bd.year()
            if now.month() < bd.month() || 
               (now.month() == bd.month() && now.day() < bd.day()) {
                years - 1
            } else {
                years
            }
        })
    }
    
    /// Check if profile is complete
    fn is_complete() -> Bool {
        self.avatar_url.is_some() &&
        self.bio.is_some() &&
        self.email.is_some()
    }
    
    /// Get completion percentage
    fn completion_percentage() -> Int {
        var filled = 0
        var total = 10
        
        if self.avatar_url.is_some() { filled += 1 }
        if self.cover_url.is_some() { filled += 1 }
        if self.bio.is_some() { filled += 1 }
        if self.email.is_some() { filled += 1 }
        if self.phone.is_some() { filled += 1 }
        if self.website.is_some() { filled += 1 }
        if self.location.is_some() { filled += 1 }
        if self.birthday.is_some() { filled += 1 }
        if self.gender.is_some() { filled += 1 }
        if !self.metadata.is_empty() { filled += 1 }
        
        (filled * 100) / total
    }
    
    /// Update last active time
    fn touch() {
        self.last_active = Some(DateTime.now())
    }
    
    /// Verify profile
    fn verify() {
        self.verified = true
        self.updated_at = DateTime.now()
    }
    
    /// Unverify profile
    fn unverify() {
        self.verified = false
        self.updated_at = DateTime.now()
    }
    
    /// Suspend account
    fn suspend(reason: String) {
        self.status = AccountStatus.Suspended(reason)
        self.updated_at = DateTime.now()
    }
    
    /// Activate account
    fn activate() {
        self.status = AccountStatus.Active
        self.updated_at = DateTime.now()
    }
    
    /// Deactivate account
    fn deactivate() {
        self.status = AccountStatus.Deactivated
        self.updated_at = DateTime.now()
    }
    
    /// Ban account until date
    fn ban(until: DateTime) {
        self.status = AccountStatus.Banned(until)
        self.updated_at = DateTime.now()
    }
    
    /// Set visibility
    fn set_visibility(visibility: ProfileVisibility) {
        self.visibility = visibility
        self.updated_at = DateTime.now()
    }
    
    /// Add metadata
    fn set_metadata(key: String, value: String) {
        self.metadata.set(key, value)
        self.updated_at = DateTime.now()
    }
    
    /// Get metadata
    fn get_metadata(key: String) -> Option<String> {
        self.metadata.get(key)
    }
    
    /// Get public profile view
    fn public_view() -> PublicProfile {
        PublicProfile {
            id: self.id,
            username: self.username,
            display_name: self.display_name,
            avatar_url: self.avatar_url,
            bio: self.bio,
            verified: self.verified,
            created_at: self.created_at
        }
    }
    
    /// Check if can be viewed by user
    fn can_be_viewed_by(viewer_id: String, is_friend: Bool) -> Bool {
        if self.id == viewer_id { return true }
        self.visibility.can_view(viewer_id, is_friend)
    }
}

/// Gender options
enum Gender {
    Male,
    Female,
    NonBinary,
    Other(String),
    PreferNotToSay
}

impl Gender {
    fn display_name() -> String {
        match self {
            Gender.Male => "Male",
            Gender.Female => "Female",
            Gender.NonBinary => "Non-binary",
            Gender.Other(s) => s,
            Gender.PreferNotToSay => "Prefer not to say"
        }
    }
}

/// Public profile view (limited data)
struct PublicProfile {
    id: String,
    username: String,
    display_name: String,
    avatar_url: Option<String>,
    bio: Option<String>,
    verified: Bool,
    created_at: DateTime
}

// =============================================================================
// Profile Settings
// =============================================================================

/// Profile privacy settings
struct PrivacySettings {
    show_email: Bool,
    show_phone: Bool,
    show_birthday: Bool,
    show_location: Bool,
    show_last_active: Bool,
    allow_messages_from: MessagePermission,
    allow_friend_requests: Bool,
    allow_tagging: Bool,
    allow_mentions: Bool,
    searchable: Bool
}

impl PrivacySettings {
    fn default() -> Self {
        PrivacySettings {
            show_email: false,
            show_phone: false,
            show_birthday: true,
            show_location: true,
            show_last_active: true,
            allow_messages_from: MessagePermission.Everyone,
            allow_friend_requests: true,
            allow_tagging: true,
            allow_mentions: true,
            searchable: true
        }
    }
    
    fn strict() -> Self {
        PrivacySettings {
            show_email: false,
            show_phone: false,
            show_birthday: false,
            show_location: false,
            show_last_active: false,
            allow_messages_from: MessagePermission.FriendsOnly,
            allow_friend_requests: false,
            allow_tagging: false,
            allow_mentions: false,
            searchable: false
        }
    }
}

/// Message permission levels
enum MessagePermission {
    Everyone,
    FriendsOnly,
    FriendsOfFriends,
    Nobody
}

/// Notification settings
struct NotificationSettings {
    email_notifications: Bool,
    push_notifications: Bool,
    sms_notifications: Bool,
    notify_likes: Bool,
    notify_comments: Bool,
    notify_follows: Bool,
    notify_mentions: Bool,
    notify_messages: Bool,
    quiet_hours_enabled: Bool,
    quiet_hours_start: Option<Int>,
    quiet_hours_end: Option<Int>
}

impl NotificationSettings {
    fn default() -> Self {
        NotificationSettings {
            email_notifications: true,
            push_notifications: true,
            sms_notifications: false,
            notify_likes: true,
            notify_comments: true,
            notify_follows: true,
            notify_mentions: true,
            notify_messages: true,
            quiet_hours_enabled: false,
            quiet_hours_start: None,
            quiet_hours_end: None
        }
    }
    
    fn is_quiet_hour(hour: Int) -> Bool {
        if !self.quiet_hours_enabled { return false }
        
        match (self.quiet_hours_start, self.quiet_hours_end) {
            (Some(start), Some(end)) => {
                if start <= end {
                    hour >= start && hour < end
                } else {
                    hour >= start || hour < end
                }
            },
            _ => false
        }
    }
    
    fn set_quiet_hours(start: Int, end: Int) {
        self.quiet_hours_enabled = true
        self.quiet_hours_start = Some(start)
        self.quiet_hours_end = Some(end)
    }
}

// =============================================================================
// Profile Statistics
// =============================================================================

/// User statistics
struct ProfileStats {
    user_id: String,
    followers_count: Int64,
    following_count: Int64,
    posts_count: Int64,
    likes_received: Int64,
    comments_received: Int64,
    shares_received: Int64,
    profile_views: Int64,
    updated_at: DateTime
}

impl ProfileStats {
    fn new(user_id: String) -> Self {
        ProfileStats {
            user_id: user_id,
            followers_count: 0,
            following_count: 0,
            posts_count: 0,
            likes_received: 0,
            comments_received: 0,
            shares_received: 0,
            profile_views: 0,
            updated_at: DateTime.now()
        }
    }
    
    fn increment_followers() {
        self.followers_count += 1
        self.updated_at = DateTime.now()
    }
    
    fn decrement_followers() {
        if self.followers_count > 0 {
            self.followers_count -= 1
        }
        self.updated_at = DateTime.now()
    }
    
    fn increment_following() {
        self.following_count += 1
        self.updated_at = DateTime.now()
    }
    
    fn decrement_following() {
        if self.following_count > 0 {
            self.following_count -= 1
        }
        self.updated_at = DateTime.now()
    }
    
    fn increment_posts() {
        self.posts_count += 1
        self.updated_at = DateTime.now()
    }
    
    fn decrement_posts() {
        if self.posts_count > 0 {
            self.posts_count -= 1
        }
        self.updated_at = DateTime.now()
    }
    
    fn add_like() {
        self.likes_received += 1
        self.updated_at = DateTime.now()
    }
    
    fn remove_like() {
        if self.likes_received > 0 {
            self.likes_received -= 1
        }
        self.updated_at = DateTime.now()
    }
    
    fn add_profile_view() {
        self.profile_views += 1
        self.updated_at = DateTime.now()
    }
    
    /// Engagement rate
    fn engagement_rate() -> Float {
        if self.followers_count == 0 { return 0.0 }
        let total_engagement = self.likes_received + self.comments_received + self.shares_received
        (total_engagement as Float / self.followers_count as Float) * 100.0
    }
    
    /// Format followers count
    fn formatted_followers() -> String {
        format_count(self.followers_count)
    }
    
    /// Format following count
    fn formatted_following() -> String {
        format_count(self.following_count)
    }
}

fn format_count(count: Int64) -> String {
    if count < 1000 { count.to_string() }
    else if count < 1_000_000 { format!("{:.1}K", count as Float / 1000.0) }
    else if count < 1_000_000_000 { format!("{:.1}M", count as Float / 1_000_000.0) }
    else { format!("{:.1}B", count as Float / 1_000_000_000.0) }
}

// =============================================================================
// Profile Service
// =============================================================================

/// Profile service actor
actor ProfileService {
    state profiles: Map<String, UserProfile>
    state stats: Map<String, ProfileStats>
    state settings: Map<String, (PrivacySettings, NotificationSettings)>
    
    fn new() -> Self {
        ProfileService {
            profiles: Map.empty(),
            stats: Map.empty(),
            settings: Map.empty()
        }
    }
    
    /// Create new profile
    on create_profile(id: String, username: String) -> Result<UserProfile, ProfileError> {
        if self.profiles.contains_key(id) {
            return Err(ProfileError.AlreadyExists(id))
        }
        
        // Check username uniqueness
        for (_, profile) in self.profiles {
            if profile.username == username {
                return Err(ProfileError.UsernameTaken(username))
            }
        }
        
        let profile = UserProfile.new(id, username)
        self.profiles.set(id, profile.clone())
        self.stats.set(id, ProfileStats.new(id))
        self.settings.set(id, (PrivacySettings.default(), NotificationSettings.default()))
        
        Ok(profile)
    }
    
    /// Get profile by ID
    on get_profile(id: String) -> Option<UserProfile> {
        self.profiles.get(id)
    }
    
    /// Get profile by username
    on get_by_username(username: String) -> Option<UserProfile> {
        for (_, profile) in self.profiles {
            if profile.username == username {
                return Some(profile)
            }
        }
        None
    }
    
    /// Update profile
    on update_profile(id: String, updates: ProfileUpdate) -> Result<UserProfile, ProfileError> {
        let profile = self.profiles.get_mut(id)
            .ok_or(ProfileError.NotFound(id))?
        
        if let Some(display_name) = updates.display_name {
            profile.display_name = display_name
        }
        if let Some(bio) = updates.bio {
            profile.bio = Some(bio)
        }
        if let Some(avatar) = updates.avatar_url {
            profile.avatar_url = Some(avatar)
        }
        if let Some(cover) = updates.cover_url {
            profile.cover_url = Some(cover)
        }
        if let Some(website) = updates.website {
            profile.website = Some(website)
        }
        if let Some(location) = updates.location {
            profile.location = Some(location)
        }
        
        profile.updated_at = DateTime.now()
        Ok(profile.clone())
    }
    
    /// Delete profile
    on delete_profile(id: String) -> Result<(), ProfileError> {
        if !self.profiles.contains_key(id) {
            return Err(ProfileError.NotFound(id))
        }
        
        self.profiles.remove(id)
        self.stats.remove(id)
        self.settings.remove(id)
        Ok(())
    }
    
    /// Get profile stats
    on get_stats(id: String) -> Option<ProfileStats> {
        self.stats.get(id)
    }
    
    /// Update stats
    on update_stats(id: String, f: fn(ProfileStats) -> ProfileStats) {
        if let Some(stats) = self.stats.get_mut(id) {
            *stats = f(stats.clone())
        }
    }
    
    /// Get privacy settings
    on get_privacy_settings(id: String) -> Option<PrivacySettings> {
        self.settings.get(id).map(|(p, _)| p)
    }
    
    /// Update privacy settings
    on set_privacy_settings(id: String, settings: PrivacySettings) {
        if let Some((_, notif)) = self.settings.get(id) {
            self.settings.set(id, (settings, notif))
        }
    }
    
    /// Get notification settings
    on get_notification_settings(id: String) -> Option<NotificationSettings> {
        self.settings.get(id).map(|(_, n)| n)
    }
    
    /// Update notification settings
    on set_notification_settings(id: String, settings: NotificationSettings) {
        if let Some((priv_settings, _)) = self.settings.get(id) {
            self.settings.set(id, (priv_settings, settings))
        }
    }
    
    /// Search profiles
    on search(query: String, limit: Int) -> [PublicProfile] {
        let query_lower = query.to_lowercase()
        
        self.profiles.values()
            .filter(|p| {
                let (privacy, _) = self.settings.get(p.id).unwrap_or_default()
                privacy.searchable &&
                (p.username.to_lowercase().contains(query_lower) ||
                 p.display_name.to_lowercase().contains(query_lower))
            })
            .map(|p| p.public_view())
            .take(limit)
            .collect()
    }
    
    /// Record profile view
    on view_profile(profile_id: String, viewer_id: String) {
        if profile_id != viewer_id {
            if let Some(stats) = self.stats.get_mut(profile_id) {
                stats.add_profile_view()
            }
        }
    }
}

/// Profile update request
struct ProfileUpdate {
    display_name: Option<String>,
    bio: Option<String>,
    avatar_url: Option<String>,
    cover_url: Option<String>,
    website: Option<String>,
    location: Option<String>
}

impl ProfileUpdate {
    fn new() -> Self {
        ProfileUpdate {
            display_name: None,
            bio: None,
            avatar_url: None,
            cover_url: None,
            website: None,
            location: None
        }
    }
    
    fn with_display_name(name: String) -> Self {
        var update = Self.new()
        update.display_name = Some(name)
        update
    }
    
    fn with_bio(bio: String) -> Self {
        var update = Self.new()
        update.bio = Some(bio)
        update
    }
}

// =============================================================================
// Profile Errors
// =============================================================================

/// Profile errors
enum ProfileError {
    NotFound(String),
    AlreadyExists(String),
    UsernameTaken(String),
    InvalidUrl(String),
    InvalidBirthday,
    Unauthorized,
    ValidationError(String)
}

impl ProfileError {
    fn message() -> String {
        match self {
            ProfileError.NotFound(id) => format!("Profile not found: {}", id),
            ProfileError.AlreadyExists(id) => format!("Profile already exists: {}", id),
            ProfileError.UsernameTaken(name) => format!("Username already taken: {}", name),
            ProfileError.InvalidUrl(url) => format!("Invalid URL: {}", url),
            ProfileError.InvalidBirthday => "Birthday cannot be in the future",
            ProfileError.Unauthorized => "Unauthorized access",
            ProfileError.ValidationError(msg) => msg
        }
    }
}

// =============================================================================
// Profile Events
// =============================================================================

/// Profile events for event sourcing
enum ProfileEvent {
    Created { id: String, username: String, timestamp: DateTime },
    Updated { id: String, fields: [String], timestamp: DateTime },
    AvatarChanged { id: String, url: String, timestamp: DateTime },
    Verified { id: String, timestamp: DateTime },
    Suspended { id: String, reason: String, timestamp: DateTime },
    Activated { id: String, timestamp: DateTime },
    Deleted { id: String, timestamp: DateTime }
}

impl ProfileEvent {
    fn timestamp() -> DateTime {
        match self {
            ProfileEvent.Created { timestamp, .. } => timestamp,
            ProfileEvent.Updated { timestamp, .. } => timestamp,
            ProfileEvent.AvatarChanged { timestamp, .. } => timestamp,
            ProfileEvent.Verified { timestamp, .. } => timestamp,
            ProfileEvent.Suspended { timestamp, .. } => timestamp,
            ProfileEvent.Activated { timestamp, .. } => timestamp,
            ProfileEvent.Deleted { timestamp, .. } => timestamp
        }
    }
    
    fn user_id() -> String {
        match self {
            ProfileEvent.Created { id, .. } => id,
            ProfileEvent.Updated { id, .. } => id,
            ProfileEvent.AvatarChanged { id, .. } => id,
            ProfileEvent.Verified { id, .. } => id,
            ProfileEvent.Suspended { id, .. } => id,
            ProfileEvent.Activated { id, .. } => id,
            ProfileEvent.Deleted { id, .. } => id
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create user profile" {
    let profile = UserProfile.new("user1", "johndoe")
    assert_eq(profile.username, "johndoe")?
    assert_eq(profile.display_name, "johndoe")?
    assert(!profile.verified)?
    assert(profile.status.is_active())?
}

test "profile completion" {
    var profile = UserProfile.new("user1", "johndoe")
    assert_eq(profile.completion_percentage(), 0)?
    
    profile.set_avatar("https://example.com/avatar.jpg")
    profile.set_bio("Hello world")
    profile.email = Some("john@example.com")
    
    assert(profile.is_complete())?
}

test "profile visibility" {
    let public = ProfileVisibility.Public
    let friends = ProfileVisibility.FriendsOnly
    let private = ProfileVisibility.Private
    
    assert(public.can_view("anyone", false))?
    assert(friends.can_view("friend", true))?
    assert(!friends.can_view("stranger", false))?
    assert(!private.can_view("anyone", true))?
}

test "profile stats" {
    var stats = ProfileStats.new("user1")
    stats.increment_followers()
    stats.increment_followers()
    stats.add_like()
    
    assert_eq(stats.followers_count, 2)?
    assert_eq(stats.likes_received, 1)?
}

test "privacy settings" {
    let default = PrivacySettings.default()
    let strict = PrivacySettings.strict()
    
    assert(default.searchable)?
    assert(!strict.searchable)?
    assert(default.allow_friend_requests)?
    assert(!strict.allow_friend_requests)?
}

test "format count" {
    assert_eq(format_count(500), "500")?
    assert_eq(format_count(1500), "1.5K")?
    assert_eq(format_count(1_500_000), "1.5M")?
}
