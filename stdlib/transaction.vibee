// =============================================================================
// Vibee OS â€” Transaction Module
// Blockchain transaction handling
// =============================================================================

// =============================================================================
// Transaction Types
// =============================================================================

/// Legacy transaction (pre-EIP-1559)
struct LegacyTransaction {
    nonce: UInt64
    gas_price: UInt256
    gas_limit: UInt64
    to: Option<Address>
    value: UInt256
    data: [UInt8]
    v: UInt64
    r: [UInt8; 32]
    s: [UInt8; 32]
    
    fn new() -> Self {
        LegacyTransaction {
            nonce: 0,
            gas_price: UInt256.zero(),
            gas_limit: 21000,
            to: None,
            value: UInt256.zero(),
            data: [],
            v: 0,
            r: [0u8; 32],
            s: [0u8; 32]
        }
    }
    
    fn to(addr: Address) -> Self { self.to = Some(addr); self }
    fn value(val: UInt256) -> Self { self.value = val; self }
    fn data(d: [UInt8]) -> Self { self.data = d; self }
    fn nonce(n: UInt64) -> Self { self.nonce = n; self }
    fn gas_price(p: UInt256) -> Self { self.gas_price = p; self }
    fn gas_limit(l: UInt64) -> Self { self.gas_limit = l; self }
    
    fn signing_hash(chain_id: UInt64) -> [UInt8; 32] {
        let encoded = rlp.encode([
            rlp.encode_uint(self.nonce),
            rlp.encode_uint256(self.gas_price),
            rlp.encode_uint(self.gas_limit),
            if let Some(to) = self.to { rlp.encode_bytes(to.bytes) } else { rlp.encode_bytes([]) },
            rlp.encode_uint256(self.value),
            rlp.encode_bytes(self.data),
            rlp.encode_uint(chain_id),
            rlp.encode_uint(0),
            rlp.encode_uint(0)
        ])
        crypto.keccak256(encoded)
    }
    
    fn sign(signer: PrivateKey, chain_id: UInt64) -> Self {
        let hash = self.signing_hash(chain_id)
        let sig = signer.sign(hash)
        self.v = sig.v as UInt64 + chain_id * 2 + 35
        self.r = sig.r
        self.s = sig.s
        self
    }
    
    fn encode() -> [UInt8] {
        rlp.encode([
            rlp.encode_uint(self.nonce),
            rlp.encode_uint256(self.gas_price),
            rlp.encode_uint(self.gas_limit),
            if let Some(to) = self.to { rlp.encode_bytes(to.bytes) } else { rlp.encode_bytes([]) },
            rlp.encode_uint256(self.value),
            rlp.encode_bytes(self.data),
            rlp.encode_uint(self.v),
            rlp.encode_bytes(self.r),
            rlp.encode_bytes(self.s)
        ])
    }
    
    fn hash() -> [UInt8; 32] {
        crypto.keccak256(self.encode())
    }
    
    fn recover_sender() -> Result<Address, TransactionError> {
        let chain_id = (self.v - 35) / 2
        let recovery_id = ((self.v - 35) % 2) as UInt8
        let sig = Signature { r: self.r, s: self.s, v: recovery_id }
        let hash = self.signing_hash(chain_id)
        let pubkey = sig.recover(hash)?
        Ok(pubkey.to_eth_address())
    }
}

/// EIP-1559 transaction
struct Transaction {
    chain_id: UInt64
    nonce: UInt64
    max_priority_fee: UInt256
    max_fee: UInt256
    gas_limit: UInt64
    to: Option<Address>
    value: UInt256
    data: [UInt8]
    access_list: [AccessListEntry]
    v: UInt8
    r: [UInt8; 32]
    s: [UInt8; 32]
    
    fn new(chain_id: UInt64) -> Self {
        Transaction {
            chain_id: chain_id,
            nonce: 0,
            max_priority_fee: UInt256.zero(),
            max_fee: UInt256.zero(),
            gas_limit: 21000,
            to: None,
            value: UInt256.zero(),
            data: [],
            access_list: [],
            v: 0,
            r: [0u8; 32],
            s: [0u8; 32]
        }
    }
    
    fn to(addr: Address) -> Self { self.to = Some(addr); self }
    fn value(val: UInt256) -> Self { self.value = val; self }
    fn data(d: [UInt8]) -> Self { self.data = d; self }
    fn nonce(n: UInt64) -> Self { self.nonce = n; self }
    fn max_priority_fee(f: UInt256) -> Self { self.max_priority_fee = f; self }
    fn max_fee(f: UInt256) -> Self { self.max_fee = f; self }
    fn gas_limit(l: UInt64) -> Self { self.gas_limit = l; self }
    fn access_list(list: [AccessListEntry]) -> Self { self.access_list = list; self }
    
    fn signing_hash() -> [UInt8; 32] {
        let encoded = rlp.encode([
            rlp.encode_uint(self.chain_id),
            rlp.encode_uint(self.nonce),
            rlp.encode_uint256(self.max_priority_fee),
            rlp.encode_uint256(self.max_fee),
            rlp.encode_uint(self.gas_limit),
            if let Some(to) = self.to { rlp.encode_bytes(to.bytes) } else { rlp.encode_bytes([]) },
            rlp.encode_uint256(self.value),
            rlp.encode_bytes(self.data),
            self.encode_access_list()
        ])
        var prefixed = [0x02u8]
        prefixed.extend(encoded)
        crypto.keccak256(prefixed)
    }
    
    fn encode_access_list() -> [UInt8] {
        rlp.encode(self.access_list.iter().map(|e| {
            rlp.encode([
                rlp.encode_bytes(e.address.bytes),
                rlp.encode(e.storage_keys.iter().map(|k| rlp.encode_bytes(k)).collect())
            ])
        }).collect())
    }
    
    fn sign(signer: PrivateKey) -> Self {
        let hash = self.signing_hash()
        let sig = signer.sign(hash)
        self.v = sig.v
        self.r = sig.r
        self.s = sig.s
        self
    }
    
    fn encode() -> [UInt8] {
        let encoded = rlp.encode([
            rlp.encode_uint(self.chain_id),
            rlp.encode_uint(self.nonce),
            rlp.encode_uint256(self.max_priority_fee),
            rlp.encode_uint256(self.max_fee),
            rlp.encode_uint(self.gas_limit),
            if let Some(to) = self.to { rlp.encode_bytes(to.bytes) } else { rlp.encode_bytes([]) },
            rlp.encode_uint256(self.value),
            rlp.encode_bytes(self.data),
            self.encode_access_list(),
            rlp.encode_uint(self.v),
            rlp.encode_bytes(self.r),
            rlp.encode_bytes(self.s)
        ])
        var result = [0x02u8]
        result.extend(encoded)
        result
    }
    
    fn hash() -> [UInt8; 32] {
        crypto.keccak256(self.encode())
    }
    
    fn recover_sender() -> Result<Address, TransactionError> {
        let sig = Signature { r: self.r, s: self.s, v: self.v }
        let hash = self.signing_hash()
        let pubkey = sig.recover(hash)?
        Ok(pubkey.to_eth_address())
    }
}

/// Access list entry for EIP-2930
struct AccessListEntry {
    address: Address
    storage_keys: [[UInt8; 32]]
    
    fn new(address: Address) -> Self {
        AccessListEntry { address: address, storage_keys: [] }
    }
    
    fn with_keys(keys: [[UInt8; 32]]) -> Self {
        self.storage_keys = keys
        self
    }
}

// =============================================================================
// Transaction Builder
// =============================================================================

/// Transaction builder with automatic gas estimation
struct TransactionBuilder {
    chain_id: UInt64
    from: Option<Address>
    to: Option<Address>
    value: UInt256
    data: [UInt8]
    gas_limit: Option<UInt64>
    max_fee: Option<UInt256>
    max_priority_fee: Option<UInt256>
    nonce: Option<UInt64>
    
    fn new(chain_id: UInt64) -> Self {
        TransactionBuilder {
            chain_id: chain_id,
            from: None,
            to: None,
            value: UInt256.zero(),
            data: [],
            gas_limit: None,
            max_fee: None,
            max_priority_fee: None,
            nonce: None
        }
    }
    
    fn from(addr: Address) -> Self { self.from = Some(addr); self }
    fn to(addr: Address) -> Self { self.to = Some(addr); self }
    fn value(val: UInt256) -> Self { self.value = val; self }
    fn data(d: [UInt8]) -> Self { self.data = d; self }
    fn gas_limit(l: UInt64) -> Self { self.gas_limit = Some(l); self }
    fn max_fee(f: UInt256) -> Self { self.max_fee = Some(f); self }
    fn max_priority_fee(f: UInt256) -> Self { self.max_priority_fee = Some(f); self }
    fn nonce(n: UInt64) -> Self { self.nonce = Some(n); self }
    
    fn build() -> Result<Transaction, TransactionError> {
        let from = self.from.ok_or(TransactionError.MissingFrom)?
        
        // Get nonce if not set
        let nonce = match self.nonce {
            Some(n) => n
            None => @native("eth_get_transaction_count", from)?
        }
        
        // Estimate gas if not set
        let gas_limit = match self.gas_limit {
            Some(l) => l
            None => @native("eth_estimate_gas", from, self.to, self.value, self.data)?
        }
        
        // Get gas prices if not set
        let (max_fee, max_priority_fee) = match (self.max_fee, self.max_priority_fee) {
            (Some(f), Some(p)) => (f, p)
            _ => {
                let fees = @native("eth_fee_history")?
                (fees.base_fee * 2 + fees.priority_fee, fees.priority_fee)
            }
        }
        
        Ok(Transaction {
            chain_id: self.chain_id,
            nonce: nonce,
            max_priority_fee: max_priority_fee,
            max_fee: max_fee,
            gas_limit: gas_limit,
            to: self.to,
            value: self.value,
            data: self.data,
            access_list: [],
            v: 0,
            r: [0u8; 32],
            s: [0u8; 32]
        })
    }
    
    fn sign_and_send(signer: PrivateKey) -> Result<TransactionReceipt, TransactionError> {
        let tx = self.build()?.sign(signer)
        tx.send()
    }
}

// =============================================================================
// Transaction Receipt
// =============================================================================

/// Transaction receipt
struct TransactionReceipt {
    transaction_hash: [UInt8; 32]
    block_hash: [UInt8; 32]
    block_number: UInt64
    from: Address
    to: Option<Address>
    contract_address: Option<Address>
    gas_used: UInt64
    cumulative_gas_used: UInt64
    effective_gas_price: UInt256
    status: Bool
    logs: [Log]
    
    fn success() -> Bool { self.status }
    fn failed() -> Bool { !self.status }
}

/// Transaction log
struct Log {
    address: Address
    topics: [[UInt8; 32]]
    data: [UInt8]
    log_index: UInt64
    
    fn topic(index: Int) -> Option<[UInt8; 32]> {
        self.topics.get(index).cloned()
    }
    
    fn decode<T: AbiDecode>() -> Result<T, TransactionError> {
        T.abi_decode(self.data).map_err(|_| TransactionError.DecodeFailed)
    }
}

// =============================================================================
// Transaction Pool
// =============================================================================

/// Transaction pool for batch operations
struct TransactionPool {
    transactions: [Transaction]
    
    fn new() -> Self { TransactionPool { transactions: [] } }
    
    fn add(tx: Transaction) -> Self {
        self.transactions.push(tx)
        self
    }
    
    fn send_all(signer: PrivateKey) -> Result<[TransactionReceipt], TransactionError> {
        var receipts = []
        for tx in self.transactions {
            let signed = tx.sign(signer)
            let receipt = signed.send()?
            receipts.push(receipt)
        }
        Ok(receipts)
    }
    
    fn send_batch(signer: PrivateKey) -> Result<[[UInt8; 32]], TransactionError> {
        var hashes = []
        for tx in self.transactions {
            let signed = tx.sign(signer)
            let hash = @native("eth_send_raw_transaction", signed.encode())?
            hashes.push(hash)
        }
        Ok(hashes)
    }
    
    fn estimate_total_gas() -> Result<UInt64, TransactionError> {
        var total = 0u64
        for tx in self.transactions {
            total += @native("eth_estimate_gas", tx)?
        }
        Ok(total)
    }
}

// =============================================================================
// Pending Transaction
// =============================================================================

/// Pending transaction with confirmation tracking
struct PendingTransaction {
    hash: [UInt8; 32]
    
    fn new(hash: [UInt8; 32]) -> Self {
        PendingTransaction { hash: hash }
    }
    
    fn wait() -> Result<TransactionReceipt, TransactionError> {
        self.wait_confirmations(1)
    }
    
    fn wait_confirmations(confirmations: UInt64) -> Result<TransactionReceipt, TransactionError> {
        loop {
            if let Some(receipt) = @native("eth_get_transaction_receipt", self.hash)? {
                let current_block = @native("eth_block_number")?
                if current_block >= receipt.block_number + confirmations {
                    return Ok(receipt)
                }
            }
            @native("sleep", 1000)  // 1 second
        }
    }
    
    fn status() -> TransactionStatus {
        match @native("eth_get_transaction_receipt", self.hash) {
            Ok(Some(receipt)) => {
                if receipt.status { TransactionStatus.Confirmed } 
                else { TransactionStatus.Failed }
            }
            Ok(None) => TransactionStatus.Pending
            Err(_) => TransactionStatus.Unknown
        }
    }
}

enum TransactionStatus {
    Pending
    Confirmed
    Failed
    Unknown
}

// =============================================================================
// RLP Encoding
// =============================================================================

module rlp {
    fn encode_uint(value: UInt64) -> [UInt8] {
        if value == 0 { return [0x80] }
        var bytes = []
        var v = value
        while v > 0 {
            bytes.insert(0, (v & 0xff) as UInt8)
            v >>= 8
        }
        if bytes.len() == 1 && bytes[0] < 0x80 {
            bytes
        } else {
            var result = [(0x80 + bytes.len()) as UInt8]
            result.extend(bytes)
            result
        }
    }
    
    fn encode_uint256(value: UInt256) -> [UInt8] {
        let bytes = value.to_be_bytes()
        var trimmed = []
        var started = false
        for b in bytes {
            if b != 0 || started {
                started = true
                trimmed.push(b)
            }
        }
        if trimmed.is_empty() { return [0x80] }
        encode_bytes(trimmed)
    }
    
    fn encode_bytes(bytes: [UInt8]) -> [UInt8] {
        let len = bytes.len()
        if len == 0 { return [0x80] }
        if len == 1 && bytes[0] < 0x80 { return bytes }
        if len <= 55 {
            var result = [(0x80 + len) as UInt8]
            result.extend(bytes)
            result
        } else {
            let len_bytes = encode_length(len)
            var result = [(0xb7 + len_bytes.len()) as UInt8]
            result.extend(len_bytes)
            result.extend(bytes)
            result
        }
    }
    
    fn encode(items: [[UInt8]]) -> [UInt8] {
        var payload = []
        for item in items {
            payload.extend(item)
        }
        let len = payload.len()
        if len <= 55 {
            var result = [(0xc0 + len) as UInt8]
            result.extend(payload)
            result
        } else {
            let len_bytes = encode_length(len)
            var result = [(0xf7 + len_bytes.len()) as UInt8]
            result.extend(len_bytes)
            result.extend(payload)
            result
        }
    }
    
    fn encode_length(len: Int) -> [UInt8] {
        var bytes = []
        var l = len
        while l > 0 {
            bytes.insert(0, (l & 0xff) as UInt8)
            l >>= 8
        }
        bytes
    }
    
    fn decode(data: [UInt8]) -> Result<RlpItem, TransactionError> {
        if data.is_empty() { return Err(TransactionError.InvalidRlp) }
        let (item, _) = decode_item(data, 0)?
        Ok(item)
    }
    
    fn decode_item(data: [UInt8], offset: Int) -> Result<(RlpItem, Int), TransactionError> {
        let prefix = data[offset]
        if prefix < 0x80 {
            Ok((RlpItem.Bytes([prefix]), offset + 1))
        } else if prefix <= 0xb7 {
            let len = (prefix - 0x80) as Int
            Ok((RlpItem.Bytes(data[offset+1..offset+1+len].to_vec()), offset + 1 + len))
        } else if prefix <= 0xbf {
            let len_len = (prefix - 0xb7) as Int
            let len = decode_be_int(data[offset+1..offset+1+len_len])
            Ok((RlpItem.Bytes(data[offset+1+len_len..offset+1+len_len+len].to_vec()), offset + 1 + len_len + len))
        } else if prefix <= 0xf7 {
            let len = (prefix - 0xc0) as Int
            let items = decode_list(data, offset + 1, len)?
            Ok((RlpItem.List(items), offset + 1 + len))
        } else {
            let len_len = (prefix - 0xf7) as Int
            let len = decode_be_int(data[offset+1..offset+1+len_len])
            let items = decode_list(data, offset + 1 + len_len, len)?
            Ok((RlpItem.List(items), offset + 1 + len_len + len))
        }
    }
    
    fn decode_list(data: [UInt8], start: Int, len: Int) -> Result<[RlpItem], TransactionError> {
        var items = []
        var offset = start
        while offset < start + len {
            let (item, new_offset) = decode_item(data, offset)?
            items.push(item)
            offset = new_offset
        }
        Ok(items)
    }
    
    fn decode_be_int(bytes: [UInt8]) -> Int {
        var result = 0
        for b in bytes {
            result = (result << 8) | (b as Int)
        }
        result
    }
}

enum RlpItem {
    Bytes([UInt8])
    List([RlpItem])
    
    fn as_bytes() -> Option<[UInt8]> {
        match self { Bytes(b) => Some(b), _ => None }
    }
    
    fn as_list() -> Option<[RlpItem]> {
        match self { List(l) => Some(l), _ => None }
    }
}

// =============================================================================
// Transaction Sending
// =============================================================================

impl Transaction {
    fn send() -> Result<TransactionReceipt, TransactionError> {
        let hash = @native("eth_send_raw_transaction", self.encode())?
        PendingTransaction.new(hash).wait()
    }
    
    fn send_async() -> Result<PendingTransaction, TransactionError> {
        let hash = @native("eth_send_raw_transaction", self.encode())?
        Ok(PendingTransaction.new(hash))
    }
}

// =============================================================================
// Errors
// =============================================================================

enum TransactionError {
    InvalidSignature
    InvalidNonce
    InsufficientFunds
    GasTooLow
    GasTooHigh
    InvalidRlp
    MissingFrom
    DecodeFailed
    Timeout
    Reverted(String)
}

impl Display for TransactionError {
    fn fmt(f: Formatter) {
        match self {
            InvalidSignature => f.write("Invalid signature")
            InvalidNonce => f.write("Invalid nonce")
            InsufficientFunds => f.write("Insufficient funds")
            GasTooLow => f.write("Gas too low")
            GasTooHigh => f.write("Gas too high")
            InvalidRlp => f.write("Invalid RLP encoding")
            MissingFrom => f.write("Missing from address")
            DecodeFailed => f.write("Decode failed")
            Timeout => f.write("Transaction timeout")
            Reverted(s) => f.write(format!("Reverted: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "rlp encode uint" {
    assert_eq(rlp.encode_uint(0), [0x80])?
    assert_eq(rlp.encode_uint(127), [127])?
    assert_eq(rlp.encode_uint(128), [0x81, 128])?
}

test "rlp encode bytes" {
    assert_eq(rlp.encode_bytes([]), [0x80])?
    assert_eq(rlp.encode_bytes([0x01]), [0x01])?
    assert_eq(rlp.encode_bytes([0x80]), [0x81, 0x80])?
}

test "rlp encode list" {
    assert_eq(rlp.encode([]), [0xc0])?
    assert_eq(rlp.encode([[0x01], [0x02]]), [0xc2, 0x01, 0x02])?
}

test "transaction hash" {
    let tx = LegacyTransaction.new()
        .to(Address.zero())
        .value(UInt256.from(1000))
    let hash = tx.hash()
    assert_eq(hash.len(), 32)?
}

test "eip1559 transaction" {
    let tx = Transaction.new(1)
        .to(Address.zero())
        .value(UInt256.from(1000))
        .max_fee(UInt256.from(20_000_000_000))
        .max_priority_fee(UInt256.from(1_000_000_000))
    let encoded = tx.encode()
    assert_eq(encoded[0], 0x02)?  // EIP-1559 type
}

test "transaction builder" {
    let builder = TransactionBuilder.new(1)
        .to(Address.zero())
        .value(UInt256.from(1000))
    // Build would require network access
}
