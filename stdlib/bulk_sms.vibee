// =============================================================================
// Vibee OS â€” Bulk SMS Module
// Mass SMS sending with batching, scheduling, and analytics
// =============================================================================

use sms_sender.{SmsSender, SmsMessage, SmsResult, SmsStatus, SmsError, SmsProvider}
use sms_template.{SmsTemplate, TemplateEngine}

// =============================================================================
// Bulk SMS Campaign
// =============================================================================

/// Bulk SMS campaign
struct BulkSmsCampaign {
    id: String
    name: String
    message: String
    template: Option<SmsTemplate>
    from: String
    recipients: [BulkRecipient]
    status: CampaignStatus
    settings: BulkSettings
    stats: BulkStats
    created_at: Instant
    started_at: Option<Instant>
    completed_at: Option<Instant>
    scheduled_at: Option<Instant>
}

struct BulkRecipient {
    phone: String
    variables: Map<String, String>
    status: RecipientStatus
    message_id: Option<String>
    sent_at: Option<Instant>
    delivered_at: Option<Instant>
    error: Option<String>
}

enum RecipientStatus {
    Pending
    Queued
    Sent
    Delivered
    Failed
    Skipped
    Unsubscribed
}

enum CampaignStatus {
    Draft
    Scheduled
    Running
    Paused
    Completed
    Cancelled
    Failed
}

struct BulkSettings {
    batch_size: Int
    batch_delay_ms: Int64
    max_concurrent: Int
    retry_failed: Bool
    retry_count: Int
    skip_invalid: Bool
    deduplicate: Bool
    respect_quiet_hours: Bool
    quiet_hours_start: Option<Int>  // Hour 0-23
    quiet_hours_end: Option<Int>
    timezone: String
}

impl BulkSettings {
    fn default() -> Self {
        BulkSettings {
            batch_size: 100,
            batch_delay_ms: 1000,
            max_concurrent: 10,
            retry_failed: true,
            retry_count: 2,
            skip_invalid: true,
            deduplicate: true,
            respect_quiet_hours: false,
            quiet_hours_start: None,
            quiet_hours_end: None,
            timezone: "UTC"
        }
    }
    
    fn batch_size(size: Int) -> Self { self.batch_size = size; self }
    fn batch_delay(ms: Int64) -> Self { self.batch_delay_ms = ms; self }
    fn max_concurrent(n: Int) -> Self { self.max_concurrent = n; self }
    fn retry(enabled: Bool, count: Int) -> Self { self.retry_failed = enabled; self.retry_count = count; self }
    fn skip_invalid(enabled: Bool) -> Self { self.skip_invalid = enabled; self }
    fn deduplicate(enabled: Bool) -> Self { self.deduplicate = enabled; self }
    fn quiet_hours(start: Int, end: Int, tz: String) -> Self {
        self.respect_quiet_hours = true
        self.quiet_hours_start = Some(start)
        self.quiet_hours_end = Some(end)
        self.timezone = tz
        self
    }
}

impl BulkSmsCampaign {
    fn new(name: String) -> Self {
        BulkSmsCampaign {
            id: UUID.v4(),
            name: name,
            message: "",
            template: None,
            from: "",
            recipients: [],
            status: CampaignStatus.Draft,
            settings: BulkSettings.default(),
            stats: BulkStats.new(),
            created_at: Instant.now(),
            started_at: None,
            completed_at: None,
            scheduled_at: None
        }
    }
    
    fn message(msg: String) -> Self { self.message = msg; self }
    fn template(t: SmsTemplate) -> Self { self.template = Some(t); self }
    fn from(sender: String) -> Self { self.from = sender; self }
    fn settings(s: BulkSettings) -> Self { self.settings = s; self }
    
    fn add_recipient(phone: String) -> Self {
        self.recipients.push(BulkRecipient {
            phone: phone,
            variables: Map.empty(),
            status: RecipientStatus.Pending,
            message_id: None,
            sent_at: None,
            delivered_at: None,
            error: None
        })
        self
    }
    
    fn add_recipient_with_vars(phone: String, vars: Map<String, String>) -> Self {
        self.recipients.push(BulkRecipient {
            phone: phone,
            variables: vars,
            status: RecipientStatus.Pending,
            message_id: None,
            sent_at: None,
            delivered_at: None,
            error: None
        })
        self
    }
    
    fn add_recipients(phones: [String]) -> Self {
        for phone in phones {
            self = self.add_recipient(phone)
        }
        self
    }
    
    fn add_recipients_from_csv(csv: String) -> Result<Self, BulkSmsError> {
        let lines = csv.lines().skip(1)  // Skip header
        for line in lines {
            let parts: Vec<&str> = line.split(',').collect()
            if parts.is_empty() { continue }
            
            let phone = parts[0].trim().to_string()
            var vars = Map.empty()
            
            // Parse additional columns as variables
            if parts.len() > 1 { vars.set("name", parts[1].trim().to_string()) }
            if parts.len() > 2 { vars.set("var1", parts[2].trim().to_string()) }
            if parts.len() > 3 { vars.set("var2", parts[3].trim().to_string()) }
            
            self = self.add_recipient_with_vars(phone, vars)
        }
        Ok(self)
    }
    
    fn schedule(time: Instant) -> Self {
        self.scheduled_at = Some(time)
        self.status = CampaignStatus.Scheduled
        self
    }
    
    fn recipient_count() -> Int { self.recipients.len() }
    fn pending_count() -> Int { self.recipients.iter().filter(|r| r.status == RecipientStatus.Pending).count() }
    fn is_draft() -> Bool { self.status == CampaignStatus.Draft }
    fn is_running() -> Bool { self.status == CampaignStatus.Running }
    fn is_completed() -> Bool { self.status == CampaignStatus.Completed }
    
    fn validate() -> Result<(), BulkSmsError> {
        if self.message.is_empty() && self.template.is_none() {
            return Err(BulkSmsError.ValidationError("Message or template required"))
        }
        if self.from.is_empty() {
            return Err(BulkSmsError.ValidationError("Sender number required"))
        }
        if self.recipients.is_empty() {
            return Err(BulkSmsError.ValidationError("At least one recipient required"))
        }
        Ok(())
    }
}

// =============================================================================
// Bulk Stats
// =============================================================================

struct BulkStats {
    total: Int
    pending: Int
    queued: Int
    sent: Int
    delivered: Int
    failed: Int
    skipped: Int
    cost: Float
    currency: String
    start_time: Option<Instant>
    end_time: Option<Instant>
}

impl BulkStats {
    fn new() -> Self {
        BulkStats {
            total: 0,
            pending: 0,
            queued: 0,
            sent: 0,
            delivered: 0,
            failed: 0,
            skipped: 0,
            cost: 0.0,
            currency: "USD",
            start_time: None,
            end_time: None
        }
    }
    
    fn delivery_rate() -> Float {
        if self.sent == 0 { 0.0 } else { self.delivered as Float / self.sent as Float }
    }
    
    fn success_rate() -> Float {
        if self.total == 0 { 0.0 } else { (self.sent + self.delivered) as Float / self.total as Float }
    }
    
    fn failure_rate() -> Float {
        if self.total == 0 { 0.0 } else { self.failed as Float / self.total as Float }
    }
    
    fn progress() -> Float {
        if self.total == 0 { 0.0 } else { (self.total - self.pending) as Float / self.total as Float }
    }
    
    fn duration() -> Option<Duration> {
        match (self.start_time, self.end_time) {
            (Some(start), Some(end)) => Some(end.duration_since(start)),
            (Some(start), None) => Some(Instant.now().duration_since(start)),
            _ => None
        }
    }
    
    fn messages_per_second() -> Float {
        match self.duration() {
            Some(d) if d.as_secs() > 0 => self.sent as Float / d.as_secs() as Float,
            _ => 0.0
        }
    }
}

// =============================================================================
// Bulk SMS Runner
// =============================================================================

actor BulkSmsRunner {
    state sender: SmsSender
    state campaigns: Map<String, BulkSmsCampaign>
    state running_campaigns: Set<String>
    state suppression_list: Set<String>
    state on_progress: Option<fn(String, BulkStats)>
    state on_complete: Option<fn(String, BulkStats)>
    
    fn new(sender: SmsSender) -> Self {
        BulkSmsRunner {
            sender: sender,
            campaigns: Map.empty(),
            running_campaigns: Set.new(),
            suppression_list: Set.new(),
            on_progress: None,
            on_complete: None
        }
    }
    
    fn on_progress(callback: fn(String, BulkStats)) -> Self { self.on_progress = Some(callback); self }
    fn on_complete(callback: fn(String, BulkStats)) -> Self { self.on_complete = Some(callback); self }
    
    fn add_to_suppression_list(phones: [String]) {
        for phone in phones {
            self.suppression_list.insert(phone)
        }
    }
    
    fn remove_from_suppression_list(phone: String) {
        self.suppression_list.remove(phone)
    }
    
    fn create(campaign: BulkSmsCampaign) -> Result<String, BulkSmsError> {
        campaign.validate()?
        
        var campaign = campaign
        
        // Deduplicate if enabled
        if campaign.settings.deduplicate {
            campaign = self.deduplicate_recipients(campaign)
        }
        
        // Update stats
        campaign.stats.total = campaign.recipients.len()
        campaign.stats.pending = campaign.recipients.len()
        
        let id = campaign.id.clone()
        self.campaigns.set(id.clone(), campaign)
        Ok(id)
    }
    
    fn start(campaign_id: String) -> Result<(), BulkSmsError> {
        let campaign = self.campaigns.get_mut(campaign_id.clone())
            .ok_or(BulkSmsError.CampaignNotFound)?
        
        if campaign.status != CampaignStatus.Draft && campaign.status != CampaignStatus.Scheduled {
            return Err(BulkSmsError.InvalidStatus("Campaign cannot be started"))
        }
        
        campaign.status = CampaignStatus.Running
        campaign.started_at = Some(Instant.now())
        campaign.stats.start_time = Some(Instant.now())
        
        self.running_campaigns.insert(campaign_id.clone())
        
        spawn { self.run_campaign(campaign_id) }
        
        Ok(())
    }
    
    fn pause(campaign_id: String) -> Result<(), BulkSmsError> {
        let campaign = self.campaigns.get_mut(campaign_id.clone())
            .ok_or(BulkSmsError.CampaignNotFound)?
        
        if campaign.status == CampaignStatus.Running {
            campaign.status = CampaignStatus.Paused
            self.running_campaigns.remove(campaign_id)
        }
        Ok(())
    }
    
    fn resume(campaign_id: String) -> Result<(), BulkSmsError> {
        let campaign = self.campaigns.get_mut(campaign_id.clone())
            .ok_or(BulkSmsError.CampaignNotFound)?
        
        if campaign.status == CampaignStatus.Paused {
            campaign.status = CampaignStatus.Running
            self.running_campaigns.insert(campaign_id.clone())
            spawn { self.run_campaign(campaign_id) }
        }
        Ok(())
    }
    
    fn cancel(campaign_id: String) -> Result<(), BulkSmsError> {
        let campaign = self.campaigns.get_mut(campaign_id.clone())
            .ok_or(BulkSmsError.CampaignNotFound)?
        
        campaign.status = CampaignStatus.Cancelled
        self.running_campaigns.remove(campaign_id)
        Ok(())
    }
    
    fn run_campaign(campaign_id: String) {
        let campaign = match self.campaigns.get_mut(campaign_id.clone()) {
            Some(c) => c,
            None => return
        }
        
        let batch_size = campaign.settings.batch_size
        let delay = campaign.settings.batch_delay_ms
        let skip_invalid = campaign.settings.skip_invalid
        
        // Get pending recipients
        let pending_indices: Vec<Int> = campaign.recipients.iter()
            .enumerate()
            .filter(|(_, r)| r.status == RecipientStatus.Pending)
            .map(|(i, _)| i)
            .collect()
        
        for chunk in pending_indices.chunks(batch_size) {
            // Check if still running
            if !self.running_campaigns.contains(&campaign_id) {
                break
            }
            
            // Check quiet hours
            if campaign.settings.respect_quiet_hours && self.is_quiet_hours(&campaign.settings) {
                @native("sleep", Duration.minutes(15))
                continue
            }
            
            // Process batch
            for idx in chunk {
                let recipient = match campaign.recipients.get_mut(*idx) {
                    Some(r) => r,
                    None => continue
                }
                
                // Check suppression list
                if self.suppression_list.contains(&recipient.phone) {
                    recipient.status = RecipientStatus.Skipped
                    campaign.stats.skipped += 1
                    campaign.stats.pending -= 1
                    continue
                }
                
                // Build message
                let message_text = self.build_message(campaign, recipient)
                
                // Validate phone
                if skip_invalid && !self.is_valid_phone(&recipient.phone) {
                    recipient.status = RecipientStatus.Skipped
                    recipient.error = Some("Invalid phone number")
                    campaign.stats.skipped += 1
                    campaign.stats.pending -= 1
                    continue
                }
                
                // Send SMS
                match self.sender.send(recipient.phone.clone(), message_text) {
                    Ok(result) => {
                        recipient.status = RecipientStatus.Sent
                        recipient.message_id = Some(result.message_id)
                        recipient.sent_at = Some(Instant.now())
                        campaign.stats.sent += 1
                        campaign.stats.pending -= 1
                        
                        if let Some(cost) = result.cost {
                            campaign.stats.cost += cost
                        }
                    }
                    Err(e) => {
                        recipient.status = RecipientStatus.Failed
                        recipient.error = Some(e.to_string())
                        campaign.stats.failed += 1
                        campaign.stats.pending -= 1
                    }
                }
            }
            
            // Progress callback
            if let Some(callback) = self.on_progress {
                callback(campaign_id.clone(), campaign.stats.clone())
            }
            
            // Batch delay
            @native("sleep", Duration.milliseconds(delay))
        }
        
        // Retry failed if enabled
        if campaign.settings.retry_failed && campaign.stats.failed > 0 {
            self.retry_failed_recipients(campaign_id.clone())
        }
        
        // Complete campaign
        if self.running_campaigns.contains(&campaign_id) {
            campaign.status = CampaignStatus.Completed
            campaign.completed_at = Some(Instant.now())
            campaign.stats.end_time = Some(Instant.now())
            self.running_campaigns.remove(campaign_id.clone())
            
            if let Some(callback) = self.on_complete {
                callback(campaign_id, campaign.stats.clone())
            }
        }
    }
    
    fn retry_failed_recipients(campaign_id: String) {
        let campaign = match self.campaigns.get_mut(campaign_id.clone()) {
            Some(c) => c,
            None => return
        }
        
        let retry_count = campaign.settings.retry_count
        
        for _ in 0..retry_count {
            let failed_indices: Vec<Int> = campaign.recipients.iter()
                .enumerate()
                .filter(|(_, r)| r.status == RecipientStatus.Failed)
                .map(|(i, _)| i)
                .collect()
            
            if failed_indices.is_empty() { break }
            
            for idx in failed_indices {
                let recipient = match campaign.recipients.get_mut(idx) {
                    Some(r) => r,
                    None => continue
                }
                
                let message_text = self.build_message(campaign, recipient)
                
                match self.sender.send(recipient.phone.clone(), message_text) {
                    Ok(result) => {
                        recipient.status = RecipientStatus.Sent
                        recipient.message_id = Some(result.message_id)
                        recipient.sent_at = Some(Instant.now())
                        recipient.error = None
                        campaign.stats.sent += 1
                        campaign.stats.failed -= 1
                    }
                    Err(_) => {
                        // Keep as failed
                    }
                }
            }
            
            @native("sleep", Duration.seconds(5))
        }
    }
    
    fn build_message(campaign: &BulkSmsCampaign, recipient: &BulkRecipient) -> String {
        if let Some(ref template) = campaign.template {
            template.render(recipient.variables.clone()).unwrap_or(campaign.message.clone())
        } else {
            var msg = campaign.message.clone()
            for (key, value) in recipient.variables.iter() {
                msg = msg.replace(format!("{{{}}}", key).as_str(), value.as_str())
            }
            msg
        }
    }
    
    fn deduplicate_recipients(campaign: BulkSmsCampaign) -> BulkSmsCampaign {
        var seen = Set.new()
        var unique_recipients = Vec.new()
        
        for recipient in campaign.recipients {
            if !seen.contains(&recipient.phone) {
                seen.insert(recipient.phone.clone())
                unique_recipients.push(recipient)
            }
        }
        
        var campaign = campaign
        campaign.recipients = unique_recipients
        campaign
    }
    
    fn is_quiet_hours(settings: &BulkSettings) -> Bool {
        if !settings.respect_quiet_hours { return false }
        
        let (start, end) = match (settings.quiet_hours_start, settings.quiet_hours_end) {
            (Some(s), Some(e)) => (s, e),
            _ => return false
        }
        
        let now = @native("current_hour_in_tz", settings.timezone.clone())
        
        if start < end {
            now >= start && now < end
        } else {
            now >= start || now < end
        }
    }
    
    fn is_valid_phone(phone: &String) -> Bool {
        let cleaned: String = phone.chars().filter(|c| c.is_digit(10)).collect()
        cleaned.len() >= 10 && cleaned.len() <= 15
    }
    
    fn get(campaign_id: String) -> Option<BulkSmsCampaign> {
        self.campaigns.get(campaign_id).cloned()
    }
    
    fn get_stats(campaign_id: String) -> Option<BulkStats> {
        self.campaigns.get(campaign_id).map(|c| c.stats.clone())
    }
    
    fn list() -> [BulkSmsCampaign] {
        self.campaigns.values().cloned().collect()
    }
    
    fn list_running() -> [String] {
        self.running_campaigns.iter().cloned().collect()
    }
}

// =============================================================================
// Bulk SMS Builder
// =============================================================================

struct BulkSmsBuilder {
    sender: SmsSender
    campaign: BulkSmsCampaign
}

impl BulkSmsBuilder {
    fn new(sender: SmsSender, name: String) -> Self {
        BulkSmsBuilder {
            sender: sender,
            campaign: BulkSmsCampaign.new(name)
        }
    }
    
    fn message(msg: String) -> Self { self.campaign = self.campaign.message(msg); self }
    fn template(t: SmsTemplate) -> Self { self.campaign = self.campaign.template(t); self }
    fn from(sender: String) -> Self { self.campaign = self.campaign.from(sender); self }
    fn to(phone: String) -> Self { self.campaign = self.campaign.add_recipient(phone); self }
    fn to_many(phones: [String]) -> Self { self.campaign = self.campaign.add_recipients(phones); self }
    fn to_with_vars(phone: String, vars: Map<String, String>) -> Self { self.campaign = self.campaign.add_recipient_with_vars(phone, vars); self }
    fn batch_size(size: Int) -> Self { self.campaign.settings = self.campaign.settings.batch_size(size); self }
    fn batch_delay(ms: Int64) -> Self { self.campaign.settings = self.campaign.settings.batch_delay(ms); self }
    fn schedule(time: Instant) -> Self { self.campaign = self.campaign.schedule(time); self }
    
    fn build() -> BulkSmsCampaign { self.campaign.clone() }
    
    fn send() -> Result<BulkStats, BulkSmsError> {
        self.campaign.validate()?
        
        var stats = BulkStats.new()
        stats.total = self.campaign.recipients.len()
        stats.start_time = Some(Instant.now())
        
        for recipient in self.campaign.recipients.iter_mut() {
            let message_text = if let Some(ref template) = self.campaign.template {
                template.render(recipient.variables.clone()).unwrap_or(self.campaign.message.clone())
            } else {
                self.campaign.message.clone()
            }
            
            match self.sender.send(recipient.phone.clone(), message_text) {
                Ok(result) => {
                    recipient.status = RecipientStatus.Sent
                    recipient.message_id = Some(result.message_id)
                    stats.sent += 1
                    if let Some(cost) = result.cost {
                        stats.cost += cost
                    }
                }
                Err(e) => {
                    recipient.status = RecipientStatus.Failed
                    recipient.error = Some(e.to_string())
                    stats.failed += 1
                }
            }
        }
        
        stats.end_time = Some(Instant.now())
        Ok(stats)
    }
}

// =============================================================================
// Import/Export
// =============================================================================

struct BulkSmsExporter {
    campaign: BulkSmsCampaign
}

impl BulkSmsExporter {
    fn new(campaign: BulkSmsCampaign) -> Self {
        BulkSmsExporter { campaign: campaign }
    }
    
    fn to_csv() -> String {
        var lines = Vec.new()
        lines.push("phone,status,message_id,sent_at,error")
        
        for recipient in self.campaign.recipients.iter() {
            let status = match recipient.status {
                RecipientStatus.Pending => "pending",
                RecipientStatus.Queued => "queued",
                RecipientStatus.Sent => "sent",
                RecipientStatus.Delivered => "delivered",
                RecipientStatus.Failed => "failed",
                RecipientStatus.Skipped => "skipped",
                RecipientStatus.Unsubscribed => "unsubscribed"
            }
            
            let sent_at = recipient.sent_at.map(|t| t.to_iso8601()).unwrap_or_default()
            let error = recipient.error.clone().unwrap_or_default()
            let message_id = recipient.message_id.clone().unwrap_or_default()
            
            lines.push(format!("{},{},{},{},{}", recipient.phone, status, message_id, sent_at, error))
        }
        
        lines.join("\n")
    }
    
    fn to_json() -> String {
        @native("json_serialize", self.campaign)
    }
    
    fn failed_only() -> [BulkRecipient] {
        self.campaign.recipients.iter()
            .filter(|r| r.status == RecipientStatus.Failed)
            .cloned()
            .collect()
    }
    
    fn successful_only() -> [BulkRecipient] {
        self.campaign.recipients.iter()
            .filter(|r| r.status == RecipientStatus.Sent || r.status == RecipientStatus.Delivered)
            .cloned()
            .collect()
    }
}

// =============================================================================
// Errors
// =============================================================================

enum BulkSmsError {
    CampaignNotFound
    ValidationError(String)
    InvalidStatus(String)
    SendError(String)
    ImportError(String)
}

impl Display for BulkSmsError {
    fn fmt(f: Formatter) {
        match self {
            CampaignNotFound => f.write("Campaign not found"),
            ValidationError(msg) => f.write(format!("Validation error: {}", msg)),
            InvalidStatus(msg) => f.write(format!("Invalid status: {}", msg)),
            SendError(msg) => f.write(format!("Send error: {}", msg)),
            ImportError(msg) => f.write(format!("Import error: {}", msg))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "bulk campaign creation" {
    let campaign = BulkSmsCampaign.new("Test Campaign")
        .message("Hello {name}!")
        .from("+15551234567")
        .add_recipient("+15559876543")
        .add_recipient("+15551112222")
    
    assert_eq(campaign.name, "Test Campaign")?
    assert_eq(campaign.recipient_count(), 2)?
}

test "bulk settings" {
    let settings = BulkSettings.default()
        .batch_size(50)
        .batch_delay(2000)
        .quiet_hours(22, 8, "America/New_York")
    
    assert_eq(settings.batch_size, 50)?
    assert(settings.respect_quiet_hours)?
}

test "bulk stats" {
    let stats = BulkStats {
        total: 100,
        pending: 0,
        queued: 0,
        sent: 90,
        delivered: 85,
        failed: 10,
        skipped: 0,
        cost: 4.5,
        currency: "USD",
        start_time: None,
        end_time: None
    }
    
    assert_eq(stats.success_rate(), 0.9)?
    assert_eq(stats.failure_rate(), 0.1)?
}

test "recipient with variables" {
    let campaign = BulkSmsCampaign.new("Test")
        .message("Hello {name}, your code is {code}")
        .from("+1234")
    
    var vars = Map.empty()
    vars.set("name", "John")
    vars.set("code", "123456")
    
    let campaign = campaign.add_recipient_with_vars("+5678", vars)
    
    assert_eq(campaign.recipients[0].variables.get("name"), Some("John"))?
}

test "campaign validation" {
    let invalid = BulkSmsCampaign.new("Test")
    assert(invalid.validate().is_err())?
    
    let valid = BulkSmsCampaign.new("Test")
        .message("Hello")
        .from("+1234")
        .add_recipient("+5678")
    assert(valid.validate().is_ok())?
}

test "csv export" {
    var campaign = BulkSmsCampaign.new("Test")
        .message("Hello")
        .from("+1234")
        .add_recipient("+5678")
    
    campaign.recipients[0].status = RecipientStatus.Sent
    campaign.recipients[0].message_id = Some("MSG123")
    
    let exporter = BulkSmsExporter.new(campaign)
    let csv = exporter.to_csv()
    
    assert(csv.contains("+5678"))?
    assert(csv.contains("sent"))?
    assert(csv.contains("MSG123"))?
}
