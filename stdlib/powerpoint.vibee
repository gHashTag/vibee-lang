// =============================================================================
// Vibee OS â€” PowerPoint Module
// Reading, writing, and manipulating PowerPoint presentations (.pptx)
// =============================================================================

use fs::{File, IoError}
use image::Image

// =============================================================================
// Presentation
// =============================================================================

/// PowerPoint presentation
struct Presentation {
    handle: @native("PptxPresentationHandle")
    path: Option<String>
    slides: [Slide]
}

impl Presentation {
    fn new() -> Self {
        let handle = @native("pptx_presentation_new")
        Presentation { handle: handle, path: None, slides: [] }
    }
    
    fn open(path: String) -> Result<Self, PptxError> {
        let handle = @native("pptx_presentation_open", path)?
        let slides = @native("pptx_presentation_slides", handle)?
        Ok(Presentation { handle: handle, path: Some(path), slides: slides })
    }
    
    fn from_bytes(data: [UInt8]) -> Result<Self, PptxError> {
        let handle = @native("pptx_presentation_from_bytes", data)?
        let slides = @native("pptx_presentation_slides", handle)?
        Ok(Presentation { handle: handle, path: None, slides: slides })
    }
    
    fn slide(index: Int) -> Result<Slide, PptxError> {
        if index < 0 || index >= self.slides.len() {
            return Err(PptxError.SlideNotFound(index))
        }
        Ok(self.slides[index].clone())
    }
    
    fn add_slide(layout: SlideLayout) -> Slide {
        let slide = Slide.new(layout)
        @native("pptx_presentation_add_slide", self.handle, slide.handle)
        self.slides.push(slide.clone())
        slide
    }
    
    fn add_blank_slide() -> Slide { self.add_slide(SlideLayout.Blank) }
    fn add_title_slide() -> Slide { self.add_slide(SlideLayout.Title) }
    
    fn remove_slide(index: Int) -> Result<(), PptxError> {
        if index < 0 || index >= self.slides.len() {
            return Err(PptxError.SlideNotFound(index))
        }
        @native("pptx_presentation_remove_slide", self.handle, index)?
        self.slides.remove(index)
        Ok(())
    }
    
    fn move_slide(from: Int, to: Int) -> Result<(), PptxError> {
        @native("pptx_presentation_move_slide", self.handle, from, to)
    }
    
    fn slide_count() -> Int { self.slides.len() }
    
    fn properties() -> PresentationProperties {
        @native("pptx_presentation_properties", self.handle)
    }
    
    fn set_properties(props: PresentationProperties) {
        @native("pptx_presentation_set_properties", self.handle, props)
    }
    
    fn slide_size() -> SlideSize { @native("pptx_presentation_slide_size", self.handle) }
    fn set_slide_size(size: SlideSize) { @native("pptx_presentation_set_slide_size", self.handle, size) }
    
    fn save(path: String) -> Result<(), PptxError> {
        @native("pptx_presentation_save", self.handle, path)
    }
    
    fn to_bytes() -> Result<[UInt8], PptxError> {
        @native("pptx_presentation_to_bytes", self.handle)
    }
    
    fn to_pdf(path: String) -> Result<(), PptxError> {
        @native("pptx_presentation_to_pdf", self.handle, path)
    }
    
    fn close() { @native("pptx_presentation_close", self.handle) }
}

impl Drop for Presentation { fn drop() { self.close() } }

// =============================================================================
// Slide
// =============================================================================

struct Slide {
    handle: @native("PptxSlideHandle")
    layout: SlideLayout
    shapes: [Shape]
}

impl Slide {
    fn new(layout: SlideLayout) -> Self {
        let handle = @native("pptx_slide_new", layout)
        Slide { handle: handle, layout: layout, shapes: [] }
    }
    
    fn add_text_box(x: Float64, y: Float64, width: Float64, height: Float64) -> TextBox {
        let tb = TextBox.new(x, y, width, height)
        @native("pptx_slide_add_shape", self.handle, tb.handle)
        self.shapes.push(Shape.TextBox(tb.clone()))
        tb
    }
    
    fn add_title(text: String) -> TextBox {
        let tb = self.add_text_box(50.0, 50.0, 620.0, 80.0)
        tb.set_text(text)
        tb.font_size(44.0)
        tb
    }
    
    fn add_subtitle(text: String) -> TextBox {
        let tb = self.add_text_box(50.0, 150.0, 620.0, 60.0)
        tb.set_text(text)
        tb.font_size(24.0)
        tb
    }
    
    fn add_image(path: String, x: Float64, y: Float64) -> Result<ImageShape, PptxError> {
        let img = ImageShape.from_file(path, x, y)?
        @native("pptx_slide_add_shape", self.handle, img.handle)
        self.shapes.push(Shape.Image(img.clone()))
        Ok(img)
    }
    
    fn add_shape(shape_type: ShapeType, x: Float64, y: Float64, w: Float64, h: Float64) -> BasicShape {
        let shape = BasicShape.new(shape_type, x, y, w, h)
        @native("pptx_slide_add_shape", self.handle, shape.handle)
        self.shapes.push(Shape.Basic(shape.clone()))
        shape
    }
    
    fn add_table(rows: Int, cols: Int, x: Float64, y: Float64) -> SlideTable {
        let table = SlideTable.new(rows, cols, x, y)
        @native("pptx_slide_add_shape", self.handle, table.handle)
        self.shapes.push(Shape.Table(table.clone()))
        table
    }
    
    fn add_chart(chart: SlideChart, x: Float64, y: Float64) -> SlideChart {
        @native("pptx_slide_add_chart", self.handle, chart.handle, x, y)
        chart
    }
    
    fn background(bg: Background) { @native("pptx_slide_set_background", self.handle, bg) }
    fn notes() -> String { @native("pptx_slide_notes", self.handle) }
    fn set_notes(notes: String) { @native("pptx_slide_set_notes", self.handle, notes) }
    
    fn render(dpi: Float64) -> Result<Image, PptxError> {
        @native("pptx_slide_render", self.handle, dpi)
    }
}

enum SlideLayout { Blank, Title, TitleContent, TwoContent, Comparison, TitleOnly, SectionHeader }

// =============================================================================
// Shapes
// =============================================================================

enum Shape {
    TextBox(TextBox)
    Image(ImageShape)
    Basic(BasicShape)
    Table(SlideTable)
}

struct TextBox {
    handle: @native("PptxTextBoxHandle")
    x: Float64
    y: Float64
    width: Float64
    height: Float64
}

impl TextBox {
    fn new(x: Float64, y: Float64, w: Float64, h: Float64) -> Self {
        let handle = @native("pptx_textbox_new", x, y, w, h)
        TextBox { handle: handle, x: x, y: y, width: w, height: h }
    }
    
    fn text() -> String { @native("pptx_textbox_text", self.handle) }
    fn set_text(text: String) -> Self { @native("pptx_textbox_set_text", self.handle, text); self }
    fn font(name: String) -> Self { @native("pptx_textbox_set_font", self.handle, name); self }
    fn font_size(size: Float64) -> Self { @native("pptx_textbox_set_font_size", self.handle, size); self }
    fn bold() -> Self { @native("pptx_textbox_set_bold", self.handle, true); self }
    fn italic() -> Self { @native("pptx_textbox_set_italic", self.handle, true); self }
    fn color(hex: String) -> Self { @native("pptx_textbox_set_color", self.handle, hex); self }
    fn align(a: TextAlign) -> Self { @native("pptx_textbox_set_align", self.handle, a); self }
    fn fill(color: String) -> Self { @native("pptx_textbox_set_fill", self.handle, color); self }
    fn border(color: String, width: Float64) -> Self { @native("pptx_textbox_set_border", self.handle, color, width); self }
}

enum TextAlign { Left, Center, Right, Justify }

struct ImageShape {
    handle: @native("PptxImageHandle")
    x: Float64
    y: Float64
    width: Float64
    height: Float64
}

impl ImageShape {
    fn from_file(path: String, x: Float64, y: Float64) -> Result<Self, PptxError> {
        let handle = @native("pptx_image_from_file", path)?
        let (w, h) = @native("pptx_image_size", handle)
        Ok(ImageShape { handle: handle, x: x, y: y, width: w, height: h })
    }
    
    fn resize(w: Float64, h: Float64) -> Self { self.width = w; self.height = h; @native("pptx_image_resize", self.handle, w, h); self }
    fn scale(factor: Float64) -> Self { self.resize(self.width * factor, self.height * factor) }
    fn move_to(x: Float64, y: Float64) -> Self { self.x = x; self.y = y; @native("pptx_image_move", self.handle, x, y); self }
}

struct BasicShape {
    handle: @native("PptxShapeHandle")
    shape_type: ShapeType
}

impl BasicShape {
    fn new(t: ShapeType, x: Float64, y: Float64, w: Float64, h: Float64) -> Self {
        let handle = @native("pptx_shape_new", t, x, y, w, h)
        BasicShape { handle: handle, shape_type: t }
    }
    
    fn fill(color: String) -> Self { @native("pptx_shape_set_fill", self.handle, color); self }
    fn border(color: String, width: Float64) -> Self { @native("pptx_shape_set_border", self.handle, color, width); self }
    fn text(t: String) -> Self { @native("pptx_shape_set_text", self.handle, t); self }
    fn rotation(degrees: Float64) -> Self { @native("pptx_shape_set_rotation", self.handle, degrees); self }
}

enum ShapeType { Rectangle, RoundedRect, Ellipse, Triangle, Diamond, Arrow, Star, Line, Callout }

// =============================================================================
// Table and Chart
// =============================================================================

struct SlideTable {
    handle: @native("PptxTableHandle")
    rows: Int
    cols: Int
}

impl SlideTable {
    fn new(rows: Int, cols: Int, x: Float64, y: Float64) -> Self {
        let handle = @native("pptx_table_new", rows, cols, x, y)
        SlideTable { handle: handle, rows: rows, cols: cols }
    }
    
    fn set_cell(row: Int, col: Int, text: String) { @native("pptx_table_set_cell", self.handle, row, col, text) }
    fn cell_style(row: Int, col: Int, style: CellStyle) { @native("pptx_table_cell_style", self.handle, row, col, style) }
    fn header_row(texts: [String]) { for (i, t) in texts.iter().enumerate() { self.set_cell(0, i, t.clone()) } }
}

struct CellStyle { fill: Option<String>, font_size: Option<Float64>, bold: Bool }

struct SlideChart { handle: @native("PptxChartHandle"), chart_type: ChartType }

impl SlideChart {
    fn new(t: ChartType) -> Self { SlideChart { handle: @native("pptx_chart_new", t), chart_type: t } }
    fn bar() -> Self { Self.new(ChartType.Bar) }
    fn line() -> Self { Self.new(ChartType.Line) }
    fn pie() -> Self { Self.new(ChartType.Pie) }
    
    fn title(t: String) -> Self { @native("pptx_chart_set_title", self.handle, t); self }
    fn add_series(name: String, values: [Float64]) -> Self { @native("pptx_chart_add_series", self.handle, name, values); self }
    fn categories(cats: [String]) -> Self { @native("pptx_chart_set_categories", self.handle, cats); self }
}

enum ChartType { Bar, Column, Line, Pie, Area, Scatter, Doughnut }

// =============================================================================
// Background and Properties
// =============================================================================

enum Background { Solid(String), Gradient(String, String), Image(String) }

struct SlideSize { width: Float64, height: Float64 }
impl SlideSize {
    fn standard() -> Self { SlideSize { width: 720.0, height: 540.0 } }
    fn widescreen() -> Self { SlideSize { width: 960.0, height: 540.0 } }
}

struct PresentationProperties { title: Option<String>, author: Option<String>, subject: Option<String> }

// =============================================================================
// Convenience Functions
// =============================================================================

fn open(path: String) -> Result<Presentation, PptxError> { Presentation.open(path) }
fn create() -> Presentation { Presentation.new() }

// =============================================================================
// Errors
// =============================================================================

enum PptxError { FileNotFound(String), InvalidFormat, SlideNotFound(Int), IoError(IoError), Other(String) }

impl Display for PptxError {
    fn fmt(f: Formatter) {
        match self {
            FileNotFound(p) => f.write(format!("File not found: {}", p))
            SlideNotFound(i) => f.write(format!("Slide not found: {}", i))
            _ => f.write("PowerPoint error")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create presentation" {
    let pres = Presentation.new()
    pres.add_title_slide()
    assert_eq(pres.slide_count(), 1)?
}

test "slide size" {
    let std = SlideSize.standard()
    let wide = SlideSize.widescreen()
    assert_eq(std.height, wide.height)?
}
