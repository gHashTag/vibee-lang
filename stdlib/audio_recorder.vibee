// =============================================================================
// Vibee OS â€” Audio Recorder Module
// Professional audio recording with multi-track support
// =============================================================================

use audio::{AudioBuffer, AudioClip, AudioFormat, Sample, SampleFormat, ChannelLayout, AudioError}
use datetime::{DateTime}
use fs::{File}

/// Recording state
enum RecordingState {
    Idle,
    Recording,
    Paused,
    Stopped
    
    fn is_active() -> Bool {
        match self {
            Recording | Paused => true,
            _ => false
        }
    }
}

/// Audio input device
struct AudioInputDevice {
    id: String
    name: String
    channels: Int
    sample_rates: [Int]
    default_sample_rate: Int
    
    fn new(id: String, name: String) -> Self {
        AudioInputDevice {
            id: id,
            name: name,
            channels: 2,
            sample_rates: [44100, 48000, 96000],
            default_sample_rate: 44100
        }
    }
    
    fn list_devices() -> [Self] {
        @native("audio_list_input_devices")
    }
    
    fn default_device() -> Option<Self> {
        @native("audio_default_input_device")
    }
}

/// Recording configuration
struct RecordingConfig {
    sample_rate: Int
    channels: Int
    sample_format: SampleFormat
    buffer_size: Int
    input_device: Option<AudioInputDevice>
    
    fn new() -> Self {
        RecordingConfig {
            sample_rate: 44100,
            channels: 2,
            sample_format: SampleFormat.F32,
            buffer_size: 1024,
            input_device: None
        }
    }
    
    fn mono() -> Self {
        RecordingConfig {
            sample_rate: 44100,
            channels: 1,
            sample_format: SampleFormat.F32,
            buffer_size: 1024,
            input_device: None
        }
    }
    
    fn high_quality() -> Self {
        RecordingConfig {
            sample_rate: 96000,
            channels: 2,
            sample_format: SampleFormat.F32,
            buffer_size: 512,
            input_device: None
        }
    }
    
    fn with_device(device: AudioInputDevice) -> Self {
        self.input_device = Some(device)
        self
    }
    
    fn with_sample_rate(rate: Int) -> Self {
        self.sample_rate = rate
        self
    }
    
    fn with_channels(channels: Int) -> Self {
        self.channels = channels.clamp(1, 8)
        self
    }
}

/// Recording session metadata
struct RecordingMetadata {
    name: String
    created_at: DateTime
    duration: Float64
    sample_rate: Int
    channels: Int
    format: SampleFormat
    file_path: Option<String>
    tags: [String]
    notes: String
    
    fn new(name: String) -> Self {
        RecordingMetadata {
            name: name,
            created_at: DateTime.now(),
            duration: 0.0,
            sample_rate: 44100,
            channels: 2,
            format: SampleFormat.F32,
            file_path: None,
            tags: [],
            notes: ""
        }
    }
    
    fn add_tag(tag: String) {
        self.tags.push(tag)
    }
}

/// Recording marker for navigation
struct Marker {
    id: Int
    name: String
    position: Float64    // Position in seconds
    color: String
    
    fn new(id: Int, name: String, position: Float64) -> Self {
        Marker { id: id, name: name, position: position, color: "#FF0000" }
    }
}

/// Recording region for selection
struct Region {
    id: Int
    name: String
    start: Float64
    end: Float64
    color: String
    
    fn new(id: Int, name: String, start: Float64, end: Float64) -> Self {
        Region { id: id, name: name, start: start, end: end, color: "#0000FF" }
    }
    
    fn duration() -> Float64 {
        self.end - self.start
    }
}

/// Single track recorder
actor AudioRecorder {
    state config: RecordingConfig
    state state: RecordingState
    state buffer: AudioBuffer
    state metadata: RecordingMetadata
    state markers: [Marker]
    state regions: [Region]
    state input_level: Float64
    state monitoring: Bool
    state punch_in: Option<Float64>
    state punch_out: Option<Float64>
    
    fn new(config: RecordingConfig) -> Self {
        AudioRecorder {
            config: config,
            state: RecordingState.Idle,
            buffer: AudioBuffer.new(config.channels, config.sample_rate),
            metadata: RecordingMetadata.new("Untitled Recording"),
            markers: [],
            regions: [],
            input_level: 1.0,
            monitoring: false,
            punch_in: None,
            punch_out: None
        }
    }
    
    fn default() -> Self {
        AudioRecorder.new(RecordingConfig.new())
    }
    
    fn set_name(name: String) {
        self.metadata.name = name
    }
    
    fn set_input_level(level: Float64) {
        self.input_level = level.clamp(0.0, 2.0)
    }
    
    fn set_monitoring(enabled: Bool) {
        self.monitoring = enabled
    }
    
    fn set_punch_in(time: Float64) {
        self.punch_in = Some(time)
    }
    
    fn set_punch_out(time: Float64) {
        self.punch_out = Some(time)
    }
    
    fn clear_punch() {
        self.punch_in = None
        self.punch_out = None
    }
    
    fn start() -> Result<(), AudioError> {
        if self.state == RecordingState.Recording {
            return Err(AudioError.PlaybackError("Already recording"))
        }
        
        self.state = RecordingState.Recording
        self.buffer = AudioBuffer.new(self.config.channels, self.config.sample_rate)
        @native("audio_recorder_start", self)
        Ok(())
    }
    
    fn pause() {
        if self.state == RecordingState.Recording {
            self.state = RecordingState.Paused
            @native("audio_recorder_pause", self)
        }
    }
    
    fn resume() {
        if self.state == RecordingState.Paused {
            self.state = RecordingState.Recording
            @native("audio_recorder_resume", self)
        }
    }
    
    fn stop() -> AudioBuffer {
        self.state = RecordingState.Stopped
        @native("audio_recorder_stop", self)
        self.metadata.duration = self.buffer.duration()
        self.buffer.clone()
    }
    
    fn add_marker(name: String) {
        let position = self.buffer.duration()
        let id = self.markers.len()
        self.markers.push(Marker.new(id, name, position))
    }
    
    fn add_region(name: String, start: Float64, end: Float64) {
        let id = self.regions.len()
        self.regions.push(Region.new(id, name, start, end))
    }
    
    fn get_duration() -> Float64 {
        self.buffer.duration()
    }
    
    fn get_state() -> RecordingState {
        self.state
    }
    
    fn get_peak_level() -> Float64 {
        @native("audio_recorder_peak_level", self)
    }
    
    fn get_rms_level() -> Float64 {
        @native("audio_recorder_rms_level", self)
    }
    
    fn save(path: String, format: AudioFormat) -> Result<(), AudioError> {
        let clip = AudioClip.new(self.buffer.clone())
        clip.save(path, format)?
        self.metadata.file_path = Some(path)
        Ok(())
    }
    
    fn export_region(region: Region, path: String, format: AudioFormat) -> Result<(), AudioError> {
        let trimmed = self.buffer.trim_seconds(region.start, region.end)
        let clip = AudioClip.new(trimmed)
        clip.save(path, format)
    }
}

/// Multi-track recorder
actor MultiTrackRecorder {
    state tracks: [RecorderTrack]
    state config: RecordingConfig
    state state: RecordingState
    state master_buffer: Option<AudioBuffer>
    state tempo: Float64
    state time_signature: (Int, Int)
    state metronome_enabled: Bool
    state count_in_bars: Int
    
    fn new(config: RecordingConfig) -> Self {
        MultiTrackRecorder {
            tracks: [],
            config: config,
            state: RecordingState.Idle,
            master_buffer: None,
            tempo: 120.0,
            time_signature: (4, 4),
            metronome_enabled: false,
            count_in_bars: 0
        }
    }
    
    fn add_track(name: String) -> Int {
        let id = self.tracks.len()
        self.tracks.push(RecorderTrack.new(id, name, self.config.clone()))
        id
    }
    
    fn remove_track(id: Int) {
        self.tracks = self.tracks.filter(|t| t.id != id)
    }
    
    fn get_track(id: Int) -> Option<RecorderTrack> {
        self.tracks.iter().find(|t| t.id == id)
    }
    
    fn arm_track(id: Int, armed: Bool) {
        if let Some(track) = self.get_track(id) {
            track.armed = armed
        }
    }
    
    fn mute_track(id: Int, muted: Bool) {
        if let Some(track) = self.get_track(id) {
            track.muted = muted
        }
    }
    
    fn solo_track(id: Int, solo: Bool) {
        if let Some(track) = self.get_track(id) {
            track.solo = solo
        }
    }
    
    fn set_track_volume(id: Int, volume: Float64) {
        if let Some(track) = self.get_track(id) {
            track.volume = volume.clamp(0.0, 1.0)
        }
    }
    
    fn set_track_pan(id: Int, pan: Float64) {
        if let Some(track) = self.get_track(id) {
            track.pan = pan.clamp(-1.0, 1.0)
        }
    }
    
    fn set_tempo(tempo: Float64) {
        self.tempo = tempo.clamp(20.0, 300.0)
    }
    
    fn set_time_signature(numerator: Int, denominator: Int) {
        self.time_signature = (numerator, denominator)
    }
    
    fn set_metronome(enabled: Bool) {
        self.metronome_enabled = enabled
    }
    
    fn set_count_in(bars: Int) {
        self.count_in_bars = bars.max(0)
    }
    
    fn start() -> Result<(), AudioError> {
        if self.state == RecordingState.Recording {
            return Err(AudioError.PlaybackError("Already recording"))
        }
        
        // Check if any track is armed
        let armed_tracks = self.tracks.filter(|t| t.armed)
        if armed_tracks.is_empty() {
            return Err(AudioError.PlaybackError("No tracks armed for recording"))
        }
        
        self.state = RecordingState.Recording
        
        // Start count-in if enabled
        if self.count_in_bars > 0 && self.metronome_enabled {
            @native("multitrack_count_in", self)
        }
        
        // Start recording on armed tracks
        for track in armed_tracks {
            track.start_recording()
        }
        
        @native("multitrack_recorder_start", self)
        Ok(())
    }
    
    fn stop() {
        self.state = RecordingState.Stopped
        for track in self.tracks {
            if track.armed {
                track.stop_recording()
            }
        }
        @native("multitrack_recorder_stop", self)
    }
    
    fn pause() {
        if self.state == RecordingState.Recording {
            self.state = RecordingState.Paused
            @native("multitrack_recorder_pause", self)
        }
    }
    
    fn mixdown() -> AudioBuffer {
        var result = AudioBuffer.new(2, self.config.sample_rate)
        let has_solo = self.tracks.any(|t| t.solo)
        
        for track in self.tracks {
            if track.muted { continue }
            if has_solo && !track.solo { continue }
            
            if let Some(buf) = track.get_buffer() {
                let processed = buf.amplify(track.volume)
                let panned = apply_pan(processed, track.pan)
                result = mix_buffers(result, panned)
            }
        }
        
        self.master_buffer = Some(result.clone())
        result
    }
    
    fn export(path: String, format: AudioFormat) -> Result<(), AudioError> {
        let mixed = self.mixdown()
        let clip = AudioClip.new(mixed)
        clip.save(path, format)
    }
    
    fn export_stems(directory: String, format: AudioFormat) -> Result<(), AudioError> {
        for track in self.tracks {
            if let Some(buf) = track.get_buffer() {
                let path = format!("{}/{}.{}", directory, track.name, format.extension())
                let clip = AudioClip.new(buf)
                clip.save(path, format)?
            }
        }
        Ok(())
    }
}

/// Individual track in multi-track recorder
struct RecorderTrack {
    id: Int
    name: String
    config: RecordingConfig
    buffer: Option<AudioBuffer>
    armed: Bool
    muted: Bool
    solo: Bool
    volume: Float64
    pan: Float64
    input_channel: Int
    monitoring: Bool
    
    fn new(id: Int, name: String, config: RecordingConfig) -> Self {
        RecorderTrack {
            id: id,
            name: name,
            config: config,
            buffer: None,
            armed: false,
            muted: false,
            solo: false,
            volume: 1.0,
            pan: 0.0,
            input_channel: 0,
            monitoring: false
        }
    }
    
    fn start_recording() {
        self.buffer = Some(AudioBuffer.new(self.config.channels, self.config.sample_rate))
        @native("track_start_recording", self)
    }
    
    fn stop_recording() {
        @native("track_stop_recording", self)
    }
    
    fn get_buffer() -> Option<AudioBuffer> {
        self.buffer.clone()
    }
    
    fn clear() {
        self.buffer = None
    }
    
    fn get_duration() -> Float64 {
        if let Some(buf) = self.buffer {
            buf.duration()
        } else { 0.0 }
    }
}

/// Loop recorder for live looping
actor LoopRecorder {
    state loops: [LoopLayer]
    state config: RecordingConfig
    state state: RecordingState
    state loop_length: Option<Float64>
    state current_position: Float64
    state playing: Bool
    state overdub: Bool
    
    fn new(config: RecordingConfig) -> Self {
        LoopRecorder {
            loops: [],
            config: config,
            state: RecordingState.Idle,
            loop_length: None,
            current_position: 0.0,
            playing: false,
            overdub: false
        }
    }
    
    fn record() {
        if self.state == RecordingState.Idle {
            // First loop - start recording
            self.state = RecordingState.Recording
            self.loops.push(LoopLayer.new(self.loops.len(), self.config.clone()))
            @native("loop_recorder_start", self)
        } else if self.state == RecordingState.Recording && self.loop_length.is_none() {
            // End first loop - set loop length
            self.loop_length = Some(self.current_position)
            self.state = RecordingState.Stopped
            self.playing = true
            @native("loop_recorder_set_length", self)
        }
    }
    
    fn overdub_start() {
        if self.loop_length.is_some() {
            self.overdub = true
            self.loops.push(LoopLayer.new(self.loops.len(), self.config.clone()))
            @native("loop_recorder_overdub_start", self)
        }
    }
    
    fn overdub_stop() {
        self.overdub = false
        @native("loop_recorder_overdub_stop", self)
    }
    
    fn undo() {
        if self.loops.len() > 1 {
            self.loops.pop()
        }
    }
    
    fn clear() {
        self.loops.clear()
        self.loop_length = None
        self.state = RecordingState.Idle
        self.playing = false
    }
    
    fn set_layer_volume(layer: Int, volume: Float64) {
        if layer < self.loops.len() {
            self.loops[layer].volume = volume.clamp(0.0, 1.0)
        }
    }
    
    fn mute_layer(layer: Int, muted: Bool) {
        if layer < self.loops.len() {
            self.loops[layer].muted = muted
        }
    }
    
    fn get_mixed_output() -> AudioBuffer {
        var result = AudioBuffer.new(self.config.channels, self.config.sample_rate)
        for loop in self.loops {
            if !loop.muted {
                if let Some(buf) = loop.buffer {
                    result = mix_buffers(result, buf.amplify(loop.volume))
                }
            }
        }
        result
    }
}

/// Single loop layer
struct LoopLayer {
    id: Int
    buffer: Option<AudioBuffer>
    volume: Float64
    muted: Bool
    
    fn new(id: Int, config: RecordingConfig) -> Self {
        LoopLayer {
            id: id,
            buffer: Some(AudioBuffer.new(config.channels, config.sample_rate)),
            volume: 1.0,
            muted: false
        }
    }
}

/// Utility functions
fn apply_pan(buffer: AudioBuffer, pan: Float64) -> AudioBuffer {
    if buffer.channels != 2 { return buffer }
    var result = buffer.clone()
    let left_gain = ((1.0 - pan) / 2.0).sqrt()
    let right_gain = ((1.0 + pan) / 2.0).sqrt()
    for i in 0..result.num_samples() {
        result.samples[0][i] = result.samples[0][i].amplify(left_gain)
        result.samples[1][i] = result.samples[1][i].amplify(right_gain)
    }
    result
}

fn mix_buffers(a: AudioBuffer, b: AudioBuffer) -> AudioBuffer {
    a.mix(b, 0.5).amplify(2.0)
}

// Tests
test "recording config" {
    let config = RecordingConfig.high_quality()
    assert_eq(config.sample_rate, 96000)?
    assert_eq(config.channels, 2)?
}

test "recorder state" {
    let recorder = AudioRecorder.default()
    assert_eq(recorder.get_state(), RecordingState.Idle)?
}

test "multi-track add tracks" {
    var recorder = MultiTrackRecorder.new(RecordingConfig.new())
    let id1 = recorder.add_track("Vocals")
    let id2 = recorder.add_track("Guitar")
    assert_eq(recorder.tracks.len(), 2)?
}

test "marker creation" {
    let marker = Marker.new(0, "Verse 1", 10.5)
    assert_eq(marker.position, 10.5)?
}

test "region duration" {
    let region = Region.new(0, "Chorus", 30.0, 45.0)
    assert_eq(region.duration(), 15.0)?
}
