// =============================================================================
// Vibee OS â€” Args Module
// Command-line argument parsing
// =============================================================================

// -----------------------------------------------------------------------------
// Argument Types
// -----------------------------------------------------------------------------

/// Argument value type
enum ArgValue {
    String(String)
    Int(Int)
    Float(Float64)
    Bool(Bool)
    List([String])
    
    fn as_string() -> Option<String> {
        match self { .String(s) => Some(s), _ => None }
    }
    
    fn as_int() -> Option<Int> {
        match self {
            .Int(i) => Some(i)
            .String(s) => s.parse_int().ok()
            _ => None
        }
    }
    
    fn as_float() -> Option<Float64> {
        match self {
            .Float(f) => Some(f)
            .Int(i) => Some(i as Float64)
            .String(s) => s.parse_float().ok()
            _ => None
        }
    }
    
    fn as_bool() -> Option<Bool> {
        match self {
            .Bool(b) => Some(b)
            .String(s) => match s.to_lowercase() {
                "true" | "yes" | "1" | "on" => Some(true)
                "false" | "no" | "0" | "off" => Some(false)
                _ => None
            }
            _ => None
        }
    }
    
    fn as_list() -> Option<[String]> {
        match self {
            .List(l) => Some(l)
            .String(s) => Some([s])
            _ => None
        }
    }
}

// -----------------------------------------------------------------------------
// Argument Definition
// -----------------------------------------------------------------------------

/// Argument definition
struct Arg {
    name: String
    short: Option<Char>
    long: Option<String>
    description: String
    required: Bool
    default_value: Option<ArgValue>
    value_name: String
    takes_value: Bool
    multiple: Bool
    possible_values: [String]
    env_var: Option<String>
    hidden: Bool
    
    /// Create new argument
    fn new(name: String) -> Self {
        Arg {
            name: name,
            short: None,
            long: None,
            description: "",
            required: false,
            default_value: None,
            value_name: "VALUE",
            takes_value: true,
            multiple: false,
            possible_values: [],
            env_var: None,
            hidden: false
        }
    }
    
    /// Create positional argument
    fn positional(name: String) -> Self {
        Arg.new(name)
    }
    
    /// Create flag (boolean argument)
    fn flag(name: String) -> Self {
        Arg.new(name)
            .takes_value(false)
            .default(ArgValue.Bool(false))
    }
    
    /// Set short option (-x)
    fn short(c: Char) -> Self {
        self.short = Some(c)
        self
    }
    
    /// Set long option (--name)
    fn long(s: String) -> Self {
        self.long = Some(s)
        self
    }
    
    /// Set description
    fn description(s: String) -> Self {
        self.description = s
        self
    }
    
    /// Alias for description
    fn help(s: String) -> Self {
        self.description(s)
    }
    
    /// Mark as required
    fn required(r: Bool = true) -> Self {
        self.required = r
        self
    }
    
    /// Set default value
    fn default(v: ArgValue) -> Self {
        self.default_value = Some(v)
        self
    }
    
    /// Set default string value
    fn default_str(s: String) -> Self {
        self.default(ArgValue.String(s))
    }
    
    /// Set default int value
    fn default_int(i: Int) -> Self {
        self.default(ArgValue.Int(i))
    }
    
    /// Set value name for help
    fn value_name(s: String) -> Self {
        self.value_name = s
        self
    }
    
    /// Set whether argument takes a value
    fn takes_value(b: Bool) -> Self {
        self.takes_value = b
        self
    }
    
    /// Allow multiple values
    fn multiple(b: Bool = true) -> Self {
        self.multiple = b
        self
    }
    
    /// Set possible values
    fn possible_values(values: [String]) -> Self {
        self.possible_values = values
        self
    }
    
    /// Set environment variable fallback
    fn env(var: String) -> Self {
        self.env_var = Some(var)
        self
    }
    
    /// Hide from help
    fn hidden(b: Bool = true) -> Self {
        self.hidden = b
        self
    }
    
    /// Check if this is a positional argument
    fn is_positional() -> Bool {
        self.short.is_none() && self.long.is_none()
    }
    
    /// Get display name for help
    fn display_name() -> String {
        if let Some(l) = self.long {
            format!("--{}", l)
        } else if let Some(s) = self.short {
            format!("-{}", s)
        } else {
            format!("<{}>", self.name)
        }
    }
}

// -----------------------------------------------------------------------------
// Parsed Results
// -----------------------------------------------------------------------------

/// Parsed arguments result
struct ArgMatches {
    values: Map<String, ArgValue>
    positional: [String]
    subcommand: Option<(String, ArgMatches)>
    
    fn new() -> Self {
        ArgMatches {
            values: Map.new(),
            positional: [],
            subcommand: None
        }
    }
    
    /// Get string value
    fn get(name: String) -> Option<String> {
        self.values.get(name)?.as_string()
    }
    
    /// Get string value or default
    fn get_or(name: String, default: String) -> String {
        self.get(name).unwrap_or(default)
    }
    
    /// Get int value
    fn get_int(name: String) -> Option<Int> {
        self.values.get(name)?.as_int()
    }
    
    /// Get int value or default
    fn get_int_or(name: String, default: Int) -> Int {
        self.get_int(name).unwrap_or(default)
    }
    
    /// Get float value
    fn get_float(name: String) -> Option<Float64> {
        self.values.get(name)?.as_float()
    }
    
    /// Get bool value (flag)
    fn get_bool(name: String) -> Bool {
        self.values.get(name)
            .and_then(|v| v.as_bool())
            .unwrap_or(false)
    }
    
    /// Alias for get_bool
    fn is_present(name: String) -> Bool {
        self.get_bool(name)
    }
    
    /// Get list of values
    fn get_many(name: String) -> Option<[String]> {
        self.values.get(name)?.as_list()
    }
    
    /// Get positional argument by index
    fn positional_at(index: Int) -> Option<String> {
        self.positional.get(index)
    }
    
    /// Get subcommand name and matches
    fn subcommand() -> Option<(String, ArgMatches)> {
        self.subcommand.clone()
    }
    
    /// Check if subcommand was used
    fn has_subcommand(name: String) -> Bool {
        self.subcommand.map(|(n, _)| n == name).unwrap_or(false)
    }
    
    /// Get number of occurrences
    fn occurrences(name: String) -> Int {
        match self.values.get(name) {
            Some(ArgValue.List(l)) => l.len()
            Some(_) => 1
            None => 0
        }
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

/// Argument parser error
enum ArgError {
    MissingRequired(String)
    InvalidValue(String, String)
    UnknownArgument(String)
    MissingValue(String)
    InvalidSubcommand(String)
    TooManyPositional
    
    fn message() -> String {
        match self {
            .MissingRequired(name) => format!("Missing required argument: {}", name)
            .InvalidValue(name, value) => format!("Invalid value '{}' for argument '{}'", value, name)
            .UnknownArgument(name) => format!("Unknown argument: {}", name)
            .MissingValue(name) => format!("Argument '{}' requires a value", name)
            .InvalidSubcommand(name) => format!("Unknown subcommand: {}", name)
            .TooManyPositional => "Too many positional arguments"
        }
    }
}

// -----------------------------------------------------------------------------
// Subcommand
// -----------------------------------------------------------------------------

/// Subcommand definition
struct Subcommand {
    name: String
    description: String
    args: [Arg]
    aliases: [String]
    hidden: Bool
    
    fn new(name: String) -> Self {
        Subcommand {
            name: name,
            description: "",
            args: [],
            aliases: [],
            hidden: false
        }
    }
    
    fn description(s: String) -> Self {
        self.description = s
        self
    }
    
    fn about(s: String) -> Self {
        self.description(s)
    }
    
    fn arg(a: Arg) -> Self {
        self.args.push(a)
        self
    }
    
    fn args(args: [Arg]) -> Self {
        self.args.extend(args)
        self
    }
    
    fn alias(s: String) -> Self {
        self.aliases.push(s)
        self
    }
    
    fn hidden(b: Bool = true) -> Self {
        self.hidden = b
        self
    }
}

// -----------------------------------------------------------------------------
// Argument Parser
// -----------------------------------------------------------------------------

/// Command-line argument parser
actor ArgParser {
    state name: String
    state version: String
    state description: String
    state author: String
    state args: [Arg]
    state subcommands: [Subcommand]
    
    /// Create new parser
    init(name: String) {
        self.name = name
        self.version = "1.0.0"
        self.description = ""
        self.author = ""
        self.args = []
        self.subcommands = []
    }
    
    /// Set version
    on version(v: String) -> Self {
        self.version = v
        self
    }
    
    /// Set description
    on description(d: String) -> Self {
        self.description = d
        self
    }
    
    /// Alias for description
    on about(d: String) -> Self {
        self.description(d)
    }
    
    /// Set author
    on author(a: String) -> Self {
        self.author = a
        self
    }
    
    /// Add argument
    on arg(a: Arg) -> Self {
        self.args.push(a)
        self
    }
    
    /// Add multiple arguments
    on args(args: [Arg]) -> Self {
        self.args.extend(args)
        self
    }
    
    /// Add subcommand
    on subcommand(s: Subcommand) -> Self {
        self.subcommands.push(s)
        self
    }
    
    /// Parse arguments from command line
    on parse() -> Result<ArgMatches, ArgError> {
        self.parse_from(Environment.args())
    }
    
    /// Parse arguments from array
    on parse_from(args: [String]) -> Result<ArgMatches, ArgError> {
        var matches = ArgMatches.new()
        var positional_index = 0
        var i = 1  // Skip program name
        
        let positional_args = self.args.iter()
            .filter(|a| a.is_positional())
            .collect()
        
        while i < args.len() {
            let arg = args[i]
            
            // Check for help flag
            if arg == "-h" || arg == "--help" {
                print(self.help())
                Process.exit(0)
            }
            
            // Check for version flag
            if arg == "-V" || arg == "--version" {
                println!("{} {}", self.name, self.version)
                Process.exit(0)
            }
            
            if arg.starts_with("--") {
                // Long option
                let (name, value) = if arg.contains("=") {
                    let parts = arg[2..].split_once("=")
                    (parts.0, Some(parts.1))
                } else {
                    (arg[2..].to_string(), None)
                }
                
                if let Some(arg_def) = self.find_arg_by_long(name) {
                    if arg_def.takes_value {
                        let val = if let Some(v) = value {
                            v
                        } else {
                            i += 1
                            if i >= args.len() {
                                return Err(ArgError.MissingValue(name))
                            }
                            args[i].clone()
                        }
                        
                        // Validate possible values
                        if !arg_def.possible_values.is_empty() {
                            if !arg_def.possible_values.contains(val) {
                                return Err(ArgError.InvalidValue(name, val))
                            }
                        }
                        
                        if arg_def.multiple {
                            let list = matches.values.get(arg_def.name)
                                .and_then(|v| v.as_list())
                                .unwrap_or([])
                            list.push(val)
                            matches.values.insert(arg_def.name.clone(), ArgValue.List(list))
                        } else {
                            matches.values.insert(arg_def.name.clone(), ArgValue.String(val))
                        }
                    } else {
                        matches.values.insert(arg_def.name.clone(), ArgValue.Bool(true))
                    }
                } else {
                    return Err(ArgError.UnknownArgument(format!("--{}", name)))
                }
            } else if arg.starts_with("-") && arg.len() > 1 {
                // Short option(s)
                let chars = arg[1..].chars()
                for (idx, c) in chars.enumerate() {
                    if let Some(arg_def) = self.find_arg_by_short(c) {
                        if arg_def.takes_value {
                            let val = if idx < chars.len() - 1 {
                                arg[(idx + 2)..].to_string()
                            } else {
                                i += 1
                                if i >= args.len() {
                                    return Err(ArgError.MissingValue(arg_def.name.clone()))
                                }
                                args[i].clone()
                            }
                            matches.values.insert(arg_def.name.clone(), ArgValue.String(val))
                            break
                        } else {
                            matches.values.insert(arg_def.name.clone(), ArgValue.Bool(true))
                        }
                    } else {
                        return Err(ArgError.UnknownArgument(format!("-{}", c)))
                    }
                }
            } else {
                // Check for subcommand
                if let Some(subcmd) = self.find_subcommand(arg) {
                    let sub_parser = ArgParser.new(subcmd.name.clone())
                        .args(subcmd.args.clone())
                    let sub_args = args[(i + 1)..].to_vec()
                    let sub_matches = sub_parser.parse_from(
                        [""].iter().chain(sub_args.iter()).collect()
                    )?
                    matches.subcommand = Some((subcmd.name.clone(), sub_matches))
                    break
                }
                
                // Positional argument
                if positional_index < positional_args.len() {
                    let arg_def = positional_args[positional_index]
                    if arg_def.multiple {
                        let list = matches.values.get(arg_def.name)
                            .and_then(|v| v.as_list())
                            .unwrap_or([])
                        list.push(arg.clone())
                        matches.values.insert(arg_def.name.clone(), ArgValue.List(list))
                    } else {
                        matches.values.insert(arg_def.name.clone(), ArgValue.String(arg.clone()))
                        positional_index += 1
                    }
                }
                matches.positional.push(arg.clone())
            }
            
            i += 1
        }
        
        // Apply defaults and check required
        for arg_def in self.args.iter() {
            if !matches.values.contains_key(arg_def.name) {
                // Check environment variable
                if let Some(env_var) = arg_def.env_var {
                    if let Some(val) = Environment.get(env_var) {
                        matches.values.insert(arg_def.name.clone(), ArgValue.String(val))
                        continue
                    }
                }
                
                // Apply default
                if let Some(default) = arg_def.default_value {
                    matches.values.insert(arg_def.name.clone(), default.clone())
                } else if arg_def.required {
                    return Err(ArgError.MissingRequired(arg_def.name.clone()))
                }
            }
        }
        
        Ok(matches)
    }
    
    /// Find argument by long name
    fn find_arg_by_long(name: String) -> Option<Arg> {
        self.args.iter().find(|a| a.long == Some(name.clone()))
    }
    
    /// Find argument by short name
    fn find_arg_by_short(c: Char) -> Option<Arg> {
        self.args.iter().find(|a| a.short == Some(c))
    }
    
    /// Find subcommand by name or alias
    fn find_subcommand(name: String) -> Option<Subcommand> {
        self.subcommands.iter().find(|s| {
            s.name == name || s.aliases.contains(name)
        })
    }
    
    /// Generate help text
    on help() -> String {
        var help = String.new()
        
        // Header
        help.push_str(format!("{} {}\n", self.name, self.version))
        if !self.author.is_empty() {
            help.push_str(format!("{}\n", self.author))
        }
        if !self.description.is_empty() {
            help.push_str(format!("{}\n", self.description))
        }
        help.push_str("\n")
        
        // Usage
        help.push_str("USAGE:\n")
        help.push_str(format!("    {} [OPTIONS]", self.name))
        
        let positional_args = self.args.iter()
            .filter(|a| a.is_positional() && !a.hidden)
            .collect()
        
        for arg in positional_args.iter() {
            if arg.required {
                help.push_str(format!(" <{}>", arg.name))
            } else {
                help.push_str(format!(" [{}]", arg.name))
            }
        }
        
        if !self.subcommands.is_empty() {
            help.push_str(" [SUBCOMMAND]")
        }
        help.push_str("\n\n")
        
        // Options
        let options = self.args.iter()
            .filter(|a| !a.is_positional() && !a.hidden)
            .collect()
        
        if !options.is_empty() {
            help.push_str("OPTIONS:\n")
            for arg in options.iter() {
                var line = "    "
                if let Some(s) = arg.short {
                    line.push_str(format!("-{}", s))
                    if arg.long.is_some() {
                        line.push_str(", ")
                    }
                } else {
                    line.push_str("    ")
                }
                if let Some(l) = arg.long {
                    line.push_str(format!("--{}", l))
                }
                if arg.takes_value {
                    line.push_str(format!(" <{}>", arg.value_name))
                }
                
                while line.len() < 30 {
                    line.push(' ')
                }
                line.push_str(arg.description)
                
                if let Some(default) = arg.default_value {
                    line.push_str(format!(" [default: {:?}]", default))
                }
                
                help.push_str(line)
                help.push_str("\n")
            }
            help.push_str("\n")
        }
        
        // Positional arguments
        if !positional_args.is_empty() {
            help.push_str("ARGS:\n")
            for arg in positional_args.iter() {
                var line = format!("    <{}>", arg.name)
                while line.len() < 30 {
                    line.push(' ')
                }
                line.push_str(arg.description)
                help.push_str(line)
                help.push_str("\n")
            }
            help.push_str("\n")
        }
        
        // Subcommands
        let visible_subcommands = self.subcommands.iter()
            .filter(|s| !s.hidden)
            .collect()
        
        if !visible_subcommands.is_empty() {
            help.push_str("SUBCOMMANDS:\n")
            for subcmd in visible_subcommands.iter() {
                var line = format!("    {}", subcmd.name)
                while line.len() < 30 {
                    line.push(' ')
                }
                line.push_str(subcmd.description)
                help.push_str(line)
                help.push_str("\n")
            }
        }
        
        help
    }
    
    /// Parse and exit on error
    on parse_or_exit() -> ArgMatches {
        match self.parse() {
            Ok(matches) => matches
            Err(e) => {
                eprintln!("error: {}", e.message())
                eprintln!("\nFor more information try --help")
                Process.exit(1)
            }
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Create new argument parser
fn parser(name: String) -> ArgParser {
    ArgParser.new(name)
}

/// Create new argument
fn arg(name: String) -> Arg {
    Arg.new(name)
}

/// Create flag argument
fn flag(name: String) -> Arg {
    Arg.flag(name)
}

/// Create positional argument
fn positional(name: String) -> Arg {
    Arg.positional(name)
}

/// Create subcommand
fn subcommand(name: String) -> Subcommand {
    Subcommand.new(name)
}

/// Get raw command line arguments
fn raw_args() -> [String] {
    Environment.args()
}

/// Get arguments without program name
fn args_without_program() -> [String] {
    Environment.args()[1..].to_vec()
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "basic parsing" {
    let parser = ArgParser.new("test")
        .arg(Arg.new("output").short('o').long("output").description("Output file"))
        .arg(Arg.flag("verbose").short('v').long("verbose"))
    
    let matches = parser.parse_from(["test", "-o", "file.txt", "-v"])?
    
    assert_eq(matches.get("output"), Some("file.txt"))?
    assert(matches.get_bool("verbose"))?
}

test "positional arguments" {
    let parser = ArgParser.new("test")
        .arg(Arg.positional("input").required(true))
        .arg(Arg.positional("output"))
    
    let matches = parser.parse_from(["test", "in.txt", "out.txt"])?
    
    assert_eq(matches.get("input"), Some("in.txt"))?
    assert_eq(matches.get("output"), Some("out.txt"))?
}

test "default values" {
    let parser = ArgParser.new("test")
        .arg(Arg.new("port").long("port").default_int(8080))
    
    let matches = parser.parse_from(["test"])?
    
    assert_eq(matches.get_int("port"), Some(8080))?
}

test "required argument missing" {
    let parser = ArgParser.new("test")
        .arg(Arg.new("config").long("config").required(true))
    
    let result = parser.parse_from(["test"])
    assert(result.is_err())?
}

test "subcommands" {
    let parser = ArgParser.new("git")
        .subcommand(
            Subcommand.new("clone")
                .description("Clone a repository")
                .arg(Arg.positional("url").required(true))
        )
    
    let matches = parser.parse_from(["git", "clone", "https://github.com/example/repo"])?
    
    assert(matches.has_subcommand("clone"))?
    let (name, sub_matches) = matches.subcommand()?
    assert_eq(name, "clone")?
    assert_eq(sub_matches.get("url"), Some("https://github.com/example/repo"))?
}

test "multiple values" {
    let parser = ArgParser.new("test")
        .arg(Arg.new("file").short('f').multiple(true))
    
    let matches = parser.parse_from(["test", "-f", "a.txt", "-f", "b.txt"])?
    
    let files = matches.get_many("file")?
    assert_eq(files.len(), 2)?
    assert_eq(files[0], "a.txt")?
}

test "possible values validation" {
    let parser = ArgParser.new("test")
        .arg(Arg.new("level").long("level").possible_values(["debug", "info", "warn", "error"]))
    
    let result = parser.parse_from(["test", "--level", "invalid"])
    assert(result.is_err())?
    
    let matches = parser.parse_from(["test", "--level", "info"])?
    assert_eq(matches.get("level"), Some("info"))?
}
