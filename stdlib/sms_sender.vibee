// =============================================================================
// Vibee OS â€” SMS Sender Module
// Core SMS sending functionality with provider abstraction
// =============================================================================

use http.{HttpClient, Request, Response}
use json.{JsonValue, Serialize, Deserialize}

// =============================================================================
// SMS Message
// =============================================================================

/// SMS message structure
struct SmsMessage {
    id: String
    from: String
    to: String
    body: String
    media_urls: [String]
    scheduled_at: Option<Instant>
    callback_url: Option<String>
    metadata: Map<String, String>
    status: SmsStatus
    created_at: Instant
    sent_at: Option<Instant>
    delivered_at: Option<Instant>
}

impl SmsMessage {
    fn new(to: String, body: String) -> Self {
        SmsMessage {
            id: UUID.v4(),
            from: "",
            to: to,
            body: body,
            media_urls: [],
            scheduled_at: None,
            callback_url: None,
            metadata: Map.empty(),
            status: SmsStatus.Pending,
            created_at: Instant.now(),
            sent_at: None,
            delivered_at: None
        }
    }
    
    fn from(sender: String) -> Self { self.from = sender; self }
    fn to(recipient: String) -> Self { self.to = recipient; self }
    fn body(text: String) -> Self { self.body = text; self }
    fn media(url: String) -> Self { self.media_urls.push(url); self }
    fn schedule(time: Instant) -> Self { self.scheduled_at = Some(time); self }
    fn callback(url: String) -> Self { self.callback_url = Some(url); self }
    fn meta(key: String, value: String) -> Self { self.metadata.set(key, value); self }
    
    fn is_mms() -> Bool { !self.media_urls.is_empty() }
    fn char_count() -> Int { self.body.len() }
    fn segment_count() -> Int {
        let len = self.body.len()
        if len <= 160 { 1 }
        else { (len + 152) / 153 }  // Multi-part messages use 153 chars per segment
    }
    
    fn is_pending() -> Bool { self.status == SmsStatus.Pending }
    fn is_sent() -> Bool { self.status == SmsStatus.Sent }
    fn is_delivered() -> Bool { self.status == SmsStatus.Delivered }
    fn is_failed() -> Bool { self.status == SmsStatus.Failed }
    
    fn validate() -> Result<(), SmsError> {
        if self.to.is_empty() { return Err(SmsError.InvalidRecipient("Recipient is required")) }
        if self.body.is_empty() && self.media_urls.is_empty() { return Err(SmsError.InvalidMessage("Message body or media is required")) }
        if self.body.len() > 1600 { return Err(SmsError.InvalidMessage("Message too long (max 1600 chars)")) }
        Ok(())
    }
}

// =============================================================================
// SMS Status
// =============================================================================

enum SmsStatus {
    Pending
    Queued
    Sending
    Sent
    Delivered
    Failed
    Undelivered
    Cancelled
}

impl Display for SmsStatus {
    fn fmt(f: Formatter) {
        match self {
            Pending => f.write("pending"),
            Queued => f.write("queued"),
            Sending => f.write("sending"),
            Sent => f.write("sent"),
            Delivered => f.write("delivered"),
            Failed => f.write("failed"),
            Undelivered => f.write("undelivered"),
            Cancelled => f.write("cancelled")
        }
    }
}

// =============================================================================
// SMS Provider Trait
// =============================================================================

/// Trait for SMS providers
trait SmsProvider {
    fn name() -> String
    fn send(message: SmsMessage) -> Result<SmsResult, SmsError>
    fn send_batch(messages: [SmsMessage]) -> [Result<SmsResult, SmsError>]
    fn get_status(message_id: String) -> Result<SmsStatus, SmsError>
    fn cancel(message_id: String) -> Result<(), SmsError>
    fn get_balance() -> Result<Float, SmsError>
}

// =============================================================================
// SMS Result
// =============================================================================

struct SmsResult {
    message_id: String
    provider_id: String
    status: SmsStatus
    segments: Int
    cost: Option<Float>
    currency: Option<String>
    error_code: Option<String>
    error_message: Option<String>
}

impl SmsResult {
    fn new(message_id: String, provider_id: String) -> Self {
        SmsResult {
            message_id: message_id,
            provider_id: provider_id,
            status: SmsStatus.Sent,
            segments: 1,
            cost: None,
            currency: None,
            error_code: None,
            error_message: None
        }
    }
    
    fn with_status(status: SmsStatus) -> Self { self.status = status; self }
    fn with_segments(count: Int) -> Self { self.segments = count; self }
    fn with_cost(amount: Float, currency: String) -> Self { self.cost = Some(amount); self.currency = Some(currency); self }
    fn with_error(code: String, message: String) -> Self { self.error_code = Some(code); self.error_message = Some(message); self }
    
    fn is_success() -> Bool { self.status == SmsStatus.Sent || self.status == SmsStatus.Delivered || self.status == SmsStatus.Queued }
}

// =============================================================================
// SMS Sender
// =============================================================================

/// Main SMS sender with provider support
struct SmsSender {
    provider: Box<dyn SmsProvider>
    default_from: Option<String>
    retry_count: Int
    retry_delay_ms: Int64
    rate_limit: Option<RateLimit>
}

struct RateLimit {
    max_per_second: Int
    max_per_minute: Int
    max_per_hour: Int
    current_second: Int
    current_minute: Int
    current_hour: Int
    last_reset: Instant
}

impl SmsSender {
    fn new(provider: Box<dyn SmsProvider>) -> Self {
        SmsSender {
            provider: provider,
            default_from: None,
            retry_count: 3,
            retry_delay_ms: 1000,
            rate_limit: None
        }
    }
    
    fn from(sender: String) -> Self { self.default_from = Some(sender); self }
    fn retries(count: Int) -> Self { self.retry_count = count; self }
    fn retry_delay(ms: Int64) -> Self { self.retry_delay_ms = ms; self }
    fn rate_limit(per_second: Int, per_minute: Int, per_hour: Int) -> Self {
        self.rate_limit = Some(RateLimit {
            max_per_second: per_second,
            max_per_minute: per_minute,
            max_per_hour: per_hour,
            current_second: 0,
            current_minute: 0,
            current_hour: 0,
            last_reset: Instant.now()
        })
        self
    }
    
    fn send(to: String, body: String) -> Result<SmsResult, SmsError> {
        let mut message = SmsMessage.new(to, body)
        if let Some(from) = self.default_from.clone() {
            message = message.from(from)
        }
        self.send_message(message)
    }
    
    fn send_message(message: SmsMessage) -> Result<SmsResult, SmsError> {
        message.validate()?
        
        if let Some(ref mut limit) = self.rate_limit {
            self.check_rate_limit(limit)?
        }
        
        var last_error: Option<SmsError> = None
        for attempt in 0..self.retry_count {
            match self.provider.send(message.clone()) {
                Ok(result) => return Ok(result),
                Err(e) => {
                    last_error = Some(e)
                    if attempt < self.retry_count - 1 {
                        @native("sleep", Duration.milliseconds(self.retry_delay_ms))
                    }
                }
            }
        }
        Err(last_error.unwrap_or(SmsError.SendFailed("Unknown error")))
    }
    
    fn send_batch(messages: [SmsMessage]) -> [Result<SmsResult, SmsError>] {
        messages.iter().map(|m| self.send_message(m.clone())).collect()
    }
    
    fn check_rate_limit(limit: &mut RateLimit) -> Result<(), SmsError> {
        let now = Instant.now()
        let elapsed = now.duration_since(limit.last_reset)
        
        if elapsed.as_secs() >= 3600 {
            limit.current_hour = 0
            limit.current_minute = 0
            limit.current_second = 0
            limit.last_reset = now
        } else if elapsed.as_secs() >= 60 {
            limit.current_minute = 0
            limit.current_second = 0
        } else if elapsed.as_secs() >= 1 {
            limit.current_second = 0
        }
        
        if limit.current_second >= limit.max_per_second {
            return Err(SmsError.RateLimited("Per-second limit exceeded"))
        }
        if limit.current_minute >= limit.max_per_minute {
            return Err(SmsError.RateLimited("Per-minute limit exceeded"))
        }
        if limit.current_hour >= limit.max_per_hour {
            return Err(SmsError.RateLimited("Per-hour limit exceeded"))
        }
        
        limit.current_second += 1
        limit.current_minute += 1
        limit.current_hour += 1
        Ok(())
    }
    
    fn get_status(message_id: String) -> Result<SmsStatus, SmsError> {
        self.provider.get_status(message_id)
    }
    
    fn get_balance() -> Result<Float, SmsError> {
        self.provider.get_balance()
    }
}

// =============================================================================
// Phone Number Utilities
// =============================================================================

/// Phone number validation and formatting
struct PhoneNumber {
    raw: String
    country_code: Option<String>
    national_number: String
    formatted: String
}

impl PhoneNumber {
    fn parse(number: String) -> Result<Self, SmsError> {
        let cleaned = number.chars().filter(|c| c.is_digit(10) || *c == '+').collect::<String>()
        
        if cleaned.is_empty() {
            return Err(SmsError.InvalidRecipient("Empty phone number"))
        }
        
        let (country_code, national) = if cleaned.starts_with("+") {
            let digits = cleaned[1..].to_string()
            if digits.len() < 10 {
                return Err(SmsError.InvalidRecipient("Phone number too short"))
            }
            // Simple extraction - first 1-3 digits as country code
            let cc_len = if digits.starts_with("1") { 1 } 
                        else if digits.len() > 11 { 2 } 
                        else { 1 }
            (Some(digits[0..cc_len].to_string()), digits[cc_len..].to_string())
        } else {
            (None, cleaned)
        }
        
        Ok(PhoneNumber {
            raw: number,
            country_code: country_code.clone(),
            national_number: national.clone(),
            formatted: match country_code {
                Some(cc) => format!("+{}{}", cc, national),
                None => national
            }
        })
    }
    
    fn e164() -> String { self.formatted.clone() }
    fn is_valid() -> Bool { self.national_number.len() >= 7 && self.national_number.len() <= 15 }
    
    fn with_country_code(code: String) -> Self {
        self.country_code = Some(code.clone())
        self.formatted = format!("+{}{}", code, self.national_number)
        self
    }
}

fn is_valid_phone(number: String) -> Bool {
    PhoneNumber.parse(number).map(|p| p.is_valid()).unwrap_or(false)
}

fn format_e164(number: String, default_country: String) -> Result<String, SmsError> {
    let phone = PhoneNumber.parse(number)?
    if phone.country_code.is_none() {
        Ok(phone.with_country_code(default_country).e164())
    } else {
        Ok(phone.e164())
    }
}

// =============================================================================
// Delivery Report
// =============================================================================

struct DeliveryReport {
    message_id: String
    status: SmsStatus
    timestamp: Instant
    error_code: Option<String>
    carrier: Option<String>
    price: Option<Float>
}

impl DeliveryReport {
    fn new(message_id: String, status: SmsStatus) -> Self {
        DeliveryReport {
            message_id: message_id,
            status: status,
            timestamp: Instant.now(),
            error_code: None,
            carrier: None,
            price: None
        }
    }
    
    fn with_error(code: String) -> Self { self.error_code = Some(code); self }
    fn with_carrier(carrier: String) -> Self { self.carrier = Some(carrier); self }
    fn with_price(price: Float) -> Self { self.price = Some(price); self }
}

// =============================================================================
// Webhook Handler
// =============================================================================

trait SmsWebhookHandler {
    fn on_sent(report: DeliveryReport)
    fn on_delivered(report: DeliveryReport)
    fn on_failed(report: DeliveryReport)
    fn on_received(message: IncomingSms)
}

struct IncomingSms {
    id: String
    from: String
    to: String
    body: String
    media_urls: [String]
    received_at: Instant
}

impl IncomingSms {
    fn new(from: String, to: String, body: String) -> Self {
        IncomingSms {
            id: UUID.v4(),
            from: from,
            to: to,
            body: body,
            media_urls: [],
            received_at: Instant.now()
        }
    }
    
    fn is_mms() -> Bool { !self.media_urls.is_empty() }
}

// =============================================================================
// Errors
// =============================================================================

enum SmsError {
    InvalidRecipient(String)
    InvalidMessage(String)
    InvalidSender(String)
    SendFailed(String)
    ProviderError(String)
    AuthenticationFailed
    InsufficientBalance
    RateLimited(String)
    NetworkError(String)
    Timeout
    NotFound
    Cancelled
}

impl Display for SmsError {
    fn fmt(f: Formatter) {
        match self {
            InvalidRecipient(msg) => f.write(format!("Invalid recipient: {}", msg)),
            InvalidMessage(msg) => f.write(format!("Invalid message: {}", msg)),
            InvalidSender(msg) => f.write(format!("Invalid sender: {}", msg)),
            SendFailed(msg) => f.write(format!("Send failed: {}", msg)),
            ProviderError(msg) => f.write(format!("Provider error: {}", msg)),
            AuthenticationFailed => f.write("Authentication failed"),
            InsufficientBalance => f.write("Insufficient balance"),
            RateLimited(msg) => f.write(format!("Rate limited: {}", msg)),
            NetworkError(msg) => f.write(format!("Network error: {}", msg)),
            Timeout => f.write("Request timeout"),
            NotFound => f.write("Message not found"),
            Cancelled => f.write("Message cancelled")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "sms message creation" {
    let msg = SmsMessage.new("+1234567890", "Hello World")
        .from("+0987654321")
        .meta("campaign", "test")
    
    assert_eq(msg.to, "+1234567890")?
    assert_eq(msg.body, "Hello World")?
    assert_eq(msg.segment_count(), 1)?
}

test "sms message validation" {
    let valid = SmsMessage.new("+1234567890", "Test")
    assert(valid.validate().is_ok())?
    
    let no_recipient = SmsMessage.new("", "Test")
    assert(no_recipient.validate().is_err())?
    
    let no_body = SmsMessage.new("+1234567890", "")
    assert(no_body.validate().is_err())?
}

test "segment count" {
    let short = SmsMessage.new("+1", "Hello")
    assert_eq(short.segment_count(), 1)?
    
    let long = SmsMessage.new("+1", "A".repeat(200))
    assert_eq(long.segment_count(), 2)?
}

test "phone number parsing" {
    let phone = PhoneNumber.parse("+14155551234")?
    assert_eq(phone.country_code, Some("1"))?
    assert(phone.is_valid())?
    
    let invalid = PhoneNumber.parse("")
    assert(invalid.is_err())?
}

test "e164 formatting" {
    let formatted = format_e164("5551234567", "1")?
    assert_eq(formatted, "+15551234567")?
}
