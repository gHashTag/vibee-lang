// =============================================================================
// Vibee OS â€” Fingerprint Module
// Data fingerprinting and similarity hashing
// =============================================================================
//
// This module provides algorithms for creating data fingerprints:
// - Content-based fingerprinting
// - SimHash (similarity-preserving hash)
// - MinHash (Jaccard similarity estimation)
// - Rabin fingerprinting (rolling hash)
// - Audio/Image perceptual hashing concepts
// - Document fingerprinting
// =============================================================================

// =============================================================================
// Basic Fingerprint
// =============================================================================

/// Generic fingerprint
struct Fingerprint {
    bytes: [UInt8]
    algorithm: FingerprintAlgorithm
}

impl Fingerprint {
    fn new(bytes: [UInt8], algorithm: FingerprintAlgorithm) -> Self {
        Fingerprint { bytes: bytes, algorithm: algorithm }
    }
    
    /// Create from hex string
    fn from_hex(hex: String, algorithm: FingerprintAlgorithm) -> Result<Self, FingerprintError> {
        let bytes = hex.decode_hex().map_err(|_| FingerprintError.InvalidHex)?
        Ok(Fingerprint { bytes: bytes, algorithm: algorithm })
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Compare fingerprints
    fn matches(other: Fingerprint) -> Bool {
        self.bytes == other.bytes
    }
    
    /// Hamming distance to another fingerprint
    fn hamming_distance(other: Fingerprint) -> Int {
        if self.bytes.len() != other.bytes.len() { return -1 }
        
        var distance = 0
        for i in 0..self.bytes.len() {
            var xor = self.bytes[i] ^ other.bytes[i]
            while xor != 0 {
                distance += (xor & 1) as Int
                xor >>= 1
            }
        }
        distance
    }
    
    /// Similarity (0.0 to 1.0) based on Hamming distance
    fn similarity(other: Fingerprint) -> Float64 {
        let distance = self.hamming_distance(other)
        if distance < 0 { return 0.0 }
        let total_bits = self.bytes.len() * 8
        1.0 - (distance as Float64 / total_bits as Float64)
    }
    
    /// Get bit at position
    fn bit_at(pos: Int) -> Bool {
        let byte_idx = pos / 8
        let bit_idx = pos % 8
        if byte_idx >= self.bytes.len() { return false }
        (self.bytes[byte_idx] >> bit_idx) & 1 == 1
    }
    
    /// Count set bits
    fn popcount() -> Int {
        var count = 0
        for byte in self.bytes {
            var b = byte
            while b != 0 {
                count += (b & 1) as Int
                b >>= 1
            }
        }
        count
    }
}

impl Display for Fingerprint {
    fn fmt(f: Formatter) {
        f.write(self.to_hex())
    }
}

impl Hash for Fingerprint {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

enum FingerprintAlgorithm {
    SimHash
    MinHash
    Rabin
    Content
    Perceptual
}

// =============================================================================
// SimHash (Similarity-Preserving Hash)
// =============================================================================

/// SimHash for text similarity detection
struct SimHash {
    bits: Int
}

impl SimHash {
    fn new() -> Self {
        SimHash { bits: 64 }
    }
    
    fn with_bits(bits: Int) -> Self {
        SimHash { bits: bits }
    }
    
    /// Compute SimHash of text
    fn hash(text: String) -> Fingerprint {
        self.hash_tokens(tokenize(text))
    }
    
    /// Compute SimHash from tokens
    fn hash_tokens(tokens: [String]) -> Fingerprint {
        var v = [0i64; self.bits]
        
        for token in tokens {
            let h = hash_token(token, self.bits)
            for i in 0..self.bits {
                if (h >> i) & 1 == 1 {
                    v[i] += 1
                } else {
                    v[i] -= 1
                }
            }
        }
        
        // Convert to fingerprint
        var bytes = [0u8; (self.bits + 7) / 8]
        for i in 0..self.bits {
            if v[i] > 0 {
                bytes[i / 8] |= 1u8 << (i % 8)
            }
        }
        
        Fingerprint.new(bytes, FingerprintAlgorithm.SimHash)
    }
    
    /// Compute similarity between two texts
    fn similarity(text1: String, text2: String) -> Float64 {
        let fp1 = self.hash(text1)
        let fp2 = self.hash(text2)
        fp1.similarity(fp2)
    }
}

fn hash_token(token: String, bits: Int) -> UInt64 {
    // FNV-1a hash
    var hash: UInt64 = 0xcbf29ce484222325
    for byte in token.as_bytes() {
        hash ^= byte as UInt64
        hash = hash.wrapping_mul(0x100000001b3)
    }
    hash
}

fn tokenize(text: String) -> [String] {
    text.to_lowercase()
        .split_whitespace()
        .filter(|s| s.len() >= 2)
        .collect()
}

/// Quick SimHash computation
fn simhash(text: String) -> Fingerprint {
    SimHash.new().hash(text)
}

/// SimHash similarity
fn simhash_similarity(text1: String, text2: String) -> Float64 {
    SimHash.new().similarity(text1, text2)
}

// =============================================================================
// MinHash (Jaccard Similarity Estimation)
// =============================================================================

/// MinHash for set similarity
struct MinHash {
    num_hashes: Int
    seeds: [UInt64]
}

impl MinHash {
    fn new(num_hashes: Int) -> Self {
        var seeds = []
        for i in 0..num_hashes {
            seeds.push(0x9e3779b97f4a7c15u64.wrapping_mul(i as UInt64 + 1))
        }
        MinHash { num_hashes: num_hashes, seeds: seeds }
    }
    
    /// Compute MinHash signature
    fn signature(elements: [String]) -> [UInt64] {
        var mins = [UInt64.MAX; self.num_hashes]
        
        for element in elements {
            let base_hash = hash_token(element, 64)
            for i in 0..self.num_hashes {
                let h = base_hash ^ self.seeds[i]
                if h < mins[i] {
                    mins[i] = h
                }
            }
        }
        
        mins
    }
    
    /// Estimate Jaccard similarity from signatures
    fn jaccard(sig1: [UInt64], sig2: [UInt64]) -> Float64 {
        if sig1.len() != sig2.len() { return 0.0 }
        
        var matches = 0
        for i in 0..sig1.len() {
            if sig1[i] == sig2[i] {
                matches += 1
            }
        }
        
        matches as Float64 / sig1.len() as Float64
    }
    
    /// Compute similarity between two sets
    fn similarity(set1: [String], set2: [String]) -> Float64 {
        let sig1 = self.signature(set1)
        let sig2 = self.signature(set2)
        self.jaccard(sig1, sig2)
    }
    
    /// Convert signature to fingerprint
    fn to_fingerprint(sig: [UInt64]) -> Fingerprint {
        var bytes = []
        for h in sig {
            for i in 0..8 {
                bytes.push(((h >> (i * 8)) & 0xFF) as UInt8)
            }
        }
        Fingerprint.new(bytes, FingerprintAlgorithm.MinHash)
    }
}

/// Quick MinHash similarity
fn minhash_similarity(set1: [String], set2: [String], num_hashes: Int) -> Float64 {
    MinHash.new(num_hashes).similarity(set1, set2)
}

// =============================================================================
// Rabin Fingerprint (Rolling Hash)
// =============================================================================

/// Rabin fingerprint for content-defined chunking
struct RabinFingerprint {
    polynomial: UInt64
    window_size: Int
    table: [UInt64; 256]
    out_table: [UInt64; 256]
}

impl RabinFingerprint {
    fn new(window_size: Int) -> Self {
        const POLY: UInt64 = 0xbfe6b8a5bf378d83
        let table = generate_rabin_table(POLY)
        let out_table = generate_rabin_out_table(POLY, window_size)
        RabinFingerprint { polynomial: POLY, window_size: window_size, table: table, out_table: out_table }
    }
    
    /// Compute fingerprint of data
    fn fingerprint(data: [UInt8]) -> UInt64 {
        var fp: UInt64 = 0
        for byte in data {
            fp = self.slide(fp, byte, 0)
        }
        fp
    }
    
    /// Slide window (add new byte, remove old byte)
    fn slide(fp: UInt64, new_byte: UInt8, old_byte: UInt8) -> UInt64 {
        let fp = (fp << 8) | new_byte as UInt64
        fp ^ self.table[(fp >> 56) as Int] ^ self.out_table[old_byte as Int]
    }
    
    /// Find chunk boundaries using fingerprint
    fn find_boundaries(data: [UInt8], mask: UInt64) -> [Int] {
        var boundaries = []
        var window = [0u8; self.window_size]
        var fp: UInt64 = 0
        var pos = 0
        
        for i in 0..data.len() {
            let old_byte = window[pos]
            window[pos] = data[i]
            pos = (pos + 1) % self.window_size
            
            fp = self.slide(fp, data[i], old_byte)
            
            if i >= self.window_size && (fp & mask) == 0 {
                boundaries.push(i)
            }
        }
        
        boundaries
    }
}

fn generate_rabin_table(poly: UInt64) -> [UInt64; 256] {
    var table = [0u64; 256]
    for i in 0..256 {
        var fp = i as UInt64
        for _ in 0..8 {
            fp = if fp & 0x8000000000000000 != 0 {
                (fp << 1) ^ poly
            } else {
                fp << 1
            }
        }
        table[i] = fp
    }
    table
}

fn generate_rabin_out_table(poly: UInt64, window_size: Int) -> [UInt64; 256] {
    var table = [0u64; 256]
    for i in 0..256 {
        var fp = i as UInt64
        for _ in 0..(window_size * 8) {
            fp = if fp & 0x8000000000000000 != 0 {
                (fp << 1) ^ poly
            } else {
                fp << 1
            }
        }
        table[i] = fp
    }
    table
}

/// Quick Rabin fingerprint
fn rabin_fingerprint(data: [UInt8]) -> UInt64 {
    RabinFingerprint.new(48).fingerprint(data)
}

// =============================================================================
// Content Fingerprint
// =============================================================================

/// Content-based fingerprint combining multiple techniques
struct ContentFingerprint {
    simhash: SimHash
    chunk_size: Int
}

impl ContentFingerprint {
    fn new() -> Self {
        ContentFingerprint { simhash: SimHash.new(), chunk_size: 4096 }
    }
    
    /// Compute content fingerprint
    fn fingerprint(data: [UInt8]) -> Fingerprint {
        // Combine hash of content with structural information
        var hasher = sha256.Sha256Hasher.new()
        hasher.update(data)
        
        // Add size information
        hasher.update_u64(data.len() as UInt64)
        
        let digest = hasher.finalize()
        Fingerprint.new(digest.as_bytes().to_vec(), FingerprintAlgorithm.Content)
    }
    
    /// Compute text fingerprint
    fn fingerprint_text(text: String) -> Fingerprint {
        self.simhash.hash(text)
    }
    
    /// Compute chunked fingerprint (for large files)
    fn fingerprint_chunked(data: [UInt8]) -> [Fingerprint] {
        var fingerprints = []
        
        for chunk in data.chunks(self.chunk_size) {
            fingerprints.push(self.fingerprint(chunk.to_vec()))
        }
        
        fingerprints
    }
}

/// Quick content fingerprint
fn content_fingerprint(data: [UInt8]) -> Fingerprint {
    ContentFingerprint.new().fingerprint(data)
}

/// Content fingerprint of string
fn content_fingerprint_string(s: String) -> Fingerprint {
    content_fingerprint(s.as_bytes())
}

// =============================================================================
// Document Fingerprint
// =============================================================================

/// Document fingerprint for plagiarism detection
struct DocumentFingerprint {
    k: Int          // k-gram size
    window: Int     // winnowing window size
}

impl DocumentFingerprint {
    fn new(k: Int, window: Int) -> Self {
        DocumentFingerprint { k: k, window: window }
    }
    
    fn default() -> Self {
        DocumentFingerprint { k: 5, window: 4 }
    }
    
    /// Compute document fingerprint using winnowing
    fn fingerprint(text: String) -> [UInt64] {
        let normalized = normalize_text(text)
        let kgrams = generate_kgrams(normalized, self.k)
        let hashes: [UInt64] = kgrams.iter().map(|kg| hash_token(kg, 64)).collect()
        winnow(hashes, self.window)
    }
    
    /// Compare two documents
    fn similarity(doc1: String, doc2: String) -> Float64 {
        let fp1 = self.fingerprint(doc1)
        let fp2 = self.fingerprint(doc2)
        
        let set1: Set<UInt64> = fp1.iter().collect()
        let set2: Set<UInt64> = fp2.iter().collect()
        
        let intersection = set1.intersection(set2).len()
        let union = set1.union(set2).len()
        
        if union == 0 { 1.0 } else { intersection as Float64 / union as Float64 }
    }
}

fn normalize_text(text: String) -> String {
    text.to_lowercase()
        .chars()
        .filter(|c| c.is_alphanumeric())
        .collect()
}

fn generate_kgrams(text: String, k: Int) -> [String] {
    if text.len() < k { return [] }
    
    var kgrams = []
    for i in 0..=(text.len() - k) {
        kgrams.push(text[i..(i + k)].to_string())
    }
    kgrams
}

fn winnow(hashes: [UInt64], window: Int) -> [UInt64] {
    if hashes.len() < window { return hashes }
    
    var fingerprints = []
    var prev_min_idx: Option<Int> = None
    
    for i in 0..=(hashes.len() - window) {
        let window_slice = hashes[i..(i + window)]
        
        // Find minimum in window
        var min_idx = 0
        var min_val = window_slice[0]
        for j in 1..window {
            if window_slice[j] < min_val {
                min_val = window_slice[j]
                min_idx = j
            }
        }
        
        let global_idx = i + min_idx
        if prev_min_idx.is_none() || prev_min_idx.unwrap() != global_idx {
            fingerprints.push(min_val)
            prev_min_idx = Some(global_idx)
        }
    }
    
    fingerprints
}

/// Quick document fingerprint
fn document_fingerprint(text: String) -> [UInt64] {
    DocumentFingerprint.default().fingerprint(text)
}

// =============================================================================
// Fingerprint Index
// =============================================================================

/// Index for fast fingerprint lookup
struct FingerprintIndex<T> {
    fingerprints: Map<String, (Fingerprint, T)>
    simhash: SimHash
}

impl<T: Clone> FingerprintIndex<T> {
    fn new() -> Self {
        FingerprintIndex { fingerprints: Map.empty(), simhash: SimHash.new() }
    }
    
    /// Add item with fingerprint
    fn add(id: String, text: String, data: T) {
        let fp = self.simhash.hash(text)
        self.fingerprints.set(id, (fp, data))
    }
    
    /// Find similar items
    fn find_similar(text: String, threshold: Float64) -> [(String, T, Float64)] {
        let query_fp = self.simhash.hash(text)
        
        var results = []
        for (id, (fp, data)) in self.fingerprints.iter() {
            let sim = query_fp.similarity(fp)
            if sim >= threshold {
                results.push((id.clone(), data.clone(), sim))
            }
        }
        
        results.sort_by(|a, b| b.2.partial_cmp(a.2).unwrap())
        results
    }
    
    /// Check for duplicates
    fn has_duplicate(text: String, threshold: Float64) -> Bool {
        !self.find_similar(text, threshold).is_empty()
    }
    
    /// Get by ID
    fn get(id: String) -> Option<(Fingerprint, T)> {
        self.fingerprints.get(id).cloned()
    }
    
    /// Remove by ID
    fn remove(id: String) -> Bool {
        self.fingerprints.remove(id).is_some()
    }
    
    fn len() -> Int {
        self.fingerprints.len()
    }
}

// =============================================================================
// Fingerprint Actor
// =============================================================================

/// Actor for fingerprint operations
actor FingerprintActor {
    state index: FingerprintIndex<String>
    state stats: FingerprintStats
    
    fn new() -> Self {
        FingerprintActor { 
            index: FingerprintIndex.new(),
            stats: FingerprintStats { computed: 0, comparisons: 0, duplicates_found: 0 }
        }
    }
    
    /// Add document
    fn add(id: String, text: String) {
        self.index.add(id.clone(), text, id)
        self.stats.computed += 1
    }
    
    /// Find similar documents
    fn find_similar(text: String, threshold: Float64) -> [(String, Float64)] {
        self.stats.comparisons += self.index.len()
        self.index.find_similar(text, threshold)
            .iter()
            .map(|(id, _, sim)| (id.clone(), sim))
            .collect()
    }
    
    /// Check for duplicate
    fn is_duplicate(text: String, threshold: Float64) -> Bool {
        let is_dup = self.index.has_duplicate(text, threshold)
        if is_dup { self.stats.duplicates_found += 1 }
        is_dup
    }
    
    /// Get statistics
    fn get_stats() -> FingerprintStats {
        self.stats.clone()
    }
}

struct FingerprintStats {
    computed: Int
    comparisons: Int
    duplicates_found: Int
}

// =============================================================================
// Errors
// =============================================================================

enum FingerprintError {
    InvalidHex
    InvalidSize
    ComputationError(String)
}

impl Display for FingerprintError {
    fn fmt(f: Formatter) {
        match self {
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidSize => f.write("Invalid fingerprint size")
            ComputationError(s) => f.write(format!("Computation error: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "simhash identical" {
    let fp1 = simhash("hello world")
    let fp2 = simhash("hello world")
    assert_eq(fp1.similarity(fp2), 1.0)?
}

test "simhash similar" {
    let fp1 = simhash("the quick brown fox")
    let fp2 = simhash("the quick brown dog")
    assert(fp1.similarity(fp2) > 0.5)?
}

test "simhash different" {
    let fp1 = simhash("hello world")
    let fp2 = simhash("completely different text")
    assert(fp1.similarity(fp2) < 0.9)?
}

test "minhash similarity" {
    let set1 = ["a", "b", "c", "d"]
    let set2 = ["a", "b", "c", "e"]
    let sim = minhash_similarity(set1, set2, 100)
    assert(sim > 0.5)?
}

test "rabin fingerprint" {
    let fp = rabin_fingerprint("hello".as_bytes())
    assert(fp != 0)?
}

test "content fingerprint" {
    let fp1 = content_fingerprint_string("hello")
    let fp2 = content_fingerprint_string("hello")
    assert(fp1.matches(fp2))?
}

test "document fingerprint" {
    let fp = document_fingerprint("the quick brown fox jumps over the lazy dog")
    assert(!fp.is_empty())?
}

test "hamming distance" {
    let fp1 = Fingerprint.new([0xFF, 0x00], FingerprintAlgorithm.Content)
    let fp2 = Fingerprint.new([0x00, 0xFF], FingerprintAlgorithm.Content)
    assert_eq(fp1.hamming_distance(fp2), 16)?
}

test "fingerprint index" {
    var index = FingerprintIndex::<String>.new()
    index.add("doc1", "hello world", "doc1")
    index.add("doc2", "hello earth", "doc2")
    
    let similar = index.find_similar("hello world", 0.5)
    assert(!similar.is_empty())?
}

test "fingerprint actor" {
    var actor = FingerprintActor.new()
    actor.add("doc1", "hello world")
    actor.add("doc2", "goodbye world")
    
    let similar = actor.find_similar("hello world", 0.5)
    assert(!similar.is_empty())?
}

test "popcount" {
    let fp = Fingerprint.new([0xFF], FingerprintAlgorithm.Content)
    assert_eq(fp.popcount(), 8)?
}
