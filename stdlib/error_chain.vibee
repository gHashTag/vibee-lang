// =============================================================================
// Vibee OS â€” Error Chain Module
// Chained errors with context and cause tracking
// =============================================================================

use result.{Error, ContextError}
use debug.{StackTrace, StackFrame, stack_trace}
use datetime.{DateTime}

// -----------------------------------------------------------------------------
// Core Types
// -----------------------------------------------------------------------------

/// Error with chain of causes
struct ChainedError {
    message: String
    kind: ErrorKind
    cause: Option<Box<ChainedError>>
    context: Map<String, Any>
    location: Option<SourceLocation>
    timestamp: DateTime
    stack: Option<StackTrace>
}

/// Source code location
struct SourceLocation {
    file: String
    line: Int
    column: Int
    function: Option<String>
}

impl SourceLocation {
    fn new(file: String, line: Int, column: Int) -> Self {
        SourceLocation { file: file, line: line, column: column, function: None }
    }
    
    fn with_function(function: String) -> Self {
        self.function = Some(function)
        self
    }
    
    fn to_string() -> String {
        match self.function {
            Some(f) => format!("{}:{}:{} in {}", self.file, self.line, self.column, f)
            None => format!("{}:{}:{}", self.file, self.line, self.column)
        }
    }
}

/// Error classification
enum ErrorKind {
    /// I/O related errors
    Io
    /// Network errors
    Network
    /// Parse/format errors
    Parse
    /// Validation errors
    Validation
    /// Permission/auth errors
    Permission
    /// Resource not found
    NotFound
    /// Resource already exists
    AlreadyExists
    /// Timeout errors
    Timeout
    /// Cancelled operation
    Cancelled
    /// Internal/unexpected errors
    Internal
    /// Configuration errors
    Config
    /// External service errors
    External
    /// Custom error kind
    Custom(String)
    
    fn name() -> String {
        match self {
            Io => "IO"
            Network => "Network"
            Parse => "Parse"
            Validation => "Validation"
            Permission => "Permission"
            NotFound => "NotFound"
            AlreadyExists => "AlreadyExists"
            Timeout => "Timeout"
            Cancelled => "Cancelled"
            Internal => "Internal"
            Config => "Config"
            External => "External"
            Custom(name) => name
        }
    }
    
    fn is_retryable() -> Bool {
        match self {
            Network | Timeout | External => true
            _ => false
        }
    }
    
    fn is_client_error() -> Bool {
        match self {
            Validation | Permission | NotFound | AlreadyExists => true
            _ => false
        }
    }
}

impl ChainedError {
    /// Create new error with message
    fn new(message: String) -> Self {
        ChainedError {
            message: message,
            kind: ErrorKind.Internal,
            cause: None,
            context: Map.new(),
            location: None,
            timestamp: DateTime.now(),
            stack: None
        }
    }
    
    /// Create error with kind
    fn with_kind(kind: ErrorKind, message: String) -> Self {
        ChainedError.new(message).kind(kind)
    }
    
    /// Set error kind
    fn kind(kind: ErrorKind) -> Self {
        self.kind = kind
        self
    }
    
    /// Add cause error
    fn caused_by(cause: ChainedError) -> Self {
        self.cause = Some(Box.new(cause))
        self
    }
    
    /// Add cause from any Error
    fn caused_by_err<E: Error>(err: E) -> Self {
        self.cause = Some(Box.new(ChainedError.from_error(err)))
        self
    }
    
    /// Add context key-value
    fn with_context(key: String, value: Any) -> Self {
        self.context.insert(key, value)
        self
    }
    
    /// Add multiple context values
    fn with_contexts(ctx: Map<String, Any>) -> Self {
        for (k, v) in ctx {
            self.context.insert(k, v)
        }
        self
    }
    
    /// Set source location
    fn at(file: String, line: Int, column: Int) -> Self {
        self.location = Some(SourceLocation.new(file, line, column))
        self
    }
    
    /// Set source location with function
    fn at_fn(file: String, line: Int, column: Int, function: String) -> Self {
        self.location = Some(SourceLocation.new(file, line, column).with_function(function))
        self
    }
    
    /// Capture stack trace
    fn with_stack() -> Self {
        self.stack = Some(stack_trace())
        self
    }
    
    /// Create from any Error
    fn from_error<E: Error>(err: E) -> Self {
        var chained = ChainedError.new(err.to_string())
        if let Some(source) = err.source() {
            chained = chained.caused_by_err(source)
        }
        chained
    }
    
    // Accessors
    fn message() -> String { self.message.clone() }
    fn error_kind() -> ErrorKind { self.kind }
    fn cause() -> Option<Box<ChainedError>> { self.cause.clone() }
    fn timestamp() -> DateTime { self.timestamp }
    
    /// Get root cause
    fn root_cause() -> ChainedError {
        var current = self
        while let Some(cause) = current.cause.as_ref() {
            current = cause.as_ref()
        }
        current.clone()
    }
    
    /// Get error chain as list
    fn chain() -> [ChainedError] {
        var result = [self.clone()]
        var current = self
        while let Some(cause) = current.cause.as_ref() {
            result.push(cause.as_ref().clone())
            current = cause.as_ref()
        }
        result
    }
    
    /// Get chain depth
    fn depth() -> Int {
        var count = 1
        var current = self
        while let Some(cause) = current.cause.as_ref() {
            count += 1
            current = cause.as_ref()
        }
        count
    }
    
    /// Check if chain contains error kind
    fn contains_kind(kind: ErrorKind) -> Bool {
        for err in self.chain() {
            if err.kind == kind { return true }
        }
        false
    }
    
    /// Find first error of kind in chain
    fn find_kind(kind: ErrorKind) -> Option<ChainedError> {
        for err in self.chain() {
            if err.kind == kind { return Some(err) }
        }
        None
    }
    
    /// Check if error is retryable
    fn is_retryable() -> Bool {
        self.kind.is_retryable()
    }
    
    /// Format error for display
    fn display() -> String {
        var result = format!("[{}] {}", self.kind.name(), self.message)
        
        if let Some(loc) = self.location.as_ref() {
            result = format!("{}\n  at {}", result, loc.to_string())
        }
        
        if !self.context.is_empty() {
            result = format!("{}\n  context:", result)
            for (k, v) in self.context.iter() {
                result = format!("{}\n    {}: {:?}", result, k, v)
            }
        }
        
        result
    }
    
    /// Format full chain
    fn display_chain() -> String {
        var result = StringBuilder.new()
        
        for (i, err) in self.chain().enumerate() {
            if i == 0 {
                result.append("Error: ")
            } else {
                result.append("\nCaused by: ")
            }
            result.append(err.display())
        }
        
        if let Some(stack) = self.stack.as_ref() {
            result.append("\n\nStack trace:\n")
            result.append(stack.to_string())
        }
        
        result.build()
    }
    
    /// Format as JSON
    fn to_json() -> String {
        var obj = Map.new()
        obj.insert("message", self.message.clone())
        obj.insert("kind", self.kind.name())
        obj.insert("timestamp", self.timestamp.to_iso8601())
        
        if let Some(loc) = self.location.as_ref() {
            obj.insert("location", loc.to_string())
        }
        
        if !self.context.is_empty() {
            obj.insert("context", self.context.clone())
        }
        
        if let Some(cause) = self.cause.as_ref() {
            obj.insert("cause", cause.to_json())
        }
        
        Json.stringify(obj)
    }
}

impl Error for ChainedError {
    fn source() -> Option<Box<dyn Error>> {
        self.cause.as_ref().map(|c| Box.new(c.as_ref().clone()) as Box<dyn Error>)
    }
}

impl Display for ChainedError {
    fn fmt(f: Formatter) {
        f.write(self.display())
    }
}

impl Debug for ChainedError {
    fn debug() -> String {
        self.display_chain()
    }
}

// -----------------------------------------------------------------------------
// Error Chain Builder
// -----------------------------------------------------------------------------

/// Fluent builder for chained errors
struct ErrorChainBuilder {
    message: String
    kind: ErrorKind
    causes: [ChainedError]
    context: Map<String, Any>
    location: Option<SourceLocation>
    capture_stack: Bool
}

impl ErrorChainBuilder {
    fn new(message: String) -> Self {
        ErrorChainBuilder {
            message: message,
            kind: ErrorKind.Internal,
            causes: [],
            context: Map.new(),
            location: None,
            capture_stack: false
        }
    }
    
    fn kind(kind: ErrorKind) -> Self {
        self.kind = kind
        self
    }
    
    fn io() -> Self { self.kind(ErrorKind.Io) }
    fn network() -> Self { self.kind(ErrorKind.Network) }
    fn parse() -> Self { self.kind(ErrorKind.Parse) }
    fn validation() -> Self { self.kind(ErrorKind.Validation) }
    fn permission() -> Self { self.kind(ErrorKind.Permission) }
    fn not_found() -> Self { self.kind(ErrorKind.NotFound) }
    fn timeout() -> Self { self.kind(ErrorKind.Timeout) }
    fn internal() -> Self { self.kind(ErrorKind.Internal) }
    
    fn cause(err: ChainedError) -> Self {
        self.causes.push(err)
        self
    }
    
    fn cause_err<E: Error>(err: E) -> Self {
        self.causes.push(ChainedError.from_error(err))
        self
    }
    
    fn context(key: String, value: Any) -> Self {
        self.context.insert(key, value)
        self
    }
    
    fn at(file: String, line: Int) -> Self {
        self.location = Some(SourceLocation.new(file, line, 0))
        self
    }
    
    fn with_stack() -> Self {
        self.capture_stack = true
        self
    }
    
    fn build() -> ChainedError {
        var err = ChainedError.new(self.message.clone())
            .kind(self.kind)
        
        // Chain causes
        if !self.causes.is_empty() {
            var current = self.causes.pop().unwrap()
            while let Some(cause) = self.causes.pop() {
                current = cause.caused_by(current)
            }
            err = err.caused_by(current)
        }
        
        // Add context
        for (k, v) in self.context {
            err = err.with_context(k, v)
        }
        
        // Set location
        if let Some(loc) = self.location {
            err.location = Some(loc)
        }
        
        // Capture stack
        if self.capture_stack {
            err = err.with_stack()
        }
        
        err
    }
}

// -----------------------------------------------------------------------------
// Result Extensions
// -----------------------------------------------------------------------------

/// Extension methods for Result with ChainedError
impl<T> Result<T, ChainedError> {
    /// Add context to error
    fn context(ctx: String) -> Result<T, ChainedError> {
        self.map_err(|e| ChainedError.new(ctx).caused_by(e))
    }
    
    /// Add context with key-value
    fn with_context(key: String, value: Any) -> Result<T, ChainedError> {
        self.map_err(|e| e.with_context(key, value))
    }
    
    /// Set error kind
    fn kind(kind: ErrorKind) -> Result<T, ChainedError> {
        self.map_err(|e| e.kind(kind))
    }
    
    /// Add source location
    fn at(file: String, line: Int) -> Result<T, ChainedError> {
        self.map_err(|e| e.at(file, line, 0))
    }
}

/// Convert any Result to ChainedError Result
fn chain_err<T, E: Error>(result: Result<T, E>) -> Result<T, ChainedError> {
    result.map_err(|e| ChainedError.from_error(e))
}

// -----------------------------------------------------------------------------
// Macros
// -----------------------------------------------------------------------------

/// Create error with location
macro err!(message) {
    ChainedError.new(message)
        .at(@file(), @line(), @column())
}

/// Create error with kind and location
macro err_kind!(kind, message) {
    ChainedError.with_kind(kind, message)
        .at(@file(), @line(), @column())
}

/// Wrap error with context
macro wrap_err!(result, context) {
    result.map_err(|e| {
        ChainedError.new(context)
            .at(@file(), @line(), @column())
            .caused_by_err(e)
    })
}

/// Bail with error
macro bail!(message) {
    return Err(err!(message))
}

/// Bail with kind
macro bail_kind!(kind, message) {
    return Err(err_kind!(kind, message))
}

/// Ensure condition or bail
macro ensure!(condition, message) {
    if !condition {
        bail!(message)
    }
}

// -----------------------------------------------------------------------------
// Error Aggregation
// -----------------------------------------------------------------------------

/// Aggregate multiple errors
struct ErrorAggregate {
    errors: [ChainedError]
    message: String
}

impl ErrorAggregate {
    fn new(message: String) -> Self {
        ErrorAggregate { errors: [], message: message }
    }
    
    fn add(err: ChainedError) -> Self {
        self.errors.push(err)
        self
    }
    
    fn add_err<E: Error>(err: E) -> Self {
        self.errors.push(ChainedError.from_error(err))
        self
    }
    
    fn is_empty() -> Bool { self.errors.is_empty() }
    fn len() -> Int { self.errors.len() }
    
    /// Convert to single ChainedError
    fn into_error() -> Option<ChainedError> {
        if self.errors.is_empty() {
            return None
        }
        
        if self.errors.len() == 1 {
            return Some(self.errors[0].clone())
        }
        
        var err = ChainedError.new(format!("{} ({} errors)", self.message, self.errors.len()))
            .kind(ErrorKind.Internal)
        
        for (i, e) in self.errors.enumerate() {
            err = err.with_context(format!("error_{}", i), e.message())
        }
        
        Some(err)
    }
    
    /// Convert to Result
    fn into_result<T>(value: T) -> Result<T, ChainedError> {
        match self.into_error() {
            Some(err) => Err(err)
            None => Ok(value)
        }
    }
    
    fn display() -> String {
        var result = format!("{} ({} errors):\n", self.message, self.errors.len())
        for (i, err) in self.errors.enumerate() {
            result = format!("{}  {}: {}\n", result, i + 1, err.message())
        }
        result
    }
}

// -----------------------------------------------------------------------------
// Error Formatting
// -----------------------------------------------------------------------------

/// Format error chain for different outputs
struct ErrorFormatter {
    show_context: Bool
    show_location: Bool
    show_stack: Bool
    show_timestamp: Bool
    color: Bool
}

impl ErrorFormatter {
    fn new() -> Self {
        ErrorFormatter {
            show_context: true,
            show_location: true,
            show_stack: false,
            show_timestamp: false,
            color: true
        }
    }
    
    fn minimal() -> Self {
        ErrorFormatter {
            show_context: false,
            show_location: false,
            show_stack: false,
            show_timestamp: false,
            color: false
        }
    }
    
    fn detailed() -> Self {
        ErrorFormatter {
            show_context: true,
            show_location: true,
            show_stack: true,
            show_timestamp: true,
            color: true
        }
    }
    
    fn format(err: ChainedError) -> String {
        var result = StringBuilder.new()
        
        for (i, e) in err.chain().enumerate() {
            if i == 0 {
                if self.color {
                    result.append("\x1b[31mError:\x1b[0m ")
                } else {
                    result.append("Error: ")
                }
            } else {
                result.append("\n  Caused by: ")
            }
            
            result.append(format!("[{}] {}", e.kind.name(), e.message))
            
            if self.show_timestamp {
                result.append(format!(" ({})", e.timestamp.to_iso8601()))
            }
            
            if self.show_location {
                if let Some(loc) = e.location.as_ref() {
                    result.append(format!("\n    at {}", loc.to_string()))
                }
            }
            
            if self.show_context && !e.context.is_empty() {
                result.append("\n    context:")
                for (k, v) in e.context.iter() {
                    result.append(format!("\n      {}: {:?}", k, v))
                }
            }
        }
        
        if self.show_stack {
            if let Some(stack) = err.stack.as_ref() {
                result.append("\n\nStack trace:\n")
                result.append(stack.to_string())
            }
        }
        
        result.build()
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "create chained error" {
    let err = ChainedError.new("Something went wrong")
        .kind(ErrorKind.Io)
        .with_context("file", "/tmp/test.txt")
    
    assert_eq(err.message(), "Something went wrong")?
    assert_eq(err.error_kind(), ErrorKind.Io)?
}

test "error chain" {
    let root = ChainedError.new("Root cause")
        .kind(ErrorKind.Io)
    
    let middle = ChainedError.new("Middle error")
        .kind(ErrorKind.Internal)
        .caused_by(root)
    
    let top = ChainedError.new("Top level error")
        .kind(ErrorKind.External)
        .caused_by(middle)
    
    assert_eq(top.depth(), 3)?
    assert_eq(top.root_cause().message(), "Root cause")?
}

test "error chain contains kind" {
    let err = ChainedError.new("Top")
        .kind(ErrorKind.External)
        .caused_by(ChainedError.new("Middle").kind(ErrorKind.Network))
    
    assert(err.contains_kind(ErrorKind.Network))?
    assert(!err.contains_kind(ErrorKind.Io))?
}

test "error builder" {
    let err = ErrorChainBuilder.new("Failed to process")
        .network()
        .context("url", "https://api.example.com")
        .context("status", 500)
        .build()
    
    assert_eq(err.error_kind(), ErrorKind.Network)?
}

test "error aggregate" {
    var agg = ErrorAggregate.new("Multiple failures")
    agg.add(ChainedError.new("Error 1"))
    agg.add(ChainedError.new("Error 2"))
    
    assert_eq(agg.len(), 2)?
    assert(agg.into_error().is_some())?
}

test "result context extension" {
    let result: Result<Int, ChainedError> = Err(ChainedError.new("Original"))
    let wrapped = result.context("While processing request")
    
    assert(wrapped.is_err())?
    let err = wrapped.unwrap_err()
    assert_eq(err.message(), "While processing request")?
    assert(err.cause().is_some())?
}
