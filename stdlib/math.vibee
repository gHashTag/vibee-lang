// =============================================================================
// Vibee OS — Math Module
// Mathematical functions, constants, and utilities
// =============================================================================

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

/// Pi (π)
const PI: Float = 3.141592653589793

/// Tau (τ = 2π)
const TAU: Float = 6.283185307179586

/// Euler's number (e)
const E: Float = 2.718281828459045

/// Golden ratio (φ)
const PHI: Float = 1.618033988749895

/// Square root of 2
const SQRT2: Float = 1.4142135623730951

/// Square root of 3
const SQRT3: Float = 1.7320508075688772

/// Natural log of 2
const LN2: Float = 0.6931471805599453

/// Natural log of 10
const LN10: Float = 2.302585092994046

/// Log base 2 of e
const LOG2E: Float = 1.4426950408889634

/// Log base 10 of e
const LOG10E: Float = 0.4342944819032518

/// Positive infinity
const INFINITY: Float = @native("float_infinity")

/// Negative infinity
const NEG_INFINITY: Float = @native("float_neg_infinity")

/// Not a Number
const NAN: Float = @native("float_nan")

/// Machine epsilon
const EPSILON: Float = 2.220446049250313e-16

/// Maximum float value
const MAX_FLOAT: Float = 1.7976931348623157e+308

/// Minimum positive float value
const MIN_POSITIVE: Float = 2.2250738585072014e-308

// -----------------------------------------------------------------------------
// Basic Functions
// -----------------------------------------------------------------------------

/// Absolute value
fn abs(x: Float) -> Float {
    if x < 0.0 { -x } else { x }
}

fn abs_int(x: Int) -> Int {
    if x < 0 { -x } else { x }
}

/// Sign of number (-1, 0, or 1)
fn sign(x: Float) -> Int {
    if x > 0.0 { 1 }
    else if x < 0.0 { -1 }
    else { 0 }
}

/// Copy sign from y to x
fn copysign(x: Float, y: Float) -> Float {
    abs(x) * sign(y) as Float
}

/// Minimum of two values
fn min<T: Ord>(a: T, b: T) -> T {
    if a <= b { a } else { b }
}

/// Maximum of two values
fn max<T: Ord>(a: T, b: T) -> T {
    if a >= b { a } else { b }
}

/// Clamp value to range
fn clamp<T: Ord>(value: T, min_val: T, max_val: T) -> T {
    max(min_val, min(max_val, value))
}

/// Linear interpolation
fn lerp(a: Float, b: Float, t: Float) -> Float {
    a + (b - a) * t
}

/// Inverse linear interpolation
fn inverse_lerp(a: Float, b: Float, value: Float) -> Float {
    (value - a) / (b - a)
}

/// Remap value from one range to another
fn remap(value: Float, from_min: Float, from_max: Float, to_min: Float, to_max: Float) -> Float {
    let t = inverse_lerp(from_min, from_max, value)
    lerp(to_min, to_max, t)
}

// -----------------------------------------------------------------------------
// Rounding
// -----------------------------------------------------------------------------

/// Floor (round down)
fn floor(x: Float) -> Float {
    @native("math_floor", x)
}

/// Ceiling (round up)
fn ceil(x: Float) -> Float {
    @native("math_ceil", x)
}

/// Round to nearest integer
fn round(x: Float) -> Float {
    @native("math_round", x)
}

/// Round to n decimal places
fn round_to(x: Float, decimals: Int) -> Float {
    let factor = pow(10.0, decimals as Float)
    round(x * factor) / factor
}

/// Truncate (round toward zero)
fn trunc(x: Float) -> Float {
    @native("math_trunc", x)
}

/// Fractional part
fn fract(x: Float) -> Float {
    x - floor(x)
}

// -----------------------------------------------------------------------------
// Powers & Roots
// -----------------------------------------------------------------------------

/// Power
fn pow(base: Float, exp: Float) -> Float {
    @native("math_pow", base, exp)
}

/// Integer power (faster for integer exponents)
fn powi(base: Float, exp: Int) -> Float {
    if exp == 0 { return 1.0 }
    if exp < 0 { return 1.0 / powi(base, -exp) }
    
    var result = 1.0
    var b = base
    var e = exp
    
    while e > 0 {
        if e & 1 == 1 { result *= b }
        b *= b
        e >>= 1
    }
    result
}

/// Square root
fn sqrt(x: Float) -> Float {
    @native("math_sqrt", x)
}

/// Cube root
fn cbrt(x: Float) -> Float {
    @native("math_cbrt", x)
}

/// Nth root
fn nroot(x: Float, n: Float) -> Float {
    pow(x, 1.0 / n)
}

/// Hypotenuse (sqrt(x² + y²))
fn hypot(x: Float, y: Float) -> Float {
    @native("math_hypot", x, y)
}

/// Square
fn sq(x: Float) -> Float {
    x * x
}

/// Cube
fn cube(x: Float) -> Float {
    x * x * x
}

// -----------------------------------------------------------------------------
// Exponential & Logarithmic
// -----------------------------------------------------------------------------

/// e^x
fn exp(x: Float) -> Float {
    @native("math_exp", x)
}

/// 2^x
fn exp2(x: Float) -> Float {
    @native("math_exp2", x)
}

/// e^x - 1 (more accurate for small x)
fn expm1(x: Float) -> Float {
    @native("math_expm1", x)
}

/// Natural logarithm (base e)
fn ln(x: Float) -> Float {
    @native("math_ln", x)
}

/// Logarithm base 2
fn log2(x: Float) -> Float {
    @native("math_log2", x)
}

/// Logarithm base 10
fn log10(x: Float) -> Float {
    @native("math_log10", x)
}

/// Logarithm with arbitrary base
fn log(x: Float, base: Float) -> Float {
    ln(x) / ln(base)
}

/// ln(1 + x) (more accurate for small x)
fn ln1p(x: Float) -> Float {
    @native("math_ln1p", x)
}

// -----------------------------------------------------------------------------
// Trigonometric
// -----------------------------------------------------------------------------

/// Sine
fn sin(x: Float) -> Float {
    @native("math_sin", x)
}

/// Cosine
fn cos(x: Float) -> Float {
    @native("math_cos", x)
}

/// Tangent
fn tan(x: Float) -> Float {
    @native("math_tan", x)
}

/// Arcsine
fn asin(x: Float) -> Float {
    @native("math_asin", x)
}

/// Arccosine
fn acos(x: Float) -> Float {
    @native("math_acos", x)
}

/// Arctangent
fn atan(x: Float) -> Float {
    @native("math_atan", x)
}

/// Arctangent of y/x (handles quadrants)
fn atan2(y: Float, x: Float) -> Float {
    @native("math_atan2", y, x)
}

/// Sine and cosine together (more efficient)
fn sincos(x: Float) -> (Float, Float) {
    (sin(x), cos(x))
}

// -----------------------------------------------------------------------------
// Hyperbolic
// -----------------------------------------------------------------------------

/// Hyperbolic sine
fn sinh(x: Float) -> Float {
    @native("math_sinh", x)
}

/// Hyperbolic cosine
fn cosh(x: Float) -> Float {
    @native("math_cosh", x)
}

/// Hyperbolic tangent
fn tanh(x: Float) -> Float {
    @native("math_tanh", x)
}

/// Inverse hyperbolic sine
fn asinh(x: Float) -> Float {
    @native("math_asinh", x)
}

/// Inverse hyperbolic cosine
fn acosh(x: Float) -> Float {
    @native("math_acosh", x)
}

/// Inverse hyperbolic tangent
fn atanh(x: Float) -> Float {
    @native("math_atanh", x)
}

// -----------------------------------------------------------------------------
// Angle Conversions
// -----------------------------------------------------------------------------

/// Degrees to radians
fn to_radians(degrees: Float) -> Float {
    degrees * PI / 180.0
}

/// Radians to degrees
fn to_degrees(radians: Float) -> Float {
    radians * 180.0 / PI
}

/// Normalize angle to [0, 2π)
fn normalize_angle(radians: Float) -> Float {
    var r = radians % TAU
    if r < 0.0 { r += TAU }
    r
}

/// Normalize angle to [-π, π)
fn normalize_angle_signed(radians: Float) -> Float {
    var r = normalize_angle(radians)
    if r >= PI { r -= TAU }
    r
}

// -----------------------------------------------------------------------------
// Special Functions
// -----------------------------------------------------------------------------

/// Gamma function
fn gamma(x: Float) -> Float {
    @native("math_gamma", x)
}

/// Log gamma function
fn lgamma(x: Float) -> Float {
    @native("math_lgamma", x)
}

/// Factorial
fn factorial(n: Int) -> Int {
    if n <= 1 { 1 }
    else { n * factorial(n - 1) }
}

/// Factorial as float (for large values)
fn factorial_f(n: Int) -> Float {
    gamma(n as Float + 1.0)
}

/// Binomial coefficient (n choose k)
fn binomial(n: Int, k: Int) -> Int {
    if k > n { return 0 }
    if k == 0 || k == n { return 1 }
    
    let k = min(k, n - k)
    var result = 1
    for i in 0..k {
        result = result * (n - i) / (i + 1)
    }
    result
}

/// Error function
fn erf(x: Float) -> Float {
    @native("math_erf", x)
}

/// Complementary error function
fn erfc(x: Float) -> Float {
    @native("math_erfc", x)
}

/// Beta function
fn beta(a: Float, b: Float) -> Float {
    gamma(a) * gamma(b) / gamma(a + b)
}

// -----------------------------------------------------------------------------
// Number Theory
// -----------------------------------------------------------------------------

/// Greatest common divisor
fn gcd(a: Int, b: Int) -> Int {
    var x = abs_int(a)
    var y = abs_int(b)
    while y != 0 {
        let t = y
        y = x % y
        x = t
    }
    x
}

/// Least common multiple
fn lcm(a: Int, b: Int) -> Int {
    if a == 0 || b == 0 { 0 }
    else { abs_int(a * b) / gcd(a, b) }
}

/// Check if prime
fn is_prime(n: Int) -> Bool {
    if n < 2 { return false }
    if n == 2 { return true }
    if n % 2 == 0 { return false }
    
    let limit = sqrt(n as Float) as Int
    for i in (3..=limit).step_by(2) {
        if n % i == 0 { return false }
    }
    true
}

/// Prime factors
fn prime_factors(n: Int) -> [Int] {
    var factors = []
    var num = n
    var d = 2
    
    while d * d <= num {
        while num % d == 0 {
            factors.append(d)
            num /= d
        }
        d += 1
    }
    
    if num > 1 { factors.append(num) }
    factors
}

/// Modular exponentiation
fn mod_pow(base: Int, exp: Int, modulus: Int) -> Int {
    var result = 1
    var b = base % modulus
    var e = exp
    
    while e > 0 {
        if e & 1 == 1 {
            result = (result * b) % modulus
        }
        e >>= 1
        b = (b * b) % modulus
    }
    result
}

/// Modular inverse
fn mod_inverse(a: Int, m: Int) -> Option<Int> {
    let (g, x, _) = extended_gcd(a, m)
    if g != 1 { None }
    else { Some(((x % m) + m) % m) }
}

fn extended_gcd(a: Int, b: Int) -> (Int, Int, Int) {
    if a == 0 { (b, 0, 1) }
    else {
        let (g, x, y) = extended_gcd(b % a, a)
        (g, y - (b / a) * x, x)
    }
}

// -----------------------------------------------------------------------------
// Floating Point Utilities
// -----------------------------------------------------------------------------

/// Check if NaN
fn is_nan(x: Float) -> Bool {
    x != x
}

/// Check if infinite
fn is_infinite(x: Float) -> Bool {
    x == INFINITY || x == NEG_INFINITY
}

/// Check if finite
fn is_finite(x: Float) -> Bool {
    !is_nan(x) && !is_infinite(x)
}

/// Check if normal (not zero, subnormal, infinite, or NaN)
fn is_normal(x: Float) -> Bool {
    is_finite(x) && abs(x) >= MIN_POSITIVE
}

/// Approximately equal
fn approx_eq(a: Float, b: Float, epsilon: Float = EPSILON) -> Bool {
    abs(a - b) < epsilon
}

/// Relative approximately equal
fn rel_approx_eq(a: Float, b: Float, rel_epsilon: Float = 1e-9) -> Bool {
    let diff = abs(a - b)
    let largest = max(abs(a), abs(b))
    diff <= largest * rel_epsilon
}

/// Next representable float
fn next_up(x: Float) -> Float {
    @native("math_next_up", x)
}

/// Previous representable float
fn next_down(x: Float) -> Float {
    @native("math_next_down", x)
}

// -----------------------------------------------------------------------------
// Sequences
// -----------------------------------------------------------------------------

/// Fibonacci number
fn fibonacci(n: Int) -> Int {
    if n <= 1 { return n }
    
    var a = 0
    var b = 1
    for _ in 2..=n {
        let c = a + b
        a = b
        b = c
    }
    b
}

/// Sum of arithmetic sequence
fn arithmetic_sum(first: Float, last: Float, count: Int) -> Float {
    (first + last) * count as Float / 2.0
}

/// Sum of geometric sequence
fn geometric_sum(first: Float, ratio: Float, count: Int) -> Float {
    if ratio == 1.0 { first * count as Float }
    else { first * (1.0 - pow(ratio, count as Float)) / (1.0 - ratio) }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "basic functions" {
    assert_eq(abs(-5.0), 5.0)?
    assert_eq(sign(-3.0), -1)?
    assert_eq(clamp(15.0, 0.0, 10.0), 10.0)?
}

test "powers and roots" {
    assert(approx_eq(sqrt(4.0), 2.0))
    assert(approx_eq(pow(2.0, 3.0), 8.0))
    assert(approx_eq(cbrt(27.0), 3.0))
}

test "trigonometry" {
    assert(approx_eq(sin(0.0), 0.0))
    assert(approx_eq(cos(0.0), 1.0))
    assert(approx_eq(sin(PI / 2.0), 1.0))
}

test "number theory" {
    assert_eq(gcd(48, 18), 6)?
    assert_eq(lcm(4, 6), 12)?
    assert(is_prime(17))
    assert(!is_prime(18))
}

test "factorial and binomial" {
    assert_eq(factorial(5), 120)?
    assert_eq(binomial(5, 2), 10)?
}
