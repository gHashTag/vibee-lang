// =============================================================================
// Vibee OS â€” Geocoding Module
// Address geocoding, reverse geocoding, and place search
// =============================================================================

use coordinate::{GeoCoord}
use geo_distance::{haversine_distance}

// -----------------------------------------------------------------------------
// Address Components
// -----------------------------------------------------------------------------

/// Structured address
struct Address {
    street_number: Option<String>
    street_name: Option<String>
    unit: Option<String>
    city: Option<String>
    district: Option<String>
    state: Option<String>
    postal_code: Option<String>
    country: Option<String>
    country_code: Option<String>
    
    fn new() -> Self {
        Address {
            street_number: None,
            street_name: None,
            unit: None,
            city: None,
            district: None,
            state: None,
            postal_code: None,
            country: None,
            country_code: None
        }
    }
    
    fn with_street(number: String, name: String) -> Self {
        self.street_number = Some(number)
        self.street_name = Some(name)
        self
    }
    
    fn with_city(city: String) -> Self {
        self.city = Some(city)
        self
    }
    
    fn with_state(state: String) -> Self {
        self.state = Some(state)
        self
    }
    
    fn with_postal_code(code: String) -> Self {
        self.postal_code = Some(code)
        self
    }
    
    fn with_country(country: String, code: String) -> Self {
        self.country = Some(country)
        self.country_code = Some(code)
        self
    }
    
    /// Format as single line
    fn format_line() -> String {
        var parts = []
        
        if let Some(num) = self.street_number {
            if let Some(name) = self.street_name {
                parts.push(format!("{} {}", num, name))
            }
        } else if let Some(name) = self.street_name {
            parts.push(name)
        }
        
        if let Some(unit) = self.unit {
            parts.push(format!("#{}", unit))
        }
        
        if let Some(city) = self.city {
            parts.push(city)
        }
        
        if let Some(state) = self.state {
            if let Some(postal) = self.postal_code {
                parts.push(format!("{} {}", state, postal))
            } else {
                parts.push(state)
            }
        } else if let Some(postal) = self.postal_code {
            parts.push(postal)
        }
        
        if let Some(country) = self.country {
            parts.push(country)
        }
        
        parts.join(", ")
    }
    
    /// Format as multi-line
    fn format_multiline() -> String {
        var lines = []
        
        if let Some(num) = self.street_number {
            if let Some(name) = self.street_name {
                lines.push(format!("{} {}", num, name))
            }
        }
        
        if let Some(unit) = self.unit {
            lines.push(format!("Unit {}", unit))
        }
        
        var city_line = ""
        if let Some(city) = self.city {
            city_line = city
        }
        if let Some(state) = self.state {
            if !city_line.is_empty() { city_line += ", " }
            city_line += state
        }
        if let Some(postal) = self.postal_code {
            if !city_line.is_empty() { city_line += " " }
            city_line += postal
        }
        if !city_line.is_empty() {
            lines.push(city_line)
        }
        
        if let Some(country) = self.country {
            lines.push(country)
        }
        
        lines.join("\n")
    }
    
    /// Parse from string (basic parsing)
    fn parse(s: String) -> Self {
        let parts = s.split(",").map(|p| p.trim())
        var addr = Address.new()
        
        if parts.len() >= 1 {
            // First part is usually street address
            let street_parts = parts[0].split_whitespace()
            if street_parts.len() >= 2 {
                if street_parts[0].chars().all(|c| c.is_digit()) {
                    addr.street_number = Some(street_parts[0].to_string())
                    addr.street_name = Some(street_parts[1..].join(" "))
                } else {
                    addr.street_name = Some(parts[0].to_string())
                }
            }
        }
        
        if parts.len() >= 2 {
            addr.city = Some(parts[1].to_string())
        }
        
        if parts.len() >= 3 {
            // Could be state/postal or country
            let part = parts[2]
            if part.len() == 2 && part.chars().all(|c| c.is_alphabetic()) {
                addr.state = Some(part.to_string())
            } else {
                addr.country = Some(part.to_string())
            }
        }
        
        if parts.len() >= 4 {
            addr.country = Some(parts[3].to_string())
        }
        
        addr
    }
}

// -----------------------------------------------------------------------------
// Geocoding Result
// -----------------------------------------------------------------------------

/// Result of geocoding operation
struct GeocodingResult {
    location: GeoCoord
    address: Address
    formatted_address: String
    place_id: Option<String>
    place_type: PlaceType
    confidence: Float64
    viewport: Option<Viewport>
    
    fn new(location: GeoCoord, address: Address) -> Self {
        GeocodingResult {
            location: location,
            address: address,
            formatted_address: address.format_line(),
            place_id: None,
            place_type: PlaceType.Unknown,
            confidence: 0.0,
            viewport: None
        }
    }
    
    fn with_confidence(confidence: Float64) -> Self {
        self.confidence = confidence
        self
    }
    
    fn with_place_type(place_type: PlaceType) -> Self {
        self.place_type = place_type
        self
    }
}

/// Viewport for map display
struct Viewport {
    northeast: GeoCoord
    southwest: GeoCoord
    
    fn new(ne: GeoCoord, sw: GeoCoord) -> Self {
        Viewport { northeast: ne, southwest: sw }
    }
    
    fn center() -> GeoCoord {
        GeoCoord.unchecked(
            (self.northeast.lat + self.southwest.lat) / 2.0,
            (self.northeast.lon + self.southwest.lon) / 2.0
        )
    }
}

/// Place type classification
enum PlaceType {
    StreetAddress
    Route
    Intersection
    Neighborhood
    Locality
    City
    AdminArea1  // State/Province
    AdminArea2  // County
    Country
    PostalCode
    Airport
    Park
    PointOfInterest
    Establishment
    Unknown
}

impl PlaceType {
    fn from_string(s: String) -> Self {
        match s.to_lower().as_str() {
            "street_address" | "address" => StreetAddress
            "route" | "road" => Route
            "intersection" => Intersection
            "neighborhood" => Neighborhood
            "locality" => Locality
            "city" => City
            "administrative_area_level_1" | "state" | "province" => AdminArea1
            "administrative_area_level_2" | "county" => AdminArea2
            "country" => Country
            "postal_code" | "zip" => PostalCode
            "airport" => Airport
            "park" => Park
            "point_of_interest" | "poi" => PointOfInterest
            "establishment" => Establishment
            _ => Unknown
        }
    }
}

// -----------------------------------------------------------------------------
// Geocoder
// -----------------------------------------------------------------------------

/// Geocoding service interface
trait Geocoder {
    /// Forward geocoding: address to coordinates
    fn geocode(address: String) -> Result<[GeocodingResult], GeocodingError>
    
    /// Reverse geocoding: coordinates to address
    fn reverse_geocode(location: GeoCoord) -> Result<[GeocodingResult], GeocodingError>
    
    /// Autocomplete suggestions
    fn autocomplete(query: String, location: Option<GeoCoord>) -> Result<[AutocompleteSuggestion], GeocodingError>
}

/// Autocomplete suggestion
struct AutocompleteSuggestion {
    text: String
    place_id: Option<String>
    description: String
    matched_substrings: [(Int, Int)]
    
    fn new(text: String, description: String) -> Self {
        AutocompleteSuggestion {
            text: text,
            place_id: None,
            description: description,
            matched_substrings: []
        }
    }
}

// -----------------------------------------------------------------------------
// Local Geocoder (Offline)
// -----------------------------------------------------------------------------

/// Simple offline geocoder using local database
struct LocalGeocoder {
    places: [Place]
    
    fn new() -> Self {
        LocalGeocoder { places: [] }
    }
    
    fn add_place(place: Place) {
        self.places.push(place)
    }
    
    fn load_from_csv(path: String) -> Result<Self, GeocodingError> {
        // Load places from CSV file
        @native("geocoder_load_csv", path)
    }
}

impl Geocoder for LocalGeocoder {
    fn geocode(address: String) -> Result<[GeocodingResult], GeocodingError> {
        let query = address.to_lower()
        var results = []
        
        for place in self.places {
            let score = fuzzy_match_score(query, place.name.to_lower())
            if score > 0.5 {
                let addr = Address.new()
                    .with_city(place.name.clone())
                    .with_country(place.country.clone(), place.country_code.clone())
                
                results.push(GeocodingResult.new(place.location, addr)
                    .with_confidence(score)
                    .with_place_type(place.place_type))
            }
        }
        
        results.sort_by(|a, b| b.confidence.cmp(a.confidence))
        Ok(results)
    }
    
    fn reverse_geocode(location: GeoCoord) -> Result<[GeocodingResult], GeocodingError> {
        var results = []
        
        for place in self.places {
            let dist = haversine_distance(location, place.location)
            if dist < 50000.0 {  // Within 50km
                let confidence = 1.0 - (dist / 50000.0)
                let addr = Address.new()
                    .with_city(place.name.clone())
                    .with_country(place.country.clone(), place.country_code.clone())
                
                results.push(GeocodingResult.new(place.location, addr)
                    .with_confidence(confidence)
                    .with_place_type(place.place_type))
            }
        }
        
        results.sort_by(|a, b| b.confidence.cmp(a.confidence))
        Ok(results)
    }
    
    fn autocomplete(query: String, location: Option<GeoCoord>) -> Result<[AutocompleteSuggestion], GeocodingError> {
        let query_lower = query.to_lower()
        var suggestions = []
        
        for place in self.places {
            if place.name.to_lower().starts_with(query_lower) {
                var suggestion = AutocompleteSuggestion.new(
                    place.name.clone(),
                    format!("{}, {}", place.name, place.country)
                )
                
                // Boost nearby places
                if let Some(loc) = location {
                    let dist = haversine_distance(loc, place.location)
                    if dist < 100000.0 {
                        suggestions.insert(0, suggestion)
                        continue
                    }
                }
                
                suggestions.push(suggestion)
            }
        }
        
        Ok(suggestions[0..min(10, suggestions.len())])
    }
}

/// Place entry for local geocoder
struct Place {
    name: String
    location: GeoCoord
    country: String
    country_code: String
    place_type: PlaceType
    population: Option<Int>
    
    fn new(name: String, location: GeoCoord) -> Self {
        Place {
            name: name,
            location: location,
            country: "",
            country_code: "",
            place_type: PlaceType.Unknown,
            population: None
        }
    }
}

// -----------------------------------------------------------------------------
// HTTP Geocoder (Online)
// -----------------------------------------------------------------------------

/// HTTP-based geocoder for external services
struct HttpGeocoder {
    base_url: String
    api_key: Option<String>
    provider: GeocodingProvider
    
    fn new(provider: GeocodingProvider) -> Self {
        HttpGeocoder {
            base_url: provider.base_url(),
            api_key: None,
            provider: provider
        }
    }
    
    fn with_api_key(key: String) -> Self {
        self.api_key = Some(key)
        self
    }
}

impl Geocoder for HttpGeocoder {
    fn geocode(address: String) -> Result<[GeocodingResult], GeocodingError> {
        let url = self.provider.build_geocode_url(address, self.api_key.clone())
        let response = http.get(url)?
        self.provider.parse_geocode_response(response.text())
    }
    
    fn reverse_geocode(location: GeoCoord) -> Result<[GeocodingResult], GeocodingError> {
        let url = self.provider.build_reverse_url(location, self.api_key.clone())
        let response = http.get(url)?
        self.provider.parse_geocode_response(response.text())
    }
    
    fn autocomplete(query: String, location: Option<GeoCoord>) -> Result<[AutocompleteSuggestion], GeocodingError> {
        let url = self.provider.build_autocomplete_url(query, location, self.api_key.clone())
        let response = http.get(url)?
        self.provider.parse_autocomplete_response(response.text())
    }
}

/// Geocoding service provider
enum GeocodingProvider {
    Nominatim
    GoogleMaps
    Mapbox
    Here
    OpenCage
}

impl GeocodingProvider {
    fn base_url() -> String {
        match self {
            Nominatim => "https://nominatim.openstreetmap.org"
            GoogleMaps => "https://maps.googleapis.com/maps/api"
            Mapbox => "https://api.mapbox.com/geocoding/v5"
            Here => "https://geocode.search.hereapi.com/v1"
            OpenCage => "https://api.opencagedata.com/geocode/v1"
        }
    }
    
    fn build_geocode_url(address: String, api_key: Option<String>) -> String {
        let encoded = url.encode(address)
        match self {
            Nominatim => format!("{}/search?q={}&format=json", self.base_url(), encoded)
            GoogleMaps => format!("{}/geocode/json?address={}&key={}", 
                self.base_url(), encoded, api_key.unwrap_or(""))
            Mapbox => format!("{}/mapbox.places/{}.json?access_token={}", 
                self.base_url(), encoded, api_key.unwrap_or(""))
            _ => format!("{}/geocode?q={}", self.base_url(), encoded)
        }
    }
    
    fn build_reverse_url(location: GeoCoord, api_key: Option<String>) -> String {
        match self {
            Nominatim => format!("{}/reverse?lat={}&lon={}&format=json", 
                self.base_url(), location.lat, location.lon)
            GoogleMaps => format!("{}/geocode/json?latlng={},{}&key={}", 
                self.base_url(), location.lat, location.lon, api_key.unwrap_or(""))
            _ => format!("{}/reverse?lat={}&lon={}", 
                self.base_url(), location.lat, location.lon)
        }
    }
    
    fn build_autocomplete_url(query: String, location: Option<GeoCoord>, api_key: Option<String>) -> String {
        let encoded = url.encode(query)
        match self {
            GoogleMaps => {
                var url = format!("{}/place/autocomplete/json?input={}&key={}", 
                    self.base_url(), encoded, api_key.unwrap_or(""))
                if let Some(loc) = location {
                    url += format!("&location={},{}", loc.lat, loc.lon)
                }
                url
            }
            _ => format!("{}/autocomplete?q={}", self.base_url(), encoded)
        }
    }
    
    fn parse_geocode_response(json: String) -> Result<[GeocodingResult], GeocodingError> {
        // Parse JSON response based on provider format
        @native("geocoder_parse_response", self, json)
    }
    
    fn parse_autocomplete_response(json: String) -> Result<[AutocompleteSuggestion], GeocodingError> {
        @native("geocoder_parse_autocomplete", self, json)
    }
}

// -----------------------------------------------------------------------------
// Batch Geocoder
// -----------------------------------------------------------------------------

/// Batch geocoding for multiple addresses
struct BatchGeocoder {
    geocoder: impl Geocoder
    rate_limit: Int  // requests per second
    
    fn new(geocoder: impl Geocoder) -> Self {
        BatchGeocoder { geocoder: geocoder, rate_limit: 10 }
    }
    
    fn with_rate_limit(limit: Int) -> Self {
        self.rate_limit = limit
        self
    }
    
    /// Geocode multiple addresses
    async fn geocode_batch(addresses: [String]) -> [Result<GeocodingResult, GeocodingError>] {
        var results = []
        let delay = Duration.from_millis(1000 / self.rate_limit as Int64)
        
        for address in addresses {
            let result = self.geocoder.geocode(address)
                .map(|r| r.first().cloned())
                .flatten()
                .ok_or(GeocodingError.NotFound)
            results.push(result)
            
            sleep(delay).await
        }
        
        results
    }
    
    /// Reverse geocode multiple locations
    async fn reverse_batch(locations: [GeoCoord]) -> [Result<GeocodingResult, GeocodingError>] {
        var results = []
        let delay = Duration.from_millis(1000 / self.rate_limit as Int64)
        
        for location in locations {
            let result = self.geocoder.reverse_geocode(location)
                .map(|r| r.first().cloned())
                .flatten()
                .ok_or(GeocodingError.NotFound)
            results.push(result)
            
            sleep(delay).await
        }
        
        results
    }
}

// -----------------------------------------------------------------------------
// Geocoding Cache
// -----------------------------------------------------------------------------

/// Caching layer for geocoding results
struct GeocodingCache {
    geocoder: impl Geocoder
    cache: Map<String, (GeocodingResult, Instant)>
    ttl: Duration
    max_size: Int
    
    fn new(geocoder: impl Geocoder) -> Self {
        GeocodingCache {
            geocoder: geocoder,
            cache: Map.empty(),
            ttl: Duration.from_hours(24),
            max_size: 10000
        }
    }
    
    fn with_ttl(ttl: Duration) -> Self {
        self.ttl = ttl
        self
    }
    
    fn geocode_cached(address: String) -> Result<[GeocodingResult], GeocodingError> {
        let key = address.to_lower()
        
        // Check cache
        if let Some((result, timestamp)) = self.cache.get(key) {
            if Instant.now().duration_since(*timestamp) < self.ttl {
                return Ok([result.clone()])
            }
        }
        
        // Fetch and cache
        let results = self.geocoder.geocode(address)?
        if let Some(result) = results.first() {
            self.cache_result(key, result.clone())
        }
        
        Ok(results)
    }
    
    fn cache_result(key: String, result: GeocodingResult) {
        // Evict old entries if needed
        if self.cache.len() >= self.max_size {
            self.evict_oldest()
        }
        self.cache.set(key, (result, Instant.now()))
    }
    
    fn evict_oldest() {
        var oldest_key: Option<String> = None
        var oldest_time = Instant.now()
        
        for (key, (_, timestamp)) in self.cache {
            if *timestamp < oldest_time {
                oldest_time = *timestamp
                oldest_key = Some(key.clone())
            }
        }
        
        if let Some(key) = oldest_key {
            self.cache.remove(key)
        }
    }
    
    fn clear() {
        self.cache.clear()
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum GeocodingError {
    NotFound
    InvalidAddress(String)
    RateLimited
    ServiceUnavailable(String)
    ParseError(String)
    NetworkError(String)
}

impl Display for GeocodingError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("Address not found")
            InvalidAddress(msg) => f.write(format!("Invalid address: {}", msg))
            RateLimited => f.write("Rate limit exceeded")
            ServiceUnavailable(msg) => f.write(format!("Service unavailable: {}", msg))
            ParseError(msg) => f.write(format!("Parse error: {}", msg))
            NetworkError(msg) => f.write(format!("Network error: {}", msg))
        }
    }
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

fn fuzzy_match_score(query: String, target: String) -> Float64 {
    if query == target { return 1.0 }
    if target.starts_with(query) { return 0.9 }
    if target.contains(query) { return 0.7 }
    
    // Simple Levenshtein-based score
    let distance = levenshtein_distance(query, target)
    let max_len = max(query.len(), target.len()) as Float64
    1.0 - (distance as Float64 / max_len)
}

fn levenshtein_distance(s1: String, s2: String) -> Int {
    let m = s1.len()
    let n = s2.len()
    
    if m == 0 { return n }
    if n == 0 { return m }
    
    var prev = (0..=n).collect()
    var curr = vec![0; n + 1]
    
    for i in 1..=m {
        curr[0] = i
        for j in 1..=n {
            let cost = if s1.char_at(i-1) == s2.char_at(j-1) { 0 } else { 1 }
            curr[j] = min(min(prev[j] + 1, curr[j-1] + 1), prev[j-1] + cost)
        }
        swap(prev, curr)
    }
    
    prev[n]
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "address formatting" {
    let addr = Address.new()
        .with_street("123", "Main Street")
        .with_city("New York")
        .with_state("NY")
        .with_postal_code("10001")
        .with_country("United States", "US")
    
    let formatted = addr.format_line()
    assert(formatted.contains("123 Main Street"))?
    assert(formatted.contains("New York"))?
}

test "address parsing" {
    let addr = Address.parse("123 Main St, New York, NY, USA")
    assert_eq(addr.street_number, Some("123"))?
    assert(addr.city.is_some())?
}

test "local geocoder" {
    var geocoder = LocalGeocoder.new()
    geocoder.add_place(Place {
        name: "New York",
        location: GeoCoord.unchecked(40.7128, -74.0060),
        country: "United States",
        country_code: "US",
        place_type: PlaceType.City,
        population: Some(8336817)
    })
    
    let results = geocoder.geocode("New York")?
    assert(results.len() > 0)?
}

test "fuzzy matching" {
    assert(fuzzy_match_score("new york", "new york") == 1.0)?
    assert(fuzzy_match_score("new", "new york") > 0.5)?
}
