// =============================================================================
// Vibee OS â€” CMS Page Module
// Content Management System pages with versioning and publishing workflow
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}
use slug::{slugify}

// =============================================================================
// Page Types
// =============================================================================

/// Page status
enum PageStatus {
    Draft,
    PendingReview,
    Scheduled,
    Published,
    Archived,
    Deleted
}

impl PageStatus {
    fn is_visible() -> Bool {
        match self {
            PageStatus.Published => true,
            _ => false
        }
    }
    
    fn is_editable() -> Bool {
        match self {
            PageStatus.Draft | PageStatus.PendingReview => true,
            _ => false
        }
    }
    
    fn display_name() -> String {
        match self {
            PageStatus.Draft => "Draft",
            PageStatus.PendingReview => "Pending Review",
            PageStatus.Scheduled => "Scheduled",
            PageStatus.Published => "Published",
            PageStatus.Archived => "Archived",
            PageStatus.Deleted => "Deleted"
        }
    }
}

/// Page template type
enum PageTemplate {
    Default,
    Landing,
    Blog,
    Contact,
    About,
    Product,
    Service,
    FAQ,
    Legal,
    Custom(String)
}

impl PageTemplate {
    fn template_file() -> String {
        match self {
            PageTemplate.Default => "default.html",
            PageTemplate.Landing => "landing.html",
            PageTemplate.Blog => "blog.html",
            PageTemplate.Contact => "contact.html",
            PageTemplate.About => "about.html",
            PageTemplate.Product => "product.html",
            PageTemplate.Service => "service.html",
            PageTemplate.FAQ => "faq.html",
            PageTemplate.Legal => "legal.html",
            PageTemplate.Custom(name) => format!("{}.html", name)
        }
    }
}

/// Page visibility
enum PageVisibility {
    Public,
    Private,
    PasswordProtected(String),
    MembersOnly,
    RoleRestricted([String])
}

impl PageVisibility {
    fn is_public() -> Bool {
        match self {
            PageVisibility.Public => true,
            _ => false
        }
    }
}

// =============================================================================
// Page Content
// =============================================================================

/// Content block within a page
struct ContentSection {
    id: String,
    name: String,
    content: String,
    content_type: String,
    position: Int,
    metadata: Map<String, String>
}

impl ContentSection {
    fn new(name: String, content: String) -> Self {
        ContentSection {
            id: generate_id(),
            name: name,
            content: content,
            content_type: "html",
            position: 0,
            metadata: Map.empty()
        }
    }
    
    fn markdown(name: String, content: String) -> Self {
        ContentSection {
            id: generate_id(),
            name: name,
            content: content,
            content_type: "markdown",
            position: 0,
            metadata: Map.empty()
        }
    }
    
    fn with_position(position: Int) -> Self {
        self.position = position
        self
    }
}

// =============================================================================
// Page Structure
// =============================================================================

/// CMS Page
struct Page {
    id: String,
    title: String,
    slug: String,
    content: String,
    excerpt: Option<String>,
    template: PageTemplate,
    status: PageStatus,
    visibility: PageVisibility,
    parent_id: Option<String>,
    author_id: String,
    featured_image: Option<String>,
    sections: [ContentSection],
    seo_title: Option<String>,
    seo_description: Option<String>,
    seo_keywords: [String],
    canonical_url: Option<String>,
    og_image: Option<String>,
    custom_css: Option<String>,
    custom_js: Option<String>,
    menu_order: Int,
    show_in_menu: Bool,
    allow_comments: Bool,
    version: Int,
    published_at: Option<DateTime>,
    scheduled_at: Option<DateTime>,
    created_at: DateTime,
    updated_at: DateTime,
    metadata: Map<String, String>
}

impl Page {
    fn new(title: String, author_id: String) -> Self {
        let now = DateTime.now()
        Page {
            id: generate_id(),
            title: title.clone(),
            slug: slugify(title),
            content: "",
            excerpt: None,
            template: PageTemplate.Default,
            status: PageStatus.Draft,
            visibility: PageVisibility.Public,
            parent_id: None,
            author_id: author_id,
            featured_image: None,
            sections: [],
            seo_title: None,
            seo_description: None,
            seo_keywords: [],
            canonical_url: None,
            og_image: None,
            custom_css: None,
            custom_js: None,
            menu_order: 0,
            show_in_menu: true,
            allow_comments: false,
            version: 1,
            published_at: None,
            scheduled_at: None,
            created_at: now,
            updated_at: now,
            metadata: Map.empty()
        }
    }
    
    fn with_content(content: String) -> Self {
        self.content = content
        self.updated_at = DateTime.now()
        self
    }
    
    fn with_excerpt(excerpt: String) -> Self {
        self.excerpt = Some(excerpt)
        self
    }
    
    fn with_template(template: PageTemplate) -> Self {
        self.template = template
        self
    }
    
    fn with_slug(slug: String) -> Self {
        self.slug = slug
        self
    }
    
    fn with_parent(parent_id: String) -> Self {
        self.parent_id = Some(parent_id)
        self
    }
    
    fn with_featured_image(url: String) -> Self {
        self.featured_image = Some(url)
        self
    }
    
    fn with_seo(title: String, description: String, keywords: [String]) -> Self {
        self.seo_title = Some(title)
        self.seo_description = Some(description)
        self.seo_keywords = keywords
        self
    }
    
    fn with_visibility(visibility: PageVisibility) -> Self {
        self.visibility = visibility
        self
    }
    
    fn add_section(section: ContentSection) {
        self.sections.push(section)
        self.updated_at = DateTime.now()
    }
    
    fn publish() -> Result<(), PageError> {
        if self.content.is_empty() {
            return Err(PageError.EmptyContent)
        }
        self.status = PageStatus.Published
        self.published_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        self.version += 1
        Ok(())
    }
    
    fn unpublish() {
        self.status = PageStatus.Draft
        self.updated_at = DateTime.now()
    }
    
    fn schedule(publish_at: DateTime) -> Result<(), PageError> {
        if publish_at <= DateTime.now() {
            return Err(PageError.InvalidScheduleTime)
        }
        self.status = PageStatus.Scheduled
        self.scheduled_at = Some(publish_at)
        self.updated_at = DateTime.now()
        Ok(())
    }
    
    fn submit_for_review() {
        self.status = PageStatus.PendingReview
        self.updated_at = DateTime.now()
    }
    
    fn archive() {
        self.status = PageStatus.Archived
        self.updated_at = DateTime.now()
    }
    
    fn delete() {
        self.status = PageStatus.Deleted
        self.updated_at = DateTime.now()
    }
    
    fn restore() {
        self.status = PageStatus.Draft
        self.updated_at = DateTime.now()
    }
    
    fn is_published() -> Bool { self.status.is_visible() }
    fn is_draft() -> Bool { matches!(self.status, PageStatus.Draft) }
    fn is_scheduled() -> Bool { matches!(self.status, PageStatus.Scheduled) }
    
    fn url() -> String {
        format!("/{}", self.slug)
    }
    
    fn full_url(base_url: String) -> String {
        format!("{}/{}", base_url.trim_end_matches('/'), self.slug)
    }
    
    fn effective_seo_title() -> String {
        self.seo_title.clone().unwrap_or(self.title.clone())
    }
    
    fn effective_seo_description() -> String {
        self.seo_description.clone()
            .or(self.excerpt.clone())
            .unwrap_or_else(|| self.content[0..160].to_string())
    }
}

// =============================================================================
// Page Version
// =============================================================================

/// Page version for history tracking
struct PageVersion {
    id: String,
    page_id: String,
    version: Int,
    title: String,
    content: String,
    sections: [ContentSection],
    author_id: String,
    change_summary: Option<String>,
    created_at: DateTime
}

impl PageVersion {
    fn from_page(page: Page, change_summary: Option<String>) -> Self {
        PageVersion {
            id: generate_id(),
            page_id: page.id.clone(),
            version: page.version,
            title: page.title.clone(),
            content: page.content.clone(),
            sections: page.sections.clone(),
            author_id: page.author_id.clone(),
            change_summary: change_summary,
            created_at: DateTime.now()
        }
    }
    
    fn restore_to(page: Page) -> Page {
        var restored = page.clone()
        restored.title = self.title.clone()
        restored.content = self.content.clone()
        restored.sections = self.sections.clone()
        restored.version += 1
        restored.updated_at = DateTime.now()
        restored
    }
}

// =============================================================================
// Page Errors
// =============================================================================

/// Page errors
enum PageError {
    NotFound,
    SlugExists,
    EmptyContent,
    InvalidScheduleTime,
    ParentNotFound,
    CircularReference,
    PermissionDenied,
    InvalidTemplate,
    VersionNotFound,
    ValidationFailed(String)
}

impl PageError {
    fn message() -> String {
        match self {
            PageError.NotFound => "Page not found",
            PageError.SlugExists => "Page with this slug already exists",
            PageError.EmptyContent => "Page content cannot be empty",
            PageError.InvalidScheduleTime => "Schedule time must be in the future",
            PageError.ParentNotFound => "Parent page not found",
            PageError.CircularReference => "Circular reference detected",
            PageError.PermissionDenied => "Permission denied",
            PageError.InvalidTemplate => "Invalid template",
            PageError.VersionNotFound => "Version not found",
            PageError.ValidationFailed(msg) => msg
        }
    }
}

// =============================================================================
// Page Service
// =============================================================================

/// Page service actor
actor PageService {
    state pages: Map<String, Page>
    state slug_index: Map<String, String>
    state parent_children: Map<String, [String]>
    state versions: Map<String, [PageVersion]>
    state scheduled_pages: [String]
    
    fn new() -> Self {
        PageService {
            pages: Map.empty(),
            slug_index: Map.empty(),
            parent_children: Map.empty(),
            versions: Map.empty(),
            scheduled_pages: []
        }
    }
    
    /// Create a new page
    on create(page: Page) -> Result<Page, PageError> {
        if self.slug_index.contains_key(page.slug.clone()) {
            return Err(PageError.SlugExists)
        }
        
        if let Some(parent_id) = page.parent_id.clone() {
            if !self.pages.contains_key(parent_id.clone()) {
                return Err(PageError.ParentNotFound)
            }
        }
        
        let page_id = page.id.clone()
        self.pages.set(page_id.clone(), page.clone())
        self.slug_index.set(page.slug.clone(), page_id.clone())
        
        if let Some(parent_id) = page.parent_id.clone() {
            self.parent_children.entry(parent_id).or_insert([]).push(page_id)
        }
        
        // Save initial version
        let version = PageVersion.from_page(page.clone(), Some("Initial creation".to_string()))
        self.versions.entry(page.id.clone()).or_insert([]).push(version)
        
        Ok(page)
    }
    
    /// Get page by ID
    on get(page_id: String) -> Option<Page> {
        self.pages.get(page_id)
    }
    
    /// Get page by slug
    on get_by_slug(slug: String) -> Option<Page> {
        self.slug_index.get(slug)
            .and_then(|id| self.pages.get(id))
    }
    
    /// Update page
    on update(page_id: String, title: Option<String>, content: Option<String>, change_summary: Option<String>) -> Result<Page, PageError> {
        let page = self.pages.get_mut(page_id.clone())
            .ok_or(PageError.NotFound)?
        
        // Save version before update
        let version = PageVersion.from_page(page.clone(), change_summary)
        self.versions.entry(page_id.clone()).or_insert([]).push(version)
        
        if let Some(t) = title {
            let new_slug = slugify(t.clone())
            if new_slug != page.slug && self.slug_index.contains_key(new_slug.clone()) {
                return Err(PageError.SlugExists)
            }
            self.slug_index.remove(page.slug.clone())
            self.slug_index.set(new_slug.clone(), page_id)
            page.title = t
            page.slug = new_slug
        }
        
        if let Some(c) = content {
            page.content = c
        }
        
        page.version += 1
        page.updated_at = DateTime.now()
        Ok(page.clone())
    }
    
    /// Publish page
    on publish(page_id: String) -> Result<Page, PageError> {
        let page = self.pages.get_mut(page_id)
            .ok_or(PageError.NotFound)?
        page.publish()?
        Ok(page.clone())
    }
    
    /// Unpublish page
    on unpublish(page_id: String) -> Result<Page, PageError> {
        let page = self.pages.get_mut(page_id)
            .ok_or(PageError.NotFound)?
        page.unpublish()
        Ok(page.clone())
    }
    
    /// Schedule page publication
    on schedule(page_id: String, publish_at: DateTime) -> Result<Page, PageError> {
        let page = self.pages.get_mut(page_id.clone())
            .ok_or(PageError.NotFound)?
        page.schedule(publish_at)?
        self.scheduled_pages.push(page_id)
        Ok(page.clone())
    }
    
    /// Delete page
    on delete(page_id: String) -> Result<(), PageError> {
        let page = self.pages.get_mut(page_id.clone())
            .ok_or(PageError.NotFound)?
        
        // Check for children
        if let Some(children) = self.parent_children.get(page_id.clone()) {
            if !children.is_empty() {
                return Err(PageError.ValidationFailed("Cannot delete page with children".to_string()))
            }
        }
        
        page.delete()
        self.slug_index.remove(page.slug.clone())
        Ok(())
    }
    
    /// Get all published pages
    on get_published() -> [Page] {
        self.pages.values()
            .filter(|p| p.is_published())
            .collect()
    }
    
    /// Get pages by status
    on get_by_status(status: PageStatus) -> [Page] {
        self.pages.values()
            .filter(|p| p.status == status)
            .collect()
    }
    
    /// Get child pages
    on get_children(parent_id: String) -> [Page] {
        self.parent_children.get(parent_id)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.pages.get(id))
                    .collect()
            })
            .unwrap_or([])
    }
    
    /// Get page versions
    on get_versions(page_id: String) -> [PageVersion] {
        self.versions.get(page_id).unwrap_or([])
    }
    
    /// Restore page to version
    on restore_version(page_id: String, version_number: Int) -> Result<Page, PageError> {
        let versions = self.versions.get(page_id.clone())
            .ok_or(PageError.VersionNotFound)?
        
        let version = versions.iter()
            .find(|v| v.version == version_number)
            .ok_or(PageError.VersionNotFound)?
        
        let page = self.pages.get_mut(page_id)
            .ok_or(PageError.NotFound)?
        
        *page = version.restore_to(page.clone())
        Ok(page.clone())
    }
    
    /// Process scheduled pages
    on process_scheduled() -> [Page] {
        let now = DateTime.now()
        var published: [Page] = []
        
        self.scheduled_pages.retain(|page_id| {
            if let Some(page) = self.pages.get_mut(page_id.clone()) {
                if let Some(scheduled_at) = page.scheduled_at {
                    if scheduled_at <= now {
                        page.status = PageStatus.Published
                        page.published_at = Some(now)
                        page.scheduled_at = None
                        published.push(page.clone())
                        return false
                    }
                }
            }
            true
        })
        
        published
    }
    
    /// Search pages
    on search(query: String) -> [Page] {
        let query_lower = query.to_lower()
        self.pages.values()
            .filter(|p| {
                p.title.to_lower().contains(query_lower.clone()) ||
                p.content.to_lower().contains(query_lower.clone())
            })
            .collect()
    }
    
    /// Get menu pages
    on get_menu_pages() -> [Page] {
        var pages: [Page] = self.pages.values()
            .filter(|p| p.is_published() && p.show_in_menu)
            .collect()
        pages.sort_by(|a, b| a.menu_order.cmp(b.menu_order))
        pages
    }
}

// =============================================================================
// Page Builder
// =============================================================================

/// Fluent page builder
struct PageBuilder {
    page: Page
}

impl PageBuilder {
    fn new(title: String, author_id: String) -> Self {
        PageBuilder { page: Page.new(title, author_id) }
    }
    
    fn content(content: String) -> Self {
        self.page.content = content
        self
    }
    
    fn excerpt(excerpt: String) -> Self {
        self.page.excerpt = Some(excerpt)
        self
    }
    
    fn template(template: PageTemplate) -> Self {
        self.page.template = template
        self
    }
    
    fn slug(slug: String) -> Self {
        self.page.slug = slug
        self
    }
    
    fn parent(parent_id: String) -> Self {
        self.page.parent_id = Some(parent_id)
        self
    }
    
    fn featured_image(url: String) -> Self {
        self.page.featured_image = Some(url)
        self
    }
    
    fn seo(title: String, description: String) -> Self {
        self.page.seo_title = Some(title)
        self.page.seo_description = Some(description)
        self
    }
    
    fn keywords(keywords: [String]) -> Self {
        self.page.seo_keywords = keywords
        self
    }
    
    fn visibility(visibility: PageVisibility) -> Self {
        self.page.visibility = visibility
        self
    }
    
    fn section(name: String, content: String) -> Self {
        self.page.sections.push(ContentSection.new(name, content))
        self
    }
    
    fn menu_order(order: Int) -> Self {
        self.page.menu_order = order
        self
    }
    
    fn hide_from_menu() -> Self {
        self.page.show_in_menu = false
        self
    }
    
    fn allow_comments() -> Self {
        self.page.allow_comments = true
        self
    }
    
    fn custom_css(css: String) -> Self {
        self.page.custom_css = Some(css)
        self
    }
    
    fn custom_js(js: String) -> Self {
        self.page.custom_js = Some(js)
        self
    }
    
    fn metadata(key: String, value: String) -> Self {
        self.page.metadata.set(key, value)
        self
    }
    
    fn build() -> Page {
        self.page
    }
    
    fn build_and_publish() -> Result<Page, PageError> {
        self.page.publish()?
        Ok(self.page)
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create page" {
    let page = Page.new("Welcome", "user1")
    assert_eq(page.title, "Welcome")?
    assert_eq(page.slug, "welcome")?
    assert_eq(page.status, PageStatus.Draft)?
}

test "publish page" {
    var page = Page.new("Test", "user1")
        .with_content("Hello World")
    
    page.publish()?
    assert_eq(page.status, PageStatus.Published)?
    assert(page.published_at.is_some())?
}

test "page builder" {
    let page = PageBuilder.new("About Us", "user1")
        .content("<h1>About</h1><p>We are awesome</p>")
        .template(PageTemplate.About)
        .seo("About Our Company", "Learn about our company")
        .menu_order(2)
        .build()
    
    assert_eq(page.title, "About Us")?
    assert_eq(page.template, PageTemplate.About)?
}

test "page service" {
    var service = PageService.new()
    
    let page = Page.new("Home", "user1")
        .with_content("Welcome to our site")
    
    let created = service.create(page)?
    assert_eq(created.title, "Home")?
    
    let found = service.get_by_slug("home")
    assert(found.is_some())?
}

test "page versioning" {
    var service = PageService.new()
    
    let page = Page.new("Test", "user1")
        .with_content("Version 1")
    
    service.create(page)?
    service.update(page.id.clone(), None, Some("Version 2"), Some("Updated content"))?
    
    let versions = service.get_versions(page.id)
    assert_eq(versions.len(), 2)?
}

test "schedule page" {
    var page = Page.new("Future Post", "user1")
        .with_content("Coming soon")
    
    let future = DateTime.now().add(Duration.days(1))
    page.schedule(future)?
    
    assert_eq(page.status, PageStatus.Scheduled)?
}
