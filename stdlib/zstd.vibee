// =============================================================================
// Vibee OS â€” Zstd Module
// Zstandard compression and decompression (RFC 8878)
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

const ZSTD_MAGIC: UInt32 = 0xFD2FB528
const ZSTD_MIN_CLEVEL: Int = -131072
const ZSTD_MAX_CLEVEL: Int = 22
const ZSTD_DEFAULT_CLEVEL: Int = 3
const ZSTD_CONTENTSIZE_UNKNOWN: UInt64 = 0xFFFFFFFFFFFFFFFF
const ZSTD_CONTENTSIZE_ERROR: UInt64 = 0xFFFFFFFFFFFFFFFE

// =============================================================================
// Compression Level
// =============================================================================

/// Zstd compression level
enum ZstdLevel {
    Fastest     // Level -5 (negative levels for speed)
    Fast        // Level 1
    Default     // Level 3
    Better      // Level 9
    Best        // Level 19
    Ultra       // Level 22 (maximum compression)
    Custom(Int) // Custom level (-131072 to 22)
}

impl ZstdLevel {
    fn value() -> Int {
        match self {
            Fastest => -5
            Fast => 1
            Default => 3
            Better => 9
            Best => 19
            Ultra => 22
            Custom(n) => n.clamp(ZSTD_MIN_CLEVEL, ZSTD_MAX_CLEVEL)
        }
    }
    
    fn from_int(level: Int) -> Self {
        match level {
            -5 => ZstdLevel.Fastest
            1 => ZstdLevel.Fast
            3 => ZstdLevel.Default
            9 => ZstdLevel.Better
            19 => ZstdLevel.Best
            22 => ZstdLevel.Ultra
            n => ZstdLevel.Custom(n)
        }
    }
}

// =============================================================================
// Compression Strategy
// =============================================================================

/// Zstd compression strategy
enum ZstdStrategy {
    Fast
    DFast
    Greedy
    Lazy
    Lazy2
    BtLazy2
    BtOpt
    BtUltra
    BtUltra2
}

impl ZstdStrategy {
    fn value() -> Int {
        match self {
            Fast => 1
            DFast => 2
            Greedy => 3
            Lazy => 4
            Lazy2 => 5
            BtLazy2 => 6
            BtOpt => 7
            BtUltra => 8
            BtUltra2 => 9
        }
    }
}

// =============================================================================
// Compression Parameters
// =============================================================================

/// Zstd compression parameters
struct ZstdParams {
    level: Int
    window_log: Option<Int>
    hash_log: Option<Int>
    chain_log: Option<Int>
    search_log: Option<Int>
    min_match: Option<Int>
    target_length: Option<Int>
    strategy: Option<ZstdStrategy>
    enable_long_distance_matching: Bool
    ldm_hash_log: Option<Int>
    ldm_min_match: Option<Int>
    ldm_bucket_size_log: Option<Int>
    ldm_hash_rate_log: Option<Int>
    content_size_flag: Bool
    checksum_flag: Bool
    dict_id_flag: Bool
    nb_workers: Int
}

impl ZstdParams {
    fn new() -> Self {
        ZstdParams {
            level: ZSTD_DEFAULT_CLEVEL,
            window_log: None,
            hash_log: None,
            chain_log: None,
            search_log: None,
            min_match: None,
            target_length: None,
            strategy: None,
            enable_long_distance_matching: false,
            ldm_hash_log: None,
            ldm_min_match: None,
            ldm_bucket_size_log: None,
            ldm_hash_rate_log: None,
            content_size_flag: true,
            checksum_flag: false,
            dict_id_flag: true,
            nb_workers: 0
        }
    }
    
    fn with_level(level: ZstdLevel) -> Self {
        var params = Self.new()
        params.level = level.value()
        params
    }
    
    fn level(l: ZstdLevel) -> Self { self.level = l.value(); self }
    fn window_log(log: Int) -> Self { self.window_log = Some(log); self }
    fn strategy(s: ZstdStrategy) -> Self { self.strategy = Some(s); self }
    fn checksum(enabled: Bool) -> Self { self.checksum_flag = enabled; self }
    fn workers(n: Int) -> Self { self.nb_workers = n; self }
    fn long_distance_matching(enabled: Bool) -> Self { self.enable_long_distance_matching = enabled; self }
}

// =============================================================================
// Core Functions
// =============================================================================

/// Compress data using zstd with default level
fn compress(data: [UInt8]) -> Result<[UInt8], ZstdError> {
    compress_level(data, ZstdLevel.Default)
}

/// Compress data using zstd with specified level
fn compress_level(data: [UInt8], level: ZstdLevel) -> Result<[UInt8], ZstdError> {
    @native("zstd_compress", data, level.value())
}

/// Compress data with parameters
fn compress_with_params(data: [UInt8], params: ZstdParams) -> Result<[UInt8], ZstdError> {
    @native("zstd_compress_params", data, params)
}

/// Decompress zstd data
fn decompress(data: [UInt8]) -> Result<[UInt8], ZstdError> {
    @native("zstd_decompress", data)
}

/// Decompress with size hint
fn decompress_with_hint(data: [UInt8], size_hint: Int) -> Result<[UInt8], ZstdError> {
    @native("zstd_decompress_hint", data, size_hint)
}

/// Check if data is zstd compressed
fn is_zstd(data: [UInt8]) -> Bool {
    if data.len() < 4 { return false }
    let magic = (data[0] as UInt32) | ((data[1] as UInt32) << 8) | 
                ((data[2] as UInt32) << 16) | ((data[3] as UInt32) << 24)
    magic == ZSTD_MAGIC
}

/// Get content size from frame header
fn get_content_size(data: [UInt8]) -> Option<UInt64> {
    let size = @native("zstd_get_content_size", data)
    if size == ZSTD_CONTENTSIZE_UNKNOWN || size == ZSTD_CONTENTSIZE_ERROR {
        None
    } else {
        Some(size)
    }
}

/// Get dictionary ID from frame
fn get_dict_id(data: [UInt8]) -> Option<UInt32> {
    let id = @native("zstd_get_dict_id", data)
    if id == 0 { None } else { Some(id) }
}

// =============================================================================
// Streaming Compressor
// =============================================================================

/// Streaming zstd compressor
struct ZstdCompressor {
    inner: @native("ZstdCompressor")
    level: Int
    bytes_in: Int64
    bytes_out: Int64
}

impl ZstdCompressor {
    fn new() -> Self { Self.with_level(ZstdLevel.Default) }
    
    fn with_level(level: ZstdLevel) -> Self {
        ZstdCompressor {
            inner: @native("zstd_compressor_new", level.value()),
            level: level.value(),
            bytes_in: 0,
            bytes_out: 0
        }
    }
    
    fn with_params(params: ZstdParams) -> Self {
        ZstdCompressor {
            inner: @native("zstd_compressor_new_params", params),
            level: params.level,
            bytes_in: 0,
            bytes_out: 0
        }
    }
    
    fn write(data: [UInt8]) -> Result<[UInt8], ZstdError> {
        self.bytes_in += data.len() as Int64
        let output = @native("zstd_compressor_write", self.inner, data)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn flush() -> Result<[UInt8], ZstdError> {
        let output = @native("zstd_compressor_flush", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn finish() -> Result<[UInt8], ZstdError> {
        let output = @native("zstd_compressor_finish", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn reset() {
        self.inner = @native("zstd_compressor_new", self.level)
        self.bytes_in = 0
        self.bytes_out = 0
    }
    
    fn total_in() -> Int64 { self.bytes_in }
    fn total_out() -> Int64 { self.bytes_out }
    
    fn ratio() -> Float64 {
        if self.bytes_in == 0 { return 0.0 }
        1.0 - (self.bytes_out as Float64 / self.bytes_in as Float64)
    }
}

// =============================================================================
// Streaming Decompressor
// =============================================================================

/// Streaming zstd decompressor
struct ZstdDecompressor {
    inner: @native("ZstdDecompressor")
    bytes_in: Int64
    bytes_out: Int64
}

impl ZstdDecompressor {
    fn new() -> Self {
        ZstdDecompressor {
            inner: @native("zstd_decompressor_new"),
            bytes_in: 0,
            bytes_out: 0
        }
    }
    
    fn write(data: [UInt8]) -> Result<[UInt8], ZstdError> {
        self.bytes_in += data.len() as Int64
        let output = @native("zstd_decompressor_write", self.inner, data)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn finish() -> Result<[UInt8], ZstdError> {
        let output = @native("zstd_decompressor_finish", self.inner)?
        self.bytes_out += output.len() as Int64
        Ok(output)
    }
    
    fn reset() {
        self.inner = @native("zstd_decompressor_new")
        self.bytes_in = 0
        self.bytes_out = 0
    }
    
    fn total_in() -> Int64 { self.bytes_in }
    fn total_out() -> Int64 { self.bytes_out }
}

// =============================================================================
// Dictionary Support
// =============================================================================

/// Zstd compression dictionary
struct ZstdDict {
    data: [UInt8]
    id: UInt32
}

impl ZstdDict {
    fn new(data: [UInt8]) -> Self {
        let id = @native("zstd_dict_id", data)
        ZstdDict { data: data, id: id }
    }
    
    fn from_samples(samples: [[UInt8]], dict_size: Int) -> Result<Self, ZstdError> {
        let data = @native("zstd_train_dict", samples, dict_size)?
        Ok(Self.new(data))
    }
    
    fn from_file(path: String) -> Result<Self, ZstdError> {
        let data = fs.read(path).map_err(|e| ZstdError.IoError(e.to_string()))?
        Ok(Self.new(data))
    }
    
    fn id() -> UInt32 { self.id }
    fn data() -> [UInt8] { self.data.clone() }
    fn len() -> Int { self.data.len() }
}

/// Compress with dictionary
fn compress_with_dict(data: [UInt8], dict: ZstdDict) -> Result<[UInt8], ZstdError> {
    compress_with_dict_level(data, dict, ZstdLevel.Default)
}

fn compress_with_dict_level(data: [UInt8], dict: ZstdDict, level: ZstdLevel) -> Result<[UInt8], ZstdError> {
    @native("zstd_compress_dict", data, dict.data, level.value())
}

/// Decompress with dictionary
fn decompress_with_dict(data: [UInt8], dict: ZstdDict) -> Result<[UInt8], ZstdError> {
    @native("zstd_decompress_dict", data, dict.data)
}

// =============================================================================
// Compiled Dictionary
// =============================================================================

/// Pre-compiled dictionary for faster compression
struct CompiledDict {
    inner: @native("ZstdCDict")
    level: Int
}

impl CompiledDict {
    fn new(dict: ZstdDict, level: ZstdLevel) -> Self {
        CompiledDict {
            inner: @native("zstd_cdict_new", dict.data, level.value()),
            level: level.value()
        }
    }
    
    fn compress(data: [UInt8]) -> Result<[UInt8], ZstdError> {
        @native("zstd_compress_cdict", data, self.inner)
    }
}

/// Pre-compiled dictionary for faster decompression
struct DecompiledDict {
    inner: @native("ZstdDDict")
}

impl DecompiledDict {
    fn new(dict: ZstdDict) -> Self {
        DecompiledDict { inner: @native("zstd_ddict_new", dict.data) }
    }
    
    fn decompress(data: [UInt8]) -> Result<[UInt8], ZstdError> {
        @native("zstd_decompress_ddict", data, self.inner)
    }
}

// =============================================================================
// Async Streaming
// =============================================================================

actor AsyncZstdCompressor {
    state compressor: ZstdCompressor
    state buffer: [UInt8]
    
    fn new() -> Self { AsyncZstdCompressor { compressor: ZstdCompressor.new(), buffer: [] } }
    fn with_level(level: ZstdLevel) -> Self { AsyncZstdCompressor { compressor: ZstdCompressor.with_level(level), buffer: [] } }
    
    async fn write(data: [UInt8]) -> Result<(), ZstdError> {
        let output = self.compressor.write(data)?
        self.buffer.extend(output)
        Ok(())
    }
    
    async fn finish() -> Result<[UInt8], ZstdError> {
        let final_data = self.compressor.finish()?
        self.buffer.extend(final_data)
        let result = self.buffer.clone()
        self.buffer.clear()
        Ok(result)
    }
    
    fn stats() -> (Int64, Int64, Float64) {
        (self.compressor.total_in(), self.compressor.total_out(), self.compressor.ratio())
    }
}

actor AsyncZstdDecompressor {
    state decompressor: ZstdDecompressor
    state buffer: [UInt8]
    
    fn new() -> Self { AsyncZstdDecompressor { decompressor: ZstdDecompressor.new(), buffer: [] } }
    
    async fn write(data: [UInt8]) -> Result<(), ZstdError> {
        let output = self.decompressor.write(data)?
        self.buffer.extend(output)
        Ok(())
    }
    
    async fn finish() -> Result<[UInt8], ZstdError> {
        let final_data = self.decompressor.finish()?
        self.buffer.extend(final_data)
        let result = self.buffer.clone()
        self.buffer.clear()
        Ok(result)
    }
}

// =============================================================================
// Multi-threaded Compression
// =============================================================================

/// Parallel compressor using multiple threads
struct ParallelCompressor {
    inner: @native("ZstdParallelCompressor")
    workers: Int
    level: Int
}

impl ParallelCompressor {
    fn new(workers: Int) -> Self { Self.with_level(workers, ZstdLevel.Default) }
    
    fn with_level(workers: Int, level: ZstdLevel) -> Self {
        ParallelCompressor {
            inner: @native("zstd_parallel_new", workers, level.value()),
            workers: workers,
            level: level.value()
        }
    }
    
    fn compress(data: [UInt8]) -> Result<[UInt8], ZstdError> {
        @native("zstd_parallel_compress", self.inner, data)
    }
}

// =============================================================================
// Utilities
// =============================================================================

/// Calculate maximum compressed size
fn compress_bound(src_size: Int) -> Int {
    src_size + (src_size >> 8) + (if src_size < 128 * 1024 { (128 * 1024 - src_size) >> 11 } else { 0 }) + 32
}

/// Get minimum compression level
fn min_level() -> Int { ZSTD_MIN_CLEVEL }

/// Get maximum compression level
fn max_level() -> Int { ZSTD_MAX_CLEVEL }

/// Get default compression level
fn default_level() -> Int { ZSTD_DEFAULT_CLEVEL }

/// Get zstd version
fn version() -> UInt32 { @native("zstd_version") }

fn version_string() -> String { @native("zstd_version_string") }

// =============================================================================
// Errors
// =============================================================================

enum ZstdError {
    InvalidData
    InvalidMagic
    BufferTooSmall
    DictMismatch
    ChecksumMismatch
    FrameParameterUnsupported
    IoError(String)
    Other(String)
}

impl Display for ZstdError {
    fn fmt(f: Formatter) {
        match self {
            InvalidData => f.write("Invalid zstd data")
            InvalidMagic => f.write("Invalid zstd magic number")
            BufferTooSmall => f.write("Output buffer too small")
            DictMismatch => f.write("Dictionary mismatch")
            ChecksumMismatch => f.write("Checksum mismatch")
            FrameParameterUnsupported => f.write("Frame parameter unsupported")
            IoError(s) => f.write(format!("I/O error: {}", s))
            Other(s) => f.write(s)
        }
    }
}

impl Error for ZstdError {}

// =============================================================================
// Tests
// =============================================================================

test "compress decompress" {
    let original = "Hello, World! Zstd compression test.".as_bytes()
    let compressed = compress(original)?
    let decompressed = decompress(compressed)?
    assert_eq(decompressed, original)?
}

test "compression levels" {
    let data = "aaaaaaaaaa".repeat(1000).as_bytes()
    
    let fast = compress_level(data, ZstdLevel.Fast)?
    let default = compress_level(data, ZstdLevel.Default)?
    let best = compress_level(data, ZstdLevel.Best)?
    
    assert_eq(decompress(fast)?, data)?
    assert_eq(decompress(default)?, data)?
    assert_eq(decompress(best)?, data)?
    
    assert(best.len() <= fast.len())?
}

test "streaming" {
    var compressor = ZstdCompressor.new()
    compressor.write("Hello, ".as_bytes())?
    compressor.write("World!".as_bytes())?
    let compressed = compressor.finish()?
    assert_eq(decompress(compressed)?, "Hello, World!".as_bytes())?
}

test "is_zstd" {
    let compressed = compress("test".as_bytes())?
    assert(is_zstd(compressed))?
    assert(!is_zstd("not zstd".as_bytes()))?
}

test "content size" {
    let data = "test data".as_bytes()
    let compressed = compress(data)?
    let size = get_content_size(compressed)
    assert_eq(size, Some(data.len() as UInt64))?
}

test "empty data" {
    let compressed = compress([])?
    let decompressed = decompress(compressed)?
    assert_eq(decompressed, [])?
}

test "dictionary" {
    let samples = [
        "Hello World".as_bytes(),
        "Hello Vibee".as_bytes(),
        "Hello Zstd".as_bytes()
    ]
    let dict = ZstdDict.from_samples(samples, 1024)?
    
    let data = "Hello Test".as_bytes()
    let compressed = compress_with_dict(data, dict)?
    let decompressed = decompress_with_dict(compressed, dict)?
    assert_eq(decompressed, data)?
}
