// =============================================================================
// Vibee OS â€” Native Module
// Native system calls and low-level platform operations
// =============================================================================

// =============================================================================
// Platform Detection
// =============================================================================

/// Current platform
enum Platform { Linux, MacOS, Windows, FreeBSD, Android, iOS, WASM, Unknown }

/// Current architecture
enum Architecture { X86, X86_64, ARM, ARM64, RISCV64, WASM32, Unknown }

/// Get current platform
fn platform() -> Platform {
    match @native("platform") {
        "linux" => Platform.Linux
        "macos" | "darwin" => Platform.MacOS
        "windows" => Platform.Windows
        "freebsd" => Platform.FreeBSD
        "android" => Platform.Android
        "ios" => Platform.iOS
        "wasm" => Platform.WASM
        _ => Platform.Unknown
    }
}

/// Get current architecture
fn arch() -> Architecture {
    match @native("arch") {
        "x86" | "i386" | "i686" => Architecture.X86
        "x86_64" | "amd64" => Architecture.X86_64
        "arm" | "armv7" => Architecture.ARM
        "aarch64" | "arm64" => Architecture.ARM64
        "riscv64" => Architecture.RISCV64
        "wasm32" => Architecture.WASM32
        _ => Architecture.Unknown
    }
}

/// Get pointer size in bytes
fn pointer_size() -> Int { @native("pointer_size") }

/// Get page size
fn page_size() -> Int { @native("page_size") }

/// Check if big endian
fn is_big_endian() -> Bool { @native("is_big_endian") }

// =============================================================================
// System Calls
// =============================================================================

/// Raw system call with up to 6 arguments
fn syscall0(num: Int) -> Int { @native("syscall0", num) }
fn syscall1(num: Int, a1: Int) -> Int { @native("syscall1", num, a1) }
fn syscall2(num: Int, a1: Int, a2: Int) -> Int { @native("syscall2", num, a1, a2) }
fn syscall3(num: Int, a1: Int, a2: Int, a3: Int) -> Int { @native("syscall3", num, a1, a2, a3) }
fn syscall4(num: Int, a1: Int, a2: Int, a3: Int, a4: Int) -> Int { @native("syscall4", num, a1, a2, a3, a4) }
fn syscall5(num: Int, a1: Int, a2: Int, a3: Int, a4: Int, a5: Int) -> Int { @native("syscall5", num, a1, a2, a3, a4, a5) }
fn syscall6(num: Int, a1: Int, a2: Int, a3: Int, a4: Int, a5: Int, a6: Int) -> Int { @native("syscall6", num, a1, a2, a3, a4, a5, a6) }

/// Linux syscall numbers
mod linux_syscall {
    const READ: Int = 0
    const WRITE: Int = 1
    const OPEN: Int = 2
    const CLOSE: Int = 3
    const STAT: Int = 4
    const FSTAT: Int = 5
    const LSTAT: Int = 6
    const POLL: Int = 7
    const LSEEK: Int = 8
    const MMAP: Int = 9
    const MPROTECT: Int = 10
    const MUNMAP: Int = 11
    const BRK: Int = 12
    const IOCTL: Int = 16
    const PIPE: Int = 22
    const SELECT: Int = 23
    const SCHED_YIELD: Int = 24
    const MREMAP: Int = 25
    const DUP: Int = 32
    const DUP2: Int = 33
    const NANOSLEEP: Int = 35
    const GETPID: Int = 39
    const SOCKET: Int = 41
    const CONNECT: Int = 42
    const ACCEPT: Int = 43
    const SENDTO: Int = 44
    const RECVFROM: Int = 45
    const BIND: Int = 49
    const LISTEN: Int = 50
    const FORK: Int = 57
    const EXECVE: Int = 59
    const EXIT: Int = 60
    const WAIT4: Int = 61
    const KILL: Int = 62
    const FCNTL: Int = 72
    const FLOCK: Int = 73
    const FSYNC: Int = 74
    const TRUNCATE: Int = 76
    const GETDENTS: Int = 78
    const GETCWD: Int = 79
    const CHDIR: Int = 80
    const RENAME: Int = 82
    const MKDIR: Int = 83
    const RMDIR: Int = 84
    const CREAT: Int = 85
    const LINK: Int = 86
    const UNLINK: Int = 87
    const SYMLINK: Int = 88
    const READLINK: Int = 89
    const CHMOD: Int = 90
    const CHOWN: Int = 92
    const GETUID: Int = 102
    const GETGID: Int = 104
    const GETEUID: Int = 107
    const GETEGID: Int = 108
    const GETPPID: Int = 110
    const GETPGRP: Int = 111
    const SETSID: Int = 112
    const SIGACTION: Int = 13
    const SIGPROCMASK: Int = 14
    const CLONE: Int = 56
    const FUTEX: Int = 202
    const EPOLL_CREATE: Int = 213
    const EPOLL_CTL: Int = 233
    const EPOLL_WAIT: Int = 232
    const EVENTFD: Int = 284
    const TIMERFD_CREATE: Int = 283
    const SIGNALFD: Int = 282
    const INOTIFY_INIT: Int = 253
    const INOTIFY_ADD_WATCH: Int = 254
    const INOTIFY_RM_WATCH: Int = 255
}

// =============================================================================
// Memory Operations
// =============================================================================

/// Memory protection flags
enum MemProtect { None = 0, Read = 1, Write = 2, Exec = 4, ReadWrite = 3, ReadExec = 5, All = 7 }

/// Memory mapping flags
enum MemMap { Shared = 1, Private = 2, Fixed = 16, Anonymous = 32 }

/// Map memory
fn mmap(addr: *(), len: Int, prot: MemProtect, flags: Int, fd: Int, offset: Int64) -> Result<*(), NativeError> {
    let result = @native("mmap", addr, len, prot as Int, flags, fd, offset)
    if result == -1 as *() { Err(NativeError.from_errno()) } else { Ok(result) }
}

/// Unmap memory
fn munmap(addr: *(), len: Int) -> Result<(), NativeError> {
    if @native("munmap", addr, len) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Change memory protection
fn mprotect(addr: *(), len: Int, prot: MemProtect) -> Result<(), NativeError> {
    if @native("mprotect", addr, len, prot as Int) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Lock memory
fn mlock(addr: *(), len: Int) -> Result<(), NativeError> {
    if @native("mlock", addr, len) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Unlock memory
fn munlock(addr: *(), len: Int) -> Result<(), NativeError> {
    if @native("munlock", addr, len) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Sync memory to disk
fn msync(addr: *(), len: Int, flags: Int) -> Result<(), NativeError> {
    if @native("msync", addr, len, flags) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

// =============================================================================
// Raw Pointer Operations
// =============================================================================

/// Read value from pointer
fn ptr_read<T>(ptr: *T) -> T { @native("ptr_read", ptr) }

/// Write value to pointer
fn ptr_write<T>(ptr: *mut T, value: T) { @native("ptr_write", ptr, value) }

/// Read volatile
fn ptr_read_volatile<T>(ptr: *T) -> T { @native("ptr_read_volatile", ptr) }

/// Write volatile
fn ptr_write_volatile<T>(ptr: *mut T, value: T) { @native("ptr_write_volatile", ptr, value) }

/// Copy memory
fn ptr_copy<T>(src: *T, dst: *mut T, count: Int) { @native("ptr_copy", src, dst, count) }

/// Copy overlapping memory
fn ptr_copy_overlapping<T>(src: *T, dst: *mut T, count: Int) { @native("ptr_copy_overlapping", src, dst, count) }

/// Set memory to bytes
fn ptr_write_bytes(dst: *mut UInt8, value: UInt8, count: Int) { @native("ptr_write_bytes", dst, value, count) }

/// Offset pointer
fn ptr_offset<T>(ptr: *T, offset: Int) -> *T { @native("ptr_offset", ptr, offset) }

/// Get pointer address as integer
fn ptr_addr<T>(ptr: *T) -> Int { @native("ptr_addr", ptr) }

/// Create pointer from address
fn ptr_from_addr<T>(addr: Int) -> *T { @native("ptr_from_addr", addr) }

/// Check if pointer is null
fn ptr_is_null<T>(ptr: *T) -> Bool { @native("ptr_is_null", ptr) }

/// Check if pointer is aligned
fn ptr_is_aligned<T>(ptr: *T, align: Int) -> Bool { ptr_addr(ptr) % align == 0 }

// =============================================================================
// Atomic Operations
// =============================================================================

/// Memory ordering
enum Ordering { Relaxed, Acquire, Release, AcqRel, SeqCst }

/// Atomic load
fn atomic_load<T>(ptr: *T, order: Ordering) -> T { @native("atomic_load", ptr, order) }

/// Atomic store
fn atomic_store<T>(ptr: *mut T, value: T, order: Ordering) { @native("atomic_store", ptr, value, order) }

/// Atomic exchange
fn atomic_swap<T>(ptr: *mut T, value: T, order: Ordering) -> T { @native("atomic_swap", ptr, value, order) }

/// Atomic compare and exchange
fn atomic_compare_exchange<T>(ptr: *mut T, expected: T, desired: T, success: Ordering, failure: Ordering) -> (Bool, T) {
    @native("atomic_compare_exchange", ptr, expected, desired, success, failure)
}

/// Atomic fetch and add
fn atomic_fetch_add<T>(ptr: *mut T, value: T, order: Ordering) -> T { @native("atomic_fetch_add", ptr, value, order) }

/// Atomic fetch and sub
fn atomic_fetch_sub<T>(ptr: *mut T, value: T, order: Ordering) -> T { @native("atomic_fetch_sub", ptr, value, order) }

/// Atomic fetch and and
fn atomic_fetch_and<T>(ptr: *mut T, value: T, order: Ordering) -> T { @native("atomic_fetch_and", ptr, value, order) }

/// Atomic fetch and or
fn atomic_fetch_or<T>(ptr: *mut T, value: T, order: Ordering) -> T { @native("atomic_fetch_or", ptr, value, order) }

/// Atomic fetch and xor
fn atomic_fetch_xor<T>(ptr: *mut T, value: T, order: Ordering) -> T { @native("atomic_fetch_xor", ptr, value, order) }

/// Memory fence
fn atomic_fence(order: Ordering) { @native("atomic_fence", order) }

/// Compiler fence
fn compiler_fence(order: Ordering) { @native("compiler_fence", order) }

// =============================================================================
// Intrinsics
// =============================================================================

/// Count leading zeros
fn clz(value: Int64) -> Int { @native("clz", value) }

/// Count trailing zeros
fn ctz(value: Int64) -> Int { @native("ctz", value) }

/// Population count (count ones)
fn popcnt(value: Int64) -> Int { @native("popcnt", value) }

/// Byte swap
fn bswap16(value: UInt16) -> UInt16 { @native("bswap16", value) }
fn bswap32(value: UInt32) -> UInt32 { @native("bswap32", value) }
fn bswap64(value: UInt64) -> UInt64 { @native("bswap64", value) }

/// Rotate left
fn rotl32(value: UInt32, shift: Int) -> UInt32 { @native("rotl32", value, shift) }
fn rotl64(value: UInt64, shift: Int) -> UInt64 { @native("rotl64", value, shift) }

/// Rotate right
fn rotr32(value: UInt32, shift: Int) -> UInt32 { @native("rotr32", value, shift) }
fn rotr64(value: UInt64, shift: Int) -> UInt64 { @native("rotr64", value, shift) }

/// Prefetch memory
fn prefetch_read<T>(ptr: *T) { @native("prefetch_read", ptr) }
fn prefetch_write<T>(ptr: *T) { @native("prefetch_write", ptr) }

/// CPU pause (for spin loops)
fn cpu_pause() { @native("cpu_pause") }

/// Read timestamp counter
fn rdtsc() -> UInt64 { @native("rdtsc") }

/// Get CPU ID
fn cpuid(leaf: UInt32, subleaf: UInt32) -> (UInt32, UInt32, UInt32, UInt32) {
    @native("cpuid", leaf, subleaf)
}

// =============================================================================
// Signal Handling
// =============================================================================

/// Signal numbers
enum Signal {
    HUP = 1, INT = 2, QUIT = 3, ILL = 4, TRAP = 5, ABRT = 6, BUS = 7, FPE = 8,
    KILL = 9, USR1 = 10, SEGV = 11, USR2 = 12, PIPE = 13, ALRM = 14, TERM = 15,
    STKFLT = 16, CHLD = 17, CONT = 18, STOP = 19, TSTP = 20, TTIN = 21, TTOU = 22,
    URG = 23, XCPU = 24, XFSZ = 25, VTALRM = 26, PROF = 27, WINCH = 28, IO = 29,
    PWR = 30, SYS = 31
}

/// Signal handler type
type SignalHandler = fn(Signal)

/// Set signal handler
fn signal(sig: Signal, handler: SignalHandler) -> Result<SignalHandler, NativeError> {
    let prev = @native("signal", sig as Int, handler)
    if prev == -1 as SignalHandler { Err(NativeError.from_errno()) } else { Ok(prev) }
}

/// Ignore signal
fn signal_ignore(sig: Signal) -> Result<(), NativeError> {
    if @native("signal_ignore", sig as Int) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Reset signal to default
fn signal_default(sig: Signal) -> Result<(), NativeError> {
    if @native("signal_default", sig as Int) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Send signal to process
fn kill(pid: Int, sig: Signal) -> Result<(), NativeError> {
    if @native("kill", pid, sig as Int) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Raise signal in current process
fn raise(sig: Signal) -> Result<(), NativeError> {
    if @native("raise", sig as Int) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

// =============================================================================
// Process Operations
// =============================================================================

/// Get process ID
fn getpid() -> Int { @native("getpid") }

/// Get parent process ID
fn getppid() -> Int { @native("getppid") }

/// Get user ID
fn getuid() -> Int { @native("getuid") }

/// Get effective user ID
fn geteuid() -> Int { @native("geteuid") }

/// Get group ID
fn getgid() -> Int { @native("getgid") }

/// Get effective group ID
fn getegid() -> Int { @native("getegid") }

/// Fork process
fn fork() -> Result<Int, NativeError> {
    let pid = @native("fork")
    if pid < 0 { Err(NativeError.from_errno()) } else { Ok(pid) }
}

/// Execute program
fn execve(path: String, args: [String], env: [String]) -> NativeError {
    @native("execve", path, args, env)
    NativeError.from_errno()
}

/// Exit process
fn exit(code: Int) -> ! { @native("exit", code) }

/// Abort process
fn abort() -> ! { @native("abort") }

// =============================================================================
// File Descriptor Operations
// =============================================================================

/// Open file
fn open(path: String, flags: Int, mode: Int) -> Result<Int, NativeError> {
    let fd = @native("open", path, flags, mode)
    if fd < 0 { Err(NativeError.from_errno()) } else { Ok(fd) }
}

/// Close file descriptor
fn close(fd: Int) -> Result<(), NativeError> {
    if @native("close", fd) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Read from file descriptor
fn read(fd: Int, buf: *mut UInt8, count: Int) -> Result<Int, NativeError> {
    let n = @native("read", fd, buf, count)
    if n < 0 { Err(NativeError.from_errno()) } else { Ok(n) }
}

/// Write to file descriptor
fn write(fd: Int, buf: *UInt8, count: Int) -> Result<Int, NativeError> {
    let n = @native("write", fd, buf, count)
    if n < 0 { Err(NativeError.from_errno()) } else { Ok(n) }
}

/// Seek in file
fn lseek(fd: Int, offset: Int64, whence: Int) -> Result<Int64, NativeError> {
    let pos = @native("lseek", fd, offset, whence)
    if pos < 0 { Err(NativeError.from_errno()) } else { Ok(pos) }
}

/// Duplicate file descriptor
fn dup(fd: Int) -> Result<Int, NativeError> {
    let new_fd = @native("dup", fd)
    if new_fd < 0 { Err(NativeError.from_errno()) } else { Ok(new_fd) }
}

/// Duplicate file descriptor to specific number
fn dup2(old_fd: Int, new_fd: Int) -> Result<Int, NativeError> {
    let fd = @native("dup2", old_fd, new_fd)
    if fd < 0 { Err(NativeError.from_errno()) } else { Ok(fd) }
}

/// Create pipe
fn pipe() -> Result<(Int, Int), NativeError> {
    let (read_fd, write_fd) = @native("pipe")
    if read_fd < 0 { Err(NativeError.from_errno()) } else { Ok((read_fd, write_fd)) }
}

/// File control
fn fcntl(fd: Int, cmd: Int, arg: Int) -> Result<Int, NativeError> {
    let result = @native("fcntl", fd, cmd, arg)
    if result < 0 { Err(NativeError.from_errno()) } else { Ok(result) }
}

/// IO control
fn ioctl(fd: Int, request: Int, arg: *()) -> Result<Int, NativeError> {
    let result = @native("ioctl", fd, request, arg)
    if result < 0 { Err(NativeError.from_errno()) } else { Ok(result) }
}

// =============================================================================
// Time Operations
// =============================================================================

/// Get current time in nanoseconds
fn clock_gettime_ns() -> Int64 { @native("clock_gettime_ns") }

/// Get monotonic time in nanoseconds
fn clock_monotonic_ns() -> Int64 { @native("clock_monotonic_ns") }

/// Sleep for nanoseconds
fn nanosleep(ns: Int64) -> Result<(), NativeError> {
    if @native("nanosleep", ns) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Get time of day
fn gettimeofday() -> (Int64, Int64) { @native("gettimeofday") }

// =============================================================================
// Environment
// =============================================================================

/// Get environment variable
fn getenv(name: String) -> Option<String> { @native("getenv", name) }

/// Set environment variable
fn setenv(name: String, value: String, overwrite: Bool) -> Result<(), NativeError> {
    if @native("setenv", name, value, overwrite) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Unset environment variable
fn unsetenv(name: String) -> Result<(), NativeError> {
    if @native("unsetenv", name) < 0 { Err(NativeError.from_errno()) } else { Ok(()) }
}

/// Get all environment variables
fn environ() -> [(String, String)] { @native("environ") }

// =============================================================================
// Error Types
// =============================================================================

enum NativeError {
    EPERM = 1, ENOENT = 2, ESRCH = 3, EINTR = 4, EIO = 5, ENXIO = 6, E2BIG = 7,
    ENOEXEC = 8, EBADF = 9, ECHILD = 10, EAGAIN = 11, ENOMEM = 12, EACCES = 13,
    EFAULT = 14, ENOTBLK = 15, EBUSY = 16, EEXIST = 17, EXDEV = 18, ENODEV = 19,
    ENOTDIR = 20, EISDIR = 21, EINVAL = 22, ENFILE = 23, EMFILE = 24, ENOTTY = 25,
    ETXTBSY = 26, EFBIG = 27, ENOSPC = 28, ESPIPE = 29, EROFS = 30, EMLINK = 31,
    EPIPE = 32, EDOM = 33, ERANGE = 34, EDEADLK = 35, ENAMETOOLONG = 36, ENOLCK = 37,
    ENOSYS = 38, ENOTEMPTY = 39, ELOOP = 40, EWOULDBLOCK = 11, ENOMSG = 42,
    Unknown(Int)
}

impl NativeError {
    fn from_errno() -> Self {
        let errno = @native("errno")
        match errno {
            1 => NativeError.EPERM
            2 => NativeError.ENOENT
            3 => NativeError.ESRCH
            4 => NativeError.EINTR
            5 => NativeError.EIO
            9 => NativeError.EBADF
            11 => NativeError.EAGAIN
            12 => NativeError.ENOMEM
            13 => NativeError.EACCES
            17 => NativeError.EEXIST
            22 => NativeError.EINVAL
            _ => NativeError.Unknown(errno)
        }
    }
    
    fn code() -> Int {
        match self {
            Unknown(c) => c
            _ => self as Int
        }
    }
    
    fn message() -> String { @native("strerror", self.code()) }
}

impl Display for NativeError {
    fn fmt(f: Formatter) { f.write(self.message()) }
}

// =============================================================================
// Tests
// =============================================================================

test "platform detection" {
    let p = platform()
    assert(matches!(p, Platform.Linux | Platform.MacOS | Platform.Windows | Platform.WASM))?
}

test "pointer operations" {
    var value: Int = 42
    let ptr = &value as *Int
    assert_eq(ptr_read(ptr), 42)?
    
    ptr_write(&mut value as *mut Int, 100)
    assert_eq(value, 100)?
}

test "atomic operations" {
    var value: Int = 0
    let ptr = &mut value as *mut Int
    
    atomic_store(ptr, 42, Ordering.SeqCst)
    assert_eq(atomic_load(ptr as *Int, Ordering.SeqCst), 42)?
    
    let old = atomic_fetch_add(ptr, 10, Ordering.SeqCst)
    assert_eq(old, 42)?
    assert_eq(atomic_load(ptr as *Int, Ordering.SeqCst), 52)?
}

test "intrinsics" {
    assert_eq(clz(0x0F00000000000000), 4)?
    assert_eq(ctz(0x0000000000000010), 4)?
    assert_eq(popcnt(0b10101010), 4)?
}

test "getpid" {
    let pid = getpid()
    assert(pid > 0)?
}
