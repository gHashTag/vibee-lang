// =============================================================================
// Vibee OS â€” JSON5 Module
// JSON5 parsing and generation (extended JSON format)
// =============================================================================

// -----------------------------------------------------------------------------
// JSON5 Value
// -----------------------------------------------------------------------------

enum Value {
    Null
    Bool(Bool)
    Number(Float)
    String(String)
    Array([Value])
    Object(Map<String, Value>)
    
    fn parse(json5: String) -> Result<Value, JSON5Error> { Parser.new(json5).parse() }
    
    fn parse_file(path: String) -> Result<Value, JSON5Error> {
        let content = File.read_string(path)?
        Self.parse(content)
    }
    
    fn is_null() -> Bool { match self { .Null => true, _ => false } }
    fn is_bool() -> Bool { match self { .Bool(_) => true, _ => false } }
    fn is_number() -> Bool { match self { .Number(_) => true, _ => false } }
    fn is_string() -> Bool { match self { .String(_) => true, _ => false } }
    fn is_array() -> Bool { match self { .Array(_) => true, _ => false } }
    fn is_object() -> Bool { match self { .Object(_) => true, _ => false } }
    
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    fn as_number() -> Option<Float> { match self { .Number(n) => Some(n), _ => None } }
    fn as_int() -> Option<Int> { match self { .Number(n) => Some(n as Int), _ => None } }
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_array() -> Option<[Value]> { match self { .Array(a) => Some(a), _ => None } }
    fn as_object() -> Option<Map<String, Value>> { match self { .Object(o) => Some(o), _ => None } }
    
    fn get(key: String) -> Option<Value> { match self { .Object(o) => o.get(key), _ => None } }
    fn at(idx: Int) -> Option<Value> { match self { .Array(a) if idx >= 0 && idx < a.len() => Some(a[idx]), _ => None } }
    
    fn path(p: String) -> Option<Value> {
        let parts = p.split(".")
        var current = self
        for part in parts {
            if let Ok(idx) = Int.parse(part) { current = current.at(idx)? }
            else { current = current.get(part)? }
        }
        Some(current)
    }
    
    fn to_json5() -> String { Emitter.new().emit(self) }
    fn to_json5_pretty() -> String { Emitter.pretty().emit(self) }
    fn to_json() -> String { Emitter.json().emit(self) }
}

impl Index<String> for Value {
    type Output = Option<Value>
    fn index(key: String) -> Option<Value> { self.get(key) }
}

// -----------------------------------------------------------------------------
// Parser
// -----------------------------------------------------------------------------

actor Parser {
    state input: String
    state pos: Int
    state line: Int
    state col: Int
    
    fn new(input: String) -> Self {
        Parser { input: input, pos: 0, line: 1, col: 1 }
    }
    
    fn parse() -> Result<Value, JSON5Error> {
        self.skip_whitespace_and_comments()
        let value = self.parse_value()?
        self.skip_whitespace_and_comments()
        Ok(value)
    }
    
    fn parse_value() -> Result<Value, JSON5Error> {
        self.skip_whitespace_and_comments()
        
        match self.peek_char() {
            Some('{') => self.parse_object()
            Some('[') => self.parse_array()
            Some('"') => Ok(Value.String(self.parse_double_string()?))
            Some('\'') => Ok(Value.String(self.parse_single_string()?))
            Some('t') if self.peek_str("true") => { self.advance(4); Ok(Value.Bool(true)) }
            Some('f') if self.peek_str("false") => { self.advance(5); Ok(Value.Bool(false)) }
            Some('n') if self.peek_str("null") => { self.advance(4); Ok(Value.Null) }
            Some('I') if self.peek_str("Infinity") => { self.advance(8); Ok(Value.Number(Float.INFINITY)) }
            Some('N') if self.peek_str("NaN") => { self.advance(3); Ok(Value.Number(Float.NAN)) }
            Some('+') if self.peek_str("+Infinity") => { self.advance(9); Ok(Value.Number(Float.INFINITY)) }
            Some('-') if self.peek_str("-Infinity") => { self.advance(9); Ok(Value.Number(Float.NEG_INFINITY)) }
            Some(c) if c.is_digit() || c == '-' || c == '+' || c == '.' => self.parse_number()
            Some(c) => Err(JSON5Error.UnexpectedChar(c, self.line, self.col))
            None => Err(JSON5Error.UnexpectedEOF)
        }
    }
    
    fn parse_object() -> Result<Value, JSON5Error> {
        self.expect('{')?
        var map = Map.empty()
        
        self.skip_whitespace_and_comments()
        if self.peek_char() == Some('}') {
            self.advance(1)
            return Ok(Value.Object(map))
        }
        
        loop {
            self.skip_whitespace_and_comments()
            
            let key = match self.peek_char() {
                Some('"') => self.parse_double_string()?
                Some('\'') => self.parse_single_string()?
                Some(c) if c.is_alphabetic() || c == '_' || c == '$' => self.parse_identifier()?
                _ => return Err(JSON5Error.ExpectedKey(self.line, self.col))
            }
            
            self.skip_whitespace_and_comments()
            self.expect(':')?
            
            self.skip_whitespace_and_comments()
            let value = self.parse_value()?
            map.set(key, value)
            
            self.skip_whitespace_and_comments()
            match self.peek_char() {
                Some(',') => { self.advance(1); self.skip_whitespace_and_comments(); if self.peek_char() == Some('}') { self.advance(1); break } }
                Some('}') => { self.advance(1); break }
                _ => return Err(JSON5Error.Expected(',', self.line, self.col))
            }
        }
        
        Ok(Value.Object(map))
    }
    
    fn parse_array() -> Result<Value, JSON5Error> {
        self.expect('[')?
        var items = []
        
        self.skip_whitespace_and_comments()
        if self.peek_char() == Some(']') {
            self.advance(1)
            return Ok(Value.Array(items))
        }
        
        loop {
            self.skip_whitespace_and_comments()
            items.append(self.parse_value()?)
            
            self.skip_whitespace_and_comments()
            match self.peek_char() {
                Some(',') => { self.advance(1); self.skip_whitespace_and_comments(); if self.peek_char() == Some(']') { self.advance(1); break } }
                Some(']') => { self.advance(1); break }
                _ => return Err(JSON5Error.Expected(',', self.line, self.col))
            }
        }
        
        Ok(Value.Array(items))
    }
    
    fn parse_double_string() -> Result<String, JSON5Error> {
        self.expect('"')?
        self.parse_string_content('"')
    }
    
    fn parse_single_string() -> Result<String, JSON5Error> {
        self.expect('\'')?
        self.parse_string_content('\'')
    }
    
    fn parse_string_content(quote: Char) -> Result<String, JSON5Error> {
        var result = StringBuilder.new()
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            self.pos += 1
            self.col += 1
            
            if c == quote { return Ok(result.build()) }
            if c == '\\' {
                if self.pos >= self.input.len() { return Err(JSON5Error.UnexpectedEOF) }
                let escaped = self.input[self.pos]
                self.pos += 1
                self.col += 1
                
                match escaped {
                    '"' => result.append('"')
                    '\'' => result.append('\'')
                    '\\' => result.append('\\')
                    '/' => result.append('/')
                    'b' => result.append('\x08')
                    'f' => result.append('\x0C')
                    'n' => result.append('\n')
                    'r' => result.append('\r')
                    't' => result.append('\t')
                    'v' => result.append('\x0B')
                    '0' => result.append('\0')
                    '\n' => { self.line += 1; self.col = 1 }
                    '\r' => { if self.peek_char() == Some('\n') { self.pos += 1 }; self.line += 1; self.col = 1 }
                    'x' => {
                        if self.pos + 2 > self.input.len() { return Err(JSON5Error.InvalidEscape(self.line)) }
                        let hex = self.input[self.pos..self.pos + 2]
                        self.pos += 2
                        self.col += 2
                        let code = Int.parse_hex(hex)?
                        result.append(Char.from_code(code))
                    }
                    'u' => {
                        if self.pos + 4 > self.input.len() { return Err(JSON5Error.InvalidEscape(self.line)) }
                        let hex = self.input[self.pos..self.pos + 4]
                        self.pos += 4
                        self.col += 4
                        let code = Int.parse_hex(hex)?
                        result.append(Char.from_code(code))
                    }
                    _ => result.append(escaped)
                }
            } else if c == '\n' || c == '\r' {
                return Err(JSON5Error.UnterminatedString(self.line))
            } else {
                result.append(c)
            }
        }
        
        Err(JSON5Error.UnterminatedString(self.line))
    }
    
    fn parse_identifier() -> Result<String, JSON5Error> {
        let start = self.pos
        
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c.is_alphanumeric() || c == '_' || c == '$' {
                self.pos += 1
                self.col += 1
            } else {
                break
            }
        }
        
        if self.pos == start { return Err(JSON5Error.ExpectedKey(self.line, self.col)) }
        Ok(self.input[start..self.pos])
    }
    
    fn parse_number() -> Result<Value, JSON5Error> {
        let start = self.pos
        
        if self.peek_char() == Some('+') || self.peek_char() == Some('-') { self.advance(1) }
        
        if self.peek_str("0x") || self.peek_str("0X") {
            self.advance(2)
            while self.peek_char()?.is_hex_digit() { self.advance(1) }
            let s = self.input[start..self.pos]
            return Ok(Value.Number(Int.parse_hex(s.replace("0x", "").replace("0X", ""))? as Float))
        }
        
        if self.peek_char() == Some('.') {
            self.advance(1)
        } else if self.peek_char() == Some('0') {
            self.advance(1)
        } else if self.peek_char()?.is_digit() {
            while self.peek_char()?.is_digit() { self.advance(1) }
        }
        
        if self.peek_char() == Some('.') {
            self.advance(1)
            while self.peek_char()?.is_digit() { self.advance(1) }
        }
        
        if self.peek_char() == Some('e') || self.peek_char() == Some('E') {
            self.advance(1)
            if self.peek_char() == Some('+') || self.peek_char() == Some('-') { self.advance(1) }
            while self.peek_char()?.is_digit() { self.advance(1) }
        }
        
        let s = self.input[start..self.pos]
        Ok(Value.Number(Float.parse(s)?))
    }
    
    fn skip_whitespace_and_comments() {
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            
            if c == ' ' || c == '\t' || c == '\r' || c == '\x0B' || c == '\x0C' || c == '\u00A0' {
                self.pos += 1
                self.col += 1
            } else if c == '\n' {
                self.pos += 1
                self.line += 1
                self.col = 1
            } else if self.peek_str("//") {
                self.skip_line_comment()
            } else if self.peek_str("/*") {
                self.skip_block_comment()
            } else {
                break
            }
        }
    }
    
    fn skip_line_comment() {
        self.pos += 2
        self.col += 2
        while self.pos < self.input.len() && self.input[self.pos] != '\n' {
            self.pos += 1
            self.col += 1
        }
    }
    
    fn skip_block_comment() {
        self.pos += 2
        self.col += 2
        while self.pos < self.input.len() - 1 {
            if self.input[self.pos] == '\n' {
                self.line += 1
                self.col = 1
            } else {
                self.col += 1
            }
            if self.peek_str("*/") {
                self.pos += 2
                self.col += 2
                return
            }
            self.pos += 1
        }
    }
    
    fn peek_char() -> Option<Char> { if self.pos < self.input.len() { Some(self.input[self.pos]) } else { None } }
    fn peek_str(s: String) -> Bool { self.input[self.pos..].starts_with(s) }
    fn advance(n: Int) { self.pos += n; self.col += n }
    fn expect(c: Char) -> Result<(), JSON5Error> {
        if self.peek_char() == Some(c) { self.advance(1); Ok(()) }
        else { Err(JSON5Error.Expected(c, self.line, self.col)) }
    }
}

// -----------------------------------------------------------------------------
// Emitter
// -----------------------------------------------------------------------------

struct EmitOptions {
    indent: String
    trailing_comma: Bool
    quote_style: QuoteStyle
    unquoted_keys: Bool
    
    fn default() -> Self {
        EmitOptions { indent: "", trailing_comma: false, quote_style: QuoteStyle.Double, unquoted_keys: false }
    }
    
    fn pretty() -> Self {
        EmitOptions { indent: "  ", trailing_comma: true, quote_style: QuoteStyle.Single, unquoted_keys: true }
    }
    
    fn json() -> Self {
        EmitOptions { indent: "  ", trailing_comma: false, quote_style: QuoteStyle.Double, unquoted_keys: false }
    }
}

enum QuoteStyle { Single, Double }

actor Emitter {
    state options: EmitOptions
    state depth: Int
    
    fn new() -> Self { Emitter { options: EmitOptions.default(), depth: 0 } }
    fn pretty() -> Self { Emitter { options: EmitOptions.pretty(), depth: 0 } }
    fn json() -> Self { Emitter { options: EmitOptions.json(), depth: 0 } }
    fn with_options(options: EmitOptions) -> Self { Emitter { options: options, depth: 0 } }
    
    fn emit(value: Value) -> String {
        match value {
            .Null => "null"
            .Bool(b) => if b { "true" } else { "false" }
            .Number(n) => self.emit_number(n)
            .String(s) => self.emit_string(s)
            .Array(a) => self.emit_array(a)
            .Object(o) => self.emit_object(o)
        }
    }
    
    fn emit_number(n: Float) -> String {
        if n.is_nan() { "NaN" }
        else if n.is_infinite() { if n > 0 { "Infinity" } else { "-Infinity" } }
        else if n == n.floor() && n.abs() < 1e15 { "\(n as Int)" }
        else { "\(n)" }
    }
    
    fn emit_string(s: String) -> String {
        let quote = match self.options.quote_style {
            .Single => '\''
            .Double => '"'
        }
        
        var result = "\(quote)"
        for c in s {
            match c {
                '\'' if quote == '\'' => result += "\\'"
                '"' if quote == '"' => result += "\\\""
                '\\' => result += "\\\\"
                '\n' => result += "\\n"
                '\r' => result += "\\r"
                '\t' => result += "\\t"
                _ if c.code() < 32 => result += "\\x\(c.code().to_hex_padded(2))"
                _ => result += c
            }
        }
        result + "\(quote)"
    }
    
    fn emit_key(key: String) -> String {
        if self.options.unquoted_keys && self.is_valid_identifier(key) {
            key
        } else {
            self.emit_string(key)
        }
    }
    
    fn is_valid_identifier(s: String) -> Bool {
        if s.is_empty() { return false }
        let first = s[0]
        if !first.is_alphabetic() && first != '_' && first != '$' { return false }
        for c in s[1..] {
            if !c.is_alphanumeric() && c != '_' && c != '$' { return false }
        }
        true
    }
    
    fn emit_array(items: [Value]) -> String {
        if items.is_empty() { return "[]" }
        
        if self.options.indent.is_empty() {
            return "[" + items.map(|v| self.emit(v)).join(", ") + "]"
        }
        
        self.depth += 1
        var result = "[\n"
        for (i, item) in items.enumerate() {
            result += self.indent() + self.emit(item)
            if i < items.len() - 1 { result += "," }
            else if self.options.trailing_comma { result += "," }
            result += "\n"
        }
        self.depth -= 1
        result += self.indent() + "]"
        result
    }
    
    fn emit_object(map: Map<String, Value>) -> String {
        if map.is_empty() { return "{}" }
        
        if self.options.indent.is_empty() {
            return "{" + map.map(|(k, v)| self.emit_key(k) + ": " + self.emit(v)).join(", ") + "}"
        }
        
        self.depth += 1
        var result = "{\n"
        let entries = map.entries()
        for (i, (key, value)) in entries.enumerate() {
            result += self.indent() + self.emit_key(key) + ": " + self.emit(value)
            if i < entries.len() - 1 { result += "," }
            else if self.options.trailing_comma { result += "," }
            result += "\n"
        }
        self.depth -= 1
        result += self.indent() + "}"
        result
    }
    
    fn indent() -> String { self.options.indent.repeat(self.depth) }
}

// -----------------------------------------------------------------------------
// Builder
// -----------------------------------------------------------------------------

struct ObjectBuilder {
    map: Map<String, Value>
    
    fn new() -> Self { ObjectBuilder { map: Map.empty() } }
    fn set(key: String, value: Value) -> Self { self.map.set(key, value); self }
    fn string(key: String, value: String) -> Self { self.set(key, Value.String(value)) }
    fn number(key: String, value: Float) -> Self { self.set(key, Value.Number(value)) }
    fn int(key: String, value: Int) -> Self { self.set(key, Value.Number(value as Float)) }
    fn bool(key: String, value: Bool) -> Self { self.set(key, Value.Bool(value)) }
    fn null(key: String) -> Self { self.set(key, Value.Null) }
    fn array(key: String, items: [Value]) -> Self { self.set(key, Value.Array(items)) }
    fn object(key: String, obj: Value) -> Self { self.set(key, obj) }
    fn infinity(key: String) -> Self { self.set(key, Value.Number(Float.INFINITY)) }
    fn nan(key: String) -> Self { self.set(key, Value.Number(Float.NAN)) }
    fn build() -> Value { Value.Object(self.map) }
}

struct ArrayBuilder {
    items: [Value]
    
    fn new() -> Self { ArrayBuilder { items: [] } }
    fn add(value: Value) -> Self { self.items.append(value); self }
    fn string(value: String) -> Self { self.add(Value.String(value)) }
    fn number(value: Float) -> Self { self.add(Value.Number(value)) }
    fn int(value: Int) -> Self { self.add(Value.Number(value as Float)) }
    fn bool(value: Bool) -> Self { self.add(Value.Bool(value)) }
    fn null() -> Self { self.add(Value.Null) }
    fn build() -> Value { Value.Array(self.items) }
}

fn object() -> ObjectBuilder { ObjectBuilder.new() }
fn array() -> ArrayBuilder { ArrayBuilder.new() }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum JSON5Error {
    UnexpectedChar(Char, Int, Int)
    UnexpectedEOF
    Expected(Char, Int, Int)
    ExpectedKey(Int, Int)
    UnterminatedString(Int)
    InvalidEscape(Int)
    InvalidNumber(Int)
    IOError(String)
    
    fn message() -> String {
        match self {
            .UnexpectedChar(c, l, col) => "Unexpected character '\(c)' at line \(l), column \(col)"
            .UnexpectedEOF => "Unexpected end of file"
            .Expected(c, l, col) => "Expected '\(c)' at line \(l), column \(col)"
            .ExpectedKey(l, col) => "Expected object key at line \(l), column \(col)"
            .UnterminatedString(l) => "Unterminated string at line \(l)"
            .InvalidEscape(l) => "Invalid escape sequence at line \(l)"
            .InvalidNumber(l) => "Invalid number at line \(l)"
            .IOError(m) => "I/O error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn parse(json5: String) -> Result<Value, JSON5Error> { Value.parse(json5) }
fn parse_file(path: String) -> Result<Value, JSON5Error> { Value.parse_file(path) }

fn to_json5(value: Value) -> String { value.to_json5() }
fn to_json5_pretty(value: Value) -> String { value.to_json5_pretty() }
fn to_json(value: Value) -> String { value.to_json() }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse single quoted strings" {
    let json5 = "{ name: 'test' }"
    let v = parse(json5)?
    assert(v["name"]?.as_str() == Some("test"))
}

test "parse unquoted keys" {
    let json5 = "{ firstName: 'John', lastName: 'Doe' }"
    let v = parse(json5)?
    assert(v["firstName"]?.as_str() == Some("John"))
    assert(v["lastName"]?.as_str() == Some("Doe"))
}

test "parse trailing commas" {
    let json5 = "{ a: 1, b: 2, }"
    let v = parse(json5)?
    assert(v["a"]?.as_int() == Some(1))
    assert(v["b"]?.as_int() == Some(2))
}

test "parse hex numbers" {
    let json5 = "{ value: 0xFF }"
    let v = parse(json5)?
    assert(v["value"]?.as_int() == Some(255))
}

test "parse infinity and nan" {
    let json5 = "{ inf: Infinity, negInf: -Infinity, nan: NaN }"
    let v = parse(json5)?
    assert(v["inf"]?.as_number()?.is_infinite())
    assert(v["nan"]?.as_number()?.is_nan())
}

test "parse leading decimal point" {
    let json5 = "{ value: .5 }"
    let v = parse(json5)?
    assert(v["value"]?.as_number() == Some(0.5))
}

test "parse with comments" {
    let json5 = "{\n  // line comment\n  name: 'test', /* block comment */\n  value: 42\n}"
    let v = parse(json5)?
    assert(v["name"]?.as_str() == Some("test"))
    assert(v["value"]?.as_int() == Some(42))
}

test "emit json5" {
    let v = object().string("name", "test").int("count", 42).build()
    let json5 = v.to_json5_pretty()
    assert(json5.contains("name: 'test'"))
}

test "multiline strings" {
    let json5 = "{ text: 'line1\\\nline2' }"
    let v = parse(json5)?
    assert(v["text"]?.as_str() == Some("line1line2"))
}

test "positive sign" {
    let json5 = "{ value: +42 }"
    let v = parse(json5)?
    assert(v["value"]?.as_int() == Some(42))
}
