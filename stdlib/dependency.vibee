// =============================================================================
// Vibee OS â€” Dependency Module
// Dependency management and resolution
// =============================================================================

// -----------------------------------------------------------------------------
// Dependency Specification
// -----------------------------------------------------------------------------

/// Dependency specification
struct Dependency {
    name: String
    version_req: VersionReq
    source: DependencySource
    features: [String]
    optional: Bool
    dev_only: Bool
    
    fn new(name: String, version: String) -> Result<Self, DependencyError> {
        Ok(Dependency {
            name: name,
            version_req: VersionReq.parse(version)?,
            source: DependencySource.Registry("https://registry.vibee.dev"),
            features: [],
            optional: false,
            dev_only: false
        })
    }
    
    fn from_git(name: String, url: String, rev: Option<String>) -> Self {
        Dependency {
            name: name,
            version_req: VersionReq.Any,
            source: DependencySource.Git { url: url, rev: rev, branch: None, tag: None },
            features: [],
            optional: false,
            dev_only: false
        }
    }
    
    fn from_path(name: String, path: String) -> Self {
        Dependency {
            name: name,
            version_req: VersionReq.Any,
            source: DependencySource.Path(path),
            features: [],
            optional: false,
            dev_only: false
        }
    }
    
    fn with_features(self, features: [String]) -> Self {
        Dependency { features: features, ..self }
    }
    
    fn optional(self) -> Self {
        Dependency { optional: true, ..self }
    }
    
    fn dev(self) -> Self {
        Dependency { dev_only: true, ..self }
    }
}

/// Dependency source
enum DependencySource {
    Registry(String)
    Git { url: String, rev: Option<String>, branch: Option<String>, tag: Option<String> }
    Path(String)
    
    fn is_local() -> Bool {
        match self {
            .Path(_) => true
            _ => false
        }
    }
}

/// Version requirement
enum VersionReq {
    Exact(Version)
    Range { min: Option<Version>, max: Option<Version>, min_inclusive: Bool, max_inclusive: Bool }
    Caret(Version)
    Tilde(Version)
    Wildcard { major: Int, minor: Option<Int> }
    Any
    
    fn parse(s: String) -> Result<Self, DependencyError> {
        let s = s.trim()
        
        if s == "*" || s.is_empty() {
            return Ok(VersionReq.Any)
        }
        
        if s.starts_with("^") {
            let v = Version.parse(s[1..])?
            return Ok(VersionReq.Caret(v))
        }
        
        if s.starts_with("~") {
            let v = Version.parse(s[1..])?
            return Ok(VersionReq.Tilde(v))
        }
        
        if s.starts_with(">=") {
            let v = Version.parse(s[2..].trim())?
            return Ok(VersionReq.Range { min: Some(v), max: None, min_inclusive: true, max_inclusive: false })
        }
        
        if s.starts_with(">") {
            let v = Version.parse(s[1..].trim())?
            return Ok(VersionReq.Range { min: Some(v), max: None, min_inclusive: false, max_inclusive: false })
        }
        
        if s.starts_with("<=") {
            let v = Version.parse(s[2..].trim())?
            return Ok(VersionReq.Range { min: None, max: Some(v), min_inclusive: false, max_inclusive: true })
        }
        
        if s.starts_with("<") {
            let v = Version.parse(s[1..].trim())?
            return Ok(VersionReq.Range { min: None, max: Some(v), min_inclusive: false, max_inclusive: false })
        }
        
        if s.starts_with("=") {
            let v = Version.parse(s[1..].trim())?
            return Ok(VersionReq.Exact(v))
        }
        
        if s.contains("*") || s.contains("x") {
            let parts = s.split(".")
            let major = Int.parse(parts[0])?
            let minor = parts.get(1).and_then(|p| {
                if p == "*" || p == "x" { None }
                else { Int.parse(p).ok() }
            })
            return Ok(VersionReq.Wildcard { major: major, minor: minor })
        }
        
        // Default to exact version
        let v = Version.parse(s)?
        Ok(VersionReq.Exact(v))
    }
    
    fn matches(version: Version) -> Bool {
        match self {
            .Any => true
            .Exact(v) => version == v
            .Caret(v) => {
                if version < v { return false }
                if v.major == 0 {
                    if v.minor == 0 {
                        version.major == 0 && version.minor == 0 && version.patch == v.patch
                    } else {
                        version.major == 0 && version.minor == v.minor
                    }
                } else {
                    version.major == v.major
                }
            }
            .Tilde(v) => {
                version >= v && version.major == v.major && version.minor == v.minor
            }
            .Range { min, max, min_inclusive, max_inclusive } => {
                let min_ok = match min {
                    Some(m) => if min_inclusive { version >= m } else { version > m }
                    None => true
                }
                let max_ok = match max {
                    Some(m) => if max_inclusive { version <= m } else { version < m }
                    None => true
                }
                min_ok && max_ok
            }
            .Wildcard { major, minor } => {
                if version.major != major { return false }
                match minor {
                    Some(m) => version.minor == m
                    None => true
                }
            }
        }
    }
}

/// Semantic version
struct Version {
    major: Int
    minor: Int
    patch: Int
    prerelease: Option<String>
    build: Option<String>
    
    fn new(major: Int, minor: Int, patch: Int) -> Self {
        Version { major: major, minor: minor, patch: patch, prerelease: None, build: None }
    }
    
    fn parse(s: String) -> Result<Self, DependencyError> {
        let s = s.trim().trim_start("v")
        
        // Split build metadata
        let (version_pre, build) = match s.split_once("+") {
            Some((v, b)) => (v, Some(b))
            None => (s, None)
        }
        
        // Split prerelease
        let (version, prerelease) = match version_pre.split_once("-") {
            Some((v, p)) => (v, Some(p))
            None => (version_pre, None)
        }
        
        let parts = version.split(".")
        if parts.len() < 1 || parts.len() > 3 {
            return Err(DependencyError.InvalidVersion(s))
        }
        
        let major = Int.parse(parts[0]).map_err(|_| DependencyError.InvalidVersion(s))?
        let minor = parts.get(1).map(|p| Int.parse(p)).transpose()?.unwrap_or(0)
        let patch = parts.get(2).map(|p| Int.parse(p)).transpose()?.unwrap_or(0)
        
        Ok(Version { major: major, minor: minor, patch: patch, prerelease: prerelease, build: build })
    }
    
    fn to_string() -> String {
        var s = format!("{}.{}.{}", self.major, self.minor, self.patch)
        if let Some(pre) = self.prerelease {
            s = format!("{}-{}", s, pre)
        }
        if let Some(b) = self.build {
            s = format!("{}+{}", s, b)
        }
        s
    }
}

impl Eq for Version {
    fn eq(other: Version) -> Bool {
        self.major == other.major && self.minor == other.minor && self.patch == other.patch
    }
}

impl Ord for Version {
    fn cmp(other: Version) -> Ordering {
        match self.major.cmp(other.major) {
            Ordering.Equal => {}
            ord => return ord
        }
        match self.minor.cmp(other.minor) {
            Ordering.Equal => {}
            ord => return ord
        }
        self.patch.cmp(other.patch)
    }
}

// -----------------------------------------------------------------------------
// Dependency Resolver
// -----------------------------------------------------------------------------

/// Dependency resolver
actor DependencyResolver {
    state registry: RegistryClient
    state cache: DependencyCache
    state lock: LockFile
    state strategy: ResolutionStrategy
    
    init() {
        self.registry = RegistryClient.new("https://registry.vibee.dev")
        self.cache = DependencyCache.new()
        self.lock = LockFile.empty()
        self.strategy = ResolutionStrategy.Newest
    }
    
    /// Set resolution strategy
    on strategy(s: ResolutionStrategy) -> Self {
        self.strategy = s
        self
    }
    
    /// Load lock file
    on load_lock(path: String) -> Result<(), DependencyError> {
        self.lock = LockFile.load(path)?
        Ok(())
    }
    
    /// Resolve dependencies
    on resolve(deps: [Dependency]) -> Result<ResolvedDependencies, DependencyError> {
        var resolved = Map.empty()
        var queue = deps.clone()
        var visited = Set.empty()
        
        while !queue.is_empty() {
            let dep = queue.pop().unwrap()
            
            if visited.contains(dep.name) {
                continue
            }
            visited.insert(dep.name.clone())
            
            // Check lock file first
            let version = if let Some(locked) = self.lock.get(dep.name) {
                if dep.version_req.matches(locked.version) {
                    locked.version.clone()
                } else {
                    self.find_version(dep)?
                }
            } else {
                self.find_version(dep)?
            }
            
            // Get package metadata
            let pkg = self.fetch_metadata(dep.name, version)?
            
            // Add transitive dependencies
            for trans_dep in pkg.dependencies {
                if !visited.contains(trans_dep.name) {
                    queue.push(trans_dep)
                }
            }
            
            resolved.set(dep.name.clone(), ResolvedDependency {
                name: dep.name,
                version: version,
                source: dep.source,
                checksum: pkg.checksum,
                dependencies: pkg.dependencies.iter().map(|d| d.name.clone()).collect()
            })
        }
        
        // Check for conflicts
        self.check_conflicts(resolved)?
        
        Ok(ResolvedDependencies { deps: resolved })
    }
    
    /// Update dependencies
    on update(deps: [Dependency]) -> Result<ResolvedDependencies, DependencyError> {
        // Clear lock for specified deps
        for dep in deps {
            self.lock.remove(dep.name)
        }
        self.resolve(deps)
    }
    
    /// Find best matching version
    fn find_version(dep: Dependency) -> Result<Version, DependencyError> {
        let versions = self.registry.get_versions(dep.name)?
        
        let matching = versions.iter()
            .filter(|v| dep.version_req.matches(v))
            .collect::<[Version]>()
        
        if matching.is_empty() {
            return Err(DependencyError.NoMatchingVersion(dep.name, dep.version_req.to_string()))
        }
        
        match self.strategy {
            ResolutionStrategy.Newest => Ok(matching.max().unwrap())
            ResolutionStrategy.Oldest => Ok(matching.min().unwrap())
            ResolutionStrategy.Locked => {
                self.lock.get(dep.name)
                    .map(|l| l.version.clone())
                    .ok_or(DependencyError.NotLocked(dep.name))
            }
        }
    }
    
    /// Fetch package metadata
    fn fetch_metadata(name: String, version: Version) -> Result<PackageMetadata, DependencyError> {
        // Check cache first
        if let Some(meta) = self.cache.get(name, version) {
            return Ok(meta)
        }
        
        let meta = self.registry.get_metadata(name, version)?
        self.cache.set(name, version, meta.clone())
        Ok(meta)
    }
    
    /// Check for version conflicts
    fn check_conflicts(resolved: Map<String, ResolvedDependency>) -> Result<(), DependencyError> {
        // Build dependency graph and check for conflicts
        var versions = Map.empty()
        
        for (name, dep) in resolved {
            if let Some(existing) = versions.get(name) {
                if existing != dep.version {
                    return Err(DependencyError.VersionConflict(name, existing.to_string(), dep.version.to_string()))
                }
            }
            versions.set(name, dep.version)
        }
        
        Ok(())
    }
}

/// Resolution strategy
enum ResolutionStrategy {
    Newest      // Always use newest matching version
    Oldest      // Use oldest matching version
    Locked      // Prefer locked versions
}

// -----------------------------------------------------------------------------
// Dependency Fetcher
// -----------------------------------------------------------------------------

/// Dependency fetcher
actor DependencyFetcher {
    state cache_dir: String
    state registry: RegistryClient
    state parallel: Int
    
    init() {
        self.cache_dir = ".vibee/cache"
        self.registry = RegistryClient.new("https://registry.vibee.dev")
        self.parallel = 4
    }
    
    /// Fetch all resolved dependencies
    on fetch(resolved: ResolvedDependencies) -> Result<FetchResult, DependencyError> {
        var fetched = []
        var errors = []
        
        let deps = resolved.deps.values().collect::<[ResolvedDependency]>()
        
        // Parallel fetch
        let results = parallel::map_with_limit(deps, self.parallel, |dep| {
            self.fetch_one(dep)
        })
        
        for result in results {
            match result {
                Ok(path) => fetched.append(path)
                Err(e) => errors.append(e)
            }
        }
        
        if !errors.is_empty() {
            return Err(DependencyError.FetchFailed(errors))
        }
        
        Ok(FetchResult { paths: fetched })
    }
    
    /// Fetch single dependency
    on fetch_one(dep: ResolvedDependency) -> Result<String, DependencyError> {
        let cache_path = self.cache_path(dep.name, dep.version)
        
        // Check if already cached
        if fs::exists(cache_path) {
            // Verify checksum
            if self.verify_checksum(cache_path, dep.checksum) {
                return Ok(cache_path)
            }
            // Invalid cache, remove
            fs::remove_dir_all(cache_path)?
        }
        
        // Fetch based on source
        match dep.source {
            DependencySource.Registry(url) => {
                self.fetch_from_registry(dep.name, dep.version, cache_path)
            }
            DependencySource.Git { url, rev, .. } => {
                self.fetch_from_git(url, rev, cache_path)
            }
            DependencySource.Path(path) => {
                // Local path, just return it
                Ok(path)
            }
        }
    }
    
    fn fetch_from_registry(name: String, version: Version, dest: String) -> Result<String, DependencyError> {
        let url = self.registry.download_url(name, version)
        let archive_path = format!("{}.tar.gz", dest)
        
        // Download
        http::download(url, archive_path)?
        
        // Extract
        fs::create_dir_all(dest)?
        tar::extract(archive_path, dest)?
        fs::remove(archive_path)?
        
        Ok(dest)
    }
    
    fn fetch_from_git(url: String, rev: Option<String>, dest: String) -> Result<String, DependencyError> {
        fs::create_dir_all(dest)?
        
        // Clone repository
        let args = match rev {
            Some(r) => ["clone", "--depth", "1", "--branch", r, url, dest]
            None => ["clone", "--depth", "1", url, dest]
        }
        
        let result = shell::exec("git", args)?
        if result.exit_code != 0 {
            return Err(DependencyError.GitError(result.stderr))
        }
        
        Ok(dest)
    }
    
    fn cache_path(name: String, version: Version) -> String {
        format!("{}/{}/{}", self.cache_dir, name, version.to_string())
    }
    
    fn verify_checksum(path: String, expected: String) -> Bool {
        if expected.is_empty() { return true }
        
        let actual = match crypto::sha256_dir(path) {
            Ok(h) => h
            Err(_) => return false
        }
        
        actual == expected
    }
}

// -----------------------------------------------------------------------------
// Lock File
// -----------------------------------------------------------------------------

struct LockFile {
    version: Int
    packages: Map<String, LockedPackage>
    
    fn empty() -> Self {
        LockFile { version: 1, packages: Map.empty() }
    }
    
    fn load(path: String) -> Result<Self, DependencyError> {
        if !fs::exists(path) {
            return Ok(Self.empty())
        }
        
        let content = fs::read_string(path)?
        let toml = toml::parse(content)?
        
        var packages = Map.empty()
        if let Some(pkgs) = toml.get("package")?.as_array() {
            for pkg in pkgs {
                let name = pkg.get("name")?.as_str()?
                packages.set(name.clone(), LockedPackage {
                    name: name,
                    version: Version.parse(pkg.get("version")?.as_str()?)?,
                    source: pkg.get("source")?.as_str().unwrap_or(""),
                    checksum: pkg.get("checksum")?.as_str().unwrap_or("")
                })
            }
        }
        
        Ok(LockFile { version: 1, packages: packages })
    }
    
    fn save(path: String) -> Result<(), DependencyError> {
        var content = "# This file is auto-generated by vibee\n"
        content += "version = 1\n\n"
        
        for (_, pkg) in self.packages {
            content += "[[package]]\n"
            content += format!("name = \"{}\"\n", pkg.name)
            content += format!("version = \"{}\"\n", pkg.version.to_string())
            if !pkg.source.is_empty() {
                content += format!("source = \"{}\"\n", pkg.source)
            }
            if !pkg.checksum.is_empty() {
                content += format!("checksum = \"{}\"\n", pkg.checksum)
            }
            content += "\n"
        }
        
        fs::write_string(path, content)?
        Ok(())
    }
    
    fn get(name: String) -> Option<LockedPackage> {
        self.packages.get(name)
    }
    
    fn set(name: String, pkg: LockedPackage) {
        self.packages.set(name, pkg)
    }
    
    fn remove(name: String) {
        self.packages.remove(name)
    }
}

struct LockedPackage {
    name: String
    version: Version
    source: String
    checksum: String
}

// -----------------------------------------------------------------------------
// Registry Client
// -----------------------------------------------------------------------------

actor RegistryClient {
    state base_url: String
    state token: Option<String>
    
    init(url: String) {
        self.base_url = url
        self.token = None
    }
    
    on authenticate(token: String) {
        self.token = Some(token)
    }
    
    on get_versions(name: String) -> Result<[Version], DependencyError> {
        let url = format!("{}/api/v1/crates/{}/versions", self.base_url, name)
        let response = self.request(url)?
        
        let json = json::parse(response.body)?
        let versions = json.get("versions")?.as_array()?
            .filter_map(|v| Version.parse(v.get("num")?.as_str()?).ok())
            .collect()
        
        Ok(versions)
    }
    
    on get_metadata(name: String, version: Version) -> Result<PackageMetadata, DependencyError> {
        let url = format!("{}/api/v1/crates/{}/{}", self.base_url, name, version.to_string())
        let response = self.request(url)?
        
        let json = json::parse(response.body)?
        let pkg = json.get("version")?
        
        let deps = pkg.get("dependencies")?.as_array().unwrap_or([])
            .filter_map(|d| {
                let name = d.get("crate_id")?.as_str()?
                let req = d.get("req")?.as_str()?
                Dependency.new(name, req).ok()
            })
            .collect()
        
        Ok(PackageMetadata {
            name: name,
            version: version,
            checksum: pkg.get("checksum")?.as_str().unwrap_or(""),
            dependencies: deps
        })
    }
    
    on download_url(name: String, version: Version) -> String {
        format!("{}/api/v1/crates/{}/{}/download", self.base_url, name, version.to_string())
    }
    
    fn request(url: String) -> Result<HttpResponse, DependencyError> {
        var headers = Map.empty()
        if let Some(token) = self.token {
            headers.set("Authorization", format!("Bearer {}", token))
        }
        
        http::get(url, headers).map_err(|e| DependencyError.NetworkError(e.to_string()))
    }
}

// -----------------------------------------------------------------------------
// Dependency Cache
// -----------------------------------------------------------------------------

struct DependencyCache {
    entries: Map<String, PackageMetadata>
    
    fn new() -> Self {
        DependencyCache { entries: Map.empty() }
    }
    
    fn key(name: String, version: Version) -> String {
        format!("{}@{}", name, version.to_string())
    }
    
    fn get(name: String, version: Version) -> Option<PackageMetadata> {
        self.entries.get(Self.key(name, version))
    }
    
    fn set(name: String, version: Version, meta: PackageMetadata) {
        self.entries.set(Self.key(name, version), meta)
    }
}

// -----------------------------------------------------------------------------
// Supporting Types
// -----------------------------------------------------------------------------

struct PackageMetadata {
    name: String
    version: Version
    checksum: String
    dependencies: [Dependency]
}

struct ResolvedDependencies {
    deps: Map<String, ResolvedDependency>
    
    fn iter() -> impl Iterator<Item = ResolvedDependency> {
        self.deps.values()
    }
    
    fn get(name: String) -> Option<ResolvedDependency> {
        self.deps.get(name)
    }
}

struct ResolvedDependency {
    name: String
    version: Version
    source: DependencySource
    checksum: String
    dependencies: [String]
}

struct FetchResult {
    paths: [String]
}

struct HttpResponse {
    status: Int
    body: String
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum DependencyError {
    InvalidVersion(String)
    NoMatchingVersion(String, String)
    VersionConflict(String, String, String)
    NotLocked(String)
    FetchFailed([DependencyError])
    NetworkError(String)
    GitError(String)
    ParseError(String)
    IOError(String)
    
    fn message() -> String {
        match self {
            .InvalidVersion(v) => "Invalid version: \(v)"
            .NoMatchingVersion(n, r) => "No version of \(n) matches \(r)"
            .VersionConflict(n, v1, v2) => "Version conflict for \(n): \(v1) vs \(v2)"
            .NotLocked(n) => "Package not locked: \(n)"
            .FetchFailed(errs) => "Failed to fetch dependencies"
            .NetworkError(m) => "Network error: \(m)"
            .GitError(m) => "Git error: \(m)"
            .ParseError(m) => "Parse error: \(m)"
            .IOError(m) => "I/O error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Create new dependency
fn dep(name: String, version: String) -> Result<Dependency, DependencyError> {
    Dependency.new(name, version)
}

/// Create git dependency
fn git(name: String, url: String) -> Dependency {
    Dependency.from_git(name, url, None)
}

/// Create path dependency
fn path(name: String, path: String) -> Dependency {
    Dependency.from_path(name, path)
}

/// Resolve dependencies from config
fn resolve(config_path: String) -> Result<ResolvedDependencies, DependencyError> {
    let content = fs::read_string(config_path)?
    let toml = toml::parse(content)?
    
    var deps = []
    if let Some(dep_table) = toml.get("dependencies")?.as_table() {
        for (name, spec) in dep_table {
            let dep = match spec {
                toml::Value.String(v) => Dependency.new(name, v)?
                toml::Value.Table(t) => {
                    if let Some(path) = t.get("path")?.as_str() {
                        Dependency.from_path(name, path)
                    } else if let Some(git) = t.get("git")?.as_str() {
                        let rev = t.get("rev")?.as_str()
                        Dependency.from_git(name, git, rev)
                    } else {
                        let version = t.get("version")?.as_str().unwrap_or("*")
                        Dependency.new(name, version)?
                    }
                }
                _ => continue
            }
            deps.append(dep)
        }
    }
    
    let resolver = DependencyResolver.new()
    resolver.resolve(deps)
}

/// Install dependencies
fn install(config_path: String) -> Result<(), DependencyError> {
    let resolved = resolve(config_path)?
    let fetcher = DependencyFetcher.new()
    fetcher.fetch(resolved)?
    Ok(())
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "version parsing" {
    let v = Version.parse("1.2.3")?
    assert_eq(v.major, 1)?
    assert_eq(v.minor, 2)?
    assert_eq(v.patch, 3)?
}

test "version comparison" {
    assert(Version.new(1, 0, 0) < Version.new(2, 0, 0))?
    assert(Version.new(1, 1, 0) > Version.new(1, 0, 0))?
    assert(Version.new(1, 0, 1) > Version.new(1, 0, 0))?
}

test "version requirement caret" {
    let req = VersionReq.parse("^1.2.3")?
    assert(req.matches(Version.new(1, 2, 3)))?
    assert(req.matches(Version.new(1, 9, 0)))?
    assert(!req.matches(Version.new(2, 0, 0)))?
}

test "version requirement tilde" {
    let req = VersionReq.parse("~1.2.3")?
    assert(req.matches(Version.new(1, 2, 3)))?
    assert(req.matches(Version.new(1, 2, 9)))?
    assert(!req.matches(Version.new(1, 3, 0)))?
}

test "dependency creation" {
    let dep = Dependency.new("serde", "^1.0")?
    assert_eq(dep.name, "serde")?
    assert(!dep.optional)?
}

test "lock file" {
    let lock = LockFile.empty()
    assert(lock.packages.is_empty())?
}
