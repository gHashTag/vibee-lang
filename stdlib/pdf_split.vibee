// =============================================================================
// Vibee OS â€” PDF Split Module
// Splitting and extracting pages from PDF documents
// =============================================================================

use fs::{File, IoError}
use pdf_reader::{PdfDocument, PdfPage, PdfMetadata, PdfError, PdfPageSize}

// =============================================================================
// PDF Splitter
// =============================================================================

/// PDF document splitter
struct PdfSplitter {
    handle: @native("PdfSplitterHandle")
    source: PdfDocument
    preserve_metadata: Bool
    preserve_outline: Bool
}

impl PdfSplitter {
    /// Create splitter from file path
    fn open(path: String) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(path)?
        Ok(PdfSplitter {
            handle: @native("pdf_splitter_new", doc.handle),
            source: doc,
            preserve_metadata: true,
            preserve_outline: false
        })
    }
    
    /// Create splitter from document
    fn from_document(doc: PdfDocument) -> Self {
        PdfSplitter {
            handle: @native("pdf_splitter_new", doc.handle),
            source: doc,
            preserve_metadata: true,
            preserve_outline: false
        }
    }
    
    /// Set metadata preservation
    fn preserve_metadata(preserve: Bool) -> Self {
        self.preserve_metadata = preserve
        self
    }
    
    /// Set outline preservation
    fn preserve_outline(preserve: Bool) -> Self {
        self.preserve_outline = preserve
        self
    }
    
    /// Get page count
    fn page_count() -> Int {
        self.source.page_count
    }
    
    // -------------------------------------------------------------------------
    // Single Page Extraction
    // -------------------------------------------------------------------------
    
    /// Extract single page to file
    fn extract_page(page_index: Int, output: String) -> Result<(), PdfError> {
        self.extract_pages([page_index], output)
    }
    
    /// Extract multiple pages to single file
    fn extract_pages(page_indices: [Int], output: String) -> Result<(), PdfError> {
        for idx in page_indices {
            if idx < 0 || idx >= self.source.page_count {
                return Err(PdfError.PageNotFound(idx))
            }
        }
        @native("pdf_splitter_extract_pages", self.handle, page_indices, output, self.preserve_metadata)
    }
    
    /// Extract page range to file
    fn extract_range(start: Int, end: Int, output: String) -> Result<(), PdfError> {
        if start < 0 || end >= self.source.page_count || start > end {
            return Err(PdfError.InvalidPageRange(start, end))
        }
        let pages: [Int] = (start..=end).collect()
        self.extract_pages(pages, output)
    }
    
    // -------------------------------------------------------------------------
    // Split Operations
    // -------------------------------------------------------------------------
    
    /// Split into individual pages
    fn split_all(output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        fs::create_dir_all(output_dir)?
        
        let mut files = []
        for i in 0..self.source.page_count {
            let filename = format!("{}/{}_{:04}.pdf", output_dir, prefix, i + 1)
            self.extract_page(i, filename.clone())?
            files.push(filename)
        }
        
        Ok(SplitResult {
            files: files,
            page_count: self.source.page_count
        })
    }
    
    /// Split into chunks of N pages
    fn split_every(n: Int, output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        if n <= 0 {
            return Err(PdfError.InvalidChunkSize(n))
        }
        
        fs::create_dir_all(output_dir)?
        
        let mut files = []
        let mut chunk_num = 1
        let mut start = 0
        
        while start < self.source.page_count {
            let end = (start + n - 1).min(self.source.page_count - 1)
            let filename = format!("{}/{}_{:04}.pdf", output_dir, prefix, chunk_num)
            self.extract_range(start, end, filename.clone())?
            files.push(filename)
            
            start += n
            chunk_num += 1
        }
        
        Ok(SplitResult {
            files: files,
            page_count: self.source.page_count
        })
    }
    
    /// Split at specific page numbers
    fn split_at(split_points: [Int], output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        fs::create_dir_all(output_dir)?
        
        let mut points = split_points.clone()
        points.sort()
        points.dedup()
        
        // Add start and end points
        if points.is_empty() || points[0] != 0 {
            points.insert(0, 0)
        }
        if points.last().unwrap() != self.source.page_count {
            points.push(self.source.page_count)
        }
        
        let mut files = []
        for i in 0..(points.len() - 1) {
            let start = points[i]
            let end = points[i + 1] - 1
            let filename = format!("{}/{}_{:04}.pdf", output_dir, prefix, i + 1)
            self.extract_range(start, end, filename.clone())?
            files.push(filename)
        }
        
        Ok(SplitResult {
            files: files,
            page_count: self.source.page_count
        })
    }
    
    /// Split by file size (approximate)
    fn split_by_size(max_size_bytes: Int, output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        fs::create_dir_all(output_dir)?
        
        let avg_page_size = self.estimate_page_size()
        let pages_per_chunk = (max_size_bytes / avg_page_size).max(1)
        
        self.split_every(pages_per_chunk, output_dir, prefix)
    }
    
    /// Split into N equal parts
    fn split_into(n: Int, output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        if n <= 0 {
            return Err(PdfError.InvalidChunkSize(n))
        }
        
        let pages_per_part = (self.source.page_count + n - 1) / n
        self.split_every(pages_per_part, output_dir, prefix)
    }
    
    /// Split odd and even pages
    fn split_odd_even(output_dir: String, prefix: String) -> Result<(String, String), PdfError> {
        fs::create_dir_all(output_dir)?
        
        let odd_pages: [Int] = (0..self.source.page_count).filter(|i| i % 2 == 0).collect()
        let even_pages: [Int] = (0..self.source.page_count).filter(|i| i % 2 == 1).collect()
        
        let odd_file = format!("{}/{}_odd.pdf", output_dir, prefix)
        let even_file = format!("{}/{}_even.pdf", output_dir, prefix)
        
        if !odd_pages.is_empty() {
            self.extract_pages(odd_pages, odd_file.clone())?
        }
        if !even_pages.is_empty() {
            self.extract_pages(even_pages, even_file.clone())?
        }
        
        Ok((odd_file, even_file))
    }
    
    /// Split by bookmarks/outline
    fn split_by_outline(output_dir: String) -> Result<SplitResult, PdfError> {
        fs::create_dir_all(output_dir)?
        
        let outline = self.source.outline()?
        if outline.is_empty() {
            return Err(PdfError.NoOutline)
        }
        
        let mut files = []
        let mut split_points = []
        
        for item in outline {
            if let Some(dest) = item.destination {
                split_points.push(dest)
            }
        }
        
        if split_points.is_empty() {
            return Err(PdfError.NoOutline)
        }
        
        split_points.sort()
        split_points.dedup()
        
        for i in 0..split_points.len() {
            let start = split_points[i]
            let end = if i + 1 < split_points.len() {
                split_points[i + 1] - 1
            } else {
                self.source.page_count - 1
            }
            
            let title = outline.get(i).map(|o| o.title.clone()).unwrap_or_default()
            let safe_title = sanitize_filename(title)
            let filename = format!("{}/{:04}_{}.pdf", output_dir, i + 1, safe_title)
            
            self.extract_range(start, end, filename.clone())?
            files.push(filename)
        }
        
        Ok(SplitResult {
            files: files,
            page_count: self.source.page_count
        })
    }
    
    // -------------------------------------------------------------------------
    // Helper Methods
    // -------------------------------------------------------------------------
    
    fn estimate_page_size() -> Int {
        // Estimate average page size in bytes
        @native("pdf_splitter_estimate_page_size", self.handle)
    }
}

/// Split operation result
struct SplitResult {
    files: [String]
    page_count: Int
}

impl SplitResult {
    fn file_count() -> Int { self.files.len() }
}

// =============================================================================
// Page Extractor
// =============================================================================

/// Fluent page extractor
struct PageExtractor {
    source_path: String
    pages: [Int]
    output_path: Option<String>
}

impl PageExtractor {
    fn from(path: String) -> Self {
        PageExtractor {
            source_path: path,
            pages: [],
            output_path: None
        }
    }
    
    /// Add single page
    fn page(index: Int) -> Self {
        self.pages.push(index)
        self
    }
    
    /// Add page range
    fn range(start: Int, end: Int) -> Self {
        for i in start..=end {
            self.pages.push(i)
        }
        self
    }
    
    /// Add first N pages
    fn first(n: Int) -> Self {
        for i in 0..n {
            self.pages.push(i)
        }
        self
    }
    
    /// Add last N pages
    fn last(n: Int) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(self.source_path.clone())?
        let start = (doc.page_count - n).max(0)
        for i in start..doc.page_count {
            self.pages.push(i)
        }
        Ok(self)
    }
    
    /// Add odd pages
    fn odd() -> Result<Self, PdfError> {
        let doc = PdfDocument.open(self.source_path.clone())?
        for i in 0..doc.page_count {
            if i % 2 == 0 { self.pages.push(i) }
        }
        Ok(self)
    }
    
    /// Add even pages
    fn even() -> Result<Self, PdfError> {
        let doc = PdfDocument.open(self.source_path.clone())?
        for i in 0..doc.page_count {
            if i % 2 == 1 { self.pages.push(i) }
        }
        Ok(self)
    }
    
    /// Exclude pages
    fn exclude(indices: [Int]) -> Self {
        self.pages = self.pages.iter().filter(|p| !indices.contains(p)).collect()
        self
    }
    
    /// Reverse page order
    fn reverse() -> Self {
        self.pages.reverse()
        self
    }
    
    /// Set output path
    fn to(path: String) -> Self {
        self.output_path = Some(path)
        self
    }
    
    /// Execute extraction
    fn extract() -> Result<(), PdfError> {
        let output = self.output_path.clone().ok_or(PdfError.NoOutputPath)?
        let splitter = PdfSplitter.open(self.source_path.clone())?
        splitter.extract_pages(self.pages.clone(), output)
    }
    
    /// Extract to bytes
    fn extract_bytes() -> Result<[UInt8], PdfError> {
        let splitter = PdfSplitter.open(self.source_path.clone())?
        @native("pdf_splitter_extract_pages_bytes", splitter.handle, self.pages.clone())
    }
}

// =============================================================================
// Burst Mode
// =============================================================================

/// Burst PDF into individual pages (optimized)
struct PdfBurst {
    handle: @native("PdfBurstHandle")
    source_path: String
    output_dir: String
    prefix: String
    format: String
}

impl PdfBurst {
    fn new(source: String, output_dir: String) -> Self {
        PdfBurst {
            handle: @native("pdf_burst_new"),
            source_path: source,
            output_dir: output_dir,
            prefix: "page".to_string(),
            format: "{prefix}_{num:04}.pdf".to_string()
        }
    }
    
    fn prefix(p: String) -> Self { self.prefix = p; self }
    fn format(f: String) -> Self { self.format = f; self }
    
    /// Execute burst operation
    fn execute() -> Result<SplitResult, PdfError> {
        fs::create_dir_all(self.output_dir.clone())?
        @native("pdf_burst_execute", self.handle, self.source_path, self.output_dir, self.prefix, self.format)
    }
    
    /// Execute with progress callback
    fn execute_with_progress<F>(callback: F) -> Result<SplitResult, PdfError>
    where F: Fn(Int, Int) {
        fs::create_dir_all(self.output_dir.clone())?
        
        let doc = PdfDocument.open(self.source_path.clone())?
        let total = doc.page_count
        let mut files = []
        
        for i in 0..total {
            callback(i + 1, total)
            let filename = self.format
                .replace("{prefix}", self.prefix.as_str())
                .replace("{num:04}", format!("{:04}", i + 1).as_str())
            let path = format!("{}/{}", self.output_dir, filename)
            
            @native("pdf_burst_extract_page", self.handle, i, path.clone())?
            files.push(path)
        }
        
        Ok(SplitResult { files: files, page_count: total })
    }
}

// =============================================================================
// Async Splitter
// =============================================================================

/// Async PDF splitter for large documents
actor AsyncSplitter {
    source_path: String
    
    fn new(path: String) -> Self {
        AsyncSplitter { source_path: path }
    }
    
    /// Split all pages asynchronously
    async fn split_all(output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        let splitter = PdfSplitter.open(self.source_path.clone())?
        splitter.split_all(output_dir, prefix)
    }
    
    /// Split with parallel processing
    async fn split_parallel(n: Int, output_dir: String, prefix: String) -> Result<SplitResult, PdfError> {
        let doc = PdfDocument.open(self.source_path.clone())?
        let total = doc.page_count
        
        let mut tasks = []
        for i in 0..total {
            let path = self.source_path.clone()
            let out = format!("{}/{}_{:04}.pdf", output_dir, prefix, i + 1)
            tasks.push(async {
                let splitter = PdfSplitter.open(path)?
                splitter.extract_page(i, out)
            })
        }
        
        // Execute in parallel with concurrency limit
        let results = parallel::join_all_limited(tasks, n).await?
        
        let files: [String] = (0..total)
            .map(|i| format!("{}/{}_{:04}.pdf", output_dir, prefix, i + 1))
            .collect()
        
        Ok(SplitResult { files: files, page_count: total })
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Split PDF into individual pages
fn split_all(path: String, output_dir: String) -> Result<SplitResult, PdfError> {
    PdfSplitter.open(path)?.split_all(output_dir, "page")
}

/// Split PDF every N pages
fn split_every(path: String, n: Int, output_dir: String) -> Result<SplitResult, PdfError> {
    PdfSplitter.open(path)?.split_every(n, output_dir, "part")
}

/// Split PDF into N parts
fn split_into(path: String, n: Int, output_dir: String) -> Result<SplitResult, PdfError> {
    PdfSplitter.open(path)?.split_into(n, output_dir, "part")
}

/// Extract single page
fn extract_page(path: String, page_index: Int, output: String) -> Result<(), PdfError> {
    PdfSplitter.open(path)?.extract_page(page_index, output)
}

/// Extract page range
fn extract_range(path: String, start: Int, end: Int, output: String) -> Result<(), PdfError> {
    PdfSplitter.open(path)?.extract_range(start, end, output)
}

/// Extract first N pages
fn extract_first(path: String, n: Int, output: String) -> Result<(), PdfError> {
    PdfSplitter.open(path)?.extract_range(0, n - 1, output)
}

/// Extract last N pages
fn extract_last(path: String, n: Int, output: String) -> Result<(), PdfError> {
    let doc = PdfDocument.open(path.clone())?
    let start = (doc.page_count - n).max(0)
    PdfSplitter.open(path)?.extract_range(start, doc.page_count - 1, output)
}

/// Burst PDF into pages
fn burst(path: String, output_dir: String) -> Result<SplitResult, PdfError> {
    PdfBurst.new(path, output_dir).execute()
}

/// Remove pages from PDF
fn remove_pages(path: String, pages_to_remove: [Int], output: String) -> Result<(), PdfError> {
    let doc = PdfDocument.open(path.clone())?
    let pages_to_keep: [Int] = (0..doc.page_count)
        .filter(|i| !pages_to_remove.contains(i))
        .collect()
    
    PdfSplitter.open(path)?.extract_pages(pages_to_keep, output)
}

/// Keep only specified pages
fn keep_pages(path: String, pages_to_keep: [Int], output: String) -> Result<(), PdfError> {
    PdfSplitter.open(path)?.extract_pages(pages_to_keep, output)
}

// =============================================================================
// Helper Functions
// =============================================================================

fn sanitize_filename(name: String) -> String {
    name.chars()
        .map(|c| if c.is_alphanumeric() || c == '-' || c == '_' { c } else { '_' })
        .collect()
}

// =============================================================================
// Errors
// =============================================================================

impl PdfError {
    fn InvalidPageRange(start: Int, end: Int) -> Self {
        PdfError.Other(format!("Invalid page range: {}-{}", start, end))
    }
    
    fn InvalidChunkSize(n: Int) -> Self {
        PdfError.Other(format!("Invalid chunk size: {}", n))
    }
    
    fn NoOutline() -> Self {
        PdfError.Other("Document has no outline/bookmarks")
    }
    
    fn NoOutputPath() -> Self {
        PdfError.Other("No output path specified")
    }
}

// =============================================================================
// Tests
// =============================================================================

test "split all pages" {
    let result = split_all("test.pdf", "/tmp/split")?
    assert(result.files.len() > 0)?
}

test "split every n pages" {
    let result = split_every("test.pdf", 5, "/tmp/split")?
    assert(result.files.len() > 0)?
}

test "extract single page" {
    extract_page("test.pdf", 0, "/tmp/page1.pdf")?
}

test "extract range" {
    extract_range("test.pdf", 0, 4, "/tmp/first5.pdf")?
}

test "page extractor fluent" {
    PageExtractor.from("test.pdf")
        .range(0, 4)
        .page(10)
        .exclude([2])
        .to("/tmp/extracted.pdf")
        .extract()?
}

test "burst" {
    let result = PdfBurst.new("test.pdf", "/tmp/burst")
        .prefix("doc")
        .execute()?
    assert(result.files.len() > 0)?
}

test "split result" {
    let result = SplitResult {
        files: ["a.pdf".to_string(), "b.pdf".to_string()],
        page_count: 10
    }
    assert_eq(result.file_count(), 2)?
}
