// =============================================================================
// Vibee OS â€” Environment Config Module
// Configuration from environment variables
// =============================================================================

// =============================================================================
// Core Environment Functions
// =============================================================================

/// Get environment variable
fn get(name: String) -> Option<String> { @native("env_get", name) }

/// Get environment variable with default
fn get_or(name: String, default: String) -> String { get(name).unwrap_or(default) }

/// Get required environment variable
fn require(name: String) -> Result<String, EnvConfigError> {
    get(name).ok_or(EnvConfigError.Missing(name))
}

/// Set environment variable
fn set(name: String, value: String) { @native("env_set", name, value) }

/// Remove environment variable
fn remove(name: String) { @native("env_remove", name) }

/// Check if environment variable exists
fn exists(name: String) -> Bool { get(name).is_some() }

/// Get all environment variables
fn all() -> Map<String, String> { @native("env_all") }

/// Get environment variables with prefix
fn with_prefix(prefix: String) -> Map<String, String> {
    all().filter(|(k, _)| k.starts_with(prefix))
}

// =============================================================================
// Typed Getters
// =============================================================================

/// Get as integer
fn get_int(name: String) -> Result<Int, EnvConfigError> {
    let value = require(name)?
    Int.parse(value).map_err(|_| EnvConfigError.ParseError(name, "Int"))
}

/// Get as integer with default
fn get_int_or(name: String, default: Int) -> Int {
    get_int(name).unwrap_or(default)
}

/// Get as float
fn get_float(name: String) -> Result<Float, EnvConfigError> {
    let value = require(name)?
    Float.parse(value).map_err(|_| EnvConfigError.ParseError(name, "Float"))
}

/// Get as float with default
fn get_float_or(name: String, default: Float) -> Float {
    get_float(name).unwrap_or(default)
}

/// Get as boolean
fn get_bool(name: String) -> Result<Bool, EnvConfigError> {
    let value = require(name)?
    match value.to_lower() {
        "true" | "1" | "yes" | "on" => Ok(true)
        "false" | "0" | "no" | "off" => Ok(false)
        _ => Err(EnvConfigError.ParseError(name, "Bool"))
    }
}

/// Get as boolean with default
fn get_bool_or(name: String, default: Bool) -> Bool {
    get_bool(name).unwrap_or(default)
}

/// Get as list (comma-separated)
fn get_list(name: String) -> Result<[String], EnvConfigError> {
    let value = require(name)?
    Ok(value.split(",").map(|s| s.trim()).filter(|s| !s.is_empty()).collect())
}

/// Get as list with default
fn get_list_or(name: String, default: [String]) -> [String] {
    get_list(name).unwrap_or(default)
}

/// Get as duration (e.g., "30s", "5m", "1h")
fn get_duration(name: String) -> Result<Duration, EnvConfigError> {
    let value = require(name)?
    Duration.parse(value).map_err(|_| EnvConfigError.ParseError(name, "Duration"))
}

/// Get as bytes size (e.g., "1KB", "10MB", "1GB")
fn get_bytes(name: String) -> Result<Int64, EnvConfigError> {
    let value = require(name)?
    parse_bytes(value).ok_or(EnvConfigError.ParseError(name, "Bytes"))
}

fn parse_bytes(s: String) -> Option<Int64> {
    let s = s.to_upper().trim()
    let multipliers = [
        ("TB", 1024 * 1024 * 1024 * 1024),
        ("GB", 1024 * 1024 * 1024),
        ("MB", 1024 * 1024),
        ("KB", 1024),
        ("B", 1)
    ]
    for (suffix, mult) in multipliers {
        if s.ends_with(suffix) {
            let num = s[..s.len() - suffix.len()].trim()
            return Int64.parse(num).ok().map(|n| n * mult)
        }
    }
    Int64.parse(s).ok()
}

// =============================================================================
// Environment Config Struct
// =============================================================================

/// Environment configuration builder
struct EnvConfig {
    prefix: Option<String>
    required: [String]
    defaults: Map<String, String>
    validators: Map<String, fn(String) -> Bool>
    transformers: Map<String, fn(String) -> String>
}

impl EnvConfig {
    fn new() -> Self {
        EnvConfig {
            prefix: None,
            required: [],
            defaults: Map.empty(),
            validators: Map.empty(),
            transformers: Map.empty()
        }
    }
    
    /// Set prefix for all variables
    fn with_prefix(prefix: String) -> Self {
        self.prefix = Some(prefix)
        self
    }
    
    /// Mark variable as required
    fn require(name: String) -> Self {
        self.required.push(name)
        self
    }
    
    /// Set default value
    fn default(name: String, value: String) -> Self {
        self.defaults.set(name, value)
        self
    }
    
    /// Add validator
    fn validate(name: String, validator: fn(String) -> Bool) -> Self {
        self.validators.set(name, validator)
        self
    }
    
    /// Add transformer
    fn transform(name: String, transformer: fn(String) -> String) -> Self {
        self.transformers.set(name, transformer)
        self
    }
    
    /// Get prefixed name
    fn prefixed_name(name: String) -> String {
        match self.prefix {
            Some(p) => format!("{}_{}", p, name)
            None => name
        }
    }
    
    /// Get value with prefix, defaults, and transformations
    fn get(name: String) -> Option<String> {
        let full_name = self.prefixed_name(name)
        let value = env_config.get(full_name).or_else(|| self.defaults.get(name).cloned())
        
        value.map(|v| {
            match self.transformers.get(name) {
                Some(t) => t(v)
                None => v
            }
        })
    }
    
    /// Get required value
    fn require_value(name: String) -> Result<String, EnvConfigError> {
        self.get(name).ok_or(EnvConfigError.Missing(self.prefixed_name(name)))
    }
    
    /// Validate all required variables
    fn validate_all() -> Result<(), EnvConfigError> {
        for name in self.required {
            let full_name = self.prefixed_name(name)
            let value = self.get(name).ok_or(EnvConfigError.Missing(full_name.clone()))?
            
            if let Some(validator) = self.validators.get(name) {
                if !validator(value.clone()) {
                    return Err(EnvConfigError.ValidationFailed(full_name, value))
                }
            }
        }
        Ok(())
    }
    
    /// Load into struct
    fn load<T: FromEnv>() -> Result<T, EnvConfigError> {
        self.validate_all()?
        T.from_env(self)
    }
}

// =============================================================================
// FromEnv Trait
// =============================================================================

/// Trait for loading configuration from environment
trait FromEnv {
    fn from_env(config: EnvConfig) -> Result<Self, EnvConfigError>
}

// =============================================================================
// Environment Profile
// =============================================================================

/// Environment profile (development, staging, production)
enum EnvProfile {
    Development
    Staging
    Production
    Custom(String)
}

impl EnvProfile {
    fn current() -> Self {
        match get("ENV").or_else(|| get("ENVIRONMENT")).or_else(|| get("APP_ENV")) {
            Some(e) => Self.from_string(e)
            None => EnvProfile.Development
        }
    }
    
    fn from_string(s: String) -> Self {
        match s.to_lower() {
            "dev" | "development" => EnvProfile.Development
            "staging" | "stage" => EnvProfile.Staging
            "prod" | "production" => EnvProfile.Production
            other => EnvProfile.Custom(other)
        }
    }
    
    fn is_development() -> Bool { match self { .Development => true, _ => false } }
    fn is_staging() -> Bool { match self { .Staging => true, _ => false } }
    fn is_production() -> Bool { match self { .Production => true, _ => false } }
    
    fn to_string() -> String {
        match self {
            .Development => "development"
            .Staging => "staging"
            .Production => "production"
            .Custom(s) => s
        }
    }
}

// =============================================================================
// Dotenv Support
// =============================================================================

/// Load .env file
fn load_dotenv(path: String) -> Result<(), EnvConfigError> {
    let content = fs.read_string(path).map_err(|e| EnvConfigError.IOError(e.to_string()))?
    parse_dotenv(content)
}

/// Load .env file if exists
fn load_dotenv_if_exists(path: String) -> Result<(), EnvConfigError> {
    if fs.exists(path) { load_dotenv(path) } else { Ok(()) }
}

/// Load default .env files based on profile
fn load_dotenv_for_profile() -> Result<(), EnvConfigError> {
    let profile = EnvProfile.current()
    
    // Load base .env
    load_dotenv_if_exists(".env")?
    
    // Load profile-specific .env
    let profile_file = format!(".env.{}", profile.to_string())
    load_dotenv_if_exists(profile_file)?
    
    // Load local overrides
    load_dotenv_if_exists(".env.local")?
    
    Ok(())
}

fn parse_dotenv(content: String) -> Result<(), EnvConfigError> {
    for line in content.lines() {
        let line = line.trim()
        
        // Skip empty lines and comments
        if line.is_empty() || line.starts_with("#") { continue }
        
        // Parse KEY=VALUE
        if let Some(eq_pos) = line.find("=") {
            let key = line[..eq_pos].trim()
            var value = line[eq_pos + 1..].trim()
            
            // Remove quotes
            if (value.starts_with("\"") && value.ends_with("\"")) ||
               (value.starts_with("'") && value.ends_with("'")) {
                value = value[1..value.len() - 1]
            }
            
            // Only set if not already defined (env vars take precedence)
            if !exists(key) {
                set(key, value)
            }
        }
    }
    Ok(())
}

// =============================================================================
// Environment Variable Watcher
// =============================================================================

/// Watch for environment variable changes
actor EnvWatcher {
    state watchers: Map<String, [fn(String, Option<String>)]>
    state values: Map<String, String>
    state poll_interval_ms: Int64
    state running: Bool
    
    fn new() -> Self {
        EnvWatcher {
            watchers: Map.empty(),
            values: Map.empty(),
            poll_interval_ms: 1000,
            running: false
        }
    }
    
    fn poll_interval(ms: Int64) -> Self {
        self.poll_interval_ms = ms
        self
    }
    
    fn watch(name: String, callback: fn(String, Option<String>)) -> Self {
        self.watchers.entry(name).or_insert([]).push(callback)
        if let Some(v) = get(name) {
            self.values.set(name, v)
        }
        self
    }
    
    fn start() {
        self.running = true
        spawn {
            while self.running {
                self.check_changes()
                sleep(Duration.millis(self.poll_interval_ms))
            }
        }
    }
    
    fn stop() {
        self.running = false
    }
    
    fn check_changes() {
        for (name, callbacks) in self.watchers {
            let current = get(name)
            let previous = self.values.get(name).cloned()
            
            if current != previous {
                for callback in callbacks {
                    callback(name.clone(), current.clone())
                }
                match current {
                    Some(v) => self.values.set(name, v)
                    None => self.values.remove(name)
                }
            }
        }
    }
}

// =============================================================================
// Common Validators
// =============================================================================

/// Common validators for environment variables
struct EnvValidators {}

impl EnvValidators {
    fn not_empty(value: String) -> Bool { !value.is_empty() }
    fn is_url(value: String) -> Bool { value.starts_with("http://") || value.starts_with("https://") }
    fn is_email(value: String) -> Bool { value.contains("@") && value.contains(".") }
    fn is_port(value: String) -> Bool { Int.parse(value).map(|p| p > 0 && p < 65536).unwrap_or(false) }
    fn is_positive_int(value: String) -> Bool { Int.parse(value).map(|n| n > 0).unwrap_or(false) }
    fn one_of(options: [String]) -> fn(String) -> Bool { |value| options.contains(value) }
    fn matches(pattern: String) -> fn(String) -> Bool { |value| regex.is_match(pattern, value) }
    fn min_length(min: Int) -> fn(String) -> Bool { |value| value.len() >= min }
    fn max_length(max: Int) -> fn(String) -> Bool { |value| value.len() <= max }
}

// =============================================================================
// Errors
// =============================================================================

enum EnvConfigError {
    Missing(String)
    ParseError(String, String)
    ValidationFailed(String, String)
    IOError(String)
}

impl Display for EnvConfigError {
    fn fmt(f: Formatter) {
        match self {
            .Missing(name) => f.write(format!("Missing required environment variable: {}", name))
            .ParseError(name, typ) => f.write(format!("Failed to parse {} as {}", name, typ))
            .ValidationFailed(name, value) => f.write(format!("Validation failed for {}: {}", name, value))
            .IOError(msg) => f.write(format!("I/O error: {}", msg))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "get and set" {
    set("TEST_VAR", "hello")
    assert_eq(get("TEST_VAR"), Some("hello"))?
    remove("TEST_VAR")
    assert_eq(get("TEST_VAR"), None)?
}

test "get_or default" {
    assert_eq(get_or("NONEXISTENT_VAR", "default"), "default")?
}

test "get_int" {
    set("TEST_INT", "42")
    assert_eq(get_int("TEST_INT")?, 42)?
    remove("TEST_INT")
}

test "get_bool" {
    set("TEST_BOOL", "true")
    assert_eq(get_bool("TEST_BOOL")?, true)?
    set("TEST_BOOL", "0")
    assert_eq(get_bool("TEST_BOOL")?, false)?
    remove("TEST_BOOL")
}

test "get_list" {
    set("TEST_LIST", "a, b, c")
    assert_eq(get_list("TEST_LIST")?, ["a", "b", "c"])?
    remove("TEST_LIST")
}

test "parse_bytes" {
    assert_eq(parse_bytes("1KB"), Some(1024))?
    assert_eq(parse_bytes("1MB"), Some(1024 * 1024))?
    assert_eq(parse_bytes("1GB"), Some(1024 * 1024 * 1024))?
}

test "env config with prefix" {
    set("APP_HOST", "localhost")
    set("APP_PORT", "8080")
    
    let config = EnvConfig.new()
        .with_prefix("APP")
        .require("HOST")
        .require("PORT")
        .default("TIMEOUT", "30")
    
    assert_eq(config.get("HOST"), Some("localhost"))?
    assert_eq(config.get("PORT"), Some("8080"))?
    assert_eq(config.get("TIMEOUT"), Some("30"))?
    
    remove("APP_HOST")
    remove("APP_PORT")
}

test "env profile" {
    set("ENV", "production")
    assert(EnvProfile.current().is_production())?
    remove("ENV")
}

test "validators" {
    assert(EnvValidators.is_url("https://example.com"))?
    assert(!EnvValidators.is_url("not-a-url"))?
    assert(EnvValidators.is_port("8080"))?
    assert(!EnvValidators.is_port("99999"))?
}
