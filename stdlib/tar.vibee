// =============================================================================
// Vibee OS â€” TAR Module
// TAR archive creation and extraction (POSIX.1-2001, GNU, UStar)
// =============================================================================

// =============================================================================
// Constants
// =============================================================================

const TAR_BLOCK_SIZE: Int = 512
const TAR_NAME_SIZE: Int = 100
const TAR_MAGIC: String = "ustar"
const TAR_VERSION: String = "00"

// File type flags
const REGTYPE: UInt8 = 0x30      // '0' - Regular file
const AREGTYPE: UInt8 = 0x00    // '\0' - Regular file (old)
const LNKTYPE: UInt8 = 0x31     // '1' - Hard link
const SYMTYPE: UInt8 = 0x32     // '2' - Symbolic link
const CHRTYPE: UInt8 = 0x33     // '3' - Character device
const BLKTYPE: UInt8 = 0x34     // '4' - Block device
const DIRTYPE: UInt8 = 0x35     // '5' - Directory
const FIFOTYPE: UInt8 = 0x36    // '6' - FIFO
const CONTTYPE: UInt8 = 0x37    // '7' - Contiguous file

// GNU extensions
const GNUTYPE_LONGNAME: UInt8 = 0x4c  // 'L' - Long name
const GNUTYPE_LONGLINK: UInt8 = 0x4b  // 'K' - Long link

// =============================================================================
// Enums
// =============================================================================

/// TAR format variants
enum TarFormat {
    V7          // Original Unix V7 format
    Ustar       // POSIX.1-1988 (UStar)
    Pax         // POSIX.1-2001 (PAX)
    Gnu         // GNU tar format
    OldGnu      // Old GNU format
}

impl TarFormat {
    fn magic() -> String {
        match self {
            V7 => ""
            Ustar | Pax => "ustar\x0000"
            Gnu | OldGnu => "ustar  \x00"
        }
    }
}

/// Entry type in TAR archive
enum EntryType {
    Regular
    HardLink
    SymLink
    CharDevice
    BlockDevice
    Directory
    Fifo
    Continuous
    GnuLongName
    GnuLongLink
    Unknown(UInt8)
}

impl EntryType {
    fn from_byte(b: UInt8) -> Self {
        match b {
            0x00 | 0x30 => Regular
            0x31 => HardLink
            0x32 => SymLink
            0x33 => CharDevice
            0x34 => BlockDevice
            0x35 => Directory
            0x36 => Fifo
            0x37 => Continuous
            0x4c => GnuLongName
            0x4b => GnuLongLink
            _ => Unknown(b)
        }
    }
    
    fn to_byte() -> UInt8 {
        match self {
            Regular => REGTYPE
            HardLink => LNKTYPE
            SymLink => SYMTYPE
            CharDevice => CHRTYPE
            BlockDevice => BLKTYPE
            Directory => DIRTYPE
            Fifo => FIFOTYPE
            Continuous => CONTTYPE
            GnuLongName => GNUTYPE_LONGNAME
            GnuLongLink => GNUTYPE_LONGLINK
            Unknown(b) => b
        }
    }
    
    fn is_file() -> Bool { match self { Regular | Continuous => true, _ => false } }
    fn is_dir() -> Bool { match self { Directory => true, _ => false } }
    fn is_link() -> Bool { match self { HardLink | SymLink => true, _ => false } }
}

/// Compression method for TAR archives
enum TarCompression {
    None        // .tar
    Gzip        // .tar.gz, .tgz
    Bzip2       // .tar.bz2
    Xz          // .tar.xz
    Zstd        // .tar.zst
    Lz4         // .tar.lz4
}

impl TarCompression {
    fn extension() -> String {
        match self {
            None => ".tar"
            Gzip => ".tar.gz"
            Bzip2 => ".tar.bz2"
            Xz => ".tar.xz"
            Zstd => ".tar.zst"
            Lz4 => ".tar.lz4"
        }
    }
    
    fn from_path(path: String) -> Self {
        if path.ends_with(".tar.gz") || path.ends_with(".tgz") { return Gzip }
        if path.ends_with(".tar.bz2") || path.ends_with(".tbz2") { return Bzip2 }
        if path.ends_with(".tar.xz") || path.ends_with(".txz") { return Xz }
        if path.ends_with(".tar.zst") { return Zstd }
        if path.ends_with(".tar.lz4") { return Lz4 }
        None
    }
}

// =============================================================================
// Structs
// =============================================================================

/// TAR header (512 bytes)
struct TarHeader {
    name: String            // 100 bytes - File name
    mode: Int               // 8 bytes - File mode (octal)
    uid: Int                // 8 bytes - Owner user ID
    gid: Int                // 8 bytes - Owner group ID
    size: Int64             // 12 bytes - File size
    mtime: Int64            // 12 bytes - Modification time
    checksum: Int           // 8 bytes - Header checksum
    typeflag: EntryType     // 1 byte - Entry type
    linkname: String        // 100 bytes - Link target name
    magic: String           // 6 bytes - "ustar\0"
    version: String         // 2 bytes - "00"
    uname: String           // 32 bytes - Owner user name
    gname: String           // 32 bytes - Owner group name
    devmajor: Int           // 8 bytes - Device major number
    devminor: Int           // 8 bytes - Device minor number
    prefix: String          // 155 bytes - Filename prefix
}

impl TarHeader {
    fn new() -> Self {
        TarHeader {
            name: ""
            mode: 0o644
            uid: 0
            gid: 0
            size: 0
            mtime: 0
            checksum: 0
            typeflag: EntryType.Regular
            linkname: ""
            magic: TAR_MAGIC
            version: TAR_VERSION
            uname: ""
            gname: ""
            devmajor: 0
            devminor: 0
            prefix: ""
        }
    }
    
    fn for_file(name: String, size: Int64) -> Self {
        let mut h = Self.new()
        h.name = name
        h.size = size
        h.typeflag = EntryType.Regular
        h.mode = 0o644
        h
    }
    
    fn for_dir(name: String) -> Self {
        let mut h = Self.new()
        h.name = if name.ends_with("/") { name } else { name + "/" }
        h.size = 0
        h.typeflag = EntryType.Directory
        h.mode = 0o755
        h
    }
    
    fn for_symlink(name: String, target: String) -> Self {
        let mut h = Self.new()
        h.name = name
        h.linkname = target
        h.size = 0
        h.typeflag = EntryType.SymLink
        h.mode = 0o777
        h
    }
    
    fn full_name() -> String {
        if self.prefix.is_empty() { self.name }
        else { self.prefix + "/" + self.name }
    }
    
    fn is_empty() -> Bool {
        self.name.is_empty() && self.size == 0
    }
    
    fn to_bytes() -> [UInt8] { @native("tar_header_to_bytes", self) }
    fn from_bytes(data: [UInt8]) -> Result<Self, TarError> { @native("tar_header_from_bytes", data) }
    
    fn compute_checksum() -> Int { @native("tar_compute_checksum", self) }
}

/// TAR archive entry
struct TarEntry {
    header: TarHeader
    data: [UInt8]
}

impl TarEntry {
    fn new(header: TarHeader, data: [UInt8]) -> Self {
        TarEntry { header: header, data: data }
    }
    
    fn from_file(name: String, data: [UInt8]) -> Self {
        let header = TarHeader.for_file(name, data.len() as Int64)
        TarEntry { header: header, data: data }
    }
    
    fn from_dir(name: String) -> Self {
        let header = TarHeader.for_dir(name)
        TarEntry { header: header, data: [] }
    }
    
    fn name() -> String { self.header.full_name() }
    fn size() -> Int64 { self.header.size }
    fn is_file() -> Bool { self.header.typeflag.is_file() }
    fn is_dir() -> Bool { self.header.typeflag.is_dir() }
    fn is_link() -> Bool { self.header.typeflag.is_link() }
    fn link_target() -> Option<String> {
        if self.is_link() { Some(self.header.linkname) } else { None }
    }
}

/// TAR archive reader
struct TarReader {
    inner: @native("TarReader")
    compression: TarCompression
}

impl TarReader {
    fn new(data: [UInt8]) -> Result<Self, TarError> {
        let compression = detect_compression(data)
        let decompressed = decompress_tar(data, compression)?
        Ok(TarReader { 
            inner: @native("tar_reader_new", decompressed)
            compression: compression
        })
    }
    
    fn open(path: String) -> Result<Self, TarError> {
        let data = @native("fs_read_bytes", path)?
        Self.new(data)
    }
    
    fn entries() -> Result<[TarEntry], TarError> { @native("tar_reader_entries", self.inner) }
    
    fn extract(dest: String) -> Result<Int, TarError> { @native("tar_reader_extract", self.inner, dest) }
    
    fn extract_file(name: String) -> Result<[UInt8], TarError> { @native("tar_reader_extract_file", self.inner, name) }
    
    fn list() -> Result<[String], TarError> {
        let entries = self.entries()?
        Ok(entries.map(|e| e.name()))
    }
    
    fn find(name: String) -> Result<Option<TarEntry>, TarError> {
        let entries = self.entries()?
        for e in entries {
            if e.name() == name { return Ok(Some(e)) }
        }
        Ok(None)
    }
}

impl Iterator for TarReader {
    type Item = Result<TarEntry, TarError>
    fn next() -> Option<Self.Item> { @native("tar_reader_next", self.inner) }
}

/// TAR archive writer/builder
struct TarBuilder {
    entries: [TarEntry]
    compression: TarCompression
    format: TarFormat
}

impl TarBuilder {
    fn new() -> Self {
        TarBuilder { 
            entries: []
            compression: TarCompression.None
            format: TarFormat.Ustar
        }
    }
    
    fn with_compression(compression: TarCompression) -> Self {
        self.compression = compression
        self
    }
    
    fn with_format(format: TarFormat) -> Self {
        self.format = format
        self
    }
    
    fn add_file(name: String, data: [UInt8]) -> Self {
        self.entries.push(TarEntry.from_file(name, data))
        self
    }
    
    fn add_file_with_mode(name: String, data: [UInt8], mode: Int) -> Self {
        let mut entry = TarEntry.from_file(name, data)
        entry.header.mode = mode
        self.entries.push(entry)
        self
    }
    
    fn add_dir(name: String) -> Self {
        self.entries.push(TarEntry.from_dir(name))
        self
    }
    
    fn add_symlink(name: String, target: String) -> Self {
        let header = TarHeader.for_symlink(name, target)
        self.entries.push(TarEntry.new(header, []))
        self
    }
    
    fn add_entry(entry: TarEntry) -> Self {
        self.entries.push(entry)
        self
    }
    
    fn add_path(path: String) -> Result<Self, TarError> {
        @native("tar_builder_add_path", self, path)
    }
    
    fn add_dir_recursive(path: String) -> Result<Self, TarError> {
        @native("tar_builder_add_dir_recursive", self, path)
    }
    
    fn build() -> Result<[UInt8], TarError> {
        let raw = @native("tar_builder_build", self.entries, self.format)?
        compress_tar(raw, self.compression)
    }
    
    fn write(path: String) -> Result<(), TarError> {
        let data = self.build()?
        @native("fs_write_bytes", path, data)
    }
}

/// Streaming TAR writer
struct TarWriter {
    inner: @native("TarWriter")
    compression: TarCompression
}

impl TarWriter {
    fn new() -> Self {
        TarWriter { 
            inner: @native("tar_writer_new")
            compression: TarCompression.None
        }
    }
    
    fn create(path: String) -> Result<Self, TarError> {
        let compression = TarCompression.from_path(path)
        Ok(TarWriter { 
            inner: @native("tar_writer_create", path)?
            compression: compression
        })
    }
    
    fn with_compression(compression: TarCompression) -> Self {
        self.compression = compression
        self
    }
    
    fn write_header(header: TarHeader) -> Result<(), TarError> {
        @native("tar_writer_write_header", self.inner, header)
    }
    
    fn write_data(data: [UInt8]) -> Result<(), TarError> {
        @native("tar_writer_write_data", self.inner, data)
    }
    
    fn write_entry(entry: TarEntry) -> Result<(), TarError> {
        self.write_header(entry.header)?
        self.write_data(entry.data)
    }
    
    fn finish() -> Result<[UInt8], TarError> {
        let raw = @native("tar_writer_finish", self.inner)?
        compress_tar(raw, self.compression)
    }
}

impl Drop for TarWriter {
    fn drop() { @native("tar_writer_close", self.inner) }
}

// =============================================================================
// Actor for async operations
// =============================================================================

actor TarActor {
    fn extract_async(data: [UInt8], dest: String) -> Result<Int, TarError> {
        let reader = TarReader.new(data)?
        reader.extract(dest)
    }
    
    fn create_async(entries: [TarEntry], compression: TarCompression) -> Result<[UInt8], TarError> {
        let mut builder = TarBuilder.new().with_compression(compression)
        for e in entries {
            builder = builder.add_entry(e)
        }
        builder.build()
    }
    
    fn list_async(data: [UInt8]) -> Result<[String], TarError> {
        let reader = TarReader.new(data)?
        reader.list()
    }
}

// =============================================================================
// Trait implementations
// =============================================================================

trait Archive {
    fn list() -> Result<[String], TarError>
    fn extract(dest: String) -> Result<Int, TarError>
    fn extract_file(name: String) -> Result<[UInt8], TarError>
}

impl Archive for TarReader {
    fn list() -> Result<[String], TarError> { self.list() }
    fn extract(dest: String) -> Result<Int, TarError> { self.extract(dest) }
    fn extract_file(name: String) -> Result<[UInt8], TarError> { self.extract_file(name) }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn detect_compression(data: [UInt8]) -> TarCompression {
    if data.len() < 4 { return TarCompression.None }
    
    // Gzip magic: 1f 8b
    if data[0] == 0x1f && data[1] == 0x8b { return TarCompression.Gzip }
    
    // Bzip2 magic: 42 5a 68 ('BZh')
    if data[0] == 0x42 && data[1] == 0x5a && data[2] == 0x68 { return TarCompression.Bzip2 }
    
    // XZ magic: fd 37 7a 58 5a 00
    if data.len() >= 6 && data[0] == 0xfd && data[1] == 0x37 && data[2] == 0x7a && 
       data[3] == 0x58 && data[4] == 0x5a && data[5] == 0x00 { return TarCompression.Xz }
    
    // Zstd magic: 28 b5 2f fd
    if data[0] == 0x28 && data[1] == 0xb5 && data[2] == 0x2f && data[3] == 0xfd { return TarCompression.Zstd }
    
    // LZ4 magic: 04 22 4d 18
    if data[0] == 0x04 && data[1] == 0x22 && data[2] == 0x4d && data[3] == 0x18 { return TarCompression.Lz4 }
    
    TarCompression.None
}

fn decompress_tar(data: [UInt8], compression: TarCompression) -> Result<[UInt8], TarError> {
    match compression {
        None => Ok(data)
        Gzip => @native("gzip_decompress", data).map_err(|e| TarError.DecompressError(e.to_string()))
        Bzip2 => @native("bzip2_decompress", data).map_err(|e| TarError.DecompressError(e.to_string()))
        Xz => @native("xz_decompress", data).map_err(|e| TarError.DecompressError(e.to_string()))
        Zstd => @native("zstd_decompress", data).map_err(|e| TarError.DecompressError(e.to_string()))
        Lz4 => @native("lz4_decompress", data).map_err(|e| TarError.DecompressError(e.to_string()))
    }
}

fn compress_tar(data: [UInt8], compression: TarCompression) -> Result<[UInt8], TarError> {
    match compression {
        None => Ok(data)
        Gzip => @native("gzip_compress", data).map_err(|e| TarError.CompressError(e.to_string()))
        Bzip2 => @native("bzip2_compress", data).map_err(|e| TarError.CompressError(e.to_string()))
        Xz => @native("xz_compress", data).map_err(|e| TarError.CompressError(e.to_string()))
        Zstd => @native("zstd_compress", data).map_err(|e| TarError.CompressError(e.to_string()))
        Lz4 => @native("lz4_compress", data).map_err(|e| TarError.CompressError(e.to_string()))
    }
}

// =============================================================================
// Public API Functions
// =============================================================================

/// Create a TAR archive from files
fn create(files: [(String, [UInt8])]) -> Result<[UInt8], TarError> {
    let mut builder = TarBuilder.new()
    for (name, data) in files {
        builder = builder.add_file(name, data)
    }
    builder.build()
}

/// Create a compressed TAR archive
fn create_compressed(files: [(String, [UInt8])], compression: TarCompression) -> Result<[UInt8], TarError> {
    let mut builder = TarBuilder.new().with_compression(compression)
    for (name, data) in files {
        builder = builder.add_file(name, data)
    }
    builder.build()
}

/// Create a .tar.gz archive
fn create_gzip(files: [(String, [UInt8])]) -> Result<[UInt8], TarError> {
    create_compressed(files, TarCompression.Gzip)
}

/// Extract TAR archive to directory
fn extract(data: [UInt8], dest: String) -> Result<Int, TarError> {
    let reader = TarReader.new(data)?
    reader.extract(dest)
}

/// Extract TAR archive from file
fn extract_file(path: String, dest: String) -> Result<Int, TarError> {
    let reader = TarReader.open(path)?
    reader.extract(dest)
}

/// List files in TAR archive
fn list(data: [UInt8]) -> Result<[String], TarError> {
    let reader = TarReader.new(data)?
    reader.list()
}

/// Get a single file from TAR archive
fn get_file(data: [UInt8], name: String) -> Result<[UInt8], TarError> {
    let reader = TarReader.new(data)?
    reader.extract_file(name)
}

/// Archive a directory
fn archive_dir(path: String) -> Result<[UInt8], TarError> {
    TarBuilder.new().add_dir_recursive(path)?.build()
}

/// Archive a directory with compression
fn archive_dir_compressed(path: String, compression: TarCompression) -> Result<[UInt8], TarError> {
    TarBuilder.new()
        .with_compression(compression)
        .add_dir_recursive(path)?
        .build()
}

// =============================================================================
// Error Type
// =============================================================================

enum TarError {
    InvalidHeader
    InvalidChecksum
    InvalidFormat
    UnexpectedEof
    FileNotFound(String)
    IoError(String)
    CompressError(String)
    DecompressError(String)
    PathTooLong(String)
    UnsupportedFormat(String)
    Other(String)
}

impl Display for TarError {
    fn fmt(f: Formatter) {
        match self {
            InvalidHeader => f.write("Invalid TAR header")
            InvalidChecksum => f.write("Invalid header checksum")
            InvalidFormat => f.write("Invalid TAR format")
            UnexpectedEof => f.write("Unexpected end of file")
            FileNotFound(name) => f.write("File not found: " + name)
            IoError(msg) => f.write("I/O error: " + msg)
            CompressError(msg) => f.write("Compression error: " + msg)
            DecompressError(msg) => f.write("Decompression error: " + msg)
            PathTooLong(path) => f.write("Path too long: " + path)
            UnsupportedFormat(fmt) => f.write("Unsupported format: " + fmt)
            Other(msg) => f.write(msg)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create and extract tar" {
    let files = [
        ("file1.txt", "Hello, World!".as_bytes()),
        ("file2.txt", "Vibee Lang!".as_bytes())
    ]
    let tar_data = create(files)?
    
    let reader = TarReader.new(tar_data)?
    let entries = reader.entries()?
    assert_eq(entries.len(), 2)?
    assert_eq(entries[0].name(), "file1.txt")?
}

test "create gzip tar" {
    let files = [("test.txt", "Test content".as_bytes())]
    let tar_gz = create_gzip(files)?
    
    // Should start with gzip magic
    assert_eq(tar_gz[0], 0x1f)?
    assert_eq(tar_gz[1], 0x8b)?
}

test "tar builder" {
    let tar_data = TarBuilder.new()
        .add_file("hello.txt", "Hello".as_bytes())
        .add_dir("subdir/")
        .add_file("subdir/world.txt", "World".as_bytes())
        .build()?
    
    let names = list(tar_data)?
    assert_eq(names.len(), 3)?
}

test "entry types" {
    assert(EntryType.Regular.is_file())?
    assert(EntryType.Directory.is_dir())?
    assert(EntryType.SymLink.is_link())?
    assert(!EntryType.Regular.is_dir())?
}

test "compression detection" {
    let gzip_data = [0x1f, 0x8b, 0x08, 0x00]
    assert_eq(detect_compression(gzip_data), TarCompression.Gzip)?
    
    let plain_data = [0x75, 0x73, 0x74, 0x61]  // "usta"
    assert_eq(detect_compression(plain_data), TarCompression.None)?
}

test "tar header" {
    let header = TarHeader.for_file("test.txt", 100)
    assert_eq(header.name, "test.txt")?
    assert_eq(header.size, 100)?
    assert(header.typeflag.is_file())?
}
