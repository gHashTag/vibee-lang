// =============================================================================
// Vibee OS â€” Save System Module
// Game save/load with versioning, encryption, and cloud sync
// =============================================================================

use fs::{File, Path}
use crypto::{encrypt, decrypt, hash_sha256}
use compress::{compress, decompress}
use datetime::DateTime

// -----------------------------------------------------------------------------
// Save Data Trait
// -----------------------------------------------------------------------------

/// Trait for serializable save data
trait Saveable {
    fn serialize() -> [UInt8]
    fn deserialize(data: [UInt8]) -> Result<Self, String>
    fn version() -> Int { 1 }
}

// -----------------------------------------------------------------------------
// Save Slot
// -----------------------------------------------------------------------------

/// Represents a save slot
struct SaveSlot {
    id: Int
    name: String
    created_at: DateTime
    updated_at: DateTime
    play_time: Float64
    thumbnail: Option<[UInt8]>
    metadata: Map<String, String>
    checksum: String
    version: Int
    
    fn new(id: Int, name: String) -> Self {
        let now = DateTime.now()
        SaveSlot {
            id: id,
            name: name,
            created_at: now,
            updated_at: now,
            play_time: 0.0,
            thumbnail: None,
            metadata: Map.new(),
            checksum: "",
            version: 1
        }
    }
    
    fn with_thumbnail(data: [UInt8]) -> Self {
        self.thumbnail = Some(data)
        self
    }
    
    fn set_metadata(key: String, value: String) -> Self {
        self.metadata.insert(key, value)
        self
    }
    
    fn get_metadata(key: String) -> Option<&String> {
        self.metadata.get(key)
    }
    
    fn formatted_play_time() -> String {
        let hours = (self.play_time / 3600.0) as Int
        let minutes = ((self.play_time % 3600.0) / 60.0) as Int
        let seconds = (self.play_time % 60.0) as Int
        format!("{}:{:02}:{:02}", hours, minutes, seconds)
    }
}

// -----------------------------------------------------------------------------
// Save Header
// -----------------------------------------------------------------------------

/// Header for save files
struct SaveHeader {
    magic: [UInt8; 4]
    version: Int
    flags: SaveFlags
    timestamp: Int64
    checksum: [UInt8; 32]
    data_size: Int
    compressed_size: Int
    
    fn new(version: Int) -> Self {
        SaveHeader {
            magic: [0x56, 0x42, 0x53, 0x56], // "VBSV" - Vibee Save
            version: version,
            flags: SaveFlags.new(),
            timestamp: DateTime.now().timestamp(),
            checksum: [0; 32],
            data_size: 0,
            compressed_size: 0
        }
    }
    
    fn is_valid() -> Bool {
        self.magic == [0x56, 0x42, 0x53, 0x56]
    }
    
    fn to_bytes() -> [UInt8] {
        var bytes = []
        bytes.extend(self.magic)
        bytes.extend(self.version.to_le_bytes())
        bytes.extend(self.flags.to_bytes())
        bytes.extend(self.timestamp.to_le_bytes())
        bytes.extend(self.checksum)
        bytes.extend(self.data_size.to_le_bytes())
        bytes.extend(self.compressed_size.to_le_bytes())
        bytes
    }
    
    fn from_bytes(data: &[UInt8]) -> Result<Self, String> {
        if data.len() < 64 { return Err("Invalid header size") }
        
        var header = SaveHeader.new(0)
        header.magic = [data[0], data[1], data[2], data[3]]
        header.version = Int.from_le_bytes(&data[4..8])
        header.flags = SaveFlags.from_bytes(&data[8..12])
        header.timestamp = Int64.from_le_bytes(&data[12..20])
        header.checksum.copy_from_slice(&data[20..52])
        header.data_size = Int.from_le_bytes(&data[52..56])
        header.compressed_size = Int.from_le_bytes(&data[56..60])
        
        if !header.is_valid() {
            return Err("Invalid save file magic")
        }
        
        Ok(header)
    }
}

struct SaveFlags {
    compressed: Bool
    encrypted: Bool
    cloud_synced: Bool
    auto_save: Bool
    
    fn new() -> Self {
        SaveFlags {
            compressed: true,
            encrypted: false,
            cloud_synced: false,
            auto_save: false
        }
    }
    
    fn to_bytes() -> [UInt8] {
        var flags: UInt32 = 0
        if self.compressed { flags |= 1 }
        if self.encrypted { flags |= 2 }
        if self.cloud_synced { flags |= 4 }
        if self.auto_save { flags |= 8 }
        flags.to_le_bytes().to_vec()
    }
    
    fn from_bytes(data: &[UInt8]) -> Self {
        let flags = UInt32.from_le_bytes(data)
        SaveFlags {
            compressed: (flags & 1) != 0,
            encrypted: (flags & 2) != 0,
            cloud_synced: (flags & 4) != 0,
            auto_save: (flags & 8) != 0
        }
    }
}

// -----------------------------------------------------------------------------
// Save Manager
// -----------------------------------------------------------------------------

/// Main save system manager
struct SaveManager {
    save_dir: String
    max_slots: Int
    auto_save_interval: Float64
    auto_save_timer: Float64
    encryption_key: Option<[UInt8; 32]>
    compress_saves: Bool
    backup_count: Int
    slots: Map<Int, SaveSlot>
    on_save: Option<fn(Int)>
    on_load: Option<fn(Int)>
    on_error: Option<fn(String)>
    
    fn new() -> Self {
        SaveManager {
            save_dir: "saves/",
            max_slots: 10,
            auto_save_interval: 300.0, // 5 minutes
            auto_save_timer: 0.0,
            encryption_key: None,
            compress_saves: true,
            backup_count: 3,
            slots: Map.new(),
            on_save: None,
            on_load: None,
            on_error: None
        }
    }
    
    fn with_save_dir(dir: String) -> Self { self.save_dir = dir; self }
    fn with_max_slots(count: Int) -> Self { self.max_slots = count; self }
    fn with_auto_save(interval: Float64) -> Self { self.auto_save_interval = interval; self }
    fn with_encryption(key: [UInt8; 32]) -> Self { self.encryption_key = Some(key); self }
    fn with_compression(enabled: Bool) -> Self { self.compress_saves = enabled; self }
    fn with_backup_count(count: Int) -> Self { self.backup_count = count; self }
    
    fn on_save(callback: fn(Int)) -> Self { self.on_save = Some(callback); self }
    fn on_load(callback: fn(Int)) -> Self { self.on_load = Some(callback); self }
    fn on_error(callback: fn(String)) -> Self { self.on_error = Some(callback); self }
    
    /// Initialize save system
    fn init() -> Result<(), String> {
        // Create save directory if it doesn't exist
        if !Path.exists(self.save_dir.clone()) {
            File.create_dir_all(self.save_dir.clone())?
        }
        
        // Load existing slot metadata
        self.scan_slots()?
        
        Ok(())
    }
    
    /// Scan for existing save slots
    fn scan_slots() -> Result<(), String> {
        self.slots.clear()
        
        for i in 0..self.max_slots {
            let path = self.slot_path(i)
            if Path.exists(path.clone()) {
                if let Ok(slot) = self.load_slot_metadata(i) {
                    self.slots.insert(i, slot)
                }
            }
        }
        
        Ok(())
    }
    
    fn slot_path(slot_id: Int) -> String {
        format!("{}slot_{}.sav", self.save_dir, slot_id)
    }
    
    fn backup_path(slot_id: Int, backup_num: Int) -> String {
        format!("{}slot_{}.backup{}.sav", self.save_dir, slot_id, backup_num)
    }
    
    // -------------------------------------------------------------------------
    // Save Operations
    // -------------------------------------------------------------------------
    
    /// Save data to slot
    fn save<T: Saveable>(slot_id: Int, data: &T) -> Result<(), String> {
        self.save_with_name(slot_id, format!("Save {}", slot_id), data)
    }
    
    /// Save with custom name
    fn save_with_name<T: Saveable>(slot_id: Int, name: String, data: &T) -> Result<(), String> {
        if slot_id < 0 || slot_id >= self.max_slots {
            return Err("Invalid slot ID")
        }
        
        // Create backup of existing save
        self.create_backup(slot_id)?
        
        // Serialize data
        var bytes = data.serialize()
        let original_size = bytes.len()
        
        // Compress if enabled
        var flags = SaveFlags.new()
        flags.compressed = self.compress_saves
        
        if self.compress_saves {
            bytes = compress(bytes)?
        }
        
        // Encrypt if key is set
        if let Some(key) = &self.encryption_key {
            bytes = encrypt(bytes, key)?
            flags.encrypted = true
        }
        
        // Calculate checksum
        let checksum = hash_sha256(&bytes)
        
        // Create header
        var header = SaveHeader.new(T::version())
        header.flags = flags
        header.data_size = original_size
        header.compressed_size = bytes.len()
        header.checksum.copy_from_slice(&checksum)
        
        // Write file
        let path = self.slot_path(slot_id)
        var file = File.create(path)?
        file.write_all(header.to_bytes())?
        file.write_all(bytes)?
        
        // Update slot metadata
        var slot = if let Some(existing) = self.slots.get(slot_id) {
            var s = existing.clone()
            s.updated_at = DateTime.now()
            s.name = name
            s
        } else {
            SaveSlot.new(slot_id, name)
        }
        slot.checksum = hex::encode(&checksum)
        slot.version = T::version()
        self.slots.insert(slot_id, slot)
        
        if let Some(callback) = &self.on_save {
            callback(slot_id)
        }
        
        Ok(())
    }
    
    /// Load data from slot
    fn load<T: Saveable>(slot_id: Int) -> Result<T, String> {
        if slot_id < 0 || slot_id >= self.max_slots {
            return Err("Invalid slot ID")
        }
        
        let path = self.slot_path(slot_id)
        if !Path.exists(path.clone()) {
            return Err("Save slot does not exist")
        }
        
        // Read file
        let file_data = File.read_bytes(path)?
        
        // Parse header
        let header = SaveHeader.from_bytes(&file_data)?
        
        // Extract data
        var bytes = file_data[64..].to_vec()
        
        // Verify checksum
        let checksum = hash_sha256(&bytes)
        if checksum != header.checksum {
            return Err("Save file corrupted - checksum mismatch")
        }
        
        // Decrypt if needed
        if header.flags.encrypted {
            if let Some(key) = &self.encryption_key {
                bytes = decrypt(bytes, key)?
            } else {
                return Err("Save is encrypted but no key provided")
            }
        }
        
        // Decompress if needed
        if header.flags.compressed {
            bytes = decompress(bytes)?
        }
        
        // Handle version migration
        let data = if header.version != T::version() {
            self.migrate_data::<T>(bytes, header.version)?
        } else {
            T::deserialize(bytes)?
        }
        
        if let Some(callback) = &self.on_load {
            callback(slot_id)
        }
        
        Ok(data)
    }
    
    /// Delete save slot
    fn delete(slot_id: Int) -> Result<(), String> {
        let path = self.slot_path(slot_id)
        if Path.exists(path.clone()) {
            File.remove(path)?
        }
        
        // Delete backups
        for i in 0..self.backup_count {
            let backup = self.backup_path(slot_id, i)
            if Path.exists(backup.clone()) {
                File.remove(backup)?
            }
        }
        
        self.slots.remove(slot_id)
        Ok(())
    }
    
    // -------------------------------------------------------------------------
    // Backup System
    // -------------------------------------------------------------------------
    
    fn create_backup(slot_id: Int) -> Result<(), String> {
        let path = self.slot_path(slot_id)
        if !Path.exists(path.clone()) { return Ok(()) }
        
        // Rotate backups
        for i in (1..self.backup_count).rev() {
            let from = self.backup_path(slot_id, i - 1)
            let to = self.backup_path(slot_id, i)
            if Path.exists(from.clone()) {
                File.rename(from, to)?
            }
        }
        
        // Create new backup
        let backup = self.backup_path(slot_id, 0)
        File.copy(path, backup)?
        
        Ok(())
    }
    
    /// Restore from backup
    fn restore_backup(slot_id: Int, backup_num: Int) -> Result<(), String> {
        let backup = self.backup_path(slot_id, backup_num)
        if !Path.exists(backup.clone()) {
            return Err("Backup does not exist")
        }
        
        let path = self.slot_path(slot_id)
        File.copy(backup, path)?
        
        self.scan_slots()?
        Ok(())
    }
    
    /// List available backups
    fn list_backups(slot_id: Int) -> [Int] {
        var backups = []
        for i in 0..self.backup_count {
            let path = self.backup_path(slot_id, i)
            if Path.exists(path) {
                backups.push(i)
            }
        }
        backups
    }
    
    // -------------------------------------------------------------------------
    // Auto Save
    // -------------------------------------------------------------------------
    
    /// Update auto-save timer
    fn update(dt: Float64) {
        self.auto_save_timer += dt
    }
    
    /// Check if auto-save should trigger
    fn should_auto_save() -> Bool {
        self.auto_save_timer >= self.auto_save_interval
    }
    
    /// Reset auto-save timer
    fn reset_auto_save_timer() {
        self.auto_save_timer = 0.0
    }
    
    /// Perform auto-save
    fn auto_save<T: Saveable>(data: &T) -> Result<(), String> {
        if !self.should_auto_save() { return Ok(()) }
        
        // Find or create auto-save slot (usually slot 0)
        let slot_id = 0
        var slot = SaveSlot.new(slot_id, "Auto Save")
        slot.metadata.insert("auto_save", "true")
        
        self.save_with_name(slot_id, "Auto Save", data)?
        self.reset_auto_save_timer()
        
        Ok(())
    }
    
    // -------------------------------------------------------------------------
    // Slot Management
    // -------------------------------------------------------------------------
    
    /// Get slot info
    fn get_slot(slot_id: Int) -> Option<&SaveSlot> {
        self.slots.get(slot_id)
    }
    
    /// Get all slots
    fn get_all_slots() -> [&SaveSlot] {
        self.slots.values().collect()
    }
    
    /// Check if slot exists
    fn slot_exists(slot_id: Int) -> Bool {
        self.slots.contains_key(slot_id)
    }
    
    /// Find first empty slot
    fn find_empty_slot() -> Option<Int> {
        for i in 0..self.max_slots {
            if !self.slots.contains_key(i) {
                return Some(i)
            }
        }
        None
    }
    
    /// Load slot metadata only
    fn load_slot_metadata(slot_id: Int) -> Result<SaveSlot, String> {
        let path = self.slot_path(slot_id)
        let file_data = File.read_bytes(path)?
        let header = SaveHeader.from_bytes(&file_data)?
        
        var slot = SaveSlot.new(slot_id, format!("Save {}", slot_id))
        slot.updated_at = DateTime.from_timestamp(header.timestamp)
        slot.version = header.version
        slot.checksum = hex::encode(&header.checksum)
        
        Ok(slot)
    }
    
    // -------------------------------------------------------------------------
    // Version Migration
    // -------------------------------------------------------------------------
    
    fn migrate_data<T: Saveable>(data: [UInt8], from_version: Int) -> Result<T, String> {
        // Default migration - just try to deserialize
        // Games should override this for proper migration
        T::deserialize(data)
    }
}

// -----------------------------------------------------------------------------
// Quick Save/Load
// -----------------------------------------------------------------------------

/// Quick save to default slot
struct QuickSave {
    slot_id: Int
    
    fn new() -> Self { QuickSave { slot_id: 99 } }
    fn with_slot(id: Int) -> Self { QuickSave { slot_id: id } }
    
    fn save<T: Saveable>(manager: &mut SaveManager, data: &T) -> Result<(), String> {
        manager.save_with_name(self.slot_id, "Quick Save", data)
    }
    
    fn load<T: Saveable>(manager: &SaveManager) -> Result<T, String> {
        manager.load(self.slot_id)
    }
    
    fn exists(manager: &SaveManager) -> Bool {
        manager.slot_exists(self.slot_id)
    }
}

// -----------------------------------------------------------------------------
// Cloud Save
// -----------------------------------------------------------------------------

/// Cloud save synchronization
actor CloudSaveSync {
    local_manager: &mut SaveManager
    cloud_url: String
    auth_token: String
    sync_in_progress: Bool
    last_sync: Option<DateTime>
    
    fn new(manager: &mut SaveManager, url: String, token: String) -> Self {
        CloudSaveSync {
            local_manager: manager,
            cloud_url: url,
            auth_token: token,
            sync_in_progress: false,
            last_sync: None
        }
    }
    
    async fn sync_all() -> Result<(), String> {
        if self.sync_in_progress { return Err("Sync already in progress") }
        self.sync_in_progress = true
        
        for slot_id in 0..self.local_manager.max_slots {
            self.sync_slot(slot_id).await?
        }
        
        self.last_sync = Some(DateTime.now())
        self.sync_in_progress = false
        Ok(())
    }
    
    async fn sync_slot(slot_id: Int) -> Result<(), String> {
        let local_slot = self.local_manager.get_slot(slot_id)
        let cloud_slot = self.fetch_cloud_slot(slot_id).await?
        
        match (local_slot, cloud_slot) {
            (Some(local), Some(cloud)) => {
                if local.updated_at > cloud.updated_at {
                    self.upload_slot(slot_id).await?
                } else if cloud.updated_at > local.updated_at {
                    self.download_slot(slot_id).await?
                }
            },
            (Some(_), None) => self.upload_slot(slot_id).await?,
            (None, Some(_)) => self.download_slot(slot_id).await?,
            (None, None) => {}
        }
        
        Ok(())
    }
    
    async fn upload_slot(slot_id: Int) -> Result<(), String> {
        let path = self.local_manager.slot_path(slot_id)
        let data = File.read_bytes(path)?
        
        let url = format!("{}/saves/{}", self.cloud_url, slot_id)
        @native("http_put", url, data, self.auth_token).await
    }
    
    async fn download_slot(slot_id: Int) -> Result<(), String> {
        let url = format!("{}/saves/{}", self.cloud_url, slot_id)
        let data = @native("http_get", url, self.auth_token).await?
        
        let path = self.local_manager.slot_path(slot_id)
        File.write_bytes(path, data)?
        
        self.local_manager.scan_slots()
    }
    
    async fn fetch_cloud_slot(slot_id: Int) -> Result<Option<SaveSlot>, String> {
        let url = format!("{}/saves/{}/metadata", self.cloud_url, slot_id)
        let response = @native("http_get", url, self.auth_token).await
        
        match response {
            Ok(data) => {
                let json: JsonValue = json::parse(String.from_utf8(data)?)?
                // Parse slot from JSON
                Ok(Some(SaveSlot.new(slot_id, json.get("name").as_string().unwrap_or("Cloud Save"))))
            },
            Err(_) => Ok(None)
        }
    }
}

// -----------------------------------------------------------------------------
// Save Data Helpers
// -----------------------------------------------------------------------------

/// Helper macro for implementing Saveable
macro impl_saveable($type:ty) {
    impl Saveable for $type {
        fn serialize() -> [UInt8] {
            json::to_bytes(self)
        }
        
        fn deserialize(data: [UInt8]) -> Result<Self, String> {
            json::from_bytes(data)
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "save slot creation" {
    let slot = SaveSlot.new(0, "Test Save")
    assert_eq(slot.id, 0)?
    assert_eq(slot.name, "Test Save")?
}

test "save header" {
    let header = SaveHeader.new(1)
    assert(header.is_valid())?
    
    let bytes = header.to_bytes()
    let parsed = SaveHeader.from_bytes(&bytes)?
    assert_eq(parsed.version, 1)?
}

test "save flags" {
    var flags = SaveFlags.new()
    flags.compressed = true
    flags.encrypted = true
    
    let bytes = flags.to_bytes()
    let parsed = SaveFlags.from_bytes(&bytes)
    
    assert(parsed.compressed)?
    assert(parsed.encrypted)?
}

test "play time formatting" {
    var slot = SaveSlot.new(0, "Test")
    slot.play_time = 3661.0 // 1 hour, 1 minute, 1 second
    assert_eq(slot.formatted_play_time(), "1:01:01")?
}

test "quick save" {
    let qs = QuickSave.new()
    assert_eq(qs.slot_id, 99)?
    
    let qs2 = QuickSave.with_slot(5)
    assert_eq(qs2.slot_id, 5)?
}
