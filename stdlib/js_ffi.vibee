// =============================================================================
// Vibee OS â€” JavaScript FFI Module
// JavaScript Foreign Function Interface for JS runtime interoperability
// =============================================================================

// =============================================================================
// JavaScript Runtime
// =============================================================================

/// JavaScript runtime (V8, SpiderMonkey, QuickJS, etc.)
struct JsRuntime {
    handle: *()
    engine: JsEngine
}

enum JsEngine { V8, SpiderMonkey, QuickJS, JavaScriptCore }

impl JsRuntime {
    /// Create new JS runtime
    fn new() -> Result<Self, JsError> {
        Self.with_engine(JsEngine.V8)
    }
    
    /// Create with specific engine
    fn with_engine(engine: JsEngine) -> Result<Self, JsError> {
        let handle = @native("js_runtime_new", engine)
        if handle.is_null() { return Err(JsError.RuntimeCreationFailed) }
        Ok(JsRuntime { handle: handle, engine: engine })
    }
    
    /// Create new context
    fn create_context() -> Result<JsContext, JsError> {
        let ctx = @native("js_context_new", self.handle)
        if ctx.is_null() { return Err(JsError.ContextCreationFailed) }
        Ok(JsContext { handle: ctx, runtime: self })
    }
    
    /// Get engine type
    fn engine() -> JsEngine { self.engine }
    
    /// Run garbage collection
    fn gc() { @native("js_runtime_gc", self.handle) }
    
    /// Get memory usage
    fn memory_usage() -> JsMemoryUsage {
        @native("js_runtime_memory_usage", self.handle)
    }
}

impl Drop for JsRuntime {
    fn drop() { if !self.handle.is_null() { @native("js_runtime_delete", self.handle) } }
}

struct JsMemoryUsage {
    heap_size: Int64
    heap_used: Int64
    external: Int64
}

// =============================================================================
// JavaScript Context
// =============================================================================

/// JavaScript execution context
struct JsContext {
    handle: *()
    runtime: JsRuntime
}

impl JsContext {
    /// Evaluate JavaScript code
    fn eval(code: String) -> Result<JsValue, JsError> {
        self.eval_with_filename(code, "<eval>")
    }
    
    /// Evaluate with filename for stack traces
    fn eval_with_filename(code: String, filename: String) -> Result<JsValue, JsError> {
        let result = @native("js_eval", self.handle, code, filename)
        if @native("js_is_exception", result) {
            let exc = @native("js_get_exception", self.handle)
            return Err(JsError.Exception(JsValue { handle: exc, ctx: self }))
        }
        Ok(JsValue { handle: result, ctx: self })
    }
    
    /// Evaluate module
    fn eval_module(code: String, module_name: String) -> Result<JsValue, JsError> {
        let result = @native("js_eval_module", self.handle, code, module_name)
        if @native("js_is_exception", result) {
            return Err(JsError.Exception(JsValue { handle: @native("js_get_exception", self.handle), ctx: self }))
        }
        Ok(JsValue { handle: result, ctx: self })
    }
    
    /// Get global object
    fn global() -> JsObject {
        JsObject { handle: @native("js_get_global", self.handle), ctx: self }
    }
    
    /// Create undefined value
    fn undefined() -> JsValue { JsValue { handle: @native("js_undefined", self.handle), ctx: self } }
    
    /// Create null value
    fn null() -> JsValue { JsValue { handle: @native("js_null", self.handle), ctx: self } }
    
    /// Create values
    fn boolean(v: Bool) -> JsValue { JsValue { handle: @native("js_boolean", self.handle, v), ctx: self } }
    fn number(v: Float64) -> JsValue { JsValue { handle: @native("js_number", self.handle, v), ctx: self } }
    fn string(v: String) -> JsValue { JsValue { handle: @native("js_string", self.handle, v), ctx: self } }
    fn bigint(v: Int64) -> JsValue { JsValue { handle: @native("js_bigint", self.handle, v), ctx: self } }
    
    /// Create object
    fn object() -> JsObject { JsObject { handle: @native("js_object_new", self.handle), ctx: self } }
    
    /// Create array
    fn array() -> JsArray { JsArray { handle: @native("js_array_new", self.handle), ctx: self } }
    
    /// Create function from Vibee closure
    fn function<F>(f: F) -> JsFunction 
    where F: Fn(JsValue, [JsValue]) -> Result<JsValue, JsError> {
        let handle = @native("js_function_from_vibee", self.handle, f)
        JsFunction { handle: handle, ctx: self }
    }
    
    /// Create Promise
    fn promise() -> (JsPromise, JsResolver) {
        let (promise_h, resolver_h) = @native("js_promise_new", self.handle)
        (JsPromise { handle: promise_h, ctx: self }, JsResolver { handle: resolver_h, ctx: self })
    }
    
    /// Parse JSON
    fn parse_json(json: String) -> Result<JsValue, JsError> {
        let result = @native("js_json_parse", self.handle, json)
        if @native("js_is_exception", result) {
            Err(JsError.JsonParseError)
        } else {
            Ok(JsValue { handle: result, ctx: self })
        }
    }
    
    /// Stringify to JSON
    fn stringify_json(value: JsValue) -> Result<String, JsError> {
        let result = @native("js_json_stringify", self.handle, value.handle)
        if result.is_null() { Err(JsError.JsonStringifyError) } else { Ok(result) }
    }
}

// =============================================================================
// JavaScript Value
// =============================================================================

/// JavaScript value
struct JsValue {
    handle: *()
    ctx: JsContext
}

impl JsValue {
    /// Type checks
    fn is_undefined() -> Bool { @native("js_is_undefined", self.handle) }
    fn is_null() -> Bool { @native("js_is_null", self.handle) }
    fn is_boolean() -> Bool { @native("js_is_boolean", self.handle) }
    fn is_number() -> Bool { @native("js_is_number", self.handle) }
    fn is_string() -> Bool { @native("js_is_string", self.handle) }
    fn is_symbol() -> Bool { @native("js_is_symbol", self.handle) }
    fn is_bigint() -> Bool { @native("js_is_bigint", self.handle) }
    fn is_object() -> Bool { @native("js_is_object", self.handle) }
    fn is_array() -> Bool { @native("js_is_array", self.handle) }
    fn is_function() -> Bool { @native("js_is_function", self.handle) }
    fn is_promise() -> Bool { @native("js_is_promise", self.handle) }
    
    /// Get type name
    fn type_of() -> String { @native("js_typeof", self.handle) }
    
    /// Convert to Vibee types
    fn to_bool() -> Bool { @native("js_to_boolean", self.handle) }
    fn to_number() -> Float64 { @native("js_to_number", self.handle) }
    fn to_string() -> String { @native("js_to_string", self.handle) }
    fn to_int32() -> Int32 { @native("js_to_int32", self.handle) }
    fn to_int64() -> Int64 { @native("js_to_int64", self.handle) }
    
    /// Convert to object
    fn as_object() -> Option<JsObject> {
        if self.is_object() { Some(JsObject { handle: self.handle, ctx: self.ctx }) } else { None }
    }
    
    /// Convert to array
    fn as_array() -> Option<JsArray> {
        if self.is_array() { Some(JsArray { handle: self.handle, ctx: self.ctx }) } else { None }
    }
    
    /// Convert to function
    fn as_function() -> Option<JsFunction> {
        if self.is_function() { Some(JsFunction { handle: self.handle, ctx: self.ctx }) } else { None }
    }
    
    /// Strict equality
    fn strict_equals(other: JsValue) -> Bool {
        @native("js_strict_equals", self.handle, other.handle)
    }
    
    /// Abstract equality
    fn equals(other: JsValue) -> Bool {
        @native("js_equals", self.handle, other.handle)
    }
}

// =============================================================================
// JavaScript Object
// =============================================================================

/// JavaScript object
struct JsObject {
    handle: *()
    ctx: JsContext
}

impl JsObject {
    /// Get property
    fn get(key: String) -> JsValue {
        JsValue { handle: @native("js_object_get", self.handle, key), ctx: self.ctx }
    }
    
    /// Set property
    fn set(key: String, value: JsValue) {
        @native("js_object_set", self.handle, key, value.handle)
    }
    
    /// Delete property
    fn delete(key: String) -> Bool {
        @native("js_object_delete", self.handle, key)
    }
    
    /// Check if has property
    fn has(key: String) -> Bool {
        @native("js_object_has", self.handle, key)
    }
    
    /// Get own property names
    fn keys() -> [String] {
        @native("js_object_keys", self.handle)
    }
    
    /// Get own property values
    fn values() -> [JsValue] {
        @native("js_object_values", self.handle).iter().map(|h| JsValue { handle: h, ctx: self.ctx }).collect()
    }
    
    /// Get entries
    fn entries() -> [(String, JsValue)] {
        @native("js_object_entries", self.handle).iter().map(|(k, h)| (k, JsValue { handle: h, ctx: self.ctx })).collect()
    }
    
    /// Define property with descriptor
    fn define_property(key: String, descriptor: JsPropertyDescriptor) {
        @native("js_object_define_property", self.handle, key, descriptor)
    }
    
    /// Get prototype
    fn get_prototype() -> JsValue {
        JsValue { handle: @native("js_object_get_prototype", self.handle), ctx: self.ctx }
    }
    
    /// Set prototype
    fn set_prototype(proto: JsValue) {
        @native("js_object_set_prototype", self.handle, proto.handle)
    }
    
    /// Freeze object
    fn freeze() { @native("js_object_freeze", self.handle) }
    
    /// Seal object
    fn seal() { @native("js_object_seal", self.handle) }
    
    /// Check if frozen
    fn is_frozen() -> Bool { @native("js_object_is_frozen", self.handle) }
    
    /// Check if sealed
    fn is_sealed() -> Bool { @native("js_object_is_sealed", self.handle) }
    
    /// Convert to JsValue
    fn as_value() -> JsValue { JsValue { handle: self.handle, ctx: self.ctx } }
}

struct JsPropertyDescriptor {
    value: Option<JsValue>
    writable: Option<Bool>
    enumerable: Option<Bool>
    configurable: Option<Bool>
    get: Option<JsFunction>
    set: Option<JsFunction>
}

// =============================================================================
// JavaScript Array
// =============================================================================

/// JavaScript array
struct JsArray {
    handle: *()
    ctx: JsContext
}

impl JsArray {
    /// Get length
    fn len() -> Int { @native("js_array_length", self.handle) }
    
    /// Get element
    fn get(index: Int) -> JsValue {
        JsValue { handle: @native("js_array_get", self.handle, index), ctx: self.ctx }
    }
    
    /// Set element
    fn set(index: Int, value: JsValue) {
        @native("js_array_set", self.handle, index, value.handle)
    }
    
    /// Push element
    fn push(value: JsValue) {
        @native("js_array_push", self.handle, value.handle)
    }
    
    /// Pop element
    fn pop() -> JsValue {
        JsValue { handle: @native("js_array_pop", self.handle), ctx: self.ctx }
    }
    
    /// Shift element
    fn shift() -> JsValue {
        JsValue { handle: @native("js_array_shift", self.handle), ctx: self.ctx }
    }
    
    /// Unshift element
    fn unshift(value: JsValue) {
        @native("js_array_unshift", self.handle, value.handle)
    }
    
    /// Slice array
    fn slice(start: Int, end: Int) -> JsArray {
        JsArray { handle: @native("js_array_slice", self.handle, start, end), ctx: self.ctx }
    }
    
    /// Splice array
    fn splice(start: Int, delete_count: Int, items: [JsValue]) -> JsArray {
        let handles = items.iter().map(|v| v.handle).collect()
        JsArray { handle: @native("js_array_splice", self.handle, start, delete_count, handles), ctx: self.ctx }
    }
    
    /// Convert to Vibee array
    fn to_vec() -> [JsValue] {
        var result = []
        for i in 0..self.len() { result.push(self.get(i)) }
        result
    }
    
    /// Convert to JsValue
    fn as_value() -> JsValue { JsValue { handle: self.handle, ctx: self.ctx } }
}

// =============================================================================
// JavaScript Function
// =============================================================================

/// JavaScript function
struct JsFunction {
    handle: *()
    ctx: JsContext
}

impl JsFunction {
    /// Call function
    fn call(this: JsValue, args: [JsValue]) -> Result<JsValue, JsError> {
        let arg_handles = args.iter().map(|v| v.handle).collect()
        let result = @native("js_function_call", self.handle, this.handle, arg_handles)
        if @native("js_is_exception", result) {
            Err(JsError.Exception(JsValue { handle: @native("js_get_exception", self.ctx.handle), ctx: self.ctx }))
        } else {
            Ok(JsValue { handle: result, ctx: self.ctx })
        }
    }
    
    /// Call as constructor
    fn construct(args: [JsValue]) -> Result<JsValue, JsError> {
        let arg_handles = args.iter().map(|v| v.handle).collect()
        let result = @native("js_function_construct", self.handle, arg_handles)
        if @native("js_is_exception", result) {
            Err(JsError.Exception(JsValue { handle: @native("js_get_exception", self.ctx.handle), ctx: self.ctx }))
        } else {
            Ok(JsValue { handle: result, ctx: self.ctx })
        }
    }
    
    /// Bind this and arguments
    fn bind(this: JsValue, args: [JsValue]) -> JsFunction {
        let arg_handles = args.iter().map(|v| v.handle).collect()
        JsFunction { handle: @native("js_function_bind", self.handle, this.handle, arg_handles), ctx: self.ctx }
    }
    
    /// Get function name
    fn name() -> String { @native("js_function_name", self.handle) }
    
    /// Get function length (parameter count)
    fn length() -> Int { @native("js_function_length", self.handle) }
    
    /// Convert to JsValue
    fn as_value() -> JsValue { JsValue { handle: self.handle, ctx: self.ctx } }
}

// =============================================================================
// JavaScript Promise
// =============================================================================

/// JavaScript Promise
struct JsPromise {
    handle: *()
    ctx: JsContext
}

impl JsPromise {
    /// Create resolved promise
    fn resolve(ctx: JsContext, value: JsValue) -> Self {
        JsPromise { handle: @native("js_promise_resolve", ctx.handle, value.handle), ctx: ctx }
    }
    
    /// Create rejected promise
    fn reject(ctx: JsContext, reason: JsValue) -> Self {
        JsPromise { handle: @native("js_promise_reject", ctx.handle, reason.handle), ctx: ctx }
    }
    
    /// Then handler
    fn then(on_fulfilled: JsFunction) -> JsPromise {
        JsPromise { handle: @native("js_promise_then", self.handle, on_fulfilled.handle), ctx: self.ctx }
    }
    
    /// Catch handler
    fn catch(on_rejected: JsFunction) -> JsPromise {
        JsPromise { handle: @native("js_promise_catch", self.handle, on_rejected.handle), ctx: self.ctx }
    }
    
    /// Finally handler
    fn finally(on_finally: JsFunction) -> JsPromise {
        JsPromise { handle: @native("js_promise_finally", self.handle, on_finally.handle), ctx: self.ctx }
    }
    
    /// Get promise state
    fn state() -> JsPromiseState { @native("js_promise_state", self.handle) }
    
    /// Convert to JsValue
    fn as_value() -> JsValue { JsValue { handle: self.handle, ctx: self.ctx } }
}

enum JsPromiseState { Pending, Fulfilled, Rejected }

struct JsResolver { handle: *(), ctx: JsContext }

impl JsResolver {
    fn resolve(value: JsValue) { @native("js_resolver_resolve", self.handle, value.handle) }
    fn reject(reason: JsValue) { @native("js_resolver_reject", self.handle, reason.handle) }
}

// =============================================================================
// JavaScript Class
// =============================================================================

/// JavaScript class builder
struct JsClassBuilder {
    ctx: JsContext
    name: String
    constructor: Option<JsFunction>
    methods: [(String, JsFunction)]
    static_methods: [(String, JsFunction)]
    getters: [(String, JsFunction)]
    setters: [(String, JsFunction)]
    parent: Option<JsFunction>
}

impl JsClassBuilder {
    fn new(ctx: JsContext, name: String) -> Self {
        JsClassBuilder {
            ctx: ctx, name: name, constructor: None, methods: [],
            static_methods: [], getters: [], setters: [], parent: None
        }
    }
    
    fn constructor(f: JsFunction) -> Self { self.constructor = Some(f); self }
    fn method(name: String, f: JsFunction) -> Self { self.methods.push((name, f)); self }
    fn static_method(name: String, f: JsFunction) -> Self { self.static_methods.push((name, f)); self }
    fn getter(name: String, f: JsFunction) -> Self { self.getters.push((name, f)); self }
    fn setter(name: String, f: JsFunction) -> Self { self.setters.push((name, f)); self }
    fn extends(parent: JsFunction) -> Self { self.parent = Some(parent); self }
    
    fn build() -> JsFunction {
        JsFunction {
            handle: @native("js_class_build", self.ctx.handle, self.name, self.constructor, self.methods, self.static_methods, self.getters, self.setters, self.parent),
            ctx: self.ctx
        }
    }
}

// =============================================================================
// Conversion Traits
// =============================================================================

trait ToJsValue { fn to_js_value(ctx: JsContext) -> JsValue }
trait FromJsValue { fn from_js_value(value: JsValue) -> Result<Self, JsError> }

impl ToJsValue for Bool { fn to_js_value(ctx: JsContext) -> JsValue { ctx.boolean(self) } }
impl ToJsValue for Int { fn to_js_value(ctx: JsContext) -> JsValue { ctx.number(self as Float64) } }
impl ToJsValue for Float64 { fn to_js_value(ctx: JsContext) -> JsValue { ctx.number(self) } }
impl ToJsValue for String { fn to_js_value(ctx: JsContext) -> JsValue { ctx.string(self) } }

impl FromJsValue for Bool { fn from_js_value(v: JsValue) -> Result<Self, JsError> { Ok(v.to_bool()) } }
impl FromJsValue for Float64 { fn from_js_value(v: JsValue) -> Result<Self, JsError> { Ok(v.to_number()) } }
impl FromJsValue for String { fn from_js_value(v: JsValue) -> Result<Self, JsError> { Ok(v.to_string()) } }

// =============================================================================
// Error Types
// =============================================================================

enum JsError {
    RuntimeCreationFailed
    ContextCreationFailed
    EvalError(String)
    TypeError(String)
    ReferenceError(String)
    SyntaxError(String)
    RangeError(String)
    Exception(JsValue)
    JsonParseError
    JsonStringifyError
    Other(String)
}

impl Display for JsError {
    fn fmt(f: Formatter) {
        match self {
            RuntimeCreationFailed => f.write("Failed to create JS runtime")
            ContextCreationFailed => f.write("Failed to create JS context")
            EvalError(s) => f.write(format!("EvalError: {}", s))
            TypeError(s) => f.write(format!("TypeError: {}", s))
            ReferenceError(s) => f.write(format!("ReferenceError: {}", s))
            SyntaxError(s) => f.write(format!("SyntaxError: {}", s))
            RangeError(s) => f.write(format!("RangeError: {}", s))
            Exception(v) => f.write(format!("Exception: {}", v.to_string()))
            JsonParseError => f.write("JSON parse error")
            JsonStringifyError => f.write("JSON stringify error")
            Other(s) => f.write(s)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "js eval" {
    let runtime = JsRuntime.new()?
    let ctx = runtime.create_context()?
    
    let result = ctx.eval("1 + 2")?
    assert_eq(result.to_number(), 3.0)?
}

test "js object" {
    let runtime = JsRuntime.new()?
    let ctx = runtime.create_context()?
    
    let obj = ctx.object()
    obj.set("name", ctx.string("test"))
    
    assert(obj.has("name"))?
    assert_eq(obj.get("name").to_string(), "test")?
}

test "js array" {
    let runtime = JsRuntime.new()?
    let ctx = runtime.create_context()?
    
    let arr = ctx.array()
    arr.push(ctx.number(1.0))
    arr.push(ctx.number(2.0))
    
    assert_eq(arr.len(), 2)?
    assert_eq(arr.get(0).to_number(), 1.0)?
}

test "js function call" {
    let runtime = JsRuntime.new()?
    let ctx = runtime.create_context()?
    
    let result = ctx.eval("(function(a, b) { return a + b; })")?
    let func = result.as_function().unwrap()
    
    let sum = func.call(ctx.undefined(), [ctx.number(2.0), ctx.number(3.0)])?
    assert_eq(sum.to_number(), 5.0)?
}
