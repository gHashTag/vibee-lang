// =============================================================================
// Vibee OS â€” BigInt Module
// Arbitrary precision integer arithmetic
// =============================================================================

// -----------------------------------------------------------------------------
// BigInt Type
// -----------------------------------------------------------------------------

/// Arbitrary precision integer
struct BigInt {
    digits: [UInt32]  // Little-endian, base 2^32
    negative: Bool
    
    /// Create from integer
    fn from_int(n: Int) -> Self {
        if n == 0 {
            return BigInt { digits: [0], negative: false }
        }
        
        let negative = n < 0
        var value = if negative { -n } else { n } as UInt64
        var digits = []
        
        while value > 0 {
            digits.append((value & 0xFFFFFFFF) as UInt32)
            value >>= 32
        }
        
        BigInt { digits: digits, negative: negative }
    }
    
    /// Create from string
    fn from_string(s: String) -> Result<Self, ParseError> {
        let s = s.trim()
        if s.is_empty() { return Err(ParseError.Empty) }
        
        var negative = false
        var start = 0
        
        if s[0] == '-' { negative = true; start = 1 }
        else if s[0] == '+' { start = 1 }
        
        if start >= s.len() { return Err(ParseError.Empty) }
        
        // Parse digits
        var result = BigInt.zero()
        let ten = BigInt.from_int(10)
        
        for c in s[start..].chars() {
            if !c.is_digit() { return Err(ParseError.InvalidChar(c)) }
            let digit = (c as Int) - ('0' as Int)
            result = result * ten + BigInt.from_int(digit)
        }
        
        result.negative = negative && !result.is_zero()
        Ok(result)
    }
    
    /// Parse with radix
    fn from_string_radix(s: String, radix: Int) -> Result<Self, ParseError> {
        if radix < 2 || radix > 36 { return Err(ParseError.InvalidRadix(radix)) }
        
        let s = s.trim()
        var negative = false
        var start = 0
        
        if s[0] == '-' { negative = true; start = 1 }
        else if s[0] == '+' { start = 1 }
        
        var result = BigInt.zero()
        let base = BigInt.from_int(radix)
        
        for c in s[start..].chars() {
            let digit = char_to_digit(c, radix)?
            result = result * base + BigInt.from_int(digit)
        }
        
        result.negative = negative && !result.is_zero()
        Ok(result)
    }
    
    /// Zero
    fn zero() -> Self { BigInt { digits: [0], negative: false } }
    
    /// One
    fn one() -> Self { BigInt { digits: [1], negative: false } }
    
    /// Check if zero
    fn is_zero() -> Bool {
        self.digits.len() == 1 && self.digits[0] == 0
    }
    
    /// Check if one
    fn is_one() -> Bool {
        !self.negative && self.digits.len() == 1 && self.digits[0] == 1
    }
    
    /// Check if negative
    fn is_negative() -> Bool { self.negative }
    
    /// Check if positive
    fn is_positive() -> Bool { !self.negative && !self.is_zero() }
    
    /// Check if even
    fn is_even() -> Bool { self.digits[0] & 1 == 0 }
    
    /// Check if odd
    fn is_odd() -> Bool { self.digits[0] & 1 == 1 }
    
    /// Absolute value
    fn abs() -> Self {
        BigInt { digits: self.digits.clone(), negative: false }
    }
    
    /// Negate
    fn negate() -> Self {
        if self.is_zero() { self.clone() }
        else { BigInt { digits: self.digits.clone(), negative: !self.negative } }
    }
    
    /// Sign (-1, 0, or 1)
    fn signum() -> Int {
        if self.is_zero() { 0 }
        else if self.negative { -1 }
        else { 1 }
    }
    
    /// Number of bits
    fn bit_length() -> Int {
        if self.is_zero() { return 0 }
        let top = self.digits.last().unwrap()
        (self.digits.len() - 1) * 32 + (32 - top.leading_zeros() as Int)
    }
    
    /// Get bit at position
    fn bit(n: Int) -> Bool {
        let word_idx = n / 32
        let bit_idx = n % 32
        if word_idx >= self.digits.len() { false }
        else { (self.digits[word_idx] >> bit_idx) & 1 == 1 }
    }
    
    /// Convert to Int (may overflow)
    fn to_int() -> Option<Int> {
        if self.digits.len() > 2 { return None }
        
        var value = self.digits[0] as Int
        if self.digits.len() > 1 {
            value |= (self.digits[1] as Int) << 32
        }
        
        if self.negative { value = -value }
        Some(value)
    }
    
    /// Convert to string
    fn to_string() -> String {
        self.to_string_radix(10)
    }
    
    /// Convert to string with radix
    fn to_string_radix(radix: Int) -> String {
        if self.is_zero() { return "0" }
        
        var result = []
        var n = self.abs()
        let base = BigInt.from_int(radix)
        
        while !n.is_zero() {
            let (q, r) = n.div_rem(base)
            let digit = r.digits[0] as Int
            result.append(digit_to_char(digit))
            n = q
        }
        
        if self.negative { result.append('-') }
        result.rev().collect()
    }
    
    /// Normalize (remove leading zeros)
    fn normalize() -> Self {
        var digits = self.digits.clone()
        while digits.len() > 1 && digits.last() == Some(0) {
            digits.pop()
        }
        BigInt { digits: digits, negative: self.negative && digits != [0] }
    }
}

// -----------------------------------------------------------------------------
// Arithmetic Operations
// -----------------------------------------------------------------------------

impl Add for BigInt {
    fn add(other: BigInt) -> BigInt {
        if self.negative == other.negative {
            BigInt {
                digits: add_digits(self.digits, other.digits),
                negative: self.negative
            }.normalize()
        } else if self.negative {
            other - self.abs()
        } else {
            self - other.abs()
        }
    }
}

impl Sub for BigInt {
    fn sub(other: BigInt) -> BigInt {
        if self.negative != other.negative {
            BigInt {
                digits: add_digits(self.digits, other.digits),
                negative: self.negative
            }.normalize()
        } else {
            let cmp = compare_digits(self.digits, other.digits)
            if cmp == 0 { BigInt.zero() }
            else if cmp > 0 {
                BigInt {
                    digits: sub_digits(self.digits, other.digits),
                    negative: self.negative
                }.normalize()
            } else {
                BigInt {
                    digits: sub_digits(other.digits, self.digits),
                    negative: !self.negative
                }.normalize()
            }
        }
    }
}

impl Mul for BigInt {
    fn mul(other: BigInt) -> BigInt {
        if self.is_zero() || other.is_zero() { return BigInt.zero() }
        
        BigInt {
            digits: mul_digits(self.digits, other.digits),
            negative: self.negative != other.negative
        }.normalize()
    }
}

impl Div for BigInt {
    fn div(other: BigInt) -> BigInt {
        self.div_rem(other).0
    }
}

impl Rem for BigInt {
    fn rem(other: BigInt) -> BigInt {
        self.div_rem(other).1
    }
}

impl BigInt {
    /// Division with remainder
    fn div_rem(other: BigInt) -> (BigInt, BigInt) {
        if other.is_zero() { panic("Division by zero") }
        
        let cmp = compare_digits(self.digits, other.digits)
        if cmp < 0 { return (BigInt.zero(), self.clone()) }
        if cmp == 0 {
            return (
                BigInt { digits: [1], negative: self.negative != other.negative },
                BigInt.zero()
            )
        }
        
        let (q, r) = div_rem_digits(self.digits, other.digits)
        
        let q_neg = self.negative != other.negative
        let r_neg = self.negative
        
        (
            BigInt { digits: q, negative: q_neg && q != [0] }.normalize(),
            BigInt { digits: r, negative: r_neg && r != [0] }.normalize()
        )
    }
    
    /// Power
    fn pow(exp: Int) -> BigInt {
        if exp < 0 { panic("Negative exponent") }
        if exp == 0 { return BigInt.one() }
        
        var result = BigInt.one()
        var base = self.clone()
        var e = exp
        
        while e > 0 {
            if e & 1 == 1 { result = result * base }
            base = base * base
            e >>= 1
        }
        result
    }
    
    /// Modular power
    fn mod_pow(exp: BigInt, modulus: BigInt) -> BigInt {
        if modulus.is_one() { return BigInt.zero() }
        
        var result = BigInt.one()
        var base = self % modulus
        var e = exp
        
        while !e.is_zero() {
            if e.is_odd() {
                result = (result * base) % modulus
            }
            e = e >> 1
            base = (base * base) % modulus
        }
        result
    }
    
    /// Greatest common divisor
    fn gcd(other: BigInt) -> BigInt {
        var a = self.abs()
        var b = other.abs()
        
        while !b.is_zero() {
            let t = b.clone()
            b = a % b
            a = t
        }
        a
    }
    
    /// Least common multiple
    fn lcm(other: BigInt) -> BigInt {
        if self.is_zero() || other.is_zero() { BigInt.zero() }
        else { (self * other).abs() / self.gcd(other) }
    }
    
    /// Square root (integer)
    fn sqrt() -> BigInt {
        if self.is_negative() { panic("Square root of negative") }
        if self.is_zero() { return BigInt.zero() }
        
        // Newton's method
        var x = self.clone()
        var y = (x + BigInt.one()) >> 1
        
        while y < x {
            x = y
            y = (x + self / x) >> 1
        }
        x
    }
}

// -----------------------------------------------------------------------------
// Bitwise Operations
// -----------------------------------------------------------------------------

impl Shl<Int> for BigInt {
    fn shl(n: Int) -> BigInt {
        if n == 0 || self.is_zero() { return self.clone() }
        
        let word_shift = n / 32
        let bit_shift = n % 32
        
        var digits = vec![0; word_shift]
        var carry = 0u32
        
        for d in self.digits {
            let new_digit = (d << bit_shift) | carry
            carry = if bit_shift > 0 { d >> (32 - bit_shift) } else { 0 }
            digits.append(new_digit)
        }
        
        if carry > 0 { digits.append(carry) }
        
        BigInt { digits: digits, negative: self.negative }.normalize()
    }
}

impl Shr<Int> for BigInt {
    fn shr(n: Int) -> BigInt {
        if n == 0 || self.is_zero() { return self.clone() }
        
        let word_shift = n / 32
        let bit_shift = n % 32
        
        if word_shift >= self.digits.len() { return BigInt.zero() }
        
        var digits = []
        var carry = 0u32
        
        for i in (word_shift..self.digits.len()).rev() {
            let d = self.digits[i]
            let new_digit = (d >> bit_shift) | carry
            carry = if bit_shift > 0 { d << (32 - bit_shift) } else { 0 }
            digits.insert(0, new_digit)
        }
        
        BigInt { digits: digits, negative: self.negative }.normalize()
    }
}

impl BitAnd for BigInt {
    fn bitand(other: BigInt) -> BigInt {
        let len = min(self.digits.len(), other.digits.len())
        var digits = []
        
        for i in 0..len {
            digits.append(self.digits[i] & other.digits[i])
        }
        
        BigInt { digits: digits, negative: false }.normalize()
    }
}

impl BitOr for BigInt {
    fn bitor(other: BigInt) -> BigInt {
        let len = max(self.digits.len(), other.digits.len())
        var digits = []
        
        for i in 0..len {
            let a = self.digits.get(i).unwrap_or(0)
            let b = other.digits.get(i).unwrap_or(0)
            digits.append(a | b)
        }
        
        BigInt { digits: digits, negative: false }.normalize()
    }
}

impl BitXor for BigInt {
    fn bitxor(other: BigInt) -> BigInt {
        let len = max(self.digits.len(), other.digits.len())
        var digits = []
        
        for i in 0..len {
            let a = self.digits.get(i).unwrap_or(0)
            let b = other.digits.get(i).unwrap_or(0)
            digits.append(a ^ b)
        }
        
        BigInt { digits: digits, negative: false }.normalize()
    }
}

// -----------------------------------------------------------------------------
// Comparison
// -----------------------------------------------------------------------------

impl Eq for BigInt {
    fn eq(other: BigInt) -> Bool {
        self.negative == other.negative && self.digits == other.digits
    }
}

impl Ord for BigInt {
    fn cmp(other: BigInt) -> Ordering {
        if self.negative != other.negative {
            if self.negative { Ordering.Less } else { Ordering.Greater }
        } else {
            let cmp = compare_digits(self.digits, other.digits)
            if self.negative { -cmp } else { cmp }
        }
    }
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

fn add_digits(a: [UInt32], b: [UInt32]) -> [UInt32] {
    let len = max(a.len(), b.len())
    var result = []
    var carry = 0u64
    
    for i in 0..len {
        let x = a.get(i).unwrap_or(0) as UInt64
        let y = b.get(i).unwrap_or(0) as UInt64
        let sum = x + y + carry
        result.append((sum & 0xFFFFFFFF) as UInt32)
        carry = sum >> 32
    }
    
    if carry > 0 { result.append(carry as UInt32) }
    result
}

fn sub_digits(a: [UInt32], b: [UInt32]) -> [UInt32] {
    var result = []
    var borrow = 0i64
    
    for i in 0..a.len() {
        let x = a[i] as Int64
        let y = b.get(i).unwrap_or(0) as Int64
        var diff = x - y - borrow
        
        if diff < 0 {
            diff += 0x100000000
            borrow = 1
        } else {
            borrow = 0
        }
        
        result.append(diff as UInt32)
    }
    result
}

fn mul_digits(a: [UInt32], b: [UInt32]) -> [UInt32] {
    var result = vec![0u32; a.len() + b.len()]
    
    for i in 0..a.len() {
        var carry = 0u64
        for j in 0..b.len() {
            let prod = (a[i] as UInt64) * (b[j] as UInt64) + (result[i + j] as UInt64) + carry
            result[i + j] = (prod & 0xFFFFFFFF) as UInt32
            carry = prod >> 32
        }
        result[i + b.len()] = carry as UInt32
    }
    result
}

fn div_rem_digits(a: [UInt32], b: [UInt32]) -> ([UInt32], [UInt32]) {
    // Simple long division - can be optimized
    @native("bigint_div_rem", a, b)
}

fn compare_digits(a: [UInt32], b: [UInt32]) -> Int {
    if a.len() != b.len() {
        return if a.len() > b.len() { 1 } else { -1 }
    }
    
    for i in (0..a.len()).rev() {
        if a[i] != b[i] {
            return if a[i] > b[i] { 1 } else { -1 }
        }
    }
    0
}

fn char_to_digit(c: Char, radix: Int) -> Result<Int, ParseError> {
    let d = if c >= '0' && c <= '9' { (c as Int) - ('0' as Int) }
        else if c >= 'a' && c <= 'z' { (c as Int) - ('a' as Int) + 10 }
        else if c >= 'A' && c <= 'Z' { (c as Int) - ('A' as Int) + 10 }
        else { return Err(ParseError.InvalidChar(c)) }
    
    if d >= radix { Err(ParseError.InvalidChar(c)) }
    else { Ok(d) }
}

fn digit_to_char(d: Int) -> Char {
    if d < 10 { ('0' as Int + d) as Char }
    else { ('a' as Int + d - 10) as Char }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ParseError {
    Empty
    InvalidChar(Char)
    InvalidRadix(Int)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "from_string" {
    let n = BigInt.from_string("12345678901234567890")?
    assert(n.to_string() == "12345678901234567890")
}

test "arithmetic" {
    let a = BigInt.from_int(1000000)
    let b = BigInt.from_int(999999)
    assert((a + b).to_int() == Some(1999999))
    assert((a - b).to_int() == Some(1))
    assert((a * b).to_string() == "999999000000")
}

test "large multiplication" {
    let a = BigInt.from_string("123456789012345678901234567890")?
    let b = BigInt.from_string("987654321098765432109876543210")?
    let c = a * b
    assert(c.to_string().len() > 50)
}

test "power" {
    let two = BigInt.from_int(2)
    let result = two.pow(100)
    assert(result.bit_length() == 101)
}

test "gcd" {
    let a = BigInt.from_int(48)
    let b = BigInt.from_int(18)
    assert(a.gcd(b).to_int() == Some(6))
}
