// =============================================================================
// Vibee OS â€” WebSocket Module
// WebSocket client and server implementation (RFC 6455)
// =============================================================================

// -----------------------------------------------------------------------------
// WebSocket Client
// -----------------------------------------------------------------------------

/// WebSocket client connection
actor WebSocket {
    state url: String
    state connection: Option<Connection>
    state state: WebSocketState
    state protocols: [String]
    state headers: Map<String, String>
    state on_message: Option<(Message) -> ()>
    state on_close: Option<(CloseCode, String) -> ()>
    state on_error: Option<(WebSocketError) -> ()>
    state ping_interval: Option<Duration>
    state reconnect: ReconnectConfig?
    
    /// Connect to WebSocket server
    fn connect(url: String) -> Result<WebSocket, WebSocketError> {
        let ws = WebSocket {
            url: url,
            state: .Connecting,
            protocols: [],
            headers: Map.empty()
        }
        ws.establish_connection()?
        Ok(ws)
    }
    
    /// Create WebSocket builder
    fn builder(url: String) -> WebSocketBuilder {
        WebSocketBuilder.new(url)
    }
    
    /// Establish connection
    fn establish_connection() -> Result<(), WebSocketError> {
        // Parse URL
        let parsed = URL.parse(self.url)?
        let host = parsed.host.ok_or(WebSocketError.InvalidURL)?
        let port = parsed.port.unwrap_or(if parsed.scheme == "wss" { 443 } else { 80 })
        let secure = parsed.scheme == "wss"
        
        // Create TCP connection
        let tcp = if secure {
            TLS.connect(host, port)?
        } else {
            TCP.connect(host, port)?
        }
        
        // Perform WebSocket handshake
        let key = self.generate_key()
        let request = self.build_handshake_request(host, parsed.path, key)
        tcp.write(request)?
        
        let response = tcp.read_until("\r\n\r\n")?
        self.verify_handshake(response, key)?
        
        self.connection = Some(Connection.new(tcp))
        self.state = .Open
        
        // Start ping if configured
        if let interval = self.ping_interval {
            self.start_ping_loop(interval)
        }
        
        Ok(())
    }
    
    /// Generate WebSocket key
    fn generate_key() -> String {
        Random.bytes(16).base64_encode()
    }
    
    /// Build handshake request
    fn build_handshake_request(host: String, path: String, key: String) -> String {
        var request = "GET \(path) HTTP/1.1\r\n"
        request += "Host: \(host)\r\n"
        request += "Upgrade: websocket\r\n"
        request += "Connection: Upgrade\r\n"
        request += "Sec-WebSocket-Key: \(key)\r\n"
        request += "Sec-WebSocket-Version: 13\r\n"
        
        if !self.protocols.is_empty() {
            request += "Sec-WebSocket-Protocol: \(self.protocols.join(", "))\r\n"
        }
        
        for (name, value) in self.headers {
            request += "\(name): \(value)\r\n"
        }
        
        request += "\r\n"
        request
    }
    
    /// Verify handshake response
    fn verify_handshake(response: String, key: String) -> Result<(), WebSocketError> {
        if !response.contains("101") {
            return Err(WebSocketError.HandshakeFailed("Invalid status code"))
        }
        
        let expected_accept = SHA1.hash(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
            .base64_encode()
        
        if !response.contains("Sec-WebSocket-Accept: \(expected_accept)") {
            return Err(WebSocketError.HandshakeFailed("Invalid accept key"))
        }
        
        Ok(())
    }
    
    /// Send text message
    on send(text: String) -> Result<(), WebSocketError> {
        self.send_frame(Frame.text(text))
    }
    
    /// Send binary message
    on send_binary(data: [Byte]) -> Result<(), WebSocketError> {
        self.send_frame(Frame.binary(data))
    }
    
    /// Send ping
    on ping(data: [Byte] = []) -> Result<(), WebSocketError> {
        self.send_frame(Frame.ping(data))
    }
    
    /// Send pong
    on pong(data: [Byte] = []) -> Result<(), WebSocketError> {
        self.send_frame(Frame.pong(data))
    }
    
    /// Send frame
    fn send_frame(frame: Frame) -> Result<(), WebSocketError> {
        guard self.state == .Open else {
            return Err(WebSocketError.NotConnected)
        }
        
        guard let conn = self.connection else {
            return Err(WebSocketError.NotConnected)
        }
        
        // Client must mask frames
        let masked_frame = frame.mask(Random.bytes(4))
        conn.write(masked_frame.encode())?
        Ok(())
    }
    
    /// Receive next message
    on receive() -> Result<Message, WebSocketError> {
        guard let conn = self.connection else {
            return Err(WebSocketError.NotConnected)
        }
        
        loop {
            let frame = Frame.decode(conn)?
            
            match frame.opcode {
                .Text => return Ok(Message.Text(frame.payload_string()))
                .Binary => return Ok(Message.Binary(frame.payload))
                .Close => {
                    let (code, reason) = frame.parse_close()
                    self.handle_close(code, reason)
                    return Err(WebSocketError.ConnectionClosed(code, reason))
                }
                .Ping => {
                    self.pong(frame.payload)?
                }
                .Pong => {
                    // Ignore pong
                }
                .Continuation => {
                    // Handle fragmented messages
                }
            }
        }
    }
    
    /// Start message receive loop
    on listen() {
        async {
            while self.state == .Open {
                match self.receive() {
                    Ok(msg) => {
                        if let handler = self.on_message {
                            handler(msg)
                        }
                    }
                    Err(WebSocketError.ConnectionClosed(code, reason)) => {
                        if let handler = self.on_close {
                            handler(code, reason)
                        }
                        self.maybe_reconnect()
                        break
                    }
                    Err(e) => {
                        if let handler = self.on_error {
                            handler(e)
                        }
                    }
                }
            }
        }
    }
    
    /// Close connection
    on close(code: CloseCode = .Normal, reason: String = "") -> Result<(), WebSocketError> {
        if self.state != .Open {
            return Ok(())
        }
        
        self.state = .Closing
        self.send_frame(Frame.close(code, reason))?
        
        // Wait for close response with timeout
        let timeout = Duration.seconds(5)
        // ... handle close handshake
        
        self.state = .Closed
        self.connection = None
        Ok(())
    }
    
    fn handle_close(code: CloseCode, reason: String) {
        self.state = .Closed
        self.connection = None
    }
    
    fn maybe_reconnect() {
        if let config = self.reconnect {
            if config.attempts < config.max_attempts {
                sleep(config.delay)
                config.attempts += 1
                config.delay = (config.delay * 2).min(config.max_delay)
                
                match self.establish_connection() {
                    Ok(()) => {
                        config.attempts = 0
                        config.delay = config.initial_delay
                        self.listen()
                    }
                    Err(_) => self.maybe_reconnect()
                }
            }
        }
    }
    
    fn start_ping_loop(interval: Duration) {
        async {
            while self.state == .Open {
                sleep(interval)
                let _ = self.ping()
            }
        }
    }
    
    /// Check if connected
    fn is_connected() -> Bool {
        self.state == .Open
    }
    
    /// Get current state
    fn get_state() -> WebSocketState {
        self.state
    }
}

/// WebSocket builder
actor WebSocketBuilder {
    state url: String
    state protocols: [String]
    state headers: Map<String, String>
    state ping_interval: Option<Duration>
    state reconnect: Option<ReconnectConfig>
    state on_message: Option<(Message) -> ()>
    state on_close: Option<(CloseCode, String) -> ()>
    state on_error: Option<(WebSocketError) -> ()>
    
    fn new(url: String) -> Self {
        WebSocketBuilder {
            url: url,
            protocols: [],
            headers: Map.empty()
        }
    }
    
    on protocol(p: String) -> Self { self.protocols.append(p); self }
    on header(name: String, value: String) -> Self { self.headers.set(name, value); self }
    on ping_interval(d: Duration) -> Self { self.ping_interval = Some(d); self }
    
    on reconnect(max_attempts: Int = 5, initial_delay: Duration = Duration.seconds(1)) -> Self {
        self.reconnect = Some(ReconnectConfig {
            max_attempts: max_attempts,
            initial_delay: initial_delay,
            max_delay: Duration.seconds(30),
            delay: initial_delay,
            attempts: 0
        })
        self
    }
    
    on on_message(handler: (Message) -> ()) -> Self { self.on_message = Some(handler); self }
    on on_close(handler: (CloseCode, String) -> ()) -> Self { self.on_close = Some(handler); self }
    on on_error(handler: (WebSocketError) -> ()) -> Self { self.on_error = Some(handler); self }
    
    on connect() -> Result<WebSocket, WebSocketError> {
        let ws = WebSocket {
            url: self.url,
            state: .Connecting,
            protocols: self.protocols,
            headers: self.headers,
            ping_interval: self.ping_interval,
            reconnect: self.reconnect,
            on_message: self.on_message,
            on_close: self.on_close,
            on_error: self.on_error
        }
        ws.establish_connection()?
        Ok(ws)
    }
}

struct ReconnectConfig {
    max_attempts: Int
    initial_delay: Duration
    max_delay: Duration
    delay: Duration
    attempts: Int
}

// -----------------------------------------------------------------------------
// WebSocket Server
// -----------------------------------------------------------------------------

/// WebSocket server
actor WebSocketServer {
    state address: String
    state port: Int
    state clients: Map<String, WebSocket>
    state on_connect: Option<(WebSocket) -> ()>
    state on_disconnect: Option<(String) -> ()>
    state running: Bool
    
    /// Create WebSocket server
    fn new(port: Int) -> Self {
        WebSocketServer {
            address: "0.0.0.0",
            port: port,
            clients: Map.empty(),
            running: false
        }
    }
    
    on address(addr: String) -> Self { self.address = addr; self }
    on on_connect(handler: (WebSocket) -> ()) -> Self { self.on_connect = Some(handler); self }
    on on_disconnect(handler: (String) -> ()) -> Self { self.on_disconnect = Some(handler); self }
    
    /// Start server
    on start() -> Result<(), WebSocketError> {
        let listener = TCP.listen(self.address, self.port)?
        self.running = true
        
        while self.running {
            let conn = listener.accept()?
            async {
                self.handle_connection(conn)
            }
        }
        
        Ok(())
    }
    
    /// Handle incoming connection
    fn handle_connection(conn: TCPConnection) {
        // Read HTTP upgrade request
        let request = conn.read_until("\r\n\r\n").unwrap_or("")
        
        if !self.is_websocket_upgrade(request) {
            conn.write("HTTP/1.1 400 Bad Request\r\n\r\n")
            conn.close()
            return
        }
        
        // Extract key and perform handshake
        let key = self.extract_key(request).unwrap_or("")
        let accept = SHA1.hash(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")
            .base64_encode()
        
        let response = "HTTP/1.1 101 Switching Protocols\r\n" +
            "Upgrade: websocket\r\n" +
            "Connection: Upgrade\r\n" +
            "Sec-WebSocket-Accept: \(accept)\r\n\r\n"
        
        conn.write(response)
        
        // Create WebSocket and add to clients
        let id = UUID.v4()
        let ws = WebSocket {
            url: "",
            connection: Some(Connection.new(conn)),
            state: .Open
        }
        
        self.clients.set(id, ws)
        
        if let handler = self.on_connect {
            handler(ws)
        }
        
        // Handle messages until disconnect
        ws.listen()
        
        self.clients.remove(id)
        if let handler = self.on_disconnect {
            handler(id)
        }
    }
    
    fn is_websocket_upgrade(request: String) -> Bool {
        request.contains("Upgrade: websocket") &&
        request.contains("Sec-WebSocket-Key:")
    }
    
    fn extract_key(request: String) -> Option<String> {
        for line in request.lines() {
            if line.starts_with("Sec-WebSocket-Key:") {
                return Some(line.split(":")[1].trim())
            }
        }
        None
    }
    
    /// Broadcast message to all clients
    on broadcast(message: String) {
        for (_, client) in self.clients {
            let _ = client.send(message)
        }
    }
    
    /// Broadcast binary to all clients
    on broadcast_binary(data: [Byte]) {
        for (_, client) in self.clients {
            let _ = client.send_binary(data)
        }
    }
    
    /// Send to specific client
    on send_to(client_id: String, message: String) -> Result<(), WebSocketError> {
        let client = self.clients.get(client_id)
            .ok_or(WebSocketError.ClientNotFound(client_id))?
        client.send(message)
    }
    
    /// Get connected client count
    fn client_count() -> Int {
        self.clients.len()
    }
    
    /// Stop server
    on stop() {
        self.running = false
        for (_, client) in self.clients {
            let _ = client.close()
        }
        self.clients.clear()
    }
}

// -----------------------------------------------------------------------------
// WebSocket Frame
// -----------------------------------------------------------------------------

/// WebSocket frame
struct Frame {
    fin: Bool
    opcode: Opcode
    masked: Bool
    mask_key: [Byte]
    payload: [Byte]
    
    /// Create text frame
    fn text(data: String) -> Self {
        Frame {
            fin: true,
            opcode: .Text,
            masked: false,
            mask_key: [],
            payload: data.bytes()
        }
    }
    
    /// Create binary frame
    fn binary(data: [Byte]) -> Self {
        Frame {
            fin: true,
            opcode: .Binary,
            masked: false,
            mask_key: [],
            payload: data
        }
    }
    
    /// Create ping frame
    fn ping(data: [Byte] = []) -> Self {
        Frame {
            fin: true,
            opcode: .Ping,
            masked: false,
            mask_key: [],
            payload: data
        }
    }
    
    /// Create pong frame
    fn pong(data: [Byte] = []) -> Self {
        Frame {
            fin: true,
            opcode: .Pong,
            masked: false,
            mask_key: [],
            payload: data
        }
    }
    
    /// Create close frame
    fn close(code: CloseCode, reason: String = "") -> Self {
        var payload = []
        payload.append((code.value >> 8) as Byte)
        payload.append((code.value & 0xFF) as Byte)
        payload.extend(reason.bytes())
        
        Frame {
            fin: true,
            opcode: .Close,
            masked: false,
            mask_key: [],
            payload: payload
        }
    }
    
    /// Apply mask to frame
    fn mask(key: [Byte]) -> Self {
        var masked_payload = []
        for (i, byte) in self.payload.enumerate() {
            masked_payload.append(byte ^ key[i % 4])
        }
        
        Frame {
            fin: self.fin,
            opcode: self.opcode,
            masked: true,
            mask_key: key,
            payload: masked_payload
        }
    }
    
    /// Encode frame to bytes
    fn encode() -> [Byte] {
        var bytes = []
        
        // First byte: FIN + opcode
        var first_byte = if self.fin { 0x80 } else { 0x00 }
        first_byte |= self.opcode.value()
        bytes.append(first_byte)
        
        // Second byte: MASK + payload length
        var second_byte = if self.masked { 0x80 } else { 0x00 }
        let len = self.payload.len()
        
        if len < 126 {
            second_byte |= len as Byte
            bytes.append(second_byte)
        } else if len < 65536 {
            second_byte |= 126
            bytes.append(second_byte)
            bytes.append((len >> 8) as Byte)
            bytes.append((len & 0xFF) as Byte)
        } else {
            second_byte |= 127
            bytes.append(second_byte)
            for i in (0..8).rev() {
                bytes.append((len >> (i * 8)) as Byte)
            }
        }
        
        // Mask key
        if self.masked {
            bytes.extend(self.mask_key)
        }
        
        // Payload
        bytes.extend(self.payload)
        
        bytes
    }
    
    /// Decode frame from connection
    fn decode(conn: Connection) -> Result<Frame, WebSocketError> {
        let first_byte = conn.read_byte()?
        let fin = (first_byte & 0x80) != 0
        let opcode = Opcode.from_byte(first_byte & 0x0F)?
        
        let second_byte = conn.read_byte()?
        let masked = (second_byte & 0x80) != 0
        var payload_len = (second_byte & 0x7F) as Int
        
        if payload_len == 126 {
            let len_bytes = conn.read_bytes(2)?
            payload_len = (len_bytes[0] as Int << 8) | (len_bytes[1] as Int)
        } else if payload_len == 127 {
            let len_bytes = conn.read_bytes(8)?
            payload_len = 0
            for byte in len_bytes {
                payload_len = (payload_len << 8) | (byte as Int)
            }
        }
        
        let mask_key = if masked {
            conn.read_bytes(4)?
        } else {
            []
        }
        
        var payload = conn.read_bytes(payload_len)?
        
        // Unmask if needed
        if masked {
            for (i, byte) in payload.enumerate() {
                payload[i] = byte ^ mask_key[i % 4]
            }
        }
        
        Ok(Frame {
            fin: fin,
            opcode: opcode,
            masked: masked,
            mask_key: mask_key,
            payload: payload
        })
    }
    
    /// Get payload as string
    fn payload_string() -> String {
        String.from_utf8(self.payload).unwrap_or("")
    }
    
    /// Parse close frame
    fn parse_close() -> (CloseCode, String) {
        if self.payload.len() < 2 {
            return (CloseCode.Normal, "")
        }
        
        let code_value = (self.payload[0] as Int << 8) | (self.payload[1] as Int)
        let code = CloseCode.from_value(code_value)
        let reason = if self.payload.len() > 2 {
            String.from_utf8(self.payload[2..]).unwrap_or("")
        } else {
            ""
        }
        
        (code, reason)
    }
}

/// Frame opcode
enum Opcode {
    Continuation
    Text
    Binary
    Close
    Ping
    Pong
    
    fn value() -> Byte {
        match self {
            .Continuation => 0x0
            .Text => 0x1
            .Binary => 0x2
            .Close => 0x8
            .Ping => 0x9
            .Pong => 0xA
        }
    }
    
    fn from_byte(b: Byte) -> Result<Opcode, WebSocketError> {
        match b {
            0x0 => Ok(.Continuation)
            0x1 => Ok(.Text)
            0x2 => Ok(.Binary)
            0x8 => Ok(.Close)
            0x9 => Ok(.Ping)
            0xA => Ok(.Pong)
            _ => Err(WebSocketError.InvalidOpcode(b))
        }
    }
}

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

/// WebSocket message
enum Message {
    Text(String)
    Binary([Byte])
    
    fn is_text() -> Bool {
        match self { .Text(_) => true, _ => false }
    }
    
    fn is_binary() -> Bool {
        match self { .Binary(_) => true, _ => false }
    }
    
    fn as_text() -> Option<String> {
        match self { .Text(s) => Some(s), _ => None }
    }
    
    fn as_binary() -> Option<[Byte]> {
        match self { .Binary(b) => Some(b), _ => None }
    }
}

/// WebSocket state
enum WebSocketState {
    Connecting
    Open
    Closing
    Closed
}

/// Close code
enum CloseCode {
    Normal          // 1000
    GoingAway       // 1001
    ProtocolError   // 1002
    UnsupportedData // 1003
    NoStatus        // 1005
    Abnormal        // 1006
    InvalidPayload  // 1007
    PolicyViolation // 1008
    MessageTooBig   // 1009
    MandatoryExt    // 1010
    InternalError   // 1011
    ServiceRestart  // 1012
    TryAgainLater   // 1013
    Custom(Int)
    
    fn value() -> Int {
        match self {
            .Normal => 1000
            .GoingAway => 1001
            .ProtocolError => 1002
            .UnsupportedData => 1003
            .NoStatus => 1005
            .Abnormal => 1006
            .InvalidPayload => 1007
            .PolicyViolation => 1008
            .MessageTooBig => 1009
            .MandatoryExt => 1010
            .InternalError => 1011
            .ServiceRestart => 1012
            .TryAgainLater => 1013
            .Custom(v) => v
        }
    }
    
    fn from_value(v: Int) -> CloseCode {
        match v {
            1000 => .Normal
            1001 => .GoingAway
            1002 => .ProtocolError
            1003 => .UnsupportedData
            1005 => .NoStatus
            1006 => .Abnormal
            1007 => .InvalidPayload
            1008 => .PolicyViolation
            1009 => .MessageTooBig
            1010 => .MandatoryExt
            1011 => .InternalError
            1012 => .ServiceRestart
            1013 => .TryAgainLater
            _ => .Custom(v)
        }
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum WebSocketError {
    InvalidURL
    ConnectionFailed(String)
    HandshakeFailed(String)
    NotConnected
    ConnectionClosed(CloseCode, String)
    InvalidOpcode(Byte)
    InvalidFrame(String)
    MessageTooLarge
    ClientNotFound(String)
    IOError(String)
    
    fn message() -> String {
        match self {
            .InvalidURL => "Invalid WebSocket URL"
            .ConnectionFailed(msg) => "Connection failed: \(msg)"
            .HandshakeFailed(msg) => "Handshake failed: \(msg)"
            .NotConnected => "Not connected"
            .ConnectionClosed(code, reason) => "Connection closed (\(code.value())): \(reason)"
            .InvalidOpcode(op) => "Invalid opcode: \(op)"
            .InvalidFrame(msg) => "Invalid frame: \(msg)"
            .MessageTooLarge => "Message too large"
            .ClientNotFound(id) => "Client not found: \(id)"
            .IOError(msg) => "I/O error: \(msg)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "frame encoding" {
    let frame = Frame.text("Hello")
    let encoded = frame.mask([0x12, 0x34, 0x56, 0x78]).encode()
    
    assert(encoded[0] == 0x81)  // FIN + Text opcode
    assert(encoded[1] == 0x85)  // Masked + length 5
}

test "close code" {
    assert(CloseCode.Normal.value() == 1000)
    assert(CloseCode.from_value(1001) == .GoingAway)
}

test "message types" {
    let text = Message.Text("hello")
    let binary = Message.Binary([1, 2, 3])
    
    assert(text.is_text())
    assert(!text.is_binary())
    assert(binary.is_binary())
    assert(text.as_text() == Some("hello"))
}
