// =============================================================================
// Vibee OS â€” RSA Module
// RSA Public-Key Cryptography (PKCS#1)
// =============================================================================
//
// RSA is an asymmetric cryptographic algorithm for:
// - Public-key encryption (OAEP recommended)
// - Digital signatures (PSS recommended)
// - Key exchange
//
// Key sizes: 2048, 3072, 4096 bits (2048 minimum recommended)
// =============================================================================

const MIN_KEY_SIZE: Int = 2048
const DEFAULT_KEY_SIZE: Int = 2048
const RECOMMENDED_KEY_SIZE: Int = 4096

// =============================================================================
// Key Size
// =============================================================================

enum RsaKeySize {
    Bits2048
    Bits3072
    Bits4096
}

impl RsaKeySize {
    fn bits() -> Int {
        match self {
            Bits2048 => 2048
            Bits3072 => 3072
            Bits4096 => 4096
        }
    }
    
    fn from_bits(bits: Int) -> Option<Self> {
        match bits {
            2048 => Some(Bits2048)
            3072 => Some(Bits3072)
            4096 => Some(Bits4096)
            _ => None
        }
    }
}

// =============================================================================
// Padding Schemes
// =============================================================================

enum RsaPadding {
    Pkcs1v15       // Legacy, for compatibility
    OaepSha256     // Recommended for encryption
    OaepSha384
    OaepSha512
    PssSha256      // Recommended for signatures
    PssSha384
    PssSha512
}

impl RsaPadding {
    fn is_oaep() -> Bool {
        match self {
            OaepSha256 | OaepSha384 | OaepSha512 => true
            _ => false
        }
    }
    
    fn is_pss() -> Bool {
        match self {
            PssSha256 | PssSha384 | PssSha512 => true
            _ => false
        }
    }
}

// =============================================================================
// RSA Key Pair
// =============================================================================

/// RSA key pair containing public and private keys
struct RsaKeyPair {
    public_key: RsaPublicKey
    private_key: RsaPrivateKey
}

impl RsaKeyPair {
    /// Generate new RSA key pair
    fn generate(bits: Int) -> Result<Self, RsaError> {
        if bits < MIN_KEY_SIZE {
            return Err(RsaError.KeyTooSmall)
        }
        @native("rsa_generate", bits).map_err(|_| RsaError.KeyGenerationFailed)
    }
    
    /// Generate 2048-bit key pair
    fn generate_2048() -> Result<Self, RsaError> {
        Self.generate(2048)
    }
    
    /// Generate 3072-bit key pair
    fn generate_3072() -> Result<Self, RsaError> {
        Self.generate(3072)
    }
    
    /// Generate 4096-bit key pair (recommended)
    fn generate_4096() -> Result<Self, RsaError> {
        Self.generate(4096)
    }
    
    /// Generate with specified key size enum
    fn generate_size(size: RsaKeySize) -> Result<Self, RsaError> {
        Self.generate(size.bits())
    }
    
    /// Load key pair from PEM files
    fn from_pem_files(public_path: String, private_path: String) -> Result<Self, RsaError> {
        let public_key = RsaPublicKey.from_pem_file(public_path)?
        let private_key = RsaPrivateKey.from_pem_file(private_path)?
        Ok(RsaKeyPair { public_key: public_key, private_key: private_key })
    }
    
    /// Save key pair to PEM files
    fn to_pem_files(public_path: String, private_path: String) -> Result<(), RsaError> {
        fs.write(public_path, self.public_key.to_pem()).map_err(|e| RsaError.IoError(e.to_string()))?
        fs.write(private_path, self.private_key.to_pem()).map_err(|e| RsaError.IoError(e.to_string()))?
        Ok(())
    }
    
    /// Get public key
    fn public() -> RsaPublicKey {
        self.public_key
    }
    
    /// Get private key
    fn private() -> RsaPrivateKey {
        self.private_key
    }
}

// =============================================================================
// RSA Public Key
// =============================================================================

/// RSA public key for encryption and signature verification
struct RsaPublicKey {
    der: [UInt8]
    modulus_bits: Int
}

impl RsaPublicKey {
    /// Create from DER bytes
    fn from_der(der: [UInt8]) -> Result<Self, RsaError> {
        let bits = @native("rsa_public_key_bits", der).map_err(|_| RsaError.InvalidKey)?
        Ok(RsaPublicKey { der: der, modulus_bits: bits })
    }
    
    /// Create from PEM string
    fn from_pem(pem: String) -> Result<Self, RsaError> {
        let der = @native("rsa_public_from_pem", pem).map_err(|_| RsaError.InvalidPem)?
        Self.from_der(der)
    }
    
    /// Load from PEM file
    fn from_pem_file(path: String) -> Result<Self, RsaError> {
        let pem = fs.read_string(path).map_err(|e| RsaError.IoError(e.to_string()))?
        Self.from_pem(pem)
    }
    
    /// Export to PEM string
    fn to_pem() -> String {
        @native("rsa_public_to_pem", self.der)
    }
    
    /// Export to DER bytes
    fn to_der() -> [UInt8] {
        self.der
    }
    
    /// Get key size in bits
    fn key_bits() -> Int {
        self.modulus_bits
    }
    
    /// Encrypt data with OAEP-SHA256 (recommended)
    fn encrypt(plaintext: [UInt8]) -> Result<[UInt8], RsaError> {
        self.encrypt_oaep(plaintext, RsaPadding.OaepSha256)
    }
    
    /// Encrypt with specified OAEP padding
    fn encrypt_oaep(plaintext: [UInt8], padding: RsaPadding) -> Result<[UInt8], RsaError> {
        if !padding.is_oaep() && padding != RsaPadding.Pkcs1v15 {
            return Err(RsaError.InvalidPadding)
        }
        @native("rsa_encrypt", self.der, plaintext, padding).map_err(|_| RsaError.EncryptionFailed)
    }
    
    /// Encrypt with PKCS#1 v1.5 padding (legacy)
    fn encrypt_pkcs1v15(plaintext: [UInt8]) -> Result<[UInt8], RsaError> {
        @native("rsa_encrypt", self.der, plaintext, RsaPadding.Pkcs1v15).map_err(|_| RsaError.EncryptionFailed)
    }
    
    /// Verify signature with PSS-SHA256 (recommended)
    fn verify(message: [UInt8], signature: [UInt8]) -> Bool {
        self.verify_pss(message, signature, RsaPadding.PssSha256)
    }
    
    /// Verify with specified PSS padding
    fn verify_pss(message: [UInt8], signature: [UInt8], padding: RsaPadding) -> Bool {
        @native("rsa_verify", self.der, message, signature, padding)
    }
    
    /// Verify with PKCS#1 v1.5 padding (legacy)
    fn verify_pkcs1v15(message: [UInt8], signature: [UInt8]) -> Bool {
        @native("rsa_verify", self.der, message, signature, RsaPadding.Pkcs1v15)
    }
    
    /// Get fingerprint (SHA-256 of DER)
    fn fingerprint() -> String {
        hex.encode(crypto.sha256(self.der))
    }
    
    /// Get short fingerprint
    fn fingerprint_short() -> String {
        self.fingerprint()[0..16]
    }
}

impl Display for RsaPublicKey {
    fn fmt(f: Formatter) {
        f.write(format!("RSA-{} Public Key ({})", self.modulus_bits, self.fingerprint_short()))
    }
}

// =============================================================================
// RSA Private Key
// =============================================================================

/// RSA private key for decryption and signing
struct RsaPrivateKey {
    der: [UInt8]
    modulus_bits: Int
}

impl RsaPrivateKey {
    /// Create from DER bytes
    fn from_der(der: [UInt8]) -> Result<Self, RsaError> {
        let bits = @native("rsa_private_key_bits", der).map_err(|_| RsaError.InvalidKey)?
        Ok(RsaPrivateKey { der: der, modulus_bits: bits })
    }
    
    /// Create from PEM string
    fn from_pem(pem: String) -> Result<Self, RsaError> {
        let der = @native("rsa_private_from_pem", pem).map_err(|_| RsaError.InvalidPem)?
        Self.from_der(der)
    }
    
    /// Create from encrypted PEM
    fn from_encrypted_pem(pem: String, password: String) -> Result<Self, RsaError> {
        let der = @native("rsa_private_from_encrypted_pem", pem, password).map_err(|_| RsaError.InvalidPem)?
        Self.from_der(der)
    }
    
    /// Load from PEM file
    fn from_pem_file(path: String) -> Result<Self, RsaError> {
        let pem = fs.read_string(path).map_err(|e| RsaError.IoError(e.to_string()))?
        Self.from_pem(pem)
    }
    
    /// Export to PEM string
    fn to_pem() -> String {
        @native("rsa_private_to_pem", self.der)
    }
    
    /// Export to encrypted PEM
    fn to_encrypted_pem(password: String) -> String {
        @native("rsa_private_to_encrypted_pem", self.der, password)
    }
    
    /// Export to DER bytes
    fn to_der() -> [UInt8] {
        self.der
    }
    
    /// Get key size in bits
    fn key_bits() -> Int {
        self.modulus_bits
    }
    
    /// Decrypt data with OAEP-SHA256 (recommended)
    fn decrypt(ciphertext: [UInt8]) -> Result<[UInt8], RsaError> {
        self.decrypt_oaep(ciphertext, RsaPadding.OaepSha256)
    }
    
    /// Decrypt with specified OAEP padding
    fn decrypt_oaep(ciphertext: [UInt8], padding: RsaPadding) -> Result<[UInt8], RsaError> {
        @native("rsa_decrypt", self.der, ciphertext, padding).map_err(|_| RsaError.DecryptionFailed)
    }
    
    /// Decrypt with PKCS#1 v1.5 padding (legacy)
    fn decrypt_pkcs1v15(ciphertext: [UInt8]) -> Result<[UInt8], RsaError> {
        @native("rsa_decrypt", self.der, ciphertext, RsaPadding.Pkcs1v15).map_err(|_| RsaError.DecryptionFailed)
    }
    
    /// Sign message with PSS-SHA256 (recommended)
    fn sign(message: [UInt8]) -> Result<[UInt8], RsaError> {
        self.sign_pss(message, RsaPadding.PssSha256)
    }
    
    /// Sign with specified PSS padding
    fn sign_pss(message: [UInt8], padding: RsaPadding) -> Result<[UInt8], RsaError> {
        @native("rsa_sign", self.der, message, padding).map_err(|_| RsaError.SigningFailed)
    }
    
    /// Sign with PKCS#1 v1.5 padding (legacy)
    fn sign_pkcs1v15(message: [UInt8]) -> Result<[UInt8], RsaError> {
        @native("rsa_sign", self.der, message, RsaPadding.Pkcs1v15).map_err(|_| RsaError.SigningFailed)
    }
    
    /// Extract public key
    fn public_key() -> RsaPublicKey {
        let der = @native("rsa_private_to_public", self.der)
        RsaPublicKey { der: der, modulus_bits: self.modulus_bits }
    }
    
    /// Securely zero key from memory
    fn zeroize() {
        crypto.secure_zero(self.der)
    }
}

impl Drop for RsaPrivateKey {
    fn drop() {
        self.zeroize()
    }
}

// =============================================================================
// RSA Signer (for streaming)
// =============================================================================

/// RSA signer for incremental signing
struct RsaSigner {
    private_key: RsaPrivateKey
    hasher: crypto.Hasher
    padding: RsaPadding
}

impl RsaSigner {
    /// Create new signer with PSS-SHA256
    fn new(private_key: RsaPrivateKey) -> Self {
        RsaSigner {
            private_key: private_key,
            hasher: crypto.Hasher.sha256(),
            padding: RsaPadding.PssSha256
        }
    }
    
    /// Create with specified padding
    fn with_padding(private_key: RsaPrivateKey, padding: RsaPadding) -> Self {
        let algo = match padding {
            PssSha256 | OaepSha256 | Pkcs1v15 => crypto.HashAlgorithm.SHA256
            PssSha384 | OaepSha384 => crypto.HashAlgorithm.SHA384
            PssSha512 | OaepSha512 => crypto.HashAlgorithm.SHA512
        }
        RsaSigner {
            private_key: private_key,
            hasher: crypto.Hasher.new(algo),
            padding: padding
        }
    }
    
    /// Update with data
    fn update(data: [UInt8]) -> Self {
        self.hasher.update(data)
        self
    }
    
    /// Update with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Finalize and produce signature
    fn sign() -> Result<[UInt8], RsaError> {
        let digest = self.hasher.finalize()
        self.private_key.sign_pss(digest, self.padding)
    }
}

// =============================================================================
// RSA Verifier (for streaming)
// =============================================================================

/// RSA verifier for incremental verification
struct RsaVerifier {
    public_key: RsaPublicKey
    hasher: crypto.Hasher
    padding: RsaPadding
}

impl RsaVerifier {
    /// Create new verifier with PSS-SHA256
    fn new(public_key: RsaPublicKey) -> Self {
        RsaVerifier {
            public_key: public_key,
            hasher: crypto.Hasher.sha256(),
            padding: RsaPadding.PssSha256
        }
    }
    
    /// Update with data
    fn update(data: [UInt8]) -> Self {
        self.hasher.update(data)
        self
    }
    
    /// Update with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Verify signature
    fn verify(signature: [UInt8]) -> Bool {
        let digest = self.hasher.finalize()
        self.public_key.verify_pss(digest, signature, self.padding)
    }
}

// =============================================================================
// Hybrid Encryption (RSA + AES)
// =============================================================================

/// Hybrid encryption result
struct HybridCiphertext {
    encrypted_key: [UInt8]
    ciphertext: [UInt8]
    nonce: [UInt8]
}

impl HybridCiphertext {
    /// Serialize to bytes
    fn to_bytes() -> [UInt8] {
        var result = []
        // Length-prefixed format
        result.extend((self.encrypted_key.len() as UInt16).to_be_bytes())
        result.extend(self.encrypted_key)
        result.extend((self.nonce.len() as UInt8).to_bytes())
        result.extend(self.nonce)
        result.extend(self.ciphertext)
        result
    }
    
    /// Deserialize from bytes
    fn from_bytes(data: [UInt8]) -> Result<Self, RsaError> {
        if data.len() < 3 {
            return Err(RsaError.InvalidCiphertext)
        }
        
        let key_len = UInt16.from_be_bytes(data[0..2]) as Int
        if data.len() < 2 + key_len + 1 {
            return Err(RsaError.InvalidCiphertext)
        }
        
        let encrypted_key = data[2..2 + key_len]
        let nonce_len = data[2 + key_len] as Int
        
        if data.len() < 2 + key_len + 1 + nonce_len {
            return Err(RsaError.InvalidCiphertext)
        }
        
        let nonce = data[3 + key_len..3 + key_len + nonce_len]
        let ciphertext = data[3 + key_len + nonce_len..]
        
        Ok(HybridCiphertext {
            encrypted_key: encrypted_key,
            ciphertext: ciphertext,
            nonce: nonce
        })
    }
}

/// Hybrid encrypt (RSA-OAEP + AES-GCM)
fn hybrid_encrypt(public_key: RsaPublicKey, plaintext: [UInt8]) -> Result<HybridCiphertext, RsaError> {
    // Generate random AES key
    let aes_key = crypto.random_bytes(32)
    let nonce = crypto.random_bytes(12)
    
    // Encrypt AES key with RSA
    let encrypted_key = public_key.encrypt(aes_key)?
    
    // Encrypt data with AES-GCM
    let ciphertext = crypto.aes_gcm_encrypt(aes_key, nonce, plaintext, [])
        .map_err(|_| RsaError.EncryptionFailed)?
    
    // Zero the AES key
    crypto.secure_zero(aes_key)
    
    Ok(HybridCiphertext {
        encrypted_key: encrypted_key,
        ciphertext: ciphertext,
        nonce: nonce
    })
}

/// Hybrid decrypt (RSA-OAEP + AES-GCM)
fn hybrid_decrypt(private_key: RsaPrivateKey, hybrid: HybridCiphertext) -> Result<[UInt8], RsaError> {
    // Decrypt AES key with RSA
    let aes_key = private_key.decrypt(hybrid.encrypted_key)?
    
    // Decrypt data with AES-GCM
    let plaintext = crypto.aes_gcm_decrypt(aes_key, hybrid.nonce, hybrid.ciphertext, [])
        .map_err(|_| RsaError.DecryptionFailed)?
    
    // Zero the AES key
    crypto.secure_zero(aes_key)
    
    Ok(plaintext)
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Quick sign message
fn sign(private_key: RsaPrivateKey, message: [UInt8]) -> Result<[UInt8], RsaError> {
    private_key.sign(message)
}

/// Quick verify signature
fn verify(public_key: RsaPublicKey, message: [UInt8], signature: [UInt8]) -> Bool {
    public_key.verify(message, signature)
}

/// Quick encrypt
fn encrypt(public_key: RsaPublicKey, plaintext: [UInt8]) -> Result<[UInt8], RsaError> {
    public_key.encrypt(plaintext)
}

/// Quick decrypt
fn decrypt(private_key: RsaPrivateKey, ciphertext: [UInt8]) -> Result<[UInt8], RsaError> {
    private_key.decrypt(ciphertext)
}

// =============================================================================
// Errors
// =============================================================================

enum RsaError {
    KeyTooSmall
    KeyGenerationFailed
    InvalidKey
    InvalidPem
    InvalidPadding
    InvalidCiphertext
    EncryptionFailed
    DecryptionFailed
    SigningFailed
    VerificationFailed
    IoError(String)
}

impl Display for RsaError {
    fn fmt(f: Formatter) {
        match self {
            KeyTooSmall => f.write("RSA key size too small (minimum 2048 bits)")
            KeyGenerationFailed => f.write("RSA key generation failed")
            InvalidKey => f.write("Invalid RSA key")
            InvalidPem => f.write("Invalid PEM format")
            InvalidPadding => f.write("Invalid padding scheme")
            InvalidCiphertext => f.write("Invalid ciphertext")
            EncryptionFailed => f.write("RSA encryption failed")
            DecryptionFailed => f.write("RSA decryption failed")
            SigningFailed => f.write("RSA signing failed")
            VerificationFailed => f.write("RSA verification failed")
            IoError(s) => f.write(format!("I/O error: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "generate key pair" {
    let kp = RsaKeyPair.generate_2048()?
    assert_eq(kp.public_key.key_bits(), 2048)?
    assert_eq(kp.private_key.key_bits(), 2048)?
}

test "encrypt decrypt" {
    let kp = RsaKeyPair.generate_2048()?
    let plaintext = "Hello, RSA!".as_bytes()
    
    let ciphertext = kp.public_key.encrypt(plaintext)?
    let decrypted = kp.private_key.decrypt(ciphertext)?
    
    assert_eq(decrypted, plaintext)?
}

test "sign verify" {
    let kp = RsaKeyPair.generate_2048()?
    let message = "Sign this message".as_bytes()
    
    let signature = kp.private_key.sign(message)?
    assert(kp.public_key.verify(message, signature))?
}

test "sign verify wrong message" {
    let kp = RsaKeyPair.generate_2048()?
    let message = "Original message".as_bytes()
    let wrong_message = "Wrong message".as_bytes()
    
    let signature = kp.private_key.sign(message)?
    assert(!kp.public_key.verify(wrong_message, signature))?
}

test "hybrid encryption" {
    let kp = RsaKeyPair.generate_2048()?
    let plaintext = "Large message that would be too big for RSA alone".as_bytes()
    
    let hybrid = hybrid_encrypt(kp.public_key, plaintext)?
    let decrypted = hybrid_decrypt(kp.private_key, hybrid)?
    
    assert_eq(decrypted, plaintext)?
}

test "pem export import" {
    let kp = RsaKeyPair.generate_2048()?
    let pem = kp.public_key.to_pem()
    
    let imported = RsaPublicKey.from_pem(pem)?
    assert_eq(imported.key_bits(), 2048)?
}

test "extract public key" {
    let kp = RsaKeyPair.generate_2048()?
    let extracted = kp.private_key.public_key()
    
    assert_eq(extracted.fingerprint(), kp.public_key.fingerprint())?
}

test "streaming signer" {
    let kp = RsaKeyPair.generate_2048()?
    
    var signer = RsaSigner.new(kp.private_key)
    signer.update_str("Hello, ")
    signer.update_str("World!")
    let signature = signer.sign()?
    
    var verifier = RsaVerifier.new(kp.public_key)
    verifier.update_str("Hello, World!")
    assert(verifier.verify(signature))?
}
