// =============================================================================
// Vibee OS â€” Discount Module
// E-commerce discounts, coupons, and promotions
// =============================================================================

use money::{Money, usd}
use currency::{Currency}
use datetime::{DateTime}
use uuid::{UUID}

// =============================================================================
// Discount Types
// =============================================================================

/// Type of discount
enum DiscountType {
    Percentage(Decimal)
    FixedAmount(Money)
    FreeShipping
    BuyXGetY(Int, Int, Decimal)
}

impl DiscountType {
    fn display_name() -> String {
        match self {
            DiscountType.Percentage(pct) => "\(pct)% off"
            DiscountType.FixedAmount(amount) => "\(amount.format()) off"
            DiscountType.FreeShipping => "Free Shipping"
            DiscountType.BuyXGetY(x, y, pct) => "Buy \(x) Get \(y) at \(pct)% off"
        }
    }
}

/// Discount application scope
enum DiscountScope {
    Order
    Product(String)
    Category(String)
    Collection(String)
    ShippingLine
}

/// Discount status
enum DiscountStatus {
    Active
    Scheduled
    Expired
    Disabled
}

// =============================================================================
// Discount
// =============================================================================

/// Discount/Coupon definition
struct Discount {
    id: String
    code: String
    name: String
    description: Option<String>
    discount_type: DiscountType
    scope: DiscountScope
    status: DiscountStatus
    value: Decimal
    currency: Currency
    minimum_order: Option<Money>
    maximum_discount: Option<Money>
    usage_limit: Option<Int>
    usage_count: Int
    per_customer_limit: Option<Int>
    starts_at: Option<DateTime>
    ends_at: Option<DateTime>
    eligible_products: [String]
    eligible_categories: [String]
    excluded_products: [String]
    customer_eligibility: CustomerEligibility
    stackable: Bool
    first_order_only: Bool
    metadata: Map<String, String>
    created_at: DateTime
    updated_at: DateTime
}

impl Discount {
    /// Create percentage discount
    fn percentage(code: String, percent: Decimal) -> Self {
        let now = DateTime.now()
        Discount {
            id: UUID.v4().to_string(),
            code: code.to_upper(),
            name: "\(percent)% Off",
            description: None,
            discount_type: DiscountType.Percentage(percent),
            scope: DiscountScope.Order,
            status: DiscountStatus.Active,
            value: percent,
            currency: Currency.USD,
            minimum_order: None,
            maximum_discount: None,
            usage_limit: None,
            usage_count: 0,
            per_customer_limit: None,
            starts_at: None,
            ends_at: None,
            eligible_products: [],
            eligible_categories: [],
            excluded_products: [],
            customer_eligibility: CustomerEligibility.Everyone,
            stackable: false,
            first_order_only: false,
            metadata: Map.empty(),
            created_at: now,
            updated_at: now
        }
    }
    
    /// Create fixed amount discount
    fn fixed_amount(code: String, amount: Money) -> Self {
        var discount = Self.percentage(code, Decimal.zero())
        discount.discount_type = DiscountType.FixedAmount(amount)
        discount.value = amount.as_decimal()
        discount.currency = amount.currency
        discount.name = "\(amount.format()) Off"
        discount
    }
    
    /// Create free shipping discount
    fn free_shipping(code: String) -> Self {
        var discount = Self.percentage(code, Decimal.zero())
        discount.discount_type = DiscountType.FreeShipping
        discount.scope = DiscountScope.ShippingLine
        discount.name = "Free Shipping"
        discount
    }
    
    /// Create buy X get Y discount
    fn buy_x_get_y(code: String, buy: Int, get: Int, percent_off: Decimal) -> Self {
        var discount = Self.percentage(code, percent_off)
        discount.discount_type = DiscountType.BuyXGetY(buy, get, percent_off)
        discount.name = "Buy \(buy) Get \(get) at \(percent_off)% Off"
        discount
    }
    
    /// Builder methods
    fn with_name(name: String) -> Self {
        self.name = name
        self
    }
    
    fn with_description(desc: String) -> Self {
        self.description = Some(desc)
        self
    }
    
    fn with_minimum(min: Money) -> Self {
        self.minimum_order = Some(min)
        self
    }
    
    fn with_maximum(max: Money) -> Self {
        self.maximum_discount = Some(max)
        self
    }
    
    fn with_usage_limit(limit: Int) -> Self {
        self.usage_limit = Some(limit)
        self
    }
    
    fn with_customer_limit(limit: Int) -> Self {
        self.per_customer_limit = Some(limit)
        self
    }
    
    fn with_date_range(start: DateTime, end: DateTime) -> Self {
        self.starts_at = Some(start)
        self.ends_at = Some(end)
        self
    }
    
    fn for_products(products: [String]) -> Self {
        self.eligible_products = products
        self.scope = DiscountScope.Product(products[0].clone())
        self
    }
    
    fn for_categories(categories: [String]) -> Self {
        self.eligible_categories = categories
        self.scope = DiscountScope.Category(categories[0].clone())
        self
    }
    
    fn exclude_products(products: [String]) -> Self {
        self.excluded_products = products
        self
    }
    
    fn for_first_order() -> Self {
        self.first_order_only = true
        self
    }
    
    fn make_stackable() -> Self {
        self.stackable = true
        self
    }
    
    /// Check if discount is valid
    fn is_valid() -> Bool {
        if self.status != DiscountStatus.Active {
            return false
        }
        
        let now = DateTime.now()
        
        if let Some(start) = self.starts_at {
            if now < start { return false }
        }
        
        if let Some(end) = self.ends_at {
            if now > end { return false }
        }
        
        if let Some(limit) = self.usage_limit {
            if self.usage_count >= limit { return false }
        }
        
        true
    }
    
    /// Check if discount applies to order
    fn applies_to_order(subtotal: Money) -> Bool {
        if !self.is_valid() { return false }
        
        if let Some(min) = self.minimum_order {
            if subtotal < min { return false }
        }
        
        true
    }
    
    /// Check if discount applies to product
    fn applies_to_product(product_id: String, category_ids: [String]) -> Bool {
        if self.excluded_products.contains(product_id) {
            return false
        }
        
        if !self.eligible_products.is_empty() {
            return self.eligible_products.contains(product_id)
        }
        
        if !self.eligible_categories.is_empty() {
            return category_ids.iter().any(|c| self.eligible_categories.contains(c))
        }
        
        true
    }
    
    /// Calculate discount amount
    fn calculate(subtotal: Money) -> Money {
        if !self.applies_to_order(subtotal) {
            return Money.zero(subtotal.currency)
        }
        
        let amount = match self.discount_type {
            DiscountType.Percentage(pct) => subtotal.percent(pct)
            DiscountType.FixedAmount(fixed) => fixed
            DiscountType.FreeShipping => Money.zero(subtotal.currency)
            DiscountType.BuyXGetY(_, _, _) => Money.zero(subtotal.currency)
        }
        
        // Apply maximum cap
        if let Some(max) = self.maximum_discount {
            if amount > max { return max }
        }
        
        amount
    }
    
    /// Record usage
    fn record_usage() {
        self.usage_count += 1
        self.updated_at = DateTime.now()
    }
    
    /// Check remaining uses
    fn remaining_uses() -> Option<Int> {
        self.usage_limit.map(|limit| (limit - self.usage_count).max(0))
    }
}

/// Customer eligibility
enum CustomerEligibility {
    Everyone
    SpecificCustomers([String])
    CustomerGroups([String])
}

// =============================================================================
// Promotion
// =============================================================================

/// Automatic promotion (no code required)
struct Promotion {
    id: String
    name: String
    description: Option<String>
    discount_type: DiscountType
    scope: DiscountScope
    status: DiscountStatus
    priority: Int
    conditions: [PromotionCondition]
    starts_at: Option<DateTime>
    ends_at: Option<DateTime>
    stackable: Bool
    created_at: DateTime
}

impl Promotion {
    fn new(name: String, discount_type: DiscountType) -> Self {
        Promotion {
            id: UUID.v4().to_string(),
            name: name,
            description: None,
            discount_type: discount_type,
            scope: DiscountScope.Order,
            status: DiscountStatus.Active,
            priority: 0,
            conditions: [],
            starts_at: None,
            ends_at: None,
            stackable: false,
            created_at: DateTime.now()
        }
    }
    
    fn add_condition(condition: PromotionCondition) -> Self {
        self.conditions.push(condition)
        self
    }
    
    fn with_priority(priority: Int) -> Self {
        self.priority = priority
        self
    }
    
    fn is_active() -> Bool {
        if self.status != DiscountStatus.Active { return false }
        
        let now = DateTime.now()
        if let Some(start) = self.starts_at {
            if now < start { return false }
        }
        if let Some(end) = self.ends_at {
            if now > end { return false }
        }
        true
    }
    
    fn evaluate(context: PromotionContext) -> Bool {
        if !self.is_active() { return false }
        self.conditions.iter().all(|c| c.evaluate(context))
    }
}

/// Promotion condition
enum PromotionCondition {
    MinimumOrder(Money)
    MinimumQuantity(Int)
    ContainsProduct(String)
    ContainsCategory(String)
    CustomerGroup(String)
    FirstOrder
    DayOfWeek([Int])
    TimeRange(Int, Int)
}

impl PromotionCondition {
    fn evaluate(context: PromotionContext) -> Bool {
        match self {
            PromotionCondition.MinimumOrder(min) => context.subtotal >= min
            PromotionCondition.MinimumQuantity(qty) => context.total_quantity >= qty
            PromotionCondition.ContainsProduct(id) => context.product_ids.contains(id)
            PromotionCondition.ContainsCategory(id) => context.category_ids.contains(id)
            PromotionCondition.CustomerGroup(group) => context.customer_groups.contains(group)
            PromotionCondition.FirstOrder => context.is_first_order
            PromotionCondition.DayOfWeek(days) => days.contains(context.current_day)
            PromotionCondition.TimeRange(start, end) => {
                context.current_hour >= start && context.current_hour < end
            }
        }
    }
}

/// Context for promotion evaluation
struct PromotionContext {
    subtotal: Money
    total_quantity: Int
    product_ids: [String]
    category_ids: [String]
    customer_id: Option<String>
    customer_groups: [String]
    is_first_order: Bool
    current_day: Int
    current_hour: Int
}

impl PromotionContext {
    fn new(subtotal: Money, quantity: Int) -> Self {
        let now = DateTime.now()
        PromotionContext {
            subtotal: subtotal,
            total_quantity: quantity,
            product_ids: [],
            category_ids: [],
            customer_id: None,
            customer_groups: [],
            is_first_order: false,
            current_day: now.weekday(),
            current_hour: now.hour()
        }
    }
}

// =============================================================================
// Discount Service
// =============================================================================

actor DiscountService {
    state discounts: Map<String, Discount>
    state by_code: Map<String, String>
    state promotions: [Promotion]
    state customer_usage: Map<String, Map<String, Int>>
    
    fn new() -> Self {
        DiscountService {
            discounts: Map.empty(),
            by_code: Map.empty(),
            promotions: [],
            customer_usage: Map.empty()
        }
    }
    
    fn create(discount: Discount) -> Result<Discount, DiscountError> {
        if self.by_code.contains_key(discount.code) {
            return Err(DiscountError.CodeExists)
        }
        
        self.by_code.insert(discount.code.clone(), discount.id.clone())
        self.discounts.insert(discount.id.clone(), discount.clone())
        Ok(discount)
    }
    
    fn get(id: String) -> Option<Discount> {
        self.discounts.get(id)
    }
    
    fn get_by_code(code: String) -> Option<Discount> {
        self.by_code.get(code.to_upper()).and_then(|id| self.discounts.get(id))
    }
    
    fn validate(code: String, subtotal: Money, customer_id: Option<String>) -> Result<Discount, DiscountError> {
        let discount = self.get_by_code(code).ok_or(DiscountError.NotFound)?
        
        if !discount.is_valid() {
            return Err(DiscountError.Expired)
        }
        
        if !discount.applies_to_order(subtotal) {
            if let Some(min) = discount.minimum_order {
                return Err(DiscountError.MinimumNotMet(min))
            }
        }
        
        // Check per-customer limit
        if let Some(limit) = discount.per_customer_limit {
            if let Some(cid) = customer_id {
                let usage = self.customer_usage
                    .get(cid)
                    .and_then(|m| m.get(discount.id))
                    .unwrap_or(0)
                if usage >= limit {
                    return Err(DiscountError.CustomerLimitReached)
                }
            }
        }
        
        Ok(discount)
    }
    
    fn apply(code: String, customer_id: Option<String>) -> Result<(), DiscountError> {
        let discount = self.get_by_code(code).ok_or(DiscountError.NotFound)?
        
        // Record usage
        discount.record_usage()
        self.discounts.insert(discount.id.clone(), discount.clone())
        
        // Record customer usage
        if let Some(cid) = customer_id {
            let customer_map = self.customer_usage.get(cid.clone()).unwrap_or(Map.empty())
            let count = customer_map.get(discount.id.clone()).unwrap_or(0)
            customer_map.insert(discount.id.clone(), count + 1)
            self.customer_usage.insert(cid, customer_map)
        }
        
        Ok(())
    }
    
    fn add_promotion(promotion: Promotion) {
        self.promotions.push(promotion)
        self.promotions.sort_by(|a, b| b.priority.cmp(a.priority))
    }
    
    fn get_applicable_promotions(context: PromotionContext) -> [Promotion] {
        self.promotions.iter()
            .filter(|p| p.evaluate(context))
            .collect()
    }
    
    fn list_active() -> [Discount] {
        self.discounts.values().filter(|d| d.is_valid()).collect()
    }
    
    fn disable(id: String) -> Result<(), DiscountError> {
        if let Some(discount) = self.discounts.get_mut(id) {
            discount.status = DiscountStatus.Disabled
            discount.updated_at = DateTime.now()
            Ok(())
        } else {
            Err(DiscountError.NotFound)
        }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum DiscountError {
    NotFound
    CodeExists
    Expired
    MinimumNotMet(Money)
    UsageLimitReached
    CustomerLimitReached
    NotApplicable
}

impl Display for DiscountError {
    fn fmt(f: Formatter) {
        f.write(match self {
            NotFound => "Discount not found"
            CodeExists => "Discount code already exists"
            Expired => "Discount has expired"
            MinimumNotMet(min) => "Minimum order of \(min.format()) required"
            UsageLimitReached => "Discount usage limit reached"
            CustomerLimitReached => "You have already used this discount"
            NotApplicable => "Discount not applicable"
        })
    }
}

// =============================================================================
// Tests
// =============================================================================

test "percentage discount" {
    let discount = Discount.percentage("SAVE20", Decimal.from_int(20))
    
    assert_eq(discount.code, "SAVE20")?
    assert(discount.is_valid())?
    
    let amount = discount.calculate(usd(100.00))
    assert_eq(amount.format(), "$20.00")?
}

test "fixed amount discount" {
    let discount = Discount.fixed_amount("FLAT10", usd(10.00))
    
    let amount = discount.calculate(usd(50.00))
    assert_eq(amount.format(), "$10.00")?
}

test "minimum order requirement" {
    let discount = Discount.percentage("MIN50", Decimal.from_int(10))
        .with_minimum(usd(50.00))
    
    assert(!discount.applies_to_order(usd(30.00)))?
    assert(discount.applies_to_order(usd(60.00)))?
}

test "maximum discount cap" {
    let discount = Discount.percentage("MAX25", Decimal.from_int(50))
        .with_maximum(usd(25.00))
    
    let amount = discount.calculate(usd(100.00))
    assert_eq(amount.format(), "$25.00")?
}

test "usage limit" {
    var discount = Discount.percentage("LIMITED", Decimal.from_int(15))
        .with_usage_limit(3)
    
    assert(discount.is_valid())?
    assert_eq(discount.remaining_uses(), Some(3))?
    
    discount.record_usage()
    discount.record_usage()
    discount.record_usage()
    
    assert(!discount.is_valid())?
    assert_eq(discount.remaining_uses(), Some(0))?
}

test "date range validation" {
    let past = DateTime.now() - Duration.days(10)
    let future = DateTime.now() + Duration.days(10)
    
    let active = Discount.percentage("ACTIVE", Decimal.from_int(10))
        .with_date_range(past, future)
    assert(active.is_valid())?
    
    let expired = Discount.percentage("EXPIRED", Decimal.from_int(10))
        .with_date_range(past - Duration.days(20), past)
    assert(!expired.is_valid())?
}

test "promotion conditions" {
    let promo = Promotion.new("Weekend Sale", DiscountType.Percentage(Decimal.from_int(15)))
        .add_condition(PromotionCondition.MinimumOrder(usd(50.00)))
        .add_condition(PromotionCondition.MinimumQuantity(2))
    
    let context1 = PromotionContext {
        subtotal: usd(100.00),
        total_quantity: 3,
        product_ids: [],
        category_ids: [],
        customer_id: None,
        customer_groups: [],
        is_first_order: false,
        current_day: 1,
        current_hour: 12
    }
    assert(promo.evaluate(context1))?
    
    let context2 = PromotionContext {
        subtotal: usd(30.00),
        total_quantity: 1,
        product_ids: [],
        category_ids: [],
        customer_id: None,
        customer_groups: [],
        is_first_order: false,
        current_day: 1,
        current_hour: 12
    }
    assert(!promo.evaluate(context2))?
}
