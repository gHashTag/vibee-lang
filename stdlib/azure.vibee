// =============================================================================
// Vibee OS â€” Azure Module
// Microsoft Azure SDK
// =============================================================================

// -----------------------------------------------------------------------------
// Azure Client Configuration
// -----------------------------------------------------------------------------

struct AzureConfig {
    subscription_id: String
    tenant_id: String?
    client_id: String?
    client_secret: String?
    resource_group: String?
    location: String?
}

impl AzureConfig {
    fn new(subscription_id: String) -> Self {
        AzureConfig {
            subscription_id: subscription_id,
            tenant_id: None,
            client_id: None,
            client_secret: None,
            resource_group: None,
            location: None
        }
    }
    
    fn from_env() -> Result<Self, AzureError> {
        @native("azure_config_from_env")
    }
    
    fn from_service_principal(tenant_id: String, client_id: String, client_secret: String) -> Self {
        var config = Self.new("")
        config.tenant_id = Some(tenant_id)
        config.client_id = Some(client_id)
        config.client_secret = Some(client_secret)
        config
    }
    
    fn from_managed_identity() -> Result<Self, AzureError> {
        @native("azure_config_from_msi")
    }
    
    fn from_cli() -> Result<Self, AzureError> {
        @native("azure_config_from_cli")
    }
    
    fn with_resource_group(rg: String) -> Self {
        self.resource_group = Some(rg)
        self
    }
    
    fn with_location(loc: String) -> Self {
        self.location = Some(loc)
        self
    }
}

// -----------------------------------------------------------------------------
// Resource Management
// -----------------------------------------------------------------------------

actor ResourceClient {
    state config: AzureConfig
    
    init(config: AzureConfig) { self.config = config }
    
    // Resource Groups
    on list_resource_groups() -> Result<[ResourceGroup], AzureError> {
        @native("azure_list_resource_groups", self.config)
    }
    
    on get_resource_group(name: String) -> Result<ResourceGroup, AzureError> {
        @native("azure_get_resource_group", self.config, name)
    }
    
    on create_resource_group(name: String, location: String, tags: Map<String, String> = Map.empty()) -> Result<ResourceGroup, AzureError> {
        @native("azure_create_resource_group", self.config, name, location, tags)
    }
    
    on delete_resource_group(name: String) -> Result<(), AzureError> {
        @native("azure_delete_resource_group", self.config, name)
    }
    
    // Resources
    on list_resources(resource_group: String? = None) -> Result<[Resource], AzureError> {
        @native("azure_list_resources", self.config, resource_group)
    }
    
    on get_resource(resource_id: String) -> Result<Resource, AzureError> {
        @native("azure_get_resource", self.config, resource_id)
    }
    
    on delete_resource(resource_id: String) -> Result<(), AzureError> {
        @native("azure_delete_resource", self.config, resource_id)
    }
}

struct ResourceGroup {
    id: String
    name: String
    location: String
    tags: Map<String, String>
    provisioning_state: String
}

struct Resource {
    id: String
    name: String
    type_: String
    location: String
    resource_group: String
    tags: Map<String, String>
}

// -----------------------------------------------------------------------------
// Virtual Machines
// -----------------------------------------------------------------------------

actor ComputeClient {
    state config: AzureConfig
    
    init(config: AzureConfig) { self.config = config }
    
    // Virtual Machines
    on list_vms(resource_group: String) -> Result<[VirtualMachine], AzureError> {
        @native("azure_compute_list_vms", self.config, resource_group)
    }
    
    on get_vm(resource_group: String, name: String) -> Result<VirtualMachine, AzureError> {
        @native("azure_compute_get_vm", self.config, resource_group, name)
    }
    
    on create_vm(resource_group: String, params: CreateVmParams) -> Result<VirtualMachine, AzureError> {
        @native("azure_compute_create_vm", self.config, resource_group, params)
    }
    
    on delete_vm(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_compute_delete_vm", self.config, resource_group, name)
    }
    
    on start_vm(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_compute_start_vm", self.config, resource_group, name)
    }
    
    on stop_vm(resource_group: String, name: String, deallocate: Bool = true) -> Result<(), AzureError> {
        @native("azure_compute_stop_vm", self.config, resource_group, name, deallocate)
    }
    
    on restart_vm(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_compute_restart_vm", self.config, resource_group, name)
    }
    
    on run_command(resource_group: String, name: String, command: String) -> Result<RunCommandResult, AzureError> {
        @native("azure_compute_run_command", self.config, resource_group, name, command)
    }
    
    // VM Sizes
    on list_vm_sizes(location: String) -> Result<[VmSize], AzureError> {
        @native("azure_compute_list_vm_sizes", self.config, location)
    }
    
    // Disks
    on list_disks(resource_group: String) -> Result<[ManagedDisk], AzureError> {
        @native("azure_compute_list_disks", self.config, resource_group)
    }
    
    on create_disk(resource_group: String, name: String, size_gb: Int, sku: String = "Standard_LRS") -> Result<ManagedDisk, AzureError> {
        @native("azure_compute_create_disk", self.config, resource_group, name, size_gb, sku)
    }
    
    on delete_disk(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_compute_delete_disk", self.config, resource_group, name)
    }
    
    // Images
    on list_images(resource_group: String? = None) -> Result<[VmImage], AzureError> {
        @native("azure_compute_list_images", self.config, resource_group)
    }
}

struct VirtualMachine {
    id: String
    name: String
    location: String
    vm_size: String
    provisioning_state: String
    power_state: PowerState
    os_type: OsType
    network_interfaces: [String]
    tags: Map<String, String>
}

enum PowerState { Running, Stopped, Deallocated, Starting, Stopping, Unknown }
enum OsType { Windows, Linux }

struct CreateVmParams {
    name: String
    vm_size: String
    image_reference: ImageReference
    os_disk: OsDiskParams
    network_interface_id: String
    admin_username: String
    admin_password: String?
    ssh_public_key: String?
    tags: Map<String, String>
}

impl CreateVmParams {
    fn linux(name: String, vm_size: String, image: ImageReference, nic_id: String, admin: String, ssh_key: String) -> Self {
        CreateVmParams {
            name: name,
            vm_size: vm_size,
            image_reference: image,
            os_disk: OsDiskParams { name: "\(name)-osdisk", size_gb: 30, storage_type: "Standard_LRS" },
            network_interface_id: nic_id,
            admin_username: admin,
            admin_password: None,
            ssh_public_key: Some(ssh_key),
            tags: Map.empty()
        }
    }
    
    fn windows(name: String, vm_size: String, image: ImageReference, nic_id: String, admin: String, password: String) -> Self {
        CreateVmParams {
            name: name,
            vm_size: vm_size,
            image_reference: image,
            os_disk: OsDiskParams { name: "\(name)-osdisk", size_gb: 128, storage_type: "Standard_LRS" },
            network_interface_id: nic_id,
            admin_username: admin,
            admin_password: Some(password),
            ssh_public_key: None,
            tags: Map.empty()
        }
    }
}

struct ImageReference { publisher: String, offer: String, sku: String, version: String }

impl ImageReference {
    fn ubuntu_2204() -> Self { ImageReference { publisher: "Canonical", offer: "0001-com-ubuntu-server-jammy", sku: "22_04-lts", version: "latest" } }
    fn debian_11() -> Self { ImageReference { publisher: "Debian", offer: "debian-11", sku: "11", version: "latest" } }
    fn windows_2022() -> Self { ImageReference { publisher: "MicrosoftWindowsServer", offer: "WindowsServer", sku: "2022-datacenter", version: "latest" } }
}

struct OsDiskParams { name: String, size_gb: Int, storage_type: String }
struct ManagedDisk { id: String, name: String, location: String, size_gb: Int, sku: String, provisioning_state: String }
struct VmSize { name: String, cores: Int, memory_mb: Int, max_data_disks: Int }
struct VmImage { id: String, name: String, location: String }
struct RunCommandResult { value: [RunCommandOutput] }
struct RunCommandOutput { code: String, message: String }

// -----------------------------------------------------------------------------
// Networking
// -----------------------------------------------------------------------------

actor NetworkClient {
    state config: AzureConfig
    
    init(config: AzureConfig) { self.config = config }
    
    // Virtual Networks
    on list_vnets(resource_group: String) -> Result<[VirtualNetwork], AzureError> {
        @native("azure_network_list_vnets", self.config, resource_group)
    }
    
    on create_vnet(resource_group: String, name: String, address_space: [String], location: String) -> Result<VirtualNetwork, AzureError> {
        @native("azure_network_create_vnet", self.config, resource_group, name, address_space, location)
    }
    
    on delete_vnet(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_network_delete_vnet", self.config, resource_group, name)
    }
    
    // Subnets
    on list_subnets(resource_group: String, vnet_name: String) -> Result<[AzureSubnet], AzureError> {
        @native("azure_network_list_subnets", self.config, resource_group, vnet_name)
    }
    
    on create_subnet(resource_group: String, vnet_name: String, name: String, address_prefix: String) -> Result<AzureSubnet, AzureError> {
        @native("azure_network_create_subnet", self.config, resource_group, vnet_name, name, address_prefix)
    }
    
    // Network Interfaces
    on list_nics(resource_group: String) -> Result<[NetworkInterface], AzureError> {
        @native("azure_network_list_nics", self.config, resource_group)
    }
    
    on create_nic(resource_group: String, name: String, subnet_id: String, location: String) -> Result<NetworkInterface, AzureError> {
        @native("azure_network_create_nic", self.config, resource_group, name, subnet_id, location)
    }
    
    on delete_nic(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_network_delete_nic", self.config, resource_group, name)
    }
    
    // Public IPs
    on list_public_ips(resource_group: String) -> Result<[PublicIpAddress], AzureError> {
        @native("azure_network_list_public_ips", self.config, resource_group)
    }
    
    on create_public_ip(resource_group: String, name: String, location: String, sku: String = "Basic") -> Result<PublicIpAddress, AzureError> {
        @native("azure_network_create_public_ip", self.config, resource_group, name, location, sku)
    }
    
    // Network Security Groups
    on list_nsgs(resource_group: String) -> Result<[NetworkSecurityGroup], AzureError> {
        @native("azure_network_list_nsgs", self.config, resource_group)
    }
    
    on create_nsg(resource_group: String, name: String, location: String) -> Result<NetworkSecurityGroup, AzureError> {
        @native("azure_network_create_nsg", self.config, resource_group, name, location)
    }
    
    on add_nsg_rule(resource_group: String, nsg_name: String, rule: SecurityRule) -> Result<SecurityRule, AzureError> {
        @native("azure_network_add_nsg_rule", self.config, resource_group, nsg_name, rule)
    }
}

struct VirtualNetwork { id: String, name: String, location: String, address_space: [String], subnets: [AzureSubnet] }
struct AzureSubnet { id: String, name: String, address_prefix: String, network_security_group: String? }
struct NetworkInterface { id: String, name: String, location: String, ip_configurations: [IpConfiguration] }
struct IpConfiguration { name: String, private_ip: String, public_ip_id: String?, subnet_id: String }
struct PublicIpAddress { id: String, name: String, location: String, ip_address: String?, allocation_method: String }
struct NetworkSecurityGroup { id: String, name: String, location: String, security_rules: [SecurityRule] }
struct SecurityRule { name: String, priority: Int, direction: String, access: String, protocol: String, source_port_range: String, destination_port_range: String, source_address_prefix: String, destination_address_prefix: String }

// -----------------------------------------------------------------------------
// Storage
// -----------------------------------------------------------------------------

actor StorageClient {
    state config: AzureConfig
    
    init(config: AzureConfig) { self.config = config }
    
    // Storage Accounts
    on list_storage_accounts(resource_group: String? = None) -> Result<[StorageAccount], AzureError> {
        @native("azure_storage_list_accounts", self.config, resource_group)
    }
    
    on create_storage_account(resource_group: String, name: String, location: String, sku: String = "Standard_LRS") -> Result<StorageAccount, AzureError> {
        @native("azure_storage_create_account", self.config, resource_group, name, location, sku)
    }
    
    on delete_storage_account(resource_group: String, name: String) -> Result<(), AzureError> {
        @native("azure_storage_delete_account", self.config, resource_group, name)
    }
    
    on get_storage_keys(resource_group: String, account_name: String) -> Result<[StorageKey], AzureError> {
        @native("azure_storage_get_keys", self.config, resource_group, account_name)
    }
}

struct StorageAccount { id: String, name: String, location: String, sku: String, kind: String, provisioning_state: String }
struct StorageKey { key_name: String, value: String, permissions: String }

// Blob Storage Client
actor BlobClient {
    state account_name: String
    state account_key: String
    state endpoint: String
    
    init(account_name: String, account_key: String) {
        self.account_name = account_name
        self.account_key = account_key
        self.endpoint = "https://\(account_name).blob.core.windows.net"
    }
    
    on list_containers() -> Result<[BlobContainer], AzureError> {
        @native("azure_blob_list_containers", self.account_name, self.account_key)
    }
    
    on create_container(name: String, access_level: String = "private") -> Result<BlobContainer, AzureError> {
        @native("azure_blob_create_container", self.account_name, self.account_key, name, access_level)
    }
    
    on delete_container(name: String) -> Result<(), AzureError> {
        @native("azure_blob_delete_container", self.account_name, self.account_key, name)
    }
    
    on list_blobs(container: String, prefix: String? = None) -> Result<[Blob], AzureError> {
        @native("azure_blob_list_blobs", self.account_name, self.account_key, container, prefix)
    }
    
    on upload_blob(container: String, name: String, data: [Byte], content_type: String? = None) -> Result<Blob, AzureError> {
        @native("azure_blob_upload", self.account_name, self.account_key, container, name, data, content_type)
    }
    
    on download_blob(container: String, name: String) -> Result<[Byte], AzureError> {
        @native("azure_blob_download", self.account_name, self.account_key, container, name)
    }
    
    on delete_blob(container: String, name: String) -> Result<(), AzureError> {
        @native("azure_blob_delete", self.account_name, self.account_key, container, name)
    }
    
    on generate_sas_url(container: String, name: String, expiry: Duration, permissions: String = "r") -> Result<String, AzureError> {
        @native("azure_blob_generate_sas", self.account_name, self.account_key, container, name, expiry, permissions)
    }
}

struct BlobContainer { name: String, last_modified: DateTime, public_access: String? }
struct Blob { name: String, container: String, size: Int64, content_type: String, last_modified: DateTime, etag: String }

// -----------------------------------------------------------------------------
// Service Bus
// -----------------------------------------------------------------------------

actor ServiceBusClient {
    state connection_string: String
    
    init(connection_string: String) { self.connection_string = connection_string }
    
    // Queues
    on send_message(queue: String, body: String, properties: Map<String, String> = Map.empty()) -> Result<(), AzureError> {
        @native("azure_servicebus_send", self.connection_string, queue, body, properties)
    }
    
    on send_json<T: Serialize>(queue: String, data: T) -> Result<(), AzureError> {
        self.send_message(queue, json.encode(data), Map.from([("content-type", "application/json")]))
    }
    
    on receive_messages(queue: String, max_messages: Int = 1, wait_time: Duration = 30.seconds()) -> Result<[ServiceBusMessage], AzureError> {
        @native("azure_servicebus_receive", self.connection_string, queue, max_messages, wait_time)
    }
    
    on complete_message(queue: String, lock_token: String) -> Result<(), AzureError> {
        @native("azure_servicebus_complete", self.connection_string, queue, lock_token)
    }
    
    on abandon_message(queue: String, lock_token: String) -> Result<(), AzureError> {
        @native("azure_servicebus_abandon", self.connection_string, queue, lock_token)
    }
    
    // Topics
    on publish_to_topic(topic: String, body: String, properties: Map<String, String> = Map.empty()) -> Result<(), AzureError> {
        @native("azure_servicebus_publish", self.connection_string, topic, body, properties)
    }
    
    on receive_from_subscription(topic: String, subscription: String, max_messages: Int = 1) -> Result<[ServiceBusMessage], AzureError> {
        @native("azure_servicebus_receive_sub", self.connection_string, topic, subscription, max_messages)
    }
}

struct ServiceBusMessage {
    message_id: String
    body: String
    lock_token: String
    content_type: String?
    properties: Map<String, String>
    enqueued_time: DateTime
}

// -----------------------------------------------------------------------------
// Key Vault
// -----------------------------------------------------------------------------

actor KeyVaultClient {
    state vault_url: String
    state config: AzureConfig
    
    init(vault_url: String, config: AzureConfig) {
        self.vault_url = vault_url
        self.config = config
    }
    
    // Secrets
    on get_secret(name: String, version: String? = None) -> Result<Secret, AzureError> {
        @native("azure_keyvault_get_secret", self.vault_url, self.config, name, version)
    }
    
    on set_secret(name: String, value: String, content_type: String? = None) -> Result<Secret, AzureError> {
        @native("azure_keyvault_set_secret", self.vault_url, self.config, name, value, content_type)
    }
    
    on delete_secret(name: String) -> Result<DeletedSecret, AzureError> {
        @native("azure_keyvault_delete_secret", self.vault_url, self.config, name)
    }
    
    on list_secrets() -> Result<[SecretProperties], AzureError> {
        @native("azure_keyvault_list_secrets", self.vault_url, self.config)
    }
    
    // Keys
    on get_key(name: String, version: String? = None) -> Result<KeyVaultKey, AzureError> {
        @native("azure_keyvault_get_key", self.vault_url, self.config, name, version)
    }
    
    on create_key(name: String, key_type: String, key_size: Int? = None) -> Result<KeyVaultKey, AzureError> {
        @native("azure_keyvault_create_key", self.vault_url, self.config, name, key_type, key_size)
    }
    
    on encrypt(key_name: String, algorithm: String, plaintext: [Byte]) -> Result<[Byte], AzureError> {
        @native("azure_keyvault_encrypt", self.vault_url, self.config, key_name, algorithm, plaintext)
    }
    
    on decrypt(key_name: String, algorithm: String, ciphertext: [Byte]) -> Result<[Byte], AzureError> {
        @native("azure_keyvault_decrypt", self.vault_url, self.config, key_name, algorithm, ciphertext)
    }
}

struct Secret { id: String, value: String, content_type: String?, attributes: SecretAttributes }
struct SecretAttributes { enabled: Bool, created: DateTime, updated: DateTime, expires: DateTime? }
struct SecretProperties { id: String, name: String, content_type: String?, attributes: SecretAttributes }
struct DeletedSecret { id: String, recovery_id: String, scheduled_purge_date: DateTime }
struct KeyVaultKey { id: String, name: String, key_type: String, key_ops: [String] }

// -----------------------------------------------------------------------------
// Azure Functions
// -----------------------------------------------------------------------------

actor FunctionsClient {
    state config: AzureConfig
    
    init(config: AzureConfig) { self.config = config }
    
    on list_function_apps(resource_group: String) -> Result<[FunctionApp], AzureError> {
        @native("azure_functions_list_apps", self.config, resource_group)
    }
    
    on get_function_app(resource_group: String, name: String) -> Result<FunctionApp, AzureError> {
        @native("azure_functions_get_app", self.config, resource_group, name)
    }
    
    on list_functions(resource_group: String, app_name: String) -> Result<[AzureFunction], AzureError> {
        @native("azure_functions_list", self.config, resource_group, app_name)
    }
    
    on invoke_function(resource_group: String, app_name: String, function_name: String, data: String) -> Result<String, AzureError> {
        @native("azure_functions_invoke", self.config, resource_group, app_name, function_name, data)
    }
}

struct FunctionApp { id: String, name: String, location: String, state: String, default_hostname: String }
struct AzureFunction { id: String, name: String, trigger_type: String, is_disabled: Bool }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum AzureError {
    Authentication(String)
    Authorization(String)
    NotFound(String)
    Conflict(String)
    BadRequest(String)
    QuotaExceeded(String)
    ServiceError(String, Int)
    Timeout
    NetworkError(String)
    
    fn message() -> String {
        match self {
            .Authentication(m) => "Authentication error: \(m)"
            .Authorization(m) => "Authorization error: \(m)"
            .NotFound(m) => "Not found: \(m)"
            .Conflict(m) => "Conflict: \(m)"
            .BadRequest(m) => "Bad request: \(m)"
            .QuotaExceeded(m) => "Quota exceeded: \(m)"
            .ServiceError(m, c) => "Service error (\(c)): \(m)"
            .Timeout => "Request timed out"
            .NetworkError(m) => "Network error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "azure config" {
    let config = AzureConfig.new("sub-123").with_resource_group("my-rg").with_location("eastus")
    assert(config.subscription_id == "sub-123")
    assert(config.resource_group == Some("my-rg"))
}

test "image reference" {
    let ubuntu = ImageReference.ubuntu_2204()
    assert(ubuntu.publisher == "Canonical")
    assert(ubuntu.sku == "22_04-lts")
}

test "create vm params linux" {
    let params = CreateVmParams.linux("my-vm", "Standard_B1s", ImageReference.ubuntu_2204(), "/subscriptions/.../nic", "azureuser", "ssh-rsa ...")
    assert(params.name == "my-vm")
    assert(params.admin_password == None)
    assert(params.ssh_public_key != None)
}
