// =============================================================================
// Vibee OS â€” Autocomplete Module
// Intelligent autocomplete and suggestion systems
// =============================================================================

// =============================================================================
// Core Types
// =============================================================================

/// Autocomplete suggestion
struct Suggestion {
    text: String
    score: Float
    frequency: Int
    metadata: Map<String, String>
    
    fn new(text: String, score: Float) -> Self {
        Suggestion { text: text, score: score, frequency: 1, metadata: Map.empty() }
    }
    
    fn with_frequency(frequency: Int) -> Self {
        self.frequency = frequency
        self
    }
    
    fn with_metadata(key: String, value: String) -> Self {
        self.metadata.set(key, value)
        self
    }
}

impl Ord for Suggestion {
    fn cmp(other: Self) -> Ordering {
        // Higher score first, then higher frequency
        match other.score.partial_cmp(self.score) {
            Some(Ordering.Equal) => other.frequency.cmp(self.frequency),
            Some(ord) => ord,
            None => Ordering.Equal
        }
    }
}

/// Autocomplete configuration
struct AutocompleteConfig {
    min_prefix_length: Int
    max_suggestions: Int
    case_sensitive: Bool
    fuzzy_enabled: Bool
    fuzzy_threshold: Float
    boost_exact_match: Float
    boost_prefix_match: Float
    
    fn default() -> Self {
        AutocompleteConfig {
            min_prefix_length: 1,
            max_suggestions: 10,
            case_sensitive: false,
            fuzzy_enabled: true,
            fuzzy_threshold: 0.7,
            boost_exact_match: 10.0,
            boost_prefix_match: 5.0
        }
    }
}

// =============================================================================
// Trie-based Autocomplete
// =============================================================================

/// Trie node for autocomplete
struct TrieNode {
    children: Map<Char, TrieNode>
    is_word: Bool
    frequency: Int
    word: Option<String>
    
    fn new() -> Self {
        TrieNode {
            children: Map.empty(),
            is_word: false,
            frequency: 0,
            word: None
        }
    }
}

/// Trie-based autocomplete engine
struct TrieAutocomplete {
    root: TrieNode
    config: AutocompleteConfig
    total_words: Int
    
    fn new() -> Self {
        TrieAutocomplete {
            root: TrieNode.new(),
            config: AutocompleteConfig.default(),
            total_words: 0
        }
    }
    
    fn with_config(config: AutocompleteConfig) -> Self {
        TrieAutocomplete { config: config, ..Self.new() }
    }
    
    /// Add word to autocomplete index
    fn add(word: String, frequency: Int = 1) {
        let w = if self.config.case_sensitive { word } else { word.to_lowercase() }
        
        var node = self.root
        for c in w.chars() {
            node = node.children.entry(c).or_insert(TrieNode.new())
        }
        
        if !node.is_word {
            self.total_words += 1
        }
        
        node.is_word = true
        node.frequency += frequency
        node.word = Some(w)
    }
    
    /// Add multiple words
    fn add_all(words: [String]) {
        for word in words { self.add(word, 1) }
    }
    
    /// Add words with frequencies
    fn add_with_frequencies(words: [(String, Int)]) {
        for (word, freq) in words { self.add(word, freq) }
    }
    
    /// Get suggestions for prefix
    fn suggest(prefix: String) -> [Suggestion] {
        if prefix.len() < self.config.min_prefix_length {
            return []
        }
        
        let p = if self.config.case_sensitive { prefix } else { prefix.to_lowercase() }
        
        // Find prefix node
        var node = self.root
        for c in p.chars() {
            match node.children.get(c) {
                Some(child) => node = child,
                None => return []
            }
        }
        
        // Collect all words under this prefix
        var suggestions = []
        self.collect_suggestions(node, p.clone(), suggestions)
        
        // Sort and limit
        suggestions.sort()
        suggestions.truncate(self.config.max_suggestions)
        
        suggestions
    }
    
    fn collect_suggestions(node: TrieNode, prefix: String, suggestions: [Suggestion]) {
        if node.is_word {
            let score = node.frequency as Float
            suggestions.push(Suggestion.new(node.word.clone().unwrap_or(prefix.clone()), score)
                .with_frequency(node.frequency))
        }
        
        for (c, child) in node.children.iter() {
            self.collect_suggestions(child, format!("{}{}", prefix, c), suggestions)
        }
    }
    
    /// Get suggestions with fuzzy matching
    fn suggest_fuzzy(prefix: String) -> [Suggestion] {
        var suggestions = self.suggest(prefix.clone())
        
        if self.config.fuzzy_enabled && suggestions.len() < self.config.max_suggestions {
            // Add fuzzy matches
            let fuzzy = self.fuzzy_search(prefix.clone())
            for s in fuzzy {
                if !suggestions.iter().any(|x| x.text == s.text) {
                    suggestions.push(s)
                }
            }
        }
        
        suggestions.sort()
        suggestions.truncate(self.config.max_suggestions)
        suggestions
    }
    
    fn fuzzy_search(query: String) -> [Suggestion] {
        var results = []
        self.fuzzy_search_node(self.root, query.clone(), "", results)
        results
    }
    
    fn fuzzy_search_node(node: TrieNode, query: String, current: String, results: [Suggestion]) {
        if node.is_word {
            let word = node.word.clone().unwrap_or(current.clone())
            let similarity = fuzzy_similarity(query.clone(), word.clone())
            
            if similarity >= self.config.fuzzy_threshold {
                results.push(Suggestion.new(word, similarity * node.frequency as Float)
                    .with_frequency(node.frequency))
            }
        }
        
        for (c, child) in node.children.iter() {
            self.fuzzy_search_node(child, query.clone(), format!("{}{}", current, c), results)
        }
    }
    
    /// Remove word from index
    fn remove(word: String) -> Bool {
        let w = if self.config.case_sensitive { word } else { word.to_lowercase() }
        self.remove_recursive(self.root, w.chars().collect(), 0)
    }
    
    fn remove_recursive(node: TrieNode, chars: [Char], index: Int) -> Bool {
        if index == chars.len() {
            if node.is_word {
                node.is_word = false
                node.word = None
                self.total_words -= 1
                return node.children.is_empty()
            }
            return false
        }
        
        let c = chars[index]
        if let Some(child) = node.children.get_mut(c) {
            if self.remove_recursive(child, chars, index + 1) {
                node.children.remove(c)
                return !node.is_word && node.children.is_empty()
            }
        }
        
        false
    }
    
    /// Update word frequency
    fn update_frequency(word: String, delta: Int) {
        let w = if self.config.case_sensitive { word } else { word.to_lowercase() }
        
        var node = self.root
        for c in w.chars() {
            match node.children.get_mut(c) {
                Some(child) => node = child,
                None => return
            }
        }
        
        if node.is_word {
            node.frequency = (node.frequency as Int + delta).max(0) as Int
        }
    }
    
    fn word_count() -> Int { self.total_words }
}

/// Simple fuzzy similarity (Jaro-Winkler simplified)
fn fuzzy_similarity(s1: String, s2: String) -> Float {
    if s1 == s2 { return 1.0 }
    if s1.is_empty() || s2.is_empty() { return 0.0 }
    
    let len1 = s1.len()
    let len2 = s2.len()
    let max_len = max(len1, len2)
    
    // Check prefix match
    var prefix_len = 0
    let chars1: [Char] = s1.chars().collect()
    let chars2: [Char] = s2.chars().collect()
    
    for i in 0..min(len1, len2) {
        if chars1[i] == chars2[i] { prefix_len += 1 }
        else { break }
    }
    
    let prefix_score = prefix_len as Float / max_len as Float
    
    // Simple character overlap
    let set1: Set<Char> = chars1.iter().collect()
    let set2: Set<Char> = chars2.iter().collect()
    let common = set1.intersection(set2).len()
    let overlap_score = common as Float / max_len as Float
    
    (prefix_score * 0.6 + overlap_score * 0.4)
}

// =============================================================================
// Weighted Autocomplete
// =============================================================================

/// Weighted autocomplete with multiple scoring factors
struct WeightedAutocomplete {
    trie: TrieAutocomplete
    recency: Map<String, Int64>  // word -> last used timestamp
    context_boost: Map<String, Map<String, Float>>  // context -> word -> boost
    
    fn new() -> Self {
        WeightedAutocomplete {
            trie: TrieAutocomplete.new(),
            recency: Map.empty(),
            context_boost: Map.empty()
        }
    }
    
    /// Add word with optional context
    fn add(word: String, frequency: Int = 1) {
        self.trie.add(word.clone(), frequency)
        self.recency.set(word.to_lowercase(), timestamp_ms())
    }
    
    /// Record word usage (updates recency and frequency)
    fn record_usage(word: String, context: Option<String> = None) {
        let w = word.to_lowercase()
        self.trie.update_frequency(w.clone(), 1)
        self.recency.set(w.clone(), timestamp_ms())
        
        if let Some(ctx) = context {
            let boosts = self.context_boost.entry(ctx).or_insert(Map.empty())
            *boosts.entry(w).or_insert(0.0) += 0.1
        }
    }
    
    /// Get suggestions with weighted scoring
    fn suggest(prefix: String, context: Option<String> = None) -> [Suggestion] {
        var suggestions = self.trie.suggest(prefix)
        
        let now = timestamp_ms()
        let hour_ms = 3600000i64
        
        for s in suggestions.iter_mut() {
            var score = s.score
            
            // Recency boost (decay over time)
            if let Some(last_used) = self.recency.get(s.text.to_lowercase()) {
                let age_hours = (now - last_used) / hour_ms
                let recency_boost = 1.0 / (1.0 + age_hours as Float * 0.1)
                score *= (1.0 + recency_boost)
            }
            
            // Context boost
            if let Some(ctx) = context.clone() {
                if let Some(boosts) = self.context_boost.get(ctx) {
                    if let Some(boost) = boosts.get(s.text.to_lowercase()) {
                        score *= (1.0 + boost)
                    }
                }
            }
            
            s.score = score
        }
        
        suggestions.sort()
        suggestions
    }
}

fn timestamp_ms() -> Int64 {
    @native("timestamp_ms")
}

// =============================================================================
// Search Autocomplete
// =============================================================================

/// Search query autocomplete with history
struct SearchAutocomplete {
    queries: TrieAutocomplete
    history: [String]
    max_history: Int
    
    fn new() -> Self {
        SearchAutocomplete {
            queries: TrieAutocomplete.new(),
            history: [],
            max_history: 1000
        }
    }
    
    /// Add search query
    fn add_query(query: String) {
        let q = query.trim().to_lowercase()
        if q.is_empty() { return }
        
        self.queries.add(q.clone(), 1)
        
        // Add to history
        self.history.push(q)
        if self.history.len() > self.max_history {
            self.history.remove(0)
        }
    }
    
    /// Get query suggestions
    fn suggest(prefix: String) -> [Suggestion] {
        self.queries.suggest_fuzzy(prefix)
    }
    
    /// Get recent queries matching prefix
    fn recent_queries(prefix: String, limit: Int) -> [String] {
        let p = prefix.to_lowercase()
        self.history.iter()
            .rev()
            .filter(|q| q.starts_with(p.clone()))
            .take(limit)
            .collect()
    }
    
    /// Get popular queries
    fn popular_queries(limit: Int) -> [Suggestion] {
        var all = []
        self.queries.collect_suggestions(self.queries.root, "", all)
        all.sort()
        all.truncate(limit)
        all
    }
    
    /// Clear history
    fn clear_history() {
        self.history.clear()
    }
}

// =============================================================================
// Multi-field Autocomplete
// =============================================================================

/// Autocomplete entry with multiple fields
struct AutocompleteEntry {
    id: String
    primary: String
    secondary: Option<String>
    tags: [String]
    data: Map<String, String>
    score: Float
    
    fn new(id: String, primary: String) -> Self {
        AutocompleteEntry {
            id: id,
            primary: primary,
            secondary: None,
            tags: [],
            data: Map.empty(),
            score: 1.0
        }
    }
    
    fn with_secondary(secondary: String) -> Self {
        self.secondary = Some(secondary)
        self
    }
    
    fn with_tags(tags: [String]) -> Self {
        self.tags = tags
        self
    }
    
    fn with_data(key: String, value: String) -> Self {
        self.data.set(key, value)
        self
    }
    
    fn with_score(score: Float) -> Self {
        self.score = score
        self
    }
}

/// Multi-field autocomplete result
struct AutocompleteResult {
    entry: AutocompleteEntry
    match_score: Float
    matched_field: String
    highlight: String
}

/// Multi-field autocomplete engine
struct MultiFieldAutocomplete {
    entries: Map<String, AutocompleteEntry>
    primary_index: TrieAutocomplete
    secondary_index: TrieAutocomplete
    tag_index: Map<String, Set<String>>  // tag -> entry ids
    config: AutocompleteConfig
    
    fn new() -> Self {
        MultiFieldAutocomplete {
            entries: Map.empty(),
            primary_index: TrieAutocomplete.new(),
            secondary_index: TrieAutocomplete.new(),
            tag_index: Map.empty(),
            config: AutocompleteConfig.default()
        }
    }
    
    /// Add entry
    fn add(entry: AutocompleteEntry) {
        let id = entry.id.clone()
        
        // Index primary field
        self.primary_index.add(entry.primary.clone(), (entry.score * 100.0) as Int)
        
        // Index secondary field
        if let Some(ref secondary) = entry.secondary {
            self.secondary_index.add(secondary.clone(), (entry.score * 50.0) as Int)
        }
        
        // Index tags
        for tag in entry.tags.iter() {
            self.tag_index.entry(tag.to_lowercase()).or_insert(Set.empty()).insert(id.clone())
        }
        
        self.entries.set(id, entry)
    }
    
    /// Search across all fields
    fn search(query: String) -> [AutocompleteResult] {
        var results = []
        let q = query.to_lowercase()
        
        // Search primary field
        for suggestion in self.primary_index.suggest(q.clone()) {
            for (id, entry) in self.entries.iter() {
                if entry.primary.to_lowercase().starts_with(q.clone()) {
                    results.push(AutocompleteResult {
                        entry: entry.clone(),
                        match_score: suggestion.score * self.config.boost_prefix_match,
                        matched_field: "primary",
                        highlight: self.highlight(entry.primary.clone(), q.clone())
                    })
                }
            }
        }
        
        // Search secondary field
        for suggestion in self.secondary_index.suggest(q.clone()) {
            for (id, entry) in self.entries.iter() {
                if let Some(ref secondary) = entry.secondary {
                    if secondary.to_lowercase().starts_with(q.clone()) {
                        if !results.iter().any(|r| r.entry.id == entry.id) {
                            results.push(AutocompleteResult {
                                entry: entry.clone(),
                                match_score: suggestion.score,
                                matched_field: "secondary",
                                highlight: self.highlight(secondary.clone(), q.clone())
                            })
                        }
                    }
                }
            }
        }
        
        // Search tags
        if let Some(ids) = self.tag_index.get(q.clone()) {
            for id in ids {
                if let Some(entry) = self.entries.get(id) {
                    if !results.iter().any(|r| r.entry.id == entry.id) {
                        results.push(AutocompleteResult {
                            entry: entry.clone(),
                            match_score: entry.score,
                            matched_field: "tag",
                            highlight: q.clone()
                        })
                    }
                }
            }
        }
        
        results.sort_by(|a, b| b.match_score.partial_cmp(a.match_score).unwrap_or(Ordering.Equal))
        results.truncate(self.config.max_suggestions)
        results
    }
    
    fn highlight(text: String, query: String) -> String {
        let lower_text = text.to_lowercase()
        let lower_query = query.to_lowercase()
        
        if let Some(idx) = lower_text.find(lower_query.clone()) {
            let before = text[..idx]
            let matched = text[idx..idx + query.len()]
            let after = text[idx + query.len()..]
            format!("{}<b>{}</b>{}", before, matched, after)
        } else {
            text
        }
    }
    
    /// Get entry by ID
    fn get(id: String) -> Option<AutocompleteEntry> {
        self.entries.get(id).cloned()
    }
    
    /// Remove entry
    fn remove(id: String) {
        if let Some(entry) = self.entries.remove(id.clone()) {
            // Note: Trie removal is expensive, in production use soft delete
            for tag in entry.tags {
                if let Some(ids) = self.tag_index.get_mut(tag.to_lowercase()) {
                    ids.remove(id.clone())
                }
            }
        }
    }
}

// =============================================================================
// Contextual Autocomplete
// =============================================================================

/// Autocomplete with context awareness
struct ContextualAutocomplete {
    base: TrieAutocomplete
    ngrams: Map<String, Map<String, Int>>  // previous word -> next word -> count
    
    fn new() -> Self {
        ContextualAutocomplete {
            base: TrieAutocomplete.new(),
            ngrams: Map.empty()
        }
    }
    
    /// Train from text corpus
    fn train(text: String) {
        let words: [String] = text.to_lowercase()
            .split_whitespace()
            .collect()
        
        for word in words.iter() {
            self.base.add(word.clone(), 1)
        }
        
        // Build bigrams
        for i in 0..words.len() - 1 {
            let prev = words[i].clone()
            let next = words[i + 1].clone()
            
            let next_words = self.ngrams.entry(prev).or_insert(Map.empty())
            *next_words.entry(next).or_insert(0) += 1
        }
    }
    
    /// Get suggestions based on previous word
    fn suggest_next(previous_word: String, prefix: String) -> [Suggestion] {
        let prev = previous_word.to_lowercase()
        let p = prefix.to_lowercase()
        
        var suggestions = []
        
        // Get ngram predictions
        if let Some(next_words) = self.ngrams.get(prev) {
            for (word, count) in next_words.iter() {
                if word.starts_with(p.clone()) {
                    suggestions.push(Suggestion.new(word.clone(), count as Float * 2.0)
                        .with_frequency(count))
                }
            }
        }
        
        // Add base suggestions
        for s in self.base.suggest(p) {
            if !suggestions.iter().any(|x| x.text == s.text) {
                suggestions.push(s)
            }
        }
        
        suggestions.sort()
        suggestions.truncate(10)
        suggestions
    }
    
    /// Suggest for full input (uses last word as context)
    fn suggest_input(input: String) -> [Suggestion] {
        let words: [String] = input.split_whitespace().collect()
        
        if words.is_empty() {
            return []
        }
        
        if words.len() == 1 {
            return self.base.suggest(words[0].clone())
        }
        
        let prev = words[words.len() - 2].clone()
        let current = words[words.len() - 1].clone()
        
        self.suggest_next(prev, current)
    }
}

// =============================================================================
// Actor-based Autocomplete Service
// =============================================================================

/// Autocomplete service actor
actor AutocompleteService {
    autocomplete: WeightedAutocomplete
    
    fn new() -> Self {
        AutocompleteService { autocomplete: WeightedAutocomplete.new() }
    }
    
    /// Add word to index
    msg fn add(word: String, frequency: Int) {
        self.autocomplete.add(word, frequency)
    }
    
    /// Record word usage
    msg fn record_usage(word: String, context: Option<String>) {
        self.autocomplete.record_usage(word, context)
    }
    
    /// Get suggestions
    msg fn suggest(prefix: String, context: Option<String>) -> [Suggestion] {
        self.autocomplete.suggest(prefix, context)
    }
    
    /// Batch add words
    msg fn add_batch(words: [(String, Int)]) {
        for (word, freq) in words {
            self.autocomplete.add(word, freq)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "trie autocomplete basic" {
    var ac = TrieAutocomplete.new()
    ac.add_all(["apple", "application", "apply", "banana", "band"])
    
    let suggestions = ac.suggest("app")
    assert_eq(suggestions.len(), 3)?
    assert(suggestions.iter().any(|s| s.text == "apple"))?
    assert(suggestions.iter().any(|s| s.text == "application"))?
    assert(suggestions.iter().any(|s| s.text == "apply"))?
}

test "trie autocomplete frequency" {
    var ac = TrieAutocomplete.new()
    ac.add("apple", 10)
    ac.add("application", 5)
    ac.add("apply", 1)
    
    let suggestions = ac.suggest("app")
    assert_eq(suggestions[0].text, "apple")?  // Highest frequency
}

test "trie autocomplete case insensitive" {
    var ac = TrieAutocomplete.new()
    ac.add("Apple", 1)
    ac.add("BANANA", 1)
    
    let suggestions = ac.suggest("app")
    assert_eq(suggestions.len(), 1)?
    assert_eq(suggestions[0].text, "apple")?
}

test "fuzzy autocomplete" {
    var ac = TrieAutocomplete.with_config(AutocompleteConfig {
        fuzzy_enabled: true,
        fuzzy_threshold: 0.5,
        ..AutocompleteConfig.default()
    })
    ac.add_all(["hello", "help", "world"])
    
    let suggestions = ac.suggest_fuzzy("helo")
    assert(suggestions.iter().any(|s| s.text == "hello"))?
}

test "search autocomplete" {
    var ac = SearchAutocomplete.new()
    ac.add_query("how to cook pasta")
    ac.add_query("how to bake bread")
    ac.add_query("what is rust")
    
    let suggestions = ac.suggest("how")
    assert_eq(suggestions.len(), 2)?
}

test "multi-field autocomplete" {
    var ac = MultiFieldAutocomplete.new()
    
    ac.add(AutocompleteEntry.new("1", "John Doe")
        .with_secondary("john@example.com")
        .with_tags(["developer", "team-lead"]))
    
    ac.add(AutocompleteEntry.new("2", "Jane Smith")
        .with_secondary("jane@example.com")
        .with_tags(["designer"]))
    
    let results = ac.search("john")
    assert_eq(results.len(), 1)?
    assert_eq(results[0].entry.id, "1")?
    
    let tag_results = ac.search("developer")
    assert_eq(tag_results.len(), 1)?
}

test "contextual autocomplete" {
    var ac = ContextualAutocomplete.new()
    ac.train("the quick brown fox jumps over the lazy dog")
    ac.train("the quick brown cat sleeps on the mat")
    
    let suggestions = ac.suggest_next("quick", "b")
    assert(suggestions.iter().any(|s| s.text == "brown"))?
}

test "weighted autocomplete recency" {
    var ac = WeightedAutocomplete.new()
    ac.add("old_word", 10)
    ac.add("new_word", 1)
    ac.record_usage("new_word", None)
    
    let suggestions = ac.suggest("", None)
    // new_word should be boosted due to recency
}
