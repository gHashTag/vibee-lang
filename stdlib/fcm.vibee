// =============================================================================
// Vibee OS â€” Firebase Cloud Messaging Module
// FCM push notifications for Android, iOS, and Web
// =============================================================================

use http.{HttpClient, Request, Response}
use json.{JsonValue, Serialize, Deserialize}

// =============================================================================
// FCM Configuration
// =============================================================================

struct FcmConfig {
    project_id: String
    service_account_key: String
    api_endpoint: String
    timeout: Duration
}

impl FcmConfig {
    fn new(project_id: String, service_account_key: String) -> Self {
        FcmConfig {
            project_id: project_id,
            service_account_key: service_account_key,
            api_endpoint: "https://fcm.googleapis.com/v1",
            timeout: Duration.from_secs(30)
        }
    }
    
    fn endpoint(url: String) -> Self { self.api_endpoint = url; self }
    fn timeout(duration: Duration) -> Self { self.timeout = duration; self }
}

// =============================================================================
// FCM Message
// =============================================================================

struct FcmMessage {
    token: Option<String>
    topic: Option<String>
    condition: Option<String>
    notification: Option<FcmNotification>
    data: Map<String, String>
    android: Option<AndroidConfig>
    webpush: Option<WebPushConfig>
    apns: Option<ApnsConfig>
    fcm_options: Option<FcmOptions>
}

impl FcmMessage {
    fn new() -> Self {
        FcmMessage {
            token: None, topic: None, condition: None,
            notification: None, data: Map.empty(),
            android: None, webpush: None, apns: None, fcm_options: None
        }
    }
    
    fn to_token(token: String) -> Self { self.token = Some(token); self }
    fn to_topic(topic: String) -> Self { self.topic = Some(topic); self }
    fn to_condition(condition: String) -> Self { self.condition = Some(condition); self }
    
    fn notification(title: String, body: String) -> Self {
        self.notification = Some(FcmNotification.new(title, body)); self
    }
    
    fn data(key: String, value: String) -> Self { self.data.set(key, value); self }
    fn android(config: AndroidConfig) -> Self { self.android = Some(config); self }
    fn webpush(config: WebPushConfig) -> Self { self.webpush = Some(config); self }
    fn apns(config: ApnsConfig) -> Self { self.apns = Some(config); self }
    
    fn validate() -> Result<(), FcmError> {
        let targets = [self.token.is_some(), self.topic.is_some(), self.condition.is_some()]
        let count = targets.filter(|t| *t).len()
        if count == 0 { return Err(FcmError.InvalidMessage("No target specified")) }
        if count > 1 { return Err(FcmError.InvalidMessage("Multiple targets specified")) }
        Ok(())
    }
    
    fn to_json() -> JsonValue {
        let mut msg = JsonValue.object()
        if let Some(t) = self.token { msg.set("token", t) }
        if let Some(t) = self.topic { msg.set("topic", t) }
        if let Some(c) = self.condition { msg.set("condition", c) }
        if let Some(n) = self.notification { msg.set("notification", n.to_json()) }
        if !self.data.is_empty() { msg.set("data", JsonValue.from(self.data)) }
        if let Some(a) = self.android { msg.set("android", a.to_json()) }
        if let Some(w) = self.webpush { msg.set("webpush", w.to_json()) }
        if let Some(a) = self.apns { msg.set("apns", a.to_json()) }
        msg
    }
}

// =============================================================================
// FCM Notification
// =============================================================================

struct FcmNotification {
    title: String
    body: String
    image: Option<String>
}

impl FcmNotification {
    fn new(title: String, body: String) -> Self {
        FcmNotification { title: title, body: body, image: None }
    }
    
    fn image(url: String) -> Self { self.image = Some(url); self }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("title", self.title)
        obj.set("body", self.body)
        if let Some(img) = self.image { obj.set("image", img) }
        obj
    }
}

// =============================================================================
// Android Configuration
// =============================================================================

struct AndroidConfig {
    collapse_key: Option<String>
    priority: AndroidPriority
    ttl: Option<Duration>
    restricted_package_name: Option<String>
    notification: Option<AndroidNotification>
    data: Map<String, String>
}

enum AndroidPriority { Normal, High }

impl AndroidConfig {
    fn new() -> Self {
        AndroidConfig {
            collapse_key: None, priority: AndroidPriority.Normal,
            ttl: None, restricted_package_name: None,
            notification: None, data: Map.empty()
        }
    }
    
    fn collapse_key(key: String) -> Self { self.collapse_key = Some(key); self }
    fn priority(p: AndroidPriority) -> Self { self.priority = p; self }
    fn ttl(duration: Duration) -> Self { self.ttl = Some(duration); self }
    fn package(name: String) -> Self { self.restricted_package_name = Some(name); self }
    fn notification(n: AndroidNotification) -> Self { self.notification = Some(n); self }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        if let Some(k) = self.collapse_key { obj.set("collapse_key", k) }
        obj.set("priority", match self.priority { .Normal => "normal", .High => "high" })
        if let Some(t) = self.ttl { obj.set("ttl", format!("{}s", t.as_secs())) }
        if let Some(n) = self.notification { obj.set("notification", n.to_json()) }
        obj
    }
}

struct AndroidNotification {
    title: Option<String>
    body: Option<String>
    icon: Option<String>
    color: Option<String>
    sound: Option<String>
    tag: Option<String>
    click_action: Option<String>
    channel_id: Option<String>
}

impl AndroidNotification {
    fn new() -> Self {
        AndroidNotification {
            title: None, body: None, icon: None, color: None,
            sound: None, tag: None, click_action: None, channel_id: None
        }
    }
    
    fn title(t: String) -> Self { self.title = Some(t); self }
    fn body(b: String) -> Self { self.body = Some(b); self }
    fn icon(i: String) -> Self { self.icon = Some(i); self }
    fn color(c: String) -> Self { self.color = Some(c); self }
    fn sound(s: String) -> Self { self.sound = Some(s); self }
    fn tag(t: String) -> Self { self.tag = Some(t); self }
    fn click_action(a: String) -> Self { self.click_action = Some(a); self }
    fn channel_id(id: String) -> Self { self.channel_id = Some(id); self }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        if let Some(t) = self.title { obj.set("title", t) }
        if let Some(b) = self.body { obj.set("body", b) }
        if let Some(i) = self.icon { obj.set("icon", i) }
        if let Some(c) = self.color { obj.set("color", c) }
        if let Some(s) = self.sound { obj.set("sound", s) }
        if let Some(t) = self.tag { obj.set("tag", t) }
        if let Some(a) = self.click_action { obj.set("click_action", a) }
        if let Some(id) = self.channel_id { obj.set("channel_id", id) }
        obj
    }
}

// =============================================================================
// Web Push Configuration
// =============================================================================

struct WebPushConfig {
    headers: Map<String, String>
    data: Map<String, String>
    notification: Option<WebNotification>
    fcm_options: Option<WebFcmOptions>
}

struct WebNotification {
    title: String
    body: String
    icon: Option<String>
    badge: Option<String>
    actions: [WebNotificationAction]
}

struct WebNotificationAction {
    action: String
    title: String
    icon: Option<String>
}

struct WebFcmOptions {
    link: Option<String>
    analytics_label: Option<String>
}

impl WebPushConfig {
    fn new() -> Self {
        WebPushConfig {
            headers: Map.empty(), data: Map.empty(),
            notification: None, fcm_options: None
        }
    }
    
    fn header(key: String, value: String) -> Self { self.headers.set(key, value); self }
    fn data(key: String, value: String) -> Self { self.data.set(key, value); self }
    fn notification(n: WebNotification) -> Self { self.notification = Some(n); self }
    fn link(url: String) -> Self {
        self.fcm_options = Some(WebFcmOptions { link: Some(url), analytics_label: None }); self
    }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        if !self.headers.is_empty() { obj.set("headers", JsonValue.from(self.headers)) }
        if !self.data.is_empty() { obj.set("data", JsonValue.from(self.data)) }
        if let Some(n) = self.notification { obj.set("notification", n.to_json()) }
        obj
    }
}

impl WebNotification {
    fn new(title: String, body: String) -> Self {
        WebNotification { title: title, body: body, icon: None, badge: None, actions: [] }
    }
    
    fn icon(url: String) -> Self { self.icon = Some(url); self }
    fn badge(url: String) -> Self { self.badge = Some(url); self }
    fn action(action: String, title: String) -> Self {
        self.actions.push(WebNotificationAction { action: action, title: title, icon: None }); self
    }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("title", self.title)
        obj.set("body", self.body)
        if let Some(i) = self.icon { obj.set("icon", i) }
        if let Some(b) = self.badge { obj.set("badge", b) }
        if !self.actions.is_empty() {
            obj.set("actions", self.actions.iter().map(|a| a.to_json()).collect())
        }
        obj
    }
}

impl WebNotificationAction {
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("action", self.action)
        obj.set("title", self.title)
        if let Some(i) = self.icon { obj.set("icon", i) }
        obj
    }
}

// =============================================================================
// APNS Configuration (for iOS via FCM)
// =============================================================================

struct ApnsConfig {
    headers: Map<String, String>
    payload: ApnsPayload
}

struct ApnsPayload {
    aps: ApsAlert
    custom_data: Map<String, JsonValue>
}

struct ApsAlert {
    alert: Option<ApsAlertBody>
    badge: Option<Int>
    sound: Option<String>
    content_available: Bool
    mutable_content: Bool
    category: Option<String>
    thread_id: Option<String>
}

struct ApsAlertBody {
    title: Option<String>
    body: Option<String>
    subtitle: Option<String>
}

impl ApnsConfig {
    fn new() -> Self {
        ApnsConfig {
            headers: Map.empty(),
            payload: ApnsPayload {
                aps: ApsAlert {
                    alert: None, badge: None, sound: None,
                    content_available: false, mutable_content: false,
                    category: None, thread_id: None
                },
                custom_data: Map.empty()
            }
        }
    }
    
    fn header(key: String, value: String) -> Self { self.headers.set(key, value); self }
    fn priority(p: Int) -> Self { self.headers.set("apns-priority", p.to_string()); self }
    fn expiration(exp: Int64) -> Self { self.headers.set("apns-expiration", exp.to_string()); self }
    fn collapse_id(id: String) -> Self { self.headers.set("apns-collapse-id", id); self }
    
    fn alert(title: String, body: String) -> Self {
        self.payload.aps.alert = Some(ApsAlertBody { title: Some(title), body: Some(body), subtitle: None }); self
    }
    fn badge(count: Int) -> Self { self.payload.aps.badge = Some(count); self }
    fn sound(name: String) -> Self { self.payload.aps.sound = Some(name); self }
    fn content_available() -> Self { self.payload.aps.content_available = true; self }
    fn mutable_content() -> Self { self.payload.aps.mutable_content = true; self }
    fn category(cat: String) -> Self { self.payload.aps.category = Some(cat); self }
    fn thread_id(id: String) -> Self { self.payload.aps.thread_id = Some(id); self }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        if !self.headers.is_empty() { obj.set("headers", JsonValue.from(self.headers)) }
        obj.set("payload", self.payload.to_json())
        obj
    }
}

impl ApnsPayload {
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("aps", self.aps.to_json())
        for (k, v) in self.custom_data { obj.set(k, v) }
        obj
    }
}

impl ApsAlert {
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        if let Some(a) = self.alert { obj.set("alert", a.to_json()) }
        if let Some(b) = self.badge { obj.set("badge", b) }
        if let Some(s) = self.sound { obj.set("sound", s) }
        if self.content_available { obj.set("content-available", 1) }
        if self.mutable_content { obj.set("mutable-content", 1) }
        if let Some(c) = self.category { obj.set("category", c) }
        if let Some(t) = self.thread_id { obj.set("thread-id", t) }
        obj
    }
}

impl ApsAlertBody {
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        if let Some(t) = self.title { obj.set("title", t) }
        if let Some(b) = self.body { obj.set("body", b) }
        if let Some(s) = self.subtitle { obj.set("subtitle", s) }
        obj
    }
}

// =============================================================================
// FCM Options
// =============================================================================

struct FcmOptions {
    analytics_label: Option<String>
}

// =============================================================================
// FCM Client
// =============================================================================

struct FcmClient {
    config: FcmConfig
    http: HttpClient
    access_token: Option<String>
    token_expires_at: Option<Instant>
}

impl FcmClient {
    fn new(config: FcmConfig) -> Self {
        FcmClient {
            config: config,
            http: HttpClient.new(),
            access_token: None,
            token_expires_at: None
        }
    }
    
    fn send(message: FcmMessage) -> Result<FcmResponse, FcmError> {
        message.validate()?
        let token = self.get_access_token()?
        
        let url = format!("{}/projects/{}/messages:send", 
            self.config.api_endpoint, self.config.project_id)
        
        let body = JsonValue.object()
        body.set("message", message.to_json())
        
        let response = self.http.post(url)
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(body.to_string())
            .timeout(self.config.timeout)
            .send()?
        
        self.parse_response(response)
    }
    
    fn send_multicast(tokens: [String], message: FcmMessage) -> FcmBatchResponse {
        let mut responses = []
        let mut success_count = 0
        let mut failure_count = 0
        
        for token in tokens {
            let msg = message.clone().to_token(token.clone())
            match self.send(msg) {
                Ok(resp) => {
                    success_count += 1
                    responses.push(FcmSendResult.success(token, resp.message_id))
                },
                Err(e) => {
                    failure_count += 1
                    responses.push(FcmSendResult.failure(token, e))
                }
            }
        }
        
        FcmBatchResponse { responses: responses, success_count: success_count, failure_count: failure_count }
    }
    
    fn send_to_topic(topic: String, message: FcmMessage) -> Result<FcmResponse, FcmError> {
        self.send(message.to_topic(topic))
    }
    
    fn send_to_condition(condition: String, message: FcmMessage) -> Result<FcmResponse, FcmError> {
        self.send(message.to_condition(condition))
    }
    
    fn subscribe_to_topic(tokens: [String], topic: String) -> Result<TopicResponse, FcmError> {
        self.manage_topic(tokens, topic, "batchAdd")
    }
    
    fn unsubscribe_from_topic(tokens: [String], topic: String) -> Result<TopicResponse, FcmError> {
        self.manage_topic(tokens, topic, "batchRemove")
    }
    
    fn manage_topic(tokens: [String], topic: String, action: String) -> Result<TopicResponse, FcmError> {
        let token = self.get_access_token()?
        let url = format!("https://iid.googleapis.com/iid/v1:{}?topic={}", action, topic)
        
        let body = JsonValue.object()
        body.set("registration_tokens", JsonValue.from(tokens))
        
        let response = self.http.post(url)
            .header("Authorization", format!("Bearer {}", token))
            .header("Content-Type", "application/json")
            .body(body.to_string())
            .send()?
        
        if response.status().is_success() {
            let json = response.json()?
            Ok(TopicResponse {
                success_count: json.get("successCount").as_int().unwrap_or(0),
                failure_count: json.get("failureCount").as_int().unwrap_or(0),
                errors: []
            })
        } else {
            Err(FcmError.ApiError(response.status().code(), response.text()))
        }
    }
    
    fn get_access_token() -> Result<String, FcmError> {
        if let Some(token) = self.access_token.clone() {
            if let Some(expires) = self.token_expires_at {
                if Instant.now() < expires {
                    return Ok(token)
                }
            }
        }
        self.refresh_access_token()
    }
    
    fn refresh_access_token() -> Result<String, FcmError> {
        let token = @native("gcp_get_access_token", self.config.service_account_key)?
        self.access_token = Some(token.clone())
        self.token_expires_at = Some(Instant.now() + Duration.from_secs(3500))
        Ok(token)
    }
    
    fn parse_response(response: Response) -> Result<FcmResponse, FcmError> {
        if response.status().is_success() {
            let json = response.json()?
            Ok(FcmResponse {
                message_id: json.get("name").as_string().unwrap_or(""),
                success: true,
                error: None
            })
        } else {
            let json = response.json().ok()
            let error_msg = json.and_then(|j| j.get("error").get("message").as_string())
                .unwrap_or(response.text())
            Err(FcmError.ApiError(response.status().code(), error_msg))
        }
    }
}

// =============================================================================
// FCM Response Types
// =============================================================================

struct FcmResponse {
    message_id: String
    success: Bool
    error: Option<String>
}

struct FcmBatchResponse {
    responses: [FcmSendResult]
    success_count: Int
    failure_count: Int
}

impl FcmBatchResponse {
    fn success_rate() -> Float { self.success_count as Float / (self.success_count + self.failure_count) as Float }
    fn failed_tokens() -> [String] { self.responses.filter(|r| !r.success).map(|r| r.token.clone()).collect() }
}

struct FcmSendResult {
    token: String
    success: Bool
    message_id: Option<String>
    error: Option<FcmError>
}

impl FcmSendResult {
    fn success(token: String, message_id: String) -> Self {
        FcmSendResult { token: token, success: true, message_id: Some(message_id), error: None }
    }
    fn failure(token: String, error: FcmError) -> Self {
        FcmSendResult { token: token, success: false, message_id: None, error: Some(error) }
    }
}

struct TopicResponse {
    success_count: Int
    failure_count: Int
    errors: [TopicError]
}

struct TopicError {
    index: Int
    error: String
}

// =============================================================================
// FCM Errors
// =============================================================================

enum FcmError {
    InvalidMessage(String)
    InvalidToken(String)
    AuthenticationFailed(String)
    ApiError(Int, String)
    NetworkError(String)
    RateLimited
    QuotaExceeded
    ServerError(String)
    Timeout
}

impl Display for FcmError {
    fn fmt(f: Formatter) {
        match self {
            InvalidMessage(msg) => f.write(format!("Invalid message: {}", msg)),
            InvalidToken(msg) => f.write(format!("Invalid token: {}", msg)),
            AuthenticationFailed(msg) => f.write(format!("Auth failed: {}", msg)),
            ApiError(code, msg) => f.write(format!("API error {}: {}", code, msg)),
            NetworkError(msg) => f.write(format!("Network error: {}", msg)),
            RateLimited => f.write("Rate limited"),
            QuotaExceeded => f.write("Quota exceeded"),
            ServerError(msg) => f.write(format!("Server error: {}", msg)),
            Timeout => f.write("Request timeout")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "fcm message creation" {
    let msg = FcmMessage.new()
        .to_token("device_token_123")
        .notification("Hello", "World")
        .data("key", "value")
    
    assert(msg.token == Some("device_token_123"))?
    assert(msg.validate().is_ok())?
}

test "fcm message validation" {
    let no_target = FcmMessage.new()
    assert(no_target.validate().is_err())?
    
    let multi_target = FcmMessage.new().to_token("t").to_topic("topic")
    assert(multi_target.validate().is_err())?
}

test "android config" {
    let config = AndroidConfig.new()
        .priority(AndroidPriority.High)
        .ttl(Duration.from_secs(3600))
        .collapse_key("updates")
    
    assert(config.priority == AndroidPriority.High)?
}

test "fcm batch response" {
    let batch = FcmBatchResponse {
        responses: [
            FcmSendResult.success("t1", "m1"),
            FcmSendResult.failure("t2", FcmError.InvalidToken("bad"))
        ],
        success_count: 1,
        failure_count: 1
    }
    
    assert_eq(batch.success_rate(), 0.5)?
    assert_eq(batch.failed_tokens(), ["t2"])?
}
