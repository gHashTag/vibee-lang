// =============================================================================
// Vibee OS â€” Repository Module
// ORM Repository pattern implementation
// =============================================================================

use entity::{Entity, EntityError, EntityMeta, Row, Value, ToValue, FromValue, Timestamped, SoftDeletable, EntityHooks, Validatable}
use query_builder::{QueryBuilder, SelectBuilder, InsertBuilder, UpdateBuilder, DeleteBuilder, WhereClause, OrderDirection}
use relation::{Relation, RelationType, Eager, LazyLoader}
use datetime::{DateTime}

// =============================================================================
// Repository Trait
// =============================================================================

/// Core repository trait for entity persistence
trait Repository<T: Entity> {
    /// Returns the database connection
    fn connection() -> Box<dyn Connection>
    
    /// Returns entity metadata
    fn meta() -> EntityMeta
    
    /// Finds entity by primary key
    fn find(id: Value) -> Result<Option<T>, EntityError> {
        let pk = Self.meta().primary_key
        let query = SelectBuilder.new(Self.meta().table_name)
            .columns(Self.meta().column_names())
            .where_eq(pk, id)
            .limit(1)
            .build()
        
        let rows = self.connection().query(query.sql, query.params)?
        match rows.first() {
            Some(row) => Ok(Some(T.from_row(row)?))
            None => Ok(None)
        }
    }
    
    /// Finds entity by primary key or returns error
    fn find_or_fail(id: Value) -> Result<T, EntityError> {
        self.find(id)?.ok_or(EntityError.NotFound(format!("Entity with id {} not found", id)))
    }
    
    /// Finds all entities
    fn all() -> Result<[T], EntityError> {
        let query = SelectBuilder.new(Self.meta().table_name)
            .columns(Self.meta().column_names())
            .build()
        
        let rows = self.connection().query(query.sql, query.params)?
        rows.iter().map(|row| T.from_row(row)).collect()
    }
    
    /// Finds entities matching criteria
    fn find_by(criteria: Map<String, Value>) -> Result<[T], EntityError> {
        var builder = SelectBuilder.new(Self.meta().table_name)
            .columns(Self.meta().column_names())
        
        for (column, value) in criteria {
            builder = builder.where_eq(column, value)
        }
        
        let query = builder.build()
        let rows = self.connection().query(query.sql, query.params)?
        rows.iter().map(|row| T.from_row(row)).collect()
    }
    
    /// Finds first entity matching criteria
    fn find_one_by(criteria: Map<String, Value>) -> Result<Option<T>, EntityError> {
        var builder = SelectBuilder.new(Self.meta().table_name)
            .columns(Self.meta().column_names())
            .limit(1)
        
        for (column, value) in criteria {
            builder = builder.where_eq(column, value)
        }
        
        let query = builder.build()
        let rows = self.connection().query(query.sql, query.params)?
        match rows.first() {
            Some(row) => Ok(Some(T.from_row(row)?))
            None => Ok(None)
        }
    }
    
    /// Saves entity (insert or update)
    fn save(entity: T) -> Result<T, EntityError> {
        if entity.is_new() {
            self.insert(entity)
        } else {
            self.update(entity)
        }
    }
    
    /// Inserts new entity
    fn insert(entity: T) -> Result<T, EntityError> {
        let row = entity.to_row()
        let columns: [String] = row.keys().filter(|k| k != Self.meta().primary_key).collect()
        let values: [Value] = columns.iter().map(|c| row.get(c).unwrap().clone()).collect()
        
        let query = InsertBuilder.new(Self.meta().table_name)
            .columns(columns)
            .values(values)
            .returning(Self.meta().primary_key)
            .build()
        
        let result = self.connection().execute_returning(query.sql, query.params)?
        
        // Update entity with generated ID
        var updated_entity = entity
        if let Some(id) = result.get(Self.meta().primary_key) {
            // Entity should have a way to set ID
        }
        
        Ok(updated_entity)
    }
    
    /// Updates existing entity
    fn update(entity: T) -> Result<T, EntityError> {
        let row = entity.to_row()
        let pk = Self.meta().primary_key
        let id = entity.id().ok_or(EntityError.ValidationFailed("Cannot update entity without ID"))?
        
        var builder = UpdateBuilder.new(Self.meta().table_name)
        
        for (column, value) in row {
            if column != pk {
                builder = builder.set(column, value)
            }
        }
        
        let query = builder.where_eq(pk, id).build()
        self.connection().execute(query.sql, query.params)?
        
        Ok(entity)
    }
    
    /// Deletes entity
    fn delete(entity: T) -> Result<(), EntityError> {
        let pk = Self.meta().primary_key
        let id = entity.id().ok_or(EntityError.ValidationFailed("Cannot delete entity without ID"))?
        
        let query = DeleteBuilder.new(Self.meta().table_name)
            .where_eq(pk, id)
            .build()
        
        self.connection().execute(query.sql, query.params)?
        Ok(())
    }
    
    /// Deletes entity by ID
    fn delete_by_id(id: Value) -> Result<Bool, EntityError> {
        let pk = Self.meta().primary_key
        let query = DeleteBuilder.new(Self.meta().table_name)
            .where_eq(pk, id)
            .build()
        
        let affected = self.connection().execute(query.sql, query.params)?
        Ok(affected > 0)
    }
    
    /// Counts all entities
    fn count() -> Result<Int64, EntityError> {
        let query = SelectBuilder.new(Self.meta().table_name)
            .count()
            .build()
        
        let rows = self.connection().query(query.sql, query.params)?
        rows.first()
            .and_then(|r| r.get::<Int64>("count").ok())
            .ok_or(EntityError.DatabaseError("Failed to get count"))
    }
    
    /// Counts entities matching criteria
    fn count_by(criteria: Map<String, Value>) -> Result<Int64, EntityError> {
        var builder = SelectBuilder.new(Self.meta().table_name).count()
        
        for (column, value) in criteria {
            builder = builder.where_eq(column, value)
        }
        
        let query = builder.build()
        let rows = self.connection().query(query.sql, query.params)?
        rows.first()
            .and_then(|r| r.get::<Int64>("count").ok())
            .ok_or(EntityError.DatabaseError("Failed to get count"))
    }
    
    /// Checks if entity exists
    fn exists(id: Value) -> Result<Bool, EntityError> {
        let pk = Self.meta().primary_key
        let query = SelectBuilder.new(Self.meta().table_name)
            .columns([pk])
            .where_eq(pk, id)
            .limit(1)
            .build()
        
        let rows = self.connection().query(query.sql, query.params)?
        Ok(!rows.is_empty())
    }
    
    /// Creates a query builder for this repository
    fn query() -> RepositoryQuery<T> {
        RepositoryQuery.new(self.connection(), Self.meta())
    }
}

// =============================================================================
// Repository Query Builder
// =============================================================================

/// Fluent query builder for repository
struct RepositoryQuery<T: Entity> {
    connection: Box<dyn Connection>
    meta: EntityMeta
    select_columns: [String]
    where_clauses: [WhereClause]
    order_by: [(String, OrderDirection)]
    limit_value: Option<Int>
    offset_value: Option<Int>
    with_relations: [String]
    group_by_columns: [String]
    having_clauses: [WhereClause]
    
    fn new(connection: Box<dyn Connection>, meta: EntityMeta) -> Self {
        RepositoryQuery {
            connection: connection,
            meta: meta,
            select_columns: meta.column_names(),
            where_clauses: [],
            order_by: [],
            limit_value: None,
            offset_value: None,
            with_relations: [],
            group_by_columns: [],
            having_clauses: []
        }
    }
    
    fn select(columns: [String]) -> Self {
        self.select_columns = columns
        self
    }
    
    fn where_eq(column: String, value: Value) -> Self {
        self.where_clauses.push(WhereClause.Eq(column, value))
        self
    }
    
    fn where_ne(column: String, value: Value) -> Self {
        self.where_clauses.push(WhereClause.Ne(column, value))
        self
    }
    
    fn where_gt(column: String, value: Value) -> Self {
        self.where_clauses.push(WhereClause.Gt(column, value))
        self
    }
    
    fn where_gte(column: String, value: Value) -> Self {
        self.where_clauses.push(WhereClause.Gte(column, value))
        self
    }
    
    fn where_lt(column: String, value: Value) -> Self {
        self.where_clauses.push(WhereClause.Lt(column, value))
        self
    }
    
    fn where_lte(column: String, value: Value) -> Self {
        self.where_clauses.push(WhereClause.Lte(column, value))
        self
    }
    
    fn where_like(column: String, pattern: String) -> Self {
        self.where_clauses.push(WhereClause.Like(column, pattern))
        self
    }
    
    fn where_in(column: String, values: [Value]) -> Self {
        self.where_clauses.push(WhereClause.In(column, values))
        self
    }
    
    fn where_not_in(column: String, values: [Value]) -> Self {
        self.where_clauses.push(WhereClause.NotIn(column, values))
        self
    }
    
    fn where_null(column: String) -> Self {
        self.where_clauses.push(WhereClause.IsNull(column))
        self
    }
    
    fn where_not_null(column: String) -> Self {
        self.where_clauses.push(WhereClause.IsNotNull(column))
        self
    }
    
    fn where_between(column: String, min: Value, max: Value) -> Self {
        self.where_clauses.push(WhereClause.Between(column, min, max))
        self
    }
    
    fn where_raw(sql: String, params: [Value]) -> Self {
        self.where_clauses.push(WhereClause.Raw(sql, params))
        self
    }
    
    fn order_by(column: String, direction: OrderDirection = OrderDirection.Asc) -> Self {
        self.order_by.push((column, direction))
        self
    }
    
    fn order_by_asc(column: String) -> Self {
        self.order_by(column, OrderDirection.Asc)
    }
    
    fn order_by_desc(column: String) -> Self {
        self.order_by(column, OrderDirection.Desc)
    }
    
    fn limit(n: Int) -> Self {
        self.limit_value = Some(n)
        self
    }
    
    fn offset(n: Int) -> Self {
        self.offset_value = Some(n)
        self
    }
    
    fn with(relations: [String]) -> Self {
        self.with_relations.extend(relations)
        self
    }
    
    fn group_by(columns: [String]) -> Self {
        self.group_by_columns.extend(columns)
        self
    }
    
    fn having(clause: WhereClause) -> Self {
        self.having_clauses.push(clause)
        self
    }
    
    /// Executes query and returns all results
    fn get() -> Result<[T], EntityError> {
        let query = self.build_select()
        let rows = self.connection.query(query.sql, query.params)?
        rows.iter().map(|row| T.from_row(row)).collect()
    }
    
    /// Executes query and returns first result
    fn first() -> Result<Option<T>, EntityError> {
        self.limit_value = Some(1)
        let results = self.get()?
        Ok(results.first().cloned())
    }
    
    /// Executes query and returns first result or error
    fn first_or_fail() -> Result<T, EntityError> {
        self.first()?.ok_or(EntityError.NotFound("No matching entity found"))
    }
    
    /// Counts matching entities
    fn count() -> Result<Int64, EntityError> {
        var builder = SelectBuilder.new(self.meta.table_name).count()
        
        for clause in self.where_clauses {
            builder = builder.where_clause(clause)
        }
        
        let query = builder.build()
        let rows = self.connection.query(query.sql, query.params)?
        rows.first()
            .and_then(|r| r.get::<Int64>("count").ok())
            .ok_or(EntityError.DatabaseError("Failed to get count"))
    }
    
    /// Checks if any matching entity exists
    fn exists() -> Result<Bool, EntityError> {
        Ok(self.count()? > 0)
    }
    
    /// Deletes all matching entities
    fn delete() -> Result<Int64, EntityError> {
        var builder = DeleteBuilder.new(self.meta.table_name)
        
        for clause in self.where_clauses {
            builder = builder.where_clause(clause)
        }
        
        let query = builder.build()
        self.connection.execute(query.sql, query.params)
    }
    
    /// Updates all matching entities
    fn update(values: Map<String, Value>) -> Result<Int64, EntityError> {
        var builder = UpdateBuilder.new(self.meta.table_name)
        
        for (column, value) in values {
            builder = builder.set(column, value)
        }
        
        for clause in self.where_clauses {
            builder = builder.where_clause(clause)
        }
        
        let query = builder.build()
        self.connection.execute(query.sql, query.params)
    }
    
    /// Paginates results
    fn paginate(page: Int, per_page: Int = 20) -> Result<Paginator<T>, EntityError> {
        let total = self.clone().count()?
        let items = self.limit(per_page).offset((page - 1) * per_page).get()?
        
        Ok(Paginator {
            items: items,
            total: total,
            per_page: per_page,
            current_page: page,
            last_page: ((total as Float64) / (per_page as Float64)).ceil() as Int
        })
    }
    
    fn build_select() -> Query {
        var builder = SelectBuilder.new(self.meta.table_name)
            .columns(self.select_columns.clone())
        
        for clause in self.where_clauses {
            builder = builder.where_clause(clause)
        }
        
        for (column, direction) in self.order_by {
            builder = builder.order_by(column, direction)
        }
        
        if let Some(limit) = self.limit_value {
            builder = builder.limit(limit)
        }
        
        if let Some(offset) = self.offset_value {
            builder = builder.offset(offset)
        }
        
        for column in self.group_by_columns {
            builder = builder.group_by(column)
        }
        
        builder.build()
    }
}

// =============================================================================
// Paginator
// =============================================================================

/// Pagination result wrapper
struct Paginator<T> {
    items: [T]
    total: Int64
    per_page: Int
    current_page: Int
    last_page: Int
    
    fn has_more_pages() -> Bool {
        self.current_page < self.last_page
    }
    
    fn has_previous_page() -> Bool {
        self.current_page > 1
    }
    
    fn next_page() -> Option<Int> {
        if self.has_more_pages() { Some(self.current_page + 1) } else { None }
    }
    
    fn previous_page() -> Option<Int> {
        if self.has_previous_page() { Some(self.current_page - 1) } else { None }
    }
    
    fn is_empty() -> Bool {
        self.items.is_empty()
    }
    
    fn len() -> Int {
        self.items.len()
    }
}

impl<T> Iterator for Paginator<T> {
    type Item = T
    fn next() -> Option<T> {
        self.items.pop_front()
    }
}

// =============================================================================
// Base Repository
// =============================================================================

/// Base repository implementation
struct BaseRepository<T: Entity> {
    connection: Box<dyn Connection>
    meta: EntityMeta
}

impl<T: Entity> BaseRepository<T> {
    fn new(connection: Box<dyn Connection>, meta: EntityMeta) -> Self {
        BaseRepository { connection: connection, meta: meta }
    }
}

impl<T: Entity> Repository<T> for BaseRepository<T> {
    fn connection() -> Box<dyn Connection> { self.connection.clone() }
    fn meta() -> EntityMeta { self.meta.clone() }
}

// =============================================================================
// Timestamped Repository
// =============================================================================

/// Repository with automatic timestamp handling
trait TimestampedRepository<T: Entity + Timestamped>: Repository<T> {
    fn insert(entity: T) -> Result<T, EntityError> {
        entity.set_created_at(DateTime.now())
        entity.set_updated_at(DateTime.now())
        Repository.insert(self, entity)
    }
    
    fn update(entity: T) -> Result<T, EntityError> {
        entity.set_updated_at(DateTime.now())
        Repository.update(self, entity)
    }
}

// =============================================================================
// Soft Delete Repository
// =============================================================================

/// Repository with soft delete support
trait SoftDeleteRepository<T: Entity + SoftDeletable>: Repository<T> {
    /// Finds only non-deleted entities
    fn all() -> Result<[T], EntityError> {
        self.query().where_null("deleted_at").get()
    }
    
    /// Finds entity by ID (only non-deleted)
    fn find(id: Value) -> Result<Option<T>, EntityError> {
        self.query()
            .where_eq(Self.meta().primary_key, id)
            .where_null("deleted_at")
            .first()
    }
    
    /// Soft deletes entity
    fn soft_delete(entity: T) -> Result<T, EntityError> {
        entity.soft_delete()
        self.update(entity)
    }
    
    /// Restores soft-deleted entity
    fn restore(entity: T) -> Result<T, EntityError> {
        entity.restore()
        self.update(entity)
    }
    
    /// Finds including soft-deleted
    fn with_trashed() -> RepositoryQuery<T> {
        RepositoryQuery.new(self.connection(), Self.meta())
    }
    
    /// Finds only soft-deleted
    fn only_trashed() -> RepositoryQuery<T> {
        RepositoryQuery.new(self.connection(), Self.meta())
            .where_not_null("deleted_at")
    }
    
    /// Force deletes entity (permanent)
    fn force_delete(entity: T) -> Result<(), EntityError> {
        Repository.delete(self, entity)
    }
}

// =============================================================================
// Hooks Repository
// =============================================================================

/// Repository with lifecycle hooks support
trait HooksRepository<T: Entity + EntityHooks>: Repository<T> {
    fn insert(entity: T) -> Result<T, EntityError> {
        entity.before_insert()?
        let result = Repository.insert(self, entity)?
        result.after_insert()
        Ok(result)
    }
    
    fn update(entity: T) -> Result<T, EntityError> {
        entity.before_update()?
        let result = Repository.update(self, entity)?
        result.after_update()
        Ok(result)
    }
    
    fn delete(entity: T) -> Result<(), EntityError> {
        entity.before_delete()?
        Repository.delete(self, entity)?
        entity.after_delete()
        Ok(())
    }
}

// =============================================================================
// Validating Repository
// =============================================================================

/// Repository with validation support
trait ValidatingRepository<T: Entity + Validatable>: Repository<T> {
    fn save(entity: T) -> Result<T, EntityError> {
        entity.validate().map_err(|errors| {
            let messages = errors.iter().map(|e| format!("{}: {}", e.field, e.message)).join(", ")
            EntityError.ValidationFailed(messages)
        })?
        Repository.save(self, entity)
    }
}

// =============================================================================
// Connection Trait
// =============================================================================

/// Database connection trait
trait Connection {
    fn query(sql: String, params: [Value]) -> Result<[Row], EntityError>
    fn execute(sql: String, params: [Value]) -> Result<Int64, EntityError>
    fn execute_returning(sql: String, params: [Value]) -> Result<Row, EntityError>
    fn begin_transaction() -> Result<Box<dyn Transaction>, EntityError>
}

/// Transaction trait
trait Transaction: Connection {
    fn commit() -> Result<(), EntityError>
    fn rollback() -> Result<(), EntityError>
}

// =============================================================================
// Query Result
// =============================================================================

/// Built query with SQL and parameters
struct Query {
    sql: String
    params: [Value]
}

// =============================================================================
// Unit of Work
// =============================================================================

/// Unit of Work pattern for managing entity changes
struct UnitOfWork {
    connection: Box<dyn Connection>
    new_entities: [Box<dyn Entity>]
    dirty_entities: [Box<dyn Entity>]
    removed_entities: [Box<dyn Entity>]
    
    fn new(connection: Box<dyn Connection>) -> Self {
        UnitOfWork {
            connection: connection,
            new_entities: [],
            dirty_entities: [],
            removed_entities: []
        }
    }
    
    fn persist<T: Entity>(entity: T) {
        if entity.is_new() {
            self.new_entities.push(Box.new(entity))
        } else {
            self.dirty_entities.push(Box.new(entity))
        }
    }
    
    fn remove<T: Entity>(entity: T) {
        self.removed_entities.push(Box.new(entity))
    }
    
    fn flush() -> Result<(), EntityError> {
        let tx = self.connection.begin_transaction()?
        
        // Insert new entities
        for entity in self.new_entities.drain(..) {
            // Insert logic
        }
        
        // Update dirty entities
        for entity in self.dirty_entities.drain(..) {
            // Update logic
        }
        
        // Delete removed entities
        for entity in self.removed_entities.drain(..) {
            // Delete logic
        }
        
        tx.commit()?
        Ok(())
    }
    
    fn clear() {
        self.new_entities.clear()
        self.dirty_entities.clear()
        self.removed_entities.clear()
    }
}

// =============================================================================
// Identity Map
// =============================================================================

/// Identity map for caching loaded entities
struct IdentityMap<T: Entity> {
    entities: Map<String, T>
    
    fn new() -> Self {
        IdentityMap { entities: Map.empty() }
    }
    
    fn get(id: Value) -> Option<T> {
        let key = format!("{}", id)
        self.entities.get(key).cloned()
    }
    
    fn put(id: Value, entity: T) {
        let key = format!("{}", id)
        self.entities.insert(key, entity)
    }
    
    fn remove(id: Value) -> Option<T> {
        let key = format!("{}", id)
        self.entities.remove(key)
    }
    
    fn contains(id: Value) -> Bool {
        let key = format!("{}", id)
        self.entities.contains_key(key)
    }
    
    fn clear() {
        self.entities.clear()
    }
}

// =============================================================================
// Tests
// =============================================================================

test "paginator" {
    let paginator = Paginator {
        items: [1, 2, 3],
        total: 100,
        per_page: 10,
        current_page: 1,
        last_page: 10
    }
    
    assert(paginator.has_more_pages())?
    assert(!paginator.has_previous_page())?
    assert_eq(paginator.next_page(), Some(2))?
    assert_eq(paginator.previous_page(), None)?
}

test "identity_map" {
    var map = IdentityMap::<Int>.new()
    map.put(Value.Int(1), 100)
    map.put(Value.Int(2), 200)
    
    assert_eq(map.get(Value.Int(1)), Some(100))?
    assert_eq(map.get(Value.Int(3)), None)?
    assert(map.contains(Value.Int(2)))?
}

test "repository_query_builder" {
    // Test query builder chain
    let query = RepositoryQuery::<TestEntity>.new(mock_connection(), test_meta())
        .where_eq("status", Value.String("active"))
        .where_gt("age", Value.Int(18))
        .order_by_desc("created_at")
        .limit(10)
    
    assert_eq(query.where_clauses.len(), 2)?
    assert_eq(query.limit_value, Some(10))?
}
