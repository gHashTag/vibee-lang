// =============================================================================
// Vibee OS â€” Web Push API Module
// Web Push notifications for browsers (Chrome, Firefox, Safari, Edge)
// =============================================================================

use http.{HttpClient, Request, Response}
use json.{JsonValue, Serialize, Deserialize}
use crypto.{ecdh_p256, hkdf_sha256, aes_gcm_encrypt, random_bytes}
use base64.{url_encode, url_decode}

// =============================================================================
// VAPID Configuration
// =============================================================================

struct VapidConfig {
    subject: String
    public_key: String
    private_key: String
}

impl VapidConfig {
    fn new(subject: String, public_key: String, private_key: String) -> Self {
        VapidConfig {
            subject: subject,
            public_key: public_key,
            private_key: private_key
        }
    }
    
    fn generate() -> Self {
        let (public_key, private_key) = @native("generate_vapid_keys")
        VapidConfig {
            subject: "",
            public_key: public_key,
            private_key: private_key
        }
    }
    
    fn subject(s: String) -> Self { self.subject = s; self }
    
    fn public_key_bytes() -> Result<[UInt8], WebPushError> {
        base64.url_decode(self.public_key).map_err(|e| WebPushError.InvalidKey(e.to_string()))
    }
}

// =============================================================================
// Push Subscription
// =============================================================================

struct PushSubscription {
    endpoint: String
    expiration_time: Option<Int64>
    keys: PushSubscriptionKeys
}

struct PushSubscriptionKeys {
    p256dh: String
    auth: String
}

impl PushSubscription {
    fn new(endpoint: String, p256dh: String, auth: String) -> Self {
        PushSubscription {
            endpoint: endpoint,
            expiration_time: None,
            keys: PushSubscriptionKeys { p256dh: p256dh, auth: auth }
        }
    }
    
    fn from_json(json: JsonValue) -> Result<Self, WebPushError> {
        let endpoint = json.get("endpoint").as_string()
            .ok_or(WebPushError.InvalidSubscription("Missing endpoint"))?
        let keys = json.get("keys")
        let p256dh = keys.get("p256dh").as_string()
            .ok_or(WebPushError.InvalidSubscription("Missing p256dh key"))?
        let auth = keys.get("auth").as_string()
            .ok_or(WebPushError.InvalidSubscription("Missing auth key"))?
        
        Ok(PushSubscription {
            endpoint: endpoint,
            expiration_time: json.get("expirationTime").as_int64(),
            keys: PushSubscriptionKeys { p256dh: p256dh, auth: auth }
        })
    }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("endpoint", self.endpoint.clone())
        if let Some(exp) = self.expiration_time {
            obj.set("expirationTime", exp)
        }
        let mut keys = JsonValue.object()
        keys.set("p256dh", self.keys.p256dh.clone())
        keys.set("auth", self.keys.auth.clone())
        obj.set("keys", keys)
        obj
    }
    
    fn is_expired() -> Bool {
        if let Some(exp) = self.expiration_time {
            Instant.now().unix_timestamp_millis() > exp
        } else {
            false
        }
    }
    
    fn get_origin() -> String {
        let url = Url.parse(self.endpoint).unwrap()
        format!("{}://{}", url.scheme(), url.host())
    }
}

// =============================================================================
// Web Push Message
// =============================================================================

struct WebPushMessage {
    payload: Option<String>
    ttl: Int
    urgency: Urgency
    topic: Option<String>
}

enum Urgency {
    VeryLow
    Low
    Normal
    High
}

impl Urgency {
    fn to_string() -> String {
        match self {
            .VeryLow => "very-low",
            .Low => "low",
            .Normal => "normal",
            .High => "high"
        }
    }
}

impl WebPushMessage {
    fn new() -> Self {
        WebPushMessage {
            payload: None,
            ttl: 86400,
            urgency: Urgency.Normal,
            topic: None
        }
    }
    
    fn payload(data: String) -> Self { self.payload = Some(data); self }
    fn json(data: JsonValue) -> Self { self.payload = Some(data.to_string()); self }
    fn ttl(seconds: Int) -> Self { self.ttl = seconds; self }
    fn urgency(u: Urgency) -> Self { self.urgency = u; self }
    fn topic(t: String) -> Self { self.topic = Some(t); self }
    
    fn notification(title: String, body: String) -> Self {
        let mut obj = JsonValue.object()
        obj.set("title", title)
        obj.set("body", body)
        self.payload = Some(obj.to_string())
        self
    }
    
    fn notification_full(options: NotificationOptions) -> Self {
        self.payload = Some(options.to_json().to_string())
        self
    }
}

// =============================================================================
// Notification Options
// =============================================================================

struct NotificationOptions {
    title: String
    body: Option<String>
    icon: Option<String>
    badge: Option<String>
    image: Option<String>
    tag: Option<String>
    data: Option<JsonValue>
    require_interaction: Bool
    renotify: Bool
    silent: Bool
    vibrate: [Int]
    actions: [NotificationAction]
    dir: TextDirection
    lang: Option<String>
    timestamp: Option<Int64>
}

enum TextDirection { Auto, Ltr, Rtl }

struct NotificationAction {
    action: String
    title: String
    icon: Option<String>
}

impl NotificationOptions {
    fn new(title: String) -> Self {
        NotificationOptions {
            title: title, body: None, icon: None, badge: None, image: None,
            tag: None, data: None, require_interaction: false, renotify: false,
            silent: false, vibrate: [], actions: [], dir: TextDirection.Auto,
            lang: None, timestamp: None
        }
    }
    
    fn body(b: String) -> Self { self.body = Some(b); self }
    fn icon(url: String) -> Self { self.icon = Some(url); self }
    fn badge(url: String) -> Self { self.badge = Some(url); self }
    fn image(url: String) -> Self { self.image = Some(url); self }
    fn tag(t: String) -> Self { self.tag = Some(t); self }
    fn data(d: JsonValue) -> Self { self.data = Some(d); self }
    fn require_interaction() -> Self { self.require_interaction = true; self }
    fn renotify() -> Self { self.renotify = true; self }
    fn silent() -> Self { self.silent = true; self }
    fn vibrate(pattern: [Int]) -> Self { self.vibrate = pattern; self }
    fn action(action: String, title: String) -> Self {
        self.actions.push(NotificationAction { action: action, title: title, icon: None }); self
    }
    fn action_with_icon(action: String, title: String, icon: String) -> Self {
        self.actions.push(NotificationAction { action: action, title: title, icon: Some(icon) }); self
    }
    
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("title", self.title.clone())
        if let Some(b) = self.body { obj.set("body", b) }
        if let Some(i) = self.icon { obj.set("icon", i) }
        if let Some(b) = self.badge { obj.set("badge", b) }
        if let Some(i) = self.image { obj.set("image", i) }
        if let Some(t) = self.tag { obj.set("tag", t) }
        if let Some(d) = self.data { obj.set("data", d) }
        if self.require_interaction { obj.set("requireInteraction", true) }
        if self.renotify { obj.set("renotify", true) }
        if self.silent { obj.set("silent", true) }
        if !self.vibrate.is_empty() { obj.set("vibrate", JsonValue.from(self.vibrate)) }
        if !self.actions.is_empty() {
            obj.set("actions", self.actions.iter().map(|a| a.to_json()).collect())
        }
        if let Some(ts) = self.timestamp { obj.set("timestamp", ts) }
        obj
    }
}

impl NotificationAction {
    fn to_json() -> JsonValue {
        let mut obj = JsonValue.object()
        obj.set("action", self.action.clone())
        obj.set("title", self.title.clone())
        if let Some(i) = self.icon { obj.set("icon", i) }
        obj
    }
}

// =============================================================================
// Web Push Client
// =============================================================================

struct WebPushClient {
    vapid: VapidConfig
    http: HttpClient
    timeout: Duration
}

impl WebPushClient {
    fn new(vapid: VapidConfig) -> Self {
        WebPushClient {
            vapid: vapid,
            http: HttpClient.new(),
            timeout: Duration.from_secs(30)
        }
    }
    
    fn timeout(duration: Duration) -> Self { self.timeout = duration; self }
    
    fn send(subscription: PushSubscription, message: WebPushMessage) -> Result<WebPushResponse, WebPushError> {
        if subscription.is_expired() {
            return Err(WebPushError.SubscriptionExpired)
        }
        
        let encrypted = self.encrypt_payload(subscription.clone(), message.payload.clone())?
        let vapid_headers = self.create_vapid_headers(subscription.endpoint.clone())?
        
        let mut request = self.http.post(subscription.endpoint.clone())
            .header("TTL", message.ttl.to_string())
            .header("Urgency", message.urgency.to_string())
            .header("Authorization", vapid_headers.authorization)
            .header("Crypto-Key", vapid_headers.crypto_key)
            .timeout(self.timeout)
        
        if let Some(topic) = message.topic {
            request = request.header("Topic", topic)
        }
        
        if let Some(enc) = encrypted {
            request = request
                .header("Content-Type", "application/octet-stream")
                .header("Content-Encoding", "aes128gcm")
                .body_bytes(enc.ciphertext)
        }
        
        let response = request.send()?
        self.parse_response(response)
    }
    
    fn send_notification(subscription: PushSubscription, title: String, body: String) -> Result<WebPushResponse, WebPushError> {
        let message = WebPushMessage.new().notification(title, body)
        self.send(subscription, message)
    }
    
    fn send_batch(subscriptions: [PushSubscription], message: WebPushMessage) -> WebPushBatchResponse {
        let mut responses = []
        let mut success_count = 0
        let mut failure_count = 0
        
        for subscription in subscriptions {
            let endpoint = subscription.endpoint.clone()
            match self.send(subscription, message.clone()) {
                Ok(resp) => {
                    success_count += 1
                    responses.push(WebPushSendResult.success(endpoint))
                },
                Err(e) => {
                    failure_count += 1
                    responses.push(WebPushSendResult.failure(endpoint, e))
                }
            }
        }
        
        WebPushBatchResponse { responses: responses, success_count: success_count, failure_count: failure_count }
    }
    
    fn encrypt_payload(subscription: PushSubscription, payload: Option<String>) -> Result<Option<EncryptedPayload>, WebPushError> {
        let data = match payload {
            Some(p) => p.as_bytes(),
            None => return Ok(None)
        }
        
        let user_public_key = base64.url_decode(subscription.keys.p256dh)?
        let auth_secret = base64.url_decode(subscription.keys.auth)?
        
        let (local_public_key, shared_secret) = ecdh_p256(user_public_key.clone())?
        
        let salt = random_bytes(16)
        
        let auth_info = b"Content-Encoding: auth\x00"
        let prk = hkdf_sha256(auth_secret, shared_secret, auth_info, 32)?
        
        let mut key_info = Vec.new()
        key_info.extend(b"Content-Encoding: aes128gcm\x00")
        key_info.extend(b"P-256\x00")
        key_info.push(0)
        key_info.push(65)
        key_info.extend(user_public_key)
        key_info.push(0)
        key_info.push(65)
        key_info.extend(local_public_key.clone())
        
        let content_encryption_key = hkdf_sha256(salt.clone(), prk.clone(), key_info, 16)?
        
        let mut nonce_info = Vec.new()
        nonce_info.extend(b"Content-Encoding: nonce\x00")
        nonce_info.extend(b"P-256\x00")
        nonce_info.push(0)
        nonce_info.push(65)
        nonce_info.extend(user_public_key)
        nonce_info.push(0)
        nonce_info.push(65)
        nonce_info.extend(local_public_key.clone())
        
        let nonce = hkdf_sha256(salt.clone(), prk, nonce_info, 12)?
        
        let mut padded_data = Vec.new()
        padded_data.extend(data)
        padded_data.push(2)  // Padding delimiter
        
        let ciphertext = aes_gcm_encrypt(content_encryption_key, nonce, padded_data)?
        
        let mut header = Vec.new()
        header.extend(salt)
        header.extend([0, 0, 16, 0])  // Record size (4096)
        header.push(65)  // Key length
        header.extend(local_public_key)
        
        let mut result = Vec.new()
        result.extend(header)
        result.extend(ciphertext)
        
        Ok(Some(EncryptedPayload { ciphertext: result }))
    }
    
    fn create_vapid_headers(endpoint: String) -> Result<VapidHeaders, WebPushError> {
        let url = Url.parse(endpoint)?
        let audience = format!("{}://{}", url.scheme(), url.host())
        
        let now = Instant.now().unix_timestamp()
        let exp = now + 86400
        
        let header = JsonValue.object()
        header.set("typ", "JWT")
        header.set("alg", "ES256")
        
        let claims = JsonValue.object()
        claims.set("aud", audience)
        claims.set("exp", exp)
        claims.set("sub", self.vapid.subject.clone())
        
        let header_b64 = base64.url_encode_no_pad(header.to_string())
        let claims_b64 = base64.url_encode_no_pad(claims.to_string())
        let signing_input = format!("{}.{}", header_b64, claims_b64)
        
        let private_key = base64.url_decode(self.vapid.private_key.clone())?
        let signature = @native("sign_es256", private_key, signing_input.as_bytes())?
        let signature_b64 = base64.url_encode_no_pad(signature)
        
        let jwt = format!("{}.{}.{}", header_b64, claims_b64, signature_b64)
        
        Ok(VapidHeaders {
            authorization: format!("vapid t={}, k={}", jwt, self.vapid.public_key),
            crypto_key: format!("p256ecdsa={}", self.vapid.public_key)
        })
    }
    
    fn parse_response(response: Response) -> Result<WebPushResponse, WebPushError> {
        match response.status().code() {
            201 => Ok(WebPushResponse { success: true, status_code: 201 }),
            400 => Err(WebPushError.BadRequest(response.text())),
            401 => Err(WebPushError.Unauthorized),
            403 => Err(WebPushError.Forbidden),
            404 => Err(WebPushError.NotFound),
            410 => Err(WebPushError.Gone),
            413 => Err(WebPushError.PayloadTooLarge),
            429 => Err(WebPushError.TooManyRequests),
            500..=599 => Err(WebPushError.ServerError(response.status().code())),
            _ => Err(WebPushError.Unknown(response.status().code()))
        }
    }
}

struct EncryptedPayload {
    ciphertext: [UInt8]
}

struct VapidHeaders {
    authorization: String
    crypto_key: String
}

// =============================================================================
// Web Push Response Types
// =============================================================================

struct WebPushResponse {
    success: Bool
    status_code: Int
}

struct WebPushBatchResponse {
    responses: [WebPushSendResult]
    success_count: Int
    failure_count: Int
}

impl WebPushBatchResponse {
    fn success_rate() -> Float {
        if self.success_count + self.failure_count == 0 { return 0.0 }
        self.success_count as Float / (self.success_count + self.failure_count) as Float
    }
    
    fn failed_endpoints() -> [String] {
        self.responses.filter(|r| !r.success).map(|r| r.endpoint.clone()).collect()
    }
    
    fn gone_endpoints() -> [String] {
        self.responses.filter(|r| {
            match r.error {
                Some(WebPushError.Gone) => true,
                _ => false
            }
        }).map(|r| r.endpoint.clone()).collect()
    }
}

struct WebPushSendResult {
    endpoint: String
    success: Bool
    error: Option<WebPushError>
}

impl WebPushSendResult {
    fn success(endpoint: String) -> Self {
        WebPushSendResult { endpoint: endpoint, success: true, error: None }
    }
    fn failure(endpoint: String, error: WebPushError) -> Self {
        WebPushSendResult { endpoint: endpoint, success: false, error: Some(error) }
    }
}

// =============================================================================
// Subscription Manager
// =============================================================================

actor SubscriptionManager {
    state subscriptions: Map<String, PushSubscription>
    state user_subscriptions: Map<String, [String]>
    
    fn new() -> Self {
        SubscriptionManager {
            subscriptions: Map.empty(),
            user_subscriptions: Map.empty()
        }
    }
    
    on add(user_id: String, subscription: PushSubscription) {
        let endpoint = subscription.endpoint.clone()
        self.subscriptions.set(endpoint.clone(), subscription)
        
        let mut user_subs = self.user_subscriptions.get(user_id.clone()).unwrap_or([])
        if !user_subs.contains(endpoint.clone()) {
            user_subs.push(endpoint)
            self.user_subscriptions.set(user_id, user_subs)
        }
    }
    
    on remove(endpoint: String) {
        self.subscriptions.remove(endpoint.clone())
        for (user_id, subs) in self.user_subscriptions.iter_mut() {
            subs.retain(|e| *e != endpoint)
        }
    }
    
    on remove_user(user_id: String) {
        if let Some(endpoints) = self.user_subscriptions.remove(user_id) {
            for endpoint in endpoints {
                self.subscriptions.remove(endpoint)
            }
        }
    }
    
    fn get(endpoint: String) -> Option<PushSubscription> {
        self.subscriptions.get(endpoint)
    }
    
    fn get_user_subscriptions(user_id: String) -> [PushSubscription] {
        self.user_subscriptions.get(user_id)
            .unwrap_or([])
            .iter()
            .filter_map(|e| self.subscriptions.get(e.clone()))
            .collect()
    }
    
    fn all() -> [PushSubscription] {
        self.subscriptions.values().collect()
    }
    
    fn cleanup_expired() -> Int {
        let expired: [String] = self.subscriptions.iter()
            .filter(|(_, s)| s.is_expired())
            .map(|(e, _)| e.clone())
            .collect()
        
        for endpoint in expired.clone() {
            self.remove(endpoint)
        }
        
        expired.len()
    }
}

// =============================================================================
// Web Push Errors
// =============================================================================

enum WebPushError {
    InvalidKey(String)
    InvalidSubscription(String)
    SubscriptionExpired
    EncryptionError(String)
    BadRequest(String)
    Unauthorized
    Forbidden
    NotFound
    Gone
    PayloadTooLarge
    TooManyRequests
    ServerError(Int)
    NetworkError(String)
    Unknown(Int)
}

impl Display for WebPushError {
    fn fmt(f: Formatter) {
        match self {
            InvalidKey(msg) => f.write(format!("Invalid key: {}", msg)),
            InvalidSubscription(msg) => f.write(format!("Invalid subscription: {}", msg)),
            SubscriptionExpired => f.write("Subscription expired"),
            EncryptionError(msg) => f.write(format!("Encryption error: {}", msg)),
            BadRequest(msg) => f.write(format!("Bad request: {}", msg)),
            Unauthorized => f.write("Unauthorized"),
            Forbidden => f.write("Forbidden"),
            NotFound => f.write("Subscription not found"),
            Gone => f.write("Subscription no longer valid"),
            PayloadTooLarge => f.write("Payload too large"),
            TooManyRequests => f.write("Too many requests"),
            ServerError(code) => f.write(format!("Server error: {}", code)),
            NetworkError(msg) => f.write(format!("Network error: {}", msg)),
            Unknown(code) => f.write(format!("Unknown error: {}", code))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "push subscription creation" {
    let sub = PushSubscription.new(
        "https://fcm.googleapis.com/fcm/send/abc123",
        "BNcRdreALRFXTkOOUHK1EtK2wtaz5Ry4YfYCA_0QTpQtUbVlUls0VJXg7A8u-Ts1XbjhazAkj7I99e8QcYP7DkM",
        "tBHItJI5svbpez7KI4CCXg"
    )
    
    assert_eq(sub.get_origin(), "https://fcm.googleapis.com")?
    assert(!sub.is_expired())?
}

test "web push message creation" {
    let msg = WebPushMessage.new()
        .notification("Hello", "World")
        .ttl(3600)
        .urgency(Urgency.High)
    
    assert_eq(msg.ttl, 3600)?
    assert(msg.payload.is_some())?
}

test "notification options" {
    let options = NotificationOptions.new("Alert")
        .body("Something happened")
        .icon("/icon.png")
        .action("view", "View")
        .action("dismiss", "Dismiss")
        .require_interaction()
    
    let json = options.to_json()
    assert_eq(json.get("title").as_string(), Some("Alert"))?
    assert(json.get("requireInteraction").as_bool() == Some(true))?
}

test "urgency values" {
    assert_eq(Urgency.VeryLow.to_string(), "very-low")?
    assert_eq(Urgency.Low.to_string(), "low")?
    assert_eq(Urgency.Normal.to_string(), "normal")?
    assert_eq(Urgency.High.to_string(), "high")?
}

test "vapid config generation" {
    let config = VapidConfig.generate().subject("mailto:admin@example.com")
    assert(!config.public_key.is_empty())?
    assert(!config.private_key.is_empty())?
}

test "batch response" {
    let batch = WebPushBatchResponse {
        responses: [
            WebPushSendResult.success("e1"),
            WebPushSendResult.failure("e2", WebPushError.Gone)
        ],
        success_count: 1,
        failure_count: 1
    }
    
    assert_eq(batch.success_rate(), 0.5)?
    assert_eq(batch.gone_endpoints(), ["e2"])?
}
