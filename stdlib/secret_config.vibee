// =============================================================================
// Vibee OS â€” Secret Config Module
// Secure secrets management with multiple backends
// =============================================================================

// =============================================================================
// Secret Value
// =============================================================================

/// Secure secret value that clears memory on drop
struct Secret<T> {
    inner: T
    accessed: Bool
    created_at: DateTime
    expires_at: Option<DateTime>
}

impl<T> Secret<T> {
    fn new(value: T) -> Self {
        Secret {
            inner: value,
            accessed: false,
            created_at: DateTime.now(),
            expires_at: None
        }
    }
    
    fn with_expiry(value: T, expires_at: DateTime) -> Self {
        Secret {
            inner: value,
            accessed: false,
            created_at: DateTime.now(),
            expires_at: Some(expires_at)
        }
    }
    
    fn with_ttl(value: T, ttl: Duration) -> Self {
        Self.with_expiry(value, DateTime.now() + ttl)
    }
    
    /// Access the secret value
    fn expose() -> T {
        self.accessed = true
        self.inner.clone()
    }
    
    /// Check if secret is expired
    fn is_expired() -> Bool {
        match self.expires_at {
            Some(exp) => DateTime.now() > exp
            None => false
        }
    }
    
    /// Check if secret was accessed
    fn was_accessed() -> Bool { self.accessed }
    
    /// Map the inner value
    fn map<U>(f: fn(T) -> U) -> Secret<U> {
        Secret {
            inner: f(self.inner.clone()),
            accessed: self.accessed,
            created_at: self.created_at,
            expires_at: self.expires_at
        }
    }
}

impl<T> Drop for Secret<T> {
    fn drop() {
        // Securely clear memory
        @native("secure_zero", self.inner)
    }
}

impl<T> Display for Secret<T> {
    fn fmt(f: Formatter) {
        f.write("[REDACTED]")
    }
}

impl<T> Debug for Secret<T> {
    fn fmt(f: Formatter) {
        f.write("Secret([REDACTED])")
    }
}

// =============================================================================
// Secret Provider Trait
// =============================================================================

/// Trait for secret storage backends
trait SecretProvider {
    fn get(key: String) -> Result<Option<Secret<String>>, SecretError>
    fn set(key: String, value: Secret<String>) -> Result<(), SecretError>
    fn delete(key: String) -> Result<(), SecretError>
    fn list(prefix: String) -> Result<[String], SecretError>
    fn exists(key: String) -> Result<Bool, SecretError>
}

// =============================================================================
// Environment Secret Provider
// =============================================================================

/// Secrets from environment variables
struct EnvSecretProvider {
    prefix: Option<String>
}

impl EnvSecretProvider {
    fn new() -> Self { EnvSecretProvider { prefix: None } }
    fn with_prefix(prefix: String) -> Self { EnvSecretProvider { prefix: Some(prefix) } }
    
    fn full_key(key: String) -> String {
        match self.prefix {
            Some(p) => format!("{}_{}", p, key)
            None => key
        }
    }
}

impl SecretProvider for EnvSecretProvider {
    fn get(key: String) -> Result<Option<Secret<String>>, SecretError> {
        Ok(env_config.get(self.full_key(key)).map(|v| Secret.new(v)))
    }
    
    fn set(key: String, value: Secret<String>) -> Result<(), SecretError> {
        env_config.set(self.full_key(key), value.expose())
        Ok(())
    }
    
    fn delete(key: String) -> Result<(), SecretError> {
        env_config.remove(self.full_key(key))
        Ok(())
    }
    
    fn list(prefix: String) -> Result<[String], SecretError> {
        let full_prefix = self.full_key(prefix)
        Ok(env_config.all()
            .keys()
            .filter(|k| k.starts_with(full_prefix))
            .collect())
    }
    
    fn exists(key: String) -> Result<Bool, SecretError> {
        Ok(env_config.exists(self.full_key(key)))
    }
}

// =============================================================================
// File Secret Provider
// =============================================================================

/// Secrets from encrypted file
struct FileSecretProvider {
    path: String
    encryption_key: [UInt8]
    secrets: Map<String, EncryptedSecret>
}

struct EncryptedSecret {
    ciphertext: [UInt8]
    nonce: [UInt8]
    created_at: Int64
    expires_at: Option<Int64>
}

impl FileSecretProvider {
    fn new(path: String, encryption_key: [UInt8]) -> Result<Self, SecretError> {
        var provider = FileSecretProvider {
            path: path.clone(),
            encryption_key: encryption_key,
            secrets: Map.empty()
        }
        
        if fs.exists(path) {
            provider.load()?
        }
        
        Ok(provider)
    }
    
    fn from_password(path: String, password: String, salt: [UInt8]) -> Result<Self, SecretError> {
        let key = crypto.pbkdf2_sha256(password.as_bytes(), salt, 100000, 32)
        Self.new(path, key)
    }
    
    fn load() -> Result<(), SecretError> {
        let content = fs.read_bytes(self.path.clone())
            .map_err(|e| SecretError.IOError(e.to_string()))?
        
        self.secrets = @native("msgpack_decode", content)
            .map_err(|e| SecretError.ParseError(e))?
        
        Ok(())
    }
    
    fn save() -> Result<(), SecretError> {
        let content = @native("msgpack_encode", self.secrets)
        fs.write_bytes(self.path.clone(), content)
            .map_err(|e| SecretError.IOError(e.to_string()))
    }
    
    fn encrypt(value: String) -> Result<EncryptedSecret, SecretError> {
        let nonce = crypto.random_bytes(12)
        let ciphertext = crypto.aes_gcm_encrypt(
            self.encryption_key.clone(),
            nonce.clone(),
            value.as_bytes(),
            []
        ).map_err(|e| SecretError.EncryptionError(e.to_string()))?
        
        Ok(EncryptedSecret {
            ciphertext: ciphertext,
            nonce: nonce,
            created_at: DateTime.now().timestamp_millis(),
            expires_at: None
        })
    }
    
    fn decrypt(encrypted: EncryptedSecret) -> Result<String, SecretError> {
        let plaintext = crypto.aes_gcm_decrypt(
            self.encryption_key.clone(),
            encrypted.nonce,
            encrypted.ciphertext,
            []
        ).map_err(|e| SecretError.DecryptionError(e.to_string()))?
        
        String.from_utf8(plaintext)
            .map_err(|_| SecretError.DecryptionError("Invalid UTF-8"))
    }
}

impl SecretProvider for FileSecretProvider {
    fn get(key: String) -> Result<Option<Secret<String>>, SecretError> {
        match self.secrets.get(key) {
            Some(encrypted) => {
                // Check expiry
                if let Some(exp) = encrypted.expires_at {
                    if DateTime.now().timestamp_millis() > exp {
                        return Ok(None)
                    }
                }
                
                let value = self.decrypt(encrypted.clone())?
                let secret = match encrypted.expires_at {
                    Some(exp) => Secret.with_expiry(value, DateTime.from_timestamp_millis(exp))
                    None => Secret.new(value)
                }
                Ok(Some(secret))
            }
            None => Ok(None)
        }
    }
    
    fn set(key: String, value: Secret<String>) -> Result<(), SecretError> {
        var encrypted = self.encrypt(value.expose())?
        encrypted.expires_at = value.expires_at.map(|dt| dt.timestamp_millis())
        self.secrets.set(key, encrypted)
        self.save()
    }
    
    fn delete(key: String) -> Result<(), SecretError> {
        self.secrets.remove(key)
        self.save()
    }
    
    fn list(prefix: String) -> Result<[String], SecretError> {
        Ok(self.secrets.keys().filter(|k| k.starts_with(prefix)).collect())
    }
    
    fn exists(key: String) -> Result<Bool, SecretError> {
        Ok(self.secrets.contains(key))
    }
}

// =============================================================================
// HashiCorp Vault Provider
// =============================================================================

/// HashiCorp Vault secret provider
struct VaultProvider {
    address: String
    token: String
    namespace: Option<String>
    mount_path: String
    version: VaultKVVersion
}

enum VaultKVVersion { V1, V2 }

impl VaultProvider {
    fn new(address: String, token: String) -> Self {
        VaultProvider {
            address: address,
            token: token,
            namespace: None,
            mount_path: "secret",
            version: VaultKVVersion.V2
        }
    }
    
    fn namespace(ns: String) -> Self { self.namespace = Some(ns); self }
    fn mount_path(path: String) -> Self { self.mount_path = path; self }
    fn kv_v1() -> Self { self.version = VaultKVVersion.V1; self }
    fn kv_v2() -> Self { self.version = VaultKVVersion.V2; self }
    
    fn build_url(path: String) -> String {
        match self.version {
            VaultKVVersion.V1 => format!("{}/v1/{}/{}", self.address, self.mount_path, path)
            VaultKVVersion.V2 => format!("{}/v1/{}/data/{}", self.address, self.mount_path, path)
        }
    }
    
    fn build_request(method: http.Method, url: String) -> http.Request {
        var req = http.Request.new(method, url)
            .header("X-Vault-Token", self.token.clone())
        
        if let Some(ns) = self.namespace {
            req = req.header("X-Vault-Namespace", ns)
        }
        
        req
    }
}

impl SecretProvider for VaultProvider {
    fn get(key: String) -> Result<Option<Secret<String>>, SecretError> {
        let url = self.build_url(key)
        let req = self.build_request(http.Method.GET, url)
        
        let response = http.Client.new().send(req)
            .map_err(|e| SecretError.NetworkError(e.to_string()))?
        
        if response.status.code == 404 {
            return Ok(None)
        }
        
        if !response.is_success() {
            return Err(SecretError.ProviderError(format!("Vault error: {}", response.status.code)))
        }
        
        let data: VaultResponse = @native("json_decode", response.text())
            .map_err(|e| SecretError.ParseError(e))?
        
        match self.version {
            VaultKVVersion.V1 => {
                Ok(data.data.get("value").map(|v| Secret.new(v.clone())))
            }
            VaultKVVersion.V2 => {
                Ok(data.data.get("data")
                    .and_then(|d| d.get("value"))
                    .map(|v| Secret.new(v.clone())))
            }
        }
    }
    
    fn set(key: String, value: Secret<String>) -> Result<(), SecretError> {
        let url = self.build_url(key)
        
        let body = match self.version {
            VaultKVVersion.V1 => format!("{{\"value\": \"{}\"}}", value.expose())
            VaultKVVersion.V2 => format!("{{\"data\": {{\"value\": \"{}\"}}}}", value.expose())
        }
        
        let req = self.build_request(http.Method.POST, url)
            .body(body.as_bytes())
            .header("Content-Type", "application/json")
        
        let response = http.Client.new().send(req)
            .map_err(|e| SecretError.NetworkError(e.to_string()))?
        
        if !response.is_success() {
            return Err(SecretError.ProviderError(format!("Vault error: {}", response.status.code)))
        }
        
        Ok(())
    }
    
    fn delete(key: String) -> Result<(), SecretError> {
        let url = match self.version {
            VaultKVVersion.V1 => self.build_url(key)
            VaultKVVersion.V2 => format!("{}/v1/{}/metadata/{}", self.address, self.mount_path, key)
        }
        
        let req = self.build_request(http.Method.DELETE, url)
        
        let response = http.Client.new().send(req)
            .map_err(|e| SecretError.NetworkError(e.to_string()))?
        
        if !response.is_success() && response.status.code != 404 {
            return Err(SecretError.ProviderError(format!("Vault error: {}", response.status.code)))
        }
        
        Ok(())
    }
    
    fn list(prefix: String) -> Result<[String], SecretError> {
        let url = match self.version {
            VaultKVVersion.V1 => format!("{}/v1/{}/{}?list=true", self.address, self.mount_path, prefix)
            VaultKVVersion.V2 => format!("{}/v1/{}/metadata/{}?list=true", self.address, self.mount_path, prefix)
        }
        
        let req = self.build_request(http.Method.GET, url)
        
        let response = http.Client.new().send(req)
            .map_err(|e| SecretError.NetworkError(e.to_string()))?
        
        if response.status.code == 404 {
            return Ok([])
        }
        
        if !response.is_success() {
            return Err(SecretError.ProviderError(format!("Vault error: {}", response.status.code)))
        }
        
        let data: VaultListResponse = @native("json_decode", response.text())
            .map_err(|e| SecretError.ParseError(e))?
        
        Ok(data.data.keys)
    }
    
    fn exists(key: String) -> Result<Bool, SecretError> {
        self.get(key).map(|opt| opt.is_some())
    }
}

struct VaultResponse { data: Map<String, String> }
struct VaultListResponse { data: VaultListData }
struct VaultListData { keys: [String] }

// =============================================================================
// AWS Secrets Manager Provider
// =============================================================================

/// AWS Secrets Manager provider
struct AWSSecretsProvider {
    region: String
    prefix: Option<String>
}

impl AWSSecretsProvider {
    fn new(region: String) -> Self {
        AWSSecretsProvider { region: region, prefix: None }
    }
    
    fn with_prefix(prefix: String) -> Self {
        AWSSecretsProvider { region: self.region.clone(), prefix: Some(prefix) }
    }
    
    fn full_key(key: String) -> String {
        match self.prefix {
            Some(p) => format!("{}/{}", p, key)
            None => key
        }
    }
}

impl SecretProvider for AWSSecretsProvider {
    fn get(key: String) -> Result<Option<Secret<String>>, SecretError> {
        let full_key = self.full_key(key)
        @native("aws_secrets_get", full_key, self.region)
            .map(|v| Some(Secret.new(v)))
            .or_else(|e| {
                if e.contains("ResourceNotFoundException") {
                    Ok(None)
                } else {
                    Err(SecretError.ProviderError(e))
                }
            })
    }
    
    fn set(key: String, value: Secret<String>) -> Result<(), SecretError> {
        let full_key = self.full_key(key)
        @native("aws_secrets_put", full_key, value.expose(), self.region)
            .map_err(|e| SecretError.ProviderError(e))
    }
    
    fn delete(key: String) -> Result<(), SecretError> {
        let full_key = self.full_key(key)
        @native("aws_secrets_delete", full_key, self.region)
            .map_err(|e| SecretError.ProviderError(e))
    }
    
    fn list(prefix: String) -> Result<[String], SecretError> {
        let full_prefix = self.full_key(prefix)
        @native("aws_secrets_list", full_prefix, self.region)
            .map_err(|e| SecretError.ProviderError(e))
    }
    
    fn exists(key: String) -> Result<Bool, SecretError> {
        self.get(key).map(|opt| opt.is_some())
    }
}

// =============================================================================
// Secret Manager
// =============================================================================

/// Unified secret manager with caching and rotation
actor SecretManager {
    state provider: Box<dyn SecretProvider>
    state cache: Map<String, CachedSecret>
    state cache_ttl_ms: Int64
    state rotation_callbacks: Map<String, fn(String) -> Result<String, SecretError>>
}

struct CachedSecret {
    secret: Secret<String>
    cached_at: Int64
}

impl SecretManager {
    fn new<P: SecretProvider>(provider: P) -> Self {
        SecretManager {
            provider: Box.new(provider),
            cache: Map.empty(),
            cache_ttl_ms: 300000, // 5 minutes
            rotation_callbacks: Map.empty()
        }
    }
    
    /// Create with environment provider
    fn from_env() -> Self {
        Self.new(EnvSecretProvider.new())
    }
    
    /// Create with Vault provider
    fn from_vault(address: String, token: String) -> Self {
        Self.new(VaultProvider.new(address, token))
    }
    
    /// Create with AWS Secrets Manager
    fn from_aws(region: String) -> Self {
        Self.new(AWSSecretsProvider.new(region))
    }
    
    /// Set cache TTL
    fn cache_ttl(ms: Int64) -> Self {
        self.cache_ttl_ms = ms
        self
    }
    
    /// Disable caching
    fn no_cache() -> Self {
        self.cache_ttl_ms = 0
        self
    }
    
    /// Get secret
    fn get(key: String) -> Result<Option<Secret<String>>, SecretError> {
        // Check cache
        if self.cache_ttl_ms > 0 {
            if let Some(cached) = self.cache.get(key.clone()) {
                let now = @native("time_now_millis")
                if now - cached.cached_at < self.cache_ttl_ms && !cached.secret.is_expired() {
                    return Ok(Some(cached.secret.clone()))
                }
            }
        }
        
        // Fetch from provider
        let secret = self.provider.get(key.clone())?
        
        // Update cache
        if let Some(s) = secret.clone() {
            if self.cache_ttl_ms > 0 {
                self.cache.set(key, CachedSecret {
                    secret: s,
                    cached_at: @native("time_now_millis")
                })
            }
        }
        
        Ok(secret)
    }
    
    /// Get secret or error if not found
    fn require(key: String) -> Result<Secret<String>, SecretError> {
        self.get(key.clone())?.ok_or(SecretError.NotFound(key))
    }
    
    /// Get secret value directly
    fn get_value(key: String) -> Result<Option<String>, SecretError> {
        Ok(self.get(key)?.map(|s| s.expose()))
    }
    
    /// Require secret value
    fn require_value(key: String) -> Result<String, SecretError> {
        Ok(self.require(key)?.expose())
    }
    
    /// Set secret
    fn set(key: String, value: String) -> Result<(), SecretError> {
        let secret = Secret.new(value)
        self.provider.set(key.clone(), secret.clone())?
        
        // Update cache
        if self.cache_ttl_ms > 0 {
            self.cache.set(key, CachedSecret {
                secret: secret,
                cached_at: @native("time_now_millis")
            })
        }
        
        Ok(())
    }
    
    /// Set secret with TTL
    fn set_with_ttl(key: String, value: String, ttl: Duration) -> Result<(), SecretError> {
        let secret = Secret.with_ttl(value, ttl)
        self.provider.set(key.clone(), secret.clone())?
        
        if self.cache_ttl_ms > 0 {
            self.cache.set(key, CachedSecret {
                secret: secret,
                cached_at: @native("time_now_millis")
            })
        }
        
        Ok(())
    }
    
    /// Delete secret
    fn delete(key: String) -> Result<(), SecretError> {
        self.provider.delete(key.clone())?
        self.cache.remove(key)
        Ok(())
    }
    
    /// List secrets
    fn list(prefix: String) -> Result<[String], SecretError> {
        self.provider.list(prefix)
    }
    
    /// Check if secret exists
    fn exists(key: String) -> Result<Bool, SecretError> {
        self.provider.exists(key)
    }
    
    /// Clear cache
    fn clear_cache() {
        self.cache.clear()
    }
    
    /// Register rotation callback
    fn on_rotation(key: String, callback: fn(String) -> Result<String, SecretError>) -> Self {
        self.rotation_callbacks.set(key, callback)
        self
    }
    
    /// Rotate secret
    fn rotate(key: String) -> Result<(), SecretError> {
        let current = self.require_value(key.clone())?
        
        let new_value = match self.rotation_callbacks.get(key.clone()) {
            Some(callback) => callback(current)?
            None => return Err(SecretError.RotationError("No rotation callback registered"))
        }
        
        self.set(key, new_value)
    }
    
    /// Rotate all secrets with registered callbacks
    fn rotate_all() -> Result<(), SecretError> {
        for key in self.rotation_callbacks.keys() {
            self.rotate(key.clone())?
        }
        Ok(())
    }
}

// =============================================================================
// Secret Reference
// =============================================================================

/// Reference to a secret that can be resolved lazily
struct SecretRef {
    key: String
    manager: Option<SecretManager>
}

impl SecretRef {
    fn new(key: String) -> Self {
        SecretRef { key: key, manager: None }
    }
    
    fn with_manager(key: String, manager: SecretManager) -> Self {
        SecretRef { key: key, manager: Some(manager) }
    }
    
    fn resolve() -> Result<Secret<String>, SecretError> {
        match self.manager {
            Some(m) => m.require(self.key.clone())
            None => Err(SecretError.ConfigError("No manager configured"))
        }
    }
    
    fn resolve_value() -> Result<String, SecretError> {
        Ok(self.resolve()?.expose())
    }
}

// =============================================================================
// Errors
// =============================================================================

enum SecretError {
    NotFound(String)
    IOError(String)
    ParseError(String)
    EncryptionError(String)
    DecryptionError(String)
    NetworkError(String)
    ProviderError(String)
    ConfigError(String)
    RotationError(String)
    Expired(String)
}

impl Display for SecretError {
    fn fmt(f: Formatter) {
        match self {
            .NotFound(key) => f.write(format!("Secret not found: {}", key))
            .IOError(msg) => f.write(format!("I/O error: {}", msg))
            .ParseError(msg) => f.write(format!("Parse error: {}", msg))
            .EncryptionError(msg) => f.write(format!("Encryption error: {}", msg))
            .DecryptionError(msg) => f.write(format!("Decryption error: {}", msg))
            .NetworkError(msg) => f.write(format!("Network error: {}", msg))
            .ProviderError(msg) => f.write(format!("Provider error: {}", msg))
            .ConfigError(msg) => f.write(format!("Config error: {}", msg))
            .RotationError(msg) => f.write(format!("Rotation error: {}", msg))
            .Expired(key) => f.write(format!("Secret expired: {}", key))
        }
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Create secret from value
fn secret(value: String) -> Secret<String> { Secret.new(value) }

/// Create secret with TTL
fn secret_with_ttl(value: String, ttl: Duration) -> Secret<String> {
    Secret.with_ttl(value, ttl)
}

/// Create environment provider
fn env_provider() -> EnvSecretProvider { EnvSecretProvider.new() }

/// Create Vault provider
fn vault(address: String, token: String) -> VaultProvider {
    VaultProvider.new(address, token)
}

/// Create AWS provider
fn aws(region: String) -> AWSSecretsProvider {
    AWSSecretsProvider.new(region)
}

// =============================================================================
// Tests
// =============================================================================

test "secret value" {
    let s = Secret.new("my-secret")
    assert_eq(s.expose(), "my-secret")?
    assert(s.was_accessed())?
}

test "secret display redacted" {
    let s = Secret.new("my-secret")
    assert_eq(format!("{}", s), "[REDACTED]")?
}

test "secret with ttl" {
    let s = Secret.with_ttl("value", Duration.hours(1))
    assert(!s.is_expired())?
}

test "secret map" {
    let s = Secret.new("hello")
    let mapped = s.map(|v| v.to_upper())
    assert_eq(mapped.expose(), "HELLO")?
}

test "env secret provider" {
    env_config.set("TEST_SECRET", "secret-value")
    
    let provider = EnvSecretProvider.new()
    let secret = provider.get("TEST_SECRET")?.unwrap()
    assert_eq(secret.expose(), "secret-value")?
    
    env_config.remove("TEST_SECRET")
}

test "vault provider config" {
    let vault = VaultProvider.new("http://localhost:8200", "token")
        .namespace("my-ns")
        .mount_path("kv")
        .kv_v2()
    
    assert_eq(vault.mount_path, "kv")?
}

test "secret manager caching" {
    let manager = SecretManager.from_env()
        .cache_ttl(60000)
    
    assert_eq(manager.cache_ttl_ms, 60000)?
}
