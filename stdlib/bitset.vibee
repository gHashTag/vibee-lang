// =============================================================================
// Vibee OS â€” BitSet Module
// Bit set/vector operations
// =============================================================================

/// Fixed-size bit set
struct BitSet {
    bits: [UInt64]
    len: Int
    
    /// Create with capacity
    fn new(size: Int) -> Self {
        let words = (size + 63) / 64
        BitSet { bits: [0u64; words], len: size }
    }
    
    /// Create from bits
    fn from_bits(bits: [Bool]) -> Self {
        var bs = Self.new(bits.len())
        for (i, b) in bits.iter().enumerate() {
            if b { bs.set(i) }
        }
        bs
    }
    
    /// Set bit
    fn set(index: Int) {
        if index < self.len {
            self.bits[index / 64] |= 1u64 << (index % 64)
        }
    }
    
    /// Clear bit
    fn clear(index: Int) {
        if index < self.len {
            self.bits[index / 64] &= !(1u64 << (index % 64))
        }
    }
    
    /// Toggle bit
    fn toggle(index: Int) {
        if index < self.len {
            self.bits[index / 64] ^= 1u64 << (index % 64)
        }
    }
    
    /// Get bit
    fn get(index: Int) -> Bool {
        if index >= self.len { return false }
        (self.bits[index / 64] >> (index % 64)) & 1 == 1
    }
    
    /// Set range
    fn set_range(start: Int, end: Int) {
        for i in start..end { self.set(i) }
    }
    
    /// Clear range
    fn clear_range(start: Int, end: Int) {
        for i in start..end { self.clear(i) }
    }
    
    /// Set all bits
    fn set_all() {
        for i in 0..self.bits.len() { self.bits[i] = !0u64 }
    }
    
    /// Clear all bits
    fn clear_all() {
        for i in 0..self.bits.len() { self.bits[i] = 0 }
    }
    
    /// Count set bits
    fn count() -> Int {
        self.bits.iter().map(|w| w.count_ones() as Int).sum()
    }
    
    /// Check if empty
    fn is_empty() -> Bool {
        self.bits.iter().all(|w| w == 0)
    }
    
    /// Check if all set
    fn is_full() -> Bool {
        self.count() == self.len
    }
    
    /// Find first set bit
    fn first_set() -> Option<Int> {
        for (i, w) in self.bits.iter().enumerate() {
            if w != 0 {
                return Some(i * 64 + w.trailing_zeros() as Int)
            }
        }
        None
    }
    
    /// Find first clear bit
    fn first_clear() -> Option<Int> {
        for (i, w) in self.bits.iter().enumerate() {
            if w != !0u64 {
                let pos = i * 64 + (!w).trailing_zeros() as Int
                if pos < self.len { return Some(pos) }
            }
        }
        None
    }
    
    /// Union (OR)
    fn union(other: BitSet) -> Self {
        var result = Self.new(self.len.max(other.len))
        for i in 0..result.bits.len() {
            let a = self.bits.get(i).unwrap_or(0)
            let b = other.bits.get(i).unwrap_or(0)
            result.bits[i] = a | b
        }
        result
    }
    
    /// Intersection (AND)
    fn intersection(other: BitSet) -> Self {
        var result = Self.new(self.len.min(other.len))
        for i in 0..result.bits.len() {
            result.bits[i] = self.bits[i] & other.bits[i]
        }
        result
    }
    
    /// Difference (AND NOT)
    fn difference(other: BitSet) -> Self {
        var result = Self.new(self.len)
        for i in 0..self.bits.len() {
            let b = other.bits.get(i).unwrap_or(0)
            result.bits[i] = self.bits[i] & !b
        }
        result
    }
    
    /// Symmetric difference (XOR)
    fn symmetric_difference(other: BitSet) -> Self {
        var result = Self.new(self.len.max(other.len))
        for i in 0..result.bits.len() {
            let a = self.bits.get(i).unwrap_or(0)
            let b = other.bits.get(i).unwrap_or(0)
            result.bits[i] = a ^ b
        }
        result
    }
    
    /// Complement (NOT)
    fn complement() -> Self {
        var result = Self.new(self.len)
        for i in 0..self.bits.len() {
            result.bits[i] = !self.bits[i]
        }
        result
    }
    
    /// Check subset
    fn is_subset(other: BitSet) -> Bool {
        self.intersection(other) == self
    }
    
    /// Check superset
    fn is_superset(other: BitSet) -> Bool {
        other.is_subset(self)
    }
    
    /// Iterate set bits
    fn iter_ones() -> impl Iterator<Item = Int> {
        BitSetIterator { bs: self, index: 0, ones: true }
    }
    
    /// Iterate clear bits
    fn iter_zeros() -> impl Iterator<Item = Int> {
        BitSetIterator { bs: self, index: 0, ones: false }
    }
    
    /// To vector of indices
    fn to_indices() -> [Int] {
        self.iter_ones().collect()
    }
    
    /// Length
    fn len() -> Int { self.len }
}

impl Eq for BitSet {
    fn eq(other: BitSet) -> Bool {
        if self.len != other.len { return false }
        self.bits == other.bits
    }
}

struct BitSetIterator {
    bs: BitSet
    index: Int
    ones: Bool
}

impl Iterator for BitSetIterator {
    type Item = Int
    
    fn next() -> Option<Int> {
        while self.index < self.bs.len {
            let i = self.index
            self.index += 1
            if self.bs.get(i) == self.ones {
                return Some(i)
            }
        }
        None
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "set and get" {
    var bs = BitSet.new(100)
    bs.set(5)
    bs.set(50)
    bs.set(99)
    assert(bs.get(5))?
    assert(bs.get(50))?
    assert(!bs.get(6))?
}

test "count" {
    var bs = BitSet.new(64)
    bs.set(0)
    bs.set(31)
    bs.set(63)
    assert_eq(bs.count(), 3)?
}

test "union" {
    var a = BitSet.new(8)
    var b = BitSet.new(8)
    a.set(0); a.set(2)
    b.set(1); b.set(2)
    let c = a.union(b)
    assert(c.get(0) && c.get(1) && c.get(2))?
}

test "intersection" {
    var a = BitSet.new(8)
    var b = BitSet.new(8)
    a.set(0); a.set(2)
    b.set(1); b.set(2)
    let c = a.intersection(b)
    assert(!c.get(0) && !c.get(1) && c.get(2))?
}
