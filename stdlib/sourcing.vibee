// =============================================================================
// Vibee OS â€” Event Sourcing Module
// Event sourcing patterns for state management
// =============================================================================

use result::{Result, Ok, Err}

// =============================================================================
// Core Types
// =============================================================================

/// Domain event trait
trait DomainEvent {
    fn event_type() -> String
    fn aggregate_id() -> String
    fn version() -> Int64
    fn timestamp() -> Int64
}

/// Stored event wrapper
struct StoredEvent<T> {
    id: String,
    aggregate_id: String,
    aggregate_type: String,
    event_type: String,
    version: Int64,
    payload: T,
    metadata: Map<String, String>,
    timestamp: Int64
}

impl<T> StoredEvent<T> {
    fn new(aggregate_id: String, aggregate_type: String, event_type: String, version: Int64, payload: T) -> Self {
        StoredEvent {
            id: @native("uuid_v4"),
            aggregate_id: aggregate_id,
            aggregate_type: aggregate_type,
            event_type: event_type,
            version: version,
            payload: payload,
            metadata: Map.new(),
            timestamp: @native("timestamp_ms")
        }
    }
    
    fn with_metadata(key: String, value: String) -> Self {
        self.metadata.insert(key, value)
        self
    }
}

/// Event stream
struct EventStream<T> {
    aggregate_id: String,
    events: [StoredEvent<T>],
    version: Int64
}

impl<T> EventStream<T> {
    fn new(aggregate_id: String) -> Self {
        EventStream { aggregate_id: aggregate_id, events: [], version: 0 }
    }
    
    fn append(event: StoredEvent<T>) {
        self.events.push(event)
        self.version += 1
    }
    
    fn len() -> Int { self.events.len() }
    fn is_empty() -> Bool { self.events.is_empty() }
}

// =============================================================================
// Aggregate Root
// =============================================================================

/// Aggregate root trait
trait AggregateRoot {
    type Event
    
    fn id() -> String
    fn version() -> Int64
    fn apply(event: Self.Event)
    fn uncommitted_events() -> [Self.Event]
    fn clear_uncommitted()
}

/// Base aggregate implementation
struct Aggregate<S, E> {
    id: String,
    version: Int64,
    state: S,
    uncommitted: [E]
}

impl<S: Default, E: Clone> Aggregate<S, E> {
    fn new(id: String) -> Self {
        Aggregate {
            id: id,
            version: 0,
            state: S.default(),
            uncommitted: []
        }
    }
    
    fn load(id: String, events: [E], apply_fn: fn(S, E) -> S) -> Self {
        var state = S.default()
        var version: Int64 = 0
        
        for event in events {
            state = apply_fn(state, event)
            version += 1
        }
        
        Aggregate { id: id, version: version, state: state, uncommitted: [] }
    }
    
    fn raise(event: E, apply_fn: fn(S, E) -> S) {
        self.state = apply_fn(self.state.clone(), event.clone())
        self.uncommitted.push(event)
        self.version += 1
    }
    
    fn state() -> S { self.state.clone() }
    fn id() -> String { self.id.clone() }
    fn version() -> Int64 { self.version }
    fn uncommitted() -> [E] { self.uncommitted.clone() }
    fn clear_uncommitted() { self.uncommitted.clear() }
}

// =============================================================================
// Event Store
// =============================================================================

/// Event store trait
trait EventStore {
    type Event
    
    fn append(aggregate_id: String, events: [Self.Event], expected_version: Int64) -> Result<Int64, Error>
    fn load(aggregate_id: String) -> Result<[Self.Event], Error>
    fn load_from(aggregate_id: String, from_version: Int64) -> Result<[Self.Event], Error>
}

/// In-memory event store
actor InMemoryEventStore<E: Clone> {
    state streams: Map<String, EventStream<E>>
    state all_events: [StoredEvent<E>]
    state subscribers: [fn(StoredEvent<E>)]
    
    fn new() -> Self {
        InMemoryEventStore {
            streams: Map.new(),
            all_events: [],
            subscribers: []
        }
    }
    
    fn append(aggregate_id: String, aggregate_type: String, events: [E], expected_version: Int64) -> Result<Int64, Error> {
        let stream = self.streams.entry(aggregate_id.clone())
            .or_insert_with(|| EventStream.new(aggregate_id.clone()))
        
        if stream.version != expected_version {
            return Err(Error.new(format!(
                "Concurrency conflict: expected {}, got {}",
                expected_version, stream.version
            )))
        }
        
        var version = stream.version
        for event in events {
            version += 1
            let stored = StoredEvent.new(
                aggregate_id.clone(),
                aggregate_type.clone(),
                "event",
                version,
                event
            )
            stream.append(stored.clone())
            self.all_events.push(stored.clone())
            
            for sub in self.subscribers.iter() {
                sub(stored.clone())
            }
        }
        
        Ok(version)
    }
    
    fn load(aggregate_id: String) -> [StoredEvent<E>] {
        self.streams.get(aggregate_id)
            .map(|s| s.events.clone())
            .unwrap_or([])
    }
    
    fn load_from(aggregate_id: String, from_version: Int64) -> [StoredEvent<E>] {
        self.streams.get(aggregate_id)
            .map(|s| s.events.iter().filter(|e| e.version > from_version).cloned().collect())
            .unwrap_or([])
    }
    
    fn load_all() -> [StoredEvent<E>] {
        self.all_events.clone()
    }
    
    fn subscribe(handler: fn(StoredEvent<E>)) {
        self.subscribers.push(handler)
    }
    
    fn stream_version(aggregate_id: String) -> Int64 {
        self.streams.get(aggregate_id).map(|s| s.version).unwrap_or(0)
    }
}

// =============================================================================
// Snapshot Store
// =============================================================================

/// Snapshot
struct Snapshot<S> {
    aggregate_id: String,
    version: Int64,
    state: S,
    timestamp: Int64
}

/// Snapshot store
actor SnapshotStore<S: Clone> {
    state snapshots: Map<String, Snapshot<S>>
    state snapshot_interval: Int64
    
    fn new(interval: Int64) -> Self {
        SnapshotStore { snapshots: Map.new(), snapshot_interval: interval }
    }
    
    fn save(aggregate_id: String, version: Int64, state: S) {
        self.snapshots.insert(aggregate_id.clone(), Snapshot {
            aggregate_id: aggregate_id,
            version: version,
            state: state,
            timestamp: @native("timestamp_ms")
        })
    }
    
    fn load(aggregate_id: String) -> Option<Snapshot<S>> {
        self.snapshots.get(aggregate_id).cloned()
    }
    
    fn should_snapshot(version: Int64) -> Bool {
        version % self.snapshot_interval == 0
    }
}

// =============================================================================
// Repository
// =============================================================================

/// Event-sourced repository
actor Repository<S: Default + Clone, E: Clone> {
    state event_store: InMemoryEventStore<E>
    state snapshot_store: Option<SnapshotStore<S>>
    state apply_fn: fn(S, E) -> S
    state aggregate_type: String
    
    fn new(aggregate_type: String, apply_fn: fn(S, E) -> S) -> Self {
        Repository {
            event_store: InMemoryEventStore.new(),
            snapshot_store: None,
            apply_fn: apply_fn,
            aggregate_type: aggregate_type
        }
    }
    
    fn with_snapshots(aggregate_type: String, apply_fn: fn(S, E) -> S, interval: Int64) -> Self {
        Repository {
            event_store: InMemoryEventStore.new(),
            snapshot_store: Some(SnapshotStore.new(interval)),
            apply_fn: apply_fn,
            aggregate_type: aggregate_type
        }
    }
    
    fn load(id: String) -> Aggregate<S, E> {
        var state = S.default()
        var from_version: Int64 = 0
        
        // Load from snapshot if available
        if let Some(ref store) = self.snapshot_store {
            if let Some(snapshot) = store.load(id.clone()) {
                state = snapshot.state
                from_version = snapshot.version
            }
        }
        
        // Load events after snapshot
        let events = self.event_store.load_from(id.clone(), from_version)
        var version = from_version
        
        for stored in events {
            state = (self.apply_fn)(state, stored.payload)
            version += 1
        }
        
        Aggregate { id: id, version: version, state: state, uncommitted: [] }
    }
    
    fn save(aggregate: Aggregate<S, E>) -> Result<(), Error> {
        let events = aggregate.uncommitted()
        if events.is_empty() { return Ok(()) }
        
        let expected = aggregate.version() - events.len() as Int64
        let new_version = self.event_store.append(
            aggregate.id(),
            self.aggregate_type.clone(),
            events,
            expected
        )?
        
        // Save snapshot if needed
        if let Some(ref store) = self.snapshot_store {
            if store.should_snapshot(new_version) {
                store.save(aggregate.id(), new_version, aggregate.state())
            }
        }
        
        Ok(())
    }
    
    fn subscribe(handler: fn(StoredEvent<E>)) {
        self.event_store.subscribe(handler)
    }
}

// =============================================================================
// Projections
// =============================================================================

/// Projection trait
trait Projection {
    type Event
    fn apply(event: Self.Event)
    fn reset()
}

/// Simple projection
struct SimpleProjection<S: Default, E> {
    state: S,
    apply_fn: fn(S, E) -> S
}

impl<S: Default + Clone, E> SimpleProjection<S, E> {
    fn new(apply_fn: fn(S, E) -> S) -> Self {
        SimpleProjection { state: S.default(), apply_fn: apply_fn }
    }
    
    fn apply(event: E) {
        self.state = (self.apply_fn)(self.state.clone(), event)
    }
    
    fn state() -> S { self.state.clone() }
    fn reset() { self.state = S.default() }
}

/// Projection manager
actor ProjectionManager<E: Clone> {
    state projections: [fn(E)]
    state position: Int64
    
    fn new() -> Self {
        ProjectionManager { projections: [], position: 0 }
    }
    
    fn register(handler: fn(E)) {
        self.projections.push(handler)
    }
    
    fn apply(event: E) {
        for proj in self.projections.iter() {
            proj(event.clone())
        }
        self.position += 1
    }
    
    fn replay(events: [E]) {
        self.position = 0
        for event in events {
            self.apply(event)
        }
    }
    
    fn position() -> Int64 { self.position }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn event_store<E: Clone>() -> InMemoryEventStore<E> {
    InMemoryEventStore.new()
}

fn repository<S: Default + Clone, E: Clone>(
    aggregate_type: String,
    apply_fn: fn(S, E) -> S
) -> Repository<S, E> {
    Repository.new(aggregate_type, apply_fn)
}

fn projection<S: Default + Clone, E>(apply_fn: fn(S, E) -> S) -> SimpleProjection<S, E> {
    SimpleProjection.new(apply_fn)
}

// =============================================================================
// Tests
// =============================================================================

test "aggregate lifecycle" {
    enum UserEvent { Created(String), NameChanged(String) }
    struct UserState { name: String }
    impl Default for UserState { fn default() -> Self { UserState { name: "" } } }
    
    fn apply(state: UserState, event: UserEvent) -> UserState {
        match event {
            UserEvent.Created(name) => UserState { name: name },
            UserEvent.NameChanged(name) => UserState { name: name }
        }
    }
    
    var agg = Aggregate::<UserState, UserEvent>.new("user-1")
    agg.raise(UserEvent.Created("John"), apply)
    agg.raise(UserEvent.NameChanged("Jane"), apply)
    
    assert_eq(agg.state().name, "Jane")?
    assert_eq(agg.version(), 2)?
    assert_eq(agg.uncommitted().len(), 2)?
}

test "event store append and load" {
    let store = InMemoryEventStore::<String>.new()
    
    store.append("agg-1", "test", ["event1", "event2"], 0)?
    store.append("agg-1", "test", ["event3"], 2)?
    
    let events = store.load("agg-1")
    assert_eq(events.len(), 3)?
}

test "concurrency conflict" {
    let store = InMemoryEventStore::<String>.new()
    
    store.append("agg-1", "test", ["event1"], 0)?
    let result = store.append("agg-1", "test", ["event2"], 0)
    
    assert(result.is_err())?
}

test "projection" {
    struct Counter { count: Int }
    impl Default for Counter { fn default() -> Self { Counter { count: 0 } } }
    
    let proj = SimpleProjection::<Counter, Int>.new(|s, n| Counter { count: s.count + n })
    
    proj.apply(5)
    proj.apply(3)
    
    assert_eq(proj.state().count, 8)?
}
