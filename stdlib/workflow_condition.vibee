// =============================================================================
// Vibee OS â€” Workflow Condition Module
// Conditions and expressions for workflow control flow
// =============================================================================

use result::{Result, Ok, Err}
use workflow_step::{StepContext, StepResult, StepStatus}

// =============================================================================
// Condition Trait
// =============================================================================

/// Trait for workflow conditions
trait Condition {
    fn evaluate(context: ConditionContext) -> Bool
    fn description() -> String
}

// =============================================================================
// Condition Context
// =============================================================================

/// Context for condition evaluation
struct ConditionContext {
    workflow_id: String
    variables: Map<String, Any>
    step_results: Map<String, StepResult>
    metadata: Map<String, Any>
    
    fn new(workflow_id: String) -> Self {
        ConditionContext {
            workflow_id: workflow_id,
            variables: Map.empty(),
            step_results: Map.empty(),
            metadata: Map.empty()
        }
    }
    
    fn with_variables(vars: Map<String, Any>) -> Self {
        self.variables = vars
        self
    }
    
    fn with_step_results(results: Map<String, StepResult>) -> Self {
        self.step_results = results
        self
    }
    
    fn get_variable<T>(key: String) -> Option<T> {
        self.variables.get(key).and_then(|v| v.cast::<T>())
    }
    
    fn get_step_result(step_id: String) -> Option<StepResult> {
        self.step_results.get(step_id)
    }
    
    fn step_succeeded(step_id: String) -> Bool {
        self.step_results.get(step_id)
            .map(|r| r.status.is_success())
            .unwrap_or(false)
    }
    
    fn step_failed(step_id: String) -> Bool {
        self.step_results.get(step_id)
            .map(|r| r.status.is_failure())
            .unwrap_or(false)
    }
    
    fn from_step_context(ctx: StepContext) -> Self {
        ConditionContext {
            workflow_id: ctx.workflow_id,
            variables: ctx.variables,
            step_results: Map.empty(),
            metadata: ctx.metadata
        }
    }
}

// =============================================================================
// Basic Conditions
// =============================================================================

/// Always true condition
struct AlwaysTrue {}

impl Condition for AlwaysTrue {
    fn evaluate(context: ConditionContext) -> Bool { true }
    fn description() -> String { "always" }
}

/// Always false condition
struct AlwaysFalse {}

impl Condition for AlwaysFalse {
    fn evaluate(context: ConditionContext) -> Bool { false }
    fn description() -> String { "never" }
}

/// Expression-based condition
struct ExpressionCondition {
    expression: fn(ConditionContext) -> Bool
    desc: String
    
    fn new(expression: fn(ConditionContext) -> Bool) -> Self {
        ExpressionCondition {
            expression: expression,
            desc: "custom expression"
        }
    }
    
    fn with_description(desc: String) -> Self {
        self.desc = desc
        self
    }
}

impl Condition for ExpressionCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        (self.expression)(context)
    }
    
    fn description() -> String { self.desc.clone() }
}

// =============================================================================
// Comparison Conditions
// =============================================================================

/// Comparison operators
enum CompareOp {
    Equal
    NotEqual
    GreaterThan
    GreaterThanOrEqual
    LessThan
    LessThanOrEqual
    Contains
    StartsWith
    EndsWith
    Matches
    
    fn to_string() -> String {
        match self {
            Equal => "=="
            NotEqual => "!="
            GreaterThan => ">"
            GreaterThanOrEqual => ">="
            LessThan => "<"
            LessThanOrEqual => "<="
            Contains => "contains"
            StartsWith => "starts_with"
            EndsWith => "ends_with"
            Matches => "matches"
        }
    }
}

/// Variable comparison condition
struct CompareCondition {
    variable: String
    operator: CompareOp
    value: Any
    
    fn new(variable: String, operator: CompareOp, value: Any) -> Self {
        CompareCondition {
            variable: variable,
            operator: operator,
            value: value
        }
    }
    
    fn equals(variable: String, value: Any) -> Self {
        Self.new(variable, CompareOp.Equal, value)
    }
    
    fn not_equals(variable: String, value: Any) -> Self {
        Self.new(variable, CompareOp.NotEqual, value)
    }
    
    fn greater_than(variable: String, value: Any) -> Self {
        Self.new(variable, CompareOp.GreaterThan, value)
    }
    
    fn less_than(variable: String, value: Any) -> Self {
        Self.new(variable, CompareOp.LessThan, value)
    }
    
    fn contains(variable: String, value: String) -> Self {
        Self.new(variable, CompareOp.Contains, value)
    }
    
    fn matches(variable: String, pattern: String) -> Self {
        Self.new(variable, CompareOp.Matches, pattern)
    }
}

impl Condition for CompareCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        let var_value = match context.get_variable::<Any>(self.variable.clone()) {
            Some(v) => v
            None => return false
        }
        
        match self.operator {
            CompareOp.Equal => var_value == self.value
            CompareOp.NotEqual => var_value != self.value
            CompareOp.GreaterThan => compare_values(var_value, self.value) > 0
            CompareOp.GreaterThanOrEqual => compare_values(var_value, self.value) >= 0
            CompareOp.LessThan => compare_values(var_value, self.value) < 0
            CompareOp.LessThanOrEqual => compare_values(var_value, self.value) <= 0
            CompareOp.Contains => {
                let s = var_value.to_string()
                let pattern = self.value.to_string()
                s.contains(pattern)
            }
            CompareOp.StartsWith => {
                let s = var_value.to_string()
                let pattern = self.value.to_string()
                s.starts_with(pattern)
            }
            CompareOp.EndsWith => {
                let s = var_value.to_string()
                let pattern = self.value.to_string()
                s.ends_with(pattern)
            }
            CompareOp.Matches => {
                let s = var_value.to_string()
                let pattern = self.value.to_string()
                regex::is_match(pattern, s)
            }
        }
    }
    
    fn description() -> String {
        format!("{} {} {}", self.variable, self.operator.to_string(), self.value)
    }
}

// =============================================================================
// Step-based Conditions
// =============================================================================

/// Condition based on step status
struct StepStatusCondition {
    step_id: String
    expected_status: StepStatus
    
    fn succeeded(step_id: String) -> Self {
        StepStatusCondition {
            step_id: step_id,
            expected_status: StepStatus.Completed
        }
    }
    
    fn failed(step_id: String) -> Self {
        StepStatusCondition {
            step_id: step_id,
            expected_status: StepStatus.Failed("")
        }
    }
    
    fn skipped(step_id: String) -> Self {
        StepStatusCondition {
            step_id: step_id,
            expected_status: StepStatus.Skipped
        }
    }
}

impl Condition for StepStatusCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        match context.get_step_result(self.step_id.clone()) {
            Some(result) => {
                match self.expected_status {
                    StepStatus.Completed => result.status.is_success()
                    StepStatus.Failed(_) => result.status.is_failure()
                    StepStatus.Skipped => matches!(result.status, StepStatus.Skipped)
                    _ => result.status == self.expected_status
                }
            }
            None => false
        }
    }
    
    fn description() -> String {
        format!("step '{}' is {}", self.step_id, self.expected_status.to_string())
    }
}

/// Condition based on step output
struct StepOutputCondition {
    step_id: String
    output_key: Option<String>
    predicate: fn(Any) -> Bool
    desc: String
    
    fn new(step_id: String, predicate: fn(Any) -> Bool) -> Self {
        StepOutputCondition {
            step_id: step_id,
            output_key: None,
            predicate: predicate,
            desc: "step output matches"
        }
    }
    
    fn with_key(key: String) -> Self {
        self.output_key = Some(key)
        self
    }
    
    fn equals(step_id: String, expected: Any) -> Self {
        Self.new(step_id, |v| v == expected)
    }
}

impl Condition for StepOutputCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        match context.get_step_result(self.step_id.clone()) {
            Some(result) => {
                match result.output {
                    Some(output) => {
                        let value = match self.output_key {
                            Some(key) => {
                                if let Some(map) = output.cast::<Map<String, Any>>() {
                                    map.get(key).unwrap_or(output)
                                } else {
                                    output
                                }
                            }
                            None => output
                        }
                        (self.predicate)(value)
                    }
                    None => false
                }
            }
            None => false
        }
    }
    
    fn description() -> String { self.desc.clone() }
}

// =============================================================================
// Logical Conditions
// =============================================================================

/// AND condition - all conditions must be true
struct AndCondition {
    conditions: [Box<dyn Condition>]
    
    fn new() -> Self {
        AndCondition { conditions: [] }
    }
    
    fn add<C: Condition>(condition: C) -> Self {
        self.conditions.push(Box.new(condition))
        self
    }
    
    fn from(conditions: [Box<dyn Condition>]) -> Self {
        AndCondition { conditions: conditions }
    }
}

impl Condition for AndCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        self.conditions.iter().all(|c| c.evaluate(context.clone()))
    }
    
    fn description() -> String {
        let descs = self.conditions.iter().map(|c| c.description()).collect::<Vec<_>>()
        format!("({})", descs.join(" AND "))
    }
}

/// OR condition - at least one condition must be true
struct OrCondition {
    conditions: [Box<dyn Condition>]
    
    fn new() -> Self {
        OrCondition { conditions: [] }
    }
    
    fn add<C: Condition>(condition: C) -> Self {
        self.conditions.push(Box.new(condition))
        self
    }
    
    fn from(conditions: [Box<dyn Condition>]) -> Self {
        OrCondition { conditions: conditions }
    }
}

impl Condition for OrCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        self.conditions.iter().any(|c| c.evaluate(context.clone()))
    }
    
    fn description() -> String {
        let descs = self.conditions.iter().map(|c| c.description()).collect::<Vec<_>>()
        format!("({})", descs.join(" OR "))
    }
}

/// NOT condition - negates another condition
struct NotCondition {
    condition: Box<dyn Condition>
    
    fn new<C: Condition>(condition: C) -> Self {
        NotCondition { condition: Box.new(condition) }
    }
}

impl Condition for NotCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        !self.condition.evaluate(context)
    }
    
    fn description() -> String {
        format!("NOT ({})", self.condition.description())
    }
}

// =============================================================================
// Time-based Conditions
// =============================================================================

/// Time window condition
struct TimeWindowCondition {
    start_hour: Int
    end_hour: Int
    days_of_week: Option<[Int]>
    timezone: String
    
    fn new(start_hour: Int, end_hour: Int) -> Self {
        TimeWindowCondition {
            start_hour: start_hour,
            end_hour: end_hour,
            days_of_week: None,
            timezone: "UTC"
        }
    }
    
    fn business_hours() -> Self {
        Self.new(9, 17).weekdays()
    }
    
    fn weekdays() -> Self {
        self.days_of_week = Some([1, 2, 3, 4, 5])
        self
    }
    
    fn weekends() -> Self {
        self.days_of_week = Some([0, 6])
        self
    }
    
    fn with_timezone(tz: String) -> Self {
        self.timezone = tz
        self
    }
}

impl Condition for TimeWindowCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        let now = DateTime.now().in_timezone(self.timezone.clone())
        let hour = now.hour()
        let day = now.weekday()
        
        let in_hours = if self.start_hour <= self.end_hour {
            hour >= self.start_hour && hour < self.end_hour
        } else {
            hour >= self.start_hour || hour < self.end_hour
        }
        
        let in_days = match self.days_of_week {
            Some(days) => days.contains(day)
            None => true
        }
        
        in_hours && in_days
    }
    
    fn description() -> String {
        format!("time between {}:00 and {}:00", self.start_hour, self.end_hour)
    }
}

/// Date range condition
struct DateRangeCondition {
    start_date: Option<DateTime>
    end_date: Option<DateTime>
    
    fn new() -> Self {
        DateRangeCondition {
            start_date: None,
            end_date: None
        }
    }
    
    fn after(date: DateTime) -> Self {
        DateRangeCondition {
            start_date: Some(date),
            end_date: None
        }
    }
    
    fn before(date: DateTime) -> Self {
        DateRangeCondition {
            start_date: None,
            end_date: Some(date)
        }
    }
    
    fn between(start: DateTime, end: DateTime) -> Self {
        DateRangeCondition {
            start_date: Some(start),
            end_date: Some(end)
        }
    }
}

impl Condition for DateRangeCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        let now = DateTime.now()
        
        let after_start = match self.start_date {
            Some(start) => now >= start
            None => true
        }
        
        let before_end = match self.end_date {
            Some(end) => now <= end
            None => true
        }
        
        after_start && before_end
    }
    
    fn description() -> String {
        match (self.start_date, self.end_date) {
            (Some(s), Some(e)) => format!("between {} and {}", s, e)
            (Some(s), None) => format!("after {}", s)
            (None, Some(e)) => format!("before {}", e)
            (None, None) => "always"
        }
    }
}

// =============================================================================
// Value-based Conditions
// =============================================================================

/// Check if variable exists
struct ExistsCondition {
    variable: String
    
    fn new(variable: String) -> Self {
        ExistsCondition { variable: variable }
    }
}

impl Condition for ExistsCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        context.variables.contains_key(self.variable.clone())
    }
    
    fn description() -> String {
        format!("{} exists", self.variable)
    }
}

/// Check if variable is empty
struct EmptyCondition {
    variable: String
    
    fn new(variable: String) -> Self {
        EmptyCondition { variable: variable }
    }
}

impl Condition for EmptyCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        match context.get_variable::<Any>(self.variable.clone()) {
            Some(value) => is_empty(value)
            None => true
        }
    }
    
    fn description() -> String {
        format!("{} is empty", self.variable)
    }
}

/// Range condition
struct RangeCondition {
    variable: String
    min: Option<Float>
    max: Option<Float>
    
    fn new(variable: String) -> Self {
        RangeCondition {
            variable: variable,
            min: None,
            max: None
        }
    }
    
    fn between(variable: String, min: Float, max: Float) -> Self {
        RangeCondition {
            variable: variable,
            min: Some(min),
            max: Some(max)
        }
    }
    
    fn at_least(variable: String, min: Float) -> Self {
        RangeCondition {
            variable: variable,
            min: Some(min),
            max: None
        }
    }
    
    fn at_most(variable: String, max: Float) -> Self {
        RangeCondition {
            variable: variable,
            min: None,
            max: Some(max)
        }
    }
}

impl Condition for RangeCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        let value = match context.get_variable::<Float>(self.variable.clone()) {
            Some(v) => v
            None => return false
        }
        
        let above_min = match self.min {
            Some(min) => value >= min
            None => true
        }
        
        let below_max = match self.max {
            Some(max) => value <= max
            None => true
        }
        
        above_min && below_max
    }
    
    fn description() -> String {
        match (self.min, self.max) {
            (Some(min), Some(max)) => format!("{} between {} and {}", self.variable, min, max)
            (Some(min), None) => format!("{} >= {}", self.variable, min)
            (None, Some(max)) => format!("{} <= {}", self.variable, max)
            (None, None) => format!("{} exists", self.variable)
        }
    }
}

/// In list condition
struct InListCondition {
    variable: String
    values: [Any]
    
    fn new(variable: String, values: [Any]) -> Self {
        InListCondition {
            variable: variable,
            values: values
        }
    }
}

impl Condition for InListCondition {
    fn evaluate(context: ConditionContext) -> Bool {
        match context.get_variable::<Any>(self.variable.clone()) {
            Some(value) => self.values.contains(value)
            None => false
        }
    }
    
    fn description() -> String {
        format!("{} in {:?}", self.variable, self.values)
    }
}

// =============================================================================
// Condition Builder
// =============================================================================

/// Fluent builder for conditions
struct ConditionBuilder {
    conditions: [Box<dyn Condition>]
    logic: LogicType
    
    fn new() -> Self {
        ConditionBuilder {
            conditions: [],
            logic: LogicType.And
        }
    }
    
    fn when(variable: String) -> VariableConditionBuilder {
        VariableConditionBuilder.new(variable)
    }
    
    fn step(step_id: String) -> StepConditionBuilder {
        StepConditionBuilder.new(step_id)
    }
    
    fn and<C: Condition>(condition: C) -> Self {
        self.conditions.push(Box.new(condition))
        self.logic = LogicType.And
        self
    }
    
    fn or<C: Condition>(condition: C) -> Self {
        self.conditions.push(Box.new(condition))
        self.logic = LogicType.Or
        self
    }
    
    fn build() -> Box<dyn Condition> {
        if self.conditions.len() == 1 {
            return self.conditions[0].clone()
        }
        
        match self.logic {
            LogicType.And => Box.new(AndCondition.from(self.conditions))
            LogicType.Or => Box.new(OrCondition.from(self.conditions))
        }
    }
}

enum LogicType {
    And
    Or
}

/// Builder for variable-based conditions
struct VariableConditionBuilder {
    variable: String
    
    fn new(variable: String) -> Self {
        VariableConditionBuilder { variable: variable }
    }
    
    fn equals(value: Any) -> CompareCondition {
        CompareCondition.equals(self.variable, value)
    }
    
    fn not_equals(value: Any) -> CompareCondition {
        CompareCondition.not_equals(self.variable, value)
    }
    
    fn greater_than(value: Any) -> CompareCondition {
        CompareCondition.greater_than(self.variable, value)
    }
    
    fn less_than(value: Any) -> CompareCondition {
        CompareCondition.less_than(self.variable, value)
    }
    
    fn contains(value: String) -> CompareCondition {
        CompareCondition.contains(self.variable, value)
    }
    
    fn matches(pattern: String) -> CompareCondition {
        CompareCondition.matches(self.variable, pattern)
    }
    
    fn exists() -> ExistsCondition {
        ExistsCondition.new(self.variable)
    }
    
    fn is_empty() -> EmptyCondition {
        EmptyCondition.new(self.variable)
    }
    
    fn in_list(values: [Any]) -> InListCondition {
        InListCondition.new(self.variable, values)
    }
    
    fn between(min: Float, max: Float) -> RangeCondition {
        RangeCondition.between(self.variable, min, max)
    }
}

/// Builder for step-based conditions
struct StepConditionBuilder {
    step_id: String
    
    fn new(step_id: String) -> Self {
        StepConditionBuilder { step_id: step_id }
    }
    
    fn succeeded() -> StepStatusCondition {
        StepStatusCondition.succeeded(self.step_id)
    }
    
    fn failed() -> StepStatusCondition {
        StepStatusCondition.failed(self.step_id)
    }
    
    fn skipped() -> StepStatusCondition {
        StepStatusCondition.skipped(self.step_id)
    }
    
    fn output_equals(expected: Any) -> StepOutputCondition {
        StepOutputCondition.equals(self.step_id, expected)
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn compare_values(a: Any, b: Any) -> Int {
    match (a, b) {
        (Int(a), Int(b)) => a.cmp(b)
        (Float(a), Float(b)) => a.partial_cmp(b).unwrap_or(0)
        (String(a), String(b)) => a.cmp(b)
        _ => 0
    }
}

fn is_empty(value: Any) -> Bool {
    match value {
        String(s) => s.is_empty()
        Array(a) => a.is_empty()
        Map(m) => m.is_empty()
        Option(None) => true
        _ => false
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Create AND condition
fn all(conditions: [Box<dyn Condition>]) -> AndCondition {
    AndCondition.from(conditions)
}

/// Create OR condition
fn any(conditions: [Box<dyn Condition>]) -> OrCondition {
    OrCondition.from(conditions)
}

/// Create NOT condition
fn not<C: Condition>(condition: C) -> NotCondition {
    NotCondition.new(condition)
}

/// Create expression condition
fn expr(f: fn(ConditionContext) -> Bool) -> ExpressionCondition {
    ExpressionCondition.new(f)
}

// =============================================================================
// Tests
// =============================================================================

test "always conditions" {
    let ctx = ConditionContext.new("wf-1")
    assert(AlwaysTrue{}.evaluate(ctx.clone()))?
    assert(!AlwaysFalse{}.evaluate(ctx))?
}

test "compare condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("count", 10)
    ctx.variables.set("name", "test")
    
    assert(CompareCondition.equals("count", 10).evaluate(ctx.clone()))?
    assert(CompareCondition.greater_than("count", 5).evaluate(ctx.clone()))?
    assert(CompareCondition.contains("name", "es").evaluate(ctx.clone()))?
}

test "and condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("a", true)
    ctx.variables.set("b", 10)
    
    let cond = AndCondition.new()
        .add(CompareCondition.equals("a", true))
        .add(CompareCondition.greater_than("b", 5))
    
    assert(cond.evaluate(ctx))?
}

test "or condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("x", 3)
    
    let cond = OrCondition.new()
        .add(CompareCondition.equals("x", 5))
        .add(CompareCondition.equals("x", 3))
    
    assert(cond.evaluate(ctx))?
}

test "not condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("flag", false)
    
    let cond = NotCondition.new(CompareCondition.equals("flag", true))
    assert(cond.evaluate(ctx))?
}

test "step status condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.step_results.set("step-1", StepResult.success(42))
    
    assert(StepStatusCondition.succeeded("step-1").evaluate(ctx.clone()))?
    assert(!StepStatusCondition.failed("step-1").evaluate(ctx))?
}

test "time window condition" {
    let cond = TimeWindowCondition.business_hours()
    // Result depends on current time
    let _ = cond.evaluate(ConditionContext.new("wf-1"))
}

test "condition builder" {
    let cond = ConditionBuilder.when("amount").greater_than(100)
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("amount", 150)
    
    assert(cond.evaluate(ctx))?
}

test "exists condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("key", "value")
    
    assert(ExistsCondition.new("key").evaluate(ctx.clone()))?
    assert(!ExistsCondition.new("missing").evaluate(ctx))?
}

test "range condition" {
    var ctx = ConditionContext.new("wf-1")
    ctx.variables.set("score", 75.0)
    
    assert(RangeCondition.between("score", 0.0, 100.0).evaluate(ctx.clone()))?
    assert(!RangeCondition.between("score", 80.0, 100.0).evaluate(ctx))?
}
