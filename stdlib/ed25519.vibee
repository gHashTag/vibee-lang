// =============================================================================
// Vibee OS â€” Ed25519 Module
// Edwards-curve Digital Signature Algorithm (EdDSA)
// =============================================================================
//
// Ed25519 is a high-performance digital signature scheme using:
// - Curve25519 elliptic curve
// - SHA-512 hash function
// - 256-bit keys, 512-bit signatures
//
// Benefits: Fast, constant-time, small keys/signatures, no random nonce needed
// =============================================================================

const PUBLIC_KEY_SIZE: Int = 32
const PRIVATE_KEY_SIZE: Int = 64
const SEED_SIZE: Int = 32
const SIGNATURE_SIZE: Int = 64

// =============================================================================
// Ed25519 Key Pair
// =============================================================================

/// Ed25519 key pair
struct Ed25519KeyPair {
    public_key: Ed25519PublicKey
    private_key: Ed25519PrivateKey
}

impl Ed25519KeyPair {
    /// Generate new random key pair
    fn generate() -> Self {
        let (pub_bytes, priv_bytes) = @native("ed25519_generate")
        Ed25519KeyPair {
            public_key: Ed25519PublicKey { bytes: pub_bytes },
            private_key: Ed25519PrivateKey { bytes: priv_bytes }
        }
    }
    
    /// Generate from 32-byte seed (deterministic)
    fn from_seed(seed: [UInt8; 32]) -> Self {
        let (pub_bytes, priv_bytes) = @native("ed25519_from_seed", seed)
        Ed25519KeyPair {
            public_key: Ed25519PublicKey { bytes: pub_bytes },
            private_key: Ed25519PrivateKey { bytes: priv_bytes }
        }
    }
    
    /// Generate from seed bytes
    fn from_seed_bytes(seed: [UInt8]) -> Result<Self, Ed25519Error> {
        if seed.len() != SEED_SIZE {
            return Err(Ed25519Error.InvalidSeedSize)
        }
        Ok(Self.from_seed(seed.try_into().unwrap()))
    }
    
    /// Generate from passphrase (using SHA-256 as seed)
    fn from_passphrase(passphrase: String) -> Self {
        let seed = crypto.sha256(passphrase.as_bytes())
        Self.from_seed(seed)
    }
    
    /// Generate from passphrase with salt (using HKDF)
    fn from_passphrase_salted(passphrase: String, salt: [UInt8]) -> Self {
        let seed = crypto.hkdf_sha256(passphrase.as_bytes(), salt, "ed25519-key".as_bytes(), 32)
        Self.from_seed(seed.try_into().unwrap())
    }
    
    /// Get public key
    fn public() -> Ed25519PublicKey {
        self.public_key
    }
    
    /// Get private key
    fn private() -> Ed25519PrivateKey {
        self.private_key
    }
    
    /// Sign message
    fn sign(message: [UInt8]) -> Ed25519Signature {
        self.private_key.sign(message)
    }
    
    /// Verify signature
    fn verify(message: [UInt8], signature: Ed25519Signature) -> Bool {
        self.public_key.verify(message, signature)
    }
}

// =============================================================================
// Ed25519 Public Key
// =============================================================================

/// Ed25519 public key (32 bytes)
struct Ed25519PublicKey {
    bytes: [UInt8; 32]
}

impl Ed25519PublicKey {
    /// Create from bytes
    fn from_bytes(bytes: [UInt8]) -> Result<Self, Ed25519Error> {
        if bytes.len() != PUBLIC_KEY_SIZE {
            return Err(Ed25519Error.InvalidPublicKeySize)
        }
        Ok(Ed25519PublicKey { bytes: bytes.try_into().unwrap() })
    }
    
    /// Create from hex string
    fn from_hex(hex_str: String) -> Result<Self, Ed25519Error> {
        let bytes = hex.decode(hex_str).map_err(|_| Ed25519Error.InvalidHex)?
        Self.from_bytes(bytes)
    }
    
    /// Create from base64
    fn from_base64(b64: String) -> Result<Self, Ed25519Error> {
        let bytes = base64.decode(b64).map_err(|_| Ed25519Error.InvalidBase64)?
        Self.from_bytes(bytes)
    }
    
    /// Get raw bytes
    fn as_bytes() -> [UInt8; 32] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to base64
    fn to_base64() -> String {
        base64.encode(self.bytes)
    }
    
    /// Verify signature
    fn verify(message: [UInt8], signature: Ed25519Signature) -> Bool {
        @native("ed25519_verify", self.bytes, message, signature.bytes)
    }
    
    /// Verify signature bytes
    fn verify_bytes(message: [UInt8], signature: [UInt8]) -> Result<Bool, Ed25519Error> {
        if signature.len() != SIGNATURE_SIZE {
            return Err(Ed25519Error.InvalidSignatureSize)
        }
        Ok(@native("ed25519_verify", self.bytes, message, signature))
    }
    
    /// Get fingerprint (first 8 bytes as hex)
    fn fingerprint() -> String {
        hex.encode(self.bytes[0..8])
    }
    
    /// Check if key is valid point on curve
    fn is_valid() -> Bool {
        @native("ed25519_public_key_is_valid", self.bytes)
    }
}

impl Display for Ed25519PublicKey {
    fn fmt(f: Formatter) {
        f.write(format!("Ed25519PublicKey({})", self.fingerprint()))
    }
}

impl Hash for Ed25519PublicKey {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

impl Eq for Ed25519PublicKey {
    fn eq(other: Ed25519PublicKey) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
}

// =============================================================================
// Ed25519 Private Key
// =============================================================================

/// Ed25519 private key (64 bytes: 32-byte seed + 32-byte public key)
struct Ed25519PrivateKey {
    bytes: [UInt8; 64]
}

impl Ed25519PrivateKey {
    /// Create from bytes
    fn from_bytes(bytes: [UInt8]) -> Result<Self, Ed25519Error> {
        if bytes.len() != PRIVATE_KEY_SIZE {
            return Err(Ed25519Error.InvalidPrivateKeySize)
        }
        Ok(Ed25519PrivateKey { bytes: bytes.try_into().unwrap() })
    }
    
    /// Create from seed (32 bytes)
    fn from_seed(seed: [UInt8; 32]) -> Self {
        let kp = Ed25519KeyPair.from_seed(seed)
        kp.private_key
    }
    
    /// Create from hex string
    fn from_hex(hex_str: String) -> Result<Self, Ed25519Error> {
        let bytes = hex.decode(hex_str).map_err(|_| Ed25519Error.InvalidHex)?
        Self.from_bytes(bytes)
    }
    
    /// Get raw bytes
    fn as_bytes() -> [UInt8; 64] {
        self.bytes
    }
    
    /// Get seed (first 32 bytes)
    fn seed() -> [UInt8; 32] {
        self.bytes[0..32].try_into().unwrap()
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Sign message
    fn sign(message: [UInt8]) -> Ed25519Signature {
        let sig_bytes = @native("ed25519_sign", self.bytes, message)
        Ed25519Signature { bytes: sig_bytes }
    }
    
    /// Sign and return raw bytes
    fn sign_bytes(message: [UInt8]) -> [UInt8; 64] {
        @native("ed25519_sign", self.bytes, message)
    }
    
    /// Extract public key
    fn public_key() -> Ed25519PublicKey {
        Ed25519PublicKey { bytes: self.bytes[32..64].try_into().unwrap() }
    }
    
    /// Securely zero key from memory
    fn zeroize() {
        crypto.secure_zero(self.bytes)
    }
}

impl Drop for Ed25519PrivateKey {
    fn drop() {
        self.zeroize()
    }
}

// =============================================================================
// Ed25519 Signature
// =============================================================================

/// Ed25519 signature (64 bytes)
struct Ed25519Signature {
    bytes: [UInt8; 64]
}

impl Ed25519Signature {
    /// Create from bytes
    fn from_bytes(bytes: [UInt8]) -> Result<Self, Ed25519Error> {
        if bytes.len() != SIGNATURE_SIZE {
            return Err(Ed25519Error.InvalidSignatureSize)
        }
        Ok(Ed25519Signature { bytes: bytes.try_into().unwrap() })
    }
    
    /// Create from hex string
    fn from_hex(hex_str: String) -> Result<Self, Ed25519Error> {
        let bytes = hex.decode(hex_str).map_err(|_| Ed25519Error.InvalidHex)?
        Self.from_bytes(bytes)
    }
    
    /// Create from base64
    fn from_base64(b64: String) -> Result<Self, Ed25519Error> {
        let bytes = base64.decode(b64).map_err(|_| Ed25519Error.InvalidBase64)?
        Self.from_bytes(bytes)
    }
    
    /// Get raw bytes
    fn as_bytes() -> [UInt8; 64] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to base64
    fn to_base64() -> String {
        base64.encode(self.bytes)
    }
    
    /// Get R component (first 32 bytes)
    fn r() -> [UInt8; 32] {
        self.bytes[0..32].try_into().unwrap()
    }
    
    /// Get S component (last 32 bytes)
    fn s() -> [UInt8; 32] {
        self.bytes[32..64].try_into().unwrap()
    }
}

impl Display for Ed25519Signature {
    fn fmt(f: Formatter) {
        f.write(format!("Ed25519Signature({}...)", self.to_hex()[0..16]))
    }
}

impl Eq for Ed25519Signature {
    fn eq(other: Ed25519Signature) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
}

// =============================================================================
// Batch Verification
// =============================================================================

/// Batch verify multiple signatures (more efficient than individual verification)
fn batch_verify(items: [(Ed25519PublicKey, [UInt8], Ed25519Signature)]) -> Bool {
    if items.is_empty() {
        return true
    }
    
    let public_keys = items.map(|(pk, _, _)| pk.bytes)
    let messages = items.map(|(_, msg, _)| msg)
    let signatures = items.map(|(_, _, sig)| sig.bytes)
    
    @native("ed25519_batch_verify", public_keys, messages, signatures)
}

/// Batch verification item
struct BatchItem {
    public_key: Ed25519PublicKey
    message: [UInt8]
    signature: Ed25519Signature
}

/// Batch verifier for collecting items
struct BatchVerifier {
    items: [BatchItem]
}

impl BatchVerifier {
    fn new() -> Self {
        BatchVerifier { items: [] }
    }
    
    fn add(public_key: Ed25519PublicKey, message: [UInt8], signature: Ed25519Signature) -> Self {
        self.items.push(BatchItem { public_key: public_key, message: message, signature: signature })
        self
    }
    
    fn verify() -> Bool {
        let tuples = self.items.map(|item| (item.public_key, item.message, item.signature))
        batch_verify(tuples)
    }
    
    fn clear() {
        self.items.clear()
    }
}

// =============================================================================
// Streaming Signer
// =============================================================================

/// Actor for streaming Ed25519 signing
actor Ed25519Signer {
    state private_key: Ed25519PrivateKey
    state hasher: crypto.Hasher
    
    fn new(private_key: Ed25519PrivateKey) -> Self {
        Ed25519Signer {
            private_key: private_key,
            hasher: crypto.Hasher.sha512()
        }
    }
    
    fn update(data: [UInt8]) {
        self.hasher.update(data)
    }
    
    fn update_str(s: String) {
        self.update(s.as_bytes())
    }
    
    fn sign() -> Ed25519Signature {
        let digest = self.hasher.finalize()
        // Ed25519ph (pre-hashed) variant
        let sig_bytes = @native("ed25519ph_sign", self.private_key.bytes, digest)
        Ed25519Signature { bytes: sig_bytes }
    }
    
    fn reset() {
        self.hasher.reset()
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Quick sign message
fn sign(private_key: Ed25519PrivateKey, message: [UInt8]) -> Ed25519Signature {
    private_key.sign(message)
}

/// Quick verify signature
fn verify(public_key: Ed25519PublicKey, message: [UInt8], signature: Ed25519Signature) -> Bool {
    public_key.verify(message, signature)
}

/// Generate new key pair
fn generate() -> Ed25519KeyPair {
    Ed25519KeyPair.generate()
}

/// Generate key pair from seed
fn from_seed(seed: [UInt8; 32]) -> Ed25519KeyPair {
    Ed25519KeyPair.from_seed(seed)
}

// =============================================================================
// Errors
// =============================================================================

enum Ed25519Error {
    InvalidPublicKeySize
    InvalidPrivateKeySize
    InvalidSignatureSize
    InvalidSeedSize
    InvalidHex
    InvalidBase64
    SigningFailed
    VerificationFailed
}

impl Display for Ed25519Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidPublicKeySize => f.write("Invalid public key size (expected 32 bytes)")
            InvalidPrivateKeySize => f.write("Invalid private key size (expected 64 bytes)")
            InvalidSignatureSize => f.write("Invalid signature size (expected 64 bytes)")
            InvalidSeedSize => f.write("Invalid seed size (expected 32 bytes)")
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidBase64 => f.write("Invalid base64 string")
            SigningFailed => f.write("Signing failed")
            VerificationFailed => f.write("Verification failed")
        }
    }
}

// =============================================================================
// Trait for Signable Types
// =============================================================================

trait Ed25519Signable {
    fn ed25519_sign(key: Ed25519PrivateKey) -> Ed25519Signature
}

impl Ed25519Signable for [UInt8] {
    fn ed25519_sign(key: Ed25519PrivateKey) -> Ed25519Signature {
        key.sign(self)
    }
}

impl Ed25519Signable for String {
    fn ed25519_sign(key: Ed25519PrivateKey) -> Ed25519Signature {
        key.sign(self.as_bytes())
    }
}

// =============================================================================
// Tests
// =============================================================================

test "generate and sign" {
    let kp = Ed25519KeyPair.generate()
    let message = "Hello, Ed25519!".as_bytes()
    
    let signature = kp.sign(message)
    assert(kp.verify(message, signature))?
}

test "deterministic from seed" {
    let seed = [0u8; 32]
    let kp1 = Ed25519KeyPair.from_seed(seed)
    let kp2 = Ed25519KeyPair.from_seed(seed)
    
    assert_eq(kp1.public_key.to_hex(), kp2.public_key.to_hex())?
}

test "wrong message fails" {
    let kp = Ed25519KeyPair.generate()
    let signature = kp.sign("correct".as_bytes())
    
    assert(!kp.public_key.verify("wrong".as_bytes(), signature))?
}

test "public key extraction" {
    let kp = Ed25519KeyPair.generate()
    let extracted = kp.private_key.public_key()
    
    assert_eq(extracted.to_hex(), kp.public_key.to_hex())?
}

test "signature serialization" {
    let kp = Ed25519KeyPair.generate()
    let signature = kp.sign("test".as_bytes())
    
    let hex_str = signature.to_hex()
    let restored = Ed25519Signature.from_hex(hex_str)?
    
    assert_eq(signature.bytes, restored.bytes)?
}

test "batch verification" {
    let kp1 = Ed25519KeyPair.generate()
    let kp2 = Ed25519KeyPair.generate()
    
    let msg1 = "message1".as_bytes()
    let msg2 = "message2".as_bytes()
    
    let sig1 = kp1.sign(msg1)
    let sig2 = kp2.sign(msg2)
    
    let items = [
        (kp1.public_key, msg1, sig1),
        (kp2.public_key, msg2, sig2)
    ]
    
    assert(batch_verify(items))?
}

test "from passphrase" {
    let kp1 = Ed25519KeyPair.from_passphrase("my secret passphrase")
    let kp2 = Ed25519KeyPair.from_passphrase("my secret passphrase")
    
    assert_eq(kp1.public_key.to_hex(), kp2.public_key.to_hex())?
}

test "key sizes" {
    let kp = Ed25519KeyPair.generate()
    
    assert_eq(kp.public_key.as_bytes().len(), 32)?
    assert_eq(kp.private_key.as_bytes().len(), 64)?
}

test "trait implementation" {
    let kp = Ed25519KeyPair.generate()
    let signature = "Hello".ed25519_sign(kp.private_key)
    
    assert(kp.public_key.verify("Hello".as_bytes(), signature))?
}
