// =============================================================================
// Vibee OS â€” BSON Module
// Binary JSON format (MongoDB)
// =============================================================================

// -----------------------------------------------------------------------------
// BSON Types
// -----------------------------------------------------------------------------

const TYPE_DOUBLE: UInt8 = 0x01
const TYPE_STRING: UInt8 = 0x02
const TYPE_DOCUMENT: UInt8 = 0x03
const TYPE_ARRAY: UInt8 = 0x04
const TYPE_BINARY: UInt8 = 0x05
const TYPE_UNDEFINED: UInt8 = 0x06  // Deprecated
const TYPE_OBJECTID: UInt8 = 0x07
const TYPE_BOOLEAN: UInt8 = 0x08
const TYPE_DATETIME: UInt8 = 0x09
const TYPE_NULL: UInt8 = 0x0A
const TYPE_REGEX: UInt8 = 0x0B
const TYPE_DBPOINTER: UInt8 = 0x0C  // Deprecated
const TYPE_JAVASCRIPT: UInt8 = 0x0D
const TYPE_SYMBOL: UInt8 = 0x0E    // Deprecated
const TYPE_JAVASCRIPT_SCOPE: UInt8 = 0x0F
const TYPE_INT32: UInt8 = 0x10
const TYPE_TIMESTAMP: UInt8 = 0x11
const TYPE_INT64: UInt8 = 0x12
const TYPE_DECIMAL128: UInt8 = 0x13
const TYPE_MIN_KEY: UInt8 = 0xFF
const TYPE_MAX_KEY: UInt8 = 0x7F

// Binary subtypes
const BINARY_GENERIC: UInt8 = 0x00
const BINARY_FUNCTION: UInt8 = 0x01
const BINARY_OLD: UInt8 = 0x02
const BINARY_UUID_OLD: UInt8 = 0x03
const BINARY_UUID: UInt8 = 0x04
const BINARY_MD5: UInt8 = 0x05
const BINARY_ENCRYPTED: UInt8 = 0x06
const BINARY_USER: UInt8 = 0x80

// -----------------------------------------------------------------------------
// Value Type
// -----------------------------------------------------------------------------

enum Value {
    Double(Float64)
    String(String)
    Document(Document)
    Array([Value])
    Binary(UInt8, [UInt8])
    ObjectId(ObjectId)
    Boolean(Bool)
    DateTime(Int64)
    Null
    Regex(String, String)
    JavaScript(String)
    JavaScriptScope(String, Document)
    Int32(Int32)
    Timestamp(UInt64)
    Int64(Int64)
    Decimal128([UInt8])
    MinKey
    MaxKey
    
    fn as_double() -> Option<Float64> { match self { .Double(d) => Some(d), _ => None } }
    fn as_string() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_document() -> Option<Document> { match self { .Document(d) => Some(d), _ => None } }
    fn as_array() -> Option<[Value]> { match self { .Array(a) => Some(a), _ => None } }
    fn as_bool() -> Option<Bool> { match self { .Boolean(b) => Some(b), _ => None } }
    fn as_int32() -> Option<Int32> { match self { .Int32(i) => Some(i), _ => None } }
    fn as_int64() -> Option<Int64> { match self { .Int64(i) => Some(i), .Int32(i) => Some(i as Int64), _ => None } }
    fn as_datetime() -> Option<Int64> { match self { .DateTime(d) => Some(d), _ => None } }
    fn as_objectid() -> Option<ObjectId> { match self { .ObjectId(o) => Some(o), _ => None } }
    fn is_null() -> Bool { match self { .Null => true, _ => false } }
}

// -----------------------------------------------------------------------------
// ObjectId
// -----------------------------------------------------------------------------

struct ObjectId {
    bytes: [UInt8]  // 12 bytes
    
    fn new() -> Self {
        // Generate: 4 bytes timestamp + 5 bytes random + 3 bytes counter
        var bytes = [0u8; 12]
        let timestamp = (DateTime.now().timestamp() as UInt32).to_le_bytes()
        for i in 0..4 { bytes[i] = timestamp[i] }
        let random = Random.bytes(5)
        for i in 0..5 { bytes[4 + i] = random[i] }
        let counter = OBJECTID_COUNTER.fetch_add(1) as UInt32
        bytes[9] = ((counter >> 16) & 0xFF) as UInt8
        bytes[10] = ((counter >> 8) & 0xFF) as UInt8
        bytes[11] = (counter & 0xFF) as UInt8
        ObjectId { bytes: bytes }
    }
    
    fn from_bytes(bytes: [UInt8]) -> Result<Self, BSONError> {
        if bytes.len() != 12 { return Err(BSONError.InvalidObjectId) }
        Ok(ObjectId { bytes: bytes })
    }
    
    fn from_hex(hex: String) -> Result<Self, BSONError> {
        if hex.len() != 24 { return Err(BSONError.InvalidObjectId) }
        var bytes = []
        for i in 0..12 {
            let h = hex[(i * 2)..(i * 2 + 2)]
            bytes.push(UInt8.parse_hex(h).map_err(|_| BSONError.InvalidObjectId)?)
        }
        Ok(ObjectId { bytes: bytes })
    }
    
    fn to_hex() -> String {
        self.bytes.map(|b| format!("{:02x}", b)).join("")
    }
    
    fn timestamp() -> Int64 {
        ((self.bytes[0] as UInt32) |
         ((self.bytes[1] as UInt32) << 8) |
         ((self.bytes[2] as UInt32) << 16) |
         ((self.bytes[3] as UInt32) << 24)) as Int64
    }
}

static OBJECTID_COUNTER: Atomic<Int> = Atomic.new(Random.int(0, 0xFFFFFF))

// -----------------------------------------------------------------------------
// Document
// -----------------------------------------------------------------------------

struct Document {
    fields: [(String, Value)]
    
    fn new() -> Self { Document { fields: [] } }
    
    fn get(key: String) -> Option<Value> {
        for (k, v) in self.fields {
            if k == key { return Some(v) }
        }
        None
    }
    
    fn set(key: String, value: Value) {
        for i in 0..self.fields.len() {
            if self.fields[i].0 == key {
                self.fields[i] = (key, value)
                return
            }
        }
        self.fields.push((key, value))
    }
    
    fn remove(key: String) -> Option<Value> {
        for i in 0..self.fields.len() {
            if self.fields[i].0 == key {
                let (_, v) = self.fields.remove(i)
                return Some(v)
            }
        }
        None
    }
    
    fn contains(key: String) -> Bool { self.get(key).is_some() }
    fn keys() -> [String] { self.fields.map(|(k, _)| k) }
    fn values() -> [Value] { self.fields.map(|(_, v)| v) }
    fn len() -> Int { self.fields.len() }
    fn is_empty() -> Bool { self.fields.is_empty() }
    
    fn iter() -> Iterator<(String, Value)> { self.fields.iter() }
}

impl Index<String> for Document {
    type Output = Option<Value>
    fn index(key: String) -> Option<Value> { self.get(key) }
}

// -----------------------------------------------------------------------------
// Encoder
// -----------------------------------------------------------------------------

actor Encoder {
    state buffer: [UInt8]
    
    fn new() -> Self { Encoder { buffer: [] } }
    
    fn encode(doc: Document) -> [UInt8] {
        self.buffer.clear()
        self.write_document(doc)
        self.buffer.clone()
    }
    
    fn write_document(doc: Document) {
        let start = self.buffer.len()
        self.write_le32(0)  // Placeholder for size
        
        for (key, value) in doc.fields {
            self.write_element(key, value)
        }
        
        self.buffer.push(0x00)  // Document terminator
        
        // Update size
        let size = (self.buffer.len() - start) as UInt32
        let size_bytes = size.to_le_bytes()
        for i in 0..4 { self.buffer[start + i] = size_bytes[i] }
    }
    
    fn write_element(key: String, value: Value) {
        match value {
            .Double(d) => { self.buffer.push(TYPE_DOUBLE); self.write_cstring(key); self.write_le64(d.to_bits()) }
            .String(s) => { self.buffer.push(TYPE_STRING); self.write_cstring(key); self.write_string(s) }
            .Document(d) => { self.buffer.push(TYPE_DOCUMENT); self.write_cstring(key); self.write_document(d) }
            .Array(a) => { self.buffer.push(TYPE_ARRAY); self.write_cstring(key); self.write_array(a) }
            .Binary(subtype, data) => { self.buffer.push(TYPE_BINARY); self.write_cstring(key); self.write_binary(subtype, data) }
            .ObjectId(oid) => { self.buffer.push(TYPE_OBJECTID); self.write_cstring(key); self.buffer.extend(oid.bytes) }
            .Boolean(b) => { self.buffer.push(TYPE_BOOLEAN); self.write_cstring(key); self.buffer.push(if b { 1 } else { 0 }) }
            .DateTime(dt) => { self.buffer.push(TYPE_DATETIME); self.write_cstring(key); self.write_le64(dt as UInt64) }
            .Null => { self.buffer.push(TYPE_NULL); self.write_cstring(key) }
            .Regex(pattern, options) => { self.buffer.push(TYPE_REGEX); self.write_cstring(key); self.write_cstring(pattern); self.write_cstring(options) }
            .JavaScript(code) => { self.buffer.push(TYPE_JAVASCRIPT); self.write_cstring(key); self.write_string(code) }
            .JavaScriptScope(code, scope) => { self.buffer.push(TYPE_JAVASCRIPT_SCOPE); self.write_cstring(key); self.write_code_scope(code, scope) }
            .Int32(i) => { self.buffer.push(TYPE_INT32); self.write_cstring(key); self.write_le32(i as UInt32) }
            .Timestamp(t) => { self.buffer.push(TYPE_TIMESTAMP); self.write_cstring(key); self.write_le64(t) }
            .Int64(i) => { self.buffer.push(TYPE_INT64); self.write_cstring(key); self.write_le64(i as UInt64) }
            .Decimal128(d) => { self.buffer.push(TYPE_DECIMAL128); self.write_cstring(key); self.buffer.extend(d) }
            .MinKey => { self.buffer.push(TYPE_MIN_KEY); self.write_cstring(key) }
            .MaxKey => { self.buffer.push(TYPE_MAX_KEY); self.write_cstring(key) }
        }
    }
    
    fn write_array(arr: [Value]) {
        var doc = Document.new()
        for (i, v) in arr.enumerate() {
            doc.set("\(i)", v)
        }
        self.write_document(doc)
    }
    
    fn write_binary(subtype: UInt8, data: [UInt8]) {
        self.write_le32(data.len() as UInt32)
        self.buffer.push(subtype)
        self.buffer.extend(data)
    }
    
    fn write_code_scope(code: String, scope: Document) {
        let start = self.buffer.len()
        self.write_le32(0)  // Placeholder
        self.write_string(code)
        self.write_document(scope)
        let size = (self.buffer.len() - start) as UInt32
        let size_bytes = size.to_le_bytes()
        for i in 0..4 { self.buffer[start + i] = size_bytes[i] }
    }
    
    fn write_cstring(s: String) {
        self.buffer.extend(s.as_bytes())
        self.buffer.push(0x00)
    }
    
    fn write_string(s: String) {
        let bytes = s.as_bytes()
        self.write_le32((bytes.len() + 1) as UInt32)
        self.buffer.extend(bytes)
        self.buffer.push(0x00)
    }
    
    fn write_le32(v: UInt32) { for i in 0..4 { self.buffer.push(((v >> (i * 8)) & 0xFF) as UInt8) } }
    fn write_le64(v: UInt64) { for i in 0..8 { self.buffer.push(((v >> (i * 8)) & 0xFF) as UInt8) } }
}

// -----------------------------------------------------------------------------
// Decoder
// -----------------------------------------------------------------------------

actor Decoder {
    state data: [UInt8]
    state pos: Int
    
    fn new(data: [UInt8]) -> Self { Decoder { data: data, pos: 0 } }
    
    fn decode(data: [UInt8]) -> Result<Document, BSONError> {
        var d = Decoder.new(data)
        d.read_document()
    }
    
    fn read_document() -> Result<Document, BSONError> {
        let size = self.read_le32()? as Int
        let end = self.pos - 4 + size
        
        var doc = Document.new()
        while self.pos < end - 1 {
            let type_byte = self.read_byte()?
            if type_byte == 0x00 { break }
            let key = self.read_cstring()?
            let value = self.read_value(type_byte)?
            doc.set(key, value)
        }
        
        self.read_byte()?  // Terminator
        Ok(doc)
    }
    
    fn read_value(type_byte: UInt8) -> Result<Value, BSONError> {
        match type_byte {
            TYPE_DOUBLE => Ok(Value.Double(Float64.from_bits(self.read_le64()?)))
            TYPE_STRING => Ok(Value.String(self.read_string()?))
            TYPE_DOCUMENT => Ok(Value.Document(self.read_document()?))
            TYPE_ARRAY => Ok(Value.Array(self.read_array()?))
            TYPE_BINARY => self.read_binary()
            TYPE_OBJECTID => Ok(Value.ObjectId(ObjectId.from_bytes(self.read_bytes(12)?)?))
            TYPE_BOOLEAN => Ok(Value.Boolean(self.read_byte()? != 0))
            TYPE_DATETIME => Ok(Value.DateTime(self.read_le64()? as Int64))
            TYPE_NULL => Ok(Value.Null)
            TYPE_REGEX => { let p = self.read_cstring()?; let o = self.read_cstring()?; Ok(Value.Regex(p, o)) }
            TYPE_JAVASCRIPT => Ok(Value.JavaScript(self.read_string()?))
            TYPE_JAVASCRIPT_SCOPE => self.read_code_scope()
            TYPE_INT32 => Ok(Value.Int32(self.read_le32()? as Int32))
            TYPE_TIMESTAMP => Ok(Value.Timestamp(self.read_le64()?))
            TYPE_INT64 => Ok(Value.Int64(self.read_le64()? as Int64))
            TYPE_DECIMAL128 => Ok(Value.Decimal128(self.read_bytes(16)?))
            TYPE_MIN_KEY => Ok(Value.MinKey)
            TYPE_MAX_KEY => Ok(Value.MaxKey)
            _ => Err(BSONError.UnknownType(type_byte))
        }
    }
    
    fn read_array() -> Result<[Value], BSONError> {
        let doc = self.read_document()?
        var arr = []
        for i in 0..doc.len() {
            if let Some(v) = doc.get("\(i)") { arr.push(v) }
            else { break }
        }
        Ok(arr)
    }
    
    fn read_binary() -> Result<Value, BSONError> {
        let len = self.read_le32()? as Int
        let subtype = self.read_byte()?
        let data = self.read_bytes(len)?
        Ok(Value.Binary(subtype, data))
    }
    
    fn read_code_scope() -> Result<Value, BSONError> {
        let _size = self.read_le32()?
        let code = self.read_string()?
        let scope = self.read_document()?
        Ok(Value.JavaScriptScope(code, scope))
    }
    
    fn read_byte() -> Result<UInt8, BSONError> {
        if self.pos >= self.data.len() { return Err(BSONError.UnexpectedEof) }
        let b = self.data[self.pos]; self.pos += 1; Ok(b)
    }
    
    fn read_bytes(len: Int) -> Result<[UInt8], BSONError> {
        if self.pos + len > self.data.len() { return Err(BSONError.UnexpectedEof) }
        let r = self.data[self.pos..(self.pos + len)].to_vec(); self.pos += len; Ok(r)
    }
    
    fn read_cstring() -> Result<String, BSONError> {
        let start = self.pos
        while self.pos < self.data.len() && self.data[self.pos] != 0 { self.pos += 1 }
        if self.pos >= self.data.len() { return Err(BSONError.UnexpectedEof) }
        let s = String.from_utf8(self.data[start..self.pos].to_vec())?
        self.pos += 1  // Skip null terminator
        Ok(s)
    }
    
    fn read_string() -> Result<String, BSONError> {
        let len = self.read_le32()? as Int
        let bytes = self.read_bytes(len - 1)?
        self.read_byte()?  // Null terminator
        Ok(String.from_utf8(bytes)?)
    }
    
    fn read_le32() -> Result<UInt32, BSONError> {
        let b = self.read_bytes(4)?
        Ok((b[0] as UInt32) | ((b[1] as UInt32) << 8) | ((b[2] as UInt32) << 16) | ((b[3] as UInt32) << 24))
    }
    
    fn read_le64() -> Result<UInt64, BSONError> {
        let b = self.read_bytes(8)?
        var r: UInt64 = 0
        for i in 0..8 { r |= (b[i] as UInt64) << (i * 8) }
        Ok(r)
    }
}

// -----------------------------------------------------------------------------
// Builder Pattern
// -----------------------------------------------------------------------------

struct DocumentBuilder {
    doc: Document
    
    fn new() -> Self { DocumentBuilder { doc: Document.new() } }
    
    fn double(key: String, value: Float64) -> Self { self.doc.set(key, Value.Double(value)); self }
    fn string(key: String, value: String) -> Self { self.doc.set(key, Value.String(value)); self }
    fn document(key: String, value: Document) -> Self { self.doc.set(key, Value.Document(value)); self }
    fn array(key: String, value: [Value]) -> Self { self.doc.set(key, Value.Array(value)); self }
    fn binary(key: String, data: [UInt8]) -> Self { self.doc.set(key, Value.Binary(BINARY_GENERIC, data)); self }
    fn objectid(key: String, value: ObjectId) -> Self { self.doc.set(key, Value.ObjectId(value)); self }
    fn bool(key: String, value: Bool) -> Self { self.doc.set(key, Value.Boolean(value)); self }
    fn datetime(key: String, value: Int64) -> Self { self.doc.set(key, Value.DateTime(value)); self }
    fn null(key: String) -> Self { self.doc.set(key, Value.Null); self }
    fn int32(key: String, value: Int32) -> Self { self.doc.set(key, Value.Int32(value)); self }
    fn int64(key: String, value: Int64) -> Self { self.doc.set(key, Value.Int64(value)); self }
    
    fn build() -> Document { self.doc }
}

// -----------------------------------------------------------------------------
// Errors & API
// -----------------------------------------------------------------------------

enum BSONError {
    UnexpectedEof
    InvalidUtf8
    InvalidObjectId
    UnknownType(UInt8)
    InvalidDocument
}

fn encode(doc: Document) -> [UInt8] { Encoder.new().encode(doc) }
fn decode(data: [UInt8]) -> Result<Document, BSONError> { Decoder.decode(data) }
fn builder() -> DocumentBuilder { DocumentBuilder.new() }

trait BSONSerializable {
    fn to_bson() -> Document
    fn from_bson(doc: Document) -> Result<Self, BSONError>
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "roundtrip document" {
    let doc = builder()
        .string("name", "Alice")
        .int32("age", 30)
        .bool("active", true)
        .build()
    
    let encoded = encode(doc)
    let decoded = decode(encoded)?
    
    assert(decoded["name"]?.as_string() == Some("Alice"))
    assert(decoded["age"]?.as_int32() == Some(30))
    assert(decoded["active"]?.as_bool() == Some(true))
}

test "objectid" {
    let oid = ObjectId.new()
    let hex = oid.to_hex()
    assert(hex.len() == 24)
    
    let parsed = ObjectId.from_hex(hex)?
    assert(parsed.bytes == oid.bytes)
}

test "nested document" {
    let inner = builder().string("city", "NYC").build()
    let outer = builder()
        .string("name", "Bob")
        .document("address", inner)
        .build()
    
    let decoded = decode(encode(outer))?
    let addr = decoded["address"]?.as_document()?
    assert(addr["city"]?.as_string() == Some("NYC"))
}

test "array" {
    let doc = builder()
        .array("numbers", [Value.Int32(1), Value.Int32(2), Value.Int32(3)])
        .build()
    
    let decoded = decode(encode(doc))?
    let arr = decoded["numbers"]?.as_array()?
    assert(arr.len() == 3)
    assert(arr[0].as_int32() == Some(1))
}
