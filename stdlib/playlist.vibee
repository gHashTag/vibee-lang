// =============================================================================
// Vibee OS â€” Playlist Module
// Audio playlist management with playback control
// =============================================================================

use audio::{AudioClip, AudioBuffer, AudioFormat, AudioError}
use datetime::{DateTime, Duration}

/// Playback mode
enum PlaybackMode {
    Normal,
    RepeatOne,
    RepeatAll,
    Shuffle
}

/// Track in playlist
struct Track {
    id: String
    title: String
    artist: String
    album: String
    duration: Float64
    path: String
    metadata: TrackMetadata
    
    fn new(id: String, title: String, path: String) -> Self {
        Track {
            id: id, title: title, artist: "", album: "",
            duration: 0.0, path: path, metadata: TrackMetadata.new()
        }
    }
    
    fn with_artist(artist: String) -> Self {
        self.artist = artist
        self
    }
    
    fn with_album(album: String) -> Self {
        self.album = album
        self
    }
    
    fn load() -> Result<AudioClip, AudioError> {
        AudioClip.load(self.path)
    }
}

/// Track metadata
struct TrackMetadata {
    year: Option<Int>
    genre: Option<String>
    track_number: Option<Int>
    play_count: Int
    rating: Int
    
    fn new() -> Self {
        TrackMetadata {
            year: None, genre: None, track_number: None,
            play_count: 0, rating: 0
        }
    }
}

/// Playlist
struct Playlist {
    id: String
    name: String
    tracks: [Track]
    created_at: DateTime
    
    fn new(name: String) -> Self {
        Playlist {
            id: @native("uuid_v4"),
            name: name,
            tracks: [],
            created_at: DateTime.now()
        }
    }
    
    fn add_track(track: Track) {
        self.tracks.push(track)
    }
    
    fn remove_track(id: String) {
        self.tracks = self.tracks.filter(|t| t.id != id)
    }
    
    fn get_track(index: Int) -> Option<Track> {
        if index >= 0 && index < self.tracks.len() {
            Some(self.tracks[index])
        } else { None }
    }
    
    fn total_duration() -> Float64 {
        self.tracks.iter().map(|t| t.duration).sum()
    }
    
    fn shuffle() {
        @native("array_shuffle", self.tracks)
    }
    
    fn sort_by_title() {
        self.tracks.sort_by(|a, b| a.title.cmp(b.title))
    }
    
    fn sort_by_artist() {
        self.tracks.sort_by(|a, b| a.artist.cmp(b.artist))
    }
}

/// Playlist player
actor PlaylistPlayer {
    state playlist: Option<Playlist>
    state current_index: Int
    state position: Float64
    state playing: Bool
    state volume: Float64
    state mode: PlaybackMode
    state shuffle_order: [Int]
    
    fn new() -> Self {
        PlaylistPlayer {
            playlist: None, current_index: 0, position: 0.0,
            playing: false, volume: 1.0, mode: PlaybackMode.Normal,
            shuffle_order: []
        }
    }
    
    fn load_playlist(playlist: Playlist) {
        self.playlist = Some(playlist)
        self.current_index = 0
        self.position = 0.0
        self.generate_shuffle_order()
    }
    
    fn play() {
        self.playing = true
        @native("playlist_play", self)
    }
    
    fn pause() {
        self.playing = false
        @native("playlist_pause", self)
    }
    
    fn stop() {
        self.playing = false
        self.position = 0.0
        @native("playlist_stop", self)
    }
    
    fn next() {
        if let Some(pl) = self.playlist {
            match self.mode {
                PlaybackMode.Shuffle => {
                    let idx = self.shuffle_order.iter().position(|i| i == self.current_index)
                    if let Some(i) = idx {
                        if i + 1 < self.shuffle_order.len() {
                            self.current_index = self.shuffle_order[i + 1]
                        } else if self.mode == PlaybackMode.RepeatAll {
                            self.current_index = self.shuffle_order[0]
                        }
                    }
                },
                _ => {
                    if self.current_index + 1 < pl.tracks.len() {
                        self.current_index += 1
                    } else if self.mode == PlaybackMode.RepeatAll {
                        self.current_index = 0
                    }
                }
            }
            self.position = 0.0
        }
    }
    
    fn previous() {
        if self.position > 3.0 {
            self.position = 0.0
        } else if self.current_index > 0 {
            self.current_index -= 1
            self.position = 0.0
        }
    }
    
    fn seek(position: Float64) {
        self.position = position.max(0.0)
    }
    
    fn set_volume(volume: Float64) {
        self.volume = volume.clamp(0.0, 1.0)
    }
    
    fn set_mode(mode: PlaybackMode) {
        self.mode = mode
        if mode == PlaybackMode.Shuffle {
            self.generate_shuffle_order()
        }
    }
    
    fn generate_shuffle_order() {
        if let Some(pl) = self.playlist {
            self.shuffle_order = (0..pl.tracks.len()).collect()
            @native("array_shuffle", self.shuffle_order)
        }
    }
    
    fn current_track() -> Option<Track> {
        self.playlist?.get_track(self.current_index)
    }
    
    fn is_playing() -> Bool { self.playing }
    fn get_position() -> Float64 { self.position }
    fn get_volume() -> Float64 { self.volume }
}

// Tests
test "create playlist" {
    let pl = Playlist.new("My Playlist")
    assert_eq(pl.tracks.len(), 0)?
}

test "add track" {
    var pl = Playlist.new("Test")
    pl.add_track(Track.new("1", "Song", "/path/song.mp3"))
    assert_eq(pl.tracks.len(), 1)?
}

test "playback mode" {
    var player = PlaylistPlayer.new()
    player.set_mode(PlaybackMode.Shuffle)
    assert_eq(player.mode, PlaybackMode.Shuffle)?
}
