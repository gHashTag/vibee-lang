// =============================================================================
// Vibee OS â€” Order Module
// E-commerce order management and processing
// =============================================================================

use money::{Money, usd}
use currency::{Currency}
use datetime::{DateTime}
use uuid::{UUID}
use cart::{Cart, CartItem, Address, ShippingMethod}

// =============================================================================
// Order Status
// =============================================================================

enum OrderStatus {
    Pending
    Confirmed
    Processing
    Shipped
    Delivered
    Cancelled
    Refunded
    OnHold
}

impl OrderStatus {
    fn is_active() -> Bool {
        match self {
            OrderStatus.Pending | OrderStatus.Confirmed | 
            OrderStatus.Processing | OrderStatus.Shipped => true
            _ => false
        }
    }
    
    fn is_cancellable() -> Bool {
        match self {
            OrderStatus.Pending | OrderStatus.Confirmed => true
            _ => false
        }
    }
    
    fn display_name() -> String {
        match self {
            OrderStatus.Pending => "Pending"
            OrderStatus.Confirmed => "Confirmed"
            OrderStatus.Processing => "Processing"
            OrderStatus.Shipped => "Shipped"
            OrderStatus.Delivered => "Delivered"
            OrderStatus.Cancelled => "Cancelled"
            OrderStatus.Refunded => "Refunded"
            OrderStatus.OnHold => "On Hold"
        }
    }
}

enum PaymentStatus {
    Pending
    Authorized
    Paid
    PartiallyPaid
    Refunded
    PartiallyRefunded
    Failed
    Voided
}

enum FulfillmentStatus {
    Unfulfilled
    PartiallyFulfilled
    Fulfilled
    Returned
    PartiallyReturned
}

// =============================================================================
// Order Line Item
// =============================================================================

struct OrderItem {
    id: String
    product_id: String
    variant_id: Option<String>
    sku: String
    name: String
    quantity: Int
    unit_price: Money
    discount: Money
    tax: Money
    total: Money
    fulfilled_quantity: Int
    returned_quantity: Int
    attributes: Map<String, String>
    image_url: Option<String>
}

impl OrderItem {
    fn from_cart_item(item: CartItem) -> Self {
        let subtotal = item.unit_price.mul_int(item.quantity)
        OrderItem {
            id: UUID.v4().to_string(),
            product_id: item.product_id,
            variant_id: item.variant_id,
            sku: item.sku,
            name: item.name,
            quantity: item.quantity,
            unit_price: item.unit_price,
            discount: item.discount_amount,
            tax: item.tax_amount,
            total: subtotal - item.discount_amount + item.tax_amount,
            fulfilled_quantity: 0,
            returned_quantity: 0,
            attributes: item.attributes,
            image_url: item.image_url
        }
    }
    
    fn is_fulfilled() -> Bool {
        self.fulfilled_quantity >= self.quantity
    }
    
    fn unfulfilled_quantity() -> Int {
        self.quantity - self.fulfilled_quantity
    }
}

// =============================================================================
// Order
// =============================================================================

struct Order {
    id: String
    order_number: String
    user_id: Option<String>
    email: String
    status: OrderStatus
    payment_status: PaymentStatus
    fulfillment_status: FulfillmentStatus
    items: [OrderItem]
    currency: Currency
    subtotal: Money
    discount_total: Money
    tax_total: Money
    shipping_total: Money
    total: Money
    shipping_address: Address
    billing_address: Address
    shipping_method: Option<ShippingMethod>
    payments: [Payment]
    fulfillments: [Fulfillment]
    notes: Option<String>
    customer_notes: Option<String>
    ip_address: Option<String>
    user_agent: Option<String>
    metadata: Map<String, String>
    created_at: DateTime
    updated_at: DateTime
    completed_at: Option<DateTime>
    cancelled_at: Option<DateTime>
}

impl Order {
    fn from_cart(cart: Cart, email: String) -> Result<Self, OrderError> {
        if cart.is_empty() {
            return Err(OrderError.EmptyCart)
        }
        
        let shipping = cart.shipping_address.ok_or(OrderError.MissingShippingAddress)?
        let billing = cart.billing_address.unwrap_or(shipping.clone())
        
        let now = DateTime.now()
        let items: [OrderItem] = cart.items.iter().map(|i| OrderItem.from_cart_item(i)).collect()
        
        Ok(Order {
            id: UUID.v4().to_string(),
            order_number: generate_order_number(),
            user_id: cart.user_id,
            email: email,
            status: OrderStatus.Pending,
            payment_status: PaymentStatus.Pending,
            fulfillment_status: FulfillmentStatus.Unfulfilled,
            items: items,
            currency: cart.currency,
            subtotal: cart.subtotal(),
            discount_total: cart.discount_total(),
            tax_total: cart.tax_total(),
            shipping_total: cart.shipping_cost(),
            total: cart.total(),
            shipping_address: shipping,
            billing_address: billing,
            shipping_method: cart.shipping_method,
            payments: [],
            fulfillments: [],
            notes: None,
            customer_notes: cart.notes,
            ip_address: None,
            user_agent: None,
            metadata: cart.metadata,
            created_at: now,
            updated_at: now,
            completed_at: None,
            cancelled_at: None
        })
    }
    
    fn confirm() -> Result<Self, OrderError> {
        if self.status != OrderStatus.Pending {
            return Err(OrderError.InvalidStatusTransition)
        }
        self.status = OrderStatus.Confirmed
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn process() -> Result<Self, OrderError> {
        if self.status != OrderStatus.Confirmed {
            return Err(OrderError.InvalidStatusTransition)
        }
        self.status = OrderStatus.Processing
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn ship(tracking: String, carrier: String) -> Result<Self, OrderError> {
        if self.status != OrderStatus.Processing {
            return Err(OrderError.InvalidStatusTransition)
        }
        self.status = OrderStatus.Shipped
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn deliver() -> Result<Self, OrderError> {
        if self.status != OrderStatus.Shipped {
            return Err(OrderError.InvalidStatusTransition)
        }
        self.status = OrderStatus.Delivered
        self.fulfillment_status = FulfillmentStatus.Fulfilled
        self.completed_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn cancel(reason: Option<String>) -> Result<Self, OrderError> {
        if !self.status.is_cancellable() {
            return Err(OrderError.CannotCancel)
        }
        self.status = OrderStatus.Cancelled
        self.cancelled_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        Ok(self)
    }
    
    fn add_payment(payment: Payment) -> Self {
        self.payments.push(payment)
        self.update_payment_status()
        self.updated_at = DateTime.now()
        self
    }
    
    fn update_payment_status() {
        let paid: Money = self.payments.iter()
            .filter(|p| p.status == PaymentStatus.Paid)
            .map(|p| p.amount)
            .fold(Money.zero(self.currency), |a, b| a + b)
        
        if paid >= self.total {
            self.payment_status = PaymentStatus.Paid
        } else if paid > Money.zero(self.currency) {
            self.payment_status = PaymentStatus.PartiallyPaid
        }
    }
    
    fn is_paid() -> Bool {
        self.payment_status == PaymentStatus.Paid
    }
    
    fn amount_due() -> Money {
        let paid: Money = self.payments.iter()
            .filter(|p| p.status == PaymentStatus.Paid)
            .map(|p| p.amount)
            .fold(Money.zero(self.currency), |a, b| a + b)
        
        if self.total > paid {
            self.total - paid
        } else {
            Money.zero(self.currency)
        }
    }
}

// =============================================================================
// Payment
// =============================================================================

struct Payment {
    id: String
    order_id: String
    amount: Money
    method: PaymentMethod
    status: PaymentStatus
    transaction_id: Option<String>
    gateway: String
    metadata: Map<String, String>
    created_at: DateTime
}

impl Payment {
    fn new(order_id: String, amount: Money, method: PaymentMethod, gateway: String) -> Self {
        Payment {
            id: UUID.v4().to_string(),
            order_id: order_id,
            amount: amount,
            method: method,
            status: PaymentStatus.Pending,
            transaction_id: None,
            gateway: gateway,
            metadata: Map.empty(),
            created_at: DateTime.now()
        }
    }
    
    fn mark_paid(transaction_id: String) -> Self {
        self.status = PaymentStatus.Paid
        self.transaction_id = Some(transaction_id)
        self
    }
    
    fn mark_failed() -> Self {
        self.status = PaymentStatus.Failed
        self
    }
}

enum PaymentMethod {
    CreditCard
    DebitCard
    PayPal
    BankTransfer
    Cash
    Crypto
    GiftCard
}

// =============================================================================
// Fulfillment
// =============================================================================

struct Fulfillment {
    id: String
    order_id: String
    items: [FulfillmentItem]
    tracking_number: Option<String>
    carrier: Option<String>
    status: FulfillmentStatus
    shipped_at: Option<DateTime>
    delivered_at: Option<DateTime>
    created_at: DateTime
}

impl Fulfillment {
    fn new(order_id: String) -> Self {
        Fulfillment {
            id: UUID.v4().to_string(),
            order_id: order_id,
            items: [],
            tracking_number: None,
            carrier: None,
            status: FulfillmentStatus.Unfulfilled,
            shipped_at: None,
            delivered_at: None,
            created_at: DateTime.now()
        }
    }
    
    fn add_item(item_id: String, quantity: Int) -> Self {
        self.items.push(FulfillmentItem { item_id: item_id, quantity: quantity })
        self
    }
    
    fn ship(tracking: String, carrier: String) -> Self {
        self.tracking_number = Some(tracking)
        self.carrier = Some(carrier)
        self.status = FulfillmentStatus.Fulfilled
        self.shipped_at = Some(DateTime.now())
        self
    }
}

struct FulfillmentItem {
    item_id: String
    quantity: Int
}

// =============================================================================
// Order Service
// =============================================================================

actor OrderService {
    state orders: Map<String, Order>
    state by_number: Map<String, String>
    state by_user: Map<String, [String]>
    state counter: Int64
    
    fn new() -> Self {
        OrderService {
            orders: Map.empty(),
            by_number: Map.empty(),
            by_user: Map.empty(),
            counter: 1000
        }
    }
    
    fn create(cart: Cart, email: String) -> Result<Order, OrderError> {
        let order = Order.from_cart(cart, email)?
        
        self.orders.insert(order.id.clone(), order.clone())
        self.by_number.insert(order.order_number.clone(), order.id.clone())
        
        if let Some(user_id) = order.user_id.clone() {
            let ids = self.by_user.get(user_id.clone()).unwrap_or([])
            ids.push(order.id.clone())
            self.by_user.insert(user_id, ids)
        }
        
        Ok(order)
    }
    
    fn get(id: String) -> Option<Order> {
        self.orders.get(id)
    }
    
    fn get_by_number(number: String) -> Option<Order> {
        self.by_number.get(number).and_then(|id| self.orders.get(id))
    }
    
    fn get_by_user(user_id: String) -> [Order] {
        self.by_user.get(user_id)
            .unwrap_or([])
            .iter()
            .filter_map(|id| self.orders.get(id))
            .collect()
    }
    
    fn update(order: Order) -> Result<Order, OrderError> {
        if !self.orders.contains_key(order.id) {
            return Err(OrderError.NotFound)
        }
        self.orders.insert(order.id.clone(), order.clone())
        Ok(order)
    }
}

// =============================================================================
// Errors & Helpers
// =============================================================================

enum OrderError {
    NotFound
    EmptyCart
    MissingShippingAddress
    InvalidStatusTransition
    CannotCancel
    PaymentFailed
}

impl Display for OrderError {
    fn fmt(f: Formatter) {
        f.write(match self {
            NotFound => "Order not found"
            EmptyCart => "Cannot create order from empty cart"
            MissingShippingAddress => "Shipping address required"
            InvalidStatusTransition => "Invalid status transition"
            CannotCancel => "Order cannot be cancelled"
            PaymentFailed => "Payment failed"
        })
    }
}

fn generate_order_number() -> String {
    let timestamp = DateTime.now().timestamp()
    let random = @native("random_int", 1000, 9999)
    "ORD-\(timestamp)-\(random)"
}

// =============================================================================
// Tests
// =============================================================================

test "order status transitions" {
    var order = Order {
        id: "test",
        order_number: "ORD-001",
        user_id: None,
        email: "test@example.com",
        status: OrderStatus.Pending,
        payment_status: PaymentStatus.Pending,
        fulfillment_status: FulfillmentStatus.Unfulfilled,
        items: [],
        currency: Currency.USD,
        subtotal: usd(100.00),
        discount_total: Money.zero(Currency.USD),
        tax_total: usd(8.00),
        shipping_total: usd(10.00),
        total: usd(118.00),
        shipping_address: Address.new("John", "Doe", "123 Main St", "City", "ST", "12345", "US"),
        billing_address: Address.new("John", "Doe", "123 Main St", "City", "ST", "12345", "US"),
        shipping_method: None,
        payments: [],
        fulfillments: [],
        notes: None,
        customer_notes: None,
        ip_address: None,
        user_agent: None,
        metadata: Map.empty(),
        created_at: DateTime.now(),
        updated_at: DateTime.now(),
        completed_at: None,
        cancelled_at: None
    }
    
    order = order.confirm().unwrap()
    assert_eq(order.status, OrderStatus.Confirmed)?
    
    order = order.process().unwrap()
    assert_eq(order.status, OrderStatus.Processing)?
}

test "payment tracking" {
    var order = Order {
        id: "test",
        order_number: "ORD-001",
        user_id: None,
        email: "test@example.com",
        status: OrderStatus.Confirmed,
        payment_status: PaymentStatus.Pending,
        fulfillment_status: FulfillmentStatus.Unfulfilled,
        items: [],
        currency: Currency.USD,
        subtotal: usd(100.00),
        discount_total: Money.zero(Currency.USD),
        tax_total: Money.zero(Currency.USD),
        shipping_total: Money.zero(Currency.USD),
        total: usd(100.00),
        shipping_address: Address.new("John", "Doe", "123 Main St", "City", "ST", "12345", "US"),
        billing_address: Address.new("John", "Doe", "123 Main St", "City", "ST", "12345", "US"),
        shipping_method: None,
        payments: [],
        fulfillments: [],
        notes: None,
        customer_notes: None,
        ip_address: None,
        user_agent: None,
        metadata: Map.empty(),
        created_at: DateTime.now(),
        updated_at: DateTime.now(),
        completed_at: None,
        cancelled_at: None
    }
    
    let payment = Payment.new(order.id.clone(), usd(100.00), PaymentMethod.CreditCard, "stripe")
        .mark_paid("txn_123")
    
    order = order.add_payment(payment)
    
    assert(order.is_paid())?
    assert(order.amount_due().is_zero())?
}
