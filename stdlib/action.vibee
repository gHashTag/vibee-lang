// =============================================================================
// Vibee OS â€” Action Module
// Redux-like actions for state management
// =============================================================================

// =============================================================================
// Core Action Types
// =============================================================================

/// Action trait - base for all actions
trait Action {
    fn action_type() -> String
}

/// Typed action with payload
trait TypedAction<P>: Action {
    fn payload() -> P
}

/// Action metadata
struct ActionMeta {
    timestamp: Int64
    source: Option<String>
    correlation_id: Option<String>
    causation_id: Option<String>
}

impl ActionMeta {
    fn new() -> Self {
        ActionMeta {
            timestamp: @native("now_ms"),
            source: None,
            correlation_id: None,
            causation_id: None
        }
    }
    
    fn with_source(source: String) -> Self {
        ActionMeta {
            timestamp: @native("now_ms"),
            source: Some(source),
            correlation_id: None,
            causation_id: None
        }
    }
    
    fn with_correlation(correlation_id: String) -> Self {
        ActionMeta {
            timestamp: @native("now_ms"),
            source: None,
            correlation_id: Some(correlation_id),
            causation_id: None
        }
    }
}

/// Standard action structure
struct StandardAction<P> {
    type_name: String
    payload: P
    meta: ActionMeta
    error: Bool
}

impl<P> Action for StandardAction<P> {
    fn action_type() -> String { self.type_name.clone() }
}

impl<P> TypedAction<P> for StandardAction<P> {
    fn payload() -> P { self.payload.clone() }
}

impl<P> StandardAction<P> {
    fn new(type_name: String, payload: P) -> Self {
        StandardAction {
            type_name: type_name,
            payload: payload,
            meta: ActionMeta.new(),
            error: false
        }
    }
    
    fn with_meta(type_name: String, payload: P, meta: ActionMeta) -> Self {
        StandardAction {
            type_name: type_name,
            payload: payload,
            meta: meta,
            error: false
        }
    }
    
    fn error_action(type_name: String, payload: P) -> Self {
        StandardAction {
            type_name: type_name,
            payload: payload,
            meta: ActionMeta.new(),
            error: true
        }
    }
    
    fn is_error() -> Bool { self.error }
    fn get_meta() -> ActionMeta { self.meta.clone() }
}

// =============================================================================
// Action Creator
// =============================================================================

/// Action creator - factory for creating actions
struct ActionCreator<P> {
    type_name: String
}

impl<P> ActionCreator<P> {
    fn new(type_name: String) -> Self {
        ActionCreator { type_name: type_name }
    }
    
    fn create(payload: P) -> StandardAction<P> {
        StandardAction.new(self.type_name.clone(), payload)
    }
    
    fn create_with_meta(payload: P, meta: ActionMeta) -> StandardAction<P> {
        StandardAction.with_meta(self.type_name.clone(), payload, meta)
    }
    
    fn matches(action: impl Action) -> Bool {
        action.action_type() == self.type_name
    }
    
    fn get_type() -> String {
        self.type_name.clone()
    }
}

/// Create action creator helper
fn create_action<P>(type_name: String) -> ActionCreator<P> {
    ActionCreator.new(type_name)
}

// =============================================================================
// Async Action Types
// =============================================================================

/// Async action states
enum AsyncActionState<P, R, E> {
    Pending(P)
    Fulfilled(R)
    Rejected(E)
}

/// Async action creator - creates pending/fulfilled/rejected actions
struct AsyncActionCreator<P, R, E> {
    base_type: String
    pending_creator: ActionCreator<P>
    fulfilled_creator: ActionCreator<R>
    rejected_creator: ActionCreator<E>
}

impl<P, R, E> AsyncActionCreator<P, R, E> {
    fn new(base_type: String) -> Self {
        AsyncActionCreator {
            base_type: base_type.clone(),
            pending_creator: ActionCreator.new(base_type.clone() + "/pending"),
            fulfilled_creator: ActionCreator.new(base_type.clone() + "/fulfilled"),
            rejected_creator: ActionCreator.new(base_type.clone() + "/rejected")
        }
    }
    
    fn pending(payload: P) -> StandardAction<P> {
        self.pending_creator.create(payload)
    }
    
    fn fulfilled(result: R) -> StandardAction<R> {
        self.fulfilled_creator.create(result)
    }
    
    fn rejected(error: E) -> StandardAction<E> {
        StandardAction.error_action(self.rejected_creator.get_type(), error)
    }
    
    fn is_pending(action: impl Action) -> Bool {
        self.pending_creator.matches(action)
    }
    
    fn is_fulfilled(action: impl Action) -> Bool {
        self.fulfilled_creator.matches(action)
    }
    
    fn is_rejected(action: impl Action) -> Bool {
        self.rejected_creator.matches(action)
    }
    
    fn get_base_type() -> String {
        self.base_type.clone()
    }
}

/// Create async action creator helper
fn create_async_action<P, R, E>(base_type: String) -> AsyncActionCreator<P, R, E> {
    AsyncActionCreator.new(base_type)
}

// =============================================================================
// Action Batch
// =============================================================================

/// Batch multiple actions together
struct ActionBatch {
    actions: [impl Action]
    meta: ActionMeta
}

impl ActionBatch {
    fn new() -> Self {
        ActionBatch {
            actions: [],
            meta: ActionMeta.new()
        }
    }
    
    fn add(action: impl Action) -> Self {
        self.actions.push(action)
        self
    }
    
    fn with_actions(actions: [impl Action]) -> Self {
        ActionBatch {
            actions: actions,
            meta: ActionMeta.new()
        }
    }
    
    fn iter() -> impl Iterator<Item = impl Action> {
        self.actions.iter()
    }
    
    fn len() -> Int {
        self.actions.len()
    }
    
    fn is_empty() -> Bool {
        self.actions.is_empty()
    }
}

impl Action for ActionBatch {
    fn action_type() -> String { "@@BATCH" }
}

// =============================================================================
// Action Matchers
// =============================================================================

/// Action matcher for pattern matching
struct ActionMatcher {
    patterns: [String]
}

impl ActionMatcher {
    fn new() -> Self {
        ActionMatcher { patterns: [] }
    }
    
    fn add_type(type_name: String) -> Self {
        self.patterns.push(type_name)
        self
    }
    
    fn add_prefix(prefix: String) -> Self {
        self.patterns.push(prefix + "*")
        self
    }
    
    fn matches(action: impl Action) -> Bool {
        let action_type = action.action_type()
        for pattern in self.patterns.iter() {
            if pattern.ends_with("*") {
                let prefix = pattern.trim_end_matches("*")
                if action_type.starts_with(prefix) {
                    return true
                }
            } else if action_type == pattern {
                return true
            }
        }
        false
    }
}

/// Match any action
fn match_any() -> ActionMatcher {
    ActionMatcher.new().add_prefix("")
}

/// Match specific types
fn match_types(types: [String]) -> ActionMatcher {
    var matcher = ActionMatcher.new()
    for t in types {
        matcher = matcher.add_type(t)
    }
    matcher
}

/// Match by prefix
fn match_prefix(prefix: String) -> ActionMatcher {
    ActionMatcher.new().add_prefix(prefix)
}

// =============================================================================
// Predefined Actions
// =============================================================================

/// Init action - dispatched when store is created
struct InitAction {}

impl Action for InitAction {
    fn action_type() -> String { "@@INIT" }
}

/// Unknown action - for testing reducers
struct UnknownAction {}

impl Action for UnknownAction {
    fn action_type() -> String { "@@UNKNOWN" }
}

/// Replace state action
struct ReplaceStateAction<S> {
    new_state: S
}

impl<S> Action for ReplaceStateAction<S> {
    fn action_type() -> String { "@@REPLACE_STATE" }
}

impl<S> ReplaceStateAction<S> {
    fn new(state: S) -> Self {
        ReplaceStateAction { new_state: state }
    }
    
    fn get_state() -> S {
        self.new_state.clone()
    }
}

// =============================================================================
// Action Helpers
// =============================================================================

/// Create simple action without payload
fn simple_action(type_name: String) -> StandardAction<()> {
    StandardAction.new(type_name, ())
}

/// Create action with payload
fn action_with_payload<P>(type_name: String, payload: P) -> StandardAction<P> {
    StandardAction.new(type_name, payload)
}

/// Check if action is of specific type
fn is_type(action: impl Action, type_name: String) -> Bool {
    action.action_type() == type_name
}

/// Check if action is any of types
fn is_any_type(action: impl Action, types: [String]) -> Bool {
    types.contains(action.action_type())
}

/// Extract payload from action (unsafe - assumes correct type)
fn extract_payload<P>(action: StandardAction<P>) -> P {
    action.payload()
}

// =============================================================================
// Action Serialization
// =============================================================================

/// Serializable action for persistence/transport
struct SerializableAction {
    type_name: String
    payload_json: String
    meta: ActionMeta
    error: Bool
}

impl SerializableAction {
    fn from_action<P: Serialize>(action: StandardAction<P>) -> Self {
        SerializableAction {
            type_name: action.action_type(),
            payload_json: action.payload.to_json(),
            meta: action.meta,
            error: action.error
        }
    }
    
    fn to_action<P: Deserialize>() -> Result<StandardAction<P>, Error> {
        let payload = P.from_json(self.payload_json)?
        Ok(StandardAction {
            type_name: self.type_name.clone(),
            payload: payload,
            meta: self.meta.clone(),
            error: self.error
        })
    }
    
    fn to_json() -> String {
        @native("json_stringify", self)
    }
    
    fn from_json(json: String) -> Result<Self, Error> {
        @native("json_parse", json)
    }
}

impl Action for SerializableAction {
    fn action_type() -> String { self.type_name.clone() }
}

// =============================================================================
// Action History
// =============================================================================

/// Action history for undo/redo
actor ActionHistory {
    state past: [impl Action]
    state future: [impl Action]
    state max_size: Int
    
    fn new(max_size: Int) -> Self {
        ActionHistory {
            past: [],
            future: [],
            max_size: max_size
        }
    }
    
    fn push(action: impl Action) {
        self.past.push(action)
        self.future.clear()
        
        // Trim if exceeds max size
        while self.past.len() > self.max_size {
            self.past.remove(0)
        }
    }
    
    fn undo() -> Option<impl Action> {
        if self.past.is_empty() {
            return None
        }
        let action = self.past.pop()
        if let Some(a) = action {
            self.future.push(a.clone())
            Some(a)
        } else {
            None
        }
    }
    
    fn redo() -> Option<impl Action> {
        if self.future.is_empty() {
            return None
        }
        let action = self.future.pop()
        if let Some(a) = action {
            self.past.push(a.clone())
            Some(a)
        } else {
            None
        }
    }
    
    fn can_undo() -> Bool {
        !self.past.is_empty()
    }
    
    fn can_redo() -> Bool {
        !self.future.is_empty()
    }
    
    fn clear() {
        self.past.clear()
        self.future.clear()
    }
    
    fn get_past() -> [impl Action] {
        self.past.clone()
    }
    
    fn get_future() -> [impl Action] {
        self.future.clone()
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create action" {
    let action = StandardAction.new("INCREMENT", 1)
    assert_eq(action.action_type(), "INCREMENT")?
    assert_eq(action.payload(), 1)?
}

test "action creator" {
    let increment = create_action::<Int>("INCREMENT")
    let action = increment.create(5)
    
    assert_eq(action.action_type(), "INCREMENT")?
    assert_eq(action.payload(), 5)?
    assert(increment.matches(action))?
}

test "async action creator" {
    let fetch_user = create_async_action::<Int, String, String>("FETCH_USER")
    
    let pending = fetch_user.pending(42)
    let fulfilled = fetch_user.fulfilled("John")
    let rejected = fetch_user.rejected("Not found")
    
    assert_eq(pending.action_type(), "FETCH_USER/pending")?
    assert_eq(fulfilled.action_type(), "FETCH_USER/fulfilled")?
    assert_eq(rejected.action_type(), "FETCH_USER/rejected")?
    
    assert(fetch_user.is_pending(pending))?
    assert(fetch_user.is_fulfilled(fulfilled))?
    assert(fetch_user.is_rejected(rejected))?
}

test "action batch" {
    let batch = ActionBatch.new()
        .add(simple_action("ACTION_1"))
        .add(simple_action("ACTION_2"))
        .add(simple_action("ACTION_3"))
    
    assert_eq(batch.len(), 3)?
    assert_eq(batch.action_type(), "@@BATCH")?
}

test "action matcher" {
    let matcher = ActionMatcher.new()
        .add_type("INCREMENT")
        .add_type("DECREMENT")
        .add_prefix("USER/")
    
    assert(matcher.matches(simple_action("INCREMENT")))?
    assert(matcher.matches(simple_action("USER/FETCH")))?
    assert(!matcher.matches(simple_action("RESET")))?
}

test "action history" {
    let history = ActionHistory.new(10)
    
    history.push(simple_action("ACTION_1"))
    history.push(simple_action("ACTION_2"))
    
    assert(history.can_undo())?
    assert(!history.can_redo())?
    
    let undone = history.undo()
    assert(undone.is_some())?
    assert(history.can_redo())?
}

test "init action" {
    let init = InitAction {}
    assert_eq(init.action_type(), "@@INIT")?
}

test "error action" {
    let error_action = StandardAction::<String>.error_action("FETCH_ERROR", "Network error")
    assert(error_action.is_error())?
}
