// =============================================================================
// Vibee OS â€” Barcode Module
// Barcode and QR code detection, decoding, and generation
// =============================================================================

use image::{Image, Pixel}

// -----------------------------------------------------------------------------
// Barcode Types
// -----------------------------------------------------------------------------

/// Barcode format enumeration
enum BarcodeFormat {
    // 1D Barcodes
    Code39,
    Code93,
    Code128,
    EAN8,
    EAN13,
    UPC_A,
    UPC_E,
    ITF,
    Codabar,
    MSI,
    Plessey,
    Pharmacode,
    
    // 2D Barcodes
    QRCode,
    DataMatrix,
    PDF417,
    Aztec,
    MaxiCode,
    MicroQR,
    
    // Postal
    USPS_IMB,
    RoyalMail,
    AustraliaPost,
    
    fn name() -> String {
        match self {
            Code39 => "Code 39", Code93 => "Code 93", Code128 => "Code 128",
            EAN8 => "EAN-8", EAN13 => "EAN-13", UPC_A => "UPC-A", UPC_E => "UPC-E",
            ITF => "ITF", Codabar => "Codabar", MSI => "MSI", Plessey => "Plessey",
            Pharmacode => "Pharmacode", QRCode => "QR Code", DataMatrix => "Data Matrix",
            PDF417 => "PDF417", Aztec => "Aztec", MaxiCode => "MaxiCode",
            MicroQR => "Micro QR", USPS_IMB => "USPS IMB", RoyalMail => "Royal Mail",
            AustraliaPost => "Australia Post"
        }
    }
    
    fn is_1d() -> Bool {
        match self {
            Code39 | Code93 | Code128 | EAN8 | EAN13 | UPC_A | UPC_E |
            ITF | Codabar | MSI | Plessey | Pharmacode => true,
            _ => false
        }
    }
    
    fn is_2d() -> Bool {
        match self {
            QRCode | DataMatrix | PDF417 | Aztec | MaxiCode | MicroQR => true,
            _ => false
        }
    }
    
    fn max_data_length() -> Int {
        match self {
            Code39 => 43, Code128 => 2048, EAN8 => 8, EAN13 => 13,
            UPC_A => 12, UPC_E => 8, QRCode => 4296, DataMatrix => 2335,
            PDF417 => 1850, Aztec => 3832, _ => 256
        }
    }
}

/// Barcode orientation
enum BarcodeOrientation {
    Horizontal,
    Vertical,
    Diagonal(Float),
    Unknown
}

// -----------------------------------------------------------------------------
// Barcode Detection Result
// -----------------------------------------------------------------------------

/// Bounding box for barcode
struct BarcodeBox {
    x: Int
    y: Int
    width: Int
    height: Int
    corners: [(Int, Int)]
    
    fn new(x: Int, y: Int, width: Int, height: Int) -> Self {
        BarcodeBox {
            x: x, y: y, width: width, height: height,
            corners: [(x, y), (x + width, y), (x + width, y + height), (x, y + height)]
        }
    }
    
    fn from_corners(corners: [(Int, Int)]) -> Self {
        let xs: [Int] = corners.iter().map(|c| c.0).collect()
        let ys: [Int] = corners.iter().map(|c| c.1).collect()
        let min_x = *xs.iter().min().unwrap_or(&0)
        let min_y = *ys.iter().min().unwrap_or(&0)
        let max_x = *xs.iter().max().unwrap_or(&0)
        let max_y = *ys.iter().max().unwrap_or(&0)
        BarcodeBox {
            x: min_x, y: min_y, width: max_x - min_x, height: max_y - min_y,
            corners: corners
        }
    }
    
    fn center() -> (Int, Int) {
        (self.x + self.width / 2, self.y + self.height / 2)
    }
    
    fn area() -> Int { self.width * self.height }
}

/// Decoded barcode result
struct Barcode {
    data: String
    raw_bytes: [Byte]
    format: BarcodeFormat
    bbox: BarcodeBox
    confidence: Float
    orientation: BarcodeOrientation
    
    fn new(data: String, format: BarcodeFormat, bbox: BarcodeBox) -> Self {
        Barcode {
            data: data, raw_bytes: [], format: format, bbox: bbox,
            confidence: 1.0, orientation: BarcodeOrientation.Unknown
        }
    }
    
    fn with_confidence(data: String, format: BarcodeFormat, bbox: BarcodeBox, confidence: Float) -> Self {
        var bc = Barcode.new(data, format, bbox)
        bc.confidence = confidence
        bc
    }
    
    fn is_qr() -> Bool { self.format == BarcodeFormat.QRCode }
    fn is_1d() -> Bool { self.format.is_1d() }
    fn is_2d() -> Bool { self.format.is_2d() }
    
    fn data_length() -> Int { self.data.len() }
    
    fn is_url() -> Bool {
        self.data.starts_with("http://") || self.data.starts_with("https://")
    }
    
    fn is_email() -> Bool {
        self.data.starts_with("mailto:") || self.data.contains("@")
    }
    
    fn is_phone() -> Bool {
        self.data.starts_with("tel:") || self.data.starts_with("+")
    }
    
    fn is_wifi() -> Bool {
        self.data.starts_with("WIFI:")
    }
    
    fn is_vcard() -> Bool {
        self.data.starts_with("BEGIN:VCARD")
    }
    
    fn crop(image: Image) -> Image {
        image.crop(self.bbox.x, self.bbox.y, self.bbox.width, self.bbox.height)
    }
}

/// Multiple barcode results
struct BarcodeResults {
    items: [Barcode]
    
    fn new(items: [Barcode]) -> Self {
        BarcodeResults { items: items }
    }
    
    fn empty() -> Self {
        BarcodeResults { items: [] }
    }
    
    fn len() -> Int { self.items.len() }
    fn is_empty() -> Bool { self.items.is_empty() }
    
    fn first() -> Option<Barcode> {
        if self.items.is_empty() { None } else { Some(self.items[0].clone()) }
    }
    
    fn filter_by_format(format: BarcodeFormat) -> Self {
        let filtered = self.items.iter()
            .filter(|b| b.format == format)
            .cloned()
            .collect()
        BarcodeResults.new(filtered)
    }
    
    fn filter_qr() -> Self {
        self.filter_by_format(BarcodeFormat.QRCode)
    }
    
    fn filter_1d() -> Self {
        let filtered = self.items.iter()
            .filter(|b| b.is_1d())
            .cloned()
            .collect()
        BarcodeResults.new(filtered)
    }
    
    fn filter_2d() -> Self {
        let filtered = self.items.iter()
            .filter(|b| b.is_2d())
            .cloned()
            .collect()
        BarcodeResults.new(filtered)
    }
    
    fn get_data() -> [String] {
        self.items.iter().map(|b| b.data.clone()).collect()
    }
}

// -----------------------------------------------------------------------------
// Barcode Reader
// -----------------------------------------------------------------------------

/// Barcode reader configuration
struct BarcodeReaderConfig {
    formats: [BarcodeFormat]
    try_harder: Bool
    try_rotate: Bool
    pure_barcode: Bool
    max_results: Int
    
    fn new() -> Self {
        BarcodeReaderConfig {
            formats: [],  // Empty = all formats
            try_harder: true,
            try_rotate: true,
            pure_barcode: false,
            max_results: 100
        }
    }
    
    fn with_formats(formats: [BarcodeFormat]) -> Self { self.formats = formats; self }
    fn with_try_harder(try_harder: Bool) -> Self { self.try_harder = try_harder; self }
    fn with_try_rotate(try_rotate: Bool) -> Self { self.try_rotate = try_rotate; self }
    fn with_max_results(max: Int) -> Self { self.max_results = max; self }
    
    fn qr_only() -> Self {
        var config = BarcodeReaderConfig.new()
        config.formats = [BarcodeFormat.QRCode]
        config
    }
    
    fn ean_only() -> Self {
        var config = BarcodeReaderConfig.new()
        config.formats = [BarcodeFormat.EAN8, BarcodeFormat.EAN13]
        config
    }
}

/// Barcode reader
struct BarcodeReader {
    config: BarcodeReaderConfig
    
    fn new() -> Self {
        BarcodeReader { config: BarcodeReaderConfig.new() }
    }
    
    fn with_config(config: BarcodeReaderConfig) -> Self {
        BarcodeReader { config: config }
    }
    
    fn qr_reader() -> Self {
        BarcodeReader { config: BarcodeReaderConfig.qr_only() }
    }
    
    fn read(image: Image) -> Result<BarcodeResults, BarcodeError> {
        @native("barcode_read", image, self.config)
    }
    
    fn read_one(image: Image) -> Result<Option<Barcode>, BarcodeError> {
        let results = self.read(image)?
        Ok(results.first())
    }
    
    fn read_qr(image: Image) -> Result<Option<Barcode>, BarcodeError> {
        var config = self.config.clone()
        config.formats = [BarcodeFormat.QRCode]
        let results = @native("barcode_read", image, config)?
        Ok(results.first())
    }
    
    fn read_batch(images: [Image]) -> Result<[BarcodeResults], BarcodeError> {
        images.iter().map(|img| self.read(img.clone())).collect()
    }
    
    fn decode_raw(data: [Byte], format: BarcodeFormat) -> Result<String, BarcodeError> {
        @native("barcode_decode_raw", data, format)
    }
}

// -----------------------------------------------------------------------------
// QR Code Specific
// -----------------------------------------------------------------------------

/// QR code error correction level
enum QRErrorCorrection {
    Low,      // ~7% recovery
    Medium,   // ~15% recovery
    Quartile, // ~25% recovery
    High      // ~30% recovery
    
    fn recovery_percent() -> Int {
        match self {
            Low => 7, Medium => 15, Quartile => 25, High => 30
        }
    }
}

/// QR code version (1-40)
struct QRVersion {
    version: Int
    
    fn new(version: Int) -> Self {
        QRVersion { version: version.clamp(1, 40) }
    }
    
    fn auto() -> Self { QRVersion { version: 0 } }
    
    fn modules() -> Int {
        if self.version == 0 { 0 }
        else { 17 + self.version * 4 }
    }
    
    fn max_data(ec: QRErrorCorrection) -> Int {
        // Simplified - actual values depend on mode
        match (self.version, ec) {
            (1, Low) => 25, (1, Medium) => 20, (1, Quartile) => 16, (1, High) => 10,
            (10, Low) => 652, (10, Medium) => 513, (10, Quartile) => 364, (10, High) => 288,
            (40, Low) => 4296, (40, Medium) => 3391, (40, Quartile) => 2420, (40, High) => 1852,
            _ => 256
        }
    }
}

/// QR code data type
enum QRDataType {
    Text,
    URL,
    Email,
    Phone,
    SMS,
    WiFi,
    VCard,
    VEvent,
    GeoLocation,
    Bitcoin,
    Custom(String)
}

/// WiFi QR code data
struct WiFiData {
    ssid: String
    password: String
    security: WiFiSecurity
    hidden: Bool
    
    fn new(ssid: String, password: String, security: WiFiSecurity) -> Self {
        WiFiData { ssid: ssid, password: password, security: security, hidden: false }
    }
    
    fn to_qr_string() -> String {
        let sec = match self.security {
            WiFiSecurity.WPA => "WPA",
            WiFiSecurity.WEP => "WEP",
            WiFiSecurity.None => "nopass"
        }
        format!("WIFI:T:{};S:{};P:{};H:{};", sec, self.ssid, self.password, self.hidden)
    }
    
    fn parse(data: String) -> Option<Self> {
        if !data.starts_with("WIFI:") { return None }
        // Parse WIFI:T:WPA;S:ssid;P:password;H:false;
        @native("parse_wifi_qr", data)
    }
}

/// WiFi security type
enum WiFiSecurity { WPA, WEP, None }

/// VCard QR code data
struct VCardData {
    name: String
    phone: Option<String>
    email: Option<String>
    organization: Option<String>
    title: Option<String>
    address: Option<String>
    url: Option<String>
    
    fn new(name: String) -> Self {
        VCardData {
            name: name, phone: None, email: None, organization: None,
            title: None, address: None, url: None
        }
    }
    
    fn to_qr_string() -> String {
        var vcard = "BEGIN:VCARD\nVERSION:3.0\n"
        vcard += &format!("N:{}\n", self.name)
        if let Some(phone) = &self.phone { vcard += &format!("TEL:{}\n", phone) }
        if let Some(email) = &self.email { vcard += &format!("EMAIL:{}\n", email) }
        if let Some(org) = &self.organization { vcard += &format!("ORG:{}\n", org) }
        if let Some(title) = &self.title { vcard += &format!("TITLE:{}\n", title) }
        if let Some(url) = &self.url { vcard += &format!("URL:{}\n", url) }
        vcard += "END:VCARD"
        vcard
    }
}

// -----------------------------------------------------------------------------
// Barcode Generator
// -----------------------------------------------------------------------------

/// Barcode generator configuration
struct BarcodeGeneratorConfig {
    format: BarcodeFormat
    width: Int
    height: Int
    margin: Int
    foreground: (Int, Int, Int)
    background: (Int, Int, Int)
    error_correction: QRErrorCorrection
    
    fn new(format: BarcodeFormat) -> Self {
        BarcodeGeneratorConfig {
            format: format,
            width: 200,
            height: 200,
            margin: 10,
            foreground: (0, 0, 0),
            background: (255, 255, 255),
            error_correction: QRErrorCorrection.Medium
        }
    }
    
    fn with_size(width: Int, height: Int) -> Self { self.width = width; self.height = height; self }
    fn with_margin(margin: Int) -> Self { self.margin = margin; self }
    fn with_colors(fg: (Int, Int, Int), bg: (Int, Int, Int)) -> Self {
        self.foreground = fg; self.background = bg; self
    }
    fn with_error_correction(ec: QRErrorCorrection) -> Self { self.error_correction = ec; self }
}

/// Barcode generator
struct BarcodeGenerator {
    config: BarcodeGeneratorConfig
    
    fn new(format: BarcodeFormat) -> Self {
        BarcodeGenerator { config: BarcodeGeneratorConfig.new(format) }
    }
    
    fn with_config(config: BarcodeGeneratorConfig) -> Self {
        BarcodeGenerator { config: config }
    }
    
    fn qr() -> Self {
        BarcodeGenerator.new(BarcodeFormat.QRCode)
    }
    
    fn ean13() -> Self {
        BarcodeGenerator.new(BarcodeFormat.EAN13)
    }
    
    fn code128() -> Self {
        BarcodeGenerator.new(BarcodeFormat.Code128)
    }
    
    fn generate(data: String) -> Result<Image, BarcodeError> {
        if data.len() > self.config.format.max_data_length() {
            return Err(BarcodeError.DataTooLong)
        }
        @native("barcode_generate", data, self.config)
    }
    
    fn generate_qr(data: String) -> Result<Image, BarcodeError> {
        var gen = BarcodeGenerator.qr()
        gen.generate(data)
    }
    
    fn generate_wifi(wifi: WiFiData) -> Result<Image, BarcodeError> {
        var gen = BarcodeGenerator.qr()
        gen.generate(wifi.to_qr_string())
    }
    
    fn generate_vcard(vcard: VCardData) -> Result<Image, BarcodeError> {
        var gen = BarcodeGenerator.qr()
        gen.generate(vcard.to_qr_string())
    }
    
    fn generate_url(url: String) -> Result<Image, BarcodeError> {
        var gen = BarcodeGenerator.qr()
        gen.generate(url)
    }
    
    fn generate_to_file(data: String, path: String) -> Result<(), BarcodeError> {
        let image = self.generate(data)?
        image.save(path).map_err(|e| BarcodeError.IoError(e.to_string()))
    }
}

// -----------------------------------------------------------------------------
// Barcode Scanner (Real-time)
// -----------------------------------------------------------------------------

/// Real-time barcode scanner
actor BarcodeScanner {
    state reader: BarcodeReader
    state running: Bool
    state last_result: Option<Barcode>
    state callback: Option<fn(Barcode)>
    
    fn new() -> Self {
        BarcodeScanner {
            reader: BarcodeReader.new(),
            running: false,
            last_result: None,
            callback: None
        }
    }
    
    fn with_config(config: BarcodeReaderConfig) -> Self {
        BarcodeScanner {
            reader: BarcodeReader.with_config(config),
            running: false,
            last_result: None,
            callback: None
        }
    }
    
    fn on_scan(callback: fn(Barcode)) {
        self.callback = Some(callback)
    }
    
    fn start() {
        self.running = true
        @native("barcode_scanner_start", self)
    }
    
    fn stop() {
        self.running = false
        @native("barcode_scanner_stop")
    }
    
    fn is_running() -> Bool { self.running }
    
    fn process_frame(image: Image) -> Option<Barcode> {
        if !self.running { return None }
        
        if let Ok(results) = self.reader.read(image) {
            if let Some(barcode) = results.first() {
                self.last_result = Some(barcode.clone())
                if let Some(cb) = &self.callback {
                    cb(barcode.clone())
                }
                return Some(barcode)
            }
        }
        None
    }
    
    fn get_last_result() -> Option<Barcode> {
        self.last_result.clone()
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

/// Barcode errors
enum BarcodeError {
    NotFound,
    InvalidFormat,
    DataTooLong,
    InvalidData(String),
    DecodingError(String),
    EncodingError(String),
    IoError(String)
}

impl Display for BarcodeError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("No barcode found in image"),
            InvalidFormat => f.write("Invalid barcode format"),
            DataTooLong => f.write("Data too long for barcode format"),
            InvalidData(msg) => f.write(format!("Invalid data: {}", msg)),
            DecodingError(msg) => f.write(format!("Decoding error: {}", msg)),
            EncodingError(msg) => f.write(format!("Encoding error: {}", msg)),
            IoError(msg) => f.write(format!("IO error: {}", msg))
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Read all barcodes from image
fn read_barcodes(image: Image) -> Result<BarcodeResults, BarcodeError> {
    BarcodeReader.new().read(image)
}

/// Read single barcode from image
fn read_barcode(image: Image) -> Result<Option<Barcode>, BarcodeError> {
    BarcodeReader.new().read_one(image)
}

/// Read QR code from image
fn read_qr(image: Image) -> Result<Option<Barcode>, BarcodeError> {
    BarcodeReader.qr_reader().read_one(image)
}

/// Read QR code data as string
fn read_qr_text(image: Image) -> Result<Option<String>, BarcodeError> {
    Ok(read_qr(image)?.map(|b| b.data))
}

/// Generate QR code image
fn generate_qr(data: String) -> Result<Image, BarcodeError> {
    BarcodeGenerator.qr().generate(data)
}

/// Generate QR code with size
fn generate_qr_sized(data: String, size: Int) -> Result<Image, BarcodeError> {
    var config = BarcodeGeneratorConfig.new(BarcodeFormat.QRCode)
    config.width = size
    config.height = size
    BarcodeGenerator.with_config(config).generate(data)
}

/// Generate WiFi QR code
fn generate_wifi_qr(ssid: String, password: String) -> Result<Image, BarcodeError> {
    let wifi = WiFiData.new(ssid, password, WiFiSecurity.WPA)
    BarcodeGenerator.qr().generate(wifi.to_qr_string())
}

/// Generate URL QR code
fn generate_url_qr(url: String) -> Result<Image, BarcodeError> {
    BarcodeGenerator.qr().generate(url)
}

/// Generate EAN-13 barcode
fn generate_ean13(data: String) -> Result<Image, BarcodeError> {
    BarcodeGenerator.ean13().generate(data)
}

/// Generate Code 128 barcode
fn generate_code128(data: String) -> Result<Image, BarcodeError> {
    BarcodeGenerator.code128().generate(data)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "barcode_format_properties" {
    assert(BarcodeFormat.QRCode.is_2d())?
    assert(BarcodeFormat.EAN13.is_1d())?
    assert(!BarcodeFormat.QRCode.is_1d())?
}

test "barcode_box_center" {
    let box = BarcodeBox.new(100, 100, 50, 50)
    assert_eq(box.center(), (125, 125))?
}

test "wifi_data_to_string" {
    let wifi = WiFiData.new("MyNetwork", "password123", WiFiSecurity.WPA)
    let qr_string = wifi.to_qr_string()
    assert(qr_string.contains("WIFI:"))?
    assert(qr_string.contains("MyNetwork"))?
}

test "vcard_data_to_string" {
    var vcard = VCardData.new("John Doe")
    vcard.email = Some("john@example.com")
    let qr_string = vcard.to_qr_string()
    assert(qr_string.contains("BEGIN:VCARD"))?
    assert(qr_string.contains("John Doe"))?
}

test "barcode_results_filter" {
    let qr = Barcode.new("test", BarcodeFormat.QRCode, BarcodeBox.new(0, 0, 100, 100))
    let ean = Barcode.new("1234567890123", BarcodeFormat.EAN13, BarcodeBox.new(200, 0, 100, 50))
    let results = BarcodeResults.new([qr, ean])
    
    let qr_only = results.filter_qr()
    assert_eq(qr_only.len(), 1)?
    
    let barcodes_1d = results.filter_1d()
    assert_eq(barcodes_1d.len(), 1)?
}

test "qr_error_correction" {
    assert_eq(QRErrorCorrection.Low.recovery_percent(), 7)?
    assert_eq(QRErrorCorrection.High.recovery_percent(), 30)?
}

test "barcode_is_url" {
    let bc = Barcode.new("https://example.com", BarcodeFormat.QRCode, BarcodeBox.new(0, 0, 100, 100))
    assert(bc.is_url())?
    assert(!bc.is_email())?
}
