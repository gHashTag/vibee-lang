// =============================================================================
// Vibee OS — ASCII Module
// ASCII encoding, validation, and character utilities
// =============================================================================

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

/// ASCII character range
const MIN_ASCII: UInt8 = 0x00
const MAX_ASCII: UInt8 = 0x7F

/// Control character range
const CONTROL_MIN: UInt8 = 0x00
const CONTROL_MAX: UInt8 = 0x1F
const DEL: UInt8 = 0x7F

/// Printable character range
const PRINTABLE_MIN: UInt8 = 0x20
const PRINTABLE_MAX: UInt8 = 0x7E

/// Common ASCII characters
const NUL: UInt8 = 0x00
const TAB: UInt8 = 0x09
const LF: UInt8 = 0x0A
const CR: UInt8 = 0x0D
const SPACE: UInt8 = 0x20

// -----------------------------------------------------------------------------
// Character Classification
// -----------------------------------------------------------------------------

/// Check if byte is valid ASCII
fn is_ascii(b: UInt8) -> Bool {
    b <= MAX_ASCII
}

/// Check if character is valid ASCII
fn is_ascii_char(c: Char) -> Bool {
    (c as UInt32) <= 0x7F
}

/// Check if byte is ASCII control character
fn is_control(b: UInt8) -> Bool {
    b <= CONTROL_MAX || b == DEL
}

/// Check if byte is ASCII printable character
fn is_printable(b: UInt8) -> Bool {
    b >= PRINTABLE_MIN && b <= PRINTABLE_MAX
}

/// Check if byte is ASCII whitespace
fn is_whitespace(b: UInt8) -> Bool {
    b == SPACE || b == TAB || b == LF || b == CR || b == 0x0B || b == 0x0C
}

/// Check if byte is ASCII digit (0-9)
fn is_digit(b: UInt8) -> Bool {
    b >= '0' as UInt8 && b <= '9' as UInt8
}

/// Check if byte is ASCII hex digit (0-9, A-F, a-f)
fn is_hex_digit(b: UInt8) -> Bool {
    is_digit(b) || 
    (b >= 'A' as UInt8 && b <= 'F' as UInt8) ||
    (b >= 'a' as UInt8 && b <= 'f' as UInt8)
}

/// Check if byte is ASCII uppercase letter
fn is_uppercase(b: UInt8) -> Bool {
    b >= 'A' as UInt8 && b <= 'Z' as UInt8
}

/// Check if byte is ASCII lowercase letter
fn is_lowercase(b: UInt8) -> Bool {
    b >= 'a' as UInt8 && b <= 'z' as UInt8
}

/// Check if byte is ASCII letter
fn is_alphabetic(b: UInt8) -> Bool {
    is_uppercase(b) || is_lowercase(b)
}

/// Check if byte is ASCII alphanumeric
fn is_alphanumeric(b: UInt8) -> Bool {
    is_alphabetic(b) || is_digit(b)
}

/// Check if byte is ASCII punctuation
fn is_punctuation(b: UInt8) -> Bool {
    is_printable(b) && !is_alphanumeric(b) && b != SPACE
}

/// Check if byte is ASCII graphic (visible) character
fn is_graphic(b: UInt8) -> Bool {
    b > SPACE && b <= PRINTABLE_MAX
}

// -----------------------------------------------------------------------------
// Case Conversion
// -----------------------------------------------------------------------------

/// Convert byte to uppercase
fn to_uppercase(b: UInt8) -> UInt8 {
    if is_lowercase(b) {
        b - 32
    } else {
        b
    }
}

/// Convert byte to lowercase
fn to_lowercase(b: UInt8) -> UInt8 {
    if is_uppercase(b) {
        b + 32
    } else {
        b
    }
}

/// Convert bytes to uppercase
fn bytes_to_uppercase(bytes: [UInt8]) -> [UInt8] {
    bytes.iter().map(|b| to_uppercase(b)).collect()
}

/// Convert bytes to lowercase
fn bytes_to_lowercase(bytes: [UInt8]) -> [UInt8] {
    bytes.iter().map(|b| to_lowercase(b)).collect()
}

/// Convert ASCII string to uppercase
fn string_to_uppercase(s: String) -> String {
    String.from_utf8(bytes_to_uppercase(s.as_bytes())).unwrap_or(s)
}

/// Convert ASCII string to lowercase
fn string_to_lowercase(s: String) -> String {
    String.from_utf8(bytes_to_lowercase(s.as_bytes())).unwrap_or(s)
}

// -----------------------------------------------------------------------------
// Encoding/Decoding
// -----------------------------------------------------------------------------

/// Encode string to ASCII bytes (fails if non-ASCII)
fn encode(s: String) -> Result<[UInt8], AsciiError> {
    let bytes = s.as_bytes()
    for (i, b) in bytes.iter().enumerate() {
        if !is_ascii(b) {
            return Err(AsciiError.NonAsciiCharacter(i, b))
        }
    }
    Ok(bytes)
}

/// Encode string to ASCII, replacing non-ASCII with '?'
fn encode_lossy(s: String) -> [UInt8] {
    s.as_bytes().iter().map(|b| {
        if is_ascii(b) { b } else { '?' as UInt8 }
    }).collect()
}

/// Encode string to ASCII, replacing non-ASCII with custom byte
fn encode_with_replacement(s: String, replacement: UInt8) -> [UInt8] {
    s.as_bytes().iter().map(|b| {
        if is_ascii(b) { b } else { replacement }
    }).collect()
}

/// Decode ASCII bytes to string
fn decode(bytes: [UInt8]) -> Result<String, AsciiError> {
    for (i, b) in bytes.iter().enumerate() {
        if !is_ascii(b) {
            return Err(AsciiError.NonAsciiCharacter(i, b))
        }
    }
    String.from_utf8(bytes).map_err(|_| AsciiError.InvalidEncoding)
}

/// Decode ASCII bytes, replacing non-ASCII with replacement char
fn decode_lossy(bytes: [UInt8]) -> String {
    let clean = bytes.iter().map(|b| {
        if is_ascii(b) { b } else { '?' as UInt8 }
    }).collect()
    String.from_utf8(clean).unwrap_or("")
}

// -----------------------------------------------------------------------------
// Validation
// -----------------------------------------------------------------------------

/// Check if all bytes are valid ASCII
fn is_valid(bytes: [UInt8]) -> Bool {
    bytes.iter().all(|b| is_ascii(b))
}

/// Check if string is pure ASCII
fn is_ascii_string(s: String) -> Bool {
    is_valid(s.as_bytes())
}

/// Validate ASCII and return first non-ASCII position
fn validate(bytes: [UInt8]) -> Result<(), AsciiError> {
    for (i, b) in bytes.iter().enumerate() {
        if !is_ascii(b) {
            return Err(AsciiError.NonAsciiCharacter(i, b))
        }
    }
    Ok(())
}

/// Count non-ASCII bytes
fn count_non_ascii(bytes: [UInt8]) -> Int {
    bytes.iter().filter(|b| !is_ascii(b)).count()
}

/// Get positions of non-ASCII bytes
fn find_non_ascii(bytes: [UInt8]) -> [Int] {
    bytes.iter()
        .enumerate()
        .filter(|(_, b)| !is_ascii(b))
        .map(|(i, _)| i)
        .collect()
}

// -----------------------------------------------------------------------------
// ASCII Table
// -----------------------------------------------------------------------------

/// ASCII character info
struct AsciiChar {
    code: UInt8
    name: String
    printable: Bool
    category: AsciiCategory
    
    fn from_byte(b: UInt8) -> Option<Self> {
        if !is_ascii(b) {
            return None
        }
        
        let name = get_char_name(b)
        let category = get_category(b)
        
        Some(AsciiChar {
            code: b,
            name: name,
            printable: is_printable(b),
            category: category
        })
    }
    
    fn to_char() -> Char {
        self.code as Char
    }
}

enum AsciiCategory {
    Control
    Digit
    UppercaseLetter
    LowercaseLetter
    Punctuation
    Space
    Symbol
}

fn get_category(b: UInt8) -> AsciiCategory {
    if is_control(b) { AsciiCategory.Control }
    else if is_digit(b) { AsciiCategory.Digit }
    else if is_uppercase(b) { AsciiCategory.UppercaseLetter }
    else if is_lowercase(b) { AsciiCategory.LowercaseLetter }
    else if b == SPACE { AsciiCategory.Space }
    else if is_punctuation(b) { AsciiCategory.Punctuation }
    else { AsciiCategory.Symbol }
}

fn get_char_name(b: UInt8) -> String {
    match b {
        0x00 => "NUL (Null)"
        0x01 => "SOH (Start of Heading)"
        0x02 => "STX (Start of Text)"
        0x03 => "ETX (End of Text)"
        0x04 => "EOT (End of Transmission)"
        0x05 => "ENQ (Enquiry)"
        0x06 => "ACK (Acknowledge)"
        0x07 => "BEL (Bell)"
        0x08 => "BS (Backspace)"
        0x09 => "HT (Horizontal Tab)"
        0x0A => "LF (Line Feed)"
        0x0B => "VT (Vertical Tab)"
        0x0C => "FF (Form Feed)"
        0x0D => "CR (Carriage Return)"
        0x0E => "SO (Shift Out)"
        0x0F => "SI (Shift In)"
        0x10 => "DLE (Data Link Escape)"
        0x11 => "DC1 (Device Control 1)"
        0x12 => "DC2 (Device Control 2)"
        0x13 => "DC3 (Device Control 3)"
        0x14 => "DC4 (Device Control 4)"
        0x15 => "NAK (Negative Acknowledge)"
        0x16 => "SYN (Synchronous Idle)"
        0x17 => "ETB (End of Trans. Block)"
        0x18 => "CAN (Cancel)"
        0x19 => "EM (End of Medium)"
        0x1A => "SUB (Substitute)"
        0x1B => "ESC (Escape)"
        0x1C => "FS (File Separator)"
        0x1D => "GS (Group Separator)"
        0x1E => "RS (Record Separator)"
        0x1F => "US (Unit Separator)"
        0x20 => "Space"
        0x7F => "DEL (Delete)"
        _ => if is_printable(b) {
            format!("'{}'", b as Char)
        } else {
            format!("0x{:02X}", b)
        }
    }
}

/// Generate ASCII table
fn ascii_table() -> [AsciiChar] {
    (0..128).map(|i| AsciiChar.from_byte(i as UInt8).unwrap()).collect()
}

/// Print ASCII table
fn print_table() -> String {
    var lines = []
    lines.push("Dec  Hex  Char  Name")
    lines.push("---  ---  ----  ----")
    
    for i in 0..128 {
        let b = i as UInt8
        let char_repr = if is_printable(b) {
            format!("'{}'", b as Char)
        } else {
            "   "
        }
        let name = get_char_name(b)
        lines.push(format!("{:3}  {:02X}  {}   {}", i, b, char_repr, name))
    }
    
    lines.join("\n")
}

// -----------------------------------------------------------------------------
// String Operations
// -----------------------------------------------------------------------------

/// Strip non-ASCII characters from string
fn strip_non_ascii(s: String) -> String {
    let bytes = s.as_bytes().iter().filter(|b| is_ascii(b)).collect()
    String.from_utf8(bytes).unwrap_or("")
}

/// Replace non-ASCII characters in string
fn replace_non_ascii(s: String, replacement: Char) -> String {
    var result = ""
    for c in s.chars() {
        if is_ascii_char(c) {
            result.push(c)
        } else {
            result.push(replacement)
        }
    }
    result
}

/// Transliterate common non-ASCII to ASCII equivalents
fn transliterate(s: String) -> String {
    var result = ""
    for c in s.chars() {
        result.push_str(transliterate_char(c))
    }
    result
}

fn transliterate_char(c: Char) -> String {
    match c {
        'á' | 'à' | 'â' | 'ä' | 'ã' | 'å' => "a"
        'Á' | 'À' | 'Â' | 'Ä' | 'Ã' | 'Å' => "A"
        'é' | 'è' | 'ê' | 'ë' => "e"
        'É' | 'È' | 'Ê' | 'Ë' => "E"
        'í' | 'ì' | 'î' | 'ï' => "i"
        'Í' | 'Ì' | 'Î' | 'Ï' => "I"
        'ó' | 'ò' | 'ô' | 'ö' | 'õ' => "o"
        'Ó' | 'Ò' | 'Ô' | 'Ö' | 'Õ' => "O"
        'ú' | 'ù' | 'û' | 'ü' => "u"
        'Ú' | 'Ù' | 'Û' | 'Ü' => "U"
        'ñ' => "n"
        'Ñ' => "N"
        'ç' => "c"
        'Ç' => "C"
        'ß' => "ss"
        'æ' => "ae"
        'Æ' => "AE"
        'œ' => "oe"
        'Œ' => "OE"
        'ø' => "o"
        'Ø' => "O"
        '©' => "(c)"
        '®' => "(r)"
        '™' => "(tm)"
        '€' => "EUR"
        '£' => "GBP"
        '¥' => "JPY"
        '°' => "deg"
        '±' => "+/-"
        '×' => "x"
        '÷' => "/"
        '–' | '—' => "-"
        ''' | ''' => "'"
        '"' | '"' => "\""
        '…' => "..."
        _ => if is_ascii_char(c) { c.to_string() } else { "" }
    }
}

// -----------------------------------------------------------------------------
// Escape Sequences
// -----------------------------------------------------------------------------

/// Escape non-printable ASCII characters
fn escape(bytes: [UInt8]) -> String {
    var result = ""
    for b in bytes {
        if is_printable(b) {
            result.push(b as Char)
        } else {
            result.push_str(escape_byte(b))
        }
    }
    result
}

fn escape_byte(b: UInt8) -> String {
    match b {
        0x00 => "\\0"
        0x07 => "\\a"
        0x08 => "\\b"
        0x09 => "\\t"
        0x0A => "\\n"
        0x0B => "\\v"
        0x0C => "\\f"
        0x0D => "\\r"
        0x1B => "\\e"
        _ => format!("\\x{:02X}", b)
    }
}

/// Unescape ASCII escape sequences
fn unescape(s: String) -> Result<[UInt8], AsciiError> {
    var result = []
    var chars = s.chars().peekable()
    
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('0') => result.push(0x00),
                Some('a') => result.push(0x07),
                Some('b') => result.push(0x08),
                Some('t') => result.push(0x09),
                Some('n') => result.push(0x0A),
                Some('v') => result.push(0x0B),
                Some('f') => result.push(0x0C),
                Some('r') => result.push(0x0D),
                Some('e') => result.push(0x1B),
                Some('\\') => result.push('\\' as UInt8),
                Some('x') => {
                    let h1 = chars.next().ok_or(AsciiError.InvalidEscape)?
                    let h2 = chars.next().ok_or(AsciiError.InvalidEscape)?
                    let hex = format!("{}{}", h1, h2)
                    let b = UInt8.parse_hex(hex).map_err(|_| AsciiError.InvalidEscape)?
                    result.push(b)
                }
                _ => return Err(AsciiError.InvalidEscape)
            }
        } else if is_ascii_char(c) {
            result.push(c as UInt8)
        } else {
            return Err(AsciiError.NonAsciiCharacter(result.len(), c as UInt8))
        }
    }
    
    Ok(result)
}

// -----------------------------------------------------------------------------
// ROT13 and Simple Ciphers
// -----------------------------------------------------------------------------

/// Apply ROT13 cipher
fn rot13(s: String) -> String {
    var result = ""
    for c in s.chars() {
        result.push(rot13_char(c))
    }
    result
}

fn rot13_char(c: Char) -> Char {
    let b = c as UInt8
    if is_uppercase(b) {
        (((b - 'A' as UInt8 + 13) % 26) + 'A' as UInt8) as Char
    } else if is_lowercase(b) {
        (((b - 'a' as UInt8 + 13) % 26) + 'a' as UInt8) as Char
    } else {
        c
    }
}

/// Apply Caesar cipher with custom shift
fn caesar(s: String, shift: Int) -> String {
    let shift = ((shift % 26) + 26) % 26  // Normalize to 0-25
    var result = ""
    for c in s.chars() {
        result.push(caesar_char(c, shift))
    }
    result
}

fn caesar_char(c: Char, shift: Int) -> Char {
    let b = c as UInt8
    if is_uppercase(b) {
        (((b - 'A' as UInt8 + shift as UInt8) % 26) + 'A' as UInt8) as Char
    } else if is_lowercase(b) {
        (((b - 'a' as UInt8 + shift as UInt8) % 26) + 'a' as UInt8) as Char
    } else {
        c
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum AsciiError {
    NonAsciiCharacter(Int, UInt8)
    InvalidEncoding
    InvalidEscape
}

impl Display for AsciiError {
    fn fmt(f: Formatter) {
        match self {
            NonAsciiCharacter(pos, byte) => 
                f.write(format!("Non-ASCII character at position {}: 0x{:02X}", pos, byte))
            InvalidEncoding => f.write("Invalid ASCII encoding")
            InvalidEscape => f.write("Invalid escape sequence")
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "is_ascii" {
    assert(is_ascii(0x41))?  // 'A'
    assert(is_ascii(0x7F))?  // DEL
    assert(!is_ascii(0x80))?
    assert(!is_ascii(0xFF))?
}

test "classification" {
    assert(is_digit('5' as UInt8))?
    assert(is_uppercase('A' as UInt8))?
    assert(is_lowercase('a' as UInt8))?
    assert(is_alphabetic('Z' as UInt8))?
    assert(is_alphanumeric('9' as UInt8))?
    assert(is_whitespace(' ' as UInt8))?
    assert(is_control(0x00))?
    assert(is_printable('!' as UInt8))?
}

test "case conversion" {
    assert_eq(to_uppercase('a' as UInt8), 'A' as UInt8)?
    assert_eq(to_lowercase('A' as UInt8), 'a' as UInt8)?
    assert_eq(string_to_uppercase("Hello"), "HELLO")?
    assert_eq(string_to_lowercase("WORLD"), "world")?
}

test "encode" {
    assert_eq(encode("Hello")?, [0x48, 0x65, 0x6C, 0x6C, 0x6F])?
    assert(encode("日本").is_err())?
}

test "encode_lossy" {
    let result = encode_lossy("Hello日本")
    assert_eq(result.len(), 11)?  // 5 + 6 bytes (日本 = 6 UTF-8 bytes)
}

test "decode" {
    assert_eq(decode([0x48, 0x65, 0x6C, 0x6C, 0x6F])?, "Hello")?
    assert(decode([0x80, 0x81]).is_err())?
}

test "is_valid" {
    assert(is_valid([0x48, 0x65, 0x6C, 0x6C, 0x6F]))?
    assert(!is_valid([0x80, 0x81]))?
}

test "is_ascii_string" {
    assert(is_ascii_string("Hello, World!"))?
    assert(!is_ascii_string("日本語"))?
}

test "strip_non_ascii" {
    assert_eq(strip_non_ascii("Hello日本World"), "HelloWorld")?
}

test "transliterate" {
    assert_eq(transliterate("café"), "cafe")?
    assert_eq(transliterate("naïve"), "naive")?
    assert_eq(transliterate("Müller"), "Muller")?
}

test "escape" {
    assert_eq(escape([0x48, 0x09, 0x0A]), "H\\t\\n")?
}

test "unescape" {
    assert_eq(unescape("H\\t\\n")?, [0x48, 0x09, 0x0A])?
    assert_eq(unescape("\\x41")?, [0x41])?
}

test "rot13" {
    assert_eq(rot13("Hello"), "Uryyb")?
    assert_eq(rot13("Uryyb"), "Hello")?  // ROT13 is self-inverse
}

test "caesar" {
    assert_eq(caesar("ABC", 3), "DEF")?
    assert_eq(caesar("DEF", -3), "ABC")?
    assert_eq(caesar("XYZ", 3), "ABC")?  // Wrap around
}

test "ascii_char_info" {
    let info = AsciiChar.from_byte(0x41).unwrap()
    assert_eq(info.code, 0x41)?
    assert(info.printable)?
    assert_eq(info.to_char(), 'A')?
}
