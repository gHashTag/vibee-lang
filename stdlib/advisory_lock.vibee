// =============================================================================
// Vibee OS â€” Advisory Lock Module
// Advisory (cooperative) locking primitives
// =============================================================================

// =============================================================================
// Advisory Lock Types
// =============================================================================

/// Advisory lock mode
enum AdvisoryLockMode {
    Shared      // Multiple readers allowed
    Exclusive   // Single writer only
}

impl AdvisoryLockMode {
    fn is_shared() -> Bool {
        match self {
            AdvisoryLockMode.Shared => true
            _ => false
        }
    }
    
    fn is_exclusive() -> Bool {
        match self {
            AdvisoryLockMode.Exclusive => true
            _ => false
        }
    }
    
    fn is_compatible(other: AdvisoryLockMode) -> Bool {
        match (self, other) {
            (AdvisoryLockMode.Shared, AdvisoryLockMode.Shared) => true
            _ => false
        }
    }
}

/// Advisory lock scope
enum AdvisoryLockScope {
    Session     // Lock released when session ends
    Transaction // Lock released when transaction ends
}

/// Advisory lock errors
enum AdvisoryLockError {
    LockNotAvailable { key: Int64 }
    LockNotHeld { key: Int64 }
    Timeout { key: Int64, timeout_ms: Int64 }
    DeadlockDetected { keys: [Int64] }
    InvalidKey { key: Int64 }
    DatabaseError { message: String }
}

impl AdvisoryLockError {
    fn message() -> String {
        match self {
            AdvisoryLockError.LockNotAvailable { key } => 
                f"Advisory lock {key} is not available"
            AdvisoryLockError.LockNotHeld { key } => 
                f"Advisory lock {key} is not held"
            AdvisoryLockError.Timeout { key, timeout_ms } => 
                f"Timeout waiting for advisory lock {key} after {timeout_ms}ms"
            AdvisoryLockError.DeadlockDetected { keys } => 
                f"Deadlock detected involving locks: {keys:?}"
            AdvisoryLockError.InvalidKey { key } => 
                f"Invalid advisory lock key: {key}"
            AdvisoryLockError.DatabaseError { message } => 
                f"Database error: {message}"
        }
    }
}

// =============================================================================
// PostgreSQL Advisory Locks
// =============================================================================

/// PostgreSQL advisory lock
actor PostgresAdvisoryLock {
    state conn: PostgresConnection
    state key: Int64
    state mode: AdvisoryLockMode
    state scope: AdvisoryLockScope
    state held: Bool
    
    fn new(conn: PostgresConnection, key: Int64) -> Self {
        PostgresAdvisoryLock {
            conn: conn,
            key: key,
            mode: AdvisoryLockMode.Exclusive,
            scope: AdvisoryLockScope.Session,
            held: false
        }
    }
    
    fn shared(conn: PostgresConnection, key: Int64) -> Self {
        PostgresAdvisoryLock {
            conn: conn,
            key: key,
            mode: AdvisoryLockMode.Shared,
            scope: AdvisoryLockScope.Session,
            held: false
        }
    }
    
    fn transaction_scoped(conn: PostgresConnection, key: Int64) -> Self {
        PostgresAdvisoryLock {
            conn: conn,
            key: key,
            mode: AdvisoryLockMode.Exclusive,
            scope: AdvisoryLockScope.Transaction,
            held: false
        }
    }
    
    /// Acquire lock (blocking)
    fn acquire() -> Result<AdvisoryLockGuard, AdvisoryLockError> {
        let sql = match (self.mode, self.scope) {
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Session) => 
                f"SELECT pg_advisory_lock({self.key})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Session) => 
                f"SELECT pg_advisory_lock_shared({self.key})"
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_advisory_xact_lock({self.key})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_advisory_xact_lock_shared({self.key})"
        }
        
        match @native("postgres_execute", self.conn, sql) {
            Ok(_) => {
                self.held = true
                Ok(AdvisoryLockGuard { lock: self })
            }
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Try to acquire lock (non-blocking)
    fn try_acquire() -> Result<Option<AdvisoryLockGuard>, AdvisoryLockError> {
        let sql = match (self.mode, self.scope) {
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Session) => 
                f"SELECT pg_try_advisory_lock({self.key})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Session) => 
                f"SELECT pg_try_advisory_lock_shared({self.key})"
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_try_advisory_xact_lock({self.key})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_try_advisory_xact_lock_shared({self.key})"
        }
        
        match @native("postgres_query_one", self.conn, sql) {
            Ok(true) => {
                self.held = true
                Ok(Some(AdvisoryLockGuard { lock: self }))
            }
            Ok(false) => Ok(None)
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Release lock (session-scoped only)
    fn release() -> Result<(), AdvisoryLockError> {
        if !self.held {
            return Ok(())
        }
        
        // Transaction-scoped locks are released automatically
        if self.scope == AdvisoryLockScope.Transaction {
            self.held = false
            return Ok(())
        }
        
        let sql = match self.mode {
            AdvisoryLockMode.Exclusive => f"SELECT pg_advisory_unlock({self.key})"
            AdvisoryLockMode.Shared => f"SELECT pg_advisory_unlock_shared({self.key})"
        }
        
        match @native("postgres_query_one", self.conn, sql) {
            Ok(true) => {
                self.held = false
                Ok(())
            }
            Ok(false) => Err(AdvisoryLockError.LockNotHeld { key: self.key })
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Check if lock is held
    fn is_held() -> Bool { self.held }
}

/// Guard for automatic lock release
struct AdvisoryLockGuard {
    lock: PostgresAdvisoryLock
}

impl Drop for AdvisoryLockGuard {
    fn drop() {
        let _ = self.lock.release()
    }
}

// =============================================================================
// Two-Key Advisory Locks
// =============================================================================

/// PostgreSQL advisory lock with two 32-bit keys
actor PostgresAdvisoryLock2 {
    state conn: PostgresConnection
    state key1: Int32
    state key2: Int32
    state mode: AdvisoryLockMode
    state scope: AdvisoryLockScope
    state held: Bool
    
    fn new(conn: PostgresConnection, key1: Int32, key2: Int32) -> Self {
        PostgresAdvisoryLock2 {
            conn: conn,
            key1: key1,
            key2: key2,
            mode: AdvisoryLockMode.Exclusive,
            scope: AdvisoryLockScope.Session,
            held: false
        }
    }
    
    /// Create from entity type and ID
    fn for_entity(conn: PostgresConnection, entity_type: Int32, entity_id: Int32) -> Self {
        Self.new(conn, entity_type, entity_id)
    }
    
    /// Acquire lock
    fn acquire() -> Result<AdvisoryLock2Guard, AdvisoryLockError> {
        let sql = match (self.mode, self.scope) {
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Session) => 
                f"SELECT pg_advisory_lock({self.key1}, {self.key2})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Session) => 
                f"SELECT pg_advisory_lock_shared({self.key1}, {self.key2})"
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_advisory_xact_lock({self.key1}, {self.key2})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_advisory_xact_lock_shared({self.key1}, {self.key2})"
        }
        
        match @native("postgres_execute", self.conn, sql) {
            Ok(_) => {
                self.held = true
                Ok(AdvisoryLock2Guard { lock: self })
            }
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Try to acquire lock
    fn try_acquire() -> Result<Option<AdvisoryLock2Guard>, AdvisoryLockError> {
        let sql = match (self.mode, self.scope) {
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Session) => 
                f"SELECT pg_try_advisory_lock({self.key1}, {self.key2})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Session) => 
                f"SELECT pg_try_advisory_lock_shared({self.key1}, {self.key2})"
            (AdvisoryLockMode.Exclusive, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_try_advisory_xact_lock({self.key1}, {self.key2})"
            (AdvisoryLockMode.Shared, AdvisoryLockScope.Transaction) => 
                f"SELECT pg_try_advisory_xact_lock_shared({self.key1}, {self.key2})"
        }
        
        match @native("postgres_query_one", self.conn, sql) {
            Ok(true) => {
                self.held = true
                Ok(Some(AdvisoryLock2Guard { lock: self }))
            }
            Ok(false) => Ok(None)
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Release lock
    fn release() -> Result<(), AdvisoryLockError> {
        if !self.held || self.scope == AdvisoryLockScope.Transaction {
            self.held = false
            return Ok(())
        }
        
        let sql = match self.mode {
            AdvisoryLockMode.Exclusive => 
                f"SELECT pg_advisory_unlock({self.key1}, {self.key2})"
            AdvisoryLockMode.Shared => 
                f"SELECT pg_advisory_unlock_shared({self.key1}, {self.key2})"
        }
        
        match @native("postgres_query_one", self.conn, sql) {
            Ok(true) => {
                self.held = false
                Ok(())
            }
            Ok(false) => Err(AdvisoryLockError.LockNotHeld { 
                key: ((self.key1 as Int64) << 32) | (self.key2 as Int64)
            })
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
}

struct AdvisoryLock2Guard {
    lock: PostgresAdvisoryLock2
}

impl Drop for AdvisoryLock2Guard {
    fn drop() {
        let _ = self.lock.release()
    }
}

// =============================================================================
// MySQL Advisory Locks
// =============================================================================

/// MySQL GET_LOCK based advisory lock
actor MySqlAdvisoryLock {
    state conn: MySqlConnection
    state name: String
    state timeout_sec: Int
    state held: Bool
    
    fn new(conn: MySqlConnection, name: String) -> Self {
        MySqlAdvisoryLock {
            conn: conn,
            name: name,
            timeout_sec: 10,
            held: false
        }
    }
    
    fn with_timeout(conn: MySqlConnection, name: String, timeout_sec: Int) -> Self {
        MySqlAdvisoryLock {
            conn: conn,
            name: name,
            timeout_sec: timeout_sec,
            held: false
        }
    }
    
    /// Acquire lock
    fn acquire() -> Result<MySqlAdvisoryLockGuard, AdvisoryLockError> {
        let sql = f"SELECT GET_LOCK('{self.name}', {self.timeout_sec})"
        
        match @native("mysql_query_one", self.conn, sql) {
            Ok(1) => {
                self.held = true
                Ok(MySqlAdvisoryLockGuard { lock: self })
            }
            Ok(0) => Err(AdvisoryLockError.Timeout { 
                key: self.name.hash() as Int64, 
                timeout_ms: (self.timeout_sec * 1000) as Int64 
            })
            Ok(_) => Err(AdvisoryLockError.DatabaseError { 
                message: "GET_LOCK returned unexpected value".to_string() 
            })
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Try to acquire lock (non-blocking)
    fn try_acquire() -> Result<Option<MySqlAdvisoryLockGuard>, AdvisoryLockError> {
        let sql = f"SELECT GET_LOCK('{self.name}', 0)"
        
        match @native("mysql_query_one", self.conn, sql) {
            Ok(1) => {
                self.held = true
                Ok(Some(MySqlAdvisoryLockGuard { lock: self }))
            }
            Ok(0) => Ok(None)
            Ok(_) => Err(AdvisoryLockError.DatabaseError { 
                message: "GET_LOCK returned unexpected value".to_string() 
            })
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Release lock
    fn release() -> Result<(), AdvisoryLockError> {
        if !self.held {
            return Ok(())
        }
        
        let sql = f"SELECT RELEASE_LOCK('{self.name}')"
        
        match @native("mysql_query_one", self.conn, sql) {
            Ok(1) => {
                self.held = false
                Ok(())
            }
            Ok(0) => Err(AdvisoryLockError.LockNotHeld { 
                key: self.name.hash() as Int64 
            })
            Ok(_) => {
                self.held = false
                Ok(())
            }
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Check if lock is free
    fn is_free() -> Result<Bool, AdvisoryLockError> {
        let sql = f"SELECT IS_FREE_LOCK('{self.name}')"
        
        match @native("mysql_query_one", self.conn, sql) {
            Ok(1) => Ok(true)
            Ok(0) => Ok(false)
            Ok(_) => Err(AdvisoryLockError.DatabaseError { 
                message: "IS_FREE_LOCK returned unexpected value".to_string() 
            })
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
    
    /// Check if lock is held by current session
    fn is_used_by_me() -> Result<Bool, AdvisoryLockError> {
        let sql = f"SELECT IS_USED_LOCK('{self.name}') = CONNECTION_ID()"
        
        match @native("mysql_query_one", self.conn, sql) {
            Ok(result) => Ok(result)
            Err(e) => Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
        }
    }
}

struct MySqlAdvisoryLockGuard {
    lock: MySqlAdvisoryLock
}

impl Drop for MySqlAdvisoryLockGuard {
    fn drop() {
        let _ = self.lock.release()
    }
}

// =============================================================================
// In-Memory Advisory Lock Manager
// =============================================================================

/// In-memory advisory lock for single-process coordination
actor AdvisoryLockManager {
    state locks: Map<String, AdvisoryLockEntry>
    state waiters: Map<String, [fn()]>
    
    fn new() -> Self {
        AdvisoryLockManager {
            locks: Map.new(),
            waiters: Map.new()
        }
    }
    
    /// Acquire exclusive lock
    fn acquire_exclusive(key: String, owner: String) -> Result<InMemoryLockGuard, AdvisoryLockError> {
        loop {
            if let Some(entry) = self.locks.get(key) {
                if entry.mode == AdvisoryLockMode.Exclusive || entry.holders.len() > 0 {
                    // Wait for lock
                    @native("advisory_wait", self, key)
                    continue
                }
            }
            
            self.locks.insert(key.clone(), AdvisoryLockEntry {
                mode: AdvisoryLockMode.Exclusive,
                holders: [owner.clone()]
            })
            
            return Ok(InMemoryLockGuard { 
                manager: self, 
                key: key, 
                owner: owner 
            })
        }
    }
    
    /// Acquire shared lock
    fn acquire_shared(key: String, owner: String) -> Result<InMemoryLockGuard, AdvisoryLockError> {
        loop {
            if let Some(entry) = self.locks.get_mut(key) {
                if entry.mode == AdvisoryLockMode.Exclusive {
                    // Wait for exclusive lock to be released
                    @native("advisory_wait", self, key)
                    continue
                }
                // Add to shared holders
                entry.holders.push(owner.clone())
                return Ok(InMemoryLockGuard { 
                    manager: self, 
                    key: key, 
                    owner: owner 
                })
            }
            
            self.locks.insert(key.clone(), AdvisoryLockEntry {
                mode: AdvisoryLockMode.Shared,
                holders: [owner.clone()]
            })
            
            return Ok(InMemoryLockGuard { 
                manager: self, 
                key: key, 
                owner: owner 
            })
        }
    }
    
    /// Try to acquire exclusive lock
    fn try_acquire_exclusive(key: String, owner: String) -> Option<InMemoryLockGuard> {
        if let Some(entry) = self.locks.get(key) {
            if entry.mode == AdvisoryLockMode.Exclusive || entry.holders.len() > 0 {
                return None
            }
        }
        
        self.locks.insert(key.clone(), AdvisoryLockEntry {
            mode: AdvisoryLockMode.Exclusive,
            holders: [owner.clone()]
        })
        
        Some(InMemoryLockGuard { 
            manager: self, 
            key: key, 
            owner: owner 
        })
    }
    
    /// Try to acquire shared lock
    fn try_acquire_shared(key: String, owner: String) -> Option<InMemoryLockGuard> {
        if let Some(entry) = self.locks.get_mut(key) {
            if entry.mode == AdvisoryLockMode.Exclusive {
                return None
            }
            entry.holders.push(owner.clone())
            return Some(InMemoryLockGuard { 
                manager: self, 
                key: key, 
                owner: owner 
            })
        }
        
        self.locks.insert(key.clone(), AdvisoryLockEntry {
            mode: AdvisoryLockMode.Shared,
            holders: [owner.clone()]
        })
        
        Some(InMemoryLockGuard { 
            manager: self, 
            key: key, 
            owner: owner 
        })
    }
    
    /// Release lock
    fn release(key: String, owner: String) {
        if let Some(entry) = self.locks.get_mut(key) {
            entry.holders.retain(|h| *h != owner)
            
            if entry.holders.is_empty() {
                self.locks.remove(key)
                // Notify waiters
                if let Some(waiters) = self.waiters.remove(key) {
                    for waiter in waiters {
                        waiter()
                    }
                }
            }
        }
    }
    
    /// Get lock info
    fn get_lock_info(key: String) -> Option<AdvisoryLockInfo> {
        self.locks.get(key).map(|entry| AdvisoryLockInfo {
            key: key,
            mode: entry.mode,
            holder_count: entry.holders.len()
        })
    }
    
    /// List all locks
    fn list_locks() -> [AdvisoryLockInfo] {
        self.locks.iter().map(|(key, entry)| AdvisoryLockInfo {
            key: key.clone(),
            mode: entry.mode,
            holder_count: entry.holders.len()
        }).collect()
    }
}

struct AdvisoryLockEntry {
    mode: AdvisoryLockMode
    holders: [String]
}

struct AdvisoryLockInfo {
    key: String
    mode: AdvisoryLockMode
    holder_count: Int
}

struct InMemoryLockGuard {
    manager: AdvisoryLockManager
    key: String
    owner: String
}

impl Drop for InMemoryLockGuard {
    fn drop() {
        self.manager.release(self.key.clone(), self.owner.clone())
    }
}

// =============================================================================
// Named Lock Registry
// =============================================================================

/// Registry for named advisory locks
actor NamedLockRegistry {
    state manager: AdvisoryLockManager
    state name_to_key: Map<String, Int64>
    state next_key: Int64
    
    fn new() -> Self {
        NamedLockRegistry {
            manager: AdvisoryLockManager.new(),
            name_to_key: Map.new(),
            next_key: 1
        }
    }
    
    /// Get or create key for name
    fn get_key(name: String) -> Int64 {
        if let Some(key) = self.name_to_key.get(name) {
            return *key
        }
        
        let key = self.next_key
        self.next_key += 1
        self.name_to_key.insert(name, key)
        key
    }
    
    /// Acquire named lock
    fn acquire(name: String, owner: String) -> Result<InMemoryLockGuard, AdvisoryLockError> {
        self.manager.acquire_exclusive(name, owner)
    }
    
    /// Acquire named shared lock
    fn acquire_shared(name: String, owner: String) -> Result<InMemoryLockGuard, AdvisoryLockError> {
        self.manager.acquire_shared(name, owner)
    }
}

// =============================================================================
// File Advisory Locks
// =============================================================================

/// File-based advisory lock (flock)
struct FileAdvisoryLock {
    path: String
    fd: Option<FileDescriptor>
    mode: AdvisoryLockMode
    held: Bool
    
    fn new(path: String) -> Self {
        FileAdvisoryLock {
            path: path,
            fd: None,
            mode: AdvisoryLockMode.Exclusive,
            held: false
        }
    }
    
    fn shared(path: String) -> Self {
        FileAdvisoryLock {
            path: path,
            fd: None,
            mode: AdvisoryLockMode.Shared,
            held: false
        }
    }
    
    /// Acquire file lock
    fn acquire() -> Result<FileLockGuard, AdvisoryLockError> {
        let fd = @native("file_open", self.path, "r+")?
        self.fd = Some(fd)
        
        let flags = match self.mode {
            AdvisoryLockMode.Exclusive => @native("LOCK_EX")
            AdvisoryLockMode.Shared => @native("LOCK_SH")
        }
        
        match @native("flock", fd, flags) {
            Ok(_) => {
                self.held = true
                Ok(FileLockGuard { lock: self })
            }
            Err(e) => {
                @native("file_close", fd)
                self.fd = None
                Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
            }
        }
    }
    
    /// Try to acquire file lock
    fn try_acquire() -> Result<Option<FileLockGuard>, AdvisoryLockError> {
        let fd = @native("file_open", self.path, "r+")?
        self.fd = Some(fd)
        
        let flags = match self.mode {
            AdvisoryLockMode.Exclusive => @native("LOCK_EX") | @native("LOCK_NB")
            AdvisoryLockMode.Shared => @native("LOCK_SH") | @native("LOCK_NB")
        }
        
        match @native("flock", fd, flags) {
            Ok(_) => {
                self.held = true
                Ok(Some(FileLockGuard { lock: self }))
            }
            Err(e) if e.code() == @native("EWOULDBLOCK") => {
                @native("file_close", fd)
                self.fd = None
                Ok(None)
            }
            Err(e) => {
                @native("file_close", fd)
                self.fd = None
                Err(AdvisoryLockError.DatabaseError { message: e.to_string() })
            }
        }
    }
    
    /// Release file lock
    fn release() -> Result<(), AdvisoryLockError> {
        if let Some(fd) = self.fd.take() {
            let _ = @native("flock", fd, @native("LOCK_UN"))
            let _ = @native("file_close", fd)
            self.held = false
        }
        Ok(())
    }
}

struct FileLockGuard {
    lock: FileAdvisoryLock
}

impl Drop for FileLockGuard {
    fn drop() {
        let _ = self.lock.release()
    }
}

// =============================================================================
// Tests
// =============================================================================

test "advisory lock mode compatibility" {
    assert(AdvisoryLockMode.Shared.is_compatible(AdvisoryLockMode.Shared))?
    assert(!AdvisoryLockMode.Shared.is_compatible(AdvisoryLockMode.Exclusive))?
    assert(!AdvisoryLockMode.Exclusive.is_compatible(AdvisoryLockMode.Shared))?
    assert(!AdvisoryLockMode.Exclusive.is_compatible(AdvisoryLockMode.Exclusive))?
}

test "in-memory advisory lock" {
    let manager = AdvisoryLockManager.new()
    
    // Acquire exclusive lock
    let guard1 = manager.try_acquire_exclusive("resource1".to_string(), "owner1".to_string())
    assert(guard1.is_some())?
    
    // Try to acquire same lock - should fail
    let guard2 = manager.try_acquire_exclusive("resource1".to_string(), "owner2".to_string())
    assert(guard2.is_none())?
    
    // Release first lock
    drop(guard1)
    
    // Now should succeed
    let guard3 = manager.try_acquire_exclusive("resource1".to_string(), "owner2".to_string())
    assert(guard3.is_some())?
}

test "shared advisory locks" {
    let manager = AdvisoryLockManager.new()
    
    // Multiple shared locks should succeed
    let guard1 = manager.try_acquire_shared("resource1".to_string(), "owner1".to_string())
    let guard2 = manager.try_acquire_shared("resource1".to_string(), "owner2".to_string())
    
    assert(guard1.is_some())?
    assert(guard2.is_some())?
    
    // Exclusive lock should fail while shared locks held
    let guard3 = manager.try_acquire_exclusive("resource1".to_string(), "owner3".to_string())
    assert(guard3.is_none())?
}

test "lock info" {
    let manager = AdvisoryLockManager.new()
    
    let _guard = manager.try_acquire_exclusive("resource1".to_string(), "owner1".to_string())
    
    let info = manager.get_lock_info("resource1".to_string())
    assert(info.is_some())?
    assert_eq(info.unwrap().holder_count, 1)?
}
