// =============================================================================
// Vibee OS â€” Event Bus Module
// Centralized event bus for application-wide event communication
// =============================================================================

use result::{Result, Ok, Err}
use emitter::{Event, EventMeta, EventPriority, ListenerId}
use listener::{Listener, Subscription, CompositeSubscription}
use dispatcher::{DispatchResult, DispatchStrategy}

// =============================================================================
// Core Types
// =============================================================================

/// Event bus configuration
struct EventBusConfig {
    max_listeners_per_event: Int,
    enable_wildcards: Bool,
    enable_namespaces: Bool,
    namespace_separator: String,
    async_dispatch: Bool,
    buffer_size: Int,
    enable_history: Bool,
    history_size: Int
}

impl EventBusConfig {
    fn default() -> Self {
        EventBusConfig {
            max_listeners_per_event: 100,
            enable_wildcards: true,
            enable_namespaces: true,
            namespace_separator: ".",
            async_dispatch: false,
            buffer_size: 0,
            enable_history: false,
            history_size: 100
        }
    }
    
    fn with_history(size: Int) -> Self {
        var config = Self.default()
        config.enable_history = true
        config.history_size = size
        config
    }
    
    fn with_buffer(size: Int) -> Self {
        var config = Self.default()
        config.buffer_size = size
        config
    }
}

/// Event history entry
struct HistoryEntry<T> {
    event: Event<T>,
    timestamp: Int64,
    listener_count: Int
}

/// Bus statistics
struct BusStats {
    total_events_published: Int64,
    total_events_delivered: Int64,
    total_listeners: Int,
    events_per_second: Float,
    avg_delivery_time_ms: Float
}

// =============================================================================
// Event Bus
// =============================================================================

/// Central event bus actor
actor EventBus<T: Clone> {
    state config: EventBusConfig
    state listeners: Map<String, [(Int, fn(Event<T>), Bool)]>  // (id, handler, once)
    state next_id: Int
    state history: [HistoryEntry<T>]
    state buffer: Map<String, [Event<T>]>
    state stats: BusStats
    state interceptors: [fn(Event<T>) -> Option<Event<T>>]
    state error_handlers: [fn(String, Error)]
    state paused: Bool
    
    fn new() -> Self {
        Self.with_config(EventBusConfig.default())
    }
    
    fn with_config(config: EventBusConfig) -> Self {
        EventBus {
            config: config,
            listeners: Map.new(),
            next_id: 0,
            history: [],
            buffer: Map.new(),
            stats: BusStats {
                total_events_published: 0,
                total_events_delivered: 0,
                total_listeners: 0,
                events_per_second: 0.0,
                avg_delivery_time_ms: 0.0
            },
            interceptors: [],
            error_handlers: [],
            paused: false
        }
    }
    
    // -------------------------------------------------------------------------
    // Subscription Methods
    // -------------------------------------------------------------------------
    
    fn on(event: String, handler: fn(Event<T>)) -> Subscription {
        self.subscribe(event, handler, false)
    }
    
    fn once(event: String, handler: fn(Event<T>)) -> Subscription {
        self.subscribe(event, handler, true)
    }
    
    fn subscribe(event: String, handler: fn(Event<T>), once: Bool) -> Subscription {
        let id = self.next_id
        self.next_id += 1
        
        if !self.listeners.contains_key(event) {
            self.listeners.insert(event.clone(), [])
        }
        
        let list = self.listeners.get_mut(event).unwrap()
        
        if list.len() >= self.config.max_listeners_per_event {
            for eh in self.error_handlers.iter() {
                eh(event.clone(), Error.new("Max listeners exceeded"))
            }
        }
        
        list.push((id, handler, once))
        self.stats.total_listeners += 1
        
        // Replay buffered events
        if self.config.buffer_size > 0 {
            if let Some(buffered) = self.buffer.get(event) {
                for evt in buffered.iter() {
                    handler(evt.clone())
                }
            }
        }
        
        let event_clone = event.clone()
        Subscription.new(id, || {
            self.unsubscribe(event_clone, id)
        })
    }
    
    fn unsubscribe(event: String, id: Int) -> Bool {
        if let Some(list) = self.listeners.get_mut(event) {
            for (i, (lid, _, _)) in list.iter().enumerate() {
                if *lid == id {
                    list.remove(i)
                    self.stats.total_listeners -= 1
                    return true
                }
            }
        }
        false
    }
    
    fn off(event: String) -> Int {
        if let Some(list) = self.listeners.remove(event) {
            let count = list.len()
            self.stats.total_listeners -= count as Int
            count
        } else {
            0
        }
    }
    
    fn off_all() {
        self.listeners.clear()
        self.stats.total_listeners = 0
    }
    
    // -------------------------------------------------------------------------
    // Publishing Methods
    // -------------------------------------------------------------------------
    
    fn emit(event: String, data: T) -> Int {
        self.publish(Event.new(event, data, "event_bus"))
    }
    
    fn emit_with_meta(event: String, data: T, meta: EventMeta) -> Int {
        self.publish(Event {
            name: event,
            data: data,
            meta: meta
        })
    }
    
    fn publish(evt: Event<T>) -> Int {
        if self.paused {
            // Buffer if paused
            self.buffer_event(evt)
            return 0
        }
        
        self.stats.total_events_published += 1
        let start_time = @native("timestamp_ms")
        
        // Apply interceptors
        var processed = evt
        for interceptor in self.interceptors.iter() {
            match interceptor(processed) {
                Some(e) => processed = e,
                None => return 0  // Event was filtered
            }
        }
        
        let event_name = processed.name.clone()
        var delivered = 0
        var to_remove = []
        
        // Direct listeners
        if let Some(list) = self.listeners.get(event_name) {
            for (i, (id, handler, once)) in list.iter().enumerate() {
                self.safe_call(handler, processed.clone())
                delivered += 1
                if *once {
                    to_remove.push(i)
                }
            }
        }
        
        // Wildcard listeners
        if self.config.enable_wildcards {
            delivered += self.notify_wildcard_listeners(processed.clone())
        }
        
        // Namespace listeners
        if self.config.enable_namespaces {
            delivered += self.notify_namespace_listeners(processed.clone())
        }
        
        // Remove once listeners
        if let Some(list) = self.listeners.get_mut(event_name) {
            for i in to_remove.iter().rev() {
                list.remove(*i)
                self.stats.total_listeners -= 1
            }
        }
        
        // Update stats
        self.stats.total_events_delivered += delivered as Int64
        let elapsed = @native("timestamp_ms") - start_time
        self.stats.avg_delivery_time_ms = 
            (self.stats.avg_delivery_time_ms * 0.9) + (elapsed as Float * 0.1)
        
        // Add to history
        if self.config.enable_history {
            self.add_to_history(processed, delivered)
        }
        
        // Buffer if no listeners
        if delivered == 0 && self.config.buffer_size > 0 {
            self.buffer_event(processed)
        }
        
        delivered
    }
    
    fn notify_wildcard_listeners(evt: Event<T>) -> Int {
        var delivered = 0
        
        // Global wildcard
        if let Some(list) = self.listeners.get("*") {
            for (_, handler, _) in list.iter() {
                self.safe_call(handler, evt.clone())
                delivered += 1
            }
        }
        
        // Pattern wildcards (e.g., "user.*")
        for (pattern, list) in self.listeners.iter() {
            if pattern.ends_with("*") && pattern != "*" {
                let prefix = pattern.trim_end_matches("*")
                if evt.name.starts_with(prefix) {
                    for (_, handler, _) in list.iter() {
                        self.safe_call(handler, evt.clone())
                        delivered += 1
                    }
                }
            }
        }
        
        delivered
    }
    
    fn notify_namespace_listeners(evt: Event<T>) -> Int {
        var delivered = 0
        let sep = self.config.namespace_separator.clone()
        let parts: [String] = evt.name.split(sep).collect()
        
        // Notify parent namespace listeners
        var namespace = String.new()
        for (i, part) in parts.iter().enumerate() {
            if i > 0 {
                namespace.push_str(sep)
            }
            namespace.push_str(part)
            
            let ns_wildcard = format!("{}{}*", namespace, sep)
            if let Some(list) = self.listeners.get(ns_wildcard) {
                for (_, handler, _) in list.iter() {
                    self.safe_call(handler, evt.clone())
                    delivered += 1
                }
            }
        }
        
        delivered
    }
    
    fn safe_call(handler: fn(Event<T>), evt: Event<T>) {
        // Wrap handler call with error handling
        match @native("try_catch", || handler(evt.clone())) {
            Ok(_) => {},
            Err(e) => {
                for eh in self.error_handlers.iter() {
                    eh(evt.name.clone(), e)
                }
            }
        }
    }
    
    fn buffer_event(evt: Event<T>) {
        let event_name = evt.name.clone()
        
        if !self.buffer.contains_key(event_name) {
            self.buffer.insert(event_name.clone(), [])
        }
        
        let buf = self.buffer.get_mut(event_name).unwrap()
        if buf.len() >= self.config.buffer_size {
            buf.remove(0)  // Remove oldest
        }
        buf.push(evt)
    }
    
    fn add_to_history(evt: Event<T>, listener_count: Int) {
        if self.history.len() >= self.config.history_size {
            self.history.remove(0)
        }
        
        self.history.push(HistoryEntry {
            event: evt,
            timestamp: @native("timestamp_ms"),
            listener_count: listener_count
        })
    }
    
    // -------------------------------------------------------------------------
    // Control Methods
    // -------------------------------------------------------------------------
    
    fn pause() {
        self.paused = true
    }
    
    fn resume() {
        self.paused = false
        
        // Flush buffered events
        let buffered = self.buffer.clone()
        self.buffer.clear()
        
        for (_, events) in buffered.iter() {
            for evt in events.iter() {
                self.publish(evt.clone())
            }
        }
    }
    
    fn is_paused() -> Bool {
        self.paused
    }
    
    // -------------------------------------------------------------------------
    // Interceptors and Error Handling
    // -------------------------------------------------------------------------
    
    fn add_interceptor(interceptor: fn(Event<T>) -> Option<Event<T>>) {
        self.interceptors.push(interceptor)
    }
    
    fn add_error_handler(handler: fn(String, Error)) {
        self.error_handlers.push(handler)
    }
    
    // -------------------------------------------------------------------------
    // Query Methods
    // -------------------------------------------------------------------------
    
    fn has_listeners(event: String) -> Bool {
        self.listener_count(event) > 0
    }
    
    fn listener_count(event: String) -> Int {
        self.listeners.get(event).map(|l| l.len()).unwrap_or(0)
    }
    
    fn total_listener_count() -> Int {
        self.stats.total_listeners
    }
    
    fn event_names() -> [String] {
        self.listeners.keys().collect()
    }
    
    fn get_stats() -> BusStats {
        self.stats.clone()
    }
    
    fn get_history() -> [HistoryEntry<T>] {
        self.history.clone()
    }
    
    fn get_history_for(event: String) -> [HistoryEntry<T>] {
        self.history.iter()
            .filter(|h| h.event.name == event)
            .cloned()
            .collect()
    }
    
    fn clear_history() {
        self.history.clear()
    }
    
    fn clear_buffer() {
        self.buffer.clear()
    }
}

// =============================================================================
// Typed Event Bus
// =============================================================================

/// Type-safe event definition
trait EventDefinition {
    type Payload
    fn event_name() -> String
}

/// Typed event bus with compile-time event type checking
actor TypedEventBus {
    state bus: EventBus<Any>
    
    fn new() -> Self {
        TypedEventBus { bus: EventBus.new() }
    }
    
    fn on<E: EventDefinition>(handler: fn(E.Payload)) -> Subscription {
        self.bus.on(E.event_name(), |evt| {
            let payload = evt.data as E.Payload
            handler(payload)
        })
    }
    
    fn once<E: EventDefinition>(handler: fn(E.Payload)) -> Subscription {
        self.bus.once(E.event_name(), |evt| {
            let payload = evt.data as E.Payload
            handler(payload)
        })
    }
    
    fn emit<E: EventDefinition>(payload: E.Payload) -> Int {
        self.bus.emit(E.event_name(), payload as Any)
    }
}

// =============================================================================
// Scoped Event Bus
// =============================================================================

/// Event bus with automatic cleanup on scope exit
struct ScopedEventBus<T: Clone> {
    bus: EventBus<T>,
    subscriptions: CompositeSubscription
}

impl<T: Clone> ScopedEventBus<T> {
    fn new(bus: EventBus<T>) -> Self {
        ScopedEventBus {
            bus: bus,
            subscriptions: CompositeSubscription.new()
        }
    }
    
    fn on(event: String, handler: fn(Event<T>)) {
        let sub = self.bus.on(event, handler)
        self.subscriptions.add(sub)
    }
    
    fn emit(event: String, data: T) -> Int {
        self.bus.emit(event, data)
    }
}

impl<T: Clone> Drop for ScopedEventBus<T> {
    fn drop() {
        self.subscriptions.unsubscribe_all()
    }
}

// =============================================================================
// Event Bus Bridge
// =============================================================================

/// Bridge between two event buses
struct EventBusBridge<T: Clone, U: Clone> {
    source: EventBus<T>,
    target: EventBus<U>,
    transformer: fn(Event<T>) -> Option<Event<U>>,
    subscription: Option<Subscription>
}

impl<T: Clone, U: Clone> EventBusBridge<T, U> {
    fn new(
        source: EventBus<T>,
        target: EventBus<U>,
        transformer: fn(Event<T>) -> Option<Event<U>>
    ) -> Self {
        EventBusBridge {
            source: source,
            target: target,
            transformer: transformer,
            subscription: None
        }
    }
    
    fn connect(events: [String]) {
        for event in events {
            let sub = self.source.on(event, |evt| {
                if let Some(transformed) = (self.transformer)(evt) {
                    self.target.publish(transformed)
                }
            })
            self.subscription = Some(sub)
        }
    }
    
    fn disconnect() {
        if let Some(sub) = self.subscription.take() {
            sub.unsubscribe()
        }
    }
}

// =============================================================================
// Event Bus Middleware
// =============================================================================

/// Logging middleware
fn logging_middleware<T: Debug>(logger: fn(String)) -> fn(Event<T>) -> Option<Event<T>> {
    |evt| {
        logger(format!("[EventBus] {} - {:?}", evt.name, evt.data))
        Some(evt)
    }
}

/// Validation middleware
fn validation_middleware<T>(
    validator: fn(Event<T>) -> Bool
) -> fn(Event<T>) -> Option<Event<T>> {
    |evt| {
        if validator(evt.clone()) {
            Some(evt)
        } else {
            None
        }
    }
}

/// Rate limiting middleware
fn rate_limit_middleware<T: Clone>(
    max_per_second: Int
) -> fn(Event<T>) -> Option<Event<T>> {
    var count = 0
    var last_reset = @native("timestamp_ms")
    
    |evt| {
        let now = @native("timestamp_ms")
        if now - last_reset >= 1000 {
            count = 0
            last_reset = now
        }
        
        if count < max_per_second {
            count += 1
            Some(evt)
        } else {
            None
        }
    }
}

/// Deduplication middleware
fn dedup_middleware<T: Hash + Eq + Clone>(
    window_ms: Int64
) -> fn(Event<T>) -> Option<Event<T>> {
    var seen: Map<T, Int64> = Map.new()
    
    |evt| {
        let now = @native("timestamp_ms")
        
        // Clean old entries
        seen.retain(|_, ts| now - *ts < window_ms)
        
        if seen.contains_key(evt.data) {
            None
        } else {
            seen.insert(evt.data.clone(), now)
            Some(evt)
        }
    }
}

// =============================================================================
// Global Event Bus
// =============================================================================

/// Global singleton event bus
static GLOBAL_BUS: Lazy<EventBus<Any>> = Lazy.new(|| EventBus.new())

fn global_bus() -> EventBus<Any> {
    GLOBAL_BUS.get()
}

fn global_emit(event: String, data: Any) -> Int {
    global_bus().emit(event, data)
}

fn global_on(event: String, handler: fn(Event<Any>)) -> Subscription {
    global_bus().on(event, handler)
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Create a new event bus
fn event_bus<T: Clone>() -> EventBus<T> {
    EventBus.new()
}

/// Create an event bus with configuration
fn event_bus_with_config<T: Clone>(config: EventBusConfig) -> EventBus<T> {
    EventBus.with_config(config)
}

/// Create a typed event bus
fn typed_bus() -> TypedEventBus {
    TypedEventBus.new()
}

/// Create a scoped event bus
fn scoped<T: Clone>(bus: EventBus<T>) -> ScopedEventBus<T> {
    ScopedEventBus.new(bus)
}

// =============================================================================
// Tests
// =============================================================================

test "basic emit and subscribe" {
    let bus = EventBus::<Int>.new()
    var received = 0
    
    bus.on("test", |evt| { received = evt.data })
    bus.emit("test", 42)
    
    assert_eq(received, 42)?
}

test "once subscription" {
    let bus = EventBus::<Int>.new()
    var count = 0
    
    bus.once("test", |_| { count += 1 })
    bus.emit("test", 1)
    bus.emit("test", 2)
    
    assert_eq(count, 1)?
}

test "unsubscribe" {
    let bus = EventBus::<Int>.new()
    var count = 0
    
    let sub = bus.on("test", |_| { count += 1 })
    bus.emit("test", 1)
    sub.unsubscribe()
    bus.emit("test", 2)
    
    assert_eq(count, 1)?
}

test "wildcard listener" {
    let bus = EventBus::<String>.new()
    var events = []
    
    bus.on("*", |evt| { events.push(evt.name.clone()) })
    bus.emit("foo", "a")
    bus.emit("bar", "b")
    
    assert_eq(events, ["foo", "bar"])?
}

test "pattern wildcard" {
    let bus = EventBus::<String>.new()
    var received = []
    
    bus.on("user.*", |evt| { received.push(evt.name.clone()) })
    bus.emit("user.created", "john")
    bus.emit("user.updated", "jane")
    bus.emit("order.created", "order1")
    
    assert_eq(received, ["user.created", "user.updated"])?
}

test "pause and resume" {
    let config = EventBusConfig.with_buffer(10)
    let bus = EventBus::<Int>.with_config(config)
    var received = []
    
    bus.on("test", |evt| { received.push(evt.data) })
    
    bus.pause()
    bus.emit("test", 1)
    bus.emit("test", 2)
    
    assert_eq(received, [])?
    
    bus.resume()
    assert_eq(received, [1, 2])?
}

test "interceptor" {
    let bus = EventBus::<Int>.new()
    var received = []
    
    bus.add_interceptor(|evt| {
        if evt.data > 0 {
            Some(Event.new(evt.name, evt.data * 2, "interceptor"))
        } else {
            None
        }
    })
    
    bus.on("test", |evt| { received.push(evt.data) })
    
    bus.emit("test", 5)
    bus.emit("test", -1)
    
    assert_eq(received, [10])?
}

test "history" {
    let config = EventBusConfig.with_history(10)
    let bus = EventBus::<String>.with_config(config)
    
    bus.on("test", |_| {})
    bus.emit("test", "a")
    bus.emit("test", "b")
    
    let history = bus.get_history()
    assert_eq(history.len(), 2)?
    assert_eq(history[0].event.data, "a")?
    assert_eq(history[1].event.data, "b")?
}

test "stats" {
    let bus = EventBus::<Int>.new()
    
    bus.on("test", |_| {})
    bus.on("test", |_| {})
    bus.emit("test", 1)
    bus.emit("test", 2)
    
    let stats = bus.get_stats()
    assert_eq(stats.total_events_published, 2)?
    assert_eq(stats.total_listeners, 2)?
}

test "buffered events" {
    let config = EventBusConfig.with_buffer(10)
    let bus = EventBus::<Int>.with_config(config)
    
    // Emit before any listeners
    bus.emit("test", 1)
    bus.emit("test", 2)
    
    var received = []
    bus.on("test", |evt| { received.push(evt.data) })
    
    // Should receive buffered events
    assert_eq(received, [1, 2])?
}

test "scoped bus cleanup" {
    let bus = EventBus::<Int>.new()
    
    {
        let scoped = ScopedEventBus.new(bus.clone())
        scoped.on("test", |_| {})
        assert_eq(bus.listener_count("test"), 1)?
    }
    // After scope exit, listener should be removed
    assert_eq(bus.listener_count("test"), 0)?
}
