// =============================================================================
// Vibee OS â€” Notification Sound Module
// Audio feedback for notifications with customization support
// =============================================================================

use audio.{AudioBuffer, AudioFormat, Sample}
use datetime.{DateTime, Duration}

// =============================================================================
// Sound Types & Enums
// =============================================================================

enum SoundType {
    System,
    Custom,
    Ringtone,
    Alert,
    Haptic,
    Silent
    
    fn is_audible() -> Bool {
        match self {
            .Silent | .Haptic => false,
            _ => true
        }
    }
}

enum SystemSound {
    Default,
    Tri_tone,
    Chime,
    Glass,
    Horn,
    Bell,
    Electronic,
    Anticipate,
    Bloom,
    Calypso,
    Choo_Choo,
    Descent,
    Fanfare,
    Ladder,
    Minuet,
    News_Flash,
    Noir,
    Sherwood_Forest,
    Spell,
    Suspense,
    Telegraph,
    Tiptoes,
    Typewriters,
    Update
    
    fn filename() -> String {
        match self {
            .Default => "default.caf",
            .Tri_tone => "tri-tone.caf",
            .Chime => "chime.caf",
            .Glass => "glass.caf",
            .Horn => "horn.caf",
            .Bell => "bell.caf",
            .Electronic => "electronic.caf",
            .Anticipate => "anticipate.caf",
            .Bloom => "bloom.caf",
            .Calypso => "calypso.caf",
            .Choo_Choo => "choo-choo.caf",
            .Descent => "descent.caf",
            .Fanfare => "fanfare.caf",
            .Ladder => "ladder.caf",
            .Minuet => "minuet.caf",
            .News_Flash => "news-flash.caf",
            .Noir => "noir.caf",
            .Sherwood_Forest => "sherwood-forest.caf",
            .Spell => "spell.caf",
            .Suspense => "suspense.caf",
            .Telegraph => "telegraph.caf",
            .Tiptoes => "tiptoes.caf",
            .Typewriters => "typewriters.caf",
            .Update => "update.caf"
        }
    }
    
    fn duration() -> Duration {
        match self {
            .Default | .Tri_tone => Duration.from_millis(1000),
            .Chime | .Glass | .Bell => Duration.from_millis(800),
            .Fanfare => Duration.from_millis(2000),
            _ => Duration.from_millis(1500)
        }
    }
}

enum HapticPattern {
    Light,
    Medium,
    Heavy,
    Soft,
    Rigid,
    Success,
    Warning,
    Error,
    Selection,
    ImpactLight,
    ImpactMedium,
    ImpactHeavy,
    Custom([HapticEvent])
    
    fn intensity() -> Float {
        match self {
            .Light | .Soft | .Selection => 0.3,
            .Medium => 0.5,
            .Heavy | .Rigid => 0.8,
            .Success => 0.6,
            .Warning => 0.7,
            .Error => 0.9,
            .ImpactLight => 0.4,
            .ImpactMedium => 0.6,
            .ImpactHeavy => 0.9,
            .Custom(_) => 0.5
        }
    }
}

struct HapticEvent {
    intensity: Float
    sharpness: Float
    duration: Duration
    delay: Duration
}

impl HapticEvent {
    fn new(intensity: Float, duration: Duration) -> Self {
        HapticEvent {
            intensity: intensity,
            sharpness: 0.5,
            duration: duration,
            delay: Duration.zero()
        }
    }
    
    fn sharpness(s: Float) -> Self { self.sharpness = s; self }
    fn delay(d: Duration) -> Self { self.delay = d; self }
}

// =============================================================================
// Notification Sound
// =============================================================================

struct NotificationSound {
    id: String
    name: String
    sound_type: SoundType
    source: SoundSource
    volume: Float
    loop_count: Int
    fade_in: Duration
    fade_out: Duration
    haptic: Option<HapticPattern>
    critical: Bool
    interruption_level: InterruptionLevel
}

enum SoundSource {
    System(SystemSound),
    File(String),
    Url(String),
    Bundle(String),
    Generated(AudioBuffer),
    None
}

enum InterruptionLevel {
    Passive,
    Active,
    TimeSensitive,
    Critical
}

impl NotificationSound {
    fn new(name: String) -> Self {
        NotificationSound {
            id: UUID.v4(),
            name: name,
            sound_type: SoundType.System,
            source: SoundSource.System(SystemSound.Default),
            volume: 1.0,
            loop_count: 1,
            fade_in: Duration.zero(),
            fade_out: Duration.zero(),
            haptic: None,
            critical: false,
            interruption_level: InterruptionLevel.Active
        }
    }
    
    fn default() -> Self {
        NotificationSound.new("Default")
    }
    
    fn silent() -> Self {
        let mut sound = NotificationSound.new("Silent");
        sound.sound_type = SoundType.Silent;
        sound.source = SoundSource.None;
        sound
    }
    
    fn system(sys_sound: SystemSound) -> Self {
        let mut sound = NotificationSound.new(format!("System: {:?}", sys_sound));
        sound.source = SoundSource.System(sys_sound);
        sound
    }
    
    fn from_file(path: String) -> Self {
        let mut sound = NotificationSound.new("Custom Sound");
        sound.sound_type = SoundType.Custom;
        sound.source = SoundSource.File(path);
        sound
    }
    
    fn from_url(url: String) -> Self {
        let mut sound = NotificationSound.new("Remote Sound");
        sound.sound_type = SoundType.Custom;
        sound.source = SoundSource.Url(url);
        sound
    }
    
    fn from_bundle(resource: String) -> Self {
        let mut sound = NotificationSound.new("Bundle Sound");
        sound.sound_type = SoundType.Custom;
        sound.source = SoundSource.Bundle(resource);
        sound
    }
    
    fn volume(v: Float) -> Self { self.volume = v.clamp(0.0, 1.0); self }
    fn loop_count(count: Int) -> Self { self.loop_count = count; self }
    fn loop_forever() -> Self { self.loop_count = -1; self }
    fn fade_in(duration: Duration) -> Self { self.fade_in = duration; self }
    fn fade_out(duration: Duration) -> Self { self.fade_out = duration; self }
    fn haptic(pattern: HapticPattern) -> Self { self.haptic = Some(pattern); self }
    fn critical() -> Self { self.critical = true; self.interruption_level = InterruptionLevel.Critical; self }
    fn interruption_level(level: InterruptionLevel) -> Self { self.interruption_level = level; self }
    
    fn with_haptic() -> Self {
        self.haptic = Some(HapticPattern.Medium); self
    }
    
    fn is_silent() -> Bool {
        match self.sound_type {
            SoundType.Silent => true,
            _ => false
        }
    }
    
    fn has_haptic() -> Bool { self.haptic.is_some() }
}

// =============================================================================
// Sound Player Actor
// =============================================================================

actor SoundPlayer {
    state current_sound: Option<PlayingSound>
    state queue: [NotificationSound]
    state settings: SoundSettings
    state muted: Bool
    state haptic_enabled: Bool
    state listeners: [Box<dyn SoundEventListener>]
    
    fn new() -> Self {
        SoundPlayer {
            current_sound: None,
            queue: [],
            settings: SoundSettings.default(),
            muted: false,
            haptic_enabled: true,
            listeners: []
        }
    }
    
    fn with_settings(settings: SoundSettings) -> Self {
        let mut player = SoundPlayer.new();
        player.settings = settings;
        player
    }
    
    on register_listener(listener: Box<dyn SoundEventListener>) {
        self.listeners.push(listener)
    }
    
    on play(sound: NotificationSound) -> Result<String, SoundError> {
        // Check if muted
        if self.muted && !sound.critical {
            return Err(SoundError.Muted)
        }
        
        // Check quiet hours
        if self.settings.is_quiet_time() && !sound.critical {
            // Only play haptic if enabled
            if sound.has_haptic() && self.haptic_enabled {
                self.play_haptic(sound.haptic.unwrap());
            }
            return Err(SoundError.QuietHours)
        }
        
        // Check Do Not Disturb
        if self.settings.do_not_disturb && sound.interruption_level != InterruptionLevel.Critical {
            return Err(SoundError.DoNotDisturb)
        }
        
        let play_id = UUID.v4();
        let adjusted_volume = sound.volume * self.settings.master_volume;
        
        let playing = PlayingSound {
            id: play_id.clone(),
            sound: sound.clone(),
            started_at: DateTime.now(),
            volume: adjusted_volume,
            loops_remaining: sound.loop_count
        };
        
        // Stop current sound if playing
        if self.current_sound.is_some() {
            self.stop_current();
        }
        
        self.current_sound = Some(playing);
        
        // Play haptic feedback
        if sound.has_haptic() && self.haptic_enabled {
            self.play_haptic(sound.haptic.unwrap());
        }
        
        // Notify listeners
        self.notify_listeners(SoundEvent.Started(play_id.clone(), sound.clone()));
        
        // Start actual playback
        self.start_playback(sound, adjusted_volume);
        
        Ok(play_id)
    }
    
    on play_queued(sound: NotificationSound) {
        if self.current_sound.is_some() {
            self.queue.push(sound);
        } else {
            let _ = self.play(sound);
        }
    }
    
    on stop() {
        self.stop_current();
        self.queue.clear();
    }
    
    on stop_current() {
        if let Some(playing) = self.current_sound.take() {
            self.notify_listeners(SoundEvent.Stopped(playing.id));
            native_audio_stop();
        }
        
        // Play next in queue
        if let Some(next) = self.queue.pop_front() {
            let _ = self.play(next);
        }
    }
    
    on mute() { self.muted = true }
    on unmute() { self.muted = false }
    on toggle_mute() { self.muted = !self.muted }
    
    on enable_haptic() { self.haptic_enabled = true }
    on disable_haptic() { self.haptic_enabled = false }
    
    on set_volume(volume: Float) {
        self.settings.master_volume = volume.clamp(0.0, 1.0);
    }
    
    fn is_playing() -> Bool { self.current_sound.is_some() }
    fn is_muted() -> Bool { self.muted }
    fn current_volume() -> Float { self.settings.master_volume }
    
    fn play_haptic(pattern: HapticPattern) {
        match pattern {
            HapticPattern.Custom(events) => {
                for event in events {
                    native_haptic_play(event.intensity, event.sharpness, event.duration);
                }
            },
            _ => {
                native_haptic_play(pattern.intensity(), 0.5, Duration.from_millis(100));
            }
        }
    }
    
    fn start_playback(sound: NotificationSound, volume: Float) {
        match sound.source {
            SoundSource.System(sys) => native_play_system_sound(sys.filename(), volume),
            SoundSource.File(path) => native_play_file(path, volume),
            SoundSource.Url(url) => native_play_url(url, volume),
            SoundSource.Bundle(res) => native_play_bundle(res, volume),
            SoundSource.Generated(buffer) => native_play_buffer(buffer, volume),
            SoundSource.None => {}
        }
    }
    
    fn notify_listeners(event: SoundEvent) {
        for listener in self.listeners.iter() {
            listener.on_sound_event(event.clone());
        }
    }
}

struct PlayingSound {
    id: String
    sound: NotificationSound
    started_at: DateTime
    volume: Float
    loops_remaining: Int
}

// =============================================================================
// Sound Events & Listener
// =============================================================================

enum SoundEvent {
    Started(String, NotificationSound),
    Stopped(String),
    Completed(String),
    Looped(String, Int),
    Error(String, SoundError)
}

trait SoundEventListener {
    fn on_sound_event(event: SoundEvent)
}

// =============================================================================
// Sound Settings
// =============================================================================

struct SoundSettings {
    master_volume: Float
    notification_volume: Float
    ringtone_volume: Float
    alert_volume: Float
    do_not_disturb: Bool
    quiet_hours: Option<QuietHours>
    vibrate_on_silent: Bool
    haptic_feedback: Bool
}

impl SoundSettings {
    fn default() -> Self {
        SoundSettings {
            master_volume: 1.0,
            notification_volume: 1.0,
            ringtone_volume: 1.0,
            alert_volume: 1.0,
            do_not_disturb: false,
            quiet_hours: None,
            vibrate_on_silent: true,
            haptic_feedback: true
        }
    }
    
    fn master_volume(v: Float) -> Self { self.master_volume = v.clamp(0.0, 1.0); self }
    fn notification_volume(v: Float) -> Self { self.notification_volume = v.clamp(0.0, 1.0); self }
    fn ringtone_volume(v: Float) -> Self { self.ringtone_volume = v.clamp(0.0, 1.0); self }
    fn alert_volume(v: Float) -> Self { self.alert_volume = v.clamp(0.0, 1.0); self }
    fn do_not_disturb(enabled: Bool) -> Self { self.do_not_disturb = enabled; self }
    fn vibrate_on_silent(enabled: Bool) -> Self { self.vibrate_on_silent = enabled; self }
    fn haptic_feedback(enabled: Bool) -> Self { self.haptic_feedback = enabled; self }
    
    fn enable_quiet_hours(start: Int, end: Int) -> Self {
        self.quiet_hours = Some(QuietHours { start_hour: start, end_hour: end });
        self
    }
    
    fn is_quiet_time() -> Bool {
        match self.quiet_hours {
            Some(qh) => qh.is_active(),
            None => false
        }
    }
}

struct QuietHours {
    start_hour: Int
    end_hour: Int
}

impl QuietHours {
    fn is_active() -> Bool {
        let current_hour = DateTime.now().hour();
        if self.start_hour <= self.end_hour {
            current_hour >= self.start_hour && current_hour < self.end_hour
        } else {
            current_hour >= self.start_hour || current_hour < self.end_hour
        }
    }
}

// =============================================================================
// Sound Library
// =============================================================================

actor SoundLibrary {
    state sounds: Map<String, NotificationSound>
    state categories: Map<String, [String]>
    
    fn new() -> Self {
        let mut lib = SoundLibrary {
            sounds: Map.empty(),
            categories: Map.empty()
        };
        lib.load_system_sounds();
        lib
    }
    
    fn load_system_sounds() {
        // Load all system sounds
        for sys_sound in SystemSound.all() {
            let sound = NotificationSound.system(sys_sound);
            self.sounds.set(sound.id.clone(), sound.clone());
            self.add_to_category("system", sound.id);
        }
    }
    
    on register(sound: NotificationSound) -> String {
        let id = sound.id.clone();
        self.sounds.set(id.clone(), sound);
        id
    }
    
    on register_in_category(sound: NotificationSound, category: String) -> String {
        let id = self.register(sound);
        self.add_to_category(category, id.clone());
        id
    }
    
    fn add_to_category(category: String, sound_id: String) {
        let mut cat_sounds = self.categories.get(category.clone()).unwrap_or([]);
        cat_sounds.push(sound_id);
        self.categories.set(category, cat_sounds);
    }
    
    fn get(id: String) -> Option<NotificationSound> {
        self.sounds.get(id)
    }
    
    fn get_by_name(name: String) -> Option<NotificationSound> {
        self.sounds.values().iter().find(|s| s.name == name)
    }
    
    fn get_category(category: String) -> [NotificationSound] {
        self.categories.get(category).unwrap_or([])
            .iter()
            .filter_map(|id| self.sounds.get(id.clone()))
            .collect()
    }
    
    fn all_sounds() -> [NotificationSound] {
        self.sounds.values().collect()
    }
    
    fn system_sounds() -> [NotificationSound] {
        self.get_category("system")
    }
    
    fn custom_sounds() -> [NotificationSound] {
        self.sounds.values()
            .iter()
            .filter(|s| s.sound_type == SoundType.Custom)
            .collect()
    }
    
    on remove(id: String) -> Option<NotificationSound> {
        let sound = self.sounds.remove(id.clone());
        for (_, cat_sounds) in self.categories.iter_mut() {
            cat_sounds.retain(|sid| *sid != id);
        }
        sound
    }
}

// =============================================================================
// Sound Generator
// =============================================================================

struct SoundGenerator;

impl SoundGenerator {
    fn sine_wave(frequency: Float, duration: Duration, sample_rate: Int) -> AudioBuffer {
        let num_samples = (duration.as_secs_f64() * sample_rate as Float) as Int;
        let mut samples: [Sample] = [];
        
        for i in 0..num_samples {
            let t = i as Float / sample_rate as Float;
            let value = (2.0 * 3.14159 * frequency * t).sin();
            samples.push(Sample.new(value));
        }
        
        AudioBuffer.from_mono(samples, sample_rate)
    }
    
    fn square_wave(frequency: Float, duration: Duration, sample_rate: Int) -> AudioBuffer {
        let num_samples = (duration.as_secs_f64() * sample_rate as Float) as Int;
        let mut samples: [Sample] = [];
        let period = sample_rate as Float / frequency;
        
        for i in 0..num_samples {
            let value = if (i as Float % period) < (period / 2.0) { 1.0 } else { -1.0 };
            samples.push(Sample.new(value));
        }
        
        AudioBuffer.from_mono(samples, sample_rate)
    }
    
    fn beep(frequency: Float, duration: Duration) -> NotificationSound {
        let buffer = SoundGenerator.sine_wave(frequency, duration, 44100);
        let mut sound = NotificationSound.new("Generated Beep");
        sound.source = SoundSource.Generated(buffer);
        sound
    }
    
    fn alert_tone() -> NotificationSound {
        // Two-tone alert
        let tone1 = SoundGenerator.sine_wave(880.0, Duration.from_millis(100), 44100);
        let tone2 = SoundGenerator.sine_wave(1320.0, Duration.from_millis(100), 44100);
        let buffer = tone1.append(tone2);
        
        let mut sound = NotificationSound.new("Alert Tone");
        sound.source = SoundSource.Generated(buffer);
        sound
    }
    
    fn success_tone() -> NotificationSound {
        // Rising two-tone
        let tone1 = SoundGenerator.sine_wave(523.25, Duration.from_millis(100), 44100);
        let tone2 = SoundGenerator.sine_wave(659.25, Duration.from_millis(150), 44100);
        let buffer = tone1.append(tone2);
        
        let mut sound = NotificationSound.new("Success Tone");
        sound.source = SoundSource.Generated(buffer);
        sound.haptic(HapticPattern.Success);
        sound
    }
    
    fn error_tone() -> NotificationSound {
        // Descending tone
        let tone1 = SoundGenerator.sine_wave(440.0, Duration.from_millis(100), 44100);
        let tone2 = SoundGenerator.sine_wave(349.23, Duration.from_millis(200), 44100);
        let buffer = tone1.append(tone2);
        
        let mut sound = NotificationSound.new("Error Tone");
        sound.source = SoundSource.Generated(buffer);
        sound.haptic(HapticPattern.Error);
        sound
    }
}

// =============================================================================
// Errors
// =============================================================================

enum SoundError {
    NotFound(String),
    InvalidFormat,
    PlaybackFailed(String),
    Muted,
    QuietHours,
    DoNotDisturb,
    PermissionDenied,
    ResourceNotAvailable,
    Unknown(String)
}

impl SoundError {
    fn is_recoverable() -> Bool {
        match self {
            .Muted | .QuietHours | .DoNotDisturb => true,
            _ => false
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "notification sound creation" {
    let sound = NotificationSound.default();
    assert_eq(sound.volume, 1.0)?
    assert(!sound.is_silent())?
}

test "silent sound" {
    let sound = NotificationSound.silent();
    assert(sound.is_silent())?
}

test "system sound" {
    let sound = NotificationSound.system(SystemSound.Chime);
    assert_eq(sound.sound_type, SoundType.System)?
}

test "sound with haptic" {
    let sound = NotificationSound.default()
        .haptic(HapticPattern.Success);
    
    assert(sound.has_haptic())?
}

test "sound volume clamping" {
    let sound = NotificationSound.default().volume(1.5);
    assert_eq(sound.volume, 1.0)?
    
    let sound2 = NotificationSound.default().volume(-0.5);
    assert_eq(sound2.volume, 0.0)?
}

test "sound player mute" {
    let player = SoundPlayer.new();
    
    assert(!player.is_muted())?
    player.mute();
    assert(player.is_muted())?
    player.unmute();
    assert(!player.is_muted())?
}

test "sound settings" {
    let settings = SoundSettings.default()
        .master_volume(0.8)
        .enable_quiet_hours(22, 7);
    
    assert_eq(settings.master_volume, 0.8)?
    assert(settings.quiet_hours.is_some())?
}

test "sound generator beep" {
    let beep = SoundGenerator.beep(440.0, Duration.from_millis(500));
    assert_eq(beep.name, "Generated Beep")?
}

test "haptic pattern intensity" {
    assert_eq(HapticPattern.Light.intensity(), 0.3)?
    assert_eq(HapticPattern.Heavy.intensity(), 0.8)?
    assert_eq(HapticPattern.Error.intensity(), 0.9)?
}

test "system sound filenames" {
    assert_eq(SystemSound.Default.filename(), "default.caf")?
    assert_eq(SystemSound.Chime.filename(), "chime.caf")?
}
