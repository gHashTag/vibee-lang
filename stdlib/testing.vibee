// =============================================================================
// Vibee OS — Testing Module
// Test framework with assertions, fixtures, and runners
// =============================================================================

// -----------------------------------------------------------------------------
// Test Runner
// -----------------------------------------------------------------------------

/// Test runner
actor TestRunner {
    state tests: [TestCase]
    state suites: [TestSuite]
    state config: TestConfig
    state results: TestResults
    state reporters: [Reporter]
    state before_all: [() -> ()]
    state after_all: [() -> ()]
    
    fn new() -> Self {
        TestRunner {
            tests: [],
            suites: [],
            config: TestConfig.default(),
            results: TestResults.new(),
            reporters: [ConsoleReporter.new()],
            before_all: [],
            after_all: []
        }
    }
    
    on config(c: TestConfig) -> Self { self.config = c; self }
    on reporter(r: Reporter) -> Self { self.reporters.append(r); self }
    on before_all(f: () -> ()) -> Self { self.before_all.append(f); self }
    on after_all(f: () -> ()) -> Self { self.after_all.append(f); self }
    
    /// Add test case
    on test(name: String, f: () -> Result<(), TestError>) -> Self {
        self.tests.append(TestCase { name: name, func: f, tags: [], timeout: None, skip: false })
        self
    }
    
    /// Add test suite
    on suite(s: TestSuite) -> Self {
        self.suites.append(s)
        self
    }
    
    /// Discover tests from module
    on discover(module: Module) -> Self {
        let tests = @native("test_discover", module)
        self.tests.extend(tests)
        self
    }
    
    /// Run all tests
    on run() -> TestResults {
        for reporter in self.reporters { reporter.on_start(self.total_count()) }
        for hook in self.before_all { hook() }
        
        // Run standalone tests
        for test in self.tests {
            if self.should_run(test) { self.run_test(test) }
        }
        
        // Run suites
        for suite in self.suites { self.run_suite(suite) }
        
        for hook in self.after_all { hook() }
        for reporter in self.reporters { reporter.on_finish(self.results) }
        
        self.results
    }
    
    fn should_run(test: TestCase) -> Bool {
        if test.skip { return false }
        if let filter = self.config.filter {
            if !test.name.contains(filter) { return false }
        }
        if !self.config.tags.is_empty() {
            if !test.tags.any(|t| self.config.tags.contains(t)) { return false }
        }
        true
    }
    
    fn run_test(test: TestCase) {
        for reporter in self.reporters { reporter.on_test_start(test.name) }
        
        let start = Instant.now()
        let timeout = test.timeout.unwrap_or(self.config.timeout)
        
        let result = if self.config.parallel {
            self.run_with_timeout(test.func, timeout)
        } else {
            self.run_with_timeout(test.func, timeout)
        }
        
        let duration = start.elapsed()
        
        let outcome = match result {
            Ok(()) => TestOutcome.Passed
            Err(TestError.Assertion(msg)) => TestOutcome.Failed(msg)
            Err(TestError.Timeout) => TestOutcome.Failed("Test timed out")
            Err(TestError.Panic(msg)) => TestOutcome.Failed("Panic: \(msg)")
            Err(e) => TestOutcome.Failed(e.message())
        }
        
        let test_result = TestResult { name: test.name, outcome: outcome, duration: duration }
        self.results.add(test_result)
        
        for reporter in self.reporters { reporter.on_test_finish(test_result) }
    }
    
    fn run_suite(suite: TestSuite) {
        for reporter in self.reporters { reporter.on_suite_start(suite.name) }
        
        for hook in suite.before_all { hook() }
        
        for test in suite.tests {
            if self.should_run(test) {
                for hook in suite.before_each { hook() }
                self.run_test(test)
                for hook in suite.after_each { hook() }
            }
        }
        
        for hook in suite.after_all { hook() }
        for reporter in self.reporters { reporter.on_suite_finish(suite.name) }
    }
    
    fn run_with_timeout<T>(f: () -> Result<T, TestError>, timeout: Duration) -> Result<T, TestError> {
        @native("test_run_with_timeout", f, timeout)
    }
    
    fn total_count() -> Int {
        self.tests.len() + self.suites.map(|s| s.tests.len()).sum()
    }
}

/// Test configuration
struct TestConfig {
    timeout: Duration
    parallel: Bool
    fail_fast: Bool
    filter: Option<String>
    tags: [String]
    verbose: Bool
    
    fn default() -> Self {
        TestConfig {
            timeout: Duration.seconds(30),
            parallel: false,
            fail_fast: false,
            filter: None,
            tags: [],
            verbose: false
        }
    }
}

/// Test case
struct TestCase {
    name: String
    func: () -> Result<(), TestError>
    tags: [String]
    timeout: Option<Duration>
    skip: Bool
    
    fn tag(t: String) -> Self { self.tags.append(t); self }
    fn timeout(d: Duration) -> Self { self.timeout = Some(d); self }
    fn skip() -> Self { self.skip = true; self }
}

/// Test suite
actor TestSuite {
    state name: String
    state tests: [TestCase]
    state before_all: [() -> ()]
    state after_all: [() -> ()]
    state before_each: [() -> ()]
    state after_each: [() -> ()]
    
    fn new(name: String) -> Self {
        TestSuite { name: name, tests: [], before_all: [], after_all: [], before_each: [], after_each: [] }
    }
    
    on test(name: String, f: () -> Result<(), TestError>) -> Self {
        self.tests.append(TestCase { name: "\(self.name)::\(name)", func: f, tags: [], timeout: None, skip: false })
        self
    }
    
    on before_all(f: () -> ()) -> Self { self.before_all.append(f); self }
    on after_all(f: () -> ()) -> Self { self.after_all.append(f); self }
    on before_each(f: () -> ()) -> Self { self.before_each.append(f); self }
    on after_each(f: () -> ()) -> Self { self.after_each.append(f); self }
}

// -----------------------------------------------------------------------------
// Test Results
// -----------------------------------------------------------------------------

actor TestResults {
    state results: [TestResult]
    state start_time: Instant
    state end_time: Option<Instant>
    
    fn new() -> Self { TestResults { results: [], start_time: Instant.now() } }
    
    on add(result: TestResult) { self.results.append(result) }
    on finish() { self.end_time = Some(Instant.now()) }
    
    fn passed() -> Int { self.results.filter(|r| r.outcome.is_passed()).len() }
    fn failed() -> Int { self.results.filter(|r| r.outcome.is_failed()).len() }
    fn skipped() -> Int { self.results.filter(|r| r.outcome.is_skipped()).len() }
    fn total() -> Int { self.results.len() }
    fn duration() -> Duration { self.end_time.map(|e| e - self.start_time).unwrap_or(Duration.zero()) }
    fn all_passed() -> Bool { self.failed() == 0 }
    fn failures() -> [TestResult] { self.results.filter(|r| r.outcome.is_failed()) }
}

struct TestResult {
    name: String
    outcome: TestOutcome
    duration: Duration
}

enum TestOutcome {
    Passed
    Failed(String)
    Skipped(String)
    
    fn is_passed() -> Bool { match self { .Passed => true, _ => false } }
    fn is_failed() -> Bool { match self { .Failed(_) => true, _ => false } }
    fn is_skipped() -> Bool { match self { .Skipped(_) => true, _ => false } }
}

// -----------------------------------------------------------------------------
// Assertions
// -----------------------------------------------------------------------------

/// Assert condition is true
fn assert(condition: Bool, message: String = "Assertion failed") -> Result<(), TestError> {
    if condition { Ok(()) } else { Err(TestError.Assertion(message)) }
}

/// Assert values are equal
fn assert_eq<T: Eq + Debug>(actual: T, expected: T) -> Result<(), TestError> {
    if actual == expected { Ok(()) }
    else { Err(TestError.Assertion("Expected \(expected.debug()), got \(actual.debug())")) }
}

/// Assert values are not equal
fn assert_ne<T: Eq + Debug>(actual: T, expected: T) -> Result<(), TestError> {
    if actual != expected { Ok(()) }
    else { Err(TestError.Assertion("Expected values to differ, both are \(actual.debug())")) }
}

/// Assert value is true
fn assert_true(value: Bool) -> Result<(), TestError> {
    assert(value, "Expected true, got false")
}

/// Assert value is false
fn assert_false(value: Bool) -> Result<(), TestError> {
    assert(!value, "Expected false, got true")
}

/// Assert option is Some
fn assert_some<T>(opt: Option<T>) -> Result<T, TestError> {
    opt.ok_or(TestError.Assertion("Expected Some, got None"))
}

/// Assert option is None
fn assert_none<T: Debug>(opt: Option<T>) -> Result<(), TestError> {
    match opt {
        None => Ok(())
        Some(v) => Err(TestError.Assertion("Expected None, got Some(\(v.debug()))"))
    }
}

/// Assert result is Ok
fn assert_ok<T, E: Debug>(result: Result<T, E>) -> Result<T, TestError> {
    result.map_err(|e| TestError.Assertion("Expected Ok, got Err(\(e.debug()))"))
}

/// Assert result is Err
fn assert_err<T: Debug, E>(result: Result<T, E>) -> Result<E, TestError> {
    match result {
        Err(e) => Ok(e)
        Ok(v) => Err(TestError.Assertion("Expected Err, got Ok(\(v.debug()))"))
    }
}

/// Assert value is in range
fn assert_in_range<T: Ord + Debug>(value: T, min: T, max: T) -> Result<(), TestError> {
    if value >= min && value <= max { Ok(()) }
    else { Err(TestError.Assertion("\(value.debug()) not in range [\(min.debug()), \(max.debug())]")) }
}

/// Assert string contains substring
fn assert_contains(haystack: String, needle: String) -> Result<(), TestError> {
    if haystack.contains(needle) { Ok(()) }
    else { Err(TestError.Assertion("'\(haystack)' does not contain '\(needle)'")) }
}

/// Assert string starts with prefix
fn assert_starts_with(s: String, prefix: String) -> Result<(), TestError> {
    if s.starts_with(prefix) { Ok(()) }
    else { Err(TestError.Assertion("'\(s)' does not start with '\(prefix)'")) }
}

/// Assert collection is empty
fn assert_empty<T>(collection: [T]) -> Result<(), TestError> {
    if collection.is_empty() { Ok(()) }
    else { Err(TestError.Assertion("Expected empty collection, got \(collection.len()) elements")) }
}

/// Assert collection has length
fn assert_len<T>(collection: [T], expected: Int) -> Result<(), TestError> {
    if collection.len() == expected { Ok(()) }
    else { Err(TestError.Assertion("Expected length \(expected), got \(collection.len())")) }
}

/// Assert floats are approximately equal
fn assert_approx(actual: Float, expected: Float, epsilon: Float = 0.0001) -> Result<(), TestError> {
    if (actual - expected).abs() < epsilon { Ok(()) }
    else { Err(TestError.Assertion("Expected ~\(expected), got \(actual) (epsilon: \(epsilon))")) }
}

/// Assert function throws
fn assert_throws<T>(f: () -> T) -> Result<(), TestError> {
    match @native("test_catch_panic", f) {
        Some(_) => Ok(())
        None => Err(TestError.Assertion("Expected function to throw"))
    }
}

/// Assert function throws specific error
fn assert_throws_with<T, E: Eq>(f: () -> Result<T, E>, expected: E) -> Result<(), TestError> {
    match f() {
        Err(e) if e == expected => Ok(())
        Err(e) => Err(TestError.Assertion("Wrong error thrown"))
        Ok(_) => Err(TestError.Assertion("Expected function to throw"))
    }
}

// -----------------------------------------------------------------------------
// Matchers (Fluent API)
// -----------------------------------------------------------------------------

/// Expectation builder
struct Expect<T> {
    value: T
    negated: Bool
    
    fn that<T>(value: T) -> Expect<T> { Expect { value: value, negated: false } }
    fn not() -> Self { self.negated = !self.negated; self }
}

impl<T: Eq + Debug> Expect<T> {
    fn equals(expected: T) -> Result<(), TestError> {
        let matches = self.value == expected
        if matches != self.negated { Ok(()) }
        else if self.negated { Err(TestError.Assertion("Expected not equal to \(expected.debug())")) }
        else { Err(TestError.Assertion("Expected \(expected.debug()), got \(self.value.debug())")) }
    }
    
    fn is_one_of(options: [T]) -> Result<(), TestError> {
        let matches = options.contains(self.value)
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion("\(self.value.debug()) not in expected values")) }
    }
}

impl Expect<Bool> {
    fn is_true() -> Result<(), TestError> { self.equals(true) }
    fn is_false() -> Result<(), TestError> { self.equals(false) }
}

impl<T> Expect<Option<T>> {
    fn is_some() -> Result<(), TestError> {
        let matches = self.value.is_some()
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion(if self.negated { "Expected None" } else { "Expected Some" })) }
    }
    fn is_none() -> Result<(), TestError> { self.not().is_some() }
}

impl Expect<String> {
    fn contains(s: String) -> Result<(), TestError> {
        let matches = self.value.contains(s)
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion("String \(if self.negated { "contains" } else { "does not contain" }) '\(s)'")) }
    }
    fn starts_with(s: String) -> Result<(), TestError> {
        let matches = self.value.starts_with(s)
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion("String \(if self.negated { "starts" } else { "does not start" }) with '\(s)'")) }
    }
    fn matches(pattern: String) -> Result<(), TestError> {
        let regex = Regex.new(pattern)?
        let matches = regex.is_match(self.value)
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion("String \(if self.negated { "matches" } else { "does not match" }) pattern")) }
    }
}

impl<T> Expect<[T]> {
    fn is_empty() -> Result<(), TestError> {
        let matches = self.value.is_empty()
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion(if self.negated { "Expected non-empty" } else { "Expected empty" })) }
    }
    fn has_length(n: Int) -> Result<(), TestError> {
        let matches = self.value.len() == n
        if matches != self.negated { Ok(()) }
        else { Err(TestError.Assertion("Expected length \(n), got \(self.value.len())")) }
    }
}

fn expect<T>(value: T) -> Expect<T> { Expect.that(value) }

// -----------------------------------------------------------------------------
// Reporters
// -----------------------------------------------------------------------------

trait Reporter {
    fn on_start(total: Int)
    fn on_finish(results: TestResults)
    fn on_suite_start(name: String)
    fn on_suite_finish(name: String)
    fn on_test_start(name: String)
    fn on_test_finish(result: TestResult)
}

/// Console reporter
actor ConsoleReporter: Reporter {
    state verbose: Bool
    
    fn new() -> Self { ConsoleReporter { verbose: false } }
    fn verbose() -> Self { self.verbose = true; self }
    
    fn on_start(total: Int) { println("\nRunning \(total) tests...\n") }
    
    fn on_finish(results: TestResults) {
        println()
        if !results.all_passed() {
            println(red("Failures:"))
            for failure in results.failures() {
                println("  \(red("✗")) \(failure.name)")
                if let .Failed(msg) = failure.outcome { println("    \(dim(msg))") }
            }
            println()
        }
        
        let status = if results.all_passed() { green("PASSED") } else { red("FAILED") }
        println("\(status) - \(results.passed()) passed, \(results.failed()) failed, \(results.skipped()) skipped")
        println("Duration: \(results.duration().as_millis())ms")
    }
    
    fn on_suite_start(name: String) { if self.verbose { println("\n\(bold(name))") } }
    fn on_suite_finish(name: String) {}
    
    fn on_test_start(name: String) {}
    fn on_test_finish(result: TestResult) {
        let icon = match result.outcome {
            .Passed => green("✓")
            .Failed(_) => red("✗")
            .Skipped(_) => yellow("○")
        }
        let time = if result.duration.as_millis() > 100 { yellow(" (\(result.duration.as_millis())ms)") } else { "" }
        println("  \(icon) \(result.name)\(time)")
    }
}

/// JSON reporter
actor JSONReporter: Reporter {
    state results: [Map<String, Any>]
    state output_path: Option<String>
    
    fn new() -> Self { JSONReporter { results: [] } }
    fn to_file(path: String) -> Self { self.output_path = Some(path); self }
    
    fn on_start(total: Int) {}
    fn on_suite_start(name: String) {}
    fn on_suite_finish(name: String) {}
    fn on_test_start(name: String) {}
    
    fn on_test_finish(result: TestResult) {
        self.results.append(Map.from([
            ("name", result.name),
            ("status", match result.outcome { .Passed => "passed", .Failed(_) => "failed", .Skipped(_) => "skipped" }),
            ("duration_ms", result.duration.as_millis())
        ]))
    }
    
    fn on_finish(results: TestResults) {
        let json = JSON.stringify(Map.from([
            ("total", results.total()),
            ("passed", results.passed()),
            ("failed", results.failed()),
            ("duration_ms", results.duration().as_millis()),
            ("tests", self.results)
        ]))
        
        if let path = self.output_path { File.write(path, json) }
        else { println(json) }
    }
}

// -----------------------------------------------------------------------------
// Test Errors
// -----------------------------------------------------------------------------

enum TestError {
    Assertion(String)
    Timeout
    Panic(String)
    Setup(String)
    Teardown(String)
    
    fn message() -> String {
        match self {
            .Assertion(m) => m
            .Timeout => "Test timed out"
            .Panic(m) => "Panic: \(m)"
            .Setup(m) => "Setup failed: \(m)"
            .Teardown(m) => "Teardown failed: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience
// -----------------------------------------------------------------------------

/// Run tests and exit with appropriate code
fn run_and_exit(runner: TestRunner) {
    let results = runner.run()
    Process.exit(if results.all_passed() { 0 } else { 1 })
}

/// Quick test runner
fn run_tests(tests: [(() -> Result<(), TestError>, String)]) -> TestResults {
    let runner = TestRunner.new()
    for (f, name) in tests { runner.test(name, f) }
    runner.run()
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "assert_eq" {
    assert_eq(1 + 1, 2)?
    assert_eq("hello", "hello")?
}

test "assert_ne" {
    assert_ne(1, 2)?
    assert_ne("a", "b")?
}

test "expect fluent" {
    expect(42).equals(42)?
    expect("hello").contains("ell")?
    expect([1, 2, 3]).has_length(3)?
}
