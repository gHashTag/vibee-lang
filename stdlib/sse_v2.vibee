// =============================================================================
// Vibee OS â€” Server-Sent Events V2 Module
// Extended SSE implementation with advanced features
// =============================================================================

use http.{Request, Response, Headers, Client}
use stream.{Stream, Poll}

// -----------------------------------------------------------------------------
// SSE Event
// -----------------------------------------------------------------------------

struct SSEEvent {
    id: Option<String>
    event: Option<String>
    data: String
    retry: Option<Int>
    comment: Option<String>
}

impl SSEEvent {
    fn new(data: String) -> Self { SSEEvent { id: None, event: None, data: data, retry: None, comment: None } }
    fn with_id(id: String) -> Self { Self.new("").id(id) }
    fn json<T: Serialize>(data: T) -> Self { Self.new(json.encode(data)) }
    
    fn id(id: String) -> Self { self.id = Some(id); self }
    fn event(name: String) -> Self { self.event = Some(name); self }
    fn data(data: String) -> Self { self.data = data; self }
    fn retry(ms: Int) -> Self { self.retry = Some(ms); self }
    fn comment(text: String) -> Self { self.comment = Some(text); self }
    
    fn encode() -> String {
        var lines = []
        if let Some(ref c) = self.comment { lines.push(format!(": {}", c)) }
        if let Some(ref id) = self.id { lines.push(format!("id: {}", id)) }
        if let Some(ref e) = self.event { lines.push(format!("event: {}", e)) }
        if let Some(r) = self.retry { lines.push(format!("retry: {}", r)) }
        for line in self.data.lines() { lines.push(format!("data: {}", line)) }
        lines.push("")
        lines.join("\n") + "\n"
    }
    
    fn parse(text: String) -> Option<Self> {
        var event = SSEEvent { id: None, event: None, data: String.new(), retry: None, comment: None }
        var data_lines = []
        for line in text.lines() {
            if line.starts_with(":") { event.comment = Some(line[1..].trim().to_string()) }
            else if line.starts_with("id:") { event.id = Some(line[3..].trim().to_string()) }
            else if line.starts_with("event:") { event.event = Some(line[6..].trim().to_string()) }
            else if line.starts_with("data:") { data_lines.push(line[5..].trim().to_string()) }
            else if line.starts_with("retry:") { event.retry = Int.parse(line[6..].trim()).ok() }
        }
        event.data = data_lines.join("\n")
        if event.data.is_empty() && event.id.is_none() && event.event.is_none() { None } else { Some(event) }
    }
}

// -----------------------------------------------------------------------------
// SSE Client V2
// -----------------------------------------------------------------------------

actor EventSourceV2 {
    state url: String
    state state: ReadyState
    state last_event_id: String
    state reconnect_time: Duration
    state headers: Map<String, String>
    state config: SSEConfig
    state on_open: Option<fn()>
    state on_message: Option<fn(SSEEvent)>
    state on_error: Option<fn(SSEError)>
    state event_handlers: Map<String, fn(SSEEvent)>
    state buffer: String
    state retry_count: Int
}

enum ReadyState { Connecting, Open, Closed }

struct SSEConfig {
    reconnect: Bool
    max_retries: Int
    retry_delay: Duration
    max_retry_delay: Duration
    backoff_multiplier: Float
    timeout: Duration
    with_credentials: Bool
}

impl SSEConfig {
    fn default() -> Self {
        SSEConfig { reconnect: true, max_retries: 10, retry_delay: Duration.seconds(1), max_retry_delay: Duration.seconds(30), backoff_multiplier: 2.0, timeout: Duration.seconds(60), with_credentials: false }
    }
}

impl EventSourceV2 {
    fn new(url: String) -> Self { Self.with_config(url, SSEConfig.default()) }
    
    fn with_config(url: String, config: SSEConfig) -> Self {
        EventSourceV2 { url: url, state: ReadyState.Connecting, last_event_id: String.new(), reconnect_time: config.retry_delay, headers: Map.new(), config: config, on_open: None, on_message: None, on_error: None, event_handlers: Map.new(), buffer: String.new(), retry_count: 0 }
    }
    
    fn header(name: String, value: String) -> Self { self.headers.insert(name, value); self }
    fn on_open(handler: fn()) -> Self { self.on_open = Some(handler); self }
    fn on_message(handler: fn(SSEEvent)) -> Self { self.on_message = Some(handler); self }
    fn on_error(handler: fn(SSEError)) -> Self { self.on_error = Some(handler); self }
    fn on(event: String, handler: fn(SSEEvent)) -> Self { self.event_handlers.insert(event, handler); self }
    
    fn connect() -> Result<(), SSEError> {
        self.state = ReadyState.Connecting
        var req = Request.get(self.url).header("Accept", "text/event-stream").header("Cache-Control", "no-cache")
        if !self.last_event_id.is_empty() { req = req.header("Last-Event-ID", self.last_event_id) }
        for (k, v) in self.headers.iter() { req = req.header(k, v) }
        
        let response = Client.new().timeout(self.config.timeout.as_millis()).send(req)?
        if response.status.code != 200 { return Err(SSEError.HttpError(response.status.code)) }
        
        self.state = ReadyState.Open
        self.retry_count = 0
        if let Some(handler) = self.on_open { handler() }
        
        self.read_stream(response)
    }
    
    fn read_stream(response: Response) -> Result<(), SSEError> {
        // Stream reading implementation
        Ok(())
    }
    
    fn process_buffer() {
        while let Some(idx) = self.buffer.find("\n\n") {
            let event_text = self.buffer[..idx].to_string()
            self.buffer = self.buffer[(idx + 2)..].to_string()
            if let Some(event) = SSEEvent.parse(event_text) {
                if let Some(ref id) = event.id { self.last_event_id = id.clone() }
                if let Some(retry) = event.retry { self.reconnect_time = Duration.millis(retry as Int64) }
                self.dispatch_event(event)
            }
        }
    }
    
    fn dispatch_event(event: SSEEvent) {
        if let Some(ref event_type) = event.event {
            if let Some(handler) = self.event_handlers.get(event_type) { handler(event.clone()) }
        }
        if let Some(handler) = self.on_message { handler(event) }
    }
    
    fn reconnect() {
        if !self.config.reconnect || self.retry_count >= self.config.max_retries { self.state = ReadyState.Closed; return }
        self.retry_count += 1
        let delay = Duration.millis((self.reconnect_time.as_millis() as Float * self.config.backoff_multiplier.powi(self.retry_count - 1)) as Int64).min(self.config.max_retry_delay)
        @native("sleep", delay)
        self.connect()
    }
    
    fn close() { self.state = ReadyState.Closed }
    fn ready_state() -> ReadyState { self.state }
}

// -----------------------------------------------------------------------------
// SSE Server V2
// -----------------------------------------------------------------------------

actor SSEServerV2 {
    state clients: Map<Int, SSEClient>
    state channels: Map<String, [Int]>
    state next_id: Int
    state config: SSEServerConfig
    state on_connect: Option<fn(Int)>
    state on_disconnect: Option<fn(Int)>
}

struct SSEClient {
    id: Int
    response: @native("ResponseWriter")
    channels: [String]
    last_event_id: Option<String>
    connected_at: Instant
    metadata: Map<String, String>
}

struct SSEServerConfig {
    heartbeat_interval: Duration
    client_timeout: Duration
    max_clients: Int
    cors_origins: [String]
}

impl SSEServerConfig {
    fn default() -> Self {
        SSEServerConfig { heartbeat_interval: Duration.seconds(30), client_timeout: Duration.minutes(5), max_clients: 10000, cors_origins: [] }
    }
}

impl SSEServerV2 {
    fn new() -> Self { Self.with_config(SSEServerConfig.default()) }
    
    fn with_config(config: SSEServerConfig) -> Self {
        SSEServerV2 { clients: Map.new(), channels: Map.new(), next_id: 0, config: config, on_connect: None, on_disconnect: None }
    }
    
    fn on_connect(handler: fn(Int)) -> Self { self.on_connect = Some(handler); self }
    fn on_disconnect(handler: fn(Int)) -> Self { self.on_disconnect = Some(handler); self }
    
    fn handle(req: Request, res: @native("ResponseWriter")) -> Int {
        let id = self.next_id
        self.next_id += 1
        
        res.header("Content-Type", "text/event-stream")
        res.header("Cache-Control", "no-cache")
        res.header("Connection", "keep-alive")
        res.header("X-Accel-Buffering", "no")
        
        if !self.config.cors_origins.is_empty() {
            res.header("Access-Control-Allow-Origin", self.config.cors_origins.join(", "))
            res.header("Access-Control-Allow-Credentials", "true")
        }
        
        let last_event_id = req.headers.get("Last-Event-ID")
        let client = SSEClient { id: id, response: res, channels: [], last_event_id: last_event_id, connected_at: Instant.now(), metadata: Map.new() }
        self.clients.insert(id, client)
        
        if let Some(handler) = self.on_connect { handler(id) }
        self.start_heartbeat(id)
        id
    }
    
    fn start_heartbeat(client_id: Int) {
        spawn {
            while self.clients.contains_key(client_id) {
                @native("sleep", self.config.heartbeat_interval)
                self.send_comment(client_id, "heartbeat")
            }
        }
    }
    
    fn send(client_id: Int, event: SSEEvent) -> Result<(), SSEError> {
        let client = self.clients.get_mut(client_id).ok_or(SSEError.ClientNotFound)?
        client.response.write(event.encode().as_bytes())?
        client.response.flush()?
        Ok(())
    }
    
    fn send_comment(client_id: Int, comment: String) -> Result<(), SSEError> {
        let client = self.clients.get_mut(client_id).ok_or(SSEError.ClientNotFound)?
        client.response.write(format!(": {}\n\n", comment).as_bytes())?
        client.response.flush()?
        Ok(())
    }
    
    fn broadcast(event: SSEEvent) { for id in self.clients.keys() { self.send(id, event.clone()) } }
    fn broadcast_to_channel(channel: String, event: SSEEvent) { if let Some(ids) = self.channels.get(channel) { for id in ids { self.send(id, event.clone()) } } }
    
    fn subscribe(client_id: Int, channel: String) {
        self.channels.entry(channel.clone()).or_insert([]).push(client_id)
        if let Some(client) = self.clients.get_mut(client_id) { client.channels.push(channel) }
    }
    
    fn unsubscribe(client_id: Int, channel: String) {
        if let Some(ids) = self.channels.get_mut(channel) { ids.retain(|id| *id != client_id) }
        if let Some(client) = self.clients.get_mut(client_id) { client.channels.retain(|c| c != channel) }
    }
    
    fn disconnect(client_id: Int) {
        if let Some(client) = self.clients.remove(client_id) {
            for channel in client.channels { if let Some(ids) = self.channels.get_mut(channel) { ids.retain(|id| *id != client_id) } }
            if let Some(handler) = self.on_disconnect { handler(client_id) }
        }
    }
    
    fn client_count() -> Int { self.clients.len() }
    fn channel_count(channel: String) -> Int { self.channels.get(channel).map(|ids| ids.len()).unwrap_or(0) }
}

// -----------------------------------------------------------------------------
// SSE Stream
// -----------------------------------------------------------------------------

struct SSEStream { source: EventSourceV2 }

impl Stream for SSEStream {
    type Item = SSEEvent
    fn poll_next() -> Poll<Option<SSEEvent>> {
        // Stream implementation
        Poll.Pending
    }
}

fn stream(url: String) -> SSEStream { SSEStream { source: EventSourceV2.new(url) } }

// -----------------------------------------------------------------------------
// Event Builder
// -----------------------------------------------------------------------------

struct EventBuilder {
    id_generator: Option<fn() -> String>
    default_retry: Option<Int>
    event_type: Option<String>
}

impl EventBuilder {
    fn new() -> Self { EventBuilder { id_generator: None, default_retry: None, event_type: None } }
    fn auto_id() -> Self { self.id_generator = Some(|| uuid.v4()); self }
    fn sequential_id() -> Self { var counter = 0; self.id_generator = Some(|| { counter += 1; counter.to_string() }); self }
    fn retry(ms: Int) -> Self { self.default_retry = Some(ms); self }
    fn event_type(t: String) -> Self { self.event_type = Some(t); self }
    
    fn build(data: String) -> SSEEvent {
        var event = SSEEvent.new(data)
        if let Some(ref gen) = self.id_generator { event = event.id(gen()) }
        if let Some(r) = self.default_retry { event = event.retry(r) }
        if let Some(ref t) = self.event_type { event = event.event(t.clone()) }
        event
    }
    
    fn build_json<T: Serialize>(data: T) -> SSEEvent { self.build(json.encode(data)) }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum SSEError { ConnectionFailed, HttpError(Int), Timeout, ClientNotFound, Io(String) }

impl Display for SSEError {
    fn fmt(f: Formatter) {
        match self {
            ConnectionFailed => f.write("Connection failed")
            HttpError(code) => f.write(format!("HTTP error: {}", code))
            Timeout => f.write("Timeout")
            ClientNotFound => f.write("Client not found")
            Io(s) => f.write(format!("IO error: {}", s))
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "event encoding" {
    let event = SSEEvent.new("hello").id("1").event("message")
    let encoded = event.encode()
    assert(encoded.contains("id: 1"))
    assert(encoded.contains("event: message"))
    assert(encoded.contains("data: hello"))
}

test "event parsing" {
    let text = "id: 42\nevent: update\ndata: test\n\n"
    let event = SSEEvent.parse(text).unwrap()
    assert_eq(event.id, Some("42"))
    assert_eq(event.event, Some("update"))
    assert_eq(event.data, "test")
}

test "event builder" {
    let builder = EventBuilder.new().retry(5000).event_type("notification")
    let event = builder.build("test data")
    assert_eq(event.retry, Some(5000))
    assert_eq(event.event, Some("notification"))
}

test "config defaults" {
    let config = SSEConfig.default()
    assert(config.reconnect)
    assert_eq(config.max_retries, 10)
}
