// =============================================================================
// Vibee OS â€” MFA Module
// Multi-Factor Authentication
// =============================================================================

// =============================================================================
// MFA Types
// =============================================================================

/// MFA Method
enum MfaMethod { Totp, Sms, Email, Push, WebAuthn, RecoveryCode }

/// MFA Status
enum MfaStatus { Disabled, Pending, Enabled }

/// MFA Configuration for a user
struct MfaConfig {
    user_id: String
    methods: [EnabledMethod]
    backup_codes: [String]
    backup_codes_used: Set<String>
    require_mfa: Bool
    created_at: DateTime
    updated_at: DateTime
}

struct EnabledMethod {
    method: MfaMethod
    secret: Option<String>
    verified: Bool
    last_used: Option<DateTime>
    metadata: Map<String, String>
}

impl MfaConfig {
    fn new(user_id: String) -> Self {
        MfaConfig {
            user_id: user_id, methods: [], backup_codes: [],
            backup_codes_used: Set.empty(), require_mfa: false,
            created_at: DateTime.now(), updated_at: DateTime.now()
        }
    }
    
    fn is_enabled() -> Bool { self.methods.iter().any(|m| m.verified) }
    fn has_method(method: MfaMethod) -> Bool { self.methods.iter().any(|m| m.method == method && m.verified) }
    fn available_methods() -> [MfaMethod] { self.methods.iter().filter(|m| m.verified).map(|m| m.method.clone()).collect() }
}

// =============================================================================
// MFA Challenge
// =============================================================================

/// MFA Challenge
struct MfaChallenge {
    id: String
    user_id: String
    method: MfaMethod
    code: Option<String>
    attempts: Int
    max_attempts: Int
    expires_at: DateTime
    created_at: DateTime
}

impl MfaChallenge {
    fn new(user_id: String, method: MfaMethod, ttl_seconds: Int64) -> Self {
        MfaChallenge {
            id: uuid.v4(), user_id: user_id, method: method, code: None,
            attempts: 0, max_attempts: 3,
            expires_at: DateTime.now().add_seconds(ttl_seconds), created_at: DateTime.now()
        }
    }
    
    fn with_code(code: String) -> Self { self.code = Some(code); self }
    fn is_expired() -> Bool { DateTime.now() > self.expires_at }
    fn is_locked() -> Bool { self.attempts >= self.max_attempts }
    fn increment_attempts() { self.attempts += 1 }
}

// =============================================================================
// MFA Manager
// =============================================================================

/// MFA Manager
struct MfaManager<S: MfaStore> {
    store: S
    config: MfaManagerConfig
}

struct MfaManagerConfig {
    totp_issuer: String
    totp_digits: Int
    totp_period: Int
    sms_code_length: Int
    email_code_length: Int
    challenge_ttl: Int64
    backup_code_count: Int
}

impl MfaManagerConfig {
    fn default() -> Self {
        MfaManagerConfig {
            totp_issuer: "Vibee", totp_digits: 6, totp_period: 30,
            sms_code_length: 6, email_code_length: 6, challenge_ttl: 300, backup_code_count: 10
        }
    }
}

impl<S: MfaStore> MfaManager<S> {
    fn new(store: S) -> Self { MfaManager { store: store, config: MfaManagerConfig.default() } }
    fn with_config(config: MfaManagerConfig) -> Self { self.config = config; self }
    
    // -------------------------------------------------------------------------
    // TOTP Setup
    // -------------------------------------------------------------------------
    
    fn setup_totp(user_id: String, account_name: String) -> Result<TotpSetup, MfaError> {
        let secret = crypto.random_bytes(20)
        let secret_b32 = base32_encode(secret)
        
        let uri = format!("otpauth://totp/{}:{}?secret={}&issuer={}&digits={}&period={}",
            url.encode(self.config.totp_issuer.clone()), url.encode(account_name),
            secret_b32, url.encode(self.config.totp_issuer.clone()),
            self.config.totp_digits, self.config.totp_period)
        
        var mfa_config = self.store.get_config(user_id.clone()).unwrap_or(MfaConfig.new(user_id.clone()))
        mfa_config.methods.push(EnabledMethod {
            method: MfaMethod.Totp, secret: Some(secret_b32.clone()),
            verified: false, last_used: None, metadata: Map.empty()
        })
        self.store.save_config(mfa_config)?
        
        Ok(TotpSetup { secret: secret_b32, uri: uri, qr_code: self.generate_qr(uri)? })
    }
    
    fn verify_totp_setup(user_id: String, code: String) -> Result<(), MfaError> {
        var mfa_config = self.store.get_config(user_id.clone()).ok_or(MfaError.NotConfigured)?
        
        let method = mfa_config.methods.iter_mut().find(|m| m.method == MfaMethod.Totp && !m.verified)
            .ok_or(MfaError.NotConfigured)?
        
        let secret = method.secret.clone().ok_or(MfaError.InvalidSecret)?
        let totp = Totp.new(secret)?
        
        if !totp.verify(code) { return Err(MfaError.InvalidCode) }
        
        method.verified = true
        mfa_config.updated_at = DateTime.now()
        self.store.save_config(mfa_config)?
        
        Ok(())
    }
    
    fn generate_qr(uri: String) -> Result<String, MfaError> {
        Ok(format!("data:image/png;base64,{}", @native("qr_encode_base64", uri)))
    }
    
    // -------------------------------------------------------------------------
    // SMS/Email Setup
    // -------------------------------------------------------------------------
    
    fn setup_sms(user_id: String, phone: String) -> Result<MfaChallenge, MfaError> {
        let code = self.generate_numeric_code(self.config.sms_code_length)
        
        var mfa_config = self.store.get_config(user_id.clone()).unwrap_or(MfaConfig.new(user_id.clone()))
        mfa_config.methods.push(EnabledMethod {
            method: MfaMethod.Sms, secret: None, verified: false, last_used: None,
            metadata: Map.from([("phone", phone.clone())])
        })
        self.store.save_config(mfa_config)?
        
        let challenge = MfaChallenge.new(user_id, MfaMethod.Sms, self.config.challenge_ttl).with_code(code.clone())
        self.store.save_challenge(challenge.clone())?
        
        // Send SMS (would call external service)
        @native("send_sms", phone, format!("Your verification code: {}", code))
        
        Ok(challenge)
    }
    
    fn setup_email(user_id: String, email: String) -> Result<MfaChallenge, MfaError> {
        let code = self.generate_numeric_code(self.config.email_code_length)
        
        var mfa_config = self.store.get_config(user_id.clone()).unwrap_or(MfaConfig.new(user_id.clone()))
        mfa_config.methods.push(EnabledMethod {
            method: MfaMethod.Email, secret: None, verified: false, last_used: None,
            metadata: Map.from([("email", email.clone())])
        })
        self.store.save_config(mfa_config)?
        
        let challenge = MfaChallenge.new(user_id, MfaMethod.Email, self.config.challenge_ttl).with_code(code.clone())
        self.store.save_challenge(challenge.clone())?
        
        Ok(challenge)
    }
    
    fn generate_numeric_code(length: Int) -> String {
        let bytes = crypto.random_bytes(length)
        bytes.iter().map(|b| ((b as Int) % 10).to_string()).join("")
    }
    
    // -------------------------------------------------------------------------
    // Backup Codes
    // -------------------------------------------------------------------------
    
    fn generate_backup_codes(user_id: String) -> Result<[String], MfaError> {
        var mfa_config = self.store.get_config(user_id.clone()).ok_or(MfaError.NotConfigured)?
        
        let codes: [String] = (0..self.config.backup_code_count).map(|_| {
            let bytes = crypto.random_bytes(5)
            format!("{}-{}", hex.encode(bytes[0..2]).to_upper(), hex.encode(bytes[2..5]).to_upper())
        }).collect()
        
        mfa_config.backup_codes = codes.iter().map(|c| password.hash(c.clone()).unwrap_or("")).collect()
        mfa_config.backup_codes_used = Set.empty()
        mfa_config.updated_at = DateTime.now()
        self.store.save_config(mfa_config)?
        
        Ok(codes)
    }
    
    // -------------------------------------------------------------------------
    // Verification
    // -------------------------------------------------------------------------
    
    fn create_challenge(user_id: String, method: MfaMethod) -> Result<MfaChallenge, MfaError> {
        let mfa_config = self.store.get_config(user_id.clone()).ok_or(MfaError.NotConfigured)?
        
        if !mfa_config.has_method(method.clone()) { return Err(MfaError.MethodNotEnabled) }
        
        let challenge = MfaChallenge.new(user_id, method, self.config.challenge_ttl)
        self.store.save_challenge(challenge.clone())?
        
        Ok(challenge)
    }
    
    fn verify(challenge_id: String, code: String) -> Result<MfaVerifyResult, MfaError> {
        var challenge = self.store.get_challenge(challenge_id.clone()).ok_or(MfaError.ChallengeNotFound)?
        
        if challenge.is_expired() { return Err(MfaError.ChallengeExpired) }
        if challenge.is_locked() { return Err(MfaError.TooManyAttempts) }
        
        let mfa_config = self.store.get_config(challenge.user_id.clone()).ok_or(MfaError.NotConfigured)?
        
        let verified = match challenge.method {
            MfaMethod.Totp => self.verify_totp(mfa_config.clone(), code.clone())
            MfaMethod.Sms | MfaMethod.Email => self.verify_otp(challenge.clone(), code.clone())
            MfaMethod.RecoveryCode => self.verify_backup_code(mfa_config.clone(), code.clone())
            _ => false
        }
        
        if !verified {
            challenge.increment_attempts()
            self.store.save_challenge(challenge.clone())?
            return Ok(MfaVerifyResult { success: false, remaining_attempts: challenge.max_attempts - challenge.attempts })
        }
        
        self.store.delete_challenge(challenge_id)?
        self.update_last_used(challenge.user_id, challenge.method)?
        
        Ok(MfaVerifyResult { success: true, remaining_attempts: 0 })
    }
    
    fn verify_totp(config: MfaConfig, code: String) -> Bool {
        let method = config.methods.iter().find(|m| m.method == MfaMethod.Totp && m.verified);
        if let Some(m) = method {
            if let Some(secret) = m.secret.clone() {
                if let Ok(totp) = Totp.new(secret) { return totp.verify(code) }
            }
        }
        false
    }
    
    fn verify_otp(challenge: MfaChallenge, code: String) -> Bool {
        challenge.code.map(|c| crypto.constant_time_eq(c.as_bytes(), code.as_bytes())).unwrap_or(false)
    }
    
    fn verify_backup_code(config: MfaConfig, code: String) -> Bool {
        let clean_code = code.replace("-", "").to_upper()
        for (i, hash) in config.backup_codes.iter().enumerate() {
            if !config.backup_codes_used.contains(i.to_string()) && password.verify(clean_code.clone(), hash.clone()) {
                return true
            }
        }
        false
    }
    
    fn update_last_used(user_id: String, method: MfaMethod) -> Result<(), MfaError> {
        var config = self.store.get_config(user_id).ok_or(MfaError.NotConfigured)?
        for m in config.methods.iter_mut() {
            if m.method == method { m.last_used = Some(DateTime.now()) }
        }
        self.store.save_config(config)
    }
    
    // -------------------------------------------------------------------------
    // Management
    // -------------------------------------------------------------------------
    
    fn disable_method(user_id: String, method: MfaMethod) -> Result<(), MfaError> {
        var config = self.store.get_config(user_id.clone()).ok_or(MfaError.NotConfigured)?
        config.methods = config.methods.iter().filter(|m| m.method != method).collect()
        config.updated_at = DateTime.now()
        self.store.save_config(config)
    }
    
    fn disable_all(user_id: String) -> Result<(), MfaError> {
        self.store.delete_config(user_id)
    }
    
    fn get_status(user_id: String) -> MfaStatus {
        match self.store.get_config(user_id) {
            Some(config) if config.is_enabled() => MfaStatus.Enabled
            Some(_) => MfaStatus.Pending
            None => MfaStatus.Disabled
        }
    }
}

struct TotpSetup { secret: String, uri: String, qr_code: String }
struct MfaVerifyResult { success: Bool, remaining_attempts: Int }

// =============================================================================
// MFA Store Trait
// =============================================================================

trait MfaStore {
    fn get_config(user_id: String) -> Option<MfaConfig>
    fn save_config(config: MfaConfig) -> Result<(), MfaError>
    fn delete_config(user_id: String) -> Result<(), MfaError>
    fn save_challenge(challenge: MfaChallenge) -> Result<(), MfaError>
    fn get_challenge(id: String) -> Option<MfaChallenge>
    fn delete_challenge(id: String) -> Result<(), MfaError>
}

// =============================================================================
// In-Memory Store
// =============================================================================

struct InMemoryMfaStore { configs: Map<String, MfaConfig>, challenges: Map<String, MfaChallenge> }

impl InMemoryMfaStore { fn new() -> Self { InMemoryMfaStore { configs: Map.empty(), challenges: Map.empty() } } }

impl MfaStore for InMemoryMfaStore {
    fn get_config(user_id: String) -> Option<MfaConfig> { self.configs.get(user_id) }
    fn save_config(config: MfaConfig) -> Result<(), MfaError> { self.configs.set(config.user_id.clone(), config); Ok(()) }
    fn delete_config(user_id: String) -> Result<(), MfaError> { self.configs.remove(user_id); Ok(()) }
    fn save_challenge(challenge: MfaChallenge) -> Result<(), MfaError> { self.challenges.set(challenge.id.clone(), challenge); Ok(()) }
    fn get_challenge(id: String) -> Option<MfaChallenge> { self.challenges.get(id) }
    fn delete_challenge(id: String) -> Result<(), MfaError> { self.challenges.remove(id); Ok(()) }
}

// =============================================================================
// Base32 Encoding
// =============================================================================

const BASE32_ALPHABET: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

fn base32_encode(data: [UInt8]) -> String {
    var result = ""
    var buffer: UInt64 = 0
    var bits = 0
    for byte in data {
        buffer = (buffer << 8) | byte as UInt64
        bits += 8
        while bits >= 5 { bits -= 5; result.push(BASE32_ALPHABET[((buffer >> bits) & 0x1f) as Int]) }
    }
    if bits > 0 { buffer <<= 5 - bits; result.push(BASE32_ALPHABET[(buffer & 0x1f) as Int]) }
    result
}

// =============================================================================
// TOTP (simplified)
// =============================================================================

struct Totp { secret: [UInt8], digits: Int, period: Int }

impl Totp {
    fn new(secret_b32: String) -> Result<Self, MfaError> {
        let secret = base32_decode(secret_b32)?
        Ok(Totp { secret: secret, digits: 6, period: 30 })
    }
    
    fn generate() -> String {
        let counter = DateTime.now().timestamp() / self.period as Int64
        self.generate_at(counter)
    }
    
    fn generate_at(counter: Int64) -> String {
        var counter_bytes = [0u8; 8]
        for i in 0..8 { counter_bytes[7 - i] = ((counter >> (i * 8)) & 0xff) as UInt8 }
        let hmac = @native("hmac_sha1", self.secret, counter_bytes)
        let offset = (hmac[hmac.len() - 1] & 0x0f) as Int
        let code = ((hmac[offset] & 0x7f) as UInt32) << 24 | (hmac[offset + 1] as UInt32) << 16 |
                   (hmac[offset + 2] as UInt32) << 8 | (hmac[offset + 3] as UInt32)
        let otp = code % (10u32.pow(self.digits as UInt32))
        format!("{:0>width$}", otp, width = self.digits)
    }
    
    fn verify(code: String) -> Bool { self.verify_with_window(code, 1) }
    
    fn verify_with_window(code: String, window: Int) -> Bool {
        let now = DateTime.now().timestamp()
        for i in -window..=window {
            let counter = (now / self.period as Int64) + i as Int64
            if self.generate_at(counter) == code { return true }
        }
        false
    }
}

fn base32_decode(s: String) -> Result<[UInt8], MfaError> {
    let s = s.trim_end("=")
    var result = []
    var buffer: UInt64 = 0
    var bits = 0
    for c in s.chars() {
        let idx = BASE32_ALPHABET.find(c).ok_or(MfaError.InvalidSecret)?
        buffer = (buffer << 5) | idx as UInt64
        bits += 5
        if bits >= 8 { bits -= 8; result.push(((buffer >> bits) & 0xff) as UInt8) }
    }
    Ok(result)
}

// =============================================================================
// MFA Actor
// =============================================================================

actor MfaActor {
    state manager: MfaManager<InMemoryMfaStore>
    
    fn new() -> Self { MfaActor { manager: MfaManager.new(InMemoryMfaStore.new()) } }
    
    fn setup_totp(user_id: String, account: String) -> Result<TotpSetup, MfaError> { self.manager.setup_totp(user_id, account) }
    fn verify_totp_setup(user_id: String, code: String) -> Result<(), MfaError> { self.manager.verify_totp_setup(user_id, code) }
    fn generate_backup_codes(user_id: String) -> Result<[String], MfaError> { self.manager.generate_backup_codes(user_id) }
    fn create_challenge(user_id: String, method: MfaMethod) -> Result<MfaChallenge, MfaError> { self.manager.create_challenge(user_id, method) }
    fn verify(challenge_id: String, code: String) -> Result<MfaVerifyResult, MfaError> { self.manager.verify(challenge_id, code) }
    fn get_status(user_id: String) -> MfaStatus { self.manager.get_status(user_id) }
}

// =============================================================================
// Errors
// =============================================================================

enum MfaError { NotConfigured, MethodNotEnabled, InvalidCode, InvalidSecret, ChallengeNotFound, ChallengeExpired, TooManyAttempts, Other(String) }

impl Display for MfaError {
    fn fmt(f: Formatter) {
        match self {
            NotConfigured => f.write("MFA not configured")
            MethodNotEnabled => f.write("MFA method not enabled")
            InvalidCode => f.write("Invalid verification code")
            ChallengeExpired => f.write("Challenge expired")
            TooManyAttempts => f.write("Too many failed attempts")
            _ => f.write("MFA error")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "totp generation" {
    let totp = Totp.new("JBSWY3DPEHPK3PXP")?
    let code = totp.generate()
    assert_eq(code.len(), 6)?
    assert(totp.verify(code))?
}

test "base32 encode decode" {
    let data = "Hello".as_bytes()
    let encoded = base32_encode(data)
    let decoded = base32_decode(encoded)?
    assert_eq(decoded, data)?
}

test "backup codes" {
    let store = InMemoryMfaStore.new()
    var manager = MfaManager.new(store)
    
    // Setup TOTP first
    manager.setup_totp("user-1", "test@example.com")?
    manager.verify_totp_setup("user-1", manager.store.get_config("user-1").unwrap().methods[0].secret.clone().map(|s| Totp.new(s).unwrap().generate()).unwrap())?
    
    let codes = manager.generate_backup_codes("user-1")?
    assert_eq(codes.len(), 10)?
}
