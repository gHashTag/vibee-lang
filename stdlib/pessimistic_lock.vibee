// =============================================================================
// Vibee OS â€” Pessimistic Lock Module
// Pessimistic concurrency control primitives
// =============================================================================

// =============================================================================
// Lock Modes
// =============================================================================

/// Pessimistic lock mode
enum PessimisticLockMode {
    Shared          // Read lock - multiple readers allowed
    Exclusive       // Write lock - single writer only
    Update          // Upgrade from shared to exclusive
    IntentShared    // Intent to acquire shared lock on child
    IntentExclusive // Intent to acquire exclusive lock on child
}

impl PessimisticLockMode {
    fn is_compatible(other: PessimisticLockMode) -> Bool {
        match (self, other) {
            (PessimisticLockMode.Shared, PessimisticLockMode.Shared) => true
            (PessimisticLockMode.Shared, PessimisticLockMode.IntentShared) => true
            (PessimisticLockMode.IntentShared, PessimisticLockMode.Shared) => true
            (PessimisticLockMode.IntentShared, PessimisticLockMode.IntentShared) => true
            (PessimisticLockMode.IntentShared, PessimisticLockMode.IntentExclusive) => true
            (PessimisticLockMode.IntentExclusive, PessimisticLockMode.IntentShared) => true
            (PessimisticLockMode.IntentExclusive, PessimisticLockMode.IntentExclusive) => true
            _ => false
        }
    }
    
    fn to_string() -> String {
        match self {
            PessimisticLockMode.Shared => "S"
            PessimisticLockMode.Exclusive => "X"
            PessimisticLockMode.Update => "U"
            PessimisticLockMode.IntentShared => "IS"
            PessimisticLockMode.IntentExclusive => "IX"
        }
    }
}

// =============================================================================
// Error Types
// =============================================================================

/// Pessimistic lock errors
enum PessimisticLockError {
    LockTimeout { resource: String, timeout_ms: Int64 }
    Deadlock { cycle: [String] }
    LockNotHeld { resource: String, owner: String }
    IncompatibleMode { current: PessimisticLockMode, requested: PessimisticLockMode }
    ResourceNotFound { resource: String }
    UpgradeFailed { reason: String }
}

impl PessimisticLockError {
    fn message() -> String {
        match self {
            PessimisticLockError.LockTimeout { resource, timeout_ms } =>
                f"Lock timeout on {resource} after {timeout_ms}ms"
            PessimisticLockError.Deadlock { cycle } =>
                f"Deadlock detected: {cycle.join(\" -> \")}"
            PessimisticLockError.LockNotHeld { resource, owner } =>
                f"Lock on {resource} not held by {owner}"
            PessimisticLockError.IncompatibleMode { current, requested } =>
                f"Incompatible lock mode: {current.to_string()} vs {requested.to_string()}"
            PessimisticLockError.ResourceNotFound { resource } =>
                f"Resource not found: {resource}"
            PessimisticLockError.UpgradeFailed { reason } =>
                f"Lock upgrade failed: {reason}"
        }
    }
}

// =============================================================================
// Lock Entry
// =============================================================================

/// Information about a held lock
struct LockEntry {
    resource: String
    owner: String
    mode: PessimisticLockMode
    acquired_at: Int64
    timeout_at: Option<Int64>
    
    fn new(resource: String, owner: String, mode: PessimisticLockMode) -> Self {
        LockEntry {
            resource: resource,
            owner: owner,
            mode: mode,
            acquired_at: @native("timestamp_ms"),
            timeout_at: None
        }
    }
    
    fn with_timeout(resource: String, owner: String, mode: PessimisticLockMode, timeout_ms: Int64) -> Self {
        LockEntry {
            resource: resource,
            owner: owner,
            mode: mode,
            acquired_at: @native("timestamp_ms"),
            timeout_at: Some(@native("timestamp_ms") + timeout_ms)
        }
    }
    
    fn is_expired() -> Bool {
        match self.timeout_at {
            Some(t) => @native("timestamp_ms") > t
            None => false
        }
    }
    
    fn held_duration_ms() -> Int64 {
        @native("timestamp_ms") - self.acquired_at
    }
}

// =============================================================================
// Pessimistic Lock Manager
// =============================================================================

/// Configuration for pessimistic locking
struct PessimisticLockConfig {
    default_timeout_ms: Int64
    deadlock_detection: Bool
    lock_wait_timeout_ms: Int64
    max_locks_per_owner: Int
    
    fn default() -> Self {
        PessimisticLockConfig {
            default_timeout_ms: 30000,
            deadlock_detection: true,
            lock_wait_timeout_ms: 10000,
            max_locks_per_owner: 100
        }
    }
}

/// Pessimistic lock manager
actor PessimisticLockManager {
    state locks: Map<String, [LockEntry]>
    state waiters: Map<String, [WaitEntry]>
    state owner_locks: Map<String, [String]>
    state config: PessimisticLockConfig
    
    fn new() -> Self {
        PessimisticLockManager {
            locks: Map.new(),
            waiters: Map.new(),
            owner_locks: Map.new(),
            config: PessimisticLockConfig.default()
        }
    }
    
    fn with_config(config: PessimisticLockConfig) -> Self {
        PessimisticLockManager {
            locks: Map.new(),
            waiters: Map.new(),
            owner_locks: Map.new(),
            config: config
        }
    }
    
    /// Acquire a lock (blocking)
    fn acquire(resource: String, owner: String, mode: PessimisticLockMode) -> Result<LockGuard, PessimisticLockError> {
        self.acquire_timeout(resource, owner, mode, self.config.lock_wait_timeout_ms)
    }
    
    /// Acquire a lock with timeout
    fn acquire_timeout(resource: String, owner: String, mode: PessimisticLockMode, timeout_ms: Int64) -> Result<LockGuard, PessimisticLockError> {
        let deadline = @native("timestamp_ms") + timeout_ms
        
        while @native("timestamp_ms") < deadline {
            // Check for deadlock
            if self.config.deadlock_detection {
                if let Some(cycle) = self.detect_deadlock(resource, owner) {
                    return Err(PessimisticLockError.Deadlock { cycle: cycle })
                }
            }
            
            // Try to acquire
            if self.try_acquire_internal(resource.clone(), owner.clone(), mode) {
                return Ok(LockGuard { manager: self, resource: resource, owner: owner })
            }
            
            // Add to waiters and wait
            self.add_waiter(resource.clone(), owner.clone(), mode)
            @native("sleep_ms", 10)
        }
        
        self.remove_waiter(resource.clone(), owner.clone())
        Err(PessimisticLockError.LockTimeout { resource: resource, timeout_ms: timeout_ms })
    }
    
    /// Try to acquire a lock (non-blocking)
    fn try_acquire(resource: String, owner: String, mode: PessimisticLockMode) -> Option<LockGuard> {
        if self.try_acquire_internal(resource.clone(), owner.clone(), mode) {
            Some(LockGuard { manager: self, resource: resource, owner: owner })
        } else {
            None
        }
    }
    
    fn try_acquire_internal(resource: String, owner: String, mode: PessimisticLockMode) -> Bool {
        // Clean expired locks
        self.cleanup_expired(resource.clone())
        
        let current_locks = self.locks.get(resource.clone()).unwrap_or([])
        
        // Check if owner already holds a lock
        for lock in current_locks.iter() {
            if lock.owner == owner {
                return true // Already holds lock
            }
        }
        
        // Check compatibility with existing locks
        for lock in current_locks.iter() {
            if !mode.is_compatible(lock.mode) {
                return false
            }
        }
        
        // Acquire the lock
        let entry = LockEntry.new(resource.clone(), owner.clone(), mode)
        var locks_list = current_locks
        locks_list.push(entry)
        self.locks.insert(resource.clone(), locks_list)
        
        // Track owner's locks
        var owner_list = self.owner_locks.get(owner.clone()).unwrap_or([])
        owner_list.push(resource)
        self.owner_locks.insert(owner, owner_list)
        
        true
    }
    
    /// Release a lock
    fn release(resource: String, owner: String) -> Result<(), PessimisticLockError> {
        let current_locks = self.locks.get(resource.clone()).unwrap_or([])
        var found = false
        var new_locks: [LockEntry] = []
        
        for lock in current_locks.iter() {
            if lock.owner == owner {
                found = true
            } else {
                new_locks.push(lock.clone())
            }
        }
        
        if !found {
            return Err(PessimisticLockError.LockNotHeld { resource: resource, owner: owner })
        }
        
        if new_locks.is_empty() {
            self.locks.remove(resource.clone())
        } else {
            self.locks.insert(resource.clone(), new_locks)
        }
        
        // Remove from owner's locks
        if let Some(owner_list) = self.owner_locks.get(owner.clone()) {
            let filtered: [String] = owner_list.iter().filter(|r| *r != resource).collect()
            if filtered.is_empty() {
                self.owner_locks.remove(owner)
            } else {
                self.owner_locks.insert(owner, filtered)
            }
        }
        
        // Wake up waiters
        self.notify_waiters(resource)
        
        Ok(())
    }
    
    /// Upgrade lock from shared to exclusive
    fn upgrade(resource: String, owner: String) -> Result<(), PessimisticLockError> {
        let current_locks = self.locks.get(resource.clone()).unwrap_or([])
        
        // Check if owner holds a shared lock
        var has_shared = false
        for lock in current_locks.iter() {
            if lock.owner == owner && matches!(lock.mode, PessimisticLockMode.Shared) {
                has_shared = true
                break
            }
        }
        
        if !has_shared {
            return Err(PessimisticLockError.LockNotHeld { resource: resource, owner: owner })
        }
        
        // Check if upgrade is possible (no other shared locks)
        for lock in current_locks.iter() {
            if lock.owner != owner {
                return Err(PessimisticLockError.UpgradeFailed { 
                    reason: "Other locks held on resource".to_string() 
                })
            }
        }
        
        // Upgrade the lock
        var new_locks: [LockEntry] = []
        for lock in current_locks.iter() {
            if lock.owner == owner {
                new_locks.push(LockEntry.new(resource.clone(), owner.clone(), PessimisticLockMode.Exclusive))
            } else {
                new_locks.push(lock.clone())
            }
        }
        self.locks.insert(resource, new_locks)
        
        Ok(())
    }
    
    /// Downgrade lock from exclusive to shared
    fn downgrade(resource: String, owner: String) -> Result<(), PessimisticLockError> {
        let current_locks = self.locks.get(resource.clone()).unwrap_or([])
        
        var new_locks: [LockEntry] = []
        var found = false
        
        for lock in current_locks.iter() {
            if lock.owner == owner && matches!(lock.mode, PessimisticLockMode.Exclusive) {
                new_locks.push(LockEntry.new(resource.clone(), owner.clone(), PessimisticLockMode.Shared))
                found = true
            } else {
                new_locks.push(lock.clone())
            }
        }
        
        if !found {
            return Err(PessimisticLockError.LockNotHeld { resource: resource, owner: owner })
        }
        
        self.locks.insert(resource.clone(), new_locks)
        self.notify_waiters(resource)
        
        Ok(())
    }
    
    /// Release all locks held by owner
    fn release_all(owner: String) {
        if let Some(resources) = self.owner_locks.get(owner.clone()) {
            for resource in resources.iter() {
                let _ = self.release(resource.clone(), owner.clone())
            }
        }
    }
    
    /// Check if resource is locked
    fn is_locked(resource: String) -> Bool {
        self.cleanup_expired(resource.clone())
        self.locks.get(resource).map(|l| !l.is_empty()).unwrap_or(false)
    }
    
    /// Get lock info
    fn get_lock_info(resource: String) -> Option<[LockEntry]> {
        self.cleanup_expired(resource.clone())
        self.locks.get(resource)
    }
    
    fn cleanup_expired(resource: String) {
        if let Some(locks) = self.locks.get(resource.clone()) {
            let active: [LockEntry] = locks.iter().filter(|l| !l.is_expired()).collect()
            if active.len() != locks.len() {
                if active.is_empty() {
                    self.locks.remove(resource)
                } else {
                    self.locks.insert(resource, active)
                }
            }
        }
    }
    
    fn add_waiter(resource: String, owner: String, mode: PessimisticLockMode) {
        var waiters_list = self.waiters.get(resource.clone()).unwrap_or([])
        waiters_list.push(WaitEntry { owner: owner, mode: mode, waiting_since: @native("timestamp_ms") })
        self.waiters.insert(resource, waiters_list)
    }
    
    fn remove_waiter(resource: String, owner: String) {
        if let Some(waiters_list) = self.waiters.get(resource.clone()) {
            let filtered: [WaitEntry] = waiters_list.iter().filter(|w| w.owner != owner).collect()
            if filtered.is_empty() {
                self.waiters.remove(resource)
            } else {
                self.waiters.insert(resource, filtered)
            }
        }
    }
    
    fn notify_waiters(resource: String) {
        // Waiters will be woken up on next iteration
    }
    
    fn detect_deadlock(resource: String, owner: String) -> Option<[String]> {
        // Simple cycle detection in wait-for graph
        var visited: Set<String> = Set.new()
        var path: [String] = [owner]
        
        fn dfs(current: String, target: String, manager: PessimisticLockManager, visited: Set<String>, path: [String]) -> Option<[String]> {
            if visited.contains(current) {
                if current == target { return Some(path) }
                return None
            }
            visited.insert(current.clone())
            
            // Find what resources current owner is waiting for
            for (res, waiters) in manager.waiters.iter() {
                for waiter in waiters.iter() {
                    if waiter.owner == current {
                        // Find who holds this resource
                        if let Some(holders) = manager.locks.get(res.clone()) {
                            for holder in holders.iter() {
                                var new_path = path.clone()
                                new_path.push(holder.owner.clone())
                                if let Some(cycle) = dfs(holder.owner.clone(), target, manager, visited.clone(), new_path) {
                                    return Some(cycle)
                                }
                            }
                        }
                    }
                }
            }
            None
        }
        
        dfs(owner.clone(), owner, self, visited, path)
    }
}

struct WaitEntry {
    owner: String
    mode: PessimisticLockMode
    waiting_since: Int64
}

/// RAII guard for automatic lock release
struct LockGuard {
    manager: PessimisticLockManager
    resource: String
    owner: String
}

impl Drop for LockGuard {
    fn drop() {
        let _ = self.manager.release(self.resource.clone(), self.owner.clone())
    }
}

// =============================================================================
// Two-Phase Locking
// =============================================================================

/// Two-phase locking transaction
actor TwoPhaseLockTransaction {
    state manager: PessimisticLockManager
    state owner: String
    state acquired_locks: [(String, PessimisticLockMode)]
    state phase: TwoPhasePhase
    
    fn new(manager: PessimisticLockManager, owner: String) -> Self {
        TwoPhaseLockTransaction {
            manager: manager,
            owner: owner,
            acquired_locks: [],
            phase: TwoPhasePhase.Growing
        }
    }
    
    /// Acquire lock (only in growing phase)
    fn acquire(resource: String, mode: PessimisticLockMode) -> Result<(), PessimisticLockError> {
        match self.phase {
            TwoPhasePhase.Growing => {
                let _ = self.manager.acquire(resource.clone(), self.owner.clone(), mode)?
                self.acquired_locks.push((resource, mode))
                Ok(())
            }
            TwoPhasePhase.Shrinking => {
                Err(PessimisticLockError.UpgradeFailed { 
                    reason: "Cannot acquire locks in shrinking phase".to_string() 
                })
            }
        }
    }
    
    /// Release lock (transitions to shrinking phase)
    fn release(resource: String) -> Result<(), PessimisticLockError> {
        self.phase = TwoPhasePhase.Shrinking
        self.manager.release(resource.clone(), self.owner.clone())?
        self.acquired_locks = self.acquired_locks.iter()
            .filter(|(r, _)| *r != resource)
            .collect()
        Ok(())
    }
    
    /// Commit - release all locks
    fn commit() {
        self.phase = TwoPhasePhase.Shrinking
        for (resource, _) in self.acquired_locks.iter() {
            let _ = self.manager.release(resource.clone(), self.owner.clone())
        }
        self.acquired_locks.clear()
    }
    
    /// Abort - release all locks
    fn abort() {
        self.phase = TwoPhasePhase.Shrinking
        for (resource, _) in self.acquired_locks.iter() {
            let _ = self.manager.release(resource.clone(), self.owner.clone())
        }
        self.acquired_locks.clear()
    }
}

enum TwoPhasePhase {
    Growing
    Shrinking
}

// =============================================================================
// Hierarchical Locking
// =============================================================================

/// Hierarchical lock manager for tree-structured resources
actor HierarchicalLockManager {
    state manager: PessimisticLockManager
    state hierarchy: Map<String, String>  // child -> parent
    
    fn new() -> Self {
        HierarchicalLockManager {
            manager: PessimisticLockManager.new(),
            hierarchy: Map.new()
        }
    }
    
    /// Register parent-child relationship
    fn register_hierarchy(child: String, parent: String) {
        self.hierarchy.insert(child, parent)
    }
    
    /// Acquire lock with intent locks on ancestors
    fn acquire(resource: String, owner: String, mode: PessimisticLockMode) -> Result<LockGuard, PessimisticLockError> {
        // Acquire intent locks on ancestors
        let ancestors = self.get_ancestors(resource.clone())
        let intent_mode = match mode {
            PessimisticLockMode.Shared => PessimisticLockMode.IntentShared
            PessimisticLockMode.Exclusive => PessimisticLockMode.IntentExclusive
            _ => mode
        }
        
        for ancestor in ancestors.iter() {
            self.manager.acquire(ancestor.clone(), owner.clone(), intent_mode)?
        }
        
        // Acquire actual lock
        self.manager.acquire(resource, owner, mode)
    }
    
    /// Release lock and intent locks
    fn release(resource: String, owner: String) -> Result<(), PessimisticLockError> {
        self.manager.release(resource.clone(), owner.clone())?
        
        // Release intent locks on ancestors
        let ancestors = self.get_ancestors(resource)
        for ancestor in ancestors.iter().rev() {
            let _ = self.manager.release(ancestor.clone(), owner.clone())
        }
        
        Ok(())
    }
    
    fn get_ancestors(resource: String) -> [String] {
        var ancestors: [String] = []
        var current = resource
        
        while let Some(parent) = self.hierarchy.get(current.clone()) {
            ancestors.push(parent.clone())
            current = parent.clone()
        }
        
        ancestors.reverse()
        ancestors
    }
}

// =============================================================================
// Database Row Locking
// =============================================================================

/// Row-level lock for database operations
struct RowLock {
    table: String
    row_id: String
    mode: PessimisticLockMode
    owner: String
    
    fn for_read(table: String, row_id: String, owner: String) -> Self {
        RowLock { table: table, row_id: row_id, mode: PessimisticLockMode.Shared, owner: owner }
    }
    
    fn for_update(table: String, row_id: String, owner: String) -> Self {
        RowLock { table: table, row_id: row_id, mode: PessimisticLockMode.Exclusive, owner: owner }
    }
    
    fn resource_key() -> String {
        f"{self.table}:{self.row_id}"
    }
}

/// SQL builder for pessimistic locking
struct PessimisticSqlBuilder {
    fn select_for_share(table: String, where_clause: String) -> String {
        f"SELECT * FROM {table} WHERE {where_clause} FOR SHARE"
    }
    
    fn select_for_update(table: String, where_clause: String) -> String {
        f"SELECT * FROM {table} WHERE {where_clause} FOR UPDATE"
    }
    
    fn select_for_update_nowait(table: String, where_clause: String) -> String {
        f"SELECT * FROM {table} WHERE {where_clause} FOR UPDATE NOWAIT"
    }
    
    fn select_for_update_skip_locked(table: String, where_clause: String) -> String {
        f"SELECT * FROM {table} WHERE {where_clause} FOR UPDATE SKIP LOCKED"
    }
}

// =============================================================================
// Tests
// =============================================================================

test "lock mode compatibility" {
    assert(PessimisticLockMode.Shared.is_compatible(PessimisticLockMode.Shared))?
    assert(!PessimisticLockMode.Shared.is_compatible(PessimisticLockMode.Exclusive))?
    assert(!PessimisticLockMode.Exclusive.is_compatible(PessimisticLockMode.Exclusive))?
}

test "acquire and release" {
    let manager = PessimisticLockManager.new()
    
    let guard = manager.try_acquire("resource1".to_string(), "owner1".to_string(), PessimisticLockMode.Exclusive)
    assert(guard.is_some())?
    assert(manager.is_locked("resource1".to_string()))?
    
    drop(guard)
    assert(!manager.is_locked("resource1".to_string()))?
}

test "shared locks compatible" {
    let manager = PessimisticLockManager.new()
    
    let g1 = manager.try_acquire("resource1".to_string(), "owner1".to_string(), PessimisticLockMode.Shared)
    let g2 = manager.try_acquire("resource1".to_string(), "owner2".to_string(), PessimisticLockMode.Shared)
    
    assert(g1.is_some())?
    assert(g2.is_some())?
}

test "exclusive blocks shared" {
    let manager = PessimisticLockManager.new()
    
    let g1 = manager.try_acquire("resource1".to_string(), "owner1".to_string(), PessimisticLockMode.Exclusive)
    let g2 = manager.try_acquire("resource1".to_string(), "owner2".to_string(), PessimisticLockMode.Shared)
    
    assert(g1.is_some())?
    assert(g2.is_none())?
}

test "two phase locking" {
    let manager = PessimisticLockManager.new()
    let tx = TwoPhaseLockTransaction.new(manager, "tx1".to_string())
    
    tx.acquire("r1".to_string(), PessimisticLockMode.Exclusive)?
    tx.acquire("r2".to_string(), PessimisticLockMode.Shared)?
    
    tx.commit()
}
