// =============================================================================
// Vibee OS â€” n8n Integration Module
// n8n workflow automation integration
// =============================================================================

use http::{Request, Response, Method, Status, Headers, Client as HttpClient}
use json::{JsonValue, Serialize, Deserialize}
use crypto::{hmac_sha256}

// =============================================================================
// n8n Client
// =============================================================================

/// n8n API client for triggering workflows and webhooks
actor N8nClient {
    state base_url: String
    state api_key: Option<String>
    state http_client: HttpClient
    state retry_config: RetryConfig
    
    fn new(base_url: String) -> Self {
        N8nClient {
            base_url: base_url.trim_end_matches('/'),
            api_key: None,
            http_client: HttpClient.new().timeout(30000),
            retry_config: RetryConfig.default()
        }
    }
    
    fn with_api_key(key: String) -> Self {
        self.api_key = Some(key)
        self
    }
    
    /// Trigger a webhook
    fn trigger_webhook(webhook_path: String, data: JsonValue) -> Result<N8nResponse, N8nError> {
        let url = format!("{}/webhook/{}", self.base_url, webhook_path)
        self.send_request(Method.POST, url, Some(data))
    }
    
    /// Trigger a test webhook
    fn trigger_test_webhook(webhook_path: String, data: JsonValue) -> Result<N8nResponse, N8nError> {
        let url = format!("{}/webhook-test/{}", self.base_url, webhook_path)
        self.send_request(Method.POST, url, Some(data))
    }
    
    /// Execute a workflow by ID
    fn execute_workflow(workflow_id: String, data: Option<JsonValue>) -> Result<N8nExecution, N8nError> {
        let url = format!("{}/api/v1/workflows/{}/execute", self.base_url, workflow_id)
        let response = self.send_request(Method.POST, url, data)?
        json.decode(response.data.unwrap_or(JsonValue.null()).to_string())
            .map_err(|_| N8nError.InvalidResponse)
    }
    
    /// Get workflow by ID
    fn get_workflow(workflow_id: String) -> Result<N8nWorkflow, N8nError> {
        let url = format!("{}/api/v1/workflows/{}", self.base_url, workflow_id)
        let response = self.send_request(Method.GET, url, None)?
        json.decode(response.data.unwrap_or(JsonValue.null()).to_string())
            .map_err(|_| N8nError.InvalidResponse)
    }
    
    /// List all workflows
    fn list_workflows() -> Result<[N8nWorkflow], N8nError> {
        let url = format!("{}/api/v1/workflows", self.base_url)
        let response = self.send_request(Method.GET, url, None)?
        let data = response.data.unwrap_or(JsonValue.null())
        let workflows = data.get("data").unwrap_or(JsonValue.array([]))
        json.decode(workflows.to_string()).map_err(|_| N8nError.InvalidResponse)
    }
    
    /// Activate a workflow
    fn activate_workflow(workflow_id: String) -> Result<(), N8nError> {
        let url = format!("{}/api/v1/workflows/{}/activate", self.base_url, workflow_id)
        self.send_request(Method.POST, url, None)?
        Ok(())
    }
    
    /// Deactivate a workflow
    fn deactivate_workflow(workflow_id: String) -> Result<(), N8nError> {
        let url = format!("{}/api/v1/workflows/{}/deactivate", self.base_url, workflow_id)
        self.send_request(Method.POST, url, None)?
        Ok(())
    }
    
    fn send_request(method: Method, url: String, body: Option<JsonValue>) -> Result<N8nResponse, N8nError> {
        var request = Request.new(method, url)
            .header("Content-Type", "application/json")
        
        if let Some(key) = self.api_key.clone() {
            request = request.header("X-N8N-API-KEY", key)
        }
        
        if let Some(data) = body {
            request = request.json(data)
        }
        
        let response = self.http_client.send(request)
            .map_err(|e| N8nError.NetworkError(e.to_string()))?
        
        if !response.is_success() {
            return Err(N8nError.ApiError(response.status.code, response.text()))
        }
        
        Ok(N8nResponse {
            status: response.status.code,
            data: response.json().ok()
        })
    }
}

// =============================================================================
// n8n Node Builder
// =============================================================================

/// Builder for n8n custom nodes
struct N8nNode {
    name: String
    display_name: String
    description: String
    icon: Option<String>
    group: [String]
    version: Int
    defaults: N8nNodeDefaults
    inputs: [String]
    outputs: [String]
    properties: [N8nProperty]
    credentials: [N8nCredential]
}

impl N8nNode {
    fn new(name: String, display_name: String) -> Self {
        N8nNode {
            name: name,
            display_name: display_name,
            description: "",
            icon: None,
            group: ["transform"],
            version: 1,
            defaults: N8nNodeDefaults.default(),
            inputs: ["main"],
            outputs: ["main"],
            properties: [],
            credentials: []
        }
    }
    
    fn description(desc: String) -> Self { self.description = desc; self }
    fn icon(i: String) -> Self { self.icon = Some(i); self }
    fn group(g: [String]) -> Self { self.group = g; self }
    fn version(v: Int) -> Self { self.version = v; self }
    fn inputs(i: [String]) -> Self { self.inputs = i; self }
    fn outputs(o: [String]) -> Self { self.outputs = o; self }
    
    fn add_property(prop: N8nProperty) -> Self {
        self.properties.push(prop)
        self
    }
    
    fn add_credential(cred: N8nCredential) -> Self {
        self.credentials.push(cred)
        self
    }
    
    fn to_json() -> JsonValue {
        var obj = Map.empty()
        obj.set("name", JsonValue.string(self.name.clone()))
        obj.set("displayName", JsonValue.string(self.display_name.clone()))
        obj.set("description", JsonValue.string(self.description.clone()))
        obj.set("version", JsonValue.number(self.version))
        obj.set("inputs", JsonValue.array(self.inputs.iter().map(|i| JsonValue.string(i.clone())).collect()))
        obj.set("outputs", JsonValue.array(self.outputs.iter().map(|o| JsonValue.string(o.clone())).collect()))
        obj.set("properties", JsonValue.array(self.properties.iter().map(|p| p.to_json()).collect()))
        
        if let Some(icon) = self.icon.clone() {
            obj.set("icon", JsonValue.string(icon))
        }
        
        JsonValue.from_map(obj)
    }
}

struct N8nNodeDefaults {
    name: String
    color: String
}

impl N8nNodeDefaults {
    fn default() -> Self {
        N8nNodeDefaults { name: "Node", color: "#772244" }
    }
}

// =============================================================================
// n8n Property
// =============================================================================

/// n8n node property definition
struct N8nProperty {
    name: String
    display_name: String
    prop_type: N8nPropertyType
    default_value: JsonValue
    required: Bool
    description: Option<String>
    options: Option<[N8nOption]>
    display_options: Option<N8nDisplayOptions>
}

impl N8nProperty {
    fn new(name: String, display_name: String, prop_type: N8nPropertyType) -> Self {
        N8nProperty {
            name: name,
            display_name: display_name,
            prop_type: prop_type,
            default_value: JsonValue.string(""),
            required: false,
            description: None,
            options: None,
            display_options: None
        }
    }
    
    fn string(name: String, display_name: String) -> Self {
        Self.new(name, display_name, N8nPropertyType.String)
    }
    
    fn number(name: String, display_name: String) -> Self {
        Self.new(name, display_name, N8nPropertyType.Number).default(JsonValue.number(0))
    }
    
    fn boolean(name: String, display_name: String) -> Self {
        Self.new(name, display_name, N8nPropertyType.Boolean).default(JsonValue.bool(false))
    }
    
    fn options(name: String, display_name: String, opts: [N8nOption]) -> Self {
        Self.new(name, display_name, N8nPropertyType.Options).with_options(opts)
    }
    
    fn default(value: JsonValue) -> Self { self.default_value = value; self }
    fn required() -> Self { self.required = true; self }
    fn description(desc: String) -> Self { self.description = Some(desc); self }
    fn with_options(opts: [N8nOption]) -> Self { self.options = Some(opts); self }
    
    fn show_when(field: String, value: JsonValue) -> Self {
        self.display_options = Some(N8nDisplayOptions {
            show: Some(Map.from([(field, [value])])),
            hide: None
        })
        self
    }
    
    fn to_json() -> JsonValue {
        var obj = Map.empty()
        obj.set("name", JsonValue.string(self.name.clone()))
        obj.set("displayName", JsonValue.string(self.display_name.clone()))
        obj.set("type", JsonValue.string(self.prop_type.to_string()))
        obj.set("default", self.default_value.clone())
        obj.set("required", JsonValue.bool(self.required))
        
        if let Some(desc) = self.description.clone() {
            obj.set("description", JsonValue.string(desc))
        }
        if let Some(opts) = self.options.clone() {
            obj.set("options", JsonValue.array(opts.iter().map(|o| o.to_json()).collect()))
        }
        
        JsonValue.from_map(obj)
    }
}

enum N8nPropertyType { String, Number, Boolean, Options, MultiOptions, Collection, FixedCollection, Json, DateTime, Color }

impl N8nPropertyType {
    fn to_string() -> String {
        match self {
            String => "string", Number => "number", Boolean => "boolean",
            Options => "options", MultiOptions => "multiOptions",
            Collection => "collection", FixedCollection => "fixedCollection",
            Json => "json", DateTime => "dateTime", Color => "color"
        }
    }
}

struct N8nOption {
    name: String
    value: String
    description: Option<String>
}

impl N8nOption {
    fn new(name: String, value: String) -> Self {
        N8nOption { name: name, value: value, description: None }
    }
    
    fn to_json() -> JsonValue {
        JsonValue.object([
            ("name", JsonValue.string(self.name.clone())),
            ("value", JsonValue.string(self.value.clone()))
        ])
    }
}

struct N8nDisplayOptions {
    show: Option<Map<String, [JsonValue]>>
    hide: Option<Map<String, [JsonValue]>>
}

// =============================================================================
// n8n Credential
// =============================================================================

struct N8nCredential {
    name: String
    required: Bool
}

impl N8nCredential {
    fn new(name: String) -> Self {
        N8nCredential { name: name, required: true }
    }
}

// =============================================================================
// n8n Data Types
// =============================================================================

struct N8nWorkflow {
    id: String
    name: String
    active: Bool
    created_at: String
    updated_at: String
    nodes: [JsonValue]
    connections: JsonValue
}

struct N8nExecution {
    id: String
    workflow_id: String
    finished: Bool
    mode: String
    started_at: String
    stopped_at: Option<String>
    status: N8nExecutionStatus
}

enum N8nExecutionStatus { Running, Success, Error, Waiting, Unknown }

struct N8nResponse {
    status: Int
    data: Option<JsonValue>
}

struct RetryConfig {
    max_retries: Int
    delay_ms: Int64
}

impl RetryConfig {
    fn default() -> Self { RetryConfig { max_retries: 3, delay_ms: 1000 } }
}

enum N8nError {
    NetworkError(String),
    ApiError(Int, String),
    InvalidResponse,
    WorkflowNotFound(String),
    Other(String)
}

impl Display for N8nError {
    fn fmt(f: Formatter) {
        match self {
            NetworkError(s) => f.write(format!("Network error: {}", s)),
            ApiError(code, msg) => f.write(format!("API error {}: {}", code, msg)),
            InvalidResponse => f.write("Invalid response"),
            WorkflowNotFound(id) => f.write(format!("Workflow not found: {}", id)),
            Other(s) => f.write(s)
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "n8n property builder" {
    let prop = N8nProperty.string("email", "Email").required().description("User email")
    let json = prop.to_json()
    assert_eq(json.get("name").as_string(), Some("email"))?
    assert_eq(json.get("required").as_bool(), Some(true))?
}

test "n8n node builder" {
    let node = N8nNode.new("myNode", "My Node")
        .description("A custom node")
        .add_property(N8nProperty.string("name", "Name").required())
    
    let json = node.to_json()
    assert_eq(json.get("name").as_string(), Some("myNode"))?
}

test "n8n options property" {
    let prop = N8nProperty.options("action", "Action", [
        N8nOption.new("Create", "create"),
        N8nOption.new("Update", "update")
    ])
    
    let json = prop.to_json()
    assert_eq(json.get("type").as_string(), Some("options"))?
}
