// =============================================================================
// Vibee OS â€” Swagger Module
// Swagger UI and documentation generation
// =============================================================================

use http::{Request, Response, Status, Method}
use openapi::{OpenApiSpec, Schema, Operation, PathItem, Parameter, ApiResponse, RequestBody}
use router::{Router}
use json::{JsonValue, Serialize}

// =============================================================================
// Swagger UI
// =============================================================================

/// Swagger UI configuration and server
struct SwaggerUI {
    spec: OpenApiSpec
    config: SwaggerConfig
    custom_css: Option<String>
    custom_js: Option<String>
}

impl SwaggerUI {
    /// Create Swagger UI from OpenAPI spec
    fn new(spec: OpenApiSpec) -> Self {
        SwaggerUI {
            spec: spec,
            config: SwaggerConfig.default(),
            custom_css: None,
            custom_js: None
        }
    }
    
    /// Create from spec file
    fn from_file(path: String) -> Result<Self, SwaggerError> {
        let content = fs.read_string(path)?
        let spec = if path.ends_with(".yaml") || path.ends_with(".yml") {
            OpenApiSpec.from_yaml(content)?
        } else {
            OpenApiSpec.from_json(content)?
        }
        Ok(Self.new(spec))
    }
    
    /// Create from URL
    fn from_url(url: String) -> Result<Self, SwaggerError> {
        let response = http.get(url)?
        let spec = OpenApiSpec.from_json(response.text())?
        Ok(Self.new(spec))
    }
    
    fn config(cfg: SwaggerConfig) -> Self { self.config = cfg; self }
    fn custom_css(css: String) -> Self { self.custom_css = Some(css); self }
    fn custom_js(js: String) -> Self { self.custom_js = Some(js); self }
    
    /// Generate HTML for Swagger UI
    fn render_html() -> String {
        let spec_json = self.spec.to_json()
        let config_json = json.encode(self.config)
        
        format!(r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title} - Swagger UI</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css">
    {custom_css}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"></script>
    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-standalone-preset.js"></script>
    <script>
        window.onload = function() {{
            const spec = {spec};
            const config = {config};
            
            SwaggerUIBundle({{
                spec: spec,
                dom_id: '#swagger-ui',
                deepLinking: config.deep_linking,
                displayOperationId: config.display_operation_id,
                defaultModelsExpandDepth: config.default_models_expand_depth,
                defaultModelExpandDepth: config.default_model_expand_depth,
                displayRequestDuration: config.display_request_duration,
                docExpansion: config.doc_expansion,
                filter: config.filter,
                showExtensions: config.show_extensions,
                showCommonExtensions: config.show_common_extensions,
                tryItOutEnabled: config.try_it_out_enabled,
                supportedSubmitMethods: config.supported_submit_methods,
                validatorUrl: config.validator_url,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout"
            }});
        }};
    </script>
    {custom_js}
</body>
</html>"#,
            title = self.spec.info.title,
            spec = spec_json,
            config = config_json,
            custom_css = self.custom_css.map(|css| format!("<style>{}</style>", css)).unwrap_or(""),
            custom_js = self.custom_js.map(|js| format!("<script>{}</script>", js)).unwrap_or("")
        )
    }
    
    /// Mount Swagger UI routes on router
    fn mount(router: Router, base_path: String = "/docs") -> Router {
        let ui = self
        
        // Swagger UI HTML
        router.get(base_path, |_| Response.ok().html(ui.render_html()))
        
        // OpenAPI spec JSON
        router.get(format!("{}/openapi.json", base_path), |_| Response.ok().json(ui.spec))
        
        // OpenAPI spec YAML
        router.get(format!("{}/openapi.yaml", base_path), |_| {
            Response.ok()
                .header("Content-Type", "text/yaml")
                .body(ui.spec.to_yaml().as_bytes())
        })
        
        router
    }
    
    /// Create standalone HTTP handler
    fn handler() -> fn(Request) -> Response {
        let html = self.render_html()
        |req| {
            match req.path {
                p if p.ends_with("/openapi.json") => Response.ok().json(self.spec),
                p if p.ends_with("/openapi.yaml") => Response.ok().header("Content-Type", "text/yaml").body(self.spec.to_yaml().as_bytes()),
                _ => Response.ok().html(html.clone())
            }
        }
    }
}

/// Swagger UI configuration
struct SwaggerConfig {
    deep_linking: Bool
    display_operation_id: Bool
    default_models_expand_depth: Int
    default_model_expand_depth: Int
    display_request_duration: Bool
    doc_expansion: String  // "list", "full", "none"
    filter: Bool
    show_extensions: Bool
    show_common_extensions: Bool
    try_it_out_enabled: Bool
    supported_submit_methods: [String]
    validator_url: Option<String>
    persist_authorization: Bool
}

impl SwaggerConfig {
    fn default() -> Self {
        SwaggerConfig {
            deep_linking: true,
            display_operation_id: false,
            default_models_expand_depth: 1,
            default_model_expand_depth: 1,
            display_request_duration: true,
            doc_expansion: "list",
            filter: true,
            show_extensions: false,
            show_common_extensions: true,
            try_it_out_enabled: true,
            supported_submit_methods: ["get", "post", "put", "delete", "patch"],
            validator_url: None,
            persist_authorization: true
        }
    }
    
    fn minimal() -> Self {
        var cfg = Self.default()
        cfg.filter = false
        cfg.try_it_out_enabled = false
        cfg.doc_expansion = "none"
        cfg
    }
    
    fn expanded() -> Self {
        var cfg = Self.default()
        cfg.doc_expansion = "full"
        cfg.default_models_expand_depth = 3
        cfg
    }
}

// =============================================================================
// Documentation Generator
// =============================================================================

/// Generate documentation from code annotations
struct DocGenerator {
    title: String
    version: String
    description: Option<String>
    routes: [DocumentedRoute]
    schemas: Map<String, Schema>
}

impl DocGenerator {
    fn new(title: String, version: String) -> Self {
        DocGenerator {
            title: title,
            version: version,
            description: None,
            routes: [],
            schemas: Map.empty()
        }
    }
    
    fn description(d: String) -> Self { self.description = Some(d); self }
    
    /// Add documented route
    fn route(route: DocumentedRoute) -> Self {
        self.routes.push(route)
        self
    }
    
    /// Add schema
    fn schema(name: String, schema: Schema) -> Self {
        self.schemas.set(name, schema)
        self
    }
    
    /// Generate OpenAPI spec
    fn generate() -> OpenApiSpec {
        var spec = OpenApiSpec.new(self.title, self.version)
        
        if let Some(desc) = self.description {
            spec = spec.description(desc)
        }
        
        // Add schemas
        for (name, schema) in self.schemas.iter() {
            spec = spec.schema(name, schema)
        }
        
        // Group routes by path
        var paths: Map<String, PathItem> = Map.empty()
        
        for route in self.routes {
            let path_item = paths.entry(route.path).or_insert(PathItem.new())
            let operation = route.to_operation()
            
            match route.method {
                Method.GET => path_item.get = Some(operation),
                Method.POST => path_item.post = Some(operation),
                Method.PUT => path_item.put = Some(operation),
                Method.DELETE => path_item.delete = Some(operation),
                Method.PATCH => path_item.patch = Some(operation),
                _ => {}
            }
        }
        
        for (path, item) in paths.iter() {
            spec = spec.path(path, item)
        }
        
        spec
    }
    
    /// Generate Swagger UI
    fn swagger_ui() -> SwaggerUI {
        SwaggerUI.new(self.generate())
    }
}

/// Documented route
struct DocumentedRoute {
    method: Method
    path: String
    operation_id: Option<String>
    summary: Option<String>
    description: Option<String>
    tags: [String]
    parameters: [Parameter]
    request_body: Option<RequestBody>
    responses: Map<String, ApiResponse>
    deprecated: Bool
    security: [String]
}

impl DocumentedRoute {
    fn new(method: Method, path: String) -> Self {
        DocumentedRoute {
            method: method,
            path: path,
            operation_id: None,
            summary: None,
            description: None,
            tags: [],
            parameters: [],
            request_body: None,
            responses: Map.empty(),
            deprecated: false,
            security: []
        }
    }
    
    fn get(path: String) -> Self { Self.new(Method.GET, path) }
    fn post(path: String) -> Self { Self.new(Method.POST, path) }
    fn put(path: String) -> Self { Self.new(Method.PUT, path) }
    fn delete(path: String) -> Self { Self.new(Method.DELETE, path) }
    fn patch(path: String) -> Self { Self.new(Method.PATCH, path) }
    
    fn id(id: String) -> Self { self.operation_id = Some(id); self }
    fn summary(s: String) -> Self { self.summary = Some(s); self }
    fn description(d: String) -> Self { self.description = Some(d); self }
    fn tag(t: String) -> Self { self.tags.push(t); self }
    fn param(p: Parameter) -> Self { self.parameters.push(p); self }
    fn body(b: RequestBody) -> Self { self.request_body = Some(b); self }
    fn response(code: String, r: ApiResponse) -> Self { self.responses.set(code, r); self }
    fn deprecated() -> Self { self.deprecated = true; self }
    fn secure(scheme: String) -> Self { self.security.push(scheme); self }
    
    fn to_operation() -> Operation {
        var op = Operation.new()
        if let Some(id) = self.operation_id { op = op.id(id) }
        if let Some(s) = self.summary { op = op.summary(s) }
        if let Some(d) = self.description { op = op.description(d) }
        for t in self.tags { op = op.tag(t) }
        for p in self.parameters { op = op.param(p) }
        if let Some(b) = self.request_body { op = op.body(b) }
        for (code, r) in self.responses.iter() { op = op.response(code, r) }
        if self.deprecated { op = op.deprecated() }
        op
    }
}

// =============================================================================
// ReDoc Support
// =============================================================================

/// ReDoc documentation UI
struct ReDoc {
    spec: OpenApiSpec
    config: ReDocConfig
}

impl ReDoc {
    fn new(spec: OpenApiSpec) -> Self {
        ReDoc { spec: spec, config: ReDocConfig.default() }
    }
    
    fn config(cfg: ReDocConfig) -> Self { self.config = cfg; self }
    
    fn render_html() -> String {
        format!(r#"<!DOCTYPE html>
<html>
<head>
    <title>{title} - API Documentation</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
    <style>body {{ margin: 0; padding: 0; }}</style>
</head>
<body>
    <redoc spec-url='openapi.json' 
           hide-download-button="{hide_download}"
           hide-hostname="{hide_hostname}"
           expand-responses="{expand_responses}"
           path-in-middle-panel="{path_in_middle}"
           native-scrollbars="{native_scrollbars}">
    </redoc>
    <script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"></script>
</body>
</html>"#,
            title = self.spec.info.title,
            hide_download = self.config.hide_download_button,
            hide_hostname = self.config.hide_hostname,
            expand_responses = self.config.expand_responses,
            path_in_middle = self.config.path_in_middle_panel,
            native_scrollbars = self.config.native_scrollbars
        )
    }
    
    fn mount(router: Router, base_path: String = "/redoc") -> Router {
        let ui = self
        router.get(base_path, |_| Response.ok().html(ui.render_html()))
        router.get(format!("{}/openapi.json", base_path), |_| Response.ok().json(ui.spec))
        router
    }
}

struct ReDocConfig {
    hide_download_button: Bool
    hide_hostname: Bool
    expand_responses: String
    path_in_middle_panel: Bool
    native_scrollbars: Bool
    theme: ReDocTheme
}

impl ReDocConfig {
    fn default() -> Self {
        ReDocConfig {
            hide_download_button: false,
            hide_hostname: false,
            expand_responses: "200,201",
            path_in_middle_panel: false,
            native_scrollbars: false,
            theme: ReDocTheme.default()
        }
    }
}

struct ReDocTheme {
    primary_color: String
    font_family: String
    code_font_family: String
}

impl ReDocTheme {
    fn default() -> Self {
        ReDocTheme {
            primary_color: "#32329f",
            font_family: "Roboto, sans-serif",
            code_font_family: "Courier, monospace"
        }
    }
}

// =============================================================================
// Annotations for Auto-Documentation
// =============================================================================

/// Annotation for API endpoints
struct ApiDoc {
    summary: String
    description: Option<String>
    tags: [String]
    deprecated: Bool
}

impl ApiDoc {
    fn new(summary: String) -> Self {
        ApiDoc { summary: summary, description: None, tags: [], deprecated: false }
    }
}

/// Annotation for request parameters
struct ParamDoc {
    name: String
    description: String
    required: Bool
    example: Option<String>
}

/// Annotation for response
struct ResponseDoc {
    code: Int
    description: String
    schema: Option<String>
}

// =============================================================================
// Markdown Documentation
// =============================================================================

/// Generate Markdown documentation
struct MarkdownGenerator {
    spec: OpenApiSpec
}

impl MarkdownGenerator {
    fn new(spec: OpenApiSpec) -> Self { MarkdownGenerator { spec: spec } }
    
    fn generate() -> String {
        var md = format!("# {}\n\n", self.spec.info.title)
        
        if let Some(desc) = self.spec.info.description {
            md += format!("{}\n\n", desc)
        }
        
        md += format!("**Version:** {}\n\n", self.spec.info.version)
        
        // Servers
        if !self.spec.servers.is_empty() {
            md += "## Servers\n\n"
            for server in self.spec.servers {
                md += format!("- `{}`", server.url)
                if let Some(desc) = server.description {
                    md += format!(" - {}", desc)
                }
                md += "\n"
            }
            md += "\n"
        }
        
        // Endpoints
        md += "## Endpoints\n\n"
        
        for (path, item) in self.spec.paths.iter() {
            md += self.render_path(path, item)
        }
        
        // Schemas
        if let Some(components) = self.spec.components {
            if !components.schemas.is_empty() {
                md += "## Schemas\n\n"
                for (name, schema) in components.schemas.iter() {
                    md += self.render_schema(name, schema)
                }
            }
        }
        
        md
    }
    
    fn render_path(path: String, item: PathItem) -> String {
        var md = ""
        
        for (method, op) in [
            ("GET", item.get),
            ("POST", item.post),
            ("PUT", item.put),
            ("DELETE", item.delete),
            ("PATCH", item.patch)
        ] {
            if let Some(operation) = op {
                md += format!("### {} `{}`\n\n", method, path)
                
                if let Some(summary) = operation.summary {
                    md += format!("**{}**\n\n", summary)
                }
                
                if let Some(desc) = operation.description {
                    md += format!("{}\n\n", desc)
                }
                
                if !operation.parameters.is_empty() {
                    md += "**Parameters:**\n\n"
                    md += "| Name | In | Required | Description |\n"
                    md += "|------|-----|----------|-------------|\n"
                    for param in operation.parameters {
                        md += format!("| {} | {} | {} | {} |\n",
                            param.name,
                            param.in_.to_string(),
                            if param.required { "Yes" } else { "No" },
                            param.description.unwrap_or("-")
                        )
                    }
                    md += "\n"
                }
                
                if !operation.responses.is_empty() {
                    md += "**Responses:**\n\n"
                    for (code, response) in operation.responses.iter() {
                        md += format!("- **{}**: {}\n", code, response.description)
                    }
                    md += "\n"
                }
            }
        }
        
        md
    }
    
    fn render_schema(name: String, schema: Schema) -> String {
        var md = format!("### {}\n\n", name)
        
        if let Some(desc) = schema.description {
            md += format!("{}\n\n", desc)
        }
        
        if !schema.properties.is_empty() {
            md += "| Property | Type | Required | Description |\n"
            md += "|----------|------|----------|-------------|\n"
            for (prop_name, prop_schema) in schema.properties.iter() {
                let type_str = prop_schema.type_.unwrap_or("any")
                let required = schema.required.contains(prop_name)
                let desc = prop_schema.description.unwrap_or("-")
                md += format!("| {} | {} | {} | {} |\n", prop_name, type_str, if required { "Yes" } else { "No" }, desc)
            }
            md += "\n"
        }
        
        md
    }
}

// =============================================================================
// Error Types
// =============================================================================

enum SwaggerError {
    ParseError(String)
    IoError(String)
    NetworkError(String)
}

// =============================================================================
// Tests
// =============================================================================

test "swagger ui creation" {
    let spec = OpenApiSpec.new("Test API", "1.0.0")
    let ui = SwaggerUI.new(spec)
    let html = ui.render_html()
    
    assert(html.contains("swagger-ui"))?
    assert(html.contains("Test API"))?
}

test "swagger config" {
    let config = SwaggerConfig.default()
    assert(config.try_it_out_enabled)?
    assert(config.deep_linking)?
    
    let minimal = SwaggerConfig.minimal()
    assert(!minimal.try_it_out_enabled)?
}

test "doc generator" {
    let docs = DocGenerator.new("My API", "1.0.0")
        .description("API description")
        .route(DocumentedRoute.get("/users")
            .id("listUsers")
            .summary("List users")
            .tag("users"))
    
    let spec = docs.generate()
    assert_eq(spec.info.title, "My API")?
    assert(spec.paths.contains("/users"))?
}

test "markdown generation" {
    let spec = OpenApiSpec.new("Test", "1.0.0")
        .path("/test", PathItem.new().get(Operation.new().summary("Test endpoint")))
    
    let md = MarkdownGenerator.new(spec).generate()
    assert(md.contains("# Test"))?
    assert(md.contains("GET `/test`"))?
}

test "redoc ui" {
    let spec = OpenApiSpec.new("API", "1.0.0")
    let redoc = ReDoc.new(spec)
    let html = redoc.render_html()
    
    assert(html.contains("redoc"))?
    assert(html.contains("API"))?
}
