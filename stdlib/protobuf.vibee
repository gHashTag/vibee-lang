// =============================================================================
// Vibee OS â€” Protocol Buffers Module
// Protocol Buffers serialization and deserialization
// =============================================================================

// -----------------------------------------------------------------------------
// Wire Types
// -----------------------------------------------------------------------------

/// Protocol Buffers wire types
enum WireType {
    Varint          // 0 - int32, int64, uint32, uint64, sint32, sint64, bool, enum
    Fixed64         // 1 - fixed64, sfixed64, double
    LengthDelimited // 2 - string, bytes, embedded messages, packed repeated fields
    StartGroup      // 3 - deprecated
    EndGroup        // 4 - deprecated
    Fixed32         // 5 - fixed32, sfixed32, float
    
    fn from_int(n: Int) -> Option<WireType> {
        match n {
            0 => Some(.Varint)
            1 => Some(.Fixed64)
            2 => Some(.LengthDelimited)
            3 => Some(.StartGroup)
            4 => Some(.EndGroup)
            5 => Some(.Fixed32)
            _ => None
        }
    }
    
    fn to_int() -> Int {
        match self {
            .Varint => 0
            .Fixed64 => 1
            .LengthDelimited => 2
            .StartGroup => 3
            .EndGroup => 4
            .Fixed32 => 5
        }
    }
}

// -----------------------------------------------------------------------------
// Protobuf Value
// -----------------------------------------------------------------------------

/// Protobuf field value
enum Value {
    Varint(Int64)
    Fixed64(UInt64)
    Fixed32(UInt32)
    Bytes([UInt8])
    String(String)
    Message(Message)
    Repeated([Value])
    
    fn as_int() -> Option<Int64> {
        match self {
            .Varint(v) => Some(v)
            _ => None
        }
    }
    
    fn as_uint() -> Option<UInt64> {
        match self {
            .Varint(v) => Some(v as UInt64)
            .Fixed64(v) => Some(v)
            .Fixed32(v) => Some(v as UInt64)
            _ => None
        }
    }
    
    fn as_sint32() -> Option<Int32> {
        match self {
            .Varint(v) => Some(zigzag_decode32(v as UInt32))
            _ => None
        }
    }
    
    fn as_sint64() -> Option<Int64> {
        match self {
            .Varint(v) => Some(zigzag_decode64(v as UInt64))
            _ => None
        }
    }
    
    fn as_bool() -> Option<Bool> {
        match self {
            .Varint(v) => Some(v != 0)
            _ => None
        }
    }
    
    fn as_float() -> Option<Float32> {
        match self {
            .Fixed32(v) => Some(Float32.from_bits(v))
            _ => None
        }
    }
    
    fn as_double() -> Option<Float64> {
        match self {
            .Fixed64(v) => Some(Float64.from_bits(v))
            _ => None
        }
    }
    
    fn as_string() -> Option<String> {
        match self {
            .String(s) => Some(s)
            .Bytes(b) => String.from_utf8(b).ok()
            _ => None
        }
    }
    
    fn as_bytes() -> Option<[UInt8]> {
        match self {
            .Bytes(b) => Some(b)
            .String(s) => Some(s.as_bytes())
            _ => None
        }
    }
    
    fn as_message() -> Option<Message> {
        match self {
            .Message(m) => Some(m)
            _ => None
        }
    }
    
    fn as_repeated() -> Option<[Value]> {
        match self {
            .Repeated(r) => Some(r)
            _ => None
        }
    }
}

// -----------------------------------------------------------------------------
// Message
// -----------------------------------------------------------------------------

/// Protobuf message (collection of fields)
struct Message {
    fields: Map<Int, Value>
    
    fn new() -> Self {
        Message { fields: Map.new() }
    }
    
    fn get(field_number: Int) -> Option<Value> {
        self.fields.get(field_number)
    }
    
    fn set(field_number: Int, value: Value) {
        self.fields.insert(field_number, value)
    }
    
    fn set_int(field_number: Int, value: Int64) {
        self.fields.insert(field_number, Value.Varint(value))
    }
    
    fn set_uint(field_number: Int, value: UInt64) {
        self.fields.insert(field_number, Value.Varint(value as Int64))
    }
    
    fn set_sint32(field_number: Int, value: Int32) {
        self.fields.insert(field_number, Value.Varint(zigzag_encode32(value) as Int64))
    }
    
    fn set_sint64(field_number: Int, value: Int64) {
        self.fields.insert(field_number, Value.Varint(zigzag_encode64(value) as Int64))
    }
    
    fn set_bool(field_number: Int, value: Bool) {
        self.fields.insert(field_number, Value.Varint(if value { 1 } else { 0 }))
    }
    
    fn set_float(field_number: Int, value: Float32) {
        self.fields.insert(field_number, Value.Fixed32(value.to_bits()))
    }
    
    fn set_double(field_number: Int, value: Float64) {
        self.fields.insert(field_number, Value.Fixed64(value.to_bits()))
    }
    
    fn set_string(field_number: Int, value: String) {
        self.fields.insert(field_number, Value.String(value))
    }
    
    fn set_bytes(field_number: Int, value: [UInt8]) {
        self.fields.insert(field_number, Value.Bytes(value))
    }
    
    fn set_message(field_number: Int, value: Message) {
        self.fields.insert(field_number, Value.Message(value))
    }
    
    fn add_repeated(field_number: Int, value: Value) {
        match self.fields.get(field_number) {
            Some(Value.Repeated(r)) => {
                r.push(value)
            }
            _ => {
                self.fields.insert(field_number, Value.Repeated([value]))
            }
        }
    }
    
    fn has(field_number: Int) -> Bool {
        self.fields.contains_key(field_number)
    }
    
    fn clear(field_number: Int) {
        self.fields.remove(field_number)
    }
    
    fn clear_all() {
        self.fields.clear()
    }
}

// -----------------------------------------------------------------------------
// Encoder
// -----------------------------------------------------------------------------

/// Protobuf encoder
actor Encoder {
    state buffer: [UInt8]
    
    fn new() -> Self {
        Encoder { buffer: [] }
    }
    
    /// Encode a message
    fn encode(msg: Message) -> [UInt8] {
        self.buffer.clear()
        self.write_message(msg)
        self.buffer.clone()
    }
    
    fn write_message(msg: Message) {
        for (field_number, value) in msg.fields.iter().sorted_by_key(|(k, _)| k) {
            self.write_field(field_number, value)
        }
    }
    
    fn write_field(field_number: Int, value: Value) {
        match value {
            .Varint(v) => {
                self.write_tag(field_number, WireType.Varint)
                self.write_varint(v as UInt64)
            }
            .Fixed64(v) => {
                self.write_tag(field_number, WireType.Fixed64)
                self.write_fixed64(v)
            }
            .Fixed32(v) => {
                self.write_tag(field_number, WireType.Fixed32)
                self.write_fixed32(v)
            }
            .Bytes(b) => {
                self.write_tag(field_number, WireType.LengthDelimited)
                self.write_varint(b.len() as UInt64)
                self.buffer.extend(b)
            }
            .String(s) => {
                self.write_tag(field_number, WireType.LengthDelimited)
                let bytes = s.as_bytes()
                self.write_varint(bytes.len() as UInt64)
                self.buffer.extend(bytes)
            }
            .Message(m) => {
                self.write_tag(field_number, WireType.LengthDelimited)
                let nested = Encoder.new().encode(m)
                self.write_varint(nested.len() as UInt64)
                self.buffer.extend(nested)
            }
            .Repeated(items) => {
                for item in items {
                    self.write_field(field_number, item)
                }
            }
        }
    }
    
    fn write_tag(field_number: Int, wire_type: WireType) {
        let tag = ((field_number << 3) | wire_type.to_int()) as UInt64
        self.write_varint(tag)
    }
    
    fn write_varint(value: UInt64) {
        var v = value
        while v >= 0x80 {
            self.buffer.push(((v & 0x7F) | 0x80) as UInt8)
            v >>= 7
        }
        self.buffer.push(v as UInt8)
    }
    
    fn write_fixed32(value: UInt32) {
        self.buffer.push((value & 0xFF) as UInt8)
        self.buffer.push(((value >> 8) & 0xFF) as UInt8)
        self.buffer.push(((value >> 16) & 0xFF) as UInt8)
        self.buffer.push(((value >> 24) & 0xFF) as UInt8)
    }
    
    fn write_fixed64(value: UInt64) {
        for i in 0..8 {
            self.buffer.push(((value >> (i * 8)) & 0xFF) as UInt8)
        }
    }
    
    /// Encode packed repeated field
    fn write_packed_varint(field_number: Int, values: [Int64]) {
        self.write_tag(field_number, WireType.LengthDelimited)
        
        var packed = Encoder.new()
        for v in values {
            packed.write_varint(v as UInt64)
        }
        
        self.write_varint(packed.buffer.len() as UInt64)
        self.buffer.extend(packed.buffer)
    }
    
    fn write_packed_fixed32(field_number: Int, values: [UInt32]) {
        self.write_tag(field_number, WireType.LengthDelimited)
        self.write_varint((values.len() * 4) as UInt64)
        
        for v in values {
            self.write_fixed32(v)
        }
    }
    
    fn write_packed_fixed64(field_number: Int, values: [UInt64]) {
        self.write_tag(field_number, WireType.LengthDelimited)
        self.write_varint((values.len() * 8) as UInt64)
        
        for v in values {
            self.write_fixed64(v)
        }
    }
}

// -----------------------------------------------------------------------------
// Decoder
// -----------------------------------------------------------------------------

/// Protobuf decoder
actor Decoder {
    state data: [UInt8]
    state pos: Int
    
    fn new(data: [UInt8]) -> Self {
        Decoder { data: data, pos: 0 }
    }
    
    /// Decode bytes to message
    fn decode(data: [UInt8]) -> Result<Message, ProtobufError> {
        var decoder = Decoder.new(data)
        decoder.read_message()
    }
    
    fn read_message() -> Result<Message, ProtobufError> {
        var msg = Message.new()
        
        while self.pos < self.data.len() {
            let tag = self.read_varint()? as Int
            let field_number = tag >> 3
            let wire_type = WireType.from_int(tag & 0x07)
                .ok_or(ProtobufError.InvalidWireType(tag & 0x07))?
            
            let value = self.read_value(wire_type)?
            
            // Handle repeated fields
            if msg.has(field_number) {
                match msg.get(field_number) {
                    Some(Value.Repeated(r)) => {
                        r.push(value)
                    }
                    Some(existing) => {
                        msg.set(field_number, Value.Repeated([existing, value]))
                    }
                    None => {
                        msg.set(field_number, value)
                    }
                }
            } else {
                msg.set(field_number, value)
            }
        }
        
        Ok(msg)
    }
    
    fn read_value(wire_type: WireType) -> Result<Value, ProtobufError> {
        match wire_type {
            .Varint => {
                let v = self.read_varint()?
                Ok(Value.Varint(v as Int64))
            }
            .Fixed64 => {
                let v = self.read_fixed64()?
                Ok(Value.Fixed64(v))
            }
            .Fixed32 => {
                let v = self.read_fixed32()?
                Ok(Value.Fixed32(v))
            }
            .LengthDelimited => {
                let len = self.read_varint()? as Int
                let bytes = self.read_bytes(len)?
                Ok(Value.Bytes(bytes))
            }
            .StartGroup | .EndGroup => {
                Err(ProtobufError.DeprecatedGroupType)
            }
        }
    }
    
    fn read_varint() -> Result<UInt64, ProtobufError> {
        var result: UInt64 = 0
        var shift = 0
        
        loop {
            if self.pos >= self.data.len() {
                return Err(ProtobufError.UnexpectedEof)
            }
            
            let byte = self.data[self.pos]
            self.pos += 1
            
            result |= ((byte & 0x7F) as UInt64) << shift
            
            if (byte & 0x80) == 0 {
                break
            }
            
            shift += 7
            if shift >= 64 {
                return Err(ProtobufError.VarintOverflow)
            }
        }
        
        Ok(result)
    }
    
    fn read_fixed32() -> Result<UInt32, ProtobufError> {
        if self.pos + 4 > self.data.len() {
            return Err(ProtobufError.UnexpectedEof)
        }
        
        let result = (self.data[self.pos] as UInt32)
            | ((self.data[self.pos + 1] as UInt32) << 8)
            | ((self.data[self.pos + 2] as UInt32) << 16)
            | ((self.data[self.pos + 3] as UInt32) << 24)
        
        self.pos += 4
        Ok(result)
    }
    
    fn read_fixed64() -> Result<UInt64, ProtobufError> {
        if self.pos + 8 > self.data.len() {
            return Err(ProtobufError.UnexpectedEof)
        }
        
        var result: UInt64 = 0
        for i in 0..8 {
            result |= (self.data[self.pos + i] as UInt64) << (i * 8)
        }
        
        self.pos += 8
        Ok(result)
    }
    
    fn read_bytes(len: Int) -> Result<[UInt8], ProtobufError> {
        if self.pos + len > self.data.len() {
            return Err(ProtobufError.UnexpectedEof)
        }
        
        let result = self.data[self.pos..(self.pos + len)].to_vec()
        self.pos += len
        Ok(result)
    }
    
    /// Decode nested message from bytes value
    fn decode_nested(value: Value) -> Result<Message, ProtobufError> {
        match value {
            .Bytes(b) => Decoder.decode(b)
            .Message(m) => Ok(m)
            _ => Err(ProtobufError.InvalidType("Expected bytes or message"))
        }
    }
    
    /// Decode packed repeated varints
    fn decode_packed_varint(value: Value) -> Result<[Int64], ProtobufError> {
        match value {
            .Bytes(b) => {
                var decoder = Decoder.new(b)
                var result = []
                while decoder.pos < decoder.data.len() {
                    result.push(decoder.read_varint()? as Int64)
                }
                Ok(result)
            }
            _ => Err(ProtobufError.InvalidType("Expected bytes"))
        }
    }
    
    /// Decode packed repeated fixed32
    fn decode_packed_fixed32(value: Value) -> Result<[UInt32], ProtobufError> {
        match value {
            .Bytes(b) => {
                var decoder = Decoder.new(b)
                var result = []
                while decoder.pos < decoder.data.len() {
                    result.push(decoder.read_fixed32()?)
                }
                Ok(result)
            }
            _ => Err(ProtobufError.InvalidType("Expected bytes"))
        }
    }
}

// -----------------------------------------------------------------------------
// ZigZag Encoding (for signed integers)
// -----------------------------------------------------------------------------

fn zigzag_encode32(n: Int32) -> UInt32 {
    ((n << 1) ^ (n >> 31)) as UInt32
}

fn zigzag_decode32(n: UInt32) -> Int32 {
    ((n >> 1) ^ (-(n & 1) as UInt32)) as Int32
}

fn zigzag_encode64(n: Int64) -> UInt64 {
    ((n << 1) ^ (n >> 63)) as UInt64
}

fn zigzag_decode64(n: UInt64) -> Int64 {
    ((n >> 1) ^ (-(n & 1) as UInt64)) as Int64
}

// -----------------------------------------------------------------------------
// Schema Definition
// -----------------------------------------------------------------------------

/// Field type in schema
enum FieldType {
    Double
    Float
    Int32
    Int64
    UInt32
    UInt64
    SInt32
    SInt64
    Fixed32
    Fixed64
    SFixed32
    SFixed64
    Bool
    String
    Bytes
    Enum(String)
    Message(String)
}

/// Field label
enum FieldLabel {
    Optional
    Required
    Repeated
}

/// Field definition
struct FieldDef {
    name: String
    number: Int
    field_type: FieldType
    label: FieldLabel
    default_value: Option<Value>
    packed: Bool
}

/// Message definition
struct MessageDef {
    name: String
    fields: Map<Int, FieldDef>
    nested_messages: Map<String, MessageDef>
    nested_enums: Map<String, EnumDef>
    
    fn new(name: String) -> Self {
        MessageDef {
            name: name,
            fields: Map.new(),
            nested_messages: Map.new(),
            nested_enums: Map.new()
        }
    }
    
    fn add_field(field: FieldDef) {
        self.fields.insert(field.number, field)
    }
    
    fn get_field(number: Int) -> Option<FieldDef> {
        self.fields.get(number)
    }
    
    fn get_field_by_name(name: String) -> Option<FieldDef> {
        self.fields.values().find(|f| f.name == name)
    }
}

/// Enum definition
struct EnumDef {
    name: String
    values: Map<String, Int>
    
    fn new(name: String) -> Self {
        EnumDef { name: name, values: Map.new() }
    }
    
    fn add_value(name: String, number: Int) {
        self.values.insert(name, number)
    }
}

// -----------------------------------------------------------------------------
// Serializable Trait
// -----------------------------------------------------------------------------

/// Trait for types that can be serialized to protobuf
trait ProtoSerializable {
    fn to_proto() -> Message
    fn from_proto(msg: Message) -> Result<Self, ProtobufError>
}

// -----------------------------------------------------------------------------
// Builder Pattern
// -----------------------------------------------------------------------------

/// Message builder for fluent API
struct MessageBuilder {
    message: Message
    
    fn new() -> Self {
        MessageBuilder { message: Message.new() }
    }
    
    fn int(field: Int, value: Int64) -> Self {
        self.message.set_int(field, value)
        self
    }
    
    fn uint(field: Int, value: UInt64) -> Self {
        self.message.set_uint(field, value)
        self
    }
    
    fn bool(field: Int, value: Bool) -> Self {
        self.message.set_bool(field, value)
        self
    }
    
    fn float(field: Int, value: Float32) -> Self {
        self.message.set_float(field, value)
        self
    }
    
    fn double(field: Int, value: Float64) -> Self {
        self.message.set_double(field, value)
        self
    }
    
    fn string(field: Int, value: String) -> Self {
        self.message.set_string(field, value)
        self
    }
    
    fn bytes(field: Int, value: [UInt8]) -> Self {
        self.message.set_bytes(field, value)
        self
    }
    
    fn message(field: Int, value: Message) -> Self {
        self.message.set_message(field, value)
        self
    }
    
    fn repeated(field: Int, values: [Value]) -> Self {
        self.message.set(field, Value.Repeated(values))
        self
    }
    
    fn build() -> Message {
        self.message
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ProtobufError {
    UnexpectedEof
    VarintOverflow
    InvalidWireType(Int)
    InvalidType(String)
    DeprecatedGroupType
    MissingRequiredField(Int)
    InvalidUtf8
    SchemaViolation(String)
    
    fn message() -> String {
        match self {
            .UnexpectedEof => "Unexpected end of data"
            .VarintOverflow => "Varint overflow"
            .InvalidWireType(t) => "Invalid wire type: \(t)"
            .InvalidType(s) => "Invalid type: \(s)"
            .DeprecatedGroupType => "Deprecated group wire type"
            .MissingRequiredField(f) => "Missing required field: \(f)"
            .InvalidUtf8 => "Invalid UTF-8 string"
            .SchemaViolation(s) => "Schema violation: \(s)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Encode a message to bytes
fn encode(msg: Message) -> [UInt8] {
    Encoder.new().encode(msg)
}

/// Decode bytes to a message
fn decode(data: [UInt8]) -> Result<Message, ProtobufError> {
    Decoder.decode(data)
}

/// Create a new message builder
fn builder() -> MessageBuilder {
    MessageBuilder.new()
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "encode varint" {
    var encoder = Encoder.new()
    encoder.write_varint(1)
    assert(encoder.buffer == [0x01])
    
    encoder.buffer.clear()
    encoder.write_varint(300)
    assert(encoder.buffer == [0xAC, 0x02])
}

test "decode varint" {
    var decoder = Decoder.new([0xAC, 0x02])
    let value = decoder.read_varint()?
    assert(value == 300)
}

test "encode message" {
    let msg = builder()
        .int(1, 150)
        .string(2, "testing")
        .build()
    
    let encoded = encode(msg)
    assert(encoded.len() > 0)
}

test "roundtrip" {
    let original = builder()
        .int(1, 42)
        .string(2, "hello")
        .bool(3, true)
        .build()
    
    let encoded = encode(original)
    let decoded = decode(encoded)?
    
    assert(decoded.get(1)?.as_int() == Some(42))
    assert(decoded.get(2)?.as_bytes()?.to_string() == "hello")
    assert(decoded.get(3)?.as_bool() == Some(true))
}

test "zigzag encoding" {
    assert(zigzag_encode32(0) == 0)
    assert(zigzag_encode32(-1) == 1)
    assert(zigzag_encode32(1) == 2)
    assert(zigzag_encode32(-2) == 3)
    
    assert(zigzag_decode32(0) == 0)
    assert(zigzag_decode32(1) == -1)
    assert(zigzag_decode32(2) == 1)
    assert(zigzag_decode32(3) == -2)
}

test "nested message" {
    let inner = builder()
        .string(1, "inner")
        .build()
    
    let outer = builder()
        .message(1, inner)
        .int(2, 100)
        .build()
    
    let encoded = encode(outer)
    let decoded = decode(encoded)?
    
    let inner_bytes = decoded.get(1)?.as_bytes()?
    let inner_decoded = decode(inner_bytes)?
    
    assert(inner_decoded.get(1)?.as_bytes()?.to_string() == "inner")
}

test "packed repeated" {
    var encoder = Encoder.new()
    encoder.write_packed_varint(1, [1, 2, 3, 150, 300])
    
    let decoded = decode(encoder.buffer)?
    let packed = decoded.get(1)?
    let values = Decoder.decode_packed_varint(packed)?
    
    assert(values == [1, 2, 3, 150, 300])
}
