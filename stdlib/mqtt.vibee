// =============================================================================
// Vibee OS â€” MQTT Module
// Message Queuing Telemetry Transport protocol for IoT
// =============================================================================

// -----------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------

/// MQTT client options
struct MqttOptions {
    client_id: String
    broker_host: String
    broker_port: UInt16
    keep_alive: Duration
    clean_session: Bool
    username: Option<String>
    password: Option<String>
    tls: Option<TlsConfig>
    will: Option<LastWill>
    protocol: MqttProtocol
    
    fn new(client_id: String, host: String) -> Self {
        MqttOptions {
            client_id: client_id,
            broker_host: host,
            broker_port: 1883,
            keep_alive: Duration.seconds(60),
            clean_session: true,
            username: None,
            password: None,
            tls: None,
            will: None,
            protocol: MqttProtocol.V311
        }
    }
    
    fn with_port(port: UInt16) -> Self {
        self.broker_port = port
        self
    }
    
    fn with_credentials(username: String, password: String) -> Self {
        self.username = Some(username)
        self.password = Some(password)
        self
    }
    
    fn with_tls(config: TlsConfig) -> Self {
        self.tls = Some(config)
        if self.broker_port == 1883 {
            self.broker_port = 8883
        }
        self
    }
    
    fn with_will(will: LastWill) -> Self {
        self.will = Some(will)
        self
    }
    
    fn with_clean_session(clean: Bool) -> Self {
        self.clean_session = clean
        self
    }
    
    fn mqtt5() -> Self {
        self.protocol = MqttProtocol.V5
        self
    }
}

enum MqttProtocol { V311, V5 }

/// TLS configuration
struct TlsConfig {
    ca_cert: Option<String>
    client_cert: Option<String>
    client_key: Option<String>
    verify: Bool
    
    fn default() -> Self {
        TlsConfig { ca_cert: None, client_cert: None, client_key: None, verify: true }
    }
}

/// Last Will and Testament
struct LastWill {
    topic: String
    payload: [Byte]
    qos: QoS
    retain: Bool
    
    fn new(topic: String, payload: [Byte]) -> Self {
        LastWill { topic: topic, payload: payload, qos: QoS.AtLeastOnce, retain: false }
    }
    
    fn with_qos(qos: QoS) -> Self { self.qos = qos; self }
    fn retained() -> Self { self.retain = true; self }
}

// -----------------------------------------------------------------------------
// Quality of Service
// -----------------------------------------------------------------------------

enum QoS {
    AtMostOnce   // QoS 0 - Fire and forget
    AtLeastOnce  // QoS 1 - Acknowledged delivery
    ExactlyOnce  // QoS 2 - Assured delivery
    
    fn value() -> Int {
        match self {
            .AtMostOnce => 0
            .AtLeastOnce => 1
            .ExactlyOnce => 2
        }
    }
}

// -----------------------------------------------------------------------------
// Client
// -----------------------------------------------------------------------------

/// MQTT client
actor MqttClient {
    state options: MqttOptions
    state connected: Bool
    state subscriptions: Map<String, MqttSubscription>
    state pending_publish: Map<UInt16, Channel<PublishResult>>
    state next_packet_id: UInt16
    
    fn new(options: MqttOptions) -> Self {
        MqttClient {
            options: options,
            connected: false,
            subscriptions: Map.empty(),
            pending_publish: Map.empty(),
            next_packet_id: 1
        }
    }
    
    /// Connect to broker
    on connect() -> Result<ConnAck, MqttError> {
        @native("mqtt_connect", self.options)
        self.connected = true
        Ok(ConnAck { session_present: false, return_code: ConnectReturnCode.Accepted })
    }
    
    /// Disconnect from broker
    on disconnect() -> Result<(), MqttError> {
        @native("mqtt_disconnect")
        self.connected = false
        Ok(())
    }
    
    /// Publish message
    on publish(topic: String, payload: [Byte], qos: QoS, retain: Bool) -> Result<(), MqttError> {
        if !self.connected { return Err(MqttError.NotConnected) }
        
        let packet_id = if qos != QoS.AtMostOnce {
            let id = self.next_packet_id
            self.next_packet_id += 1
            Some(id)
        } else { None }
        
        @native("mqtt_publish", topic, payload, qos.value(), retain, packet_id)
    }
    
    /// Publish with builder
    on publish_message(message: MqttMessage) -> Result<(), MqttError> {
        self.publish(message.topic, message.payload, message.qos, message.retain)
    }
    
    /// Subscribe to topic
    on subscribe(topic: String, qos: QoS) -> Result<MqttSubscription, MqttError> {
        if !self.connected { return Err(MqttError.NotConnected) }
        
        let sub = MqttSubscription.new(topic, qos)
        @native("mqtt_subscribe", topic, qos.value(), sub)
        self.subscriptions.set(topic, sub)
        Ok(sub)
    }
    
    /// Subscribe to multiple topics
    on subscribe_many(topics: [(String, QoS)]) -> Result<[MqttSubscription], MqttError> {
        if !self.connected { return Err(MqttError.NotConnected) }
        
        var subs = []
        for (topic, qos) in topics {
            let sub = self.subscribe(topic, qos)?
            subs.push(sub)
        }
        Ok(subs)
    }
    
    /// Unsubscribe from topic
    on unsubscribe(topic: String) -> Result<(), MqttError> {
        if !self.connected { return Err(MqttError.NotConnected) }
        
        @native("mqtt_unsubscribe", topic)
        self.subscriptions.remove(topic)
        Ok(())
    }
    
    fn is_connected() -> Bool { self.connected }
}

/// Connection acknowledgment
struct ConnAck {
    session_present: Bool
    return_code: ConnectReturnCode
}

enum ConnectReturnCode {
    Accepted
    UnacceptableProtocol
    IdentifierRejected
    ServerUnavailable
    BadCredentials
    NotAuthorized
}

struct PublishResult {
    packet_id: UInt16
    success: Bool
}

// -----------------------------------------------------------------------------
// Messages
// -----------------------------------------------------------------------------

/// MQTT message
struct MqttMessage {
    topic: String
    payload: [Byte]
    qos: QoS
    retain: Bool
    
    fn new(topic: String, payload: [Byte]) -> Self {
        MqttMessage { topic: topic, payload: payload, qos: QoS.AtMostOnce, retain: false }
    }
    
    fn text(topic: String, text: String) -> Self {
        MqttMessage.new(topic, text.bytes())
    }
    
    fn json<T: Serialize>(topic: String, data: T) -> Self {
        MqttMessage.new(topic, JSON.stringify(data).bytes())
    }
    
    fn with_qos(qos: QoS) -> Self { self.qos = qos; self }
    fn retained() -> Self { self.retain = true; self }
    
    fn payload_string() -> Result<String, DecodeError> { String.from_utf8(self.payload) }
    fn payload_json<T: Deserialize>() -> Result<T, DecodeError> { JSON.parse(self.payload_string()?) }
}

// -----------------------------------------------------------------------------
// Subscription
// -----------------------------------------------------------------------------

/// MQTT subscription
actor MqttSubscription {
    state topic: String
    state qos: QoS
    state messages: Channel<MqttMessage>
    state active: Bool
    
    fn new(topic: String, qos: QoS) -> Self {
        MqttSubscription { topic: topic, qos: qos, messages: Channel.unbounded(), active: true }
    }
    
    on recv() -> Option<MqttMessage> {
        if !self.active { return None }
        self.messages.recv().ok()
    }
    
    on recv_timeout(timeout: Duration) -> Option<MqttMessage> {
        if !self.active { return None }
        self.messages.recv_timeout(timeout).ok()
    }
    
    fn iter() -> SubscriptionIterator { SubscriptionIterator { sub: self } }
    
    on for_each(handler: fn(MqttMessage)) {
        while self.active {
            if let Some(msg) = self.recv() { handler(msg) }
        }
    }
}

struct SubscriptionIterator { sub: MqttSubscription }
impl Iterator for SubscriptionIterator {
    type Item = MqttMessage
    fn next() -> Option<MqttMessage> { self.sub.recv() }
}

// -----------------------------------------------------------------------------
// Topic Utilities
// -----------------------------------------------------------------------------

/// Topic builder and utilities
struct Topic {
    segments: [String]
    
    fn new() -> Self { Topic { segments: [] } }
    fn from(topic: String) -> Self { Topic { segments: topic.split("/") } }
    
    fn segment(s: String) -> Self { self.segments.push(s); self }
    fn wildcard() -> Self { self.segments.push("+"); self }  // Single-level wildcard
    fn multi_wildcard() -> Self { self.segments.push("#"); self }  // Multi-level wildcard
    
    fn build() -> String { self.segments.join("/") }
    
    fn matches(pattern: String, topic: String) -> Bool {
        let pattern_parts = pattern.split("/")
        let topic_parts = topic.split("/")
        Self.match_parts(pattern_parts, topic_parts)
    }
    
    fn match_parts(pattern: [String], topic: [String]) -> Bool {
        if pattern.is_empty() && topic.is_empty() { return true }
        if pattern.is_empty() { return false }
        
        match pattern[0] {
            "#" => true  // Multi-level matches everything
            "+" => {
                if topic.is_empty() { false }
                else { Self.match_parts(pattern[1..], topic[1..]) }
            }
            segment => {
                if topic.is_empty() || topic[0] != segment { false }
                else { Self.match_parts(pattern[1..], topic[1..]) }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// IoT Patterns
// -----------------------------------------------------------------------------

/// Device telemetry publisher
actor TelemetryPublisher {
    state client: MqttClient
    state device_id: String
    state base_topic: String
    
    fn new(client: MqttClient, device_id: String) -> Self {
        TelemetryPublisher {
            client: client,
            device_id: device_id,
            base_topic: "devices/\(device_id)"
        }
    }
    
    on publish_telemetry<T: Serialize>(data: T) -> Result<(), MqttError> {
        let topic = "\(self.base_topic)/telemetry"
        self.client.publish_message(MqttMessage.json(topic, data).with_qos(QoS.AtLeastOnce))
    }
    
    on publish_event(event_type: String, data: [Byte]) -> Result<(), MqttError> {
        let topic = "\(self.base_topic)/events/\(event_type)"
        self.client.publish(topic, data, QoS.AtLeastOnce, false)
    }
    
    on publish_status(status: DeviceStatus) -> Result<(), MqttError> {
        let topic = "\(self.base_topic)/status"
        self.client.publish_message(MqttMessage.json(topic, status).with_qos(QoS.AtLeastOnce).retained())
    }
}

struct DeviceStatus {
    online: Bool
    battery: Option<Int>
    signal_strength: Option<Int>
    firmware_version: String
    timestamp: Int64
}

/// Command receiver for devices
actor CommandReceiver {
    state client: MqttClient
    state device_id: String
    state handlers: Map<String, fn([Byte]) -> Result<[Byte], String>>
    
    fn new(client: MqttClient, device_id: String) -> Self {
        CommandReceiver {
            client: client,
            device_id: device_id,
            handlers: Map.empty()
        }
    }
    
    on register_command(command: String, handler: fn([Byte]) -> Result<[Byte], String>) {
        self.handlers.set(command, handler)
    }
    
    on start() -> Result<(), MqttError> {
        let topic = "devices/\(self.device_id)/commands/+"
        let sub = self.client.subscribe(topic, QoS.AtLeastOnce)?
        
        let handlers = self.handlers
        let client = self.client
        let device_id = self.device_id
        
        async {
            for msg in sub.iter() {
                let parts = msg.topic.split("/")
                if parts.len() >= 4 {
                    let command = parts[3]
                    if let handler = handlers.get(command) {
                        let response_topic = "devices/\(device_id)/responses/\(command)"
                        match handler(msg.payload) {
                            Ok(response) => {
                                let _ = client.publish(response_topic, response, QoS.AtLeastOnce, false)
                            }
                            Err(error) => {
                                let _ = client.publish(response_topic, error.bytes(), QoS.AtLeastOnce, false)
                            }
                        }
                    }
                }
            }
        }
        
        Ok(())
    }
}

/// Sensor data collector
actor SensorCollector {
    state client: MqttClient
    state sensors: Map<String, MqttSubscription>
    state data_handler: Option<fn(String, SensorReading)>
    
    fn new(client: MqttClient) -> Self {
        SensorCollector { client: client, sensors: Map.empty(), data_handler: None }
    }
    
    on add_sensor(sensor_id: String, topic: String) -> Result<(), MqttError> {
        let sub = self.client.subscribe(topic, QoS.AtLeastOnce)?
        self.sensors.set(sensor_id, sub)
        Ok(())
    }
    
    on on_data(handler: fn(String, SensorReading)) {
        self.data_handler = Some(handler)
    }
    
    on start() {
        for (sensor_id, sub) in self.sensors {
            let handler = self.data_handler
            let id = sensor_id.clone()
            async {
                for msg in sub.iter() {
                    if let Ok(reading) = msg.payload_json::<SensorReading>() {
                        if let h = handler { h(id, reading) }
                    }
                }
            }
        }
    }
}

struct SensorReading {
    value: Float64
    unit: String
    timestamp: Int64
    quality: Option<Int>
}

// -----------------------------------------------------------------------------
// Home Automation Patterns
// -----------------------------------------------------------------------------

/// Home Assistant MQTT discovery
struct HomeAssistantDiscovery {
    fn sensor(device_id: String, sensor_type: String, config: SensorConfig) -> MqttMessage {
        let topic = "homeassistant/sensor/\(device_id)/\(sensor_type)/config"
        MqttMessage.json(topic, config).retained()
    }
    
    fn switch(device_id: String, switch_id: String, config: SwitchConfig) -> MqttMessage {
        let topic = "homeassistant/switch/\(device_id)/\(switch_id)/config"
        MqttMessage.json(topic, config).retained()
    }
    
    fn light(device_id: String, light_id: String, config: LightConfig) -> MqttMessage {
        let topic = "homeassistant/light/\(device_id)/\(light_id)/config"
        MqttMessage.json(topic, config).retained()
    }
}

struct SensorConfig {
    name: String
    state_topic: String
    unit_of_measurement: Option<String>
    device_class: Option<String>
    unique_id: String
}

struct SwitchConfig {
    name: String
    state_topic: String
    command_topic: String
    unique_id: String
}

struct LightConfig {
    name: String
    state_topic: String
    command_topic: String
    brightness_state_topic: Option<String>
    brightness_command_topic: Option<String>
    unique_id: String
}

// -----------------------------------------------------------------------------
// MQTT 5.0 Features
// -----------------------------------------------------------------------------

/// MQTT 5.0 message properties
struct MessageProperties {
    payload_format: Option<PayloadFormat>
    message_expiry: Option<Duration>
    topic_alias: Option<UInt16>
    response_topic: Option<String>
    correlation_data: Option<[Byte]>
    user_properties: Map<String, String>
    content_type: Option<String>
    
    fn default() -> Self {
        MessageProperties {
            payload_format: None, message_expiry: None, topic_alias: None,
            response_topic: None, correlation_data: None,
            user_properties: Map.empty(), content_type: None
        }
    }
}

enum PayloadFormat { Unspecified, UTF8 }

/// MQTT 5.0 enhanced message
struct Mqtt5Message {
    topic: String
    payload: [Byte]
    qos: QoS
    retain: Bool
    properties: MessageProperties
    
    fn new(topic: String, payload: [Byte]) -> Self {
        Mqtt5Message {
            topic: topic, payload: payload, qos: QoS.AtMostOnce,
            retain: false, properties: MessageProperties.default()
        }
    }
    
    fn with_response_topic(topic: String) -> Self {
        self.properties.response_topic = Some(topic)
        self
    }
    
    fn with_correlation_data(data: [Byte]) -> Self {
        self.properties.correlation_data = Some(data)
        self
    }
    
    fn with_user_property(key: String, value: String) -> Self {
        self.properties.user_properties.set(key, value)
        self
    }
    
    fn with_expiry(duration: Duration) -> Self {
        self.properties.message_expiry = Some(duration)
        self
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum MqttError {
    NotConnected
    ConnectionFailed(String)
    ConnectionRefused(ConnectReturnCode)
    Timeout
    InvalidTopic
    SubscriptionFailed
    PublishFailed
    ProtocolError(String)
}

impl ToString for MqttError {
    fn to_string() -> String {
        match self {
            .NotConnected => "Not connected to broker"
            .ConnectionFailed(msg) => "Connection failed: \(msg)"
            .ConnectionRefused(code) => "Connection refused: \(code)"
            .Timeout => "Operation timed out"
            .InvalidTopic => "Invalid topic"
            .SubscriptionFailed => "Subscription failed"
            .PublishFailed => "Publish failed"
            .ProtocolError(msg) => "Protocol error: \(msg)"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "message creation" {
    let msg = MqttMessage.text("sensors/temp", "25.5")
    assert_eq(msg.topic, "sensors/temp")?
    assert_eq(msg.payload_string()?, "25.5")?
}

test "topic matching" {
    assert(Topic.matches("sensors/+/temp", "sensors/living/temp"))?
    assert(Topic.matches("sensors/#", "sensors/living/temp"))?
    assert(!Topic.matches("sensors/+/temp", "sensors/living/humidity"))?
}

test "topic builder" {
    let topic = Topic.new().segment("devices").wildcard().segment("telemetry").build()
    assert_eq(topic, "devices/+/telemetry")?
}

test "qos values" {
    assert_eq(QoS.AtMostOnce.value(), 0)?
    assert_eq(QoS.AtLeastOnce.value(), 1)?
    assert_eq(QoS.ExactlyOnce.value(), 2)?
}
