// =============================================================================
// Vibee OS — Profile Module
// Performance profiling and analysis
// =============================================================================

// -----------------------------------------------------------------------------
// CPU Profiler
// -----------------------------------------------------------------------------

/// CPU profiler
actor Profiler {
    state samples: [Sample]
    state running: Bool
    state sample_rate: Duration
    state start_time: Option<Instant>
    
    fn new() -> Self {
        Profiler {
            samples: [],
            running: false,
            sample_rate: Duration.micros(100)
        }
    }
    
    on sample_rate(rate: Duration) -> Self { self.sample_rate = rate; self }
    
    /// Start profiling
    on start() {
        self.running = true
        self.start_time = Some(Instant.now())
        self.samples = []
        
        async {
            while self.running {
                self.capture_sample()
                sleep(self.sample_rate)
            }
        }
    }
    
    /// Stop profiling
    on stop() -> ProfileReport {
        self.running = false
        let duration = self.start_time.map(|s| s.elapsed()).unwrap_or(Duration.zero())
        
        ProfileReport {
            samples: self.samples,
            duration: duration,
            sample_count: self.samples.len()
        }
    }
    
    fn capture_sample() {
        let stack = @native("capture_stack_sample")
        self.samples.append(Sample {
            timestamp: Instant.now(),
            stack: stack,
            thread_id: Thread.current_id()
        })
    }
}

struct Sample {
    timestamp: Instant
    stack: [StackFrame]
    thread_id: Int
}

struct StackFrame {
    function: String
    file: String
    line: Int
    module: String
}

/// Profile report
struct ProfileReport {
    samples: [Sample]
    duration: Duration
    sample_count: Int
    
    /// Get hot functions
    fn hot_functions(top_n: Int = 10) -> [FunctionStats] {
        var counts = Map.empty()
        
        for sample in self.samples {
            for frame in sample.stack {
                let key = frame.function
                counts.entry(key).or_insert(FunctionStats {
                    name: frame.function,
                    file: frame.file,
                    self_samples: 0,
                    total_samples: 0
                }).total_samples += 1
            }
            
            // Top of stack = self time
            if let top = sample.stack.first() {
                counts.get_mut(top.function).map(|s| s.self_samples += 1)
            }
        }
        
        var stats = counts.values().collect()
        stats.sort_by(|a, b| b.self_samples.cmp(a.self_samples))
        stats.take(top_n)
    }
    
    /// Get call tree
    fn call_tree() -> CallNode {
        var root = CallNode.new("[root]")
        
        for sample in self.samples {
            var current = root
            for frame in sample.stack.rev() {
                current = current.get_or_create_child(frame.function)
                current.samples += 1
            }
        }
        
        root
    }
    
    /// Get flame graph data
    fn flame_graph() -> String {
        var lines = []
        
        for sample in self.samples {
            let stack = sample.stack.rev().map(|f| f.function).join(";")
            lines.append(stack)
        }
        
        // Collapse identical stacks
        var counts = Map.empty()
        for line in lines {
            counts.entry(line).or_insert(0) += 1
        }
        
        counts.map(|(stack, count)| "\(stack) \(count)").join("\n")
    }
    
    /// Print summary
    fn print_summary() {
        println("\n=== Profile Summary ===")
        println("Duration:    \(self.duration.as_millis())ms")
        println("Samples:     \(self.sample_count)")
        println("Sample rate: \(1_000_000 / self.duration.as_micros() * self.sample_count) samples/sec")
        
        println("\nHot Functions (by self time):")
        for (i, func) in self.hot_functions(10).enumerate() {
            let self_pct = (func.self_samples as Float / self.sample_count as Float * 100.0).round(1)
            let total_pct = (func.total_samples as Float / self.sample_count as Float * 100.0).round(1)
            println("  \(i + 1). \(func.name)")
            println("     self: \(self_pct)% (\(func.self_samples)), total: \(total_pct)% (\(func.total_samples))")
        }
        
        println("=======================")
    }
    
    /// Save flame graph
    fn save_flame_graph(path: String) -> Result<(), IOError> {
        File.write(path, self.flame_graph())
    }
}

struct FunctionStats {
    name: String
    file: String
    self_samples: Int
    total_samples: Int
}

actor CallNode {
    state name: String
    state samples: Int
    state children: Map<String, CallNode>
    
    fn new(name: String) -> Self {
        CallNode { name: name, samples: 0, children: Map.empty() }
    }
    
    fn get_or_create_child(name: String) -> CallNode {
        self.children.entry(name).or_insert(CallNode.new(name))
    }
    
    fn print(indent: Int = 0) {
        let prefix = "  ".repeat(indent)
        println("\(prefix)\(self.name) (\(self.samples))")
        for (_, child) in self.children.sorted_by(|a, b| b.1.samples.cmp(a.1.samples)) {
            child.print(indent + 1)
        }
    }
}

// -----------------------------------------------------------------------------
// Scoped Profiling
// -----------------------------------------------------------------------------

/// Profile a specific scope
macro profile(name) {
    let _guard = ProfileGuard.new(name)
}

actor ProfileGuard {
    state name: String
    state start: Instant
    
    fn new(name: String) -> Self {
        let guard = ProfileGuard { name: name, start: Instant.now() }
        PROFILE_DATA.enter(name)
        guard
    }
    
    on drop() {
        let elapsed = self.start.elapsed()
        PROFILE_DATA.exit(self.name, elapsed)
    }
}

/// Global profile data collector
actor ProfileData {
    state entries: Map<String, ProfileEntry>
    state stack: [String]
    
    fn new() -> Self {
        ProfileData { entries: Map.empty(), stack: [] }
    }
    
    on enter(name: String) {
        self.stack.append(name)
    }
    
    on exit(name: String, elapsed: Duration) {
        self.stack.pop()
        
        let entry = self.entries.entry(name).or_insert(ProfileEntry {
            name: name,
            calls: 0,
            total_time: Duration.zero(),
            min_time: Duration.max(),
            max_time: Duration.zero(),
            self_time: Duration.zero()
        })
        
        entry.calls += 1
        entry.total_time += elapsed
        entry.min_time = entry.min_time.min(elapsed)
        entry.max_time = entry.max_time.max(elapsed)
        entry.self_time += elapsed  // Simplified; real impl would subtract child time
    }
    
    fn report() -> [ProfileEntry] {
        self.entries.values().sorted_by(|a, b| b.total_time.cmp(a.total_time))
    }
    
    fn print_report() {
        println("\n=== Profile Report ===")
        println("{:<40} {:>8} {:>12} {:>12} {:>12}", "Function", "Calls", "Total", "Avg", "Max")
        println("-".repeat(90))
        
        for entry in self.report() {
            let avg = entry.total_time / entry.calls
            println("{:<40} {:>8} {:>12} {:>12} {:>12}",
                entry.name.truncate(40),
                entry.calls,
                format_duration(entry.total_time),
                format_duration(avg),
                format_duration(entry.max_time)
            )
        }
        println("======================")
    }
    
    on reset() {
        self.entries = Map.empty()
        self.stack = []
    }
}

struct ProfileEntry {
    name: String
    calls: Int
    total_time: Duration
    min_time: Duration
    max_time: Duration
    self_time: Duration
}

var PROFILE_DATA = ProfileData.new()

fn format_duration(d: Duration) -> String {
    let us = d.as_micros()
    if us < 1000 { "\(us)µs" }
    else if us < 1_000_000 { "\((us as Float / 1000.0).round(2))ms" }
    else { "\((us as Float / 1_000_000.0).round(2))s" }
}

// -----------------------------------------------------------------------------
// Memory Profiler
// -----------------------------------------------------------------------------

/// Memory profiler
actor MemoryProfiler {
    state snapshots: [MemorySnapshot]
    state tracking: Bool
    state allocations: [AllocationRecord]
    
    fn new() -> Self {
        MemoryProfiler { snapshots: [], tracking: false, allocations: [] }
    }
    
    /// Take memory snapshot
    on snapshot(label: String) {
        let stats = @native("memory_stats")
        self.snapshots.append(MemorySnapshot {
            label: label,
            timestamp: Instant.now(),
            allocated: stats.allocated,
            freed: stats.freed,
            in_use: stats.current,
            peak: stats.peak,
            alloc_count: stats.alloc_count
        })
    }
    
    /// Start tracking allocations
    on start_tracking() {
        self.tracking = true
        self.allocations = []
        @native("memory_start_tracking")
    }
    
    /// Stop tracking
    on stop_tracking() -> [AllocationRecord] {
        self.tracking = false
        @native("memory_stop_tracking")
    }
    
    /// Compare snapshots
    fn compare(label_a: String, label_b: String) -> Option<MemoryDiff> {
        let a = self.snapshots.find(|s| s.label == label_a)?
        let b = self.snapshots.find(|s| s.label == label_b)?
        
        Some(MemoryDiff {
            from: label_a,
            to: label_b,
            allocated_diff: b.allocated - a.allocated,
            freed_diff: b.freed - a.freed,
            in_use_diff: b.in_use - a.in_use,
            alloc_count_diff: b.alloc_count - a.alloc_count
        })
    }
    
    /// Get allocation hotspots
    fn hotspots(top_n: Int = 10) -> [AllocationHotspot] {
        var by_site = Map.empty()
        
        for alloc in self.allocations {
            let site = alloc.stack.first().map(|f| f.function).unwrap_or("unknown")
            let entry = by_site.entry(site).or_insert(AllocationHotspot {
                site: site,
                count: 0,
                total_bytes: 0
            })
            entry.count += 1
            entry.total_bytes += alloc.size
        }
        
        var hotspots = by_site.values().collect()
        hotspots.sort_by(|a, b| b.total_bytes.cmp(a.total_bytes))
        hotspots.take(top_n)
    }
    
    fn print_report() {
        println("\n=== Memory Profile ===")
        
        if !self.snapshots.is_empty() {
            println("\nSnapshots:")
            for snap in self.snapshots {
                println("  \(snap.label): \(format_bytes(snap.in_use)) in use, \(snap.alloc_count) allocations")
            }
        }
        
        if !self.allocations.is_empty() {
            println("\nAllocation Hotspots:")
            for (i, hotspot) in self.hotspots(10).enumerate() {
                println("  \(i + 1). \(hotspot.site)")
                println("     \(hotspot.count) allocations, \(format_bytes(hotspot.total_bytes)) total")
            }
        }
        
        println("======================")
    }
}

struct MemorySnapshot {
    label: String
    timestamp: Instant
    allocated: Int
    freed: Int
    in_use: Int
    peak: Int
    alloc_count: Int
}

struct MemoryDiff {
    from: String
    to: String
    allocated_diff: Int
    freed_diff: Int
    in_use_diff: Int
    alloc_count_diff: Int
}

struct AllocationRecord {
    address: Int
    size: Int
    timestamp: Instant
    stack: [StackFrame]
}

struct AllocationHotspot {
    site: String
    count: Int
    total_bytes: Int
}

fn format_bytes(bytes: Int) -> String {
    if bytes < 1024 { "\(bytes) B" }
    else if bytes < 1024 * 1024 { "\((bytes as Float / 1024.0).round(2)) KB" }
    else if bytes < 1024 * 1024 * 1024 { "\((bytes as Float / (1024.0 * 1024.0)).round(2)) MB" }
    else { "\((bytes as Float / (1024.0 * 1024.0 * 1024.0)).round(2)) GB" }
}

// -----------------------------------------------------------------------------
// Async Profiler
// -----------------------------------------------------------------------------

/// Profile async operations
actor AsyncProfiler {
    state tasks: Map<String, TaskProfile>
    
    fn new() -> Self { AsyncProfiler { tasks: Map.empty() } }
    
    on task_start(id: String, name: String) {
        self.tasks.set(id, TaskProfile {
            id: id,
            name: name,
            start: Instant.now(),
            end: None,
            awaits: []
        })
    }
    
    on task_end(id: String) {
        if let task = self.tasks.get_mut(id) {
            task.end = Some(Instant.now())
        }
    }
    
    on await_start(task_id: String, await_name: String) {
        if let task = self.tasks.get_mut(task_id) {
            task.awaits.append(AwaitRecord {
                name: await_name,
                start: Instant.now(),
                end: None
            })
        }
    }
    
    on await_end(task_id: String) {
        if let task = self.tasks.get_mut(task_id) {
            if let await_rec = task.awaits.last_mut() {
                await_rec.end = Some(Instant.now())
            }
        }
    }
    
    fn report() -> AsyncProfileReport {
        let completed = self.tasks.values()
            .filter(|t| t.end.is_some())
            .collect()
        
        AsyncProfileReport { tasks: completed }
    }
}

struct TaskProfile {
    id: String
    name: String
    start: Instant
    end: Option<Instant>
    awaits: [AwaitRecord]
    
    fn duration() -> Duration {
        self.end.map(|e| e - self.start).unwrap_or(Duration.zero())
    }
    
    fn await_time() -> Duration {
        self.awaits.map(|a| a.duration()).sum()
    }
    
    fn compute_time() -> Duration {
        self.duration() - self.await_time()
    }
}

struct AwaitRecord {
    name: String
    start: Instant
    end: Option<Instant>
    
    fn duration() -> Duration {
        self.end.map(|e| e - self.start).unwrap_or(Duration.zero())
    }
}

struct AsyncProfileReport {
    tasks: [TaskProfile]
    
    fn print() {
        println("\n=== Async Profile ===")
        for task in self.tasks {
            println("\(task.name) (\(task.id))")
            println("  Total:   \(format_duration(task.duration()))")
            println("  Compute: \(format_duration(task.compute_time()))")
            println("  Await:   \(format_duration(task.await_time()))")
            
            if !task.awaits.is_empty() {
                println("  Awaits:")
                for await_rec in task.awaits {
                    println("    - \(await_rec.name): \(format_duration(await_rec.duration()))")
                }
            }
        }
        println("=====================")
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Profile a function
fn profile_fn<T>(name: String, f: () -> T) -> (T, Duration) {
    let start = Instant.now()
    let result = f()
    let elapsed = start.elapsed()
    
    PROFILE_DATA.enter(name)
    PROFILE_DATA.exit(name, elapsed)
    
    (result, elapsed)
}

/// Run with profiling enabled
fn with_profiling<T>(f: () -> T) -> (T, ProfileReport) {
    let profiler = Profiler.new()
    profiler.start()
    let result = f()
    let report = profiler.stop()
    (result, report)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "scoped profiling" {
    PROFILE_DATA.reset()
    
    fn work() {
        profile!("work")
        sleep(Duration.millis(10))
    }
    
    work()
    work()
    
    let report = PROFILE_DATA.report()
    assert(report.len() > 0)
    assert(report[0].calls == 2)
}

test "memory snapshot" {
    let profiler = MemoryProfiler.new()
    profiler.snapshot("before")
    
    let data = [0; 1000]
    
    profiler.snapshot("after")
    
    let diff = profiler.compare("before", "after")
    assert(diff.is_some())
}
