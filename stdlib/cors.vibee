// =============================================================================
// Vibee OS â€” CORS Module
// Cross-Origin Resource Sharing (CORS) policy management
// =============================================================================

// =============================================================================
// CORS Configuration
// =============================================================================

/// CORS configuration
struct CorsConfig {
    allowed_origins: AllowedOrigins
    allowed_methods: [http.Method]
    allowed_headers: AllowedHeaders
    exposed_headers: [String]
    allow_credentials: Bool
    max_age: Option<Int>
    allow_private_network: Bool
}

impl CorsConfig {
    /// Create default CORS configuration (restrictive)
    fn new() -> Self {
        CorsConfig {
            allowed_origins: AllowedOrigins.None,
            allowed_methods: [http.Method.GET, http.Method.HEAD],
            allowed_headers: AllowedHeaders.None,
            exposed_headers: [],
            allow_credentials: false,
            max_age: None,
            allow_private_network: false
        }
    }
    
    /// Create permissive CORS configuration (allow all)
    fn permissive() -> Self {
        CorsConfig {
            allowed_origins: AllowedOrigins.Any,
            allowed_methods: [
                http.Method.GET,
                http.Method.POST,
                http.Method.PUT,
                http.Method.DELETE,
                http.Method.PATCH,
                http.Method.HEAD,
                http.Method.OPTIONS
            ],
            allowed_headers: AllowedHeaders.Any,
            exposed_headers: [],
            allow_credentials: false,
            max_age: Some(86400),
            allow_private_network: false
        }
    }
    
    /// Create CORS configuration for specific origin
    fn for_origin(origin: String) -> Self {
        Self.new().origin(origin)
    }
    
    // -------------------------------------------------------------------------
    // Builder Methods
    // -------------------------------------------------------------------------
    
    /// Allow any origin
    fn allow_any_origin() -> Self {
        self.allowed_origins = AllowedOrigins.Any
        self
    }
    
    /// Allow specific origin
    fn origin(origin: String) -> Self {
        match self.allowed_origins {
            AllowedOrigins.List(ref mut list) => list.push(origin),
            _ => self.allowed_origins = AllowedOrigins.List([origin])
        }
        self
    }
    
    /// Allow multiple origins
    fn origins(origins: [String]) -> Self {
        self.allowed_origins = AllowedOrigins.List(origins)
        self
    }
    
    /// Allow origins matching regex
    fn origin_regex(pattern: String) -> Self {
        self.allowed_origins = AllowedOrigins.Regex(pattern)
        self
    }
    
    /// Allow origins matching function
    fn origin_fn(f: fn(String) -> Bool) -> Self {
        self.allowed_origins = AllowedOrigins.Function(f)
        self
    }
    
    /// Set allowed HTTP methods
    fn methods(methods: [http.Method]) -> Self {
        self.allowed_methods = methods
        self
    }
    
    /// Allow specific method
    fn method(method: http.Method) -> Self {
        if !self.allowed_methods.contains(method) {
            self.allowed_methods.push(method)
        }
        self
    }
    
    /// Allow all standard methods
    fn allow_all_methods() -> Self {
        self.allowed_methods = [
            http.Method.GET,
            http.Method.POST,
            http.Method.PUT,
            http.Method.DELETE,
            http.Method.PATCH,
            http.Method.HEAD,
            http.Method.OPTIONS
        ]
        self
    }
    
    /// Allow any header
    fn allow_any_header() -> Self {
        self.allowed_headers = AllowedHeaders.Any
        self
    }
    
    /// Allow specific header
    fn header(header: String) -> Self {
        match self.allowed_headers {
            AllowedHeaders.List(ref mut list) => list.push(header.to_lower()),
            AllowedHeaders.None => self.allowed_headers = AllowedHeaders.List([header.to_lower()]),
            _ => {}
        }
        self
    }
    
    /// Allow multiple headers
    fn headers(headers: [String]) -> Self {
        self.allowed_headers = AllowedHeaders.List(headers.iter().map(|h| h.to_lower()).collect())
        self
    }
    
    /// Expose header to client
    fn expose_header(header: String) -> Self {
        self.exposed_headers.push(header)
        self
    }
    
    /// Expose multiple headers
    fn expose_headers(headers: [String]) -> Self {
        self.exposed_headers.extend(headers)
        self
    }
    
    /// Allow credentials (cookies, authorization headers)
    fn allow_credentials(allow: Bool) -> Self {
        self.allow_credentials = allow
        self
    }
    
    /// Set preflight cache max age in seconds
    fn max_age(seconds: Int) -> Self {
        self.max_age = Some(seconds)
        self
    }
    
    /// Allow private network access
    fn allow_private_network(allow: Bool) -> Self {
        self.allow_private_network = allow
        self
    }
    
    // -------------------------------------------------------------------------
    // Validation
    // -------------------------------------------------------------------------
    
    /// Check if origin is allowed
    fn is_origin_allowed(origin: String) -> Bool {
        match self.allowed_origins {
            AllowedOrigins.Any => true,
            AllowedOrigins.None => false,
            AllowedOrigins.List(ref origins) => origins.contains(origin),
            AllowedOrigins.Regex(ref pattern) => {
                regex.Regex.new(pattern).map(|r| r.is_match(origin)).unwrap_or(false)
            }
            AllowedOrigins.Function(f) => f(origin)
        }
    }
    
    /// Check if method is allowed
    fn is_method_allowed(method: http.Method) -> Bool {
        self.allowed_methods.contains(method)
    }
    
    /// Check if header is allowed
    fn is_header_allowed(header: String) -> Bool {
        let header_lower = header.to_lower()
        
        // Simple headers are always allowed
        if is_simple_header(header_lower.clone()) {
            return true
        }
        
        match self.allowed_headers {
            AllowedHeaders.Any => true,
            AllowedHeaders.None => false,
            AllowedHeaders.List(ref headers) => headers.contains(header_lower)
        }
    }
    
    /// Check if all requested headers are allowed
    fn are_headers_allowed(headers: [String]) -> Bool {
        headers.iter().all(|h| self.is_header_allowed(h.clone()))
    }
    
    // -------------------------------------------------------------------------
    // Response Building
    // -------------------------------------------------------------------------
    
    /// Build CORS headers for actual request
    fn build_headers(origin: String) -> CorsHeaders {
        var headers = CorsHeaders.new()
        
        // Access-Control-Allow-Origin
        if self.is_origin_allowed(origin.clone()) {
            if self.allow_credentials || !matches!(self.allowed_origins, AllowedOrigins.Any) {
                headers.set("Access-Control-Allow-Origin", origin)
            } else {
                headers.set("Access-Control-Allow-Origin", "*")
            }
        }
        
        // Access-Control-Allow-Credentials
        if self.allow_credentials {
            headers.set("Access-Control-Allow-Credentials", "true")
        }
        
        // Access-Control-Expose-Headers
        if !self.exposed_headers.is_empty() {
            headers.set("Access-Control-Expose-Headers", self.exposed_headers.join(", "))
        }
        
        headers
    }
    
    /// Build CORS headers for preflight request
    fn build_preflight_headers(origin: String, method: http.Method, request_headers: [String]) -> CorsHeaders {
        var headers = self.build_headers(origin)
        
        // Access-Control-Allow-Methods
        let methods_str = self.allowed_methods.iter()
            .map(|m| m.to_string())
            .join(", ")
        headers.set("Access-Control-Allow-Methods", methods_str)
        
        // Access-Control-Allow-Headers
        match self.allowed_headers {
            AllowedHeaders.Any => {
                if !request_headers.is_empty() {
                    headers.set("Access-Control-Allow-Headers", request_headers.join(", "))
                } else {
                    headers.set("Access-Control-Allow-Headers", "*")
                }
            }
            AllowedHeaders.List(ref allowed) => {
                if !allowed.is_empty() {
                    headers.set("Access-Control-Allow-Headers", allowed.join(", "))
                }
            }
            AllowedHeaders.None => {}
        }
        
        // Access-Control-Max-Age
        if let Some(age) = self.max_age {
            headers.set("Access-Control-Max-Age", age.to_string())
        }
        
        // Access-Control-Allow-Private-Network
        if self.allow_private_network {
            headers.set("Access-Control-Allow-Private-Network", "true")
        }
        
        headers
    }
    
    /// Create middleware
    fn middleware() -> fn(Context, fn(Context) -> Response) -> Response {
        let config = self.clone()
        
        |ctx, next| {
            let origin = ctx.header("Origin");
            
            // No Origin header - not a CORS request
            if origin.is_none() {
                return next(ctx)
            }
            
            let origin = origin.unwrap()
            
            // Check if origin is allowed
            if !config.is_origin_allowed(origin.clone()) {
                return Response.error(403).json({"error": "Origin not allowed"})
            }
            
            // Handle preflight request
            if ctx.method() == http.Method.OPTIONS {
                let request_method = ctx.header("Access-Control-Request-Method")
                    .and_then(|m| http.Method.from_str(m));
                
                let request_headers = ctx.header("Access-Control-Request-Headers")
                    .map(|h| h.split(",").map(|s| s.trim()).collect())
                    .unwrap_or([]);
                
                // Validate preflight
                if let Some(method) = request_method {
                    if !config.is_method_allowed(method) {
                        return Response.error(403).json({"error": "Method not allowed"})
                    }
                }
                
                if !config.are_headers_allowed(request_headers.clone()) {
                    return Response.error(403).json({"error": "Headers not allowed"})
                }
                
                // Build preflight response
                let cors_headers = config.build_preflight_headers(
                    origin,
                    request_method.unwrap_or(http.Method.GET),
                    request_headers
                )
                
                return cors_headers.apply(Response.new(http.Status.no_content()))
            }
            
            // Handle actual request
            let cors_headers = config.build_headers(origin)
            let response = next(ctx)
            cors_headers.apply(response)
        }
    }
}

// =============================================================================
// Allowed Origins
// =============================================================================

/// Allowed origins configuration
enum AllowedOrigins {
    Any
    None
    List([String])
    Regex(String)
    Function(fn(String) -> Bool)
}

impl AllowedOrigins {
    fn is_any() -> Bool {
        matches!(self, AllowedOrigins.Any)
    }
    
    fn is_none() -> Bool {
        matches!(self, AllowedOrigins.None)
    }
}

// =============================================================================
// Allowed Headers
// =============================================================================

/// Allowed headers configuration
enum AllowedHeaders {
    Any
    None
    List([String])
}

impl AllowedHeaders {
    fn is_any() -> Bool {
        matches!(self, AllowedHeaders.Any)
    }
}

// =============================================================================
// CORS Headers
// =============================================================================

/// CORS response headers
struct CorsHeaders {
    headers: Map<String, String>
}

impl CorsHeaders {
    fn new() -> Self {
        CorsHeaders { headers: Map.empty() }
    }
    
    fn set(name: String, value: String) {
        self.headers.set(name, value)
    }
    
    fn get(name: String) -> Option<String> {
        self.headers.get(name)
    }
    
    fn apply(response: http.Response) -> http.Response {
        var res = response
        for (name, value) in self.headers.iter() {
            res = res.header(name, value)
        }
        res
    }
    
    fn iter() -> impl Iterator<Item = (String, String)> {
        self.headers.iter()
    }
}

// =============================================================================
// CORS Middleware
// =============================================================================

/// CORS middleware for router
struct Cors {
    config: CorsConfig
}

impl Cors {
    /// Create CORS middleware with default config
    fn new() -> Self {
        Cors { config: CorsConfig.new() }
    }
    
    /// Create permissive CORS middleware
    fn permissive() -> Self {
        Cors { config: CorsConfig.permissive() }
    }
    
    /// Create CORS middleware with config
    fn with_config(config: CorsConfig) -> Self {
        Cors { config: config }
    }
    
    /// Get middleware function
    fn middleware() -> fn(Context, fn(Context) -> Response) -> Response {
        self.config.middleware()
    }
}

impl Middleware for Cors {
    fn handle(ctx: Context, next: fn(Context) -> Response) -> Response {
        self.config.middleware()(ctx, next)
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Check if header is a simple header (always allowed)
fn is_simple_header(header: String) -> Bool {
    let simple_headers = [
        "accept",
        "accept-language",
        "content-language",
        "content-type"
    ]
    simple_headers.contains(header.to_lower())
}

/// Check if content type is simple (allowed without preflight)
fn is_simple_content_type(content_type: String) -> Bool {
    let ct = content_type.to_lower()
    ct.starts_with("application/x-www-form-urlencoded") ||
    ct.starts_with("multipart/form-data") ||
    ct.starts_with("text/plain")
}

/// Check if request is a simple request (no preflight needed)
fn is_simple_request(req: http.Request) -> Bool {
    // Simple methods
    let simple_methods = [http.Method.GET, http.Method.HEAD, http.Method.POST]
    if !simple_methods.contains(req.method) {
        return false
    }
    
    // Check content type for POST
    if req.method == http.Method.POST {
        if let Some(ct) = req.headers.content_type() {
            if !is_simple_content_type(ct) {
                return false
            }
        }
    }
    
    // Check for non-simple headers
    for (name, _) in req.headers.iter() {
        if !is_simple_header(name) && name.to_lower() != "content-type" {
            return false
        }
    }
    
    true
}

/// Check if request is a preflight request
fn is_preflight_request(req: http.Request) -> Bool {
    req.method == http.Method.OPTIONS &&
    req.headers.contains("Origin") &&
    req.headers.contains("Access-Control-Request-Method")
}

/// Extract origin from request
fn get_origin(req: http.Request) -> Option<String> {
    req.headers.get("Origin")
}

// =============================================================================
// Quick Middleware Constructors
// =============================================================================

/// Create permissive CORS middleware
fn permissive() -> fn(Context, fn(Context) -> Response) -> Response {
    CorsConfig.permissive().middleware()
}

/// Create CORS middleware for specific origin
fn for_origin(origin: String) -> fn(Context, fn(Context) -> Response) -> Response {
    CorsConfig.for_origin(origin).middleware()
}

/// Create CORS middleware for multiple origins
fn for_origins(origins: [String]) -> fn(Context, fn(Context) -> Response) -> Response {
    CorsConfig.new().origins(origins).middleware()
}

/// Create CORS middleware with credentials support
fn with_credentials(origins: [String]) -> fn(Context, fn(Context) -> Response) -> Response {
    CorsConfig.new()
        .origins(origins)
        .allow_credentials(true)
        .allow_all_methods()
        .allow_any_header()
        .middleware()
}

// =============================================================================
// CORS Layer for Router
// =============================================================================

/// CORS layer that can be applied to router
struct CorsLayer {
    config: CorsConfig
}

impl CorsLayer {
    fn new(config: CorsConfig) -> Self {
        CorsLayer { config: config }
    }
    
    fn permissive() -> Self {
        Self.new(CorsConfig.permissive())
    }
    
    /// Apply CORS to router
    fn apply(router: Router) -> Router {
        router.use(self.config.middleware())
    }
}

// =============================================================================
// Preflight Handler
// =============================================================================

/// Standalone preflight handler for manual routing
fn preflight_handler(config: CorsConfig) -> fn(Context) -> Response {
    |ctx| {
        let origin = ctx.header("Origin").unwrap_or("");
        let method = ctx.header("Access-Control-Request-Method")
            .and_then(|m| http.Method.from_str(m))
            .unwrap_or(http.Method.GET);
        let headers = ctx.header("Access-Control-Request-Headers")
            .map(|h| h.split(",").map(|s| s.trim()).collect())
            .unwrap_or([]);
        
        let cors_headers = config.build_preflight_headers(origin, method, headers)
        cors_headers.apply(Response.new(http.Status.no_content()))
    }
}

// =============================================================================
// Tests
// =============================================================================

test "cors config builder" {
    let config = CorsConfig.new()
        .origin("https://example.com")
        .origin("https://app.example.com")
        .methods([http.Method.GET, http.Method.POST])
        .header("X-Custom-Header")
        .allow_credentials(true)
        .max_age(3600)
    
    assert(config.is_origin_allowed("https://example.com"))?
    assert(config.is_origin_allowed("https://app.example.com"))?
    assert(!config.is_origin_allowed("https://other.com"))?
    assert(config.is_method_allowed(http.Method.GET))?
    assert(!config.is_method_allowed(http.Method.DELETE))?
}

test "permissive config" {
    let config = CorsConfig.permissive()
    
    assert(config.is_origin_allowed("https://any-origin.com"))?
    assert(config.is_method_allowed(http.Method.DELETE))?
    assert(config.is_header_allowed("X-Any-Header"))?
}

test "origin regex" {
    let config = CorsConfig.new()
        .origin_regex("^https://.*\\.example\\.com$")
    
    assert(config.is_origin_allowed("https://app.example.com"))?
    assert(config.is_origin_allowed("https://api.example.com"))?
    assert(!config.is_origin_allowed("https://example.com"))?
    assert(!config.is_origin_allowed("https://evil.com"))?
}

test "simple headers" {
    assert(is_simple_header("Accept"))?
    assert(is_simple_header("content-type"))?
    assert(!is_simple_header("Authorization"))?
    assert(!is_simple_header("X-Custom"))?
}

test "cors headers building" {
    let config = CorsConfig.new()
        .origin("https://example.com")
        .allow_credentials(true)
        .expose_header("X-Custom-Header")
    
    let headers = config.build_headers("https://example.com")
    
    assert_eq(headers.get("Access-Control-Allow-Origin"), Some("https://example.com"))?
    assert_eq(headers.get("Access-Control-Allow-Credentials"), Some("true"))?
    assert_eq(headers.get("Access-Control-Expose-Headers"), Some("X-Custom-Header"))?
}

test "preflight headers" {
    let config = CorsConfig.new()
        .origin("https://example.com")
        .methods([http.Method.GET, http.Method.POST, http.Method.PUT])
        .headers(["Content-Type", "Authorization"])
        .max_age(3600)
    
    let headers = config.build_preflight_headers(
        "https://example.com",
        http.Method.POST,
        ["Content-Type", "Authorization"]
    )
    
    assert(headers.get("Access-Control-Allow-Methods").unwrap().contains("POST"))?
    assert(headers.get("Access-Control-Allow-Headers").is_some())?
    assert_eq(headers.get("Access-Control-Max-Age"), Some("3600"))?
}

test "is preflight request" {
    let req = http.Request.new(http.Method.OPTIONS, "https://api.example.com/data")
        .header("Origin", "https://example.com")
        .header("Access-Control-Request-Method", "POST")
    
    assert(is_preflight_request(req))?
}

test "is simple request" {
    let simple = http.Request.get("https://api.example.com/data")
        .header("Accept", "application/json")
    
    assert(is_simple_request(simple))?
    
    let not_simple = http.Request.post("https://api.example.com/data")
        .header("Content-Type", "application/json")
        .header("Authorization", "Bearer token")
    
    assert(!is_simple_request(not_simple))?
}

test "wildcard origin with credentials" {
    let config = CorsConfig.new()
        .allow_any_origin()
        .allow_credentials(true)
    
    // When credentials are allowed, should echo origin instead of *
    let headers = config.build_headers("https://example.com")
    assert_eq(headers.get("Access-Control-Allow-Origin"), Some("https://example.com"))?
}
