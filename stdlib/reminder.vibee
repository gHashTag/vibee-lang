// =============================================================================
// Vibee OS â€” Reminder Module
// Reminder management with multiple notification channels
// =============================================================================

use datetime::{DateTime, Duration}
use uuid::{UUID}

// =============================================================================
// Reminder Types & Enums
// =============================================================================

enum ReminderType { OneTime, Recurring, Location, Smart }
enum ReminderStatus { Active, Snoozed, Completed, Cancelled, Expired }
enum ReminderPriority { Low, Normal, High, Critical }
enum NotificationChannel { Push, Email, SMS, InApp, Webhook }
enum TriggerType { Time, Location, Event }

// =============================================================================
// Notification Settings
// =============================================================================

struct NotificationSettings {
    channels: [NotificationChannel]
    sound: Option<String>
    vibrate: Bool
    led_color: Option<String>
    persistent: Bool
    auto_dismiss_after: Option<Duration>
}

impl NotificationSettings {
    fn default() -> Self {
        NotificationSettings {
            channels: [NotificationChannel.Push, NotificationChannel.InApp],
            sound: None,
            vibrate: true,
            led_color: None,
            persistent: false,
            auto_dismiss_after: None
        }
    }
    
    fn silent() -> Self {
        NotificationSettings {
            channels: [NotificationChannel.InApp],
            sound: None,
            vibrate: false,
            led_color: None,
            persistent: false,
            auto_dismiss_after: None
        }
    }
    
    fn urgent() -> Self {
        NotificationSettings {
            channels: [NotificationChannel.Push, NotificationChannel.SMS, NotificationChannel.InApp],
            sound: Some("urgent"),
            vibrate: true,
            led_color: Some("#FF0000"),
            persistent: true,
            auto_dismiss_after: None
        }
    }
    
    fn with_channel(ch: NotificationChannel) -> Self {
        if !self.channels.contains(ch) {
            self.channels.push(ch)
        }
        self
    }
    
    fn with_sound(s: String) -> Self { self.sound = Some(s); self }
    fn with_vibrate(v: Bool) -> Self { self.vibrate = v; self }
    fn persistent() -> Self { self.persistent = true; self }
    fn auto_dismiss(d: Duration) -> Self { self.auto_dismiss_after = Some(d); self }
}

// =============================================================================
// Snooze Options
// =============================================================================

struct SnoozeOptions {
    duration: Duration
    max_snooze_count: Int
    snooze_count: Int
}

impl SnoozeOptions {
    fn new(duration: Duration) -> Self {
        SnoozeOptions {
            duration: duration,
            max_snooze_count: 3,
            snooze_count: 0
        }
    }
    
    fn with_max_count(n: Int) -> Self { self.max_snooze_count = n; self }
    
    fn can_snooze() -> Bool {
        self.snooze_count < self.max_snooze_count
    }
    
    fn snooze() -> Option<DateTime> {
        if self.can_snooze() {
            self.snooze_count += 1
            Some(DateTime.now().add(self.duration))
        } else {
            None
        }
    }
    
    fn remaining_snoozes() -> Int {
        self.max_snooze_count - self.snooze_count
    }
}

// =============================================================================
// Location Trigger
// =============================================================================

struct LocationTrigger {
    latitude: Float
    longitude: Float
    radius_meters: Float
    trigger_on_enter: Bool
    trigger_on_exit: Bool
    location_name: Option<String>
}

impl LocationTrigger {
    fn new(lat: Float, lng: Float, radius: Float) -> Self {
        LocationTrigger {
            latitude: lat,
            longitude: lng,
            radius_meters: radius,
            trigger_on_enter: true,
            trigger_on_exit: false,
            location_name: None
        }
    }
    
    fn with_name(n: String) -> Self { self.location_name = Some(n); self }
    fn on_enter() -> Self { self.trigger_on_enter = true; self.trigger_on_exit = false; self }
    fn on_exit() -> Self { self.trigger_on_enter = false; self.trigger_on_exit = true; self }
    fn on_both() -> Self { self.trigger_on_enter = true; self.trigger_on_exit = true; self }
    
    fn is_within(lat: Float, lng: Float) -> Bool {
        let distance = haversine_distance(self.latitude, self.longitude, lat, lng)
        distance <= self.radius_meters
    }
}

fn haversine_distance(lat1: Float, lng1: Float, lat2: Float, lng2: Float) -> Float {
    let r = 6371000.0  // Earth radius in meters
    let phi1 = lat1.to_radians()
    let phi2 = lat2.to_radians()
    let delta_phi = (lat2 - lat1).to_radians()
    let delta_lambda = (lng2 - lng1).to_radians()
    
    let a = (delta_phi / 2.0).sin().pow(2.0) +
            phi1.cos() * phi2.cos() * (delta_lambda / 2.0).sin().pow(2.0)
    let c = 2.0 * a.sqrt().atan2((1.0 - a).sqrt())
    
    r * c
}

// =============================================================================
// Reminder
// =============================================================================

struct Reminder {
    id: String
    user_id: String
    title: String
    description: Option<String>
    reminder_type: ReminderType
    status: ReminderStatus
    priority: ReminderPriority
    trigger_type: TriggerType
    trigger_at: Option<DateTime>
    location_trigger: Option<LocationTrigger>
    recurrence_rule: Option<String>
    notification_settings: NotificationSettings
    snooze_options: SnoozeOptions
    snoozed_until: Option<DateTime>
    related_entity_type: Option<String>
    related_entity_id: Option<String>
    action_url: Option<String>
    tags: [String]
    custom_data: Map<String, String>
    created_at: DateTime
    updated_at: DateTime
    completed_at: Option<DateTime>
    last_triggered_at: Option<DateTime>
    trigger_count: Int
}

impl Reminder {
    fn new(title: String, trigger_at: DateTime) -> Self {
        let now = DateTime.now()
        Reminder {
            id: UUID.v4().to_string(),
            user_id: "",
            title: title,
            description: None,
            reminder_type: ReminderType.OneTime,
            status: ReminderStatus.Active,
            priority: ReminderPriority.Normal,
            trigger_type: TriggerType.Time,
            trigger_at: Some(trigger_at),
            location_trigger: None,
            recurrence_rule: None,
            notification_settings: NotificationSettings.default(),
            snooze_options: SnoozeOptions.new(Duration.minutes(10)),
            snoozed_until: None,
            related_entity_type: None,
            related_entity_id: None,
            action_url: None,
            tags: [],
            custom_data: Map.empty(),
            created_at: now,
            updated_at: now,
            completed_at: None,
            last_triggered_at: None,
            trigger_count: 0
        }
    }
    
    fn location_based(title: String, trigger: LocationTrigger) -> Self {
        let now = DateTime.now()
        Reminder {
            id: UUID.v4().to_string(),
            user_id: "",
            title: title,
            description: None,
            reminder_type: ReminderType.Location,
            status: ReminderStatus.Active,
            priority: ReminderPriority.Normal,
            trigger_type: TriggerType.Location,
            trigger_at: None,
            location_trigger: Some(trigger),
            recurrence_rule: None,
            notification_settings: NotificationSettings.default(),
            snooze_options: SnoozeOptions.new(Duration.minutes(10)),
            snoozed_until: None,
            related_entity_type: None,
            related_entity_id: None,
            action_url: None,
            tags: [],
            custom_data: Map.empty(),
            created_at: now,
            updated_at: now,
            completed_at: None,
            last_triggered_at: None,
            trigger_count: 0
        }
    }
    
    fn recurring(title: String, start: DateTime, rule: String) -> Self {
        var reminder = Reminder.new(title, start)
        reminder.reminder_type = ReminderType.Recurring
        reminder.recurrence_rule = Some(rule)
        reminder
    }
    
    fn for_event(title: String, event_id: String, minutes_before: Int) -> Self {
        var reminder = Reminder.new(title, DateTime.now())  // Will be set based on event
        reminder.trigger_type = TriggerType.Event
        reminder.related_entity_type = Some("event")
        reminder.related_entity_id = Some(event_id)
        reminder
    }
    
    // Builder methods
    fn with_user(id: String) -> Self { self.user_id = id; self }
    fn with_description(d: String) -> Self { self.description = Some(d); self }
    fn with_priority(p: ReminderPriority) -> Self { self.priority = p; self }
    fn with_notification(settings: NotificationSettings) -> Self { self.notification_settings = settings; self }
    fn with_snooze(options: SnoozeOptions) -> Self { self.snooze_options = options; self }
    fn with_action_url(url: String) -> Self { self.action_url = Some(url); self }
    fn with_related_entity(entity_type: String, entity_id: String) -> Self {
        self.related_entity_type = Some(entity_type)
        self.related_entity_id = Some(entity_id)
        self
    }
    
    fn add_tag(tag: String) -> Self {
        if !self.tags.contains(tag) {
            self.tags.push(tag)
        }
        self
    }
    
    fn set_custom_data(key: String, value: String) -> Self {
        self.custom_data.insert(key, value)
        self
    }
    
    // Status methods
    fn complete() -> Self {
        self.status = ReminderStatus.Completed
        self.completed_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
        self
    }
    
    fn cancel() -> Self {
        self.status = ReminderStatus.Cancelled
        self.updated_at = DateTime.now()
        self
    }
    
    fn snooze() -> Result<Self, ReminderError> {
        if !self.snooze_options.can_snooze() {
            return Err(ReminderError.MaxSnoozeReached)
        }
        
        if let Some(new_time) = self.snooze_options.snooze() {
            self.status = ReminderStatus.Snoozed
            self.snoozed_until = Some(new_time)
            self.updated_at = DateTime.now()
            Ok(self)
        } else {
            Err(ReminderError.MaxSnoozeReached)
        }
    }
    
    fn snooze_for(duration: Duration) -> Self {
        self.status = ReminderStatus.Snoozed
        self.snoozed_until = Some(DateTime.now().add(duration))
        self.updated_at = DateTime.now()
        self
    }
    
    fn unsnooze() -> Self {
        if self.status == ReminderStatus.Snoozed {
            self.status = ReminderStatus.Active
            self.snoozed_until = None
            self.updated_at = DateTime.now()
        }
        self
    }
    
    fn trigger() -> Self {
        self.last_triggered_at = Some(DateTime.now())
        self.trigger_count += 1
        
        // For one-time reminders, mark as completed after trigger
        if self.reminder_type == ReminderType.OneTime {
            self.status = ReminderStatus.Completed
            self.completed_at = Some(DateTime.now())
        }
        
        self.updated_at = DateTime.now()
        self
    }
    
    fn reschedule(new_time: DateTime) -> Self {
        self.trigger_at = Some(new_time)
        self.status = ReminderStatus.Active
        self.snoozed_until = None
        self.updated_at = DateTime.now()
        self
    }
    
    // Query methods
    fn is_active() -> Bool {
        self.status == ReminderStatus.Active
    }
    
    fn is_snoozed() -> Bool {
        self.status == ReminderStatus.Snoozed
    }
    
    fn is_completed() -> Bool {
        self.status == ReminderStatus.Completed
    }
    
    fn is_due() -> Bool {
        if !self.is_active() { return false }
        
        match self.trigger_type {
            TriggerType.Time => {
                if let Some(trigger_at) = self.trigger_at {
                    DateTime.now().is_after(trigger_at) || DateTime.now().is_same(trigger_at)
                } else {
                    false
                }
            }
            _ => false
        }
    }
    
    fn is_overdue() -> Bool {
        if let Some(trigger_at) = self.trigger_at {
            self.is_active() && DateTime.now().is_after(trigger_at)
        } else {
            false
        }
    }
    
    fn time_until_trigger() -> Option<Duration> {
        if let Some(trigger_at) = self.trigger_at {
            if DateTime.now().is_before(trigger_at) {
                Some(trigger_at.diff(DateTime.now()))
            } else {
                None
            }
        } else {
            None
        }
    }
    
    fn can_snooze() -> Bool {
        self.snooze_options.can_snooze()
    }
    
    fn remaining_snoozes() -> Int {
        self.snooze_options.remaining_snoozes()
    }
    
    fn has_tag(tag: String) -> Bool {
        self.tags.contains(tag)
    }
    
    fn effective_trigger_time() -> Option<DateTime> {
        if self.is_snoozed() {
            self.snoozed_until
        } else {
            self.trigger_at
        }
    }
}

// =============================================================================
// Reminder Query
// =============================================================================

struct ReminderQuery {
    user_id: Option<String>
    statuses: [ReminderStatus]
    priorities: [ReminderPriority]
    types: [ReminderType]
    due_before: Option<DateTime>
    due_after: Option<DateTime>
    tags: [String]
    search_text: Option<String>
    include_completed: Bool
    include_cancelled: Bool
    limit: Int
    offset: Int
}

impl ReminderQuery {
    fn new() -> Self {
        ReminderQuery {
            user_id: None,
            statuses: [],
            priorities: [],
            types: [],
            due_before: None,
            due_after: None,
            tags: [],
            search_text: None,
            include_completed: false,
            include_cancelled: false,
            limit: 50,
            offset: 0
        }
    }
    
    fn for_user(id: String) -> Self { self.user_id = Some(id); self }
    fn active_only() -> Self { self.statuses = [ReminderStatus.Active]; self }
    fn with_status(s: ReminderStatus) -> Self { self.statuses.push(s); self }
    fn with_priority(p: ReminderPriority) -> Self { self.priorities.push(p); self }
    fn with_type(t: ReminderType) -> Self { self.types.push(t); self }
    fn due_today() -> Self {
        let now = DateTime.now()
        self.due_after = Some(now.start_of_day())
        self.due_before = Some(now.end_of_day())
        self
    }
    fn due_this_week() -> Self {
        let now = DateTime.now()
        self.due_after = Some(now.start_of_day())
        self.due_before = Some(now.add(Duration.days(7)))
        self
    }
    fn overdue() -> Self {
        self.due_before = Some(DateTime.now())
        self.statuses = [ReminderStatus.Active]
        self
    }
    fn upcoming() -> Self {
        self.due_after = Some(DateTime.now())
        self
    }
    fn with_tag(tag: String) -> Self { self.tags.push(tag); self }
    fn search(text: String) -> Self { self.search_text = Some(text); self }
    fn include_completed() -> Self { self.include_completed = true; self }
    fn include_cancelled() -> Self { self.include_cancelled = true; self }
    fn limit(n: Int) -> Self { self.limit = n; self }
    fn page(p: Int, per: Int) -> Self {
        self.limit = per
        self.offset = (p - 1) * per
        self
    }
}

// =============================================================================
// Reminder Service
// =============================================================================

actor ReminderService {
    state reminders: Map<String, Reminder>
    state by_user: Map<String, [String]>
    state due_queue: [String]  // Sorted by trigger time
    
    fn new() -> Self {
        ReminderService {
            reminders: Map.empty(),
            by_user: Map.empty(),
            due_queue: []
        }
    }
    
    fn create(reminder: Reminder) -> Result<Reminder, ReminderError> {
        if reminder.title.is_empty() {
            return Err(ReminderError.ValidationError("Title is required"))
        }
        
        self.reminders.insert(reminder.id.clone(), reminder.clone())
        
        // Index by user
        if !reminder.user_id.is_empty() {
            let user_reminders = self.by_user.get(reminder.user_id.clone()).unwrap_or([])
            user_reminders.push(reminder.id.clone())
            self.by_user.insert(reminder.user_id.clone(), user_reminders)
        }
        
        // Add to due queue if time-based
        if reminder.trigger_at.is_some() {
            self.insert_into_queue(reminder.id.clone())
        }
        
        Ok(reminder)
    }
    
    fn get(id: String) -> Option<Reminder> {
        self.reminders.get(id)
    }
    
    fn update(reminder: Reminder) -> Result<Reminder, ReminderError> {
        if !self.reminders.contains_key(reminder.id.clone()) {
            return Err(ReminderError.NotFound)
        }
        
        var updated = reminder.clone()
        updated.updated_at = DateTime.now()
        
        self.reminders.insert(updated.id.clone(), updated.clone())
        self.reorder_queue(updated.id.clone())
        
        Ok(updated)
    }
    
    fn delete(id: String) -> Result<(), ReminderError> {
        let reminder = self.reminders.remove(id.clone()).ok_or(ReminderError.NotFound)?
        
        // Remove from user index
        if let Some(user_reminders) = self.by_user.get_mut(reminder.user_id.clone()) {
            user_reminders.retain(|r| r != id)
        }
        
        // Remove from queue
        self.due_queue.retain(|r| r != id)
        
        Ok(())
    }
    
    fn complete(id: String) -> Result<Reminder, ReminderError> {
        let reminder = self.reminders.get_mut(id.clone()).ok_or(ReminderError.NotFound)?
        reminder.complete()
        self.due_queue.retain(|r| r != id)
        Ok(reminder.clone())
    }
    
    fn snooze(id: String) -> Result<Reminder, ReminderError> {
        let reminder = self.reminders.get_mut(id.clone()).ok_or(ReminderError.NotFound)?
        reminder.snooze()?
        self.reorder_queue(id)
        Ok(reminder.clone())
    }
    
    fn snooze_for(id: String, duration: Duration) -> Result<Reminder, ReminderError> {
        let reminder = self.reminders.get_mut(id.clone()).ok_or(ReminderError.NotFound)?
        reminder.snooze_for(duration)
        self.reorder_queue(id)
        Ok(reminder.clone())
    }
    
    fn query(q: ReminderQuery) -> [Reminder] {
        self.reminders.values().filter(|r| {
            // Filter by user
            if let Some(user_id) = q.user_id.clone() {
                if r.user_id != user_id { return false }
            }
            
            // Filter by status
            if !q.statuses.is_empty() && !q.statuses.contains(r.status) { return false }
            if !q.include_completed && r.is_completed() { return false }
            if !q.include_cancelled && r.status == ReminderStatus.Cancelled { return false }
            
            // Filter by priority
            if !q.priorities.is_empty() && !q.priorities.contains(r.priority) { return false }
            
            // Filter by type
            if !q.types.is_empty() && !q.types.contains(r.reminder_type) { return false }
            
            // Filter by due time
            if let Some(trigger_at) = r.effective_trigger_time() {
                if let Some(due_before) = q.due_before {
                    if trigger_at.is_after(due_before) { return false }
                }
                if let Some(due_after) = q.due_after {
                    if trigger_at.is_before(due_after) { return false }
                }
            }
            
            // Filter by tags
            if !q.tags.is_empty() {
                if !q.tags.iter().all(|t| r.has_tag(t.clone())) { return false }
            }
            
            // Search text
            if let Some(text) = q.search_text.clone() {
                let lower = text.to_lower()
                if !r.title.to_lower().contains(lower.clone()) &&
                   !r.description.clone().unwrap_or("").to_lower().contains(lower) {
                    return false
                }
            }
            
            true
        })
        .skip(q.offset)
        .take(q.limit)
        .collect()
    }
    
    fn get_due_reminders() -> [Reminder] {
        let now = DateTime.now()
        self.due_queue.iter()
            .filter_map(|id| self.reminders.get(id.clone()))
            .filter(|r| r.is_due())
            .collect()
    }
    
    fn get_upcoming(limit: Int) -> [Reminder] {
        self.due_queue.iter()
            .filter_map(|id| self.reminders.get(id.clone()))
            .filter(|r| r.is_active() && !r.is_due())
            .take(limit)
            .collect()
    }
    
    fn get_overdue() -> [Reminder] {
        self.reminders.values()
            .filter(|r| r.is_overdue())
            .collect()
    }
    
    fn get_by_user(user_id: String) -> [Reminder] {
        self.by_user.get(user_id)
            .unwrap_or([])
            .iter()
            .filter_map(|id| self.reminders.get(id.clone()))
            .collect()
    }
    
    fn count() -> Int {
        self.reminders.len()
    }
    
    fn count_active() -> Int {
        self.reminders.values().filter(|r| r.is_active()).count()
    }
    
    // Private helpers
    fn insert_into_queue(id: String) {
        if let Some(reminder) = self.reminders.get(id.clone()) {
            if let Some(trigger_at) = reminder.effective_trigger_time() {
                // Find insertion point
                var idx = 0
                for queue_id in self.due_queue.iter() {
                    if let Some(other) = self.reminders.get(queue_id.clone()) {
                        if let Some(other_time) = other.effective_trigger_time() {
                            if trigger_at.is_before(other_time) {
                                break
                            }
                        }
                    }
                    idx += 1
                }
                self.due_queue.insert(idx, id)
            }
        }
    }
    
    fn reorder_queue(id: String) {
        self.due_queue.retain(|r| r != id)
        self.insert_into_queue(id)
    }
}

// =============================================================================
// Errors
// =============================================================================

enum ReminderError {
    NotFound
    ValidationError(String)
    MaxSnoozeReached
    AlreadyCompleted
    PermissionDenied
}

impl Display for ReminderError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("Reminder not found")
            ValidationError(msg) => f.write("Validation error: \(msg)")
            MaxSnoozeReached => f.write("Maximum snooze count reached")
            AlreadyCompleted => f.write("Reminder already completed")
            PermissionDenied => f.write("Permission denied")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "reminder creation" {
    let trigger = DateTime.now().add(Duration.hours(1))
    let reminder = Reminder.new("Call mom", trigger)
        .with_description("Weekly call")
        .with_priority(ReminderPriority.High)
    
    assert_eq(reminder.title, "Call mom")?
    assert(reminder.is_active())?
    assert(!reminder.is_due())?
}

test "reminder snooze" {
    let trigger = DateTime.now()
    var reminder = Reminder.new("Test", trigger)
    
    assert(reminder.can_snooze())?
    assert_eq(reminder.remaining_snoozes(), 3)?
    
    reminder = reminder.snooze().unwrap()
    assert(reminder.is_snoozed())?
    assert_eq(reminder.remaining_snoozes(), 2)?
}

test "location reminder" {
    let trigger = LocationTrigger.new(40.7128, -74.0060, 100.0)
        .with_name("Office")
        .on_enter()
    
    let reminder = Reminder.location_based("Check in at office", trigger)
    
    assert_eq(reminder.reminder_type, ReminderType.Location)?
    assert(reminder.location_trigger.is_some())?
}

test "reminder service" {
    let svc = ReminderService.new()
    let trigger = DateTime.now().add(Duration.hours(1))
    let reminder = svc.create(Reminder.new("Test reminder", trigger).with_user("user1")).unwrap()
    
    assert(svc.get(reminder.id.clone()).is_some())?
    assert_eq(svc.count(), 1)?
    
    svc.complete(reminder.id.clone()).unwrap()
    let completed = svc.get(reminder.id.clone()).unwrap()
    assert(completed.is_completed())?
}

test "reminder query" {
    let svc = ReminderService.new()
    let now = DateTime.now()
    
    svc.create(Reminder.new("Task 1", now.add(Duration.hours(1))).with_user("user1").with_priority(ReminderPriority.High)).unwrap()
    svc.create(Reminder.new("Task 2", now.add(Duration.hours(2))).with_user("user1")).unwrap()
    svc.create(Reminder.new("Task 3", now.add(Duration.hours(3))).with_user("user2")).unwrap()
    
    let user1_reminders = svc.query(ReminderQuery.new().for_user("user1"))
    assert_eq(user1_reminders.len(), 2)?
    
    let high_priority = svc.query(ReminderQuery.new().with_priority(ReminderPriority.High))
    assert_eq(high_priority.len(), 1)?
}
