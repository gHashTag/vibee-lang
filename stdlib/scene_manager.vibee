// =============================================================================
// Vibee OS â€” Scene Manager Module
// Scene management, transitions, and lifecycle
// =============================================================================

use animation::{Easing, Tween}
use color::RGBA

// -----------------------------------------------------------------------------
// Scene Trait
// -----------------------------------------------------------------------------

/// Trait that all scenes must implement
trait Scene {
    /// Called when scene is created
    fn on_create()
    
    /// Called when scene becomes active
    fn on_enter()
    
    /// Called when scene is about to be deactivated
    fn on_exit()
    
    /// Called when scene is destroyed
    fn on_destroy()
    
    /// Called when scene is paused (another scene pushed on top)
    fn on_pause() {}
    
    /// Called when scene is resumed (scene on top was popped)
    fn on_resume() {}
    
    /// Fixed timestep update
    fn fixed_update(dt: Float64) {}
    
    /// Variable timestep update
    fn update(dt: Float64)
    
    /// Render the scene
    fn render(alpha: Float64)
    
    /// Handle input events
    fn on_event(event: SceneEvent) -> Bool { false }
    
    /// Scene name for debugging
    fn name() -> String { "Scene" }
}

// -----------------------------------------------------------------------------
// Scene Events
// -----------------------------------------------------------------------------

enum SceneEvent {
    KeyDown(Int),
    KeyUp(Int),
    MouseMove(Float, Float),
    MouseDown(Int),
    MouseUp(Int),
    TouchStart(Int, Float, Float),
    TouchMove(Int, Float, Float),
    TouchEnd(Int),
    Custom(String, Any)
}

// -----------------------------------------------------------------------------
// Scene State
// -----------------------------------------------------------------------------

enum SceneState {
    Created,
    Entering,
    Active,
    Paused,
    Exiting,
    Destroyed
}

// -----------------------------------------------------------------------------
// Scene Wrapper
// -----------------------------------------------------------------------------

struct SceneWrapper {
    scene: Box<dyn Scene>
    state: SceneState
    transition_progress: Float64
    
    fn new(scene: Box<dyn Scene>) -> Self {
        SceneWrapper {
            scene: scene,
            state: SceneState.Created,
            transition_progress: 0.0
        }
    }
}

// -----------------------------------------------------------------------------
// Scene Manager
// -----------------------------------------------------------------------------

/// Manages scene stack and transitions
struct SceneManager {
    scenes: [SceneWrapper]
    pending_operations: [SceneOperation]
    transition: Option<SceneTransition>
    transition_progress: Float64
    
    fn new() -> Self {
        SceneManager {
            scenes: [],
            pending_operations: [],
            transition: None,
            transition_progress: 0.0
        }
    }
    
    /// Push a new scene onto the stack
    fn push<S: Scene>(scene: S) {
        self.push_with_transition(scene, None)
    }
    
    /// Push with transition
    fn push_with_transition<S: Scene>(scene: S, transition: Option<SceneTransition>) {
        self.pending_operations.push(SceneOperation.Push(Box.new(scene), transition))
    }
    
    /// Pop the current scene
    fn pop() {
        self.pop_with_transition(None)
    }
    
    /// Pop with transition
    fn pop_with_transition(transition: Option<SceneTransition>) {
        self.pending_operations.push(SceneOperation.Pop(transition))
    }
    
    /// Replace current scene
    fn replace<S: Scene>(scene: S) {
        self.replace_with_transition(scene, None)
    }
    
    /// Replace with transition
    fn replace_with_transition<S: Scene>(scene: S, transition: Option<SceneTransition>) {
        self.pending_operations.push(SceneOperation.Replace(Box.new(scene), transition))
    }
    
    /// Clear all scenes and push new one
    fn set<S: Scene>(scene: S) {
        self.pending_operations.push(SceneOperation.Clear)
        self.pending_operations.push(SceneOperation.Push(Box.new(scene), None))
    }
    
    /// Clear all scenes
    fn clear() {
        self.pending_operations.push(SceneOperation.Clear)
    }
    
    /// Update the scene manager
    fn update(dt: Float64) {
        // Process pending operations
        self.process_pending_operations()
        
        // Update transition
        if let Some(trans) = &mut self.transition {
            self.transition_progress += dt / trans.duration
            if self.transition_progress >= 1.0 {
                self.transition_progress = 1.0
                self.complete_transition()
            }
        }
        
        // Update active scene
        if let Some(wrapper) = self.current_mut() {
            if wrapper.state == SceneState.Active {
                wrapper.scene.update(dt)
            }
        }
    }
    
    /// Fixed update
    fn fixed_update(dt: Float64) {
        if let Some(wrapper) = self.current_mut() {
            if wrapper.state == SceneState.Active {
                wrapper.scene.fixed_update(dt)
            }
        }
    }
    
    /// Render scenes
    fn render(alpha: Float64) {
        // Render scenes from bottom to top
        for wrapper in self.scenes.iter() {
            if wrapper.state == SceneState.Active || wrapper.state == SceneState.Paused {
                wrapper.scene.render(alpha)
            }
        }
        
        // Render transition overlay
        if let Some(trans) = &self.transition {
            trans.render(self.transition_progress)
        }
    }
    
    /// Handle events
    fn on_event(event: SceneEvent) -> Bool {
        if let Some(wrapper) = self.current_mut() {
            return wrapper.scene.on_event(event)
        }
        false
    }
    
    /// Get current scene
    fn current() -> Option<&Box<dyn Scene>> {
        self.scenes.last().map(|w| &w.scene)
    }
    
    fn current_mut() -> Option<&mut SceneWrapper> {
        self.scenes.last_mut()
    }
    
    /// Get scene count
    fn count() -> Int { self.scenes.len() }
    
    /// Check if empty
    fn is_empty() -> Bool { self.scenes.is_empty() }
    
    /// Check if transitioning
    fn is_transitioning() -> Bool { self.transition.is_some() }
    
    fn process_pending_operations() {
        if self.is_transitioning() { return }
        
        while let Some(op) = self.pending_operations.pop_front() {
            match op {
                Push(scene, trans) => self.do_push(scene, trans),
                Pop(trans) => self.do_pop(trans),
                Replace(scene, trans) => self.do_replace(scene, trans),
                Clear => self.do_clear()
            }
        }
    }
    
    fn do_push(scene: Box<dyn Scene>, transition: Option<SceneTransition>) {
        // Pause current scene
        if let Some(wrapper) = self.current_mut() {
            wrapper.scene.on_pause()
            wrapper.state = SceneState.Paused
        }
        
        // Create and enter new scene
        var wrapper = SceneWrapper.new(scene)
        wrapper.scene.on_create()
        wrapper.scene.on_enter()
        wrapper.state = SceneState.Active
        self.scenes.push(wrapper)
        
        if let Some(trans) = transition {
            self.transition = Some(trans)
            self.transition_progress = 0.0
        }
    }
    
    fn do_pop(transition: Option<SceneTransition>) {
        if self.scenes.is_empty() { return }
        
        if let Some(trans) = transition {
            self.transition = Some(trans)
            self.transition_progress = 0.0
        } else {
            self.complete_pop()
        }
    }
    
    fn complete_pop() {
        if let Some(mut wrapper) = self.scenes.pop() {
            wrapper.scene.on_exit()
            wrapper.scene.on_destroy()
            wrapper.state = SceneState.Destroyed
        }
        
        // Resume previous scene
        if let Some(wrapper) = self.current_mut() {
            wrapper.scene.on_resume()
            wrapper.state = SceneState.Active
        }
    }
    
    fn do_replace(scene: Box<dyn Scene>, transition: Option<SceneTransition>) {
        self.do_pop(None)
        self.do_push(scene, transition)
    }
    
    fn do_clear() {
        while !self.scenes.is_empty() {
            self.complete_pop()
        }
    }
    
    fn complete_transition() {
        self.transition = None
        self.transition_progress = 0.0
    }
}

enum SceneOperation {
    Push(Box<dyn Scene>, Option<SceneTransition>),
    Pop(Option<SceneTransition>),
    Replace(Box<dyn Scene>, Option<SceneTransition>),
    Clear
}

// -----------------------------------------------------------------------------
// Scene Transitions
// -----------------------------------------------------------------------------

/// Scene transition effect
struct SceneTransition {
    kind: TransitionKind
    duration: Float64
    easing: Easing
    color: RGBA
    
    fn new(kind: TransitionKind, duration: Float64) -> Self {
        SceneTransition {
            kind: kind,
            duration: duration,
            easing: Easing.EaseInOut,
            color: RGBA.black()
        }
    }
    
    fn with_easing(e: Easing) -> Self { self.easing = e; self }
    fn with_color(c: RGBA) -> Self { self.color = c; self }
    
    fn fade(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.Fade, duration)
    }
    
    fn slide_left(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.SlideLeft, duration)
    }
    
    fn slide_right(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.SlideRight, duration)
    }
    
    fn slide_up(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.SlideUp, duration)
    }
    
    fn slide_down(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.SlideDown, duration)
    }
    
    fn zoom_in(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.ZoomIn, duration)
    }
    
    fn zoom_out(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.ZoomOut, duration)
    }
    
    fn wipe_left(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.WipeLeft, duration)
    }
    
    fn circle(duration: Float64) -> Self {
        SceneTransition.new(TransitionKind.Circle, duration)
    }
    
    fn render(progress: Float64) {
        let t = self.easing.apply(progress)
        
        match self.kind {
            Fade => self.render_fade(t),
            SlideLeft => self.render_slide(-t, 0.0),
            SlideRight => self.render_slide(t, 0.0),
            SlideUp => self.render_slide(0.0, -t),
            SlideDown => self.render_slide(0.0, t),
            ZoomIn => self.render_zoom(1.0 - t),
            ZoomOut => self.render_zoom(1.0 + t),
            WipeLeft => self.render_wipe(t),
            Circle => self.render_circle(t),
            Custom(f) => f(t)
        }
    }
    
    fn render_fade(t: Float64) {
        let alpha = if t < 0.5 { t * 2.0 } else { (1.0 - t) * 2.0 }
        @native("draw_rect_filled", 0.0, 0.0, 9999.0, 9999.0, 
                RGBA.new(self.color.r, self.color.g, self.color.b, (alpha * 255.0) as UInt8))
    }
    
    fn render_slide(x: Float64, y: Float64) {
        @native("set_render_offset", x * @native("screen_width"), y * @native("screen_height"))
    }
    
    fn render_zoom(scale: Float64) {
        @native("set_render_scale", scale, scale)
    }
    
    fn render_wipe(t: Float64) {
        let width = @native("screen_width") as Float64
        @native("draw_rect_filled", 0.0, 0.0, width * t, 9999.0, self.color)
    }
    
    fn render_circle(t: Float64) {
        let cx = @native("screen_width") as Float64 / 2.0
        let cy = @native("screen_height") as Float64 / 2.0
        let max_radius = (cx * cx + cy * cy).sqrt()
        let radius = if t < 0.5 { max_radius * (1.0 - t * 2.0) } else { max_radius * (t - 0.5) * 2.0 }
        @native("draw_circle_mask", cx, cy, radius, self.color)
    }
}

enum TransitionKind {
    Fade,
    SlideLeft,
    SlideRight,
    SlideUp,
    SlideDown,
    ZoomIn,
    ZoomOut,
    WipeLeft,
    Circle,
    Custom(fn(Float64))
}

// -----------------------------------------------------------------------------
// Scene Stack
// -----------------------------------------------------------------------------

/// Lightweight scene stack without transitions
struct SceneStack<S: Scene> {
    scenes: [S]
    
    fn new() -> Self { SceneStack { scenes: [] } }
    
    fn push(scene: S) {
        if let Some(current) = self.scenes.last_mut() {
            current.on_pause()
        }
        scene.on_create()
        scene.on_enter()
        self.scenes.push(scene)
    }
    
    fn pop() -> Option<S> {
        if let Some(mut scene) = self.scenes.pop() {
            scene.on_exit()
            scene.on_destroy()
            
            if let Some(current) = self.scenes.last_mut() {
                current.on_resume()
            }
            
            Some(scene)
        } else { None }
    }
    
    fn current() -> Option<&S> { self.scenes.last() }
    fn current_mut() -> Option<&mut S> { self.scenes.last_mut() }
    fn count() -> Int { self.scenes.len() }
    fn is_empty() -> Bool { self.scenes.is_empty() }
}

// -----------------------------------------------------------------------------
// Scene Registry
// -----------------------------------------------------------------------------

/// Registry for scene factories
struct SceneRegistry {
    factories: Map<String, fn() -> Box<dyn Scene>>
    
    fn new() -> Self { SceneRegistry { factories: Map.new() } }
    
    fn register<S: Scene>(name: String, factory: fn() -> S) {
        self.factories.insert(name, || Box.new(factory()))
    }
    
    fn create(name: String) -> Option<Box<dyn Scene>> {
        self.factories.get(name).map(|f| f())
    }
    
    fn has(name: String) -> Bool {
        self.factories.contains_key(name)
    }
    
    fn names() -> [String] {
        self.factories.keys().collect()
    }
}

// -----------------------------------------------------------------------------
// Preloading Scene
// -----------------------------------------------------------------------------

/// Scene that shows loading progress while preloading next scene
struct LoadingScene<S: Scene> {
    next_scene: Option<S>
    loader: fn() -> S
    progress: Float64
    on_progress: Option<fn(Float64)>
    
    fn new(loader: fn() -> S) -> Self {
        LoadingScene {
            next_scene: None,
            loader: loader,
            progress: 0.0,
            on_progress: None
        }
    }
    
    fn with_progress_callback(callback: fn(Float64)) -> Self {
        self.on_progress = Some(callback)
        self
    }
}

impl<S: Scene> Scene for LoadingScene<S> {
    fn on_create() {}
    fn on_enter() {
        // Start async loading
        @native("spawn_task", || {
            self.next_scene = Some((self.loader)())
            self.progress = 1.0
        })
    }
    fn on_exit() {}
    fn on_destroy() {}
    
    fn update(dt: Float64) {
        if let Some(callback) = &self.on_progress {
            callback(self.progress)
        }
    }
    
    fn render(alpha: Float64) {
        // Render loading bar
        let width = @native("screen_width") as Float64
        let height = @native("screen_height") as Float64
        let bar_width = width * 0.6
        let bar_height = 20.0
        let x = (width - bar_width) / 2.0
        let y = height / 2.0
        
        @native("draw_rect", x, y, bar_width, bar_height, RGBA.white())
        @native("draw_rect_filled", x, y, bar_width * self.progress, bar_height, RGBA.green())
    }
    
    fn name() -> String { "LoadingScene" }
}

// -----------------------------------------------------------------------------
// Scene Builder
// -----------------------------------------------------------------------------

/// Builder for creating scenes with callbacks
struct SceneBuilder {
    on_create_fn: Option<fn()>
    on_enter_fn: Option<fn()>
    on_exit_fn: Option<fn()>
    on_destroy_fn: Option<fn()>
    update_fn: Option<fn(Float64)>
    render_fn: Option<fn(Float64)>
    scene_name: String
    
    fn new(name: String) -> Self {
        SceneBuilder {
            on_create_fn: None,
            on_enter_fn: None,
            on_exit_fn: None,
            on_destroy_fn: None,
            update_fn: None,
            render_fn: None,
            scene_name: name
        }
    }
    
    fn on_create(f: fn()) -> Self { self.on_create_fn = Some(f); self }
    fn on_enter(f: fn()) -> Self { self.on_enter_fn = Some(f); self }
    fn on_exit(f: fn()) -> Self { self.on_exit_fn = Some(f); self }
    fn on_destroy(f: fn()) -> Self { self.on_destroy_fn = Some(f); self }
    fn update(f: fn(Float64)) -> Self { self.update_fn = Some(f); self }
    fn render(f: fn(Float64)) -> Self { self.render_fn = Some(f); self }
    
    fn build() -> CallbackScene {
        CallbackScene {
            on_create_fn: self.on_create_fn,
            on_enter_fn: self.on_enter_fn,
            on_exit_fn: self.on_exit_fn,
            on_destroy_fn: self.on_destroy_fn,
            update_fn: self.update_fn,
            render_fn: self.render_fn,
            scene_name: self.scene_name
        }
    }
}

struct CallbackScene {
    on_create_fn: Option<fn()>
    on_enter_fn: Option<fn()>
    on_exit_fn: Option<fn()>
    on_destroy_fn: Option<fn()>
    update_fn: Option<fn(Float64)>
    render_fn: Option<fn(Float64)>
    scene_name: String
}

impl Scene for CallbackScene {
    fn on_create() { if let Some(f) = &self.on_create_fn { f() } }
    fn on_enter() { if let Some(f) = &self.on_enter_fn { f() } }
    fn on_exit() { if let Some(f) = &self.on_exit_fn { f() } }
    fn on_destroy() { if let Some(f) = &self.on_destroy_fn { f() } }
    fn update(dt: Float64) { if let Some(f) = &self.update_fn { f(dt) } }
    fn render(alpha: Float64) { if let Some(f) = &self.render_fn { f(alpha) } }
    fn name() -> String { self.scene_name.clone() }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "scene manager push pop" {
    var manager = SceneManager.new()
    assert(manager.is_empty())?
    
    let scene = SceneBuilder.new("test").build()
    manager.push(scene)
    manager.update(0.016)
    
    assert_eq(manager.count(), 1)?
    
    manager.pop()
    manager.update(0.016)
    
    assert(manager.is_empty())?
}

test "scene transition fade" {
    let trans = SceneTransition.fade(0.5)
    assert_eq(trans.duration, 0.5)?
}

test "scene registry" {
    var registry = SceneRegistry.new()
    registry.register("menu", || SceneBuilder.new("menu").build())
    
    assert(registry.has("menu"))?
    let scene = registry.create("menu")?
    assert_eq(scene.name(), "menu")?
}

test "scene builder" {
    var created = false
    let scene = SceneBuilder.new("test")
        .on_create(|| { created = true })
        .build()
    
    scene.on_create()
    assert(created)?
}
