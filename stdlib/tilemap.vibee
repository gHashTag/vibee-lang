// =============================================================================
// Vibee OS â€” Tilemap Module
// Tile-based maps for 2D games
// =============================================================================

use vector::Vec2
use color::RGBA
use sprite::{Texture, SpriteSheet, SpriteBatch, Sprite}
use canvas::Rect

// -----------------------------------------------------------------------------
// Tile
// -----------------------------------------------------------------------------

/// Single tile data
struct Tile {
    id: Int
    flip_x: Bool
    flip_y: Bool
    rotation: Int  // 0, 90, 180, 270
    
    fn new(id: Int) -> Self { Tile { id: id, flip_x: false, flip_y: false, rotation: 0 } }
    fn empty() -> Self { Tile { id: -1, flip_x: false, flip_y: false, rotation: 0 } }
    fn is_empty() -> Bool { self.id < 0 }
    
    fn flipped_h() -> Self { Tile { flip_x: !self.flip_x, ..self } }
    fn flipped_v() -> Self { Tile { flip_y: !self.flip_y, ..self } }
    fn rotated(deg: Int) -> Self { Tile { rotation: (self.rotation + deg) % 360, ..self } }
}

// -----------------------------------------------------------------------------
// Tile Layer
// -----------------------------------------------------------------------------

/// Single layer of tiles
struct TileLayer {
    name: String
    width: Int
    height: Int
    tiles: [Tile]
    visible: Bool
    opacity: Float
    offset: Vec2
    parallax: Vec2
    
    fn new(name: String, width: Int, height: Int) -> Self {
        TileLayer {
            name: name, width: width, height: height,
            tiles: [Tile.empty(); width * height],
            visible: true, opacity: 1.0,
            offset: Vec2.zero(), parallax: Vec2.one()
        }
    }
    
    fn get(x: Int, y: Int) -> Option<&Tile> {
        if x < 0 || x >= self.width || y < 0 || y >= self.height { return None }
        Some(&self.tiles[y * self.width + x])
    }
    
    fn get_mut(x: Int, y: Int) -> Option<&mut Tile> {
        if x < 0 || x >= self.width || y < 0 || y >= self.height { return None }
        Some(&mut self.tiles[y * self.width + x])
    }
    
    fn set(x: Int, y: Int, tile: Tile) {
        if x >= 0 && x < self.width && y >= 0 && y < self.height {
            self.tiles[y * self.width + x] = tile
        }
    }
    
    fn fill(tile: Tile) {
        for i in 0..self.tiles.len() { self.tiles[i] = tile }
    }
    
    fn fill_rect(x: Int, y: Int, w: Int, h: Int, tile: Tile) {
        for dy in 0..h {
            for dx in 0..w {
                self.set(x + dx, y + dy, tile)
            }
        }
    }
    
    fn clear() { self.fill(Tile.empty()) }
    
    fn set_parallax(x: Float, y: Float) -> Self { self.parallax = Vec2.new(x, y); self }
    fn set_offset(x: Float, y: Float) -> Self { self.offset = Vec2.new(x, y); self }
}

// -----------------------------------------------------------------------------
// Tileset
// -----------------------------------------------------------------------------

/// Tileset with collision and property data
struct Tileset {
    name: String
    sheet: SpriteSheet
    first_gid: Int
    properties: Map<Int, TileProperties>
    
    fn new(name: String, sheet: SpriteSheet) -> Self {
        Tileset { name: name, sheet: sheet, first_gid: 0, properties: Map.new() }
    }
    
    fn with_first_gid(gid: Int) -> Self { self.first_gid = gid; self }
    
    fn set_properties(tile_id: Int, props: TileProperties) {
        self.properties.insert(tile_id, props)
    }
    
    fn get_properties(tile_id: Int) -> Option<&TileProperties> {
        self.properties.get(tile_id)
    }
    
    fn get_sprite(tile_id: Int) -> Sprite {
        self.sheet.get_sprite(tile_id - self.first_gid)
    }
    
    fn contains(tile_id: Int) -> Bool {
        tile_id >= self.first_gid && tile_id < self.first_gid + self.sheet.tile_count()
    }
}

/// Properties for individual tiles
struct TileProperties {
    solid: Bool
    friction: Float
    custom: Map<String, String>
    
    fn new() -> Self {
        TileProperties { solid: false, friction: 1.0, custom: Map.new() }
    }
    
    fn set_solid(s: Bool) -> Self { self.solid = s; self }
    fn set_friction(f: Float) -> Self { self.friction = f; self }
    fn set_custom(key: String, value: String) -> Self { self.custom.insert(key, value); self }
}

// -----------------------------------------------------------------------------
// Tilemap
// -----------------------------------------------------------------------------

/// Complete tilemap with multiple layers
struct Tilemap {
    width: Int
    height: Int
    tile_width: Int
    tile_height: Int
    layers: [TileLayer]
    tilesets: [Tileset]
    properties: Map<String, String>
    
    fn new(width: Int, height: Int, tile_w: Int, tile_h: Int) -> Self {
        Tilemap {
            width: width, height: height,
            tile_width: tile_w, tile_height: tile_h,
            layers: [], tilesets: [], properties: Map.new()
        }
    }
    
    fn add_layer(layer: TileLayer) -> Int {
        self.layers.push(layer)
        self.layers.len() - 1
    }
    
    fn add_tileset(tileset: Tileset) {
        self.tilesets.push(tileset)
    }
    
    fn get_layer(name: String) -> Option<&TileLayer> {
        self.layers.iter().find(|l| l.name == name)
    }
    
    fn get_layer_mut(name: String) -> Option<&mut TileLayer> {
        self.layers.iter_mut().find(|l| l.name == name)
    }
    
    fn get_layer_at(index: Int) -> Option<&TileLayer> {
        if index >= 0 && index < self.layers.len() { Some(&self.layers[index]) } else { None }
    }
    
    fn pixel_width() -> Int { self.width * self.tile_width }
    fn pixel_height() -> Int { self.height * self.tile_height }
    
    fn world_to_tile(world_pos: Vec2) -> (Int, Int) {
        ((world_pos.x / self.tile_width as Float) as Int,
         (world_pos.y / self.tile_height as Float) as Int)
    }
    
    fn tile_to_world(tile_x: Int, tile_y: Int) -> Vec2 {
        Vec2.new((tile_x * self.tile_width) as Float, (tile_y * self.tile_height) as Float)
    }
    
    fn tile_center(tile_x: Int, tile_y: Int) -> Vec2 {
        Vec2.new(
            (tile_x * self.tile_width + self.tile_width / 2) as Float,
            (tile_y * self.tile_height + self.tile_height / 2) as Float
        )
    }
    
    fn get_tileset_for(tile_id: Int) -> Option<&Tileset> {
        self.tilesets.iter().find(|ts| ts.contains(tile_id))
    }
}

// -----------------------------------------------------------------------------
// Tilemap Renderer
// -----------------------------------------------------------------------------

/// Renderer for tilemaps
struct TilemapRenderer {
    batch: SpriteBatch
    
    fn new() -> Self {
        TilemapRenderer { batch: SpriteBatch.new(10000) }
    }
    
    fn render(tilemap: &Tilemap, camera: Vec2, viewport: Vec2) {
        self.batch.begin()
        
        for layer in tilemap.layers.iter() {
            if !layer.visible { continue }
            self.render_layer(tilemap, layer, camera, viewport)
        }
        
        self.batch.end()
    }
    
    fn render_layer(tilemap: &Tilemap, layer: &TileLayer, camera: Vec2, viewport: Vec2) {
        let parallax_offset = Vec2.new(
            camera.x * (1.0 - layer.parallax.x),
            camera.y * (1.0 - layer.parallax.y)
        )
        let offset = layer.offset + parallax_offset
        
        let start_x = ((camera.x - offset.x) / tilemap.tile_width as Float).floor() as Int - 1
        let start_y = ((camera.y - offset.y) / tilemap.tile_height as Float).floor() as Int - 1
        let end_x = start_x + (viewport.x / tilemap.tile_width as Float).ceil() as Int + 2
        let end_y = start_y + (viewport.y / tilemap.tile_height as Float).ceil() as Int + 2
        
        for y in start_y.max(0)..end_y.min(layer.height) {
            for x in start_x.max(0)..end_x.min(layer.width) {
                if let Some(tile) = layer.get(x, y) {
                    if tile.is_empty() { continue }
                    
                    if let Some(tileset) = tilemap.get_tileset_for(tile.id) {
                        var sprite = tileset.get_sprite(tile.id)
                        sprite.flip_x = tile.flip_x
                        sprite.flip_y = tile.flip_y
                        sprite.color.a = (layer.opacity * 255.0) as UInt8
                        
                        let pos = Vec2.new(
                            (x * tilemap.tile_width) as Float + offset.x - camera.x,
                            (y * tilemap.tile_height) as Float + offset.y - camera.y
                        )
                        
                        let rotation = (tile.rotation as Float) * 3.14159 / 180.0
                        self.batch.draw(&sprite, pos, Vec2.one(), rotation)
                    }
                }
            }
        }
    }
    
    fn render_layer_by_name(tilemap: &Tilemap, name: String, camera: Vec2, viewport: Vec2) {
        if let Some(layer) = tilemap.get_layer(name) {
            self.batch.begin()
            self.render_layer(tilemap, layer, camera, viewport)
            self.batch.end()
        }
    }
}

// -----------------------------------------------------------------------------
// Collision
// -----------------------------------------------------------------------------

/// Tilemap collision helper
struct TilemapCollision {
    tilemap: &Tilemap
    collision_layer: String
    
    fn new(tilemap: &Tilemap, layer_name: String) -> Self {
        TilemapCollision { tilemap: tilemap, collision_layer: layer_name }
    }
    
    fn is_solid(x: Int, y: Int) -> Bool {
        if let Some(layer) = self.tilemap.get_layer(self.collision_layer.clone()) {
            if let Some(tile) = layer.get(x, y) {
                if tile.is_empty() { return false }
                if let Some(tileset) = self.tilemap.get_tileset_for(tile.id) {
                    if let Some(props) = tileset.get_properties(tile.id) {
                        return props.solid
                    }
                }
            }
        }
        false
    }
    
    fn is_solid_at(world_pos: Vec2) -> Bool {
        let (tx, ty) = self.tilemap.world_to_tile(world_pos)
        self.is_solid(tx, ty)
    }
    
    fn get_tile_rect(x: Int, y: Int) -> Rect {
        Rect.new(
            (x * self.tilemap.tile_width) as Float,
            (y * self.tilemap.tile_height) as Float,
            self.tilemap.tile_width as Float,
            self.tilemap.tile_height as Float
        )
    }
    
    fn check_rect(rect: Rect) -> [Rect] {
        var collisions = []
        
        let start_x = (rect.x / self.tilemap.tile_width as Float).floor() as Int
        let start_y = (rect.y / self.tilemap.tile_height as Float).floor() as Int
        let end_x = ((rect.x + rect.width) / self.tilemap.tile_width as Float).ceil() as Int
        let end_y = ((rect.y + rect.height) / self.tilemap.tile_height as Float).ceil() as Int
        
        for y in start_y..=end_y {
            for x in start_x..=end_x {
                if self.is_solid(x, y) {
                    collisions.push(self.get_tile_rect(x, y))
                }
            }
        }
        
        collisions
    }
    
    fn raycast(origin: Vec2, direction: Vec2, max_dist: Float) -> Option<TileHit> {
        let dir = direction.normalize()
        let step_x = if dir.x > 0.0 { 1 } else { -1 }
        let step_y = if dir.y > 0.0 { 1 } else { -1 }
        
        var (tile_x, tile_y) = self.tilemap.world_to_tile(origin)
        let tw = self.tilemap.tile_width as Float
        let th = self.tilemap.tile_height as Float
        
        var t_max_x = if dir.x != 0.0 {
            let next_x = if dir.x > 0.0 { (tile_x + 1) as Float * tw } else { tile_x as Float * tw }
            (next_x - origin.x) / dir.x
        } else { Float.MAX }
        
        var t_max_y = if dir.y != 0.0 {
            let next_y = if dir.y > 0.0 { (tile_y + 1) as Float * th } else { tile_y as Float * th }
            (next_y - origin.y) / dir.y
        } else { Float.MAX }
        
        let t_delta_x = if dir.x != 0.0 { tw / dir.x.abs() } else { Float.MAX }
        let t_delta_y = if dir.y != 0.0 { th / dir.y.abs() } else { Float.MAX }
        
        var dist = 0.0
        
        while dist < max_dist {
            if self.is_solid(tile_x, tile_y) {
                let hit_point = origin + dir * dist
                let normal = if t_max_x < t_max_y {
                    Vec2.new(-step_x as Float, 0.0)
                } else {
                    Vec2.new(0.0, -step_y as Float)
                }
                return Some(TileHit { point: hit_point, normal: normal, tile_x: tile_x, tile_y: tile_y, distance: dist })
            }
            
            if t_max_x < t_max_y {
                dist = t_max_x
                t_max_x += t_delta_x
                tile_x += step_x
            } else {
                dist = t_max_y
                t_max_y += t_delta_y
                tile_y += step_y
            }
        }
        
        None
    }
}

struct TileHit {
    point: Vec2
    normal: Vec2
    tile_x: Int
    tile_y: Int
    distance: Float
}

// -----------------------------------------------------------------------------
// Auto-tiling
// -----------------------------------------------------------------------------

/// Auto-tile rules for procedural tiling
struct AutoTiler {
    rules: Map<Int, Int>  // bitmask -> tile_id
    
    fn new() -> Self { AutoTiler { rules: Map.new() } }
    
    fn add_rule(bitmask: Int, tile_id: Int) -> Self {
        self.rules.insert(bitmask, tile_id)
        self
    }
    
    fn apply(layer: &mut TileLayer, check: fn(Int, Int) -> Bool) {
        for y in 0..layer.height {
            for x in 0..layer.width {
                if !check(x, y) { continue }
                
                var mask = 0
                if y > 0 && check(x, y - 1) { mask |= 1 }                    // Top
                if x < layer.width - 1 && check(x + 1, y) { mask |= 2 }     // Right
                if y < layer.height - 1 && check(x, y + 1) { mask |= 4 }    // Bottom
                if x > 0 && check(x - 1, y) { mask |= 8 }                    // Left
                
                if let Some(tile_id) = self.rules.get(mask) {
                    layer.set(x, y, Tile.new(*tile_id))
                }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// TMX Loader (Tiled format)
// -----------------------------------------------------------------------------

/// Load tilemap from TMX file
fn load_tmx(path: String) -> Result<Tilemap, String> {
    @native("tilemap_load_tmx", path)
}

/// Save tilemap to TMX file
fn save_tmx(tilemap: &Tilemap, path: String) -> Result<(), String> {
    @native("tilemap_save_tmx", tilemap, path)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "tilemap creation" {
    let map = Tilemap.new(10, 10, 32, 32)
    assert_eq(map.pixel_width(), 320)?
    assert_eq(map.pixel_height(), 320)?
}

test "tile layer" {
    var layer = TileLayer.new("ground", 5, 5)
    layer.set(2, 2, Tile.new(1))
    let tile = layer.get(2, 2)?
    assert_eq(tile.id, 1)?
}

test "world to tile" {
    let map = Tilemap.new(10, 10, 32, 32)
    let (tx, ty) = map.world_to_tile(Vec2.new(50.0, 70.0))
    assert_eq(tx, 1)?
    assert_eq(ty, 2)?
}

test "tile to world" {
    let map = Tilemap.new(10, 10, 32, 32)
    let pos = map.tile_to_world(3, 4)
    assert_eq(pos.x, 96.0)?
    assert_eq(pos.y, 128.0)?
}
