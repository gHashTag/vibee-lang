// =============================================================================
// Vibee OS â€” JWT Module
// JSON Web Tokens
// =============================================================================

/// JWT Token
struct Jwt { header: JwtHeader, claims: Claims, signature: [UInt8] }

impl Jwt {
    /// Decode without verification
    fn decode(token: String) -> Result<Self, JwtError> {
        let parts = token.split(".")
        if parts.len() != 3 { return Err(JwtError.InvalidFormat) }
        
        let header_json = base64.decode_url_safe(parts[0]).map_err(|_| JwtError.InvalidEncoding)?
        let claims_json = base64.decode_url_safe(parts[1]).map_err(|_| JwtError.InvalidEncoding)?
        let signature = base64.decode_url_safe(parts[2]).map_err(|_| JwtError.InvalidEncoding)?
        
        let header = json.decode::<JwtHeader>(String.from_utf8(header_json)?)?
        let claims = json.decode::<Claims>(String.from_utf8(claims_json)?)?
        
        Ok(Jwt { header: header, claims: claims, signature: signature })
    }
    
    /// Decode and verify
    fn verify(token: String, key: JwtKey) -> Result<Self, JwtError> {
        let jwt = Self.decode(token)?
        
        let parts = token.split(".")
        let message = format!("{}.{}", parts[0], parts[1])
        
        if !key.verify(jwt.header.alg, message.as_bytes(), jwt.signature) {
            return Err(JwtError.InvalidSignature)
        }
        
        // Check expiration
        if let Some(exp) = jwt.claims.exp {
            if DateTime.now().timestamp() > exp { return Err(JwtError.Expired) }
        }
        
        // Check not before
        if let Some(nbf) = jwt.claims.nbf {
            if DateTime.now().timestamp() < nbf { return Err(JwtError.NotYetValid) }
        }
        
        Ok(jwt)
    }
    
    fn is_expired() -> Bool {
        self.claims.exp.map(|exp| DateTime.now().timestamp() > exp).unwrap_or(false)
    }
}

/// JWT Header
struct JwtHeader {
    alg: Algorithm
    typ: String
    kid: Option<String>
}

impl JwtHeader {
    fn new(alg: Algorithm) -> Self { JwtHeader { alg: alg, typ: "JWT", kid: None } }
    fn with_kid(alg: Algorithm, kid: String) -> Self { JwtHeader { alg: alg, typ: "JWT", kid: Some(kid) } }
}

/// JWT Claims
struct Claims {
    iss: Option<String>  // Issuer
    sub: Option<String>  // Subject
    aud: Option<String>  // Audience
    exp: Option<Int64>   // Expiration
    nbf: Option<Int64>   // Not before
    iat: Option<Int64>   // Issued at
    jti: Option<String>  // JWT ID
    custom: Map<String, JsonValue>
}

impl Claims {
    fn new() -> Self { Claims { iss: None, sub: None, aud: None, exp: None, nbf: None, iat: None, jti: None, custom: Map.empty() } }
    fn issuer(iss: String) -> Self { self.iss = Some(iss); self }
    fn subject(sub: String) -> Self { self.sub = Some(sub); self }
    fn audience(aud: String) -> Self { self.aud = Some(aud); self }
    fn expires_in(seconds: Int64) -> Self { self.exp = Some(DateTime.now().timestamp() + seconds); self }
    fn expires_at(time: DateTime) -> Self { self.exp = Some(time.timestamp()); self }
    fn not_before(time: DateTime) -> Self { self.nbf = Some(time.timestamp()); self }
    fn issued_now() -> Self { self.iat = Some(DateTime.now().timestamp()); self }
    fn jwt_id(jti: String) -> Self { self.jti = Some(jti); self }
    fn claim(key: String, value: JsonValue) -> Self { self.custom.set(key, value); self }
    fn get(key: String) -> Option<JsonValue> { self.custom.get(key) }
}

/// Signing algorithms
enum Algorithm { HS256, HS384, HS512, RS256, RS384, RS512, ES256, ES384, ES512, PS256, PS384, PS512, EdDSA }

impl Algorithm {
    fn from_str(s: String) -> Option<Self> {
        match s { "HS256" => Some(HS256), "HS384" => Some(HS384), "HS512" => Some(HS512), "RS256" => Some(RS256), "RS384" => Some(RS384), "RS512" => Some(RS512), "ES256" => Some(ES256), "ES384" => Some(ES384), "ES512" => Some(ES512), "PS256" => Some(PS256), "EdDSA" => Some(EdDSA), _ => None }
    }
    fn to_str() -> String { match self { HS256 => "HS256", HS384 => "HS384", HS512 => "HS512", RS256 => "RS256", RS384 => "RS384", RS512 => "RS512", ES256 => "ES256", ES384 => "ES384", ES512 => "ES512", PS256 => "PS256", PS384 => "PS384", PS512 => "PS512", EdDSA => "EdDSA" } }
}

/// JWT Key
enum JwtKey {
    Hmac([UInt8])
    RsaPublic(RsaPublicKey)
    RsaPrivate(RsaPrivateKey)
    EcdsaPublic(EcdsaPublicKey)
    EcdsaPrivate(EcdsaPrivateKey)
    Ed25519Public([UInt8; 32])
    Ed25519Private([UInt8; 64])
}

impl JwtKey {
    fn hmac(secret: [UInt8]) -> Self { JwtKey.Hmac(secret) }
    fn hmac_str(secret: String) -> Self { JwtKey.Hmac(secret.as_bytes()) }
    
    fn sign(alg: Algorithm, message: [UInt8]) -> Result<[UInt8], JwtError> {
        match (alg, self) {
            (HS256, Hmac(key)) => Ok(crypto.hmac_sha256(key, message).to_vec())
            (HS384, Hmac(key)) => Ok(@native("hmac_sha384", key, message))
            (HS512, Hmac(key)) => Ok(crypto.hmac_sha512(key, message).to_vec())
            (RS256, RsaPrivate(key)) => key.sign(message).map_err(|_| JwtError.SigningFailed)
            (ES256, EcdsaPrivate(key)) => key.sign(message).map_err(|_| JwtError.SigningFailed)
            (EdDSA, Ed25519Private(key)) => Ok(@native("ed25519_sign", key, message).to_vec())
            _ => Err(JwtError.AlgorithmMismatch)
        }
    }
    
    fn verify(alg: Algorithm, message: [UInt8], signature: [UInt8]) -> Bool {
        match (alg, self) {
            (HS256, Hmac(key)) => crypto.constant_time_eq(crypto.hmac_sha256(key, message).to_vec(), signature)
            (HS512, Hmac(key)) => crypto.constant_time_eq(crypto.hmac_sha512(key, message).to_vec(), signature)
            (RS256, RsaPublic(key)) => key.verify(message, signature)
            (ES256, EcdsaPublic(key)) => key.verify(message, signature)
            (EdDSA, Ed25519Public(key)) => @native("ed25519_verify", key, message, signature)
            _ => false
        }
    }
}

/// JWT Builder
struct JwtBuilder { header: JwtHeader, claims: Claims }

impl JwtBuilder {
    fn new(alg: Algorithm) -> Self { JwtBuilder { header: JwtHeader.new(alg), claims: Claims.new() } }
    fn hs256() -> Self { Self.new(Algorithm.HS256) }
    fn rs256() -> Self { Self.new(Algorithm.RS256) }
    fn es256() -> Self { Self.new(Algorithm.ES256) }
    
    fn kid(kid: String) -> Self { self.header.kid = Some(kid); self }
    fn issuer(iss: String) -> Self { self.claims = self.claims.issuer(iss); self }
    fn subject(sub: String) -> Self { self.claims = self.claims.subject(sub); self }
    fn audience(aud: String) -> Self { self.claims = self.claims.audience(aud); self }
    fn expires_in(seconds: Int64) -> Self { self.claims = self.claims.expires_in(seconds); self }
    fn claim(key: String, value: JsonValue) -> Self { self.claims = self.claims.claim(key, value); self }
    
    fn sign(key: JwtKey) -> Result<String, JwtError> {
        let header_json = json.encode(self.header)
        let claims_json = json.encode(self.claims)
        
        let header_b64 = base64.encode_url_safe(header_json.as_bytes())
        let claims_b64 = base64.encode_url_safe(claims_json.as_bytes())
        
        let message = format!("{}.{}", header_b64, claims_b64)
        let signature = key.sign(self.header.alg, message.as_bytes())?
        let sig_b64 = base64.encode_url_safe(signature)
        
        Ok(format!("{}.{}", message, sig_b64))
    }
}

enum JwtError { InvalidFormat, InvalidEncoding, InvalidSignature, Expired, NotYetValid, AlgorithmMismatch, SigningFailed, Other(String) }
impl Display for JwtError { fn fmt(f: Formatter) { match self { InvalidFormat => f.write("Invalid JWT format"), InvalidSignature => f.write("Invalid signature"), Expired => f.write("Token expired"), NotYetValid => f.write("Token not yet valid"), _ => f.write("JWT error") } } }

// Tests
test "create and verify" {
    let secret = "super-secret-key"
    let token = JwtBuilder.hs256().subject("user123").expires_in(3600).sign(JwtKey.hmac_str(secret))?
    let jwt = Jwt.verify(token, JwtKey.hmac_str(secret))?
    assert_eq(jwt.claims.sub, Some("user123"))?
}

test "expired token" {
    let secret = "secret"
    let token = JwtBuilder.hs256().expires_in(-100).sign(JwtKey.hmac_str(secret))?
    assert(Jwt.verify(token, JwtKey.hmac_str(secret)).is_err())?
}
