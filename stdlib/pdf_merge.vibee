// =============================================================================
// Vibee OS â€” PDF Merge Module
// Merging and combining PDF documents
// =============================================================================

use fs::{File, IoError}
use pdf_reader::{PdfDocument, PdfPage, PdfMetadata, PdfError, PdfOutlineItem}

// =============================================================================
// PDF Merger
// =============================================================================

/// PDF document merger
struct PdfMerger {
    handle: @native("PdfMergerHandle")
    sources: [MergeSource]
    metadata: Option<PdfMetadata>
    outline_mode: OutlineMode
    page_labels: Bool
}

impl PdfMerger {
    /// Create new merger
    fn new() -> Self {
        PdfMerger {
            handle: @native("pdf_merger_new"),
            sources: [],
            metadata: None,
            outline_mode: OutlineMode.Preserve,
            page_labels: true
        }
    }
    
    /// Add entire PDF document
    fn add(path: String) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(path)?
        self.sources.push(MergeSource {
            path: path,
            page_range: None,
            rotation: 0,
            scale: 1.0
        })
        Ok(self)
    }
    
    /// Add PDF from bytes
    fn add_bytes(data: [UInt8]) -> Result<Self, PdfError> {
        let doc = PdfDocument.from_bytes(data)?
        self.sources.push(MergeSource {
            path: String.new(),
            page_range: None,
            rotation: 0,
            scale: 1.0
        })
        Ok(self)
    }
    
    /// Add specific pages from PDF
    fn add_pages(path: String, start: Int, end: Int) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(path)?
        if start < 0 || end >= doc.page_count || start > end {
            return Err(PdfError.InvalidPageRange(start, end))
        }
        self.sources.push(MergeSource {
            path: path,
            page_range: Some((start, end)),
            rotation: 0,
            scale: 1.0
        })
        Ok(self)
    }
    
    /// Add single page from PDF
    fn add_page(path: String, page_index: Int) -> Result<Self, PdfError> {
        self.add_pages(path, page_index, page_index)
    }
    
    /// Add pages with rotation
    fn add_rotated(path: String, rotation: Int) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(path)?
        self.sources.push(MergeSource {
            path: path,
            page_range: None,
            rotation: rotation,
            scale: 1.0
        })
        Ok(self)
    }
    
    /// Add pages with scaling
    fn add_scaled(path: String, scale: Float64) -> Result<Self, PdfError> {
        let doc = PdfDocument.open(path)?
        self.sources.push(MergeSource {
            path: path,
            page_range: None,
            rotation: 0,
            scale: scale
        })
        Ok(self)
    }
    
    /// Set output metadata
    fn metadata(meta: PdfMetadata) -> Self {
        self.metadata = Some(meta)
        self
    }
    
    /// Set title
    fn title(t: String) -> Self {
        if self.metadata.is_none() { self.metadata = Some(PdfMetadata.new()) }
        self.metadata.as_mut().unwrap().title = Some(t)
        self
    }
    
    /// Set author
    fn author(a: String) -> Self {
        if self.metadata.is_none() { self.metadata = Some(PdfMetadata.new()) }
        self.metadata.as_mut().unwrap().author = Some(a)
        self
    }
    
    /// Set outline handling mode
    fn outline_mode(mode: OutlineMode) -> Self {
        self.outline_mode = mode
        self
    }
    
    /// Enable/disable page label preservation
    fn preserve_page_labels(preserve: Bool) -> Self {
        self.page_labels = preserve
        self
    }
    
    /// Merge and save to file
    fn save(path: String) -> Result<MergeResult, PdfError> {
        let result = self.execute()?
        @native("pdf_merger_save", self.handle, path)?
        Ok(result)
    }
    
    /// Merge and return as bytes
    fn to_bytes() -> Result<([UInt8], MergeResult), PdfError> {
        let result = self.execute()?
        let bytes = @native("pdf_merger_to_bytes", self.handle)?
        Ok((bytes, result))
    }
    
    /// Execute merge operation
    fn execute() -> Result<MergeResult, PdfError> {
        let mut total_pages = 0
        let mut source_count = 0
        
        for source in self.sources {
            @native("pdf_merger_add_source", self.handle, source)?
            source_count += 1
            
            if let Some((start, end)) = source.page_range {
                total_pages += end - start + 1
            } else {
                let doc = PdfDocument.open(source.path)?
                total_pages += doc.page_count
            }
        }
        
        if let Some(meta) = self.metadata {
            @native("pdf_merger_set_metadata", self.handle, meta)?
        }
        
        @native("pdf_merger_set_outline_mode", self.handle, self.outline_mode)?
        @native("pdf_merger_execute", self.handle)?
        
        Ok(MergeResult {
            total_pages: total_pages,
            source_count: source_count
        })
    }
}

/// Merge source configuration
struct MergeSource {
    path: String
    page_range: Option<(Int, Int)>
    rotation: Int
    scale: Float64
}

/// Merge result
struct MergeResult {
    total_pages: Int
    source_count: Int
}

/// Outline handling mode
enum OutlineMode {
    Preserve,      // Keep all outlines, adjust page numbers
    Flatten,       // Flatten all outlines to single level
    Discard,       // Remove all outlines
    Merge          // Merge outlines under document titles
}

// =============================================================================
// Advanced Merger
// =============================================================================

/// Advanced merger with more control
struct AdvancedMerger {
    handle: @native("AdvancedMergerHandle")
    pages: [MergePage]
    metadata: Option<PdfMetadata>
}

impl AdvancedMerger {
    fn new() -> Self {
        AdvancedMerger {
            handle: @native("advanced_merger_new"),
            pages: [],
            metadata: None
        }
    }
    
    /// Add page with full control
    fn add_page(page: MergePage) -> Self {
        self.pages.push(page)
        self
    }
    
    /// Add blank page
    fn add_blank_page(width: Float64, height: Float64) -> Self {
        self.pages.push(MergePage.blank(width, height))
        self
    }
    
    /// Add page from document
    fn add_from_doc(doc: PdfDocument, page_index: Int) -> Result<Self, PdfError> {
        let page = doc.page(page_index)?
        self.pages.push(MergePage {
            source: PageSource.Document(doc.path.clone().unwrap_or_default(), page_index),
            transform: PageTransform.identity(),
            crop: None
        })
        Ok(self)
    }
    
    /// Interleave pages from two documents
    fn interleave(doc1: String, doc2: String) -> Result<Self, PdfError> {
        let d1 = PdfDocument.open(doc1)?
        let d2 = PdfDocument.open(doc2)?
        
        let max_pages = d1.page_count.max(d2.page_count)
        for i in 0..max_pages {
            if i < d1.page_count {
                self.pages.push(MergePage.from_file(doc1.clone(), i))
            }
            if i < d2.page_count {
                self.pages.push(MergePage.from_file(doc2.clone(), i))
            }
        }
        Ok(self)
    }
    
    /// Reverse page order
    fn reverse() -> Self {
        self.pages.reverse()
        self
    }
    
    /// Sort pages by custom function
    fn sort_by<F>(compare: F) -> Self where F: Fn(MergePage, MergePage) -> Int {
        self.pages.sort_by(compare)
        self
    }
    
    /// Set metadata
    fn metadata(meta: PdfMetadata) -> Self {
        self.metadata = Some(meta)
        self
    }
    
    /// Save merged document
    fn save(path: String) -> Result<(), PdfError> {
        for page in self.pages {
            @native("advanced_merger_add_page", self.handle, page)?
        }
        if let Some(meta) = self.metadata {
            @native("advanced_merger_set_metadata", self.handle, meta)?
        }
        @native("advanced_merger_save", self.handle, path)
    }
    
    /// Get as bytes
    fn to_bytes() -> Result<[UInt8], PdfError> {
        for page in self.pages {
            @native("advanced_merger_add_page", self.handle, page)?
        }
        if let Some(meta) = self.metadata {
            @native("advanced_merger_set_metadata", self.handle, meta)?
        }
        @native("advanced_merger_to_bytes", self.handle)
    }
}

/// Single page for merging
struct MergePage {
    source: PageSource
    transform: PageTransform
    crop: Option<CropBox>
}

impl MergePage {
    fn from_file(path: String, page_index: Int) -> Self {
        MergePage {
            source: PageSource.Document(path, page_index),
            transform: PageTransform.identity(),
            crop: None
        }
    }
    
    fn blank(width: Float64, height: Float64) -> Self {
        MergePage {
            source: PageSource.Blank(width, height),
            transform: PageTransform.identity(),
            crop: None
        }
    }
    
    fn rotate(degrees: Int) -> Self {
        self.transform.rotation = degrees
        self
    }
    
    fn scale(factor: Float64) -> Self {
        self.transform.scale_x = factor
        self.transform.scale_y = factor
        self
    }
    
    fn translate(x: Float64, y: Float64) -> Self {
        self.transform.translate_x = x
        self.transform.translate_y = y
        self
    }
    
    fn crop(x: Float64, y: Float64, width: Float64, height: Float64) -> Self {
        self.crop = Some(CropBox { x: x, y: y, width: width, height: height })
        self
    }
}

enum PageSource {
    Document(String, Int),  // path, page_index
    Blank(Float64, Float64) // width, height
}

struct PageTransform {
    rotation: Int
    scale_x: Float64
    scale_y: Float64
    translate_x: Float64
    translate_y: Float64
}

impl PageTransform {
    fn identity() -> Self {
        PageTransform {
            rotation: 0,
            scale_x: 1.0,
            scale_y: 1.0,
            translate_x: 0.0,
            translate_y: 0.0
        }
    }
}

struct CropBox { x: Float64, y: Float64, width: Float64, height: Float64 }

// =============================================================================
// Batch Merger
// =============================================================================

/// Batch merge multiple PDFs
actor BatchMerger {
    queue: [String]
    output_path: String
    
    fn new(output: String) -> Self {
        BatchMerger { queue: [], output_path: output }
    }
    
    /// Add file to queue
    fn add(path: String) {
        self.queue.push(path)
    }
    
    /// Add multiple files
    fn add_all(paths: [String]) {
        self.queue.extend(paths)
    }
    
    /// Execute batch merge
    async fn execute() -> Result<MergeResult, PdfError> {
        let mut merger = PdfMerger.new()
        for path in self.queue {
            merger = merger.add(path)?
        }
        merger.save(self.output_path)
    }
    
    /// Execute with progress callback
    async fn execute_with_progress<F>(callback: F) -> Result<MergeResult, PdfError> 
    where F: Fn(Int, Int) {
        let total = self.queue.len()
        let mut merger = PdfMerger.new()
        
        for (i, path) in self.queue.iter().enumerate() {
            callback(i + 1, total)
            merger = merger.add(path)?
        }
        
        merger.save(self.output_path)
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Merge multiple PDFs into one
fn merge(paths: [String], output: String) -> Result<MergeResult, PdfError> {
    let mut merger = PdfMerger.new()
    for path in paths {
        merger = merger.add(path)?
    }
    merger.save(output)
}

/// Merge two PDFs
fn merge_two(path1: String, path2: String, output: String) -> Result<MergeResult, PdfError> {
    merge([path1, path2], output)
}

/// Append PDF to existing PDF
fn append(base: String, addition: String, output: String) -> Result<MergeResult, PdfError> {
    merge([base, addition], output)
}

/// Prepend PDF to existing PDF
fn prepend(addition: String, base: String, output: String) -> Result<MergeResult, PdfError> {
    merge([addition, base], output)
}

/// Interleave pages from two PDFs
fn interleave(path1: String, path2: String, output: String) -> Result<(), PdfError> {
    AdvancedMerger.new()
        .interleave(path1, path2)?
        .save(output)
}

/// Merge specific pages from multiple PDFs
fn merge_pages(selections: [(String, Int, Int)], output: String) -> Result<MergeResult, PdfError> {
    let mut merger = PdfMerger.new()
    for (path, start, end) in selections {
        merger = merger.add_pages(path, start, end)?
    }
    merger.save(output)
}

/// Merge all PDFs in directory
fn merge_directory(dir: String, output: String) -> Result<MergeResult, PdfError> {
    let entries = fs::read_dir(dir)?
    let mut pdfs = []
    
    for entry in entries {
        if entry.name.ends_with(".pdf") {
            pdfs.push(entry.path)
        }
    }
    
    pdfs.sort()
    merge(pdfs, output)
}

/// Merge with custom page order
fn merge_custom_order(path: String, page_order: [Int], output: String) -> Result<(), PdfError> {
    let doc = PdfDocument.open(path)?
    let mut merger = AdvancedMerger.new()
    
    for page_index in page_order {
        merger = merger.add_from_doc(doc, page_index)?
    }
    
    merger.save(output)
}

// =============================================================================
// Errors
// =============================================================================

impl PdfError {
    fn InvalidPageRange(start: Int, end: Int) -> Self {
        PdfError.Other(format!("Invalid page range: {}-{}", start, end))
    }
}

// =============================================================================
// Tests
// =============================================================================

test "merge two pdfs" {
    let result = merge_two("doc1.pdf", "doc2.pdf", "merged.pdf")?
    assert(result.source_count == 2)?
}

test "merge with page selection" {
    let mut merger = PdfMerger.new()
        .add_pages("doc.pdf", 0, 4)?
        .add_pages("doc.pdf", 10, 14)?
    
    let result = merger.save("selected.pdf")?
    assert(result.total_pages == 10)?
}

test "advanced merger" {
    let mut merger = AdvancedMerger.new()
    merger.add_blank_page(595.0, 842.0)
    merger.add_page(MergePage.from_file("doc.pdf", 0).rotate(90))
    
    assert(merger.pages.len() == 2)?
}

test "page transform" {
    let transform = PageTransform.identity()
    assert_eq(transform.rotation, 0)?
    assert_eq(transform.scale_x, 1.0)?
}

test "merge source" {
    let source = MergeSource {
        path: "test.pdf".to_string(),
        page_range: Some((0, 5)),
        rotation: 0,
        scale: 1.0
    }
    assert(source.page_range.is_some())?
}
