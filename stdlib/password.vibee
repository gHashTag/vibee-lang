// =============================================================================
// Vibee OS â€” Password Module
// Password hashing and verification
// =============================================================================

/// Hash password with default algorithm (Argon2id)
fn hash(password: String) -> Result<String, PasswordError> { Argon2.default().hash(password) }

/// Verify password against hash
fn verify(password: String, hash: String) -> Bool {
    if hash.starts_with("$argon2") { return Argon2.verify(password, hash) }
    if hash.starts_with("$2") { return Bcrypt.verify(password, hash) }
    if hash.starts_with("$scrypt") { return Scrypt.verify(password, hash) }
    if hash.starts_with("$pbkdf2") { return Pbkdf2.verify(password, hash) }
    false
}

/// Check if hash needs rehashing (algorithm upgrade)
fn needs_rehash(hash: String) -> Bool {
    if hash.starts_with("$argon2id$v=19$m=65536,t=3,p=4") { return false }
    true
}

// =============================================================================
// Argon2
// =============================================================================

struct Argon2 { m_cost: Int, t_cost: Int, p_cost: Int, output_len: Int, variant: Argon2Variant }
enum Argon2Variant { Argon2d, Argon2i, Argon2id }

impl Argon2 {
    fn default() -> Self { Argon2 { m_cost: 65536, t_cost: 3, p_cost: 4, output_len: 32, variant: Argon2Variant.Argon2id } }
    fn new(m_cost: Int, t_cost: Int, p_cost: Int) -> Self { Argon2 { m_cost: m_cost, t_cost: t_cost, p_cost: p_cost, output_len: 32, variant: Argon2Variant.Argon2id } }
    
    fn hash(password: String) -> Result<String, PasswordError> {
        let salt = crypto.random_bytes(16)
        let hash = @native("argon2_hash", password.as_bytes(), salt, self.m_cost, self.t_cost, self.p_cost, self.output_len, self.variant)?
        let salt_b64 = base64.encode_url_safe(salt)
        let hash_b64 = base64.encode_url_safe(hash)
        Ok(format!("$argon2id$v=19$m={},t={},p={}${}${}", self.m_cost, self.t_cost, self.p_cost, salt_b64, hash_b64))
    }
    
    fn verify(password: String, encoded: String) -> Bool {
        let parts = encoded.split("$").filter(|s| !s.is_empty()).collect::<Vec<_>>()
        if parts.len() < 5 { return false }
        
        let params = parts[2]
        let salt = base64.decode_url_safe(parts[3]).unwrap_or([])
        let expected = base64.decode_url_safe(parts[4]).unwrap_or([])
        
        let (m, t, p) = parse_argon2_params(params).unwrap_or((65536, 3, 4))
        let hash = @native("argon2_hash", password.as_bytes(), salt, m, t, p, expected.len(), Argon2Variant.Argon2id).unwrap_or([])
        
        crypto.constant_time_eq(hash, expected)
    }
}

fn parse_argon2_params(s: String) -> Option<(Int, Int, Int)> {
    var m = 0; var t = 0; var p = 0
    for part in s.split(",") {
        let kv = part.split("=")
        if kv.len() != 2 { continue }
        match kv[0] { "m" => m = Int.parse(kv[1]).ok()?, "t" => t = Int.parse(kv[1]).ok()?, "p" => p = Int.parse(kv[1]).ok()?, _ => {} }
    }
    Some((m, t, p))
}

// =============================================================================
// Bcrypt
// =============================================================================

struct Bcrypt { cost: Int }

impl Bcrypt {
    fn default() -> Self { Bcrypt { cost: 12 } }
    fn new(cost: Int) -> Self { Bcrypt { cost: cost.clamp(4, 31) } }
    
    fn hash(password: String) -> Result<String, PasswordError> {
        if password.len() > 72 { return Err(PasswordError.PasswordTooLong) }
        @native("bcrypt_hash", password, self.cost)
    }
    
    fn verify(password: String, hash: String) -> Bool { @native("bcrypt_verify", password, hash) }
}

// =============================================================================
// Scrypt
// =============================================================================

struct Scrypt { n: Int, r: Int, p: Int }

impl Scrypt {
    fn default() -> Self { Scrypt { n: 16384, r: 8, p: 1 } }
    fn new(n: Int, r: Int, p: Int) -> Self { Scrypt { n: n, r: r, p: p } }
    
    fn hash(password: String) -> Result<String, PasswordError> {
        let salt = crypto.random_bytes(16)
        let hash = crypto.scrypt(password.as_bytes(), salt, self.n, self.r, self.p, 32)?
        let salt_b64 = base64.encode_url_safe(salt)
        let hash_b64 = base64.encode_url_safe(hash)
        Ok(format!("$scrypt$n={},r={},p={}${}${}", self.n, self.r, self.p, salt_b64, hash_b64))
    }
    
    fn verify(password: String, encoded: String) -> Bool {
        let parts = encoded.split("$").filter(|s| !s.is_empty()).collect::<Vec<_>>()
        if parts.len() < 4 { return false }
        
        let params = parts[1]
        let salt = base64.decode_url_safe(parts[2]).unwrap_or([])
        let expected = base64.decode_url_safe(parts[3]).unwrap_or([])
        
        let (n, r, p) = parse_scrypt_params(params).unwrap_or((16384, 8, 1))
        let hash = crypto.scrypt(password.as_bytes(), salt, n, r, p, expected.len()).unwrap_or([])
        
        crypto.constant_time_eq(hash, expected)
    }
}

fn parse_scrypt_params(s: String) -> Option<(Int, Int, Int)> {
    var n = 0; var r = 0; var p = 0
    for part in s.split(",") {
        let kv = part.split("=")
        if kv.len() != 2 { continue }
        match kv[0] { "n" => n = Int.parse(kv[1]).ok()?, "r" => r = Int.parse(kv[1]).ok()?, "p" => p = Int.parse(kv[1]).ok()?, _ => {} }
    }
    Some((n, r, p))
}

// =============================================================================
// PBKDF2
// =============================================================================

struct Pbkdf2 { iterations: Int, hash: PbkdfHash }
enum PbkdfHash { SHA256, SHA512 }

impl Pbkdf2 {
    fn default() -> Self { Pbkdf2 { iterations: 600000, hash: PbkdfHash.SHA256 } }
    fn new(iterations: Int) -> Self { Pbkdf2 { iterations: iterations, hash: PbkdfHash.SHA256 } }
    fn sha512(iterations: Int) -> Self { Pbkdf2 { iterations: iterations, hash: PbkdfHash.SHA512 } }
    
    fn hash(password: String) -> Result<String, PasswordError> {
        let salt = crypto.random_bytes(16)
        let hash = match self.hash {
            SHA256 => crypto.pbkdf2_sha256(password.as_bytes(), salt, self.iterations, 32)
            SHA512 => crypto.pbkdf2_sha512(password.as_bytes(), salt, self.iterations, 64)
        }
        let algo = match self.hash { SHA256 => "sha256", SHA512 => "sha512" }
        let salt_b64 = base64.encode_url_safe(salt)
        let hash_b64 = base64.encode_url_safe(hash)
        Ok(format!("$pbkdf2-{}$i={}${}${}", algo, self.iterations, salt_b64, hash_b64))
    }
    
    fn verify(password: String, encoded: String) -> Bool {
        let parts = encoded.split("$").filter(|s| !s.is_empty()).collect::<Vec<_>>()
        if parts.len() < 4 { return false }
        
        let algo = parts[0].trim_start("pbkdf2-")
        let iterations = parts[1].trim_start("i=").parse::<Int>().unwrap_or(600000)
        let salt = base64.decode_url_safe(parts[2]).unwrap_or([])
        let expected = base64.decode_url_safe(parts[3]).unwrap_or([])
        
        let hash = match algo { "sha256" => crypto.pbkdf2_sha256(password.as_bytes(), salt, iterations, expected.len()), "sha512" => crypto.pbkdf2_sha512(password.as_bytes(), salt, iterations, expected.len()), _ => return false }
        
        crypto.constant_time_eq(hash, expected)
    }
}

// =============================================================================
// Password Strength
// =============================================================================

fn check_strength(password: String) -> PasswordStrength {
    var score = 0
    let len = password.len()
    
    if len >= 8 { score += 1 }
    if len >= 12 { score += 1 }
    if len >= 16 { score += 1 }
    if password.chars().any(|c| c.is_lowercase()) { score += 1 }
    if password.chars().any(|c| c.is_uppercase()) { score += 1 }
    if password.chars().any(|c| c.is_digit()) { score += 1 }
    if password.chars().any(|c| !c.is_alphanumeric()) { score += 1 }
    
    match score { 0..=2 => PasswordStrength.Weak, 3..=4 => PasswordStrength.Fair, 5..=6 => PasswordStrength.Strong, _ => PasswordStrength.VeryStrong }
}

enum PasswordStrength { Weak, Fair, Strong, VeryStrong }
impl PasswordStrength { fn score() -> Int { match self { Weak => 1, Fair => 2, Strong => 3, VeryStrong => 4 } } }

fn generate(length: Int) -> String {
    let chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*"
    let bytes = crypto.random_bytes(length)
    bytes.iter().map(|b| chars[(b as Int) % chars.len()]).collect()
}

enum PasswordError { PasswordTooLong, HashingFailed, Other(String) }

// Tests
test "hash and verify" {
    let hash = hash("password123")?
    assert(verify("password123", hash))?
    assert(!verify("wrongpassword", hash))?
}

test "strength" {
    assert_eq(check_strength("abc"), PasswordStrength.Weak)?
    assert_eq(check_strength("Abc123!@#xyz"), PasswordStrength.VeryStrong)?
}

test "generate" {
    let pw = generate(16)
    assert_eq(pw.len(), 16)?
}
