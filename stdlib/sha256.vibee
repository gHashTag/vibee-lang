// =============================================================================
// Vibee OS â€” SHA-256 Module
// SHA-256 cryptographic hash function (FIPS 180-4)
// =============================================================================
//
// SHA-256 is a secure cryptographic hash function from the SHA-2 family.
// It produces a 256-bit (32-byte) digest and is widely used for:
// - Digital signatures
// - Certificate fingerprints
// - Blockchain and cryptocurrency
// - Password hashing (with proper KDF)
// - Data integrity verification
// =============================================================================

const DIGEST_SIZE: Int = 32
const BLOCK_SIZE: Int = 64

// Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
const H: [UInt32; 8] = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]

// Round constants (first 32 bits of fractional parts of cube roots of first 64 primes)
const K: [UInt32; 64] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]

// =============================================================================
// Core Functions
// =============================================================================

/// Compute SHA-256 hash of byte array
fn hash(data: [UInt8]) -> [UInt8; 32] {
    @native("sha256", data)
}

/// Compute SHA-256 hash and return as hex string
fn hash_hex(data: [UInt8]) -> String {
    hex.encode(hash(data))
}

/// Compute SHA-256 hash of string
fn hash_string(s: String) -> [UInt8; 32] {
    hash(s.as_bytes())
}

/// Compute SHA-256 hash of string and return as hex string
fn hash_string_hex(s: String) -> String {
    hex.encode(hash_string(s))
}

/// Compute SHA-256 hash of file
fn hash_file(path: String) -> Result<[UInt8; 32], Sha256Error> {
    let data = fs.read_bytes(path).map_err(|e| Sha256Error.IoError(e.to_string()))?
    Ok(hash(data))
}

/// Compute SHA-256 hash of file and return as hex string
fn hash_file_hex(path: String) -> Result<String, Sha256Error> {
    Ok(hex.encode(hash_file(path)?))
}

/// Double SHA-256 (used in Bitcoin)
fn double_hash(data: [UInt8]) -> [UInt8; 32] {
    hash(hash(data))
}

/// Double SHA-256 as hex
fn double_hash_hex(data: [UInt8]) -> String {
    hex.encode(double_hash(data))
}

// =============================================================================
// SHA-256 Digest Struct
// =============================================================================

/// Fixed-size SHA-256 digest (32 bytes / 256 bits)
struct Sha256Digest {
    bytes: [UInt8; 32]
}

impl Sha256Digest {
    /// Create digest from bytes
    fn from_bytes(bytes: [UInt8; 32]) -> Self {
        Sha256Digest { bytes: bytes }
    }
    
    /// Create digest from hex string
    fn from_hex(s: String) -> Result<Self, Sha256Error> {
        let bytes = hex.decode(s).map_err(|_| Sha256Error.InvalidHex)?
        if bytes.len() != 32 {
            return Err(Sha256Error.InvalidLength)
        }
        Ok(Sha256Digest { bytes: bytes.try_into().unwrap() })
    }
    
    /// Create zero digest
    fn zero() -> Self {
        Sha256Digest { bytes: [0; 32] }
    }
    
    /// Get bytes
    fn as_bytes() -> [UInt8; 32] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to uppercase hex string
    fn to_hex_upper() -> String {
        hex.encode_upper(self.bytes)
    }
    
    /// Convert to base64
    fn to_base64() -> String {
        base64.encode(self.bytes)
    }
    
    /// Compare digests in constant time
    fn eq(other: Sha256Digest) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
    
    /// Check if zero
    fn is_zero() -> Bool {
        self.bytes.iter().all(|b| b == 0)
    }
    
    /// Get first N bytes as hex (for short identifiers)
    fn short(len: Int) -> String {
        hex.encode(self.bytes[0..len.min(32)])
    }
    
    /// XOR with another digest
    fn xor(other: Sha256Digest) -> Sha256Digest {
        var result = [0u8; 32]
        for i in 0..32 {
            result[i] = self.bytes[i] ^ other.bytes[i]
        }
        Sha256Digest { bytes: result }
    }
}

impl Display for Sha256Digest {
    fn fmt(f: Formatter) {
        f.write(self.to_hex())
    }
}

impl Hash for Sha256Digest {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

impl Ord for Sha256Digest {
    fn cmp(other: Sha256Digest) -> Ordering {
        for i in 0..32 {
            if self.bytes[i] < other.bytes[i] { return Ordering.Less }
            if self.bytes[i] > other.bytes[i] { return Ordering.Greater }
        }
        Ordering.Equal
    }
}

// =============================================================================
// Incremental Hasher
// =============================================================================

/// Incremental SHA-256 hasher for streaming data
struct Sha256Hasher {
    inner: @native("Sha256Hasher")
}

impl Sha256Hasher {
    /// Create new SHA-256 hasher
    fn new() -> Self {
        Sha256Hasher { inner: @native("sha256_hasher_new") }
    }
    
    /// Update hasher with data
    fn update(data: [UInt8]) -> Self {
        @native("sha256_hasher_update", self.inner, data)
        self
    }
    
    /// Update hasher with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Update hasher with integer (big-endian)
    fn update_u32(v: UInt32) -> Self {
        self.update([(v >> 24) as UInt8, (v >> 16) as UInt8, (v >> 8) as UInt8, v as UInt8])
    }
    
    /// Update hasher with integer (big-endian)
    fn update_u64(v: UInt64) -> Self {
        self.update([
            (v >> 56) as UInt8, (v >> 48) as UInt8, (v >> 40) as UInt8, (v >> 32) as UInt8,
            (v >> 24) as UInt8, (v >> 16) as UInt8, (v >> 8) as UInt8, v as UInt8
        ])
    }
    
    /// Finalize and get digest
    fn finalize() -> Sha256Digest {
        let bytes = @native("sha256_hasher_finalize", self.inner)
        Sha256Digest { bytes: bytes }
    }
    
    /// Finalize and get hex string
    fn finalize_hex() -> String {
        self.finalize().to_hex()
    }
    
    /// Reset hasher for reuse
    fn reset() {
        @native("sha256_hasher_reset", self.inner)
    }
    
    /// Clone hasher state
    fn clone() -> Self {
        Sha256Hasher { inner: @native("sha256_hasher_clone", self.inner) }
    }
}

// =============================================================================
// Streaming Actor
// =============================================================================

/// Actor for streaming SHA-256 computation
actor Sha256Stream {
    state hasher: Sha256Hasher
    state total_bytes: Int
    
    fn new() -> Self {
        Sha256Stream { hasher: Sha256Hasher.new(), total_bytes: 0 }
    }
    
    /// Write data to stream
    fn write(data: [UInt8]) {
        self.hasher.update(data)
        self.total_bytes += data.len()
    }
    
    /// Write string to stream
    fn write_str(s: String) {
        self.write(s.as_bytes())
    }
    
    /// Get current byte count
    fn bytes_processed() -> Int {
        self.total_bytes
    }
    
    /// Finalize and get digest
    fn finalize() -> Sha256Digest {
        self.hasher.finalize()
    }
    
    /// Reset stream
    fn reset() {
        self.hasher.reset()
        self.total_bytes = 0
    }
}

// =============================================================================
// HMAC-SHA256
// =============================================================================

/// Compute HMAC-SHA256
fn hmac(key: [UInt8], data: [UInt8]) -> [UInt8; 32] {
    @native("hmac_sha256", key, data)
}

/// Compute HMAC-SHA256 and return as hex string
fn hmac_hex(key: [UInt8], data: [UInt8]) -> String {
    hex.encode(hmac(key, data))
}

/// HMAC-SHA256 with string inputs
fn hmac_string(key: String, data: String) -> [UInt8; 32] {
    hmac(key.as_bytes(), data.as_bytes())
}

/// Incremental HMAC-SHA256
struct HmacSha256 {
    inner: @native("HmacSha256")
}

impl HmacSha256 {
    fn new(key: [UInt8]) -> Self {
        HmacSha256 { inner: @native("hmac_sha256_new", key) }
    }
    
    fn update(data: [UInt8]) -> Self {
        @native("hmac_sha256_update", self.inner, data)
        self
    }
    
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    fn finalize() -> [UInt8; 32] {
        @native("hmac_sha256_finalize", self.inner)
    }
    
    fn finalize_hex() -> String {
        hex.encode(self.finalize())
    }
    
    fn verify(expected: [UInt8]) -> Bool {
        crypto.constant_time_eq(self.finalize(), expected)
    }
}

// =============================================================================
// Key Derivation (HKDF)
// =============================================================================

/// HKDF-SHA256 extract
fn hkdf_extract(salt: [UInt8], ikm: [UInt8]) -> [UInt8; 32] {
    hmac(salt, ikm)
}

/// HKDF-SHA256 expand
fn hkdf_expand(prk: [UInt8], info: [UInt8], length: Int) -> [UInt8] {
    @native("hkdf_sha256_expand", prk, info, length)
}

/// HKDF-SHA256 (extract and expand)
fn hkdf(ikm: [UInt8], salt: [UInt8], info: [UInt8], length: Int) -> [UInt8] {
    let prk = hkdf_extract(salt, ikm)
    hkdf_expand(prk, info, length)
}

// =============================================================================
// Verification
// =============================================================================

/// Verify data against expected SHA-256 hash (hex string)
fn verify(data: [UInt8], expected_hex: String) -> Bool {
    let computed = hash_hex(data)
    crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes())
}

/// Verify string against expected SHA-256 hash
fn verify_string(s: String, expected_hex: String) -> Bool {
    verify(s.as_bytes(), expected_hex)
}

/// Verify file against expected SHA-256 hash
fn verify_file(path: String, expected_hex: String) -> Result<Bool, Sha256Error> {
    let computed = hash_file_hex(path)?
    Ok(crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes()))
}

// =============================================================================
// Merkle Tree Support
// =============================================================================

/// Compute Merkle parent hash
fn merkle_parent(left: Sha256Digest, right: Sha256Digest) -> Sha256Digest {
    var hasher = Sha256Hasher.new()
    hasher.update(left.bytes)
    hasher.update(right.bytes)
    hasher.finalize()
}

/// Compute Merkle root from list of hashes
fn merkle_root(hashes: [Sha256Digest]) -> Option<Sha256Digest> {
    if hashes.is_empty() { return None }
    if hashes.len() == 1 { return Some(hashes[0]) }
    
    var current = hashes
    while current.len() > 1 {
        var next = []
        for i in (0..current.len()).step_by(2) {
            let left = current[i]
            let right = if i + 1 < current.len() { current[i + 1] } else { current[i] }
            next.push(merkle_parent(left, right))
        }
        current = next
    }
    
    Some(current[0])
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Check if string is valid SHA-256 hex hash
fn is_valid_hash(s: String) -> Bool {
    s.len() == 64 && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Parse SHA-256 hash from various formats
fn parse(s: String) -> Result<Sha256Digest, Sha256Error> {
    let s = s.trim().to_lowercase()
    
    // Remove common prefixes
    let s = if s.starts_with("sha256:") { s[7..] } else { s }
    let s = if s.starts_with("sha-256:") { s[8..] } else { s }
    let s = if s.starts_with("0x") { s[2..] } else { s }
    
    Sha256Digest.from_hex(s)
}

/// Format digest with prefix
fn format_with_prefix(digest: Sha256Digest) -> String {
    format!("sha256:{}", digest.to_hex())
}

/// Compute checksum (first 4 bytes of double SHA-256)
fn checksum(data: [UInt8]) -> [UInt8; 4] {
    let h = double_hash(data)
    [h[0], h[1], h[2], h[3]]
}

// =============================================================================
// Errors
// =============================================================================

enum Sha256Error {
    InvalidHex
    InvalidLength
    IoError(String)
}

impl Display for Sha256Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidLength => f.write("Invalid SHA-256 hash length (expected 32 bytes)")
            IoError(s) => f.write(format!("I/O error: {}", s))
        }
    }
}

// =============================================================================
// Trait Implementations
// =============================================================================

trait Sha256Hashable {
    fn sha256() -> Sha256Digest
}

impl Sha256Hashable for [UInt8] {
    fn sha256() -> Sha256Digest {
        Sha256Digest { bytes: hash(self) }
    }
}

impl Sha256Hashable for String {
    fn sha256() -> Sha256Digest {
        Sha256Digest { bytes: hash_string(self) }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "empty string" {
    assert_eq(hash_string_hex(""), "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")?
}

test "hello world" {
    assert_eq(hash_string_hex("hello"), "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")?
    assert_eq(hash_string_hex("Hello, World!"), "dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f")?
}

test "incremental hashing" {
    var hasher = Sha256Hasher.new()
    hasher.update_str("hello")
    hasher.update_str(" ")
    hasher.update_str("world")
    assert_eq(hasher.finalize_hex(), hash_string_hex("hello world"))?
}

test "digest from hex" {
    let digest = Sha256Digest.from_hex("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")?
    assert_eq(digest.to_hex(), "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")?
}

test "double hash" {
    let single = hash_string("hello")
    let double = double_hash("hello".as_bytes())
    assert_eq(double, hash(single))?
}

test "verify" {
    assert(verify_string("hello", "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"))?
    assert(!verify_string("hello", "0000000000000000000000000000000000000000000000000000000000000000"))?
}

test "is_valid_hash" {
    assert(is_valid_hash("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"))?
    assert(!is_valid_hash("invalid"))?
    assert(!is_valid_hash("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85"))?  // Too short
}

test "hmac" {
    let mac = hmac_string("key", "message")
    assert_eq(mac.len(), 32)?
}

test "merkle root" {
    let h1 = "hello".sha256()
    let h2 = "world".sha256()
    let root = merkle_root([h1, h2])
    assert(root.is_some())?
}

test "streaming actor" {
    var stream = Sha256Stream.new()
    stream.write_str("hello")
    stream.write_str(" world")
    assert_eq(stream.bytes_processed(), 11)?
    assert_eq(stream.finalize().to_hex(), hash_string_hex("hello world"))?
}

test "trait implementation" {
    let digest = "hello".sha256()
    assert_eq(digest.to_hex(), "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")?
}

test "xor digests" {
    let d1 = Sha256Digest.from_hex("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")?
    let d2 = Sha256Digest.from_hex("0000000000000000000000000000000000000000000000000000000000000000")?
    let xored = d1.xor(d2)
    assert_eq(xored.to_hex(), "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")?
}
