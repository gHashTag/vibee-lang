// =============================================================================
// Vibee OS â€” Deque Module
// Double-ended queue
// =============================================================================

/// Double-ended queue
struct Deque<T> {
    data: [Option<T>]
    head: Int
    tail: Int
    len: Int
    
    fn new() -> Self { Self.with_capacity(16) }
    
    fn with_capacity(cap: Int) -> Self {
        Deque { data: [None; cap], head: 0, tail: 0, len: 0 }
    }
    
    fn push_back(item: T) {
        self.grow_if_needed()
        self.data[self.tail] = Some(item)
        self.tail = (self.tail + 1) % self.data.len()
        self.len += 1
    }
    
    fn push_front(item: T) {
        self.grow_if_needed()
        self.head = if self.head == 0 { self.data.len() - 1 } else { self.head - 1 }
        self.data[self.head] = Some(item)
        self.len += 1
    }
    
    fn pop_back() -> Option<T> {
        if self.is_empty() { return None }
        self.tail = if self.tail == 0 { self.data.len() - 1 } else { self.tail - 1 }
        self.len -= 1
        self.data[self.tail].take()
    }
    
    fn pop_front() -> Option<T> {
        if self.is_empty() { return None }
        let item = self.data[self.head].take()
        self.head = (self.head + 1) % self.data.len()
        self.len -= 1
        item
    }
    
    fn front() -> Option<T> { if self.is_empty() { None } else { self.data[self.head].clone() } }
    fn back() -> Option<T> {
        if self.is_empty() { return None }
        let idx = if self.tail == 0 { self.data.len() - 1 } else { self.tail - 1 }
        self.data[idx].clone()
    }
    
    fn get(index: Int) -> Option<T> {
        if index >= self.len { return None }
        let idx = (self.head + index) % self.data.len()
        self.data[idx].clone()
    }
    
    fn len() -> Int { self.len }
    fn is_empty() -> Bool { self.len == 0 }
    fn capacity() -> Int { self.data.len() }
    
    fn clear() {
        while self.pop_front().is_some() {}
    }
    
    fn grow_if_needed() {
        if self.len < self.data.len() { return }
        let new_cap = self.data.len() * 2
        var new_data = [None; new_cap]
        for i in 0..self.len {
            new_data[i] = self.data[(self.head + i) % self.data.len()].take()
        }
        self.data = new_data
        self.head = 0
        self.tail = self.len
    }
    
    fn iter() -> DequeIterator<T> { DequeIterator { deque: self, index: 0 } }
    fn to_vec() -> [T] { self.iter().collect() }
    
    /// Rotate left (front moves to back)
    fn rotate_left(n: Int) {
        for _ in 0..n {
            if let Some(item) = self.pop_front() { self.push_back(item) }
        }
    }
    
    /// Rotate right (back moves to front)
    fn rotate_right(n: Int) {
        for _ in 0..n {
            if let Some(item) = self.pop_back() { self.push_front(item) }
        }
    }
}

struct DequeIterator<T> {
    deque: Deque<T>
    index: Int
}

impl<T> Iterator for DequeIterator<T> {
    type Item = T
    fn next() -> Option<T> {
        if self.index >= self.deque.len { return None }
        let item = self.deque.get(self.index)
        self.index += 1
        item
    }
}

// Tests
test "push pop" {
    var d = Deque::<Int>.new()
    d.push_back(1)
    d.push_back(2)
    d.push_front(0)
    assert_eq(d.pop_front(), Some(0))?
    assert_eq(d.pop_back(), Some(2))?
    assert_eq(d.pop_front(), Some(1))?
}

test "front back" {
    var d = Deque::<Int>.new()
    d.push_back(1)
    d.push_back(2)
    assert_eq(d.front(), Some(1))?
    assert_eq(d.back(), Some(2))?
}

test "rotate" {
    var d = Deque::<Int>.new()
    d.push_back(1)
    d.push_back(2)
    d.push_back(3)
    d.rotate_left(1)
    assert_eq(d.front(), Some(2))?
    assert_eq(d.back(), Some(1))?
}

test "grow" {
    var d = Deque::<Int>.with_capacity(2)
    for i in 0..10 { d.push_back(i) }
    assert_eq(d.len(), 10)?
    assert_eq(d.pop_front(), Some(0))?
}
