// =============================================================================
// Vibee OS â€” Core Module
// Base language types, traits, and primitives
// =============================================================================

// -----------------------------------------------------------------------------
// Primitive Types
// -----------------------------------------------------------------------------

/// Boolean type
@primitive
struct Bool {
    fn and(other: Bool) -> Bool { if self { other } else { false } }
    fn or(other: Bool) -> Bool { if self { true } else { other } }
    fn not() -> Bool { if self { false } else { true } }
    fn xor(other: Bool) -> Bool { self != other }
}

/// Signed integers
@primitive struct Int8  { const MIN: Int8  = -128; const MAX: Int8  = 127 }
@primitive struct Int16 { const MIN: Int16 = -32768; const MAX: Int16 = 32767 }
@primitive struct Int32 { const MIN: Int32 = -2147483648; const MAX: Int32 = 2147483647 }
@primitive struct Int64 { const MIN: Int64 = -9223372036854775808; const MAX: Int64 = 9223372036854775807 }
@primitive struct Int   { const MIN: Int = Int64.MIN; const MAX: Int = Int64.MAX }

/// Unsigned integers
@primitive struct UInt8  { const MIN: UInt8  = 0; const MAX: UInt8  = 255 }
@primitive struct UInt16 { const MIN: UInt16 = 0; const MAX: UInt16 = 65535 }
@primitive struct UInt32 { const MIN: UInt32 = 0; const MAX: UInt32 = 4294967295 }
@primitive struct UInt64 { const MIN: UInt64 = 0; const MAX: UInt64 = 18446744073709551615 }
@primitive struct UInt   { const MIN: UInt = 0; const MAX: UInt = UInt64.MAX }

/// Floating point
@primitive struct Float32 { const NAN: Float32 = 0.0/0.0; const INFINITY: Float32 = 1.0/0.0 }
@primitive struct Float64 { const NAN: Float64 = 0.0/0.0; const INFINITY: Float64 = 1.0/0.0 }
@primitive struct Float   { const NAN: Float = Float64.NAN; const INFINITY: Float = Float64.INFINITY }

/// Character (Unicode scalar)
@primitive struct Char {
    fn is_ascii() -> Bool { (self as UInt32) < 128 }
    fn is_alphabetic() -> Bool { @native("char_is_alphabetic", self) }
    fn is_numeric() -> Bool { @native("char_is_numeric", self) }
    fn is_alphanumeric() -> Bool { self.is_alphabetic() || self.is_numeric() }
    fn is_whitespace() -> Bool { @native("char_is_whitespace", self) }
    fn to_lowercase() -> Char { @native("char_to_lowercase", self) }
    fn to_uppercase() -> Char { @native("char_to_uppercase", self) }
}

/// String slice (borrowed)
@primitive struct Str {
    fn len() -> Int { @native("str_len", self) }
    fn is_empty() -> Bool { self.len() == 0 }
    fn as_bytes() -> [UInt8] { @native("str_as_bytes", self) }
    fn chars() -> CharIterator { CharIterator { s: self, pos: 0 } }
}

/// Owned string
@primitive struct String {
    data: [UInt8]
    
    fn new() -> Self { String { data: [] } }
    fn from(s: Str) -> Self { String { data: s.as_bytes() } }
    fn len() -> Int { self.data.len() }
    fn is_empty() -> Bool { self.len() == 0 }
    fn push(c: Char) { @native("string_push_char", self, c) }
    fn push_str(s: Str) { self.data.extend(s.as_bytes()) }
    fn as_str() -> Str { @native("string_as_str", self) }
    fn clear() { self.data.clear() }
}

// -----------------------------------------------------------------------------
// Option Type
// -----------------------------------------------------------------------------

enum Option<T> {
    Some(T),
    None
}

impl<T> Option<T> {
    fn is_some() -> Bool { match self { Some(_) => true, None => false } }
    fn is_none() -> Bool { !self.is_some() }
    fn unwrap() -> T { match self { Some(x) => x, None => panic("unwrap on None") } }
    fn unwrap_or(default: T) -> T { match self { Some(x) => x, None => default } }
    fn map<U>(f: fn(T) -> U) -> Option<U> { match self { Some(x) => Some(f(x)), None => None } }
    fn and_then<U>(f: fn(T) -> Option<U>) -> Option<U> { match self { Some(x) => f(x), None => None } }
    fn or(other: Option<T>) -> Option<T> { match self { Some(x) => Some(x), None => other } }
    fn take() -> Option<T> { let v = self; self = None; v }
}

// -----------------------------------------------------------------------------
// Result Type
// -----------------------------------------------------------------------------

enum Result<T, E> {
    Ok(T),
    Err(E)
}

impl<T, E> Result<T, E> {
    fn is_ok() -> Bool { match self { Ok(_) => true, Err(_) => false } }
    fn is_err() -> Bool { !self.is_ok() }
    fn unwrap() -> T { match self { Ok(x) => x, Err(_) => panic("unwrap on Err") } }
    fn unwrap_err() -> E { match self { Ok(_) => panic("unwrap_err on Ok"), Err(e) => e } }
    fn unwrap_or(default: T) -> T { match self { Ok(x) => x, Err(_) => default } }
    fn map<U>(f: fn(T) -> U) -> Result<U, E> { match self { Ok(x) => Ok(f(x)), Err(e) => Err(e) } }
    fn map_err<F>(f: fn(E) -> F) -> Result<T, F> { match self { Ok(x) => Ok(x), Err(e) => Err(f(e)) } }
    fn and_then<U>(f: fn(T) -> Result<U, E>) -> Result<U, E> { match self { Ok(x) => f(x), Err(e) => Err(e) } }
    fn ok() -> Option<T> { match self { Ok(x) => Some(x), Err(_) => None } }
    fn err() -> Option<E> { match self { Ok(_) => None, Err(e) => Some(e) } }
}

// -----------------------------------------------------------------------------
// Core Traits
// -----------------------------------------------------------------------------

/// Equality comparison
trait Eq {
    fn eq(other: Self) -> Bool
    fn ne(other: Self) -> Bool { !self.eq(other) }
}

/// Partial equality (for floats)
trait PartialEq {
    fn eq(other: Self) -> Bool
    fn ne(other: Self) -> Bool { !self.eq(other) }
}

/// Ordering result
enum Ordering { Less, Equal, Greater }

/// Total ordering
trait Ord: Eq {
    fn cmp(other: Self) -> Ordering
    fn lt(other: Self) -> Bool { self.cmp(other) == Ordering.Less }
    fn le(other: Self) -> Bool { self.cmp(other) != Ordering.Greater }
    fn gt(other: Self) -> Bool { self.cmp(other) == Ordering.Greater }
    fn ge(other: Self) -> Bool { self.cmp(other) != Ordering.Less }
    fn max(other: Self) -> Self { if self.ge(other) { self } else { other } }
    fn min(other: Self) -> Self { if self.le(other) { self } else { other } }
    fn clamp(min: Self, max: Self) -> Self { self.max(min).min(max) }
}

/// Partial ordering
trait PartialOrd: PartialEq {
    fn partial_cmp(other: Self) -> Option<Ordering>
}

/// Clone trait
trait Clone {
    fn clone() -> Self
}

/// Copy trait (bitwise copy)
trait Copy: Clone {}

/// Default value
trait Default {
    fn default() -> Self
}

/// Display formatting
trait Display {
    fn fmt(f: Formatter) -> Result<(), FormatError>
}

/// Debug formatting
trait Debug {
    fn debug_fmt(f: Formatter) -> Result<(), FormatError>
}

/// Convert to string
trait ToString {
    fn to_string() -> String
}

impl<T: Display> ToString for T {
    fn to_string() -> String { format!("{}", self) }
}

/// Hash trait
trait Hash {
    fn hash(hasher: Hasher)
}

/// Hasher trait
trait Hasher {
    fn write(bytes: [UInt8])
    fn write_u8(v: UInt8) { self.write([v]) }
    fn write_u64(v: UInt64) { self.write(v.to_le_bytes()) }
    fn finish() -> UInt64
}

/// Drop trait (destructor)
trait Drop {
    fn drop()
}

/// Sized marker trait
trait Sized {}

// -----------------------------------------------------------------------------
// Conversion Traits
// -----------------------------------------------------------------------------

trait From<T> {
    fn from(value: T) -> Self
}

trait Into<T> {
    fn into() -> T
}

impl<T, U: From<T>> Into<U> for T {
    fn into() -> U { U.from(self) }
}

trait TryFrom<T> {
    type Error
    fn try_from(value: T) -> Result<Self, Self.Error>
}

trait TryInto<T> {
    type Error
    fn try_into() -> Result<T, Self.Error>
}

trait AsRef<T> {
    fn as_ref() -> T
}

trait AsMut<T> {
    fn as_mut() -> T
}

// -----------------------------------------------------------------------------
// Iterator Traits
// -----------------------------------------------------------------------------

trait Iterator {
    type Item
    fn next() -> Option<Self.Item>
    
    fn map<U>(f: fn(Self.Item) -> U) -> MapIterator<Self, U> { MapIterator { iter: self, f: f } }
    fn filter(pred: fn(Self.Item) -> Bool) -> FilterIterator<Self> { FilterIterator { iter: self, pred: pred } }
    fn take(n: Int) -> TakeIterator<Self> { TakeIterator { iter: self, remaining: n } }
    fn skip(n: Int) -> SkipIterator<Self> { SkipIterator { iter: self, remaining: n } }
    fn collect<C: FromIterator<Self.Item>>() -> C { C.from_iter(self) }
    fn count() -> Int { var n = 0; while self.next().is_some() { n += 1 } n }
    fn fold<A>(init: A, f: fn(A, Self.Item) -> A) -> A {
        var acc = init; while let Some(x) = self.next() { acc = f(acc, x) } acc
    }
}

trait IntoIterator {
    type Item
    type IntoIter: Iterator<Item = Self.Item>
    fn into_iter() -> Self.IntoIter
}

trait FromIterator<T> {
    fn from_iter<I: Iterator<Item = T>>(iter: I) -> Self
}

trait Extend<T> {
    fn extend<I: IntoIterator<Item = T>>(iter: I)
}

// Iterator adapters
struct MapIterator<I, U> { iter: I, f: fn(I.Item) -> U }
impl<I: Iterator, U> Iterator for MapIterator<I, U> {
    type Item = U
    fn next() -> Option<U> { self.iter.next().map(self.f) }
}

struct FilterIterator<I> { iter: I, pred: fn(I.Item) -> Bool }
impl<I: Iterator> Iterator for FilterIterator<I> {
    type Item = I.Item
    fn next() -> Option<Self.Item> {
        loop { let x = self.iter.next()?; if (self.pred)(x) { return Some(x) } }
    }
}

struct TakeIterator<I> { iter: I, remaining: Int }
impl<I: Iterator> Iterator for TakeIterator<I> {
    type Item = I.Item
    fn next() -> Option<Self.Item> {
        if self.remaining == 0 { None } else { self.remaining -= 1; self.iter.next() }
    }
}

struct SkipIterator<I> { iter: I, remaining: Int }
impl<I: Iterator> Iterator for SkipIterator<I> {
    type Item = I.Item
    fn next() -> Option<Self.Item> {
        while self.remaining > 0 { self.iter.next(); self.remaining -= 1 }
        self.iter.next()
    }
}

struct CharIterator { s: Str, pos: Int }
impl Iterator for CharIterator {
    type Item = Char
    fn next() -> Option<Char> { @native("str_next_char", self) }
}

// -----------------------------------------------------------------------------
// Operator Traits
// -----------------------------------------------------------------------------

trait Add<Rhs = Self> { type Output; fn add(rhs: Rhs) -> Self.Output }
trait Sub<Rhs = Self> { type Output; fn sub(rhs: Rhs) -> Self.Output }
trait Mul<Rhs = Self> { type Output; fn mul(rhs: Rhs) -> Self.Output }
trait Div<Rhs = Self> { type Output; fn div(rhs: Rhs) -> Self.Output }
trait Rem<Rhs = Self> { type Output; fn rem(rhs: Rhs) -> Self.Output }
trait Neg { type Output; fn neg() -> Self.Output }

trait BitAnd<Rhs = Self> { type Output; fn bitand(rhs: Rhs) -> Self.Output }
trait BitOr<Rhs = Self> { type Output; fn bitor(rhs: Rhs) -> Self.Output }
trait BitXor<Rhs = Self> { type Output; fn bitxor(rhs: Rhs) -> Self.Output }
trait Not { type Output; fn not() -> Self.Output }
trait Shl<Rhs = Int> { type Output; fn shl(rhs: Rhs) -> Self.Output }
trait Shr<Rhs = Int> { type Output; fn shr(rhs: Rhs) -> Self.Output }

trait Index<Idx> { type Output; fn index(idx: Idx) -> Self.Output }
trait IndexMut<Idx>: Index<Idx> { fn index_mut(idx: Idx) -> Self.Output }

// -----------------------------------------------------------------------------
// Function Traits
// -----------------------------------------------------------------------------

trait Fn<Args, Output> { fn call(args: Args) -> Output }
trait FnMut<Args, Output>: Fn<Args, Output> { fn call_mut(args: Args) -> Output }
trait FnOnce<Args, Output> { fn call_once(args: Args) -> Output }

// -----------------------------------------------------------------------------
// Collections
// -----------------------------------------------------------------------------

/// Dynamic array
struct Vec<T> {
    data: [T]
    len: Int
    capacity: Int
    
    fn new() -> Self { Vec { data: [], len: 0, capacity: 0 } }
    fn with_capacity(cap: Int) -> Self { Vec { data: @native("alloc_array", cap), len: 0, capacity: cap } }
    fn len() -> Int { self.len }
    fn is_empty() -> Bool { self.len == 0 }
    fn capacity() -> Int { self.capacity }
    fn push(value: T) { @native("vec_push", self, value) }
    fn pop() -> Option<T> { if self.is_empty() { None } else { self.len -= 1; Some(self.data[self.len]) } }
    fn get(index: Int) -> Option<T> { if index < self.len { Some(self.data[index]) } else { None } }
    fn first() -> Option<T> { self.get(0) }
    fn last() -> Option<T> { self.get(self.len - 1) }
    fn clear() { self.len = 0 }
    fn iter() -> VecIterator<T> { VecIterator { vec: self, pos: 0 } }
}

struct VecIterator<T> { vec: Vec<T>, pos: Int }
impl<T> Iterator for VecIterator<T> {
    type Item = T
    fn next() -> Option<T> { self.vec.get(self.pos).map(|v| { self.pos += 1; v }) }
}

/// Fixed-size array
struct Array<T, const N: Int> {
    data: [T; N]
    fn len() -> Int { N }
    fn get(index: Int) -> Option<T> { if index < N { Some(self.data[index]) } else { None } }
    fn iter() -> ArrayIterator<T, N> { ArrayIterator { arr: self, pos: 0 } }
}

struct ArrayIterator<T, const N: Int> { arr: Array<T, N>, pos: Int }
impl<T, const N: Int> Iterator for ArrayIterator<T, N> {
    type Item = T
    fn next() -> Option<T> { self.arr.get(self.pos).map(|v| { self.pos += 1; v }) }
}

// -----------------------------------------------------------------------------
// Smart Pointers
// -----------------------------------------------------------------------------

/// Heap-allocated box
struct Box<T> {
    ptr: *T
    fn new(value: T) -> Self { Box { ptr: @native("box_alloc", value) } }
    fn get() -> T { *self.ptr }
    fn into_raw() -> *T { let p = self.ptr; forget(self); p }
    fn from_raw(ptr: *T) -> Self { Box { ptr: ptr } }
}
impl<T> Drop for Box<T> { fn drop() { @native("box_free", self.ptr) } }

/// Reference-counted pointer
struct Rc<T> {
    ptr: *RcInner<T>
    fn new(value: T) -> Self { Rc { ptr: @native("rc_alloc", value) } }
    fn clone() -> Self { (*self.ptr).count += 1; Rc { ptr: self.ptr } }
    fn get() -> T { (*self.ptr).value }
    fn strong_count() -> Int { (*self.ptr).count }
}
struct RcInner<T> { value: T, count: Int }
impl<T> Drop for Rc<T> {
    fn drop() { (*self.ptr).count -= 1; if (*self.ptr).count == 0 { @native("rc_free", self.ptr) } }
}

/// Atomic reference-counted pointer
struct Arc<T> {
    ptr: *ArcInner<T>
    fn new(value: T) -> Self { Arc { ptr: @native("arc_alloc", value) } }
    fn clone() -> Self { @native("atomic_inc", (*self.ptr).count); Arc { ptr: self.ptr } }
    fn get() -> T { (*self.ptr).value }
    fn strong_count() -> Int { @native("atomic_load", (*self.ptr).count) }
}
struct ArcInner<T> { value: T, count: @native("AtomicInt") }

/// Weak reference
struct Weak<T> {
    ptr: *RcInner<T>
    fn upgrade() -> Option<Rc<T>> {
        if (*self.ptr).count > 0 { (*self.ptr).count += 1; Some(Rc { ptr: self.ptr }) } else { None }
    }
}

// -----------------------------------------------------------------------------
// Range Types
// -----------------------------------------------------------------------------

struct Range { start: Int, end: Int }
impl Iterator for Range {
    type Item = Int
    fn next() -> Option<Int> {
        if self.start >= self.end { None } else { let v = self.start; self.start += 1; Some(v) }
    }
}

struct RangeInclusive { start: Int, end: Int, done: Bool }
impl Iterator for RangeInclusive {
    type Item = Int
    fn next() -> Option<Int> {
        if self.done || self.start > self.end { None }
        else { let v = self.start; if v == self.end { self.done = true } else { self.start += 1 } Some(v) }
    }
}

struct RangeFull {}

// -----------------------------------------------------------------------------
// Unit and Never Types
// -----------------------------------------------------------------------------

/// Unit type (empty tuple)
struct Unit {}
impl Default for Unit { fn default() -> Self { Unit {} } }

/// Never type (uninhabited)
enum Never {}

// -----------------------------------------------------------------------------
// Formatter
// -----------------------------------------------------------------------------

struct Formatter {
    buffer: String
    fn write(s: Str) { self.buffer.push_str(s) }
    fn write_char(c: Char) { self.buffer.push(c) }
}

struct FormatError { message: String }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "option" { assert_eq(Some(42).unwrap(), 42)?; assert(None::<Int>.is_none())? }
test "result" { assert_eq(Ok::<Int, String>(1).unwrap(), 1)?; assert(Err::<Int, String>("e").is_err())? }
test "vec" { let mut v = Vec.new(); v.push(1); v.push(2); assert_eq(v.len(), 2)? }
test "range" { assert_eq((0..3).collect::<Vec<_>>(), [0, 1, 2])? }
