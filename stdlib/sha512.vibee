// =============================================================================
// Vibee OS â€” SHA-512 Module
// SHA-512 cryptographic hash function (FIPS 180-4)
// =============================================================================
//
// SHA-512 is a secure cryptographic hash function from the SHA-2 family.
// It produces a 512-bit (64-byte) digest and offers:
// - Higher security margin than SHA-256
// - Better performance on 64-bit systems
// - Resistance to length extension attacks (when used properly)
//
// Also includes SHA-384 and SHA-512/256 variants.
// =============================================================================

const DIGEST_SIZE: Int = 64
const DIGEST_SIZE_384: Int = 48
const DIGEST_SIZE_256: Int = 32
const BLOCK_SIZE: Int = 128

// Initial hash values for SHA-512 (first 64 bits of fractional parts of square roots of first 8 primes)
const H_512: [UInt64; 8] = [
    0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
    0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
]

// Initial hash values for SHA-384
const H_384: [UInt64; 8] = [
    0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,
    0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4
]

// Initial hash values for SHA-512/256
const H_512_256: [UInt64; 8] = [
    0x22312194fc2bf72c, 0x9f555fa3c84c64c2, 0x2393b86b6f53b151, 0x963877195940eabd,
    0x96283ee2a88effe3, 0xbe5e1e2553863992, 0x2b0199fc2c85b8aa, 0x0eb72ddc81c52ca2
]

// Round constants (first 64 bits of fractional parts of cube roots of first 80 primes)
const K: [UInt64; 80] = [
    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
    0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
    0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
    0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
    0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
    0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
    0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
    0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
    0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
    0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
    0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
    0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
    0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
    0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
]

// =============================================================================
// SHA-512 Core Functions
// =============================================================================

/// Compute SHA-512 hash of byte array
fn hash(data: [UInt8]) -> [UInt8; 64] {
    @native("sha512", data)
}

/// Compute SHA-512 hash and return as hex string
fn hash_hex(data: [UInt8]) -> String {
    hex.encode(hash(data))
}

/// Compute SHA-512 hash of string
fn hash_string(s: String) -> [UInt8; 64] {
    hash(s.as_bytes())
}

/// Compute SHA-512 hash of string and return as hex string
fn hash_string_hex(s: String) -> String {
    hex.encode(hash_string(s))
}

/// Compute SHA-512 hash of file
fn hash_file(path: String) -> Result<[UInt8; 64], Sha512Error> {
    let data = fs.read_bytes(path).map_err(|e| Sha512Error.IoError(e.to_string()))?
    Ok(hash(data))
}

/// Compute SHA-512 hash of file and return as hex string
fn hash_file_hex(path: String) -> Result<String, Sha512Error> {
    Ok(hex.encode(hash_file(path)?))
}

// =============================================================================
// SHA-384 Functions
// =============================================================================

/// Compute SHA-384 hash of byte array
fn hash_384(data: [UInt8]) -> [UInt8; 48] {
    @native("sha384", data)
}

/// Compute SHA-384 hash and return as hex string
fn hash_384_hex(data: [UInt8]) -> String {
    hex.encode(hash_384(data))
}

/// Compute SHA-384 hash of string
fn hash_384_string(s: String) -> [UInt8; 48] {
    hash_384(s.as_bytes())
}

/// Compute SHA-384 hash of string and return as hex string
fn hash_384_string_hex(s: String) -> String {
    hex.encode(hash_384_string(s))
}

// =============================================================================
// SHA-512/256 Functions
// =============================================================================

/// Compute SHA-512/256 hash of byte array
fn hash_512_256(data: [UInt8]) -> [UInt8; 32] {
    @native("sha512_256", data)
}

/// Compute SHA-512/256 hash and return as hex string
fn hash_512_256_hex(data: [UInt8]) -> String {
    hex.encode(hash_512_256(data))
}

/// Compute SHA-512/256 hash of string
fn hash_512_256_string(s: String) -> [UInt8; 32] {
    hash_512_256(s.as_bytes())
}

// =============================================================================
// SHA-512 Digest Struct
// =============================================================================

/// Fixed-size SHA-512 digest (64 bytes / 512 bits)
struct Sha512Digest {
    bytes: [UInt8; 64]
}

impl Sha512Digest {
    /// Create digest from bytes
    fn from_bytes(bytes: [UInt8; 64]) -> Self {
        Sha512Digest { bytes: bytes }
    }
    
    /// Create digest from hex string
    fn from_hex(s: String) -> Result<Self, Sha512Error> {
        let bytes = hex.decode(s).map_err(|_| Sha512Error.InvalidHex)?
        if bytes.len() != 64 {
            return Err(Sha512Error.InvalidLength)
        }
        Ok(Sha512Digest { bytes: bytes.try_into().unwrap() })
    }
    
    /// Create zero digest
    fn zero() -> Self {
        Sha512Digest { bytes: [0; 64] }
    }
    
    /// Get bytes
    fn as_bytes() -> [UInt8; 64] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to uppercase hex string
    fn to_hex_upper() -> String {
        hex.encode_upper(self.bytes)
    }
    
    /// Convert to base64
    fn to_base64() -> String {
        base64.encode(self.bytes)
    }
    
    /// Compare digests in constant time
    fn eq(other: Sha512Digest) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
    
    /// Check if zero
    fn is_zero() -> Bool {
        self.bytes.iter().all(|b| b == 0)
    }
    
    /// Get first N bytes as hex (for short identifiers)
    fn short(len: Int) -> String {
        hex.encode(self.bytes[0..len.min(64)])
    }
    
    /// Get first 256 bits (32 bytes)
    fn truncate_256() -> [UInt8; 32] {
        self.bytes[0..32].try_into().unwrap()
    }
    
    /// Get first 384 bits (48 bytes)
    fn truncate_384() -> [UInt8; 48] {
        self.bytes[0..48].try_into().unwrap()
    }
}

impl Display for Sha512Digest {
    fn fmt(f: Formatter) {
        f.write(self.to_hex())
    }
}

impl Hash for Sha512Digest {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

impl Ord for Sha512Digest {
    fn cmp(other: Sha512Digest) -> Ordering {
        for i in 0..64 {
            if self.bytes[i] < other.bytes[i] { return Ordering.Less }
            if self.bytes[i] > other.bytes[i] { return Ordering.Greater }
        }
        Ordering.Equal
    }
}

// =============================================================================
// SHA-384 Digest Struct
// =============================================================================

/// Fixed-size SHA-384 digest (48 bytes / 384 bits)
struct Sha384Digest {
    bytes: [UInt8; 48]
}

impl Sha384Digest {
    fn from_bytes(bytes: [UInt8; 48]) -> Self {
        Sha384Digest { bytes: bytes }
    }
    
    fn from_hex(s: String) -> Result<Self, Sha512Error> {
        let bytes = hex.decode(s).map_err(|_| Sha512Error.InvalidHex)?
        if bytes.len() != 48 {
            return Err(Sha512Error.InvalidLength384)
        }
        Ok(Sha384Digest { bytes: bytes.try_into().unwrap() })
    }
    
    fn as_bytes() -> [UInt8; 48] { self.bytes }
    fn to_hex() -> String { hex.encode(self.bytes) }
    fn to_hex_upper() -> String { hex.encode_upper(self.bytes) }
    
    fn eq(other: Sha384Digest) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
}

impl Display for Sha384Digest {
    fn fmt(f: Formatter) { f.write(self.to_hex()) }
}

// =============================================================================
// Incremental Hasher
// =============================================================================

/// Incremental SHA-512 hasher for streaming data
struct Sha512Hasher {
    inner: @native("Sha512Hasher")
}

impl Sha512Hasher {
    /// Create new SHA-512 hasher
    fn new() -> Self {
        Sha512Hasher { inner: @native("sha512_hasher_new") }
    }
    
    /// Create SHA-384 hasher
    fn sha384() -> Self {
        Sha512Hasher { inner: @native("sha384_hasher_new") }
    }
    
    /// Create SHA-512/256 hasher
    fn sha512_256() -> Self {
        Sha512Hasher { inner: @native("sha512_256_hasher_new") }
    }
    
    /// Update hasher with data
    fn update(data: [UInt8]) -> Self {
        @native("sha512_hasher_update", self.inner, data)
        self
    }
    
    /// Update hasher with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Update hasher with integer (big-endian)
    fn update_u64(v: UInt64) -> Self {
        self.update([
            (v >> 56) as UInt8, (v >> 48) as UInt8, (v >> 40) as UInt8, (v >> 32) as UInt8,
            (v >> 24) as UInt8, (v >> 16) as UInt8, (v >> 8) as UInt8, v as UInt8
        ])
    }
    
    /// Finalize and get digest
    fn finalize() -> Sha512Digest {
        let bytes = @native("sha512_hasher_finalize", self.inner)
        Sha512Digest { bytes: bytes }
    }
    
    /// Finalize and get hex string
    fn finalize_hex() -> String {
        self.finalize().to_hex()
    }
    
    /// Reset hasher for reuse
    fn reset() {
        @native("sha512_hasher_reset", self.inner)
    }
    
    /// Clone hasher state
    fn clone() -> Self {
        Sha512Hasher { inner: @native("sha512_hasher_clone", self.inner) }
    }
}

// =============================================================================
// Streaming Actor
// =============================================================================

/// Actor for streaming SHA-512 computation
actor Sha512Stream {
    state hasher: Sha512Hasher
    state total_bytes: Int
    
    fn new() -> Self {
        Sha512Stream { hasher: Sha512Hasher.new(), total_bytes: 0 }
    }
    
    fn sha384() -> Self {
        Sha512Stream { hasher: Sha512Hasher.sha384(), total_bytes: 0 }
    }
    
    /// Write data to stream
    fn write(data: [UInt8]) {
        self.hasher.update(data)
        self.total_bytes += data.len()
    }
    
    /// Write string to stream
    fn write_str(s: String) {
        self.write(s.as_bytes())
    }
    
    /// Get current byte count
    fn bytes_processed() -> Int {
        self.total_bytes
    }
    
    /// Finalize and get digest
    fn finalize() -> Sha512Digest {
        self.hasher.finalize()
    }
    
    /// Reset stream
    fn reset() {
        self.hasher.reset()
        self.total_bytes = 0
    }
}

// =============================================================================
// HMAC-SHA512
// =============================================================================

/// Compute HMAC-SHA512
fn hmac(key: [UInt8], data: [UInt8]) -> [UInt8; 64] {
    @native("hmac_sha512", key, data)
}

/// Compute HMAC-SHA512 and return as hex string
fn hmac_hex(key: [UInt8], data: [UInt8]) -> String {
    hex.encode(hmac(key, data))
}

/// HMAC-SHA512 with string inputs
fn hmac_string(key: String, data: String) -> [UInt8; 64] {
    hmac(key.as_bytes(), data.as_bytes())
}

/// Compute HMAC-SHA384
fn hmac_384(key: [UInt8], data: [UInt8]) -> [UInt8; 48] {
    @native("hmac_sha384", key, data)
}

/// Incremental HMAC-SHA512
struct HmacSha512 {
    inner: @native("HmacSha512")
}

impl HmacSha512 {
    fn new(key: [UInt8]) -> Self {
        HmacSha512 { inner: @native("hmac_sha512_new", key) }
    }
    
    fn update(data: [UInt8]) -> Self {
        @native("hmac_sha512_update", self.inner, data)
        self
    }
    
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    fn finalize() -> [UInt8; 64] {
        @native("hmac_sha512_finalize", self.inner)
    }
    
    fn finalize_hex() -> String {
        hex.encode(self.finalize())
    }
    
    fn verify(expected: [UInt8]) -> Bool {
        crypto.constant_time_eq(self.finalize(), expected)
    }
}

// =============================================================================
// Key Derivation (HKDF)
// =============================================================================

/// HKDF-SHA512 extract
fn hkdf_extract(salt: [UInt8], ikm: [UInt8]) -> [UInt8; 64] {
    hmac(salt, ikm)
}

/// HKDF-SHA512 expand
fn hkdf_expand(prk: [UInt8], info: [UInt8], length: Int) -> [UInt8] {
    @native("hkdf_sha512_expand", prk, info, length)
}

/// HKDF-SHA512 (extract and expand)
fn hkdf(ikm: [UInt8], salt: [UInt8], info: [UInt8], length: Int) -> [UInt8] {
    let prk = hkdf_extract(salt, ikm)
    hkdf_expand(prk, info, length)
}

// =============================================================================
// PBKDF2-SHA512
// =============================================================================

/// PBKDF2 with SHA-512
fn pbkdf2(password: [UInt8], salt: [UInt8], iterations: Int, key_len: Int) -> [UInt8] {
    @native("pbkdf2_sha512", password, salt, iterations, key_len)
}

/// PBKDF2 with string password
fn pbkdf2_string(password: String, salt: [UInt8], iterations: Int, key_len: Int) -> [UInt8] {
    pbkdf2(password.as_bytes(), salt, iterations, key_len)
}

// =============================================================================
// Verification
// =============================================================================

/// Verify data against expected SHA-512 hash (hex string)
fn verify(data: [UInt8], expected_hex: String) -> Bool {
    let computed = hash_hex(data)
    crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes())
}

/// Verify string against expected SHA-512 hash
fn verify_string(s: String, expected_hex: String) -> Bool {
    verify(s.as_bytes(), expected_hex)
}

/// Verify file against expected SHA-512 hash
fn verify_file(path: String, expected_hex: String) -> Result<Bool, Sha512Error> {
    let computed = hash_file_hex(path)?
    Ok(crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes()))
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Check if string is valid SHA-512 hex hash
fn is_valid_hash(s: String) -> Bool {
    s.len() == 128 && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Check if string is valid SHA-384 hex hash
fn is_valid_hash_384(s: String) -> Bool {
    s.len() == 96 && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Parse SHA-512 hash from various formats
fn parse(s: String) -> Result<Sha512Digest, Sha512Error> {
    let s = s.trim().to_lowercase()
    
    // Remove common prefixes
    let s = if s.starts_with("sha512:") { s[7..] } else { s }
    let s = if s.starts_with("sha-512:") { s[8..] } else { s }
    let s = if s.starts_with("0x") { s[2..] } else { s }
    
    Sha512Digest.from_hex(s)
}

/// Format digest with prefix
fn format_with_prefix(digest: Sha512Digest) -> String {
    format!("sha512:{}", digest.to_hex())
}

// =============================================================================
// Errors
// =============================================================================

enum Sha512Error {
    InvalidHex
    InvalidLength
    InvalidLength384
    IoError(String)
}

impl Display for Sha512Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidLength => f.write("Invalid SHA-512 hash length (expected 64 bytes)")
            InvalidLength384 => f.write("Invalid SHA-384 hash length (expected 48 bytes)")
            IoError(s) => f.write(format!("I/O error: {}", s))
        }
    }
}

// =============================================================================
// Trait Implementations
// =============================================================================

trait Sha512Hashable {
    fn sha512() -> Sha512Digest
}

impl Sha512Hashable for [UInt8] {
    fn sha512() -> Sha512Digest {
        Sha512Digest { bytes: hash(self) }
    }
}

impl Sha512Hashable for String {
    fn sha512() -> Sha512Digest {
        Sha512Digest { bytes: hash_string(self) }
    }
}

trait Sha384Hashable {
    fn sha384() -> Sha384Digest
}

impl Sha384Hashable for [UInt8] {
    fn sha384() -> Sha384Digest {
        Sha384Digest { bytes: hash_384(self) }
    }
}

impl Sha384Hashable for String {
    fn sha384() -> Sha384Digest {
        Sha384Digest { bytes: hash_384_string(self) }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "sha512 empty string" {
    let expected = "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
    assert_eq(hash_string_hex(""), expected)?
}

test "sha512 hello" {
    let expected = "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043"
    assert_eq(hash_string_hex("hello"), expected)?
}

test "sha384 empty string" {
    let expected = "38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"
    assert_eq(hash_384_string_hex(""), expected)?
}

test "incremental hashing" {
    var hasher = Sha512Hasher.new()
    hasher.update_str("hello")
    hasher.update_str(" ")
    hasher.update_str("world")
    assert_eq(hasher.finalize_hex(), hash_string_hex("hello world"))?
}

test "digest from hex" {
    let hex_str = "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
    let digest = Sha512Digest.from_hex(hex_str)?
    assert_eq(digest.to_hex(), hex_str)?
}

test "truncate" {
    let digest = "hello".sha512()
    let truncated = digest.truncate_256()
    assert_eq(truncated.len(), 32)?
}

test "verify" {
    let expected = "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043"
    assert(verify_string("hello", expected))?
    assert(!verify_string("hello", "0".repeat(128)))?
}

test "is_valid_hash" {
    assert(is_valid_hash("cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"))?
    assert(!is_valid_hash("invalid"))?
}

test "hmac" {
    let mac = hmac_string("key", "message")
    assert_eq(mac.len(), 64)?
}

test "streaming actor" {
    var stream = Sha512Stream.new()
    stream.write_str("hello")
    stream.write_str(" world")
    assert_eq(stream.bytes_processed(), 11)?
    assert_eq(stream.finalize().to_hex(), hash_string_hex("hello world"))?
}

test "trait implementation" {
    let digest = "hello".sha512()
    assert_eq(digest.to_hex().len(), 128)?
}

test "sha384 trait" {
    let digest = "hello".sha384()
    assert_eq(digest.to_hex().len(), 96)?
}
