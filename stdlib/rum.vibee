// =============================================================================
// Vibee OS â€” RUM Module (Real User Monitoring)
// Client-side performance monitoring and user experience tracking
// =============================================================================

use datetime.{DateTime, Duration}
use metrics.{Counter, Gauge, Histogram}

// -----------------------------------------------------------------------------
// Core RUM Types
// -----------------------------------------------------------------------------

/// Page view event
struct PageView {
    id: String
    session_id: String
    user_id: Option<String>
    url: String
    referrer: Option<String>
    title: String
    timestamp: DateTime
    timing: PageTiming
    device: DeviceInfo
    geo: Option<GeoInfo>
    custom: Map<String, Any>
}

impl PageView {
    fn new(url: String, title: String) -> Self {
        PageView {
            id: Uuid.v4().to_string(),
            session_id: Session.current_id(),
            user_id: None,
            url: url,
            referrer: None,
            title: title,
            timestamp: DateTime.now(),
            timing: PageTiming.new(),
            device: DeviceInfo.detect(),
            geo: None,
            custom: Map.new()
        }
    }
    
    fn with_user(user_id: String) -> Self {
        self.user_id = Some(user_id)
        self
    }
    
    fn with_referrer(referrer: String) -> Self {
        self.referrer = Some(referrer)
        self
    }
    
    fn with_timing(timing: PageTiming) -> Self {
        self.timing = timing
        self
    }
    
    fn with_custom(key: String, value: Any) -> Self {
        self.custom.insert(key, value)
        self
    }
}

/// Page timing metrics (Web Vitals compatible)
struct PageTiming {
    // Navigation timing
    dns_lookup: Option<Float>
    tcp_connect: Option<Float>
    ssl_handshake: Option<Float>
    ttfb: Option<Float>              // Time to First Byte
    response_time: Option<Float>
    dom_interactive: Option<Float>
    dom_complete: Option<Float>
    load_event: Option<Float>
    
    // Core Web Vitals
    fcp: Option<Float>               // First Contentful Paint
    lcp: Option<Float>               // Largest Contentful Paint
    fid: Option<Float>               // First Input Delay
    cls: Option<Float>               // Cumulative Layout Shift
    inp: Option<Float>               // Interaction to Next Paint
    ttfb_vital: Option<Float>        // Time to First Byte (Web Vital)
}

impl PageTiming {
    fn new() -> Self {
        PageTiming {
            dns_lookup: None,
            tcp_connect: None,
            ssl_handshake: None,
            ttfb: None,
            response_time: None,
            dom_interactive: None,
            dom_complete: None,
            load_event: None,
            fcp: None,
            lcp: None,
            fid: None,
            cls: None,
            inp: None,
            ttfb_vital: None
        }
    }
    
    fn from_performance_api(data: Map<String, Float>) -> Self {
        PageTiming {
            dns_lookup: data.get("domainLookupEnd").zip(data.get("domainLookupStart")).map(|(e, s)| e - s),
            tcp_connect: data.get("connectEnd").zip(data.get("connectStart")).map(|(e, s)| e - s),
            ssl_handshake: data.get("connectEnd").zip(data.get("secureConnectionStart")).map(|(e, s)| e - s),
            ttfb: data.get("responseStart").zip(data.get("requestStart")).map(|(e, s)| e - s),
            response_time: data.get("responseEnd").zip(data.get("responseStart")).map(|(e, s)| e - s),
            dom_interactive: data.get("domInteractive"),
            dom_complete: data.get("domComplete"),
            load_event: data.get("loadEventEnd").zip(data.get("loadEventStart")).map(|(e, s)| e - s),
            fcp: data.get("firstContentfulPaint"),
            lcp: data.get("largestContentfulPaint"),
            fid: data.get("firstInputDelay"),
            cls: data.get("cumulativeLayoutShift"),
            inp: data.get("interactionToNextPaint"),
            ttfb_vital: data.get("timeToFirstByte")
        }
    }
    
    /// Check if Core Web Vitals are good
    fn web_vitals_score() -> WebVitalsScore {
        WebVitalsScore {
            lcp: self.lcp.map(|v| if v <= 2500.0 { VitalRating.Good } else if v <= 4000.0 { VitalRating.NeedsImprovement } else { VitalRating.Poor }),
            fid: self.fid.map(|v| if v <= 100.0 { VitalRating.Good } else if v <= 300.0 { VitalRating.NeedsImprovement } else { VitalRating.Poor }),
            cls: self.cls.map(|v| if v <= 0.1 { VitalRating.Good } else if v <= 0.25 { VitalRating.NeedsImprovement } else { VitalRating.Poor }),
            inp: self.inp.map(|v| if v <= 200.0 { VitalRating.Good } else if v <= 500.0 { VitalRating.NeedsImprovement } else { VitalRating.Poor }),
            ttfb: self.ttfb_vital.map(|v| if v <= 800.0 { VitalRating.Good } else if v <= 1800.0 { VitalRating.NeedsImprovement } else { VitalRating.Poor })
        }
    }
}

struct WebVitalsScore {
    lcp: Option<VitalRating>
    fid: Option<VitalRating>
    cls: Option<VitalRating>
    inp: Option<VitalRating>
    ttfb: Option<VitalRating>
}

enum VitalRating {
    Good
    NeedsImprovement
    Poor
    
    fn to_string() -> String {
        match self {
            Good => "good",
            NeedsImprovement => "needs-improvement",
            Poor => "poor"
        }
    }
}

/// Device information
struct DeviceInfo {
    type_: DeviceType
    browser: String
    browser_version: String
    os: String
    os_version: String
    screen_width: Int
    screen_height: Int
    viewport_width: Int
    viewport_height: Int
    pixel_ratio: Float
    connection_type: Option<String>
    effective_type: Option<String>
}

impl DeviceInfo {
    fn detect() -> Self {
        // In browser context, would use navigator and screen APIs
        DeviceInfo {
            type_: DeviceType.Desktop,
            browser: "Unknown",
            browser_version: "0.0",
            os: "Unknown",
            os_version: "0.0",
            screen_width: 1920,
            screen_height: 1080,
            viewport_width: 1920,
            viewport_height: 1080,
            pixel_ratio: 1.0,
            connection_type: None,
            effective_type: None
        }
    }
}

enum DeviceType {
    Desktop
    Mobile
    Tablet
    Bot
    Unknown
    
    fn from_user_agent(ua: String) -> Self {
        if ua.contains("Mobile") { DeviceType.Mobile }
        else if ua.contains("Tablet") { DeviceType.Tablet }
        else if ua.contains("bot") || ua.contains("Bot") { DeviceType.Bot }
        else { DeviceType.Desktop }
    }
}

/// Geographic information
struct GeoInfo {
    country: String
    country_code: String
    region: Option<String>
    city: Option<String>
    timezone: Option<String>
}

// -----------------------------------------------------------------------------
// User Actions
// -----------------------------------------------------------------------------

/// User action event (click, scroll, input, etc.)
struct UserAction {
    id: String
    session_id: String
    type_: ActionType
    target: ActionTarget
    timestamp: DateTime
    duration_ms: Option<Float>
    frustration: Bool
    custom: Map<String, Any>
}

impl UserAction {
    fn new(type_: ActionType, target: ActionTarget) -> Self {
        UserAction {
            id: Uuid.v4().to_string(),
            session_id: Session.current_id(),
            type_: type_,
            target: target,
            timestamp: DateTime.now(),
            duration_ms: None,
            frustration: false,
            custom: Map.new()
        }
    }
    
    fn with_duration(ms: Float) -> Self {
        self.duration_ms = Some(ms)
        self
    }
    
    fn mark_frustration() -> Self {
        self.frustration = true
        self
    }
}

enum ActionType {
    Click
    DoubleClick
    RageClick
    Input
    Scroll
    Swipe
    Custom(String)
}

struct ActionTarget {
    element: String
    selector: Option<String>
    text: Option<String>
    href: Option<String>
}

// -----------------------------------------------------------------------------
// Resource Timing
// -----------------------------------------------------------------------------

/// Resource loading event
struct ResourceTiming {
    id: String
    url: String
    type_: ResourceType
    start_time: Float
    duration: Float
    transfer_size: Int
    encoded_size: Int
    decoded_size: Int
    initiator: String
    cache_hit: Bool
}

impl ResourceTiming {
    fn new(url: String, type_: ResourceType) -> Self {
        ResourceTiming {
            id: Uuid.v4().to_string(),
            url: url,
            type_: type_,
            start_time: 0.0,
            duration: 0.0,
            transfer_size: 0,
            encoded_size: 0,
            decoded_size: 0,
            initiator: "other",
            cache_hit: false
        }
    }
    
    fn from_entry(entry: Map<String, Any>) -> Self {
        ResourceTiming {
            id: Uuid.v4().to_string(),
            url: entry.get("name").unwrap_or(""),
            type_: ResourceType.from_initiator(entry.get("initiatorType").unwrap_or("")),
            start_time: entry.get("startTime").unwrap_or(0.0),
            duration: entry.get("duration").unwrap_or(0.0),
            transfer_size: entry.get("transferSize").unwrap_or(0),
            encoded_size: entry.get("encodedBodySize").unwrap_or(0),
            decoded_size: entry.get("decodedBodySize").unwrap_or(0),
            initiator: entry.get("initiatorType").unwrap_or("other"),
            cache_hit: entry.get("transferSize").unwrap_or(0) == 0
        }
    }
}

enum ResourceType {
    Script
    Stylesheet
    Image
    Font
    XHR
    Fetch
    Document
    Other
    
    fn from_initiator(initiator: String) -> Self {
        match initiator.as_str() {
            "script" => ResourceType.Script,
            "link" | "css" => ResourceType.Stylesheet,
            "img" => ResourceType.Image,
            "font" => ResourceType.Font,
            "xmlhttprequest" => ResourceType.XHR,
            "fetch" => ResourceType.Fetch,
            "navigation" => ResourceType.Document,
            _ => ResourceType.Other
        }
    }
}

// -----------------------------------------------------------------------------
// Error Tracking
// -----------------------------------------------------------------------------

/// Client-side error
struct RumError {
    id: String
    session_id: String
    page_url: String
    type_: RumErrorType
    message: String
    stack: Option<String>
    source: Option<String>
    line: Option<Int>
    column: Option<Int>
    timestamp: DateTime
    handled: Bool
}

impl RumError {
    fn new(type_: RumErrorType, message: String) -> Self {
        RumError {
            id: Uuid.v4().to_string(),
            session_id: Session.current_id(),
            page_url: "",
            type_: type_,
            message: message,
            stack: None,
            source: None,
            line: None,
            column: None,
            timestamp: DateTime.now(),
            handled: false
        }
    }
    
    fn with_stack(stack: String) -> Self {
        self.stack = Some(stack)
        self
    }
    
    fn with_location(source: String, line: Int, column: Int) -> Self {
        self.source = Some(source)
        self.line = Some(line)
        self.column = Some(column)
        self
    }
}

enum RumErrorType {
    JavaScript
    Network
    Resource
    Console
    Custom(String)
}

// -----------------------------------------------------------------------------
// Session Management
// -----------------------------------------------------------------------------

/// User session
struct Session {
    id: String
    user_id: Option<String>
    start_time: DateTime
    last_activity: DateTime
    page_views: Int
    actions: Int
    errors: Int
    duration_ms: Float
    is_bounce: Bool
    entry_page: String
    exit_page: Option<String>
}

impl Session {
    fn new() -> Self {
        Session {
            id: Uuid.v4().to_string(),
            user_id: None,
            start_time: DateTime.now(),
            last_activity: DateTime.now(),
            page_views: 0,
            actions: 0,
            errors: 0,
            duration_ms: 0.0,
            is_bounce: true,
            entry_page: "",
            exit_page: None
        }
    }
    
    fn current_id() -> String {
        // Would retrieve from storage in browser
        "session-placeholder"
    }
    
    fn record_page_view(url: String) {
        self.page_views += 1
        self.last_activity = DateTime.now()
        if self.page_views == 1 {
            self.entry_page = url.clone()
        }
        self.exit_page = Some(url)
        if self.page_views > 1 {
            self.is_bounce = false
        }
        self.update_duration()
    }
    
    fn record_action() {
        self.actions += 1
        self.last_activity = DateTime.now()
        self.update_duration()
    }
    
    fn record_error() {
        self.errors += 1
    }
    
    fn update_duration() {
        self.duration_ms = self.last_activity.diff_ms(self.start_time)
    }
}

// -----------------------------------------------------------------------------
// RUM Agent
// -----------------------------------------------------------------------------

/// Main RUM agent for collecting client-side data
actor RumAgent {
    state config: RumConfig
    state session: Session
    state page_views: [PageView]
    state actions: [UserAction]
    state resources: [ResourceTiming]
    state errors: [RumError]
    state running: Bool
    
    fn new(config: RumConfig) -> Self {
        RumAgent {
            config: config,
            session: Session.new(),
            page_views: [],
            actions: [],
            resources: [],
            errors: [],
            running: false
        }
    }
    
    async fn start() {
        self.running = true
        self.setup_observers()
        self.start_flush_loop().await
    }
    
    async fn stop() {
        self.running = false
        self.flush().await
    }
    
    fn setup_observers() {
        // Would set up PerformanceObserver, error handlers, etc.
    }
    
    fn track_page_view(url: String, title: String) {
        let pv = PageView.new(url.clone(), title)
        self.session.record_page_view(url)
        self.page_views.push(pv)
    }
    
    fn track_action(type_: ActionType, target: ActionTarget) {
        let action = UserAction.new(type_, target)
        self.session.record_action()
        self.actions.push(action)
    }
    
    fn track_resource(resource: ResourceTiming) {
        self.resources.push(resource)
    }
    
    fn track_error(error: RumError) {
        self.session.record_error()
        self.errors.push(error)
    }
    
    fn track_web_vitals(timing: PageTiming) {
        if let Some(pv) = self.page_views.last_mut() {
            pv.timing = timing
        }
    }
    
    async fn flush() {
        if self.page_views.is_empty() && self.actions.is_empty() && self.errors.is_empty() {
            return
        }
        
        let payload = RumPayload {
            session: self.session.clone(),
            page_views: self.page_views.drain(..).collect(),
            actions: self.actions.drain(..).collect(),
            resources: self.resources.drain(..).collect(),
            errors: self.errors.drain(..).collect()
        }
        
        self.send_payload(payload).await
    }
    
    async fn send_payload(payload: RumPayload) {
        let url = "\(self.config.endpoint)/rum/v1/collect"
        let body = Json.encode(payload)
        
        // Use sendBeacon for reliability
        if self.config.use_beacon {
            Navigator.send_beacon(url, body)
        } else {
            Http.post(url).body(body).send().await
        }
    }
    
    async fn start_flush_loop() {
        while self.running {
            Timer.sleep(self.config.flush_interval).await
            self.flush().await
        }
    }
    
    fn get_session() -> Session {
        self.session.clone()
    }
    
    fn get_web_vitals() -> Option<WebVitalsScore> {
        self.page_views.last().map(|pv| pv.timing.web_vitals_score())
    }
}

/// RUM configuration
struct RumConfig {
    application_id: String
    client_token: String
    endpoint: String
    sample_rate: Float
    flush_interval: Duration
    track_interactions: Bool
    track_resources: Bool
    track_long_tasks: Bool
    track_frustrations: Bool
    use_beacon: Bool
    allowed_tracing_origins: [String]
}

impl RumConfig {
    fn new(application_id: String, client_token: String) -> Self {
        RumConfig {
            application_id: application_id,
            client_token: client_token,
            endpoint: "https://rum.example.com",
            sample_rate: 100.0,
            flush_interval: Duration.seconds(10),
            track_interactions: true,
            track_resources: true,
            track_long_tasks: true,
            track_frustrations: true,
            use_beacon: true,
            allowed_tracing_origins: []
        }
    }
    
    fn with_endpoint(endpoint: String) -> Self {
        self.endpoint = endpoint
        self
    }
    
    fn with_sample_rate(rate: Float) -> Self {
        self.sample_rate = rate.clamp(0.0, 100.0)
        self
    }
}

struct RumPayload {
    session: Session
    page_views: [PageView]
    actions: [UserAction]
    resources: [ResourceTiming]
    errors: [RumError]
}

// -----------------------------------------------------------------------------
// Frustration Detection
// -----------------------------------------------------------------------------

/// Detects user frustration signals
struct FrustrationDetector {
    rage_click_threshold: Int
    rage_click_window_ms: Float
    dead_click_timeout_ms: Float
    error_click_window_ms: Float
    recent_clicks: [(DateTime, ActionTarget)]
}

impl FrustrationDetector {
    fn new() -> Self {
        FrustrationDetector {
            rage_click_threshold: 3,
            rage_click_window_ms: 1000.0,
            dead_click_timeout_ms: 100.0,
            error_click_window_ms: 1000.0,
            recent_clicks: []
        }
    }
    
    fn record_click(target: ActionTarget) -> Option<FrustrationSignal> {
        let now = DateTime.now()
        self.recent_clicks.push((now, target.clone()))
        
        // Clean old clicks
        self.recent_clicks.retain(|(t, _)| now.diff_ms(*t) < self.rage_click_window_ms)
        
        // Check for rage click
        let same_target_clicks = self.recent_clicks.iter()
            .filter(|(_, t)| t.selector == target.selector)
            .count()
        
        if same_target_clicks >= self.rage_click_threshold {
            return Some(FrustrationSignal.RageClick(target))
        }
        
        None
    }
    
    fn check_dead_click(target: ActionTarget, response_time_ms: Float) -> Option<FrustrationSignal> {
        if response_time_ms > self.dead_click_timeout_ms {
            Some(FrustrationSignal.DeadClick(target))
        } else {
            None
        }
    }
    
    fn check_error_click(target: ActionTarget, had_error: Bool) -> Option<FrustrationSignal> {
        if had_error {
            Some(FrustrationSignal.ErrorClick(target))
        } else {
            None
        }
    }
}

enum FrustrationSignal {
    RageClick(ActionTarget)
    DeadClick(ActionTarget)
    ErrorClick(ActionTarget)
}

// -----------------------------------------------------------------------------
// Performance Budget
// -----------------------------------------------------------------------------

/// Performance budget checker
struct PerformanceBudget {
    lcp_budget_ms: Float
    fid_budget_ms: Float
    cls_budget: Float
    ttfb_budget_ms: Float
    total_size_budget_kb: Int
    script_size_budget_kb: Int
    image_size_budget_kb: Int
}

impl PerformanceBudget {
    fn default() -> Self {
        PerformanceBudget {
            lcp_budget_ms: 2500.0,
            fid_budget_ms: 100.0,
            cls_budget: 0.1,
            ttfb_budget_ms: 800.0,
            total_size_budget_kb: 1000,
            script_size_budget_kb: 300,
            image_size_budget_kb: 500
        }
    }
    
    fn check(timing: PageTiming, resources: [ResourceTiming]) -> [BudgetViolation] {
        var violations: [BudgetViolation] = []
        
        if let Some(lcp) = timing.lcp {
            if lcp > self.lcp_budget_ms {
                violations.push(BudgetViolation.LCP(lcp, self.lcp_budget_ms))
            }
        }
        
        if let Some(fid) = timing.fid {
            if fid > self.fid_budget_ms {
                violations.push(BudgetViolation.FID(fid, self.fid_budget_ms))
            }
        }
        
        if let Some(cls) = timing.cls {
            if cls > self.cls_budget {
                violations.push(BudgetViolation.CLS(cls, self.cls_budget))
            }
        }
        
        let total_size: Int = resources.iter().map(|r| r.transfer_size).sum()
        if total_size > self.total_size_budget_kb * 1024 {
            violations.push(BudgetViolation.TotalSize(total_size, self.total_size_budget_kb * 1024))
        }
        
        violations
    }
}

enum BudgetViolation {
    LCP(Float, Float)
    FID(Float, Float)
    CLS(Float, Float)
    TTFB(Float, Float)
    TotalSize(Int, Int)
    ScriptSize(Int, Int)
    ImageSize(Int, Int)
}

// -----------------------------------------------------------------------------
// Analytics
// -----------------------------------------------------------------------------

/// RUM analytics aggregator
struct RumAnalytics {
    page_views_by_url: Map<String, Int>
    avg_timing_by_url: Map<String, PageTiming>
    device_breakdown: Map<DeviceType, Int>
    browser_breakdown: Map<String, Int>
    error_rate_by_page: Map<String, Float>
    bounce_rate: Float
    avg_session_duration: Float
}

impl RumAnalytics {
    fn new() -> Self {
        RumAnalytics {
            page_views_by_url: Map.new(),
            avg_timing_by_url: Map.new(),
            device_breakdown: Map.new(),
            browser_breakdown: Map.new(),
            error_rate_by_page: Map.new(),
            bounce_rate: 0.0,
            avg_session_duration: 0.0
        }
    }
    
    fn record_page_view(pv: PageView) {
        *self.page_views_by_url.entry(pv.url.clone()).or_insert(0) += 1
        *self.device_breakdown.entry(pv.device.type_).or_insert(0) += 1
        *self.browser_breakdown.entry(pv.device.browser.clone()).or_insert(0) += 1
    }
    
    fn record_session(session: Session) {
        // Update bounce rate and session duration
    }
    
    fn get_top_pages(limit: Int) -> [(String, Int)] {
        self.page_views_by_url.iter()
            .collect::<Vec<_>>()
            .sort_by(|(_, a), (_, b)| b.cmp(a))
            .take(limit)
            .collect()
    }
    
    fn get_slowest_pages(limit: Int) -> [(String, Float)] {
        self.avg_timing_by_url.iter()
            .filter_map(|(url, timing)| timing.lcp.map(|lcp| (url.clone(), lcp)))
            .collect::<Vec<_>>()
            .sort_by(|(_, a), (_, b)| b.partial_cmp(a).unwrap_or(Ordering.Equal))
            .take(limit)
            .collect()
    }
}

// -----------------------------------------------------------------------------
// Global Instance
// -----------------------------------------------------------------------------

static GLOBAL_RUM: Mutex<Option<RumAgent>> = Mutex.new(None)

fn init(config: RumConfig) {
    *GLOBAL_RUM.lock() = Some(RumAgent.new(config))
}

fn agent() -> Option<&RumAgent> {
    GLOBAL_RUM.lock().as_ref()
}

fn track_page_view(url: String, title: String) {
    if let Some(a) = agent() {
        a.track_page_view(url, title)
    }
}

fn track_action(type_: ActionType, target: ActionTarget) {
    if let Some(a) = agent() {
        a.track_action(type_, target)
    }
}

fn track_error(error: RumError) {
    if let Some(a) = agent() {
        a.track_error(error)
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "page timing web vitals score" {
    let timing = PageTiming {
        lcp: Some(2000.0),
        fid: Some(50.0),
        cls: Some(0.05),
        ..PageTiming.new()
    }
    
    let score = timing.web_vitals_score()
    assert_eq(score.lcp, Some(VitalRating.Good))?
    assert_eq(score.fid, Some(VitalRating.Good))?
    assert_eq(score.cls, Some(VitalRating.Good))?
}

test "session tracking" {
    var session = Session.new()
    session.record_page_view("/home")
    session.record_page_view("/about")
    
    assert_eq(session.page_views, 2)?
    assert(!session.is_bounce)?
}

test "frustration detection" {
    var detector = FrustrationDetector.new()
    let target = ActionTarget { element: "button", selector: Some("#submit"), text: None, href: None }
    
    detector.record_click(target.clone())
    detector.record_click(target.clone())
    let result = detector.record_click(target.clone())
    
    assert(result.is_some())?
}

test "performance budget" {
    let budget = PerformanceBudget.default()
    let timing = PageTiming { lcp: Some(3000.0), ..PageTiming.new() }
    
    let violations = budget.check(timing, [])
    assert_eq(violations.len(), 1)?
}

test "device type detection" {
    assert_eq(DeviceType.from_user_agent("Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)"), DeviceType.Mobile)?
    assert_eq(DeviceType.from_user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64)"), DeviceType.Desktop)?
}
