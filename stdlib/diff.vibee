// =============================================================================
// Vibee OS â€” Diff Module
// Text comparison and difference computation
// =============================================================================
//
// This module provides algorithms for computing differences between texts:
// - Line-by-line diff (Myers algorithm)
// - Character-level diff
// - Word-level diff
// - Unified diff format
// - Side-by-side diff
// - Semantic diff with context
// =============================================================================

// =============================================================================
// Diff Operation Types
// =============================================================================

/// Type of diff operation
enum DiffOp {
    Equal       // Lines/chars are equal
    Insert      // Line/char was inserted
    Delete      // Line/char was deleted
    Replace     // Line/char was replaced (delete + insert)
}

impl Display for DiffOp {
    fn fmt(f: Formatter) {
        match self {
            Equal => f.write(" ")
            Insert => f.write("+")
            Delete => f.write("-")
            Replace => f.write("~")
        }
    }
}

/// Single diff change
struct DiffChange<T> {
    op: DiffOp
    old_value: Option<T>
    new_value: Option<T>
    old_line: Option<Int>
    new_line: Option<Int>
}

impl<T: Display> DiffChange<T> {
    fn new(op: DiffOp, old_value: Option<T>, new_value: Option<T>) -> Self {
        DiffChange { op: op, old_value: old_value, new_value: new_value, old_line: None, new_line: None }
    }
    
    fn with_lines(op: DiffOp, old_value: Option<T>, new_value: Option<T>, old_line: Option<Int>, new_line: Option<Int>) -> Self {
        DiffChange { op: op, old_value: old_value, new_value: new_value, old_line: old_line, new_line: new_line }
    }
    
    fn is_equal() -> Bool { self.op == DiffOp.Equal }
    fn is_insert() -> Bool { self.op == DiffOp.Insert }
    fn is_delete() -> Bool { self.op == DiffOp.Delete }
    fn is_replace() -> Bool { self.op == DiffOp.Replace }
    
    fn to_string() -> String {
        match self.op {
            Equal => format!(" {}", self.old_value.unwrap_or_default())
            Insert => format!("+{}", self.new_value.unwrap_or_default())
            Delete => format!("-{}", self.old_value.unwrap_or_default())
            Replace => format!("-{}\n+{}", self.old_value.unwrap_or_default(), self.new_value.unwrap_or_default())
        }
    }
}

// =============================================================================
// Diff Result
// =============================================================================

/// Result of diff computation
struct DiffResult<T> {
    changes: [DiffChange<T>]
    old_lines: Int
    new_lines: Int
    
    fn new(changes: [DiffChange<T>], old_lines: Int, new_lines: Int) -> Self {
        DiffResult { changes: changes, old_lines: old_lines, new_lines: new_lines }
    }
    
    /// Count of each operation type
    fn stats() -> DiffStats {
        var equal = 0
        var inserts = 0
        var deletes = 0
        var replaces = 0
        
        for change in self.changes {
            match change.op {
                Equal => equal += 1
                Insert => inserts += 1
                Delete => deletes += 1
                Replace => replaces += 1
            }
        }
        
        DiffStats { equal: equal, inserts: inserts, deletes: deletes, replaces: replaces }
    }
    
    /// Check if texts are identical
    fn is_identical() -> Bool {
        self.changes.iter().all(|c| c.is_equal())
    }
    
    /// Get only changed items
    fn changes_only() -> [DiffChange<T>] {
        self.changes.iter().filter(|c| !c.is_equal()).collect()
    }
    
    /// Get insertions only
    fn insertions() -> [DiffChange<T>] {
        self.changes.iter().filter(|c| c.is_insert()).collect()
    }
    
    /// Get deletions only
    fn deletions() -> [DiffChange<T>] {
        self.changes.iter().filter(|c| c.is_delete()).collect()
    }
    
    /// Similarity ratio (0.0 to 1.0)
    fn similarity() -> Float64 {
        let stats = self.stats()
        let total = stats.total()
        if total == 0 { return 1.0 }
        stats.equal as Float64 / total as Float64
    }
}

/// Diff statistics
struct DiffStats {
    equal: Int
    inserts: Int
    deletes: Int
    replaces: Int
    
    fn total() -> Int {
        self.equal + self.inserts + self.deletes + self.replaces
    }
    
    fn changed() -> Int {
        self.inserts + self.deletes + self.replaces
    }
}

// =============================================================================
// Core Diff Functions
// =============================================================================

/// Compute line-by-line diff using Myers algorithm
fn diff_lines(old_text: String, new_text: String) -> DiffResult<String> {
    let old_lines = old_text.lines()
    let new_lines = new_text.lines()
    diff_sequences(old_lines, new_lines)
}

/// Compute character-level diff
fn diff_chars(old_text: String, new_text: String) -> DiffResult<Char> {
    let old_chars = old_text.chars()
    let new_chars = new_text.chars()
    diff_sequences(old_chars, new_chars)
}

/// Compute word-level diff
fn diff_words(old_text: String, new_text: String) -> DiffResult<String> {
    let old_words = old_text.split_whitespace()
    let new_words = new_text.split_whitespace()
    diff_sequences(old_words, new_words)
}

/// Generic sequence diff using Myers algorithm
fn diff_sequences<T: Eq + Clone>(old_seq: [T], new_seq: [T]) -> DiffResult<T> {
    let changes = myers_diff(old_seq, new_seq)
    DiffResult.new(changes, old_seq.len(), new_seq.len())
}

/// Myers diff algorithm implementation
fn myers_diff<T: Eq + Clone>(old_seq: [T], new_seq: [T]) -> [DiffChange<T>] {
    let n = old_seq.len()
    let m = new_seq.len()
    
    if n == 0 && m == 0 {
        return []
    }
    
    if n == 0 {
        return new_seq.iter().enumerate().map(|(i, v)| {
            DiffChange.with_lines(DiffOp.Insert, None, Some(v.clone()), None, Some(i + 1))
        }).collect()
    }
    
    if m == 0 {
        return old_seq.iter().enumerate().map(|(i, v)| {
            DiffChange.with_lines(DiffOp.Delete, Some(v.clone()), None, Some(i + 1), None)
        }).collect()
    }
    
    // Compute LCS using dynamic programming
    let lcs = compute_lcs(old_seq, new_seq)
    
    // Build diff from LCS
    build_diff_from_lcs(old_seq, new_seq, lcs)
}

/// Compute Longest Common Subsequence
fn compute_lcs<T: Eq + Clone>(old_seq: [T], new_seq: [T]) -> [[Int]] {
    let n = old_seq.len()
    let m = new_seq.len()
    
    var dp = [[0; m + 1]; n + 1]
    
    for i in 1..=n {
        for j in 1..=m {
            if old_seq[i - 1] == new_seq[j - 1] {
                dp[i][j] = dp[i - 1][j - 1] + 1
            } else {
                dp[i][j] = dp[i - 1][j].max(dp[i][j - 1])
            }
        }
    }
    
    dp
}

/// Build diff changes from LCS matrix
fn build_diff_from_lcs<T: Eq + Clone>(old_seq: [T], new_seq: [T], lcs: [[Int]]) -> [DiffChange<T>] {
    var changes = []
    var i = old_seq.len()
    var j = new_seq.len()
    var old_line = old_seq.len()
    var new_line = new_seq.len()
    
    while i > 0 || j > 0 {
        if i > 0 && j > 0 && old_seq[i - 1] == new_seq[j - 1] {
            changes.push(DiffChange.with_lines(
                DiffOp.Equal,
                Some(old_seq[i - 1].clone()),
                Some(new_seq[j - 1].clone()),
                Some(old_line),
                Some(new_line)
            ))
            i -= 1
            j -= 1
            old_line -= 1
            new_line -= 1
        } else if j > 0 && (i == 0 || lcs[i][j - 1] >= lcs[i - 1][j]) {
            changes.push(DiffChange.with_lines(
                DiffOp.Insert,
                None,
                Some(new_seq[j - 1].clone()),
                None,
                Some(new_line)
            ))
            j -= 1
            new_line -= 1
        } else {
            changes.push(DiffChange.with_lines(
                DiffOp.Delete,
                Some(old_seq[i - 1].clone()),
                None,
                Some(old_line),
                None
            ))
            i -= 1
            old_line -= 1
        }
    }
    
    changes.reverse()
    changes
}

// =============================================================================
// Unified Diff Format
// =============================================================================

/// Generate unified diff format
fn unified_diff(old_text: String, new_text: String, old_name: String, new_name: String, context: Int) -> String {
    let diff = diff_lines(old_text, new_text)
    format_unified(diff, old_name, new_name, context)
}

/// Format diff result as unified diff
fn format_unified(diff: DiffResult<String>, old_name: String, new_name: String, context: Int) -> String {
    var output = []
    
    // Header
    output.push(format!("--- {}", old_name))
    output.push(format!("+++ {}", new_name))
    
    // Find hunks
    let hunks = find_hunks(diff.changes, context)
    
    for hunk in hunks {
        output.push(format_hunk_header(hunk))
        for change in hunk.changes {
            output.push(change.to_string())
        }
    }
    
    output.join("\n")
}

/// Diff hunk (group of changes with context)
struct DiffHunk<T> {
    old_start: Int
    old_count: Int
    new_start: Int
    new_count: Int
    changes: [DiffChange<T>]
}

fn format_hunk_header<T>(hunk: DiffHunk<T>) -> String {
    format!("@@ -{},{} +{},{} @@", hunk.old_start, hunk.old_count, hunk.new_start, hunk.new_count)
}

/// Find hunks from changes with context lines
fn find_hunks<T: Clone>(changes: [DiffChange<T>], context: Int) -> [DiffHunk<T>] {
    if changes.is_empty() {
        return []
    }
    
    var hunks = []
    var current_hunk: Option<DiffHunk<T>> = None
    var last_change_idx: Option<Int> = None
    
    for (idx, change) in changes.iter().enumerate() {
        if !change.is_equal() {
            // Start new hunk or extend existing
            if current_hunk.is_none() {
                let start = (idx as Int - context).max(0)
                current_hunk = Some(DiffHunk {
                    old_start: change.old_line.unwrap_or(1),
                    old_count: 0,
                    new_start: change.new_line.unwrap_or(1),
                    new_count: 0,
                    changes: []
                })
                
                // Add context before
                for i in start..idx {
                    current_hunk.as_mut().unwrap().changes.push(changes[i].clone())
                }
            }
            
            current_hunk.as_mut().unwrap().changes.push(change.clone())
            last_change_idx = Some(idx)
        } else if let Some(last_idx) = last_change_idx {
            if idx - last_idx <= context * 2 {
                // Within context range, add to current hunk
                current_hunk.as_mut().unwrap().changes.push(change.clone())
            } else if idx - last_idx <= context {
                // Add trailing context
                current_hunk.as_mut().unwrap().changes.push(change.clone())
            } else {
                // End current hunk
                if let Some(hunk) = current_hunk.take() {
                    hunks.push(finalize_hunk(hunk))
                }
                last_change_idx = None
            }
        }
    }
    
    // Finalize last hunk
    if let Some(hunk) = current_hunk {
        hunks.push(finalize_hunk(hunk))
    }
    
    hunks
}

fn finalize_hunk<T>(hunk: DiffHunk<T>) -> DiffHunk<T> {
    var old_count = 0
    var new_count = 0
    
    for change in hunk.changes {
        match change.op {
            Equal => { old_count += 1; new_count += 1 }
            Delete => old_count += 1
            Insert => new_count += 1
            Replace => { old_count += 1; new_count += 1 }
        }
    }
    
    DiffHunk {
        old_start: hunk.old_start,
        old_count: old_count,
        new_start: hunk.new_start,
        new_count: new_count,
        changes: hunk.changes
    }
}

// =============================================================================
// Side-by-Side Diff
// =============================================================================

/// Side-by-side diff line
struct SideBySideLine {
    left_num: Option<Int>
    left_text: Option<String>
    right_num: Option<Int>
    right_text: Option<String>
    op: DiffOp
}

/// Generate side-by-side diff
fn side_by_side(old_text: String, new_text: String) -> [SideBySideLine] {
    let diff = diff_lines(old_text, new_text)
    
    diff.changes.iter().map(|change| {
        SideBySideLine {
            left_num: change.old_line,
            left_text: change.old_value.clone(),
            right_num: change.new_line,
            right_text: change.new_value.clone(),
            op: change.op
        }
    }).collect()
}

/// Format side-by-side diff as string
fn format_side_by_side(old_text: String, new_text: String, width: Int) -> String {
    let lines = side_by_side(old_text, new_text)
    let half_width = (width - 3) / 2
    
    var output = []
    
    for line in lines {
        let left = line.left_text.unwrap_or("").truncate(half_width).pad_right(half_width)
        let right = line.right_text.unwrap_or("").truncate(half_width)
        let sep = match line.op {
            Equal => " | "
            Insert => " > "
            Delete => " < "
            Replace => " | "
        }
        output.push(format!("{}{}{}", left, sep, right))
    }
    
    output.join("\n")
}

// =============================================================================
// Semantic Diff
// =============================================================================

/// Semantic diff options
struct SemanticDiffOptions {
    ignore_whitespace: Bool
    ignore_case: Bool
    ignore_blank_lines: Bool
    context_lines: Int
}

impl SemanticDiffOptions {
    fn default() -> Self {
        SemanticDiffOptions {
            ignore_whitespace: false,
            ignore_case: false,
            ignore_blank_lines: false,
            context_lines: 3
        }
    }
    
    fn ignore_whitespace() -> Self {
        SemanticDiffOptions { ..Self.default(), ignore_whitespace: true }
    }
    
    fn ignore_case() -> Self {
        SemanticDiffOptions { ..Self.default(), ignore_case: true }
    }
}

/// Compute semantic diff with options
fn semantic_diff(old_text: String, new_text: String, options: SemanticDiffOptions) -> DiffResult<String> {
    var old_lines = old_text.lines()
    var new_lines = new_text.lines()
    
    if options.ignore_blank_lines {
        old_lines = old_lines.iter().filter(|l| !l.trim().is_empty()).collect()
        new_lines = new_lines.iter().filter(|l| !l.trim().is_empty()).collect()
    }
    
    if options.ignore_whitespace {
        old_lines = old_lines.iter().map(|l| l.split_whitespace().join(" ")).collect()
        new_lines = new_lines.iter().map(|l| l.split_whitespace().join(" ")).collect()
    }
    
    if options.ignore_case {
        old_lines = old_lines.iter().map(|l| l.to_lowercase()).collect()
        new_lines = new_lines.iter().map(|l| l.to_lowercase()).collect()
    }
    
    diff_sequences(old_lines, new_lines)
}

// =============================================================================
// Inline Diff (Character highlighting within lines)
// =============================================================================

/// Inline diff segment
struct InlineSegment {
    text: String
    op: DiffOp
}

/// Compute inline diff between two lines
fn inline_diff(old_line: String, new_line: String) -> [InlineSegment] {
    let char_diff = diff_chars(old_line, new_line)
    
    var segments = []
    var current_text = ""
    var current_op = DiffOp.Equal
    
    for change in char_diff.changes {
        let char_str = match change.op {
            Equal | Delete => change.old_value.map(|c| c.to_string()).unwrap_or("")
            Insert => change.new_value.map(|c| c.to_string()).unwrap_or("")
            Replace => change.new_value.map(|c| c.to_string()).unwrap_or("")
        }
        
        if change.op == current_op {
            current_text += char_str
        } else {
            if !current_text.is_empty() {
                segments.push(InlineSegment { text: current_text, op: current_op })
            }
            current_text = char_str
            current_op = change.op
        }
    }
    
    if !current_text.is_empty() {
        segments.push(InlineSegment { text: current_text, op: current_op })
    }
    
    segments
}

// =============================================================================
// Three-Way Diff (Merge)
// =============================================================================

/// Three-way diff result
struct ThreeWayDiff {
    base_to_ours: DiffResult<String>
    base_to_theirs: DiffResult<String>
    conflicts: [MergeConflict]
}

/// Merge conflict
struct MergeConflict {
    base_lines: [String]
    our_lines: [String]
    their_lines: [String]
    start_line: Int
}

/// Compute three-way diff
fn diff_three_way(base: String, ours: String, theirs: String) -> ThreeWayDiff {
    let base_to_ours = diff_lines(base.clone(), ours)
    let base_to_theirs = diff_lines(base, theirs)
    let conflicts = find_conflicts(base_to_ours.clone(), base_to_theirs.clone())
    
    ThreeWayDiff {
        base_to_ours: base_to_ours,
        base_to_theirs: base_to_theirs,
        conflicts: conflicts
    }
}

fn find_conflicts(ours: DiffResult<String>, theirs: DiffResult<String>) -> [MergeConflict] {
    // Simplified conflict detection
    var conflicts = []
    
    let our_changes = ours.changes_only()
    let their_changes = theirs.changes_only()
    
    for our_change in our_changes {
        for their_change in their_changes {
            // Check for overlapping changes
            if let (Some(our_line), Some(their_line)) = (our_change.old_line, their_change.old_line) {
                if our_line == their_line && our_change.new_value != their_change.new_value {
                    conflicts.push(MergeConflict {
                        base_lines: our_change.old_value.map(|v| [v]).unwrap_or([]),
                        our_lines: our_change.new_value.map(|v| [v]).unwrap_or([]),
                        their_lines: their_change.new_value.map(|v| [v]).unwrap_or([]),
                        start_line: our_line
                    })
                }
            }
        }
    }
    
    conflicts
}

// =============================================================================
// Diff Actor (Streaming)
// =============================================================================

/// Actor for streaming diff computation
actor DiffActor {
    state old_lines: [String]
    state new_lines: [String]
    state result: Option<DiffResult<String>>
    
    fn new() -> Self {
        DiffActor { old_lines: [], new_lines: [], result: None }
    }
    
    /// Set old text
    fn set_old(text: String) {
        self.old_lines = text.lines()
        self.result = None
    }
    
    /// Set new text
    fn set_new(text: String) {
        self.new_lines = text.lines()
        self.result = None
    }
    
    /// Compute diff
    fn compute() -> DiffResult<String> {
        if self.result.is_none() {
            self.result = Some(diff_sequences(self.old_lines.clone(), self.new_lines.clone()))
        }
        self.result.clone().unwrap()
    }
    
    /// Get unified diff
    fn unified(old_name: String, new_name: String, context: Int) -> String {
        let diff = self.compute()
        format_unified(diff, old_name, new_name, context)
    }
    
    /// Get similarity
    fn similarity() -> Float64 {
        self.compute().similarity()
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Quick check if texts are different
fn is_different(old_text: String, new_text: String) -> Bool {
    old_text != new_text
}

/// Compute edit distance (Levenshtein)
fn edit_distance(s1: String, s2: String) -> Int {
    let m = s1.len()
    let n = s2.len()
    
    if m == 0 { return n }
    if n == 0 { return m }
    
    var dp = [[0; n + 1]; m + 1]
    
    for i in 0..=m { dp[i][0] = i }
    for j in 0..=n { dp[0][j] = j }
    
    let s1_chars = s1.chars()
    let s2_chars = s2.chars()
    
    for i in 1..=m {
        for j in 1..=n {
            let cost = if s1_chars[i - 1] == s2_chars[j - 1] { 0 } else { 1 }
            dp[i][j] = (dp[i - 1][j] + 1)
                .min(dp[i][j - 1] + 1)
                .min(dp[i - 1][j - 1] + cost)
        }
    }
    
    dp[m][n]
}

/// Compute similarity ratio using edit distance
fn similarity_ratio(s1: String, s2: String) -> Float64 {
    let max_len = s1.len().max(s2.len())
    if max_len == 0 { return 1.0 }
    let distance = edit_distance(s1, s2)
    1.0 - (distance as Float64 / max_len as Float64)
}

// =============================================================================
// Errors
// =============================================================================

enum DiffError {
    InvalidInput(String)
    ParseError(String)
}

impl Display for DiffError {
    fn fmt(f: Formatter) {
        match self {
            InvalidInput(s) => f.write(format!("Invalid input: {}", s))
            ParseError(s) => f.write(format!("Parse error: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "identical texts" {
    let diff = diff_lines("hello\nworld", "hello\nworld")
    assert(diff.is_identical())?
    assert_eq(diff.similarity(), 1.0)?
}

test "simple insertion" {
    let diff = diff_lines("hello", "hello\nworld")
    assert(!diff.is_identical())?
    assert_eq(diff.insertions().len(), 1)?
}

test "simple deletion" {
    let diff = diff_lines("hello\nworld", "hello")
    assert(!diff.is_identical())?
    assert_eq(diff.deletions().len(), 1)?
}

test "character diff" {
    let diff = diff_chars("hello", "hallo")
    assert(!diff.is_identical())?
}

test "word diff" {
    let diff = diff_words("hello world", "hello beautiful world")
    assert_eq(diff.insertions().len(), 1)?
}

test "edit distance" {
    assert_eq(edit_distance("kitten", "sitting"), 3)?
    assert_eq(edit_distance("", "abc"), 3)?
    assert_eq(edit_distance("abc", "abc"), 0)?
}

test "similarity ratio" {
    assert_eq(similarity_ratio("hello", "hello"), 1.0)?
    assert(similarity_ratio("hello", "hallo") > 0.7)?
}

test "unified diff format" {
    let diff = unified_diff("line1\nline2", "line1\nline3", "old.txt", "new.txt", 3)
    assert(diff.contains("---"))?
    assert(diff.contains("+++"))?
}

test "side by side" {
    let lines = side_by_side("hello", "world")
    assert(!lines.is_empty())?
}

test "inline diff" {
    let segments = inline_diff("hello", "hallo")
    assert(!segments.is_empty())?
}

test "diff actor" {
    var actor = DiffActor.new()
    actor.set_old("hello\nworld")
    actor.set_new("hello\nearth")
    let diff = actor.compute()
    assert(!diff.is_identical())?
}

test "semantic diff ignore whitespace" {
    let options = SemanticDiffOptions.ignore_whitespace()
    let diff = semantic_diff("hello  world", "hello world", options)
    assert(diff.is_identical())?
}

test "three way diff" {
    let result = diff_three_way("base", "ours", "theirs")
    assert(!result.base_to_ours.is_identical())?
    assert(!result.base_to_theirs.is_identical())?
}
