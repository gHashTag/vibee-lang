// =============================================================================
// Vibee OS â€” PDF Writer Module
// Creating and generating PDF documents
// =============================================================================

use fs::{File, IoError}
use image::{Image, ImageFormat}
use pdf_reader::{PdfRect, PdfPageSize, PdfColor, PdfMetadata, PdfError}

// =============================================================================
// PDF Writer
// =============================================================================

/// PDF document writer/builder
struct PdfWriter {
    handle: @native("PdfWriterHandle")
    pages: [PdfPageBuilder]
    metadata: PdfMetadata
    compression: CompressionLevel
}

impl PdfWriter {
    /// Create new PDF writer
    fn new() -> Self {
        PdfWriter {
            handle: @native("pdf_writer_new"),
            pages: [],
            metadata: PdfMetadata.new(),
            compression: CompressionLevel.Default
        }
    }
    
    /// Set document metadata
    fn title(t: String) -> Self { self.metadata.title = Some(t); self }
    fn author(a: String) -> Self { self.metadata.author = Some(a); self }
    fn subject(s: String) -> Self { self.metadata.subject = Some(s); self }
    fn keywords(k: String) -> Self { self.metadata.keywords = Some(k); self }
    fn creator(c: String) -> Self { self.metadata.creator = Some(c); self }
    fn producer(p: String) -> Self { self.metadata.producer = Some(p); self }
    
    /// Set compression level
    fn compression(level: CompressionLevel) -> Self { self.compression = level; self }
    
    /// Add a new page with default A4 size
    fn add_page() -> PdfPageBuilder {
        self.add_page_with_size(PdfPageSize.a4())
    }
    
    /// Add a new page with custom size
    fn add_page_with_size(size: PdfPageSize) -> PdfPageBuilder {
        let page = PdfPageBuilder.new(size, self.pages.len())
        self.pages.push(page.clone())
        page
    }
    
    /// Add page with predefined size
    fn add_a4_page() -> PdfPageBuilder { self.add_page_with_size(PdfPageSize.a4()) }
    fn add_letter_page() -> PdfPageBuilder { self.add_page_with_size(PdfPageSize.letter()) }
    fn add_legal_page() -> PdfPageBuilder { self.add_page_with_size(PdfPageSize.legal()) }
    
    /// Set password protection
    fn encrypt(user_password: String, owner_password: String) -> Self {
        @native("pdf_writer_encrypt", self.handle, user_password, owner_password)
        self
    }
    
    /// Set permissions
    fn permissions(perms: PdfPermissions) -> Self {
        @native("pdf_writer_permissions", self.handle, perms)
        self
    }
    
    /// Build and save PDF to file
    fn save(path: String) -> Result<(), PdfError> {
        self.build()?
        @native("pdf_writer_save", self.handle, path)
    }
    
    /// Build and return PDF as bytes
    fn to_bytes() -> Result<[UInt8], PdfError> {
        self.build()?
        @native("pdf_writer_to_bytes", self.handle)
    }
    
    /// Internal build method
    fn build() -> Result<(), PdfError> {
        @native("pdf_writer_set_metadata", self.handle, self.metadata)?
        @native("pdf_writer_set_compression", self.handle, self.compression)?
        for page in self.pages {
            @native("pdf_writer_add_page", self.handle, page)?
        }
        Ok(())
    }
}

// =============================================================================
// Page Builder
// =============================================================================

/// PDF page builder
struct PdfPageBuilder {
    handle: @native("PdfPageBuilderHandle")
    size: PdfPageSize
    index: Int
    content: [PageContent]
    current_font: Option<PdfFontRef>
    current_font_size: Float64
    current_color: PdfColor
    current_line_width: Float64
}

impl PdfPageBuilder {
    fn new(size: PdfPageSize, index: Int) -> Self {
        PdfPageBuilder {
            handle: @native("pdf_page_builder_new", size),
            size: size,
            index: index,
            content: [],
            current_font: None,
            current_font_size: 12.0,
            current_color: PdfColor.black(),
            current_line_width: 1.0
        }
    }
    
    // -------------------------------------------------------------------------
    // Text Operations
    // -------------------------------------------------------------------------
    
    /// Set font
    fn font(font: PdfFontRef) -> Self { self.current_font = Some(font); self }
    
    /// Set font size
    fn font_size(size: Float64) -> Self { self.current_font_size = size; self }
    
    /// Set text color
    fn text_color(color: PdfColor) -> Self { self.current_color = color; self }
    
    /// Draw text at position
    fn draw_text(text: String, x: Float64, y: Float64) -> Self {
        self.content.push(PageContent.Text(TextContent {
            text: text,
            x: x,
            y: y,
            font: self.current_font.clone(),
            font_size: self.current_font_size,
            color: self.current_color.clone()
        }))
        self
    }
    
    /// Draw text with automatic line wrapping
    fn draw_text_wrapped(text: String, rect: PdfRect, line_height: Float64) -> Self {
        self.content.push(PageContent.WrappedText(WrappedTextContent {
            text: text,
            rect: rect,
            line_height: line_height,
            font: self.current_font.clone(),
            font_size: self.current_font_size,
            color: self.current_color.clone(),
            alignment: TextAlignment.Left
        }))
        self
    }
    
    /// Draw text with alignment
    fn draw_text_aligned(text: String, rect: PdfRect, alignment: TextAlignment) -> Self {
        self.content.push(PageContent.AlignedText(AlignedTextContent {
            text: text,
            rect: rect,
            alignment: alignment,
            font: self.current_font.clone(),
            font_size: self.current_font_size,
            color: self.current_color.clone()
        }))
        self
    }
    
    // -------------------------------------------------------------------------
    // Shape Operations
    // -------------------------------------------------------------------------
    
    /// Set stroke color
    fn stroke_color(color: PdfColor) -> Self { self.current_color = color; self }
    
    /// Set line width
    fn line_width(width: Float64) -> Self { self.current_line_width = width; self }
    
    /// Draw line
    fn draw_line(x1: Float64, y1: Float64, x2: Float64, y2: Float64) -> Self {
        self.content.push(PageContent.Line(LineContent {
            x1: x1, y1: y1, x2: x2, y2: y2,
            color: self.current_color.clone(),
            width: self.current_line_width
        }))
        self
    }
    
    /// Draw rectangle (stroke only)
    fn draw_rect(rect: PdfRect) -> Self {
        self.content.push(PageContent.Rect(RectContent {
            rect: rect,
            stroke_color: Some(self.current_color.clone()),
            fill_color: None,
            line_width: self.current_line_width
        }))
        self
    }
    
    /// Draw filled rectangle
    fn fill_rect(rect: PdfRect, color: PdfColor) -> Self {
        self.content.push(PageContent.Rect(RectContent {
            rect: rect,
            stroke_color: None,
            fill_color: Some(color),
            line_width: 0.0
        }))
        self
    }
    
    /// Draw rectangle with stroke and fill
    fn draw_fill_rect(rect: PdfRect, stroke: PdfColor, fill: PdfColor) -> Self {
        self.content.push(PageContent.Rect(RectContent {
            rect: rect,
            stroke_color: Some(stroke),
            fill_color: Some(fill),
            line_width: self.current_line_width
        }))
        self
    }
    
    /// Draw circle
    fn draw_circle(cx: Float64, cy: Float64, radius: Float64) -> Self {
        self.content.push(PageContent.Circle(CircleContent {
            cx: cx, cy: cy, radius: radius,
            stroke_color: Some(self.current_color.clone()),
            fill_color: None,
            line_width: self.current_line_width
        }))
        self
    }
    
    /// Draw filled circle
    fn fill_circle(cx: Float64, cy: Float64, radius: Float64, color: PdfColor) -> Self {
        self.content.push(PageContent.Circle(CircleContent {
            cx: cx, cy: cy, radius: radius,
            stroke_color: None,
            fill_color: Some(color),
            line_width: 0.0
        }))
        self
    }
    
    /// Draw ellipse
    fn draw_ellipse(cx: Float64, cy: Float64, rx: Float64, ry: Float64) -> Self {
        self.content.push(PageContent.Ellipse(EllipseContent {
            cx: cx, cy: cy, rx: rx, ry: ry,
            stroke_color: Some(self.current_color.clone()),
            fill_color: None,
            line_width: self.current_line_width
        }))
        self
    }
    
    /// Draw polygon
    fn draw_polygon(points: [(Float64, Float64)]) -> Self {
        self.content.push(PageContent.Polygon(PolygonContent {
            points: points,
            stroke_color: Some(self.current_color.clone()),
            fill_color: None,
            line_width: self.current_line_width,
            closed: true
        }))
        self
    }
    
    /// Draw polyline (open polygon)
    fn draw_polyline(points: [(Float64, Float64)]) -> Self {
        self.content.push(PageContent.Polygon(PolygonContent {
            points: points,
            stroke_color: Some(self.current_color.clone()),
            fill_color: None,
            line_width: self.current_line_width,
            closed: false
        }))
        self
    }
    
    // -------------------------------------------------------------------------
    // Image Operations
    // -------------------------------------------------------------------------
    
    /// Draw image at position
    fn draw_image(image: Image, x: Float64, y: Float64) -> Self {
        self.content.push(PageContent.Image(ImageContent {
            image: image,
            x: x,
            y: y,
            width: None,
            height: None
        }))
        self
    }
    
    /// Draw image with size
    fn draw_image_sized(image: Image, x: Float64, y: Float64, width: Float64, height: Float64) -> Self {
        self.content.push(PageContent.Image(ImageContent {
            image: image,
            x: x,
            y: y,
            width: Some(width),
            height: Some(height)
        }))
        self
    }
    
    /// Draw image from file
    fn draw_image_file(path: String, x: Float64, y: Float64) -> Result<Self, PdfError> {
        let img = Image.load(path)?
        Ok(self.draw_image(img, x, y))
    }
    
    /// Draw image fitting in rect (maintains aspect ratio)
    fn draw_image_fit(image: Image, rect: PdfRect) -> Self {
        self.content.push(PageContent.ImageFit(ImageFitContent {
            image: image,
            rect: rect,
            fit_mode: FitMode.Contain
        }))
        self
    }
    
    // -------------------------------------------------------------------------
    // Link Operations
    // -------------------------------------------------------------------------
    
    /// Add internal link (to page)
    fn add_link(rect: PdfRect, page_index: Int) -> Self {
        self.content.push(PageContent.Link(LinkContent {
            rect: rect,
            destination: LinkDest.Page(page_index)
        }))
        self
    }
    
    /// Add external link (URL)
    fn add_url_link(rect: PdfRect, url: String) -> Self {
        self.content.push(PageContent.Link(LinkContent {
            rect: rect,
            destination: LinkDest.Url(url)
        }))
        self
    }
    
    // -------------------------------------------------------------------------
    // Annotation Operations
    // -------------------------------------------------------------------------
    
    /// Add text annotation (note)
    fn add_note(rect: PdfRect, text: String) -> Self {
        self.content.push(PageContent.Annotation(AnnotationContent {
            annotation_type: AnnotType.Text,
            rect: rect,
            content: text,
            color: self.current_color.clone()
        }))
        self
    }
    
    /// Add highlight annotation
    fn add_highlight(rect: PdfRect) -> Self {
        self.content.push(PageContent.Annotation(AnnotationContent {
            annotation_type: AnnotType.Highlight,
            rect: rect,
            content: String.new(),
            color: PdfColor.rgb(1.0, 1.0, 0.0)  // Yellow
        }))
        self
    }
    
    // -------------------------------------------------------------------------
    // Path Operations
    // -------------------------------------------------------------------------
    
    /// Begin a new path
    fn begin_path() -> PathBuilder {
        PathBuilder.new(self)
    }
}

// =============================================================================
// Path Builder
// =============================================================================

/// Path builder for complex shapes
struct PathBuilder {
    page: PdfPageBuilder
    commands: [PathCommand]
    stroke_color: Option<PdfColor>
    fill_color: Option<PdfColor>
    line_width: Float64
}

impl PathBuilder {
    fn new(page: PdfPageBuilder) -> Self {
        PathBuilder {
            page: page,
            commands: [],
            stroke_color: Some(page.current_color.clone()),
            fill_color: None,
            line_width: page.current_line_width
        }
    }
    
    fn move_to(x: Float64, y: Float64) -> Self { self.commands.push(PathCommand.MoveTo(x, y)); self }
    fn line_to(x: Float64, y: Float64) -> Self { self.commands.push(PathCommand.LineTo(x, y)); self }
    fn curve_to(x1: Float64, y1: Float64, x2: Float64, y2: Float64, x3: Float64, y3: Float64) -> Self {
        self.commands.push(PathCommand.CurveTo(x1, y1, x2, y2, x3, y3)); self
    }
    fn quad_to(x1: Float64, y1: Float64, x2: Float64, y2: Float64) -> Self {
        self.commands.push(PathCommand.QuadTo(x1, y1, x2, y2)); self
    }
    fn arc(cx: Float64, cy: Float64, r: Float64, start: Float64, end: Float64) -> Self {
        self.commands.push(PathCommand.Arc(cx, cy, r, start, end)); self
    }
    fn close() -> Self { self.commands.push(PathCommand.Close); self }
    
    fn stroke(color: PdfColor) -> Self { self.stroke_color = Some(color); self }
    fn fill(color: PdfColor) -> Self { self.fill_color = Some(color); self }
    fn line_width(w: Float64) -> Self { self.line_width = w; self }
    
    fn end() -> PdfPageBuilder {
        self.page.content.push(PageContent.Path(PathContent {
            commands: self.commands.clone(),
            stroke_color: self.stroke_color.clone(),
            fill_color: self.fill_color.clone(),
            line_width: self.line_width
        }))
        self.page
    }
}

enum PathCommand {
    MoveTo(Float64, Float64),
    LineTo(Float64, Float64),
    CurveTo(Float64, Float64, Float64, Float64, Float64, Float64),
    QuadTo(Float64, Float64, Float64, Float64),
    Arc(Float64, Float64, Float64, Float64, Float64),
    Close
}

// =============================================================================
// Content Types
// =============================================================================

enum PageContent {
    Text(TextContent),
    WrappedText(WrappedTextContent),
    AlignedText(AlignedTextContent),
    Line(LineContent),
    Rect(RectContent),
    Circle(CircleContent),
    Ellipse(EllipseContent),
    Polygon(PolygonContent),
    Path(PathContent),
    Image(ImageContent),
    ImageFit(ImageFitContent),
    Link(LinkContent),
    Annotation(AnnotationContent)
}

struct TextContent { text: String, x: Float64, y: Float64, font: Option<PdfFontRef>, font_size: Float64, color: PdfColor }
struct WrappedTextContent { text: String, rect: PdfRect, line_height: Float64, font: Option<PdfFontRef>, font_size: Float64, color: PdfColor, alignment: TextAlignment }
struct AlignedTextContent { text: String, rect: PdfRect, alignment: TextAlignment, font: Option<PdfFontRef>, font_size: Float64, color: PdfColor }
struct LineContent { x1: Float64, y1: Float64, x2: Float64, y2: Float64, color: PdfColor, width: Float64 }
struct RectContent { rect: PdfRect, stroke_color: Option<PdfColor>, fill_color: Option<PdfColor>, line_width: Float64 }
struct CircleContent { cx: Float64, cy: Float64, radius: Float64, stroke_color: Option<PdfColor>, fill_color: Option<PdfColor>, line_width: Float64 }
struct EllipseContent { cx: Float64, cy: Float64, rx: Float64, ry: Float64, stroke_color: Option<PdfColor>, fill_color: Option<PdfColor>, line_width: Float64 }
struct PolygonContent { points: [(Float64, Float64)], stroke_color: Option<PdfColor>, fill_color: Option<PdfColor>, line_width: Float64, closed: Bool }
struct PathContent { commands: [PathCommand], stroke_color: Option<PdfColor>, fill_color: Option<PdfColor>, line_width: Float64 }
struct ImageContent { image: Image, x: Float64, y: Float64, width: Option<Float64>, height: Option<Float64> }
struct ImageFitContent { image: Image, rect: PdfRect, fit_mode: FitMode }
struct LinkContent { rect: PdfRect, destination: LinkDest }
struct AnnotationContent { annotation_type: AnnotType, rect: PdfRect, content: String, color: PdfColor }

enum TextAlignment { Left, Center, Right, Justify }
enum FitMode { Contain, Cover, Fill, ScaleDown }
enum LinkDest { Page(Int), Url(String), Named(String) }
enum AnnotType { Text, Highlight, Underline, StrikeOut, Squiggly }

// =============================================================================
// Fonts
// =============================================================================

/// Font reference
struct PdfFontRef { name: String, handle: @native("PdfFontHandle") }

impl PdfFontRef {
    /// Load built-in font
    fn helvetica() -> Self { PdfFontRef { name: "Helvetica".to_string(), handle: @native("pdf_font_helvetica") } }
    fn helvetica_bold() -> Self { PdfFontRef { name: "Helvetica-Bold".to_string(), handle: @native("pdf_font_helvetica_bold") } }
    fn helvetica_italic() -> Self { PdfFontRef { name: "Helvetica-Oblique".to_string(), handle: @native("pdf_font_helvetica_italic") } }
    fn times() -> Self { PdfFontRef { name: "Times-Roman".to_string(), handle: @native("pdf_font_times") } }
    fn times_bold() -> Self { PdfFontRef { name: "Times-Bold".to_string(), handle: @native("pdf_font_times_bold") } }
    fn times_italic() -> Self { PdfFontRef { name: "Times-Italic".to_string(), handle: @native("pdf_font_times_italic") } }
    fn courier() -> Self { PdfFontRef { name: "Courier".to_string(), handle: @native("pdf_font_courier") } }
    fn courier_bold() -> Self { PdfFontRef { name: "Courier-Bold".to_string(), handle: @native("pdf_font_courier_bold") } }
    fn symbol() -> Self { PdfFontRef { name: "Symbol".to_string(), handle: @native("pdf_font_symbol") } }
    fn zapf_dingbats() -> Self { PdfFontRef { name: "ZapfDingbats".to_string(), handle: @native("pdf_font_zapf") } }
    
    /// Load TrueType font from file
    fn load_ttf(path: String) -> Result<Self, PdfError> {
        let handle = @native("pdf_font_load_ttf", path)?
        Ok(PdfFontRef { name: path.clone(), handle: handle })
    }
    
    /// Load OpenType font from file
    fn load_otf(path: String) -> Result<Self, PdfError> {
        let handle = @native("pdf_font_load_otf", path)?
        Ok(PdfFontRef { name: path.clone(), handle: handle })
    }
    
    /// Measure text width
    fn measure_width(text: String, size: Float64) -> Float64 {
        @native("pdf_font_measure_width", self.handle, text, size)
    }
    
    /// Measure text height
    fn measure_height(size: Float64) -> Float64 {
        @native("pdf_font_measure_height", self.handle, size)
    }
}

// =============================================================================
// Permissions
// =============================================================================

struct PdfPermissions {
    print: Bool
    modify: Bool
    copy: Bool
    annotate: Bool
    fill_forms: Bool
    extract: Bool
    assemble: Bool
    print_high_quality: Bool
}

impl PdfPermissions {
    fn all() -> Self {
        PdfPermissions {
            print: true, modify: true, copy: true, annotate: true,
            fill_forms: true, extract: true, assemble: true, print_high_quality: true
        }
    }
    
    fn none() -> Self {
        PdfPermissions {
            print: false, modify: false, copy: false, annotate: false,
            fill_forms: false, extract: false, assemble: false, print_high_quality: false
        }
    }
    
    fn read_only() -> Self {
        PdfPermissions {
            print: true, modify: false, copy: true, annotate: false,
            fill_forms: false, extract: true, assemble: false, print_high_quality: true
        }
    }
}

// =============================================================================
// Compression
// =============================================================================

enum CompressionLevel { None, Fast, Default, Best }

// =============================================================================
// Convenience Functions
// =============================================================================

/// Create new PDF writer
fn new() -> PdfWriter { PdfWriter.new() }

/// Create simple text PDF
fn create_text_pdf(path: String, text: String) -> Result<(), PdfError> {
    let mut writer = PdfWriter.new()
    let page = writer.add_page()
        .font(PdfFontRef.helvetica())
        .font_size(12.0)
        .draw_text_wrapped(text, PdfRect.new(50.0, 50.0, 495.0, 742.0), 14.0)
    writer.save(path)
}

/// Create PDF from images
fn create_image_pdf(path: String, images: [Image]) -> Result<(), PdfError> {
    let mut writer = PdfWriter.new()
    for img in images {
        let size = PdfPageSize { width: img.width as Float64, height: img.height as Float64 }
        writer.add_page_with_size(size).draw_image(img, 0.0, 0.0)
    }
    writer.save(path)
}

// =============================================================================
// Tests
// =============================================================================

test "create simple pdf" {
    let mut writer = PdfWriter.new()
        .title("Test Document")
        .author("Vibee")
    
    writer.add_page()
        .font(PdfFontRef.helvetica())
        .font_size(24.0)
        .draw_text("Hello, PDF!", 100.0, 700.0)
    
    let bytes = writer.to_bytes()?
    assert(bytes.len() > 0)?
}

test "page builder" {
    let mut writer = PdfWriter.new()
    let page = writer.add_page()
        .draw_line(0.0, 0.0, 100.0, 100.0)
        .draw_rect(PdfRect.new(50.0, 50.0, 100.0, 100.0))
        .fill_circle(200.0, 200.0, 50.0, PdfColor.red())
    
    assert(page.content.len() == 3)?
}

test "font loading" {
    let helvetica = PdfFontRef.helvetica()
    let width = helvetica.measure_width("Hello", 12.0)
    assert(width > 0.0)?
}

test "permissions" {
    let perms = PdfPermissions.read_only()
    assert(perms.print)?
    assert(!perms.modify)?
}
