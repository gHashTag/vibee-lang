// =============================================================================
// Vibee OS â€” NATS Module
// High-performance cloud-native messaging system
// =============================================================================

// -----------------------------------------------------------------------------
// Configuration
// -----------------------------------------------------------------------------

/// NATS connection options
struct NatsOptions {
    servers: [String]
    name: String
    token: Option<String>
    user: Option<String>
    password: Option<String>
    tls: Option<TlsConfig>
    reconnect: Bool
    max_reconnects: Int
    reconnect_wait: Duration
    ping_interval: Duration
    max_pings_out: Int
    
    fn new(servers: [String]) -> Self {
        NatsOptions {
            servers: servers,
            name: "vibee-nats",
            token: None,
            user: None,
            password: None,
            tls: None,
            reconnect: true,
            max_reconnects: 60,
            reconnect_wait: Duration.seconds(2),
            ping_interval: Duration.minutes(2),
            max_pings_out: 2
        }
    }
    
    fn with_auth(user: String, password: String) -> Self {
        self.user = Some(user)
        self.password = Some(password)
        self
    }
    
    fn with_token(token: String) -> Self {
        self.token = Some(token)
        self
    }
    
    fn with_tls(config: TlsConfig) -> Self {
        self.tls = Some(config)
        self
    }
}

struct TlsConfig {
    cert_file: Option<String>
    key_file: Option<String>
    ca_file: Option<String>
}

// -----------------------------------------------------------------------------
// Connection
// -----------------------------------------------------------------------------

/// NATS connection
actor NatsConnection {
    state options: NatsOptions
    state connected: Bool
    state subscriptions: Map<String, NatsSubscription>
    
    fn connect(url: String) -> Result<Self, NatsError> {
        Self.connect_with_options(NatsOptions.new([url]))
    }
    
    fn connect_with_options(options: NatsOptions) -> Result<Self, NatsError> {
        let conn = NatsConnection {
            options: options,
            connected: false,
            subscriptions: Map.empty()
        }
        @native("nats_connect", options)
        conn.connected = true
        Ok(conn)
    }
    
    /// Publish message to subject
    on publish(subject: String, data: [Byte]) -> Result<(), NatsError> {
        if !self.connected { return Err(NatsError.NotConnected) }
        @native("nats_publish", subject, data)
    }
    
    /// Publish with reply subject
    on publish_request(subject: String, reply: String, data: [Byte]) -> Result<(), NatsError> {
        if !self.connected { return Err(NatsError.NotConnected) }
        @native("nats_publish_request", subject, reply, data)
    }
    
    /// Request-reply pattern
    on request(subject: String, data: [Byte], timeout: Duration) -> Result<NatsMessage, NatsError> {
        if !self.connected { return Err(NatsError.NotConnected) }
        @native("nats_request", subject, data, timeout.as_millis())
    }
    
    /// Subscribe to subject
    on subscribe(subject: String) -> Result<NatsSubscription, NatsError> {
        if !self.connected { return Err(NatsError.NotConnected) }
        let sub = NatsSubscription.new(subject)
        @native("nats_subscribe", subject, sub)
        self.subscriptions.set(subject, sub)
        Ok(sub)
    }
    
    /// Subscribe to queue group
    on queue_subscribe(subject: String, queue: String) -> Result<NatsSubscription, NatsError> {
        if !self.connected { return Err(NatsError.NotConnected) }
        let sub = NatsSubscription.new(subject)
        @native("nats_queue_subscribe", subject, queue, sub)
        Ok(sub)
    }
    
    /// Flush pending operations
    on flush() -> Result<(), NatsError> {
        @native("nats_flush")
    }
    
    /// Close connection
    on close() {
        for (_, sub) in self.subscriptions {
            sub.unsubscribe()
        }
        @native("nats_close")
        self.connected = false
    }
    
    fn is_connected() -> Bool { self.connected }
}

// -----------------------------------------------------------------------------
// Messages and Subscriptions
// -----------------------------------------------------------------------------

/// NATS message
struct NatsMessage {
    subject: String
    reply: Option<String>
    data: [Byte]
    headers: Map<String, String>
    
    fn new(subject: String, data: [Byte]) -> Self {
        NatsMessage { subject: subject, reply: None, data: data, headers: Map.empty() }
    }
    
    fn as_string() -> Result<String, DecodeError> { String.from_utf8(self.data) }
    fn as_json<T: Deserialize>() -> Result<T, DecodeError> { JSON.parse(self.as_string()?) }
}

/// NATS subscription
actor NatsSubscription {
    state subject: String
    state messages: Channel<NatsMessage>
    state active: Bool
    
    fn new(subject: String) -> Self {
        NatsSubscription { subject: subject, messages: Channel.unbounded(), active: true }
    }
    
    on next() -> Option<NatsMessage> {
        if !self.active { return None }
        self.messages.recv().ok()
    }
    
    on next_timeout(timeout: Duration) -> Option<NatsMessage> {
        if !self.active { return None }
        self.messages.recv_timeout(timeout).ok()
    }
    
    on unsubscribe() {
        self.active = false
        @native("nats_unsubscribe", self.subject)
    }
    
    fn iter() -> SubscriptionIterator { SubscriptionIterator { sub: self } }
}

struct SubscriptionIterator { sub: NatsSubscription }
impl Iterator for SubscriptionIterator {
    type Item = NatsMessage
    fn next() -> Option<NatsMessage> { self.sub.next() }
}

// -----------------------------------------------------------------------------
// JetStream
// -----------------------------------------------------------------------------

/// JetStream context
actor JetStream {
    state conn: NatsConnection
    
    fn new(conn: NatsConnection) -> Self { JetStream { conn: conn } }
    
    /// Create or update stream
    on add_stream(config: StreamConfig) -> Result<StreamInfo, NatsError> {
        @native("nats_js_add_stream", config)
    }
    
    /// Delete stream
    on delete_stream(name: String) -> Result<(), NatsError> {
        @native("nats_js_delete_stream", name)
    }
    
    /// Get stream info
    on stream_info(name: String) -> Result<StreamInfo, NatsError> {
        @native("nats_js_stream_info", name)
    }
    
    /// Publish to stream
    on publish(subject: String, data: [Byte]) -> Result<PubAck, NatsError> {
        @native("nats_js_publish", subject, data)
    }
    
    /// Create consumer
    on add_consumer(stream: String, config: ConsumerConfig) -> Result<ConsumerInfo, NatsError> {
        @native("nats_js_add_consumer", stream, config)
    }
    
    /// Subscribe with consumer
    on subscribe(stream: String, consumer: String) -> Result<JetStreamSubscription, NatsError> {
        let sub = JetStreamSubscription.new(stream, consumer)
        @native("nats_js_subscribe", stream, consumer, sub)
        Ok(sub)
    }
    
    /// Pull subscribe
    on pull_subscribe(stream: String, consumer: String) -> Result<JetStreamPullSubscription, NatsError> {
        let sub = JetStreamPullSubscription.new(stream, consumer)
        @native("nats_js_pull_subscribe", stream, consumer, sub)
        Ok(sub)
    }
}

/// Stream configuration
struct StreamConfig {
    name: String
    subjects: [String]
    retention: RetentionPolicy
    max_consumers: Int
    max_msgs: Int64
    max_bytes: Int64
    max_age: Duration
    storage: StorageType
    replicas: Int
    
    fn new(name: String, subjects: [String]) -> Self {
        StreamConfig {
            name: name, subjects: subjects, retention: RetentionPolicy.Limits,
            max_consumers: -1, max_msgs: -1, max_bytes: -1,
            max_age: Duration.zero(), storage: StorageType.File, replicas: 1
        }
    }
}

enum RetentionPolicy { Limits, Interest, WorkQueue }
enum StorageType { File, Memory }

struct StreamInfo { config: StreamConfig, state: StreamState }
struct StreamState { messages: Int64, bytes: Int64, first_seq: Int64, last_seq: Int64 }

/// Consumer configuration
struct ConsumerConfig {
    durable_name: Option<String>
    deliver_policy: DeliverPolicy
    ack_policy: AckPolicy
    max_deliver: Int
    filter_subject: Option<String>
    
    fn new() -> Self {
        ConsumerConfig {
            durable_name: None, deliver_policy: DeliverPolicy.All,
            ack_policy: AckPolicy.Explicit, max_deliver: -1, filter_subject: None
        }
    }
    
    fn durable(name: String) -> Self { self.durable_name = Some(name); self }
}

enum DeliverPolicy { All, Last, New, ByStartSeq(Int64), ByStartTime(Int64) }
enum AckPolicy { None, All, Explicit }

struct ConsumerInfo { name: String, config: ConsumerConfig, num_pending: Int64 }
struct PubAck { stream: String, seq: Int64 }

/// JetStream subscription
actor JetStreamSubscription {
    state stream: String
    state consumer: String
    state messages: Channel<JetStreamMessage>
    state active: Bool
    
    fn new(stream: String, consumer: String) -> Self {
        JetStreamSubscription { stream: stream, consumer: consumer, messages: Channel.unbounded(), active: true }
    }
    
    on next() -> Option<JetStreamMessage> { self.messages.recv().ok() }
    on unsubscribe() { self.active = false }
}

/// JetStream pull subscription
actor JetStreamPullSubscription {
    state stream: String
    state consumer: String
    
    fn new(stream: String, consumer: String) -> Self {
        JetStreamPullSubscription { stream: stream, consumer: consumer }
    }
    
    on fetch(batch: Int, timeout: Duration) -> Result<[JetStreamMessage], NatsError> {
        @native("nats_js_fetch", self.stream, self.consumer, batch, timeout.as_millis())
    }
}

/// JetStream message
struct JetStreamMessage {
    subject: String
    data: [Byte]
    seq: Int64
    
    fn as_string() -> Result<String, DecodeError> { String.from_utf8(self.data) }
    fn as_json<T: Deserialize>() -> Result<T, DecodeError> { JSON.parse(self.as_string()?) }
    fn ack() -> Result<(), NatsError> { @native("nats_js_ack", self.seq) }
    fn nak() -> Result<(), NatsError> { @native("nats_js_nak", self.seq) }
}

// -----------------------------------------------------------------------------
// Key-Value Store
// -----------------------------------------------------------------------------

/// Key-Value bucket
actor KeyValue {
    state js: JetStream
    state bucket: String
    
    fn new(js: JetStream, bucket: String) -> Result<Self, NatsError> {
        @native("nats_kv_create", bucket)
        Ok(KeyValue { js: js, bucket: bucket })
    }
    
    on get(key: String) -> Result<Option<KvEntry>, NatsError> { @native("nats_kv_get", self.bucket, key) }
    on put(key: String, value: [Byte]) -> Result<Int64, NatsError> { @native("nats_kv_put", self.bucket, key, value) }
    on delete(key: String) -> Result<(), NatsError> { @native("nats_kv_delete", self.bucket, key) }
    on keys() -> Result<[String], NatsError> { @native("nats_kv_keys", self.bucket) }
    on watch(key: String) -> Result<KvWatcher, NatsError> { @native("nats_kv_watch", self.bucket, key) }
}

struct KvEntry { key: String, value: [Byte], revision: Int64 }
actor KvWatcher {
    state updates: Channel<KvEntry>
    on next() -> Option<KvEntry> { self.updates.recv().ok() }
    on stop() { @native("nats_kv_watch_stop") }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum NatsError {
    NotConnected
    ConnectionFailed(String)
    Timeout
    NoResponders
    InvalidSubject
    StreamNotFound
    ConsumerNotFound
    KeyNotFound
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "message creation" {
    let msg = NatsMessage.new("test.subject", "hello".bytes())
    assert_eq(msg.subject, "test.subject")?
    assert_eq(msg.as_string()?, "hello")?
}

test "stream config" {
    let config = StreamConfig.new("ORDERS", ["orders.*"])
    assert_eq(config.name, "ORDERS")?
}
