// =============================================================================
// Vibee OS â€” Glob Module
// File path pattern matching
// =============================================================================

/// Glob pattern
struct Glob {
    pattern: String
    segments: [GlobSegment]
    
    /// Compile glob pattern
    fn new(pattern: String) -> Result<Self, GlobError> {
        let segments = parse_pattern(pattern)?
        Ok(Glob { pattern: pattern, segments: segments })
    }
    
    /// Check if path matches pattern
    fn matches(path: String) -> Bool {
        let path_segments = path.split("/").filter(|s| !s.is_empty()).collect()
        match_segments(self.segments, path_segments, 0, 0)
    }
    
    /// Check if path matches (case-insensitive)
    fn matches_ignore_case(path: String) -> Bool {
        let lower_pattern = Glob.new(self.pattern.to_lower()).unwrap_or(self)
        lower_pattern.matches(path.to_lower())
    }
    
    /// Find all matching files in directory
    fn find(root: String) -> [String] {
        find_matches(root, self)
    }
    
    /// Find matching files with options
    fn find_with(root: String, opts: GlobOptions) -> [String] {
        find_matches_with(root, self, opts)
    }
    
    /// Convert to regex pattern
    fn to_regex() -> String {
        glob_to_regex(self.pattern)
    }
    
    /// Get original pattern
    fn pattern() -> String {
        self.pattern
    }
}

/// Glob segment
enum GlobSegment {
    Literal(String)      // exact match
    Any                  // * - any characters except /
    AnyRecursive         // ** - any path segments
    Single               // ? - single character
    CharClass([CharRange], Bool)  // [abc] or [!abc]
    Alternation([String])  // {a,b,c}
}

/// Character range for [a-z]
struct CharRange {
    start: Char
    end: Char
    
    fn single(c: Char) -> Self {
        CharRange { start: c, end: c }
    }
    
    fn range(start: Char, end: Char) -> Self {
        CharRange { start: start, end: end }
    }
    
    fn contains(c: Char) -> Bool {
        c >= self.start && c <= self.end
    }
}

/// Glob options
struct GlobOptions {
    dot: Bool           // Match dotfiles
    nocase: Bool        // Case-insensitive
    follow_symlinks: Bool
    max_depth: Option<Int>
    
    fn default() -> Self {
        GlobOptions {
            dot: false,
            nocase: false,
            follow_symlinks: true,
            max_depth: None
        }
    }
    
    fn with_dot() -> Self { GlobOptions { dot: true, ..Self.default() } }
    fn with_nocase() -> Self { GlobOptions { nocase: true, ..Self.default() } }
}

// -----------------------------------------------------------------------------
// Pattern Parsing
// -----------------------------------------------------------------------------

fn parse_pattern(pattern: String) -> Result<[GlobSegment], GlobError> {
    let segments = pattern.split("/").filter(|s| !s.is_empty())
    var result = []
    
    for seg in segments {
        result.push(parse_segment(seg)?)
    }
    
    Ok(result)
}

fn parse_segment(s: String) -> Result<GlobSegment, GlobError> {
    if s == "**" {
        return Ok(GlobSegment.AnyRecursive)
    }
    if s == "*" {
        return Ok(GlobSegment.Any)
    }
    if s == "?" {
        return Ok(GlobSegment.Single)
    }
    
    // Check for special characters
    let has_special = s.chars().any(|c| c == '*' || c == '?' || c == '[' || c == '{')
    if !has_special {
        return Ok(GlobSegment.Literal(s))
    }
    
    // Handle alternation {a,b,c}
    if s.starts_with("{") && s.ends_with("}") && !s[1..(s.len()-1)].contains("{") {
        let inner = s[1..(s.len()-1)]
        let alts = inner.split(",").collect()
        return Ok(GlobSegment.Alternation(alts))
    }
    
    // Handle character class [abc]
    if s.starts_with("[") && s.ends_with("]") {
        let inner = s[1..(s.len()-1)]
        let (negated, chars) = if inner.starts_with("!") || inner.starts_with("^") {
            (true, inner[1..])
        } else {
            (false, inner)
        }
        
        let ranges = parse_char_class(chars)?
        return Ok(GlobSegment.CharClass(ranges, negated))
    }
    
    // Complex pattern - keep as literal with wildcards
    Ok(GlobSegment.Literal(s))
}

fn parse_char_class(s: String) -> Result<[CharRange], GlobError> {
    var ranges = []
    var i = 0
    let chars = s.chars().collect::<Vec<_>>()
    
    while i < chars.len() {
        let c = chars[i]
        if i + 2 < chars.len() && chars[i + 1] == '-' {
            ranges.push(CharRange.range(c, chars[i + 2]))
            i += 3
        } else {
            ranges.push(CharRange.single(c))
            i += 1
        }
    }
    
    Ok(ranges)
}

// -----------------------------------------------------------------------------
// Pattern Matching
// -----------------------------------------------------------------------------

fn match_segments(patterns: [GlobSegment], path: [String], pi: Int, si: Int) -> Bool {
    if pi >= patterns.len() {
        return si >= path.len()
    }
    
    match patterns[pi] {
        GlobSegment.AnyRecursive => {
            // ** matches zero or more path segments
            for i in si..=path.len() {
                if match_segments(patterns, path, pi + 1, i) {
                    return true
                }
            }
            false
        }
        
        GlobSegment.Literal(lit) => {
            if si >= path.len() { return false }
            if match_literal(lit, path[si]) {
                match_segments(patterns, path, pi + 1, si + 1)
            } else {
                false
            }
        }
        
        GlobSegment.Any => {
            if si >= path.len() { return false }
            // * matches any single segment (but not starting with .)
            if !path[si].starts_with(".") || path[si] == "." || path[si] == ".." {
                match_segments(patterns, path, pi + 1, si + 1)
            } else {
                false
            }
        }
        
        GlobSegment.Single => {
            if si >= path.len() { return false }
            if path[si].len() == 1 {
                match_segments(patterns, path, pi + 1, si + 1)
            } else {
                false
            }
        }
        
        GlobSegment.CharClass(ranges, negated) => {
            if si >= path.len() { return false }
            if path[si].len() != 1 { return false }
            let c = path[si].chars().next().unwrap()
            let in_class = ranges.iter().any(|r| r.contains(c))
            let matches = if negated { !in_class } else { in_class }
            if matches {
                match_segments(patterns, path, pi + 1, si + 1)
            } else {
                false
            }
        }
        
        GlobSegment.Alternation(alts) => {
            if si >= path.len() { return false }
            for alt in alts {
                if path[si] == alt {
                    if match_segments(patterns, path, pi + 1, si + 1) {
                        return true
                    }
                }
            }
            false
        }
    }
}

fn match_literal(pattern: String, text: String) -> Bool {
    if !pattern.contains("*") && !pattern.contains("?") {
        return pattern == text
    }
    
    // Simple wildcard matching
    let p_chars = pattern.chars().collect::<Vec<_>>()
    let t_chars = text.chars().collect::<Vec<_>>()
    
    match_wildcard(p_chars, t_chars, 0, 0)
}

fn match_wildcard(pattern: [Char], text: [Char], pi: Int, ti: Int) -> Bool {
    if pi >= pattern.len() {
        return ti >= text.len()
    }
    
    match pattern[pi] {
        '*' => {
            // * matches zero or more characters
            for i in ti..=text.len() {
                if match_wildcard(pattern, text, pi + 1, i) {
                    return true
                }
            }
            false
        }
        '?' => {
            if ti >= text.len() { return false }
            match_wildcard(pattern, text, pi + 1, ti + 1)
        }
        c => {
            if ti >= text.len() { return false }
            if c == text[ti] {
                match_wildcard(pattern, text, pi + 1, ti + 1)
            } else {
                false
            }
        }
    }
}

// -----------------------------------------------------------------------------
// File Finding
// -----------------------------------------------------------------------------

fn find_matches(root: String, glob: Glob) -> [String] {
    find_matches_with(root, glob, GlobOptions.default())
}

fn find_matches_with(root: String, glob: Glob, opts: GlobOptions) -> [String] {
    var results = []
    walk_dir(root, glob, opts, 0, results)
    results
}

fn walk_dir(dir: String, glob: Glob, opts: GlobOptions, depth: Int, results: [String]) {
    if let Some(max) = opts.max_depth {
        if depth > max { return }
    }
    
    let entries = @native("read_dir", dir)
    for entry in entries {
        let name = entry.name
        let path = format!("{}/{}", dir, name)
        
        // Skip dotfiles unless enabled
        if !opts.dot && name.starts_with(".") && name != "." && name != ".." {
            continue
        }
        
        // Check if matches
        let rel_path = path.trim_start(dir).trim_start("/")
        let check_path = if opts.nocase { rel_path.to_lower() } else { rel_path }
        
        if glob.matches(check_path) {
            results.push(path)
        }
        
        // Recurse into directories
        if entry.is_dir {
            if !opts.follow_symlinks && entry.is_symlink {
                continue
            }
            walk_dir(path, glob, opts, depth + 1, results)
        }
    }
}

// -----------------------------------------------------------------------------
// Regex Conversion
// -----------------------------------------------------------------------------

fn glob_to_regex(pattern: String) -> String {
    var regex = "^"
    
    for c in pattern.chars() {
        match c {
            '*' => regex.push_str(".*")
            '?' => regex.push_str(".")
            '.' => regex.push_str("\\.")
            '/' => regex.push_str("/")
            '[' => regex.push_str("[")
            ']' => regex.push_str("]")
            '{' => regex.push_str("(")
            '}' => regex.push_str(")")
            ',' => regex.push_str("|")
            '^' | '$' | '+' | '|' | '(' | ')' | '\\' => {
                regex.push('\\')
                regex.push(c)
            }
            _ => regex.push(c)
        }
    }
    
    regex.push('$')
    regex
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Match path against pattern
fn matches(pattern: String, path: String) -> Bool {
    Glob.new(pattern).map(|g| g.matches(path)).unwrap_or(false)
}

/// Find files matching pattern
fn find(pattern: String) -> [String] {
    let (root, glob_part) = split_root(pattern)
    Glob.new(glob_part).map(|g| g.find(root)).unwrap_or([])
}

fn split_root(pattern: String) -> (String, String) {
    // Find first segment with wildcards
    let segments = pattern.split("/")
    var root_parts = []
    var glob_parts = []
    var found_glob = false
    
    for seg in segments {
        if found_glob || seg.contains("*") || seg.contains("?") || seg.contains("[") {
            found_glob = true
            glob_parts.push(seg)
        } else {
            root_parts.push(seg)
        }
    }
    
    let root = if root_parts.is_empty() { "." } else { root_parts.join("/") }
    let glob = glob_parts.join("/")
    (root, glob)
}

/// Escape special characters
fn escape(s: String) -> String {
    var result = ""
    for c in s.chars() {
        match c {
            '*' | '?' | '[' | ']' | '{' | '}' | '\\' => {
                result.push('\\')
                result.push(c)
            }
            _ => result.push(c)
        }
    }
    result
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum GlobError {
    InvalidPattern(String)
    UnmatchedBracket
    InvalidCharClass
}

impl Display for GlobError {
    fn fmt(f: Formatter) {
        match self {
            InvalidPattern(s) => f.write(format!("Invalid pattern: {}", s))
            UnmatchedBracket => f.write("Unmatched bracket")
            InvalidCharClass => f.write("Invalid character class")
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "literal match" {
    let g = Glob.new("foo.txt")?
    assert(g.matches("foo.txt"))?
    assert(!g.matches("bar.txt"))?
}

test "star wildcard" {
    let g = Glob.new("*.txt")?
    assert(g.matches("foo.txt"))?
    assert(g.matches("bar.txt"))?
    assert(!g.matches("foo.md"))?
}

test "question wildcard" {
    let g = Glob.new("?.txt")?
    assert(g.matches("a.txt"))?
    assert(!g.matches("ab.txt"))?
}

test "double star" {
    let g = Glob.new("**/*.txt")?
    assert(g.matches("foo.txt"))?
    assert(g.matches("a/foo.txt"))?
    assert(g.matches("a/b/c/foo.txt"))?
}

test "character class" {
    let g = Glob.new("[abc].txt")?
    assert(g.matches("a.txt"))?
    assert(g.matches("b.txt"))?
    assert(!g.matches("d.txt"))?
}

test "negated class" {
    let g = Glob.new("[!abc].txt")?
    assert(!g.matches("a.txt"))?
    assert(g.matches("d.txt"))?
}

test "alternation" {
    let g = Glob.new("{foo,bar}.txt")?
    assert(g.matches("foo.txt"))?
    assert(g.matches("bar.txt"))?
    assert(!g.matches("baz.txt"))?
}

test "complex pattern" {
    let g = Glob.new("src/**/*.{js,ts}")?
    assert(g.matches("src/index.js"))?
    assert(g.matches("src/lib/utils.ts"))?
    assert(!g.matches("src/style.css"))?
}
