// =============================================================================
// Vibee OS â€” Workflow Trigger Module
// Triggers for starting workflows
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}
use cron::CronExpr

// =============================================================================
// Trigger Trait
// =============================================================================

trait Trigger {
    fn id() -> String
    fn name() -> String
    fn is_active() -> Bool
    fn check(context: TriggerContext) -> Option<TriggerEvent>
    fn activate()
    fn deactivate()
}

// =============================================================================
// Trigger Context & Event
// =============================================================================

struct TriggerContext {
    timestamp: DateTime
    data: Map<String, Any>
    source: String
    
    fn new() -> Self {
        TriggerContext {
            timestamp: DateTime.now(),
            data: Map.empty(),
            source: "system"
        }
    }
}

struct TriggerEvent {
    trigger_id: String
    workflow_id: String
    timestamp: DateTime
    payload: Map<String, Any>
    
    fn new(trigger_id: String, workflow_id: String) -> Self {
        TriggerEvent {
            trigger_id: trigger_id,
            workflow_id: workflow_id,
            timestamp: DateTime.now(),
            payload: Map.empty()
        }
    }
}

// =============================================================================
// Manual Trigger
// =============================================================================

struct ManualTrigger {
    id: String
    workflow_id: String
    active: Bool
    
    fn new(id: String, workflow_id: String) -> Self {
        ManualTrigger { id: id, workflow_id: workflow_id, active: true }
    }
    
    fn fire(payload: Map<String, Any>) -> TriggerEvent {
        var event = TriggerEvent.new(self.id.clone(), self.workflow_id.clone())
        event.payload = payload
        event
    }
}

impl Trigger for ManualTrigger {
    fn id() -> String { self.id.clone() }
    fn name() -> String { "Manual Trigger" }
    fn is_active() -> Bool { self.active }
    fn check(context: TriggerContext) -> Option<TriggerEvent> { None }
    fn activate() { self.active = true }
    fn deactivate() { self.active = false }
}

// =============================================================================
// Schedule Trigger
// =============================================================================

struct ScheduleTrigger {
    id: String
    workflow_id: String
    cron: CronExpr
    active: Bool
    last_fired: Option<DateTime>
    timezone: String
    
    fn new(id: String, workflow_id: String, cron_expr: String) -> Result<Self, TriggerError> {
        let cron = CronExpr.parse(cron_expr).map_err(|e| TriggerError.InvalidConfig(e.to_string()))?
        Ok(ScheduleTrigger {
            id: id,
            workflow_id: workflow_id,
            cron: cron,
            active: true,
            last_fired: None,
            timezone: "UTC"
        })
    }
    
    fn hourly(id: String, workflow_id: String) -> Self {
        Self.new(id, workflow_id, "0 * * * *").unwrap()
    }
    
    fn daily(id: String, workflow_id: String, hour: Int) -> Self {
        Self.new(id, workflow_id, format!("0 {} * * *", hour)).unwrap()
    }
    
    fn weekly(id: String, workflow_id: String, day: Int, hour: Int) -> Self {
        Self.new(id, workflow_id, format!("0 {} * * {}", hour, day)).unwrap()
    }
}

impl Trigger for ScheduleTrigger {
    fn id() -> String { self.id.clone() }
    fn name() -> String { format!("Schedule: {}", self.cron.to_string()) }
    fn is_active() -> Bool { self.active }
    fn activate() { self.active = true }
    fn deactivate() { self.active = false }
    
    fn check(context: TriggerContext) -> Option<TriggerEvent> {
        if !self.active { return None }
        
        let now = context.timestamp.in_timezone(self.timezone.clone())
        
        if self.cron.matches(now) {
            if let Some(last) = self.last_fired {
                if now - last < Duration.minutes(1) {
                    return None
                }
            }
            self.last_fired = Some(now)
            return Some(TriggerEvent.new(self.id.clone(), self.workflow_id.clone()))
        }
        None
    }
}

// =============================================================================
// Webhook Trigger
// =============================================================================

struct WebhookTrigger {
    id: String
    workflow_id: String
    path: String
    method: String
    secret: Option<String>
    active: Bool
    
    fn new(id: String, workflow_id: String, path: String) -> Self {
        WebhookTrigger {
            id: id,
            workflow_id: workflow_id,
            path: path,
            method: "POST",
            secret: None,
            active: true
        }
    }
    
    fn with_secret(secret: String) -> Self {
        self.secret = Some(secret)
        self
    }
    
    fn validate_request(request: WebhookRequest) -> Result<(), TriggerError> {
        if request.method != self.method {
            return Err(TriggerError.InvalidRequest("Method not allowed"))
        }
        
        if let Some(secret) = self.secret {
            let signature = request.headers.get("X-Signature").ok_or(TriggerError.Unauthorized)?
            if !verify_signature(request.body, secret, signature) {
                return Err(TriggerError.Unauthorized)
            }
        }
        Ok(())
    }
    
    fn handle(request: WebhookRequest) -> Result<TriggerEvent, TriggerError> {
        self.validate_request(request.clone())?
        
        var event = TriggerEvent.new(self.id.clone(), self.workflow_id.clone())
        event.payload = json::decode(request.body).unwrap_or(Map.empty())
        event.payload.set("_headers", request.headers)
        Ok(event)
    }
}

struct WebhookRequest {
    method: String
    path: String
    headers: Map<String, String>
    body: String
}

impl Trigger for WebhookTrigger {
    fn id() -> String { self.id.clone() }
    fn name() -> String { format!("Webhook: {}", self.path) }
    fn is_active() -> Bool { self.active }
    fn check(context: TriggerContext) -> Option<TriggerEvent> { None }
    fn activate() { self.active = true }
    fn deactivate() { self.active = false }
}

// =============================================================================
// Event Trigger
// =============================================================================

struct EventTrigger {
    id: String
    workflow_id: String
    event_type: String
    filter: Option<fn(Map<String, Any>) -> Bool>
    active: Bool
    
    fn new(id: String, workflow_id: String, event_type: String) -> Self {
        EventTrigger {
            id: id,
            workflow_id: workflow_id,
            event_type: event_type,
            filter: None,
            active: true
        }
    }
    
    fn with_filter(filter: fn(Map<String, Any>) -> Bool) -> Self {
        self.filter = Some(filter)
        self
    }
    
    fn matches(event_type: String, data: Map<String, Any>) -> Bool {
        if event_type != self.event_type { return false }
        match self.filter {
            Some(f) => f(data)
            None => true
        }
    }
}

impl Trigger for EventTrigger {
    fn id() -> String { self.id.clone() }
    fn name() -> String { format!("Event: {}", self.event_type) }
    fn is_active() -> Bool { self.active }
    fn activate() { self.active = true }
    fn deactivate() { self.active = false }
    
    fn check(context: TriggerContext) -> Option<TriggerEvent> {
        if !self.active { return None }
        
        let event_type = context.data.get("event_type")?.to_string()
        if self.matches(event_type, context.data.clone()) {
            var event = TriggerEvent.new(self.id.clone(), self.workflow_id.clone())
            event.payload = context.data
            return Some(event)
        }
        None
    }
}

// =============================================================================
// File Trigger
// =============================================================================

struct FileTrigger {
    id: String
    workflow_id: String
    path: String
    events: [FileEvent]
    pattern: Option<String>
    active: Bool
    
    fn new(id: String, workflow_id: String, path: String) -> Self {
        FileTrigger {
            id: id,
            workflow_id: workflow_id,
            path: path,
            events: [FileEvent.Created, FileEvent.Modified],
            pattern: None,
            active: true
        }
    }
    
    fn on_create(id: String, workflow_id: String, path: String) -> Self {
        var t = Self.new(id, workflow_id, path)
        t.events = [FileEvent.Created]
        t
    }
    
    fn with_pattern(pattern: String) -> Self {
        self.pattern = Some(pattern)
        self
    }
}

enum FileEvent {
    Created
    Modified
    Deleted
    Renamed
}

impl Trigger for FileTrigger {
    fn id() -> String { self.id.clone() }
    fn name() -> String { format!("File: {}", self.path) }
    fn is_active() -> Bool { self.active }
    fn activate() { self.active = true }
    fn deactivate() { self.active = false }
    
    fn check(context: TriggerContext) -> Option<TriggerEvent> {
        if !self.active { return None }
        
        let file_path = context.data.get("path")?.to_string()
        let event_type = context.data.get("event")?.to_string()
        
        if !file_path.starts_with(self.path.clone()) { return None }
        
        if let Some(pattern) = self.pattern {
            if !glob::matches(pattern, file_path.clone()) { return None }
        }
        
        var event = TriggerEvent.new(self.id.clone(), self.workflow_id.clone())
        event.payload.set("file_path", file_path)
        event.payload.set("event_type", event_type)
        Some(event)
    }
}

// =============================================================================
// Trigger Registry
// =============================================================================

actor TriggerRegistry {
    state triggers: Map<String, Box<dyn Trigger>>
    state workflow_triggers: Map<String, [String]>
    
    fn new() -> Self {
        TriggerRegistry {
            triggers: Map.empty(),
            workflow_triggers: Map.empty()
        }
    }
    
    fn register<T: Trigger>(trigger: T, workflow_id: String) {
        let id = trigger.id()
        self.triggers.set(id.clone(), Box.new(trigger))
        
        let triggers = self.workflow_triggers.entry(workflow_id).or_insert([])
        triggers.push(id)
    }
    
    fn unregister(trigger_id: String) {
        self.triggers.remove(trigger_id)
    }
    
    fn get(trigger_id: String) -> Option<Box<dyn Trigger>> {
        self.triggers.get(trigger_id)
    }
    
    fn get_for_workflow(workflow_id: String) -> [Box<dyn Trigger>] {
        self.workflow_triggers.get(workflow_id)
            .map(|ids| ids.iter().filter_map(|id| self.triggers.get(id)).collect())
            .unwrap_or([])
    }
    
    fn check_all(context: TriggerContext) -> [TriggerEvent] {
        self.triggers.values()
            .filter_map(|t| t.check(context.clone()))
            .collect()
    }
    
    fn activate(trigger_id: String) {
        if let Some(t) = self.triggers.get_mut(trigger_id) {
            t.activate()
        }
    }
    
    fn deactivate(trigger_id: String) {
        if let Some(t) = self.triggers.get_mut(trigger_id) {
            t.deactivate()
        }
    }
}

// =============================================================================
// Errors & Helpers
// =============================================================================

enum TriggerError {
    InvalidConfig(String)
    InvalidRequest(String)
    Unauthorized
    NotFound
}

fn verify_signature(body: String, secret: String, signature: String) -> Bool {
    let expected = crypto::hmac_sha256(secret, body)
    crypto::constant_time_compare(expected, signature)
}

// =============================================================================
// Tests
// =============================================================================

test "manual trigger" {
    let trigger = ManualTrigger.new("t1", "wf1")
    let event = trigger.fire(Map.from([("key", "value")]))
    assert_eq(event.workflow_id, "wf1")?
}

test "schedule trigger" {
    let trigger = ScheduleTrigger.daily("t1", "wf1", 9)?
    assert(trigger.is_active())?
}

test "event trigger" {
    let trigger = EventTrigger.new("t1", "wf1", "user.created")
    assert(trigger.matches("user.created", Map.empty()))?
    assert(!trigger.matches("user.deleted", Map.empty()))?
}

test "trigger registry" {
    let registry = TriggerRegistry.new()
    let trigger = ManualTrigger.new("t1", "wf1")
    registry.register(trigger, "wf1")
    
    assert(registry.get("t1").is_some())?
    assert_eq(registry.get_for_workflow("wf1").len(), 1)?
}
