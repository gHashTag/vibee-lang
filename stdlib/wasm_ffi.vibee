// =============================================================================
// Vibee OS â€” WebAssembly FFI Module
// WebAssembly Foreign Function Interface
// =============================================================================

// =============================================================================
// WASM Types
// =============================================================================

/// WASM value types
enum WasmType { I32, I64, F32, F64, V128, FuncRef, ExternRef }

/// WASM value
enum WasmValue {
    I32(Int32)
    I64(Int64)
    F32(Float32)
    F64(Float64)
    V128([UInt8; 16])
    FuncRef(Option<WasmFunc>)
    ExternRef(Option<*()>)
}

impl WasmValue {
    fn as_i32() -> Option<Int32> { match self { I32(v) => Some(v), _ => None } }
    fn as_i64() -> Option<Int64> { match self { I64(v) => Some(v), _ => None } }
    fn as_f32() -> Option<Float32> { match self { F32(v) => Some(v), _ => None } }
    fn as_f64() -> Option<Float64> { match self { F64(v) => Some(v), _ => None } }
    fn get_type() -> WasmType {
        match self { I32(_) => WasmType.I32, I64(_) => WasmType.I64, F32(_) => WasmType.F32, F64(_) => WasmType.F64, V128(_) => WasmType.V128, FuncRef(_) => WasmType.FuncRef, ExternRef(_) => WasmType.ExternRef }
    }
}

// =============================================================================
// WASM Module
// =============================================================================

/// WASM module
struct WasmModule { handle: *(), bytes: [UInt8] }

impl WasmModule {
    fn from_bytes(bytes: [UInt8]) -> Result<Self, WasmError> {
        if !Self.validate(bytes) { return Err(WasmError.InvalidModule) }
        let handle = @native("wasm_module_new", bytes.as_ptr(), bytes.len())
        if handle.is_null() { return Err(WasmError.CompilationFailed) }
        Ok(WasmModule { handle: handle, bytes: bytes })
    }
    
    fn from_file(path: String) -> Result<Self, WasmError> {
        let bytes = @native("fs_read_bytes", path).map_err(|_| WasmError.IoError)?
        Self.from_bytes(bytes)
    }
    
    fn validate(bytes: [UInt8]) -> Bool {
        bytes.len() >= 8 && bytes[0..4] == [0x00, 0x61, 0x73, 0x6D]
    }
    
    fn exports() -> [WasmExport] { @native("wasm_module_exports", self.handle) }
    fn imports() -> [WasmImport] { @native("wasm_module_imports", self.handle) }
}

impl Drop for WasmModule {
    fn drop() { if !self.handle.is_null() { @native("wasm_module_delete", self.handle) } }
}

// =============================================================================
// WASM Instance
// =============================================================================

/// WASM instance
struct WasmInstance { handle: *(), module: WasmModule, memory: Option<WasmMemory> }

impl WasmInstance {
    fn new(module: WasmModule, imports: WasmImports) -> Result<Self, WasmError> {
        let handle = @native("wasm_instance_new", module.handle, imports.handle)
        if handle.is_null() { return Err(WasmError.InstantiationFailed) }
        let memory = @native("wasm_instance_get_memory", handle).map(|h| WasmMemory { handle: h })
        Ok(WasmInstance { handle: handle, module: module, memory: memory })
    }
    
    fn get_func(name: String) -> Option<WasmFunc> {
        let h = @native("wasm_instance_get_func", self.handle, name)
        if h.is_null() { None } else { Some(WasmFunc { handle: h, name: name }) }
    }
    
    fn get_global(name: String) -> Option<WasmGlobal> {
        let h = @native("wasm_instance_get_global", self.handle, name)
        if h.is_null() { None } else { Some(WasmGlobal { handle: h }) }
    }
    
    fn get_memory(name: String) -> Option<WasmMemory> {
        let h = @native("wasm_instance_get_memory_by_name", self.handle, name)
        if h.is_null() { None } else { Some(WasmMemory { handle: h }) }
    }
    
    fn call(name: String, args: [WasmValue]) -> Result<[WasmValue], WasmError> {
        let func = self.get_func(name).ok_or(WasmError.FunctionNotFound(name))?
        func.call(args)
    }
}

impl Drop for WasmInstance {
    fn drop() { if !self.handle.is_null() { @native("wasm_instance_delete", self.handle) } }
}

// =============================================================================
// WASM Function
// =============================================================================

struct WasmFunc { handle: *(), name: String }

impl WasmFunc {
    fn call(args: [WasmValue]) -> Result<[WasmValue], WasmError> {
        @native("wasm_func_call", self.handle, args).map_err(|e| WasmError.Trap(e))
    }
    
    fn param_types() -> [WasmType] { @native("wasm_func_param_types", self.handle) }
    fn result_types() -> [WasmType] { @native("wasm_func_result_types", self.handle) }
}

// =============================================================================
// WASM Memory
// =============================================================================

struct WasmMemory { handle: *() }

impl WasmMemory {
    fn new(min_pages: Int, max_pages: Option<Int>) -> Result<Self, WasmError> {
        let h = @native("wasm_memory_new", min_pages, max_pages.unwrap_or(-1))
        if h.is_null() { Err(WasmError.MemoryAllocationFailed) } else { Ok(WasmMemory { handle: h }) }
    }
    
    fn size() -> Int { @native("wasm_memory_size", self.handle) }
    fn grow(pages: Int) -> Result<Int, WasmError> {
        let old = @native("wasm_memory_grow", self.handle, pages)
        if old < 0 { Err(WasmError.MemoryGrowFailed) } else { Ok(old) }
    }
    
    fn read(offset: Int, len: Int) -> [UInt8] { @native("wasm_memory_read", self.handle, offset, len) }
    fn write(offset: Int, data: [UInt8]) { @native("wasm_memory_write", self.handle, offset, data) }
    fn read_i32(offset: Int) -> Int32 { @native("wasm_memory_read_i32", self.handle, offset) }
    fn write_i32(offset: Int, value: Int32) { @native("wasm_memory_write_i32", self.handle, offset, value) }
    fn read_string(offset: Int, len: Int) -> Result<String, WasmError> {
        String.from_utf8(self.read(offset, len)).map_err(|_| WasmError.InvalidUtf8)
    }
}

// =============================================================================
// WASM Global
// =============================================================================

struct WasmGlobal { handle: *() }

impl WasmGlobal {
    fn get() -> WasmValue { @native("wasm_global_get", self.handle) }
    fn set(value: WasmValue) -> Result<(), WasmError> {
        if !@native("wasm_global_is_mutable", self.handle) { return Err(WasmError.ImmutableGlobal) }
        @native("wasm_global_set", self.handle, value)
        Ok(())
    }
}

// =============================================================================
// WASM Imports/Exports
// =============================================================================

struct WasmImport { module: String, name: String, kind: WasmExternKind }
struct WasmExport { name: String, kind: WasmExternKind }
enum WasmExternKind { Func, Global, Memory, Table }

struct WasmImports { handle: *(), items: [(String, String, WasmExtern)] }

impl WasmImports {
    fn new() -> Self { WasmImports { handle: @native("wasm_imports_new"), items: [] } }
    fn add_func(module: String, name: String, func: WasmHostFunc) -> Self {
        @native("wasm_imports_add_func", self.handle, module, name, func.handle)
        self.items.push((module, name, WasmExtern.Func(func)))
        self
    }
    fn add_memory(module: String, name: String, memory: WasmMemory) -> Self {
        @native("wasm_imports_add_memory", self.handle, module, name, memory.handle)
        self.items.push((module, name, WasmExtern.Memory(memory)))
        self
    }
}

enum WasmExtern { Func(WasmHostFunc), Global(WasmGlobal), Memory(WasmMemory), Table(WasmTable) }

// =============================================================================
// Host Functions
// =============================================================================

struct WasmHostFunc { handle: *() }

impl WasmHostFunc {
    fn new<F>(params: [WasmType], results: [WasmType], f: F) -> Self 
    where F: Fn([WasmValue]) -> Result<[WasmValue], String> {
        let handle = @native("wasm_host_func_new", params, results, f)
        WasmHostFunc { handle: handle }
    }
}

// =============================================================================
// WASM Table
// =============================================================================

struct WasmTable { handle: *() }

impl WasmTable {
    fn new(elem_type: WasmType, min: Int, max: Option<Int>) -> Result<Self, WasmError> {
        let h = @native("wasm_table_new", elem_type, min, max.unwrap_or(-1))
        if h.is_null() { Err(WasmError.TableCreationFailed) } else { Ok(WasmTable { handle: h }) }
    }
    fn size() -> Int { @native("wasm_table_size", self.handle) }
    fn get(index: Int) -> Option<WasmValue> { @native("wasm_table_get", self.handle, index) }
    fn set(index: Int, value: WasmValue) -> Result<(), WasmError> {
        if !@native("wasm_table_set", self.handle, index, value) { Err(WasmError.TableAccessError) } else { Ok(()) }
    }
}

// =============================================================================
// WASM Engine & Store
// =============================================================================

struct WasmEngine { handle: *() }
impl WasmEngine {
    fn new() -> Self { WasmEngine { handle: @native("wasm_engine_new") } }
}
impl Drop for WasmEngine {
    fn drop() { @native("wasm_engine_delete", self.handle) }
}

struct WasmStore { handle: *(), engine: WasmEngine }
impl WasmStore {
    fn new(engine: WasmEngine) -> Self {
        WasmStore { handle: @native("wasm_store_new", engine.handle), engine: engine }
    }
}

// =============================================================================
// Error Types
// =============================================================================

enum WasmError {
    InvalidModule
    CompilationFailed
    InstantiationFailed
    FunctionNotFound(String)
    Trap(String)
    MemoryAllocationFailed
    MemoryGrowFailed
    InvalidUtf8
    ImmutableGlobal
    TableCreationFailed
    TableAccessError
    IoError
    Other(String)
}

impl Display for WasmError {
    fn fmt(f: Formatter) {
        match self {
            InvalidModule => f.write("Invalid WASM module")
            CompilationFailed => f.write("WASM compilation failed")
            FunctionNotFound(n) => f.write(format!("Function not found: {}", n))
            Trap(s) => f.write(format!("WASM trap: {}", s))
            _ => f.write("WASM error")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "wasm value types" {
    let v = WasmValue.I32(42)
    assert_eq(v.as_i32(), Some(42))?
    assert_eq(v.get_type(), WasmType.I32)?
}

test "wasm module validation" {
    let valid = [0x00, 0x61, 0x73, 0x6D, 0x01, 0x00, 0x00, 0x00]
    assert(WasmModule.validate(valid))?
    let invalid = [0x00, 0x00, 0x00, 0x00]
    assert(!WasmModule.validate(invalid))?
}
