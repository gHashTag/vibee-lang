// =============================================================================
// Vibee OS â€” Event Dispatcher Module
// Event dispatching, routing, and command handling
// =============================================================================

use result::{Result, Ok, Err}
use emitter::{Event, EventMeta, EventPriority}
use listener::{Listener, Subscription}

// =============================================================================
// Core Types
// =============================================================================

/// Dispatch result
enum DispatchResult<T> {
    Handled(T),
    NotHandled,
    Error(Error)
}

impl<T> DispatchResult<T> {
    fn is_handled() -> Bool {
        match self {
            DispatchResult.Handled(_) => true,
            _ => false
        }
    }
    
    fn unwrap() -> T {
        match self {
            DispatchResult.Handled(v) => v,
            DispatchResult.NotHandled => panic("Dispatch not handled"),
            DispatchResult.Error(e) => panic(format!("Dispatch error: {}", e))
        }
    }
    
    fn ok() -> Option<T> {
        match self {
            DispatchResult.Handled(v) => Some(v),
            _ => None
        }
    }
}

/// Dispatch strategy
enum DispatchStrategy {
    /// First matching handler wins
    FirstMatch,
    /// All matching handlers are called
    Broadcast,
    /// Round-robin among handlers
    RoundRobin,
    /// Random handler selection
    Random,
    /// Priority-based selection
    Priority
}

/// Handler priority
struct HandlerPriority {
    value: Int
}

impl HandlerPriority {
    fn lowest() -> Self { HandlerPriority { value: 0 } }
    fn low() -> Self { HandlerPriority { value: 25 } }
    fn normal() -> Self { HandlerPriority { value: 50 } }
    fn high() -> Self { HandlerPriority { value: 75 } }
    fn highest() -> Self { HandlerPriority { value: 100 } }
    fn custom(value: Int) -> Self { HandlerPriority { value: value.clamp(0, 100) } }
}

// =============================================================================
// Dispatcher Trait
// =============================================================================

/// Core dispatcher trait
trait Dispatcher {
    type Event
    type Result
    
    fn dispatch(event: Self.Event) -> DispatchResult<Self.Result>
    fn can_handle(event: Self.Event) -> Bool
}

/// Async dispatcher trait
trait AsyncDispatcher {
    type Event
    type Result
    
    fn dispatch(event: Self.Event) -> Future<DispatchResult<Self.Result>>
    fn can_handle(event: Self.Event) -> Bool
}

// =============================================================================
// Event Dispatcher
// =============================================================================

/// Handler registration
struct HandlerRegistration<E, R> {
    id: Int,
    pattern: String,
    handler: fn(E) -> R,
    priority: HandlerPriority,
    active: Bool
}

/// Main event dispatcher
actor EventDispatcher<E, R> {
    state handlers: [HandlerRegistration<E, R>]
    state next_id: Int
    state strategy: DispatchStrategy
    state round_robin_index: Int
    state middleware: [fn(E) -> Option<E>]
    state error_handler: Option<fn(Error)>
    
    fn new() -> Self {
        EventDispatcher {
            handlers: [],
            next_id: 0,
            strategy: DispatchStrategy.FirstMatch,
            round_robin_index: 0,
            middleware: [],
            error_handler: None
        }
    }
    
    fn with_strategy(strategy: DispatchStrategy) -> Self {
        EventDispatcher {
            handlers: [],
            next_id: 0,
            strategy: strategy,
            round_robin_index: 0,
            middleware: [],
            error_handler: None
        }
    }
    
    fn register(pattern: String, handler: fn(E) -> R) -> Int {
        self.register_with_priority(pattern, handler, HandlerPriority.normal())
    }
    
    fn register_with_priority(pattern: String, handler: fn(E) -> R, priority: HandlerPriority) -> Int {
        let id = self.next_id
        self.next_id += 1
        
        let reg = HandlerRegistration {
            id: id,
            pattern: pattern,
            handler: handler,
            priority: priority,
            active: true
        }
        
        // Insert sorted by priority (higher first)
        var inserted = false
        for (i, h) in self.handlers.iter().enumerate() {
            if priority.value > h.priority.value {
                self.handlers.insert(i, reg)
                inserted = true
                break
            }
        }
        if !inserted {
            self.handlers.push(reg)
        }
        
        id
    }
    
    fn unregister(id: Int) -> Bool {
        for (i, h) in self.handlers.iter().enumerate() {
            if h.id == id {
                self.handlers.remove(i)
                return true
            }
        }
        false
    }
    
    fn set_active(id: Int, active: Bool) {
        for h in self.handlers.iter_mut() {
            if h.id == id {
                h.active = active
                break
            }
        }
    }
    
    fn add_middleware(mw: fn(E) -> Option<E>) {
        self.middleware.push(mw)
    }
    
    fn set_error_handler(handler: fn(Error)) {
        self.error_handler = Some(handler)
    }
    
    fn dispatch(event: E) -> DispatchResult<R> {
        // Apply middleware
        var processed_event = event
        for mw in self.middleware.iter() {
            match mw(processed_event) {
                Some(e) => processed_event = e,
                None => return DispatchResult.NotHandled
            }
        }
        
        match self.strategy {
            DispatchStrategy.FirstMatch => self.dispatch_first_match(processed_event),
            DispatchStrategy.Broadcast => self.dispatch_broadcast(processed_event),
            DispatchStrategy.RoundRobin => self.dispatch_round_robin(processed_event),
            DispatchStrategy.Random => self.dispatch_random(processed_event),
            DispatchStrategy.Priority => self.dispatch_first_match(processed_event) // Already sorted
        }
    }
    
    fn dispatch_first_match(event: E) -> DispatchResult<R> {
        for h in self.handlers.iter() {
            if h.active && self.matches_pattern(event, h.pattern) {
                let result = (h.handler)(event)
                return DispatchResult.Handled(result)
            }
        }
        DispatchResult.NotHandled
    }
    
    fn dispatch_broadcast(event: E) -> DispatchResult<R> where E: Clone {
        var last_result: Option<R> = None
        
        for h in self.handlers.iter() {
            if h.active && self.matches_pattern(event, h.pattern) {
                last_result = Some((h.handler)(event.clone()))
            }
        }
        
        match last_result {
            Some(r) => DispatchResult.Handled(r),
            None => DispatchResult.NotHandled
        }
    }
    
    fn dispatch_round_robin(event: E) -> DispatchResult<R> {
        let active_handlers: [_] = self.handlers.iter()
            .filter(|h| h.active && self.matches_pattern(event, h.pattern))
            .collect()
        
        if active_handlers.is_empty() {
            return DispatchResult.NotHandled
        }
        
        let idx = self.round_robin_index % active_handlers.len()
        self.round_robin_index += 1
        
        let result = (active_handlers[idx].handler)(event)
        DispatchResult.Handled(result)
    }
    
    fn dispatch_random(event: E) -> DispatchResult<R> {
        let active_handlers: [_] = self.handlers.iter()
            .filter(|h| h.active && self.matches_pattern(event, h.pattern))
            .collect()
        
        if active_handlers.is_empty() {
            return DispatchResult.NotHandled
        }
        
        let idx = @native("random_int", 0, active_handlers.len())
        let result = (active_handlers[idx].handler)(event)
        DispatchResult.Handled(result)
    }
    
    fn matches_pattern(event: E, pattern: String) -> Bool {
        // Default implementation - override for custom matching
        pattern == "*"
    }
    
    fn can_handle(event: E) -> Bool {
        self.handlers.iter().any(|h| h.active && self.matches_pattern(event, h.pattern))
    }
    
    fn handler_count() -> Int {
        self.handlers.len()
    }
    
    fn active_handler_count() -> Int {
        self.handlers.iter().filter(|h| h.active).count()
    }
}

// =============================================================================
// Command Dispatcher
// =============================================================================

/// Command trait
trait Command {
    type Result
    fn name() -> String
}

/// Command handler trait
trait CommandHandler<C: Command> {
    fn handle(cmd: C) -> C.Result
}

/// Command dispatcher for CQRS pattern
actor CommandDispatcher {
    state handlers: Map<String, fn(Any) -> Any>
    state middleware: [fn(String, Any) -> Option<Any>]
    state validators: Map<String, fn(Any) -> Result<(), Error>>
    
    fn new() -> Self {
        CommandDispatcher {
            handlers: Map.new(),
            middleware: [],
            validators: Map.new()
        }
    }
    
    fn register<C: Command>(handler: fn(C) -> C.Result) {
        let name = C.name()
        self.handlers.insert(name, |cmd| {
            let typed_cmd = cmd as C
            handler(typed_cmd) as Any
        })
    }
    
    fn register_validator<C: Command>(validator: fn(C) -> Result<(), Error>) {
        let name = C.name()
        self.validators.insert(name, |cmd| {
            let typed_cmd = cmd as C
            validator(typed_cmd)
        })
    }
    
    fn add_middleware(mw: fn(String, Any) -> Option<Any>) {
        self.middleware.push(mw)
    }
    
    fn dispatch<C: Command>(cmd: C) -> Result<C.Result, Error> {
        let name = C.name()
        
        // Validate
        if let Some(validator) = self.validators.get(name) {
            validator(cmd as Any)?
        }
        
        // Apply middleware
        var processed: Any = cmd as Any
        for mw in self.middleware.iter() {
            match mw(name.clone(), processed) {
                Some(p) => processed = p,
                None => return Err(Error.new("Command rejected by middleware"))
            }
        }
        
        // Dispatch
        match self.handlers.get(name) {
            Some(handler) => {
                let result = handler(processed)
                Ok(result as C.Result)
            },
            None => Err(Error.new(format!("No handler for command: {}", name)))
        }
    }
    
    fn can_handle<C: Command>() -> Bool {
        self.handlers.contains_key(C.name())
    }
}

// =============================================================================
// Query Dispatcher
// =============================================================================

/// Query trait
trait Query {
    type Result
    fn name() -> String
}

/// Query handler trait
trait QueryHandler<Q: Query> {
    fn handle(query: Q) -> Q.Result
}

/// Query dispatcher for CQRS pattern
actor QueryDispatcher {
    state handlers: Map<String, fn(Any) -> Any>
    state cache: Option<Map<String, (Any, Int64)>>
    state cache_ttl_ms: Int64
    
    fn new() -> Self {
        QueryDispatcher {
            handlers: Map.new(),
            cache: None,
            cache_ttl_ms: 0
        }
    }
    
    fn with_cache(ttl_ms: Int64) -> Self {
        QueryDispatcher {
            handlers: Map.new(),
            cache: Some(Map.new()),
            cache_ttl_ms: ttl_ms
        }
    }
    
    fn register<Q: Query>(handler: fn(Q) -> Q.Result) {
        let name = Q.name()
        self.handlers.insert(name, |query| {
            let typed_query = query as Q
            handler(typed_query) as Any
        })
    }
    
    fn dispatch<Q: Query>(query: Q) -> Result<Q.Result, Error> {
        let name = Q.name()
        let cache_key = format!("{}:{:?}", name, query)
        
        // Check cache
        if let Some(ref cache) = self.cache {
            if let Some((cached, timestamp)) = cache.get(cache_key) {
                let now = @native("timestamp_ms")
                if now - timestamp < self.cache_ttl_ms {
                    return Ok(cached.clone() as Q.Result)
                }
            }
        }
        
        // Execute query
        match self.handlers.get(name) {
            Some(handler) => {
                let result = handler(query as Any)
                
                // Cache result
                if let Some(ref mut cache) = self.cache {
                    cache.insert(cache_key, (result.clone(), @native("timestamp_ms")))
                }
                
                Ok(result as Q.Result)
            },
            None => Err(Error.new(format!("No handler for query: {}", name)))
        }
    }
    
    fn invalidate_cache() {
        if let Some(ref mut cache) = self.cache {
            cache.clear()
        }
    }
    
    fn invalidate_cache_for<Q: Query>() {
        if let Some(ref mut cache) = self.cache {
            let prefix = format!("{}:", Q.name())
            let keys_to_remove: [String] = cache.keys()
                .filter(|k| k.starts_with(prefix))
                .collect()
            for key in keys_to_remove {
                cache.remove(key)
            }
        }
    }
}

// =============================================================================
// Message Dispatcher
// =============================================================================

/// Message envelope
struct MessageEnvelope<T> {
    id: String,
    payload: T,
    headers: Map<String, String>,
    timestamp: Int64,
    reply_to: Option<String>
}

impl<T> MessageEnvelope<T> {
    fn new(payload: T) -> Self {
        MessageEnvelope {
            id: @native("uuid_v4"),
            payload: payload,
            headers: Map.new(),
            timestamp: @native("timestamp_ms"),
            reply_to: None
        }
    }
    
    fn with_reply_to(payload: T, reply_to: String) -> Self {
        MessageEnvelope {
            id: @native("uuid_v4"),
            payload: payload,
            headers: Map.new(),
            timestamp: @native("timestamp_ms"),
            reply_to: Some(reply_to)
        }
    }
    
    fn add_header(key: String, value: String) -> Self {
        self.headers.insert(key, value)
        self
    }
}

/// Message dispatcher with routing
actor MessageDispatcher<T> {
    state routes: Map<String, fn(MessageEnvelope<T>)>
    state default_handler: Option<fn(MessageEnvelope<T>)>
    state dead_letter_handler: Option<fn(MessageEnvelope<T>)>
    state interceptors: [fn(MessageEnvelope<T>) -> Option<MessageEnvelope<T>>]
    
    fn new() -> Self {
        MessageDispatcher {
            routes: Map.new(),
            default_handler: None,
            dead_letter_handler: None,
            interceptors: []
        }
    }
    
    fn route(pattern: String, handler: fn(MessageEnvelope<T>)) {
        self.routes.insert(pattern, handler)
    }
    
    fn set_default_handler(handler: fn(MessageEnvelope<T>)) {
        self.default_handler = Some(handler)
    }
    
    fn set_dead_letter_handler(handler: fn(MessageEnvelope<T>)) {
        self.dead_letter_handler = Some(handler)
    }
    
    fn add_interceptor(interceptor: fn(MessageEnvelope<T>) -> Option<MessageEnvelope<T>>) {
        self.interceptors.push(interceptor)
    }
    
    fn dispatch(route: String, message: MessageEnvelope<T>) {
        // Apply interceptors
        var processed = message
        for interceptor in self.interceptors.iter() {
            match interceptor(processed) {
                Some(m) => processed = m,
                None => {
                    // Message was filtered out
                    if let Some(dlh) = self.dead_letter_handler {
                        dlh(message)
                    }
                    return
                }
            }
        }
        
        // Find matching route
        if let Some(handler) = self.routes.get(route) {
            handler(processed)
        } else if let Some(default) = self.default_handler {
            default(processed)
        } else if let Some(dlh) = self.dead_letter_handler {
            dlh(processed)
        }
    }
    
    fn dispatch_to_all(message: MessageEnvelope<T>) where T: Clone {
        for (_, handler) in self.routes.iter() {
            handler(message.clone())
        }
    }
}

// =============================================================================
// Async Event Dispatcher
// =============================================================================

/// Async event dispatcher
actor AsyncEventDispatcher<E, R> {
    state handlers: Map<String, fn(E) -> Future<R>>
    state timeout_ms: Int64
    
    fn new() -> Self {
        AsyncEventDispatcher {
            handlers: Map.new(),
            timeout_ms: 30000
        }
    }
    
    fn with_timeout(timeout_ms: Int64) -> Self {
        AsyncEventDispatcher {
            handlers: Map.new(),
            timeout_ms: timeout_ms
        }
    }
    
    fn register(pattern: String, handler: fn(E) -> Future<R>) {
        self.handlers.insert(pattern, handler)
    }
    
    fn dispatch(pattern: String, event: E) -> Future<DispatchResult<R>> {
        async {
            match self.handlers.get(pattern) {
                Some(handler) => {
                    let result = handler(event)
                        .timeout(self.timeout_ms)
                        .await
                    
                    match result {
                        Some(r) => DispatchResult.Handled(r),
                        None => DispatchResult.Error(Error.new("Handler timeout"))
                    }
                },
                None => DispatchResult.NotHandled
            }
        }
    }
    
    fn dispatch_all(event: E) -> Future<[DispatchResult<R>]> where E: Clone {
        async {
            var futures = []
            for (pattern, handler) in self.handlers.iter() {
                futures.push(handler(event.clone()).timeout(self.timeout_ms))
            }
            
            let results = Future.join_all(futures).await
            results.iter().map(|r| {
                match r {
                    Some(v) => DispatchResult.Handled(v),
                    None => DispatchResult.Error(Error.new("Handler timeout"))
                }
            }).collect()
        }
    }
}

// =============================================================================
// Dispatcher Chain
// =============================================================================

/// Chain of dispatchers - tries each until one handles
struct DispatcherChain<E, R> {
    dispatchers: [impl Dispatcher<Event = E, Result = R>]
}

impl<E: Clone, R> DispatcherChain<E, R> {
    fn new() -> Self {
        DispatcherChain { dispatchers: [] }
    }
    
    fn add(dispatcher: impl Dispatcher<Event = E, Result = R>) -> Self {
        self.dispatchers.push(dispatcher)
        self
    }
    
    fn dispatch(event: E) -> DispatchResult<R> {
        for d in self.dispatchers.iter() {
            match d.dispatch(event.clone()) {
                DispatchResult.Handled(r) => return DispatchResult.Handled(r),
                _ => continue
            }
        }
        DispatchResult.NotHandled
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Create an event dispatcher
fn dispatcher<E, R>() -> EventDispatcher<E, R> {
    EventDispatcher.new()
}

/// Create a command dispatcher
fn command_dispatcher() -> CommandDispatcher {
    CommandDispatcher.new()
}

/// Create a query dispatcher
fn query_dispatcher() -> QueryDispatcher {
    QueryDispatcher.new()
}

/// Create a message dispatcher
fn message_dispatcher<T>() -> MessageDispatcher<T> {
    MessageDispatcher.new()
}

/// Create an async dispatcher
fn async_dispatcher<E, R>() -> AsyncEventDispatcher<E, R> {
    AsyncEventDispatcher.new()
}

// =============================================================================
// Tests
// =============================================================================

test "basic dispatch" {
    let d = EventDispatcher::<Int, String>.with_strategy(DispatchStrategy.FirstMatch)
    
    d.register("*", |n| format!("Got: {}", n))
    
    let result = d.dispatch(42)
    assert(result.is_handled())?
    assert_eq(result.unwrap(), "Got: 42")?
}

test "dispatch not handled" {
    let d = EventDispatcher::<Int, String>.new()
    
    let result = d.dispatch(42)
    assert(!result.is_handled())?
}

test "priority dispatch" {
    let d = EventDispatcher::<Int, Int>.with_strategy(DispatchStrategy.FirstMatch)
    
    d.register_with_priority("*", |n| n * 2, HandlerPriority.low())
    d.register_with_priority("*", |n| n * 3, HandlerPriority.high())
    
    let result = d.dispatch(10)
    assert_eq(result.unwrap(), 30)? // High priority handler runs first
}

test "round robin dispatch" {
    let d = EventDispatcher::<Int, Int>.with_strategy(DispatchStrategy.RoundRobin)
    
    d.register("*", |n| n * 1)
    d.register("*", |n| n * 2)
    d.register("*", |n| n * 3)
    
    let r1 = d.dispatch(10).unwrap()
    let r2 = d.dispatch(10).unwrap()
    let r3 = d.dispatch(10).unwrap()
    let r4 = d.dispatch(10).unwrap()
    
    assert_eq(r1, 10)?
    assert_eq(r2, 20)?
    assert_eq(r3, 30)?
    assert_eq(r4, 10)? // Wraps around
}

test "middleware" {
    let d = EventDispatcher::<Int, Int>.new()
    
    d.add_middleware(|n| if n > 0 { Some(n * 2) } else { None })
    d.register("*", |n| n + 1)
    
    let r1 = d.dispatch(5)
    assert_eq(r1.unwrap(), 11)? // (5 * 2) + 1
    
    let r2 = d.dispatch(-1)
    assert(!r2.is_handled())? // Filtered by middleware
}

test "handler activation" {
    let d = EventDispatcher::<Int, Int>.new()
    
    let id = d.register("*", |n| n * 2)
    
    assert_eq(d.dispatch(5).unwrap(), 10)?
    
    d.set_active(id, false)
    assert(!d.dispatch(5).is_handled())?
    
    d.set_active(id, true)
    assert_eq(d.dispatch(5).unwrap(), 10)?
}

test "message envelope" {
    let msg = MessageEnvelope.new("Hello")
        .add_header("type", "greeting")
    
    assert_eq(msg.payload, "Hello")?
    assert_eq(msg.headers.get("type"), Some("greeting"))?
}

test "message dispatcher routing" {
    let d = MessageDispatcher::<String>.new()
    var received = []
    
    d.route("users", |msg| { received.push(("users", msg.payload.clone())) })
    d.route("orders", |msg| { received.push(("orders", msg.payload.clone())) })
    
    d.dispatch("users", MessageEnvelope.new("user1"))
    d.dispatch("orders", MessageEnvelope.new("order1"))
    
    assert_eq(received, [("users", "user1"), ("orders", "order1")])?
}

test "dispatcher chain" {
    let chain = DispatcherChain::<Int, String>.new()
    
    let d1 = EventDispatcher.new()
    d1.register("*", |n: Int| if n > 10 { format!("d1: {}", n) } else { panic("skip") })
    
    let d2 = EventDispatcher.new()
    d2.register("*", |n: Int| format!("d2: {}", n))
    
    // Note: This is a simplified test - real implementation would need proper error handling
}
