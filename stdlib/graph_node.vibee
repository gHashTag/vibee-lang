// =============================================================================
// Vibee OS â€” Graph Node Module
// Node structures and operations for graphs
// =============================================================================

/// Node identifier type
type NodeId = Int

/// Generic graph node with data
struct Node<T> {
    id: NodeId
    data: T
    metadata: NodeMetadata
    
    fn new(id: NodeId, data: T) -> Self {
        Node { id: id, data: data, metadata: NodeMetadata.default() }
    }
    
    fn with_metadata(id: NodeId, data: T, metadata: NodeMetadata) -> Self {
        Node { id: id, data: data, metadata: metadata }
    }
    
    fn id() -> NodeId { self.id }
    fn data() -> T { self.data.clone() }
    fn data_ref() -> &T { &self.data }
    fn data_mut() -> &mut T { &mut self.data }
    fn set_data(data: T) { self.data = data }
    
    fn label() -> Option<String> { self.metadata.label.clone() }
    fn set_label(label: String) { self.metadata.label = Some(label) }
    
    fn weight() -> Float { self.metadata.weight }
    fn set_weight(weight: Float) { self.metadata.weight = weight }
}

/// Node metadata for additional properties
struct NodeMetadata {
    label: Option<String>
    weight: Float
    color: Option<String>
    position: Option<(Float, Float)>
    attributes: Map<String, String>
    created_at: Option<Int>
    
    fn default() -> Self {
        NodeMetadata {
            label: None,
            weight: 1.0,
            color: None,
            position: None,
            attributes: Map.empty(),
            created_at: None
        }
    }
    
    fn with_label(label: String) -> Self {
        var m = Self.default()
        m.label = Some(label)
        m
    }
    
    fn with_weight(weight: Float) -> Self {
        var m = Self.default()
        m.weight = weight
        m
    }
    
    fn with_position(x: Float, y: Float) -> Self {
        var m = Self.default()
        m.position = Some((x, y))
        m
    }
    
    fn set_attribute(key: String, value: String) {
        self.attributes.set(key, value)
    }
    
    fn get_attribute(key: String) -> Option<String> {
        self.attributes.get(key).cloned()
    }
    
    fn remove_attribute(key: String) -> Option<String> {
        self.attributes.remove(key)
    }
}

/// Node state for graph algorithms
enum NodeState {
    Unvisited
    Visiting
    Visited
}

impl NodeState {
    fn is_unvisited() -> Bool { matches!(self, NodeState.Unvisited) }
    fn is_visiting() -> Bool { matches!(self, NodeState.Visiting) }
    fn is_visited() -> Bool { matches!(self, NodeState.Visited) }
}

/// Node with algorithm-specific data
struct AlgorithmNode<T> {
    node: Node<T>
    state: NodeState
    distance: Float
    predecessor: Option<NodeId>
    discovery_time: Option<Int>
    finish_time: Option<Int>
    
    fn new(node: Node<T>) -> Self {
        AlgorithmNode {
            node: node,
            state: NodeState.Unvisited,
            distance: Float.INFINITY,
            predecessor: None,
            discovery_time: None,
            finish_time: None
        }
    }
    
    fn reset() {
        self.state = NodeState.Unvisited
        self.distance = Float.INFINITY
        self.predecessor = None
        self.discovery_time = None
        self.finish_time = None
    }
    
    fn mark_visiting(time: Int) {
        self.state = NodeState.Visiting
        self.discovery_time = Some(time)
    }
    
    fn mark_visited(time: Int) {
        self.state = NodeState.Visited
        self.finish_time = Some(time)
    }
    
    fn update_distance(dist: Float, pred: NodeId) -> Bool {
        if dist < self.distance {
            self.distance = dist
            self.predecessor = Some(pred)
            true
        } else {
            false
        }
    }
}

/// Trait for node types
trait GraphNode {
    type Data
    
    fn id() -> NodeId
    fn data() -> Self.Data
}

impl<T> GraphNode for Node<T> {
    type Data = T
    
    fn id() -> NodeId { self.id }
    fn data() -> T { self.data.clone() }
}

/// Node collection for efficient operations
struct NodeCollection<T> {
    nodes: Map<NodeId, Node<T>>
    next_id: NodeId
    
    fn new() -> Self {
        NodeCollection { nodes: Map.empty(), next_id: 0 }
    }
    
    fn add(data: T) -> NodeId {
        let id = self.next_id
        self.next_id += 1
        self.nodes.set(id, Node.new(id, data))
        id
    }
    
    fn add_with_id(id: NodeId, data: T) -> Bool {
        if self.nodes.contains(id) { return false }
        self.nodes.set(id, Node.new(id, data))
        if id >= self.next_id { self.next_id = id + 1 }
        true
    }
    
    fn get(id: NodeId) -> Option<Node<T>> {
        self.nodes.get(id).cloned()
    }
    
    fn get_mut(id: NodeId) -> Option<&mut Node<T>> {
        self.nodes.get_mut(id)
    }
    
    fn remove(id: NodeId) -> Option<Node<T>> {
        self.nodes.remove(id)
    }
    
    fn contains(id: NodeId) -> Bool {
        self.nodes.contains(id)
    }
    
    fn len() -> Int { self.nodes.len() }
    fn is_empty() -> Bool { self.nodes.is_empty() }
    
    fn ids() -> [NodeId] {
        self.nodes.keys().collect()
    }
    
    fn iter() -> impl Iterator<Item = (NodeId, Node<T>)> {
        self.nodes.iter()
    }
    
    fn values() -> impl Iterator<Item = Node<T>> {
        self.nodes.values()
    }
    
    fn clear() {
        self.nodes.clear()
        self.next_id = 0
    }
}

/// Labeled node for named graphs
struct LabeledNode<T> {
    inner: Node<T>
    label: String
    
    fn new(id: NodeId, label: String, data: T) -> Self {
        var node = Node.new(id, data)
        node.set_label(label.clone())
        LabeledNode { inner: node, label: label }
    }
    
    fn id() -> NodeId { self.inner.id() }
    fn label() -> String { self.label.clone() }
    fn data() -> T { self.inner.data() }
}

/// Weighted node for weighted graphs
struct WeightedNode<T> {
    inner: Node<T>
    weight: Float
    
    fn new(id: NodeId, data: T, weight: Float) -> Self {
        var node = Node.new(id, data)
        node.set_weight(weight)
        WeightedNode { inner: node, weight: weight }
    }
    
    fn id() -> NodeId { self.inner.id() }
    fn weight() -> Float { self.weight }
    fn data() -> T { self.inner.data() }
    fn set_weight(weight: Float) { self.weight = weight; self.inner.set_weight(weight) }
}

/// Node builder for fluent API
struct NodeBuilder<T> {
    id: NodeId
    data: T
    metadata: NodeMetadata
    
    fn new(id: NodeId, data: T) -> Self {
        NodeBuilder { id: id, data: data, metadata: NodeMetadata.default() }
    }
    
    fn label(label: String) -> Self {
        self.metadata.label = Some(label)
        self
    }
    
    fn weight(weight: Float) -> Self {
        self.metadata.weight = weight
        self
    }
    
    fn color(color: String) -> Self {
        self.metadata.color = Some(color)
        self
    }
    
    fn position(x: Float, y: Float) -> Self {
        self.metadata.position = Some((x, y))
        self
    }
    
    fn attribute(key: String, value: String) -> Self {
        self.metadata.attributes.set(key, value)
        self
    }
    
    fn build() -> Node<T> {
        Node.with_metadata(self.id, self.data, self.metadata)
    }
}

// Tests
test "node creation" {
    let node = Node.new(0, "test")
    assert_eq(node.id(), 0)?
    assert_eq(node.data(), "test")?
}

test "node metadata" {
    var node = Node.new(0, 42)
    node.set_label("answer")
    node.set_weight(2.5)
    assert_eq(node.label(), Some("answer"))?
    assert_eq(node.weight(), 2.5)?
}

test "node collection" {
    var nodes = NodeCollection::<String>.new()
    let a = nodes.add("A")
    let b = nodes.add("B")
    assert_eq(nodes.len(), 2)?
    assert_eq(nodes.get(a).map(|n| n.data()), Some("A"))?
}

test "node builder" {
    let node = NodeBuilder.new(0, "data")
        .label("my_node")
        .weight(1.5)
        .color("red")
        .position(10.0, 20.0)
        .attribute("type", "vertex")
        .build()
    assert_eq(node.label(), Some("my_node"))?
    assert_eq(node.weight(), 1.5)?
}

test "algorithm node" {
    let node = Node.new(0, "test")
    var algo_node = AlgorithmNode.new(node)
    assert!(algo_node.state.is_unvisited())?
    algo_node.mark_visiting(1)
    assert!(algo_node.state.is_visiting())?
    algo_node.mark_visited(2)
    assert!(algo_node.state.is_visited())?
}

test "node state" {
    let state = NodeState.Unvisited
    assert!(state.is_unvisited())?
    assert!(!state.is_visited())?
}
