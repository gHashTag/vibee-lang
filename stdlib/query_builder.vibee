// =============================================================================
// Vibee OS â€” Query Builder Module
// SQL Query Builder for ORM
// =============================================================================

use entity::{Value, SqlDialect}

// =============================================================================
// Query Result
// =============================================================================

/// Built query with SQL and parameters
struct Query {
    sql: String
    params: [Value]
    
    fn new(sql: String, params: [Value]) -> Self {
        Query { sql: sql, params: params }
    }
}

// =============================================================================
// Where Clauses
// =============================================================================

/// Where clause types
enum WhereClause {
    Eq(String, Value)
    Ne(String, Value)
    Gt(String, Value)
    Gte(String, Value)
    Lt(String, Value)
    Lte(String, Value)
    Like(String, String)
    ILike(String, String)
    In(String, [Value])
    NotIn(String, [Value])
    IsNull(String)
    IsNotNull(String)
    Between(String, Value, Value)
    Raw(String, [Value])
    And([WhereClause])
    Or([WhereClause])
    Not(Box<WhereClause>)
}

/// Order direction
enum OrderDirection {
    Asc
    Desc
    
    fn to_sql() -> String {
        match self { Asc => "ASC", Desc => "DESC" }
    }
}

/// Join type
enum JoinType {
    Inner
    Left
    Right
    Full
    Cross
    
    fn to_sql() -> String {
        match self {
            Inner => "INNER JOIN"
            Left => "LEFT JOIN"
            Right => "RIGHT JOIN"
            Full => "FULL OUTER JOIN"
            Cross => "CROSS JOIN"
        }
    }
}

// =============================================================================
// Select Builder
// =============================================================================

/// SELECT query builder
struct SelectBuilder {
    table: String
    columns: [String]
    distinct: Bool
    where_clauses: [WhereClause]
    joins: [JoinClause]
    order_by: [(String, OrderDirection)]
    group_by: [String]
    having: [WhereClause]
    limit_val: Option<Int>
    offset_val: Option<Int>
    dialect: SqlDialect
    
    fn new(table: String) -> Self {
        SelectBuilder {
            table: table,
            columns: ["*"],
            distinct: false,
            where_clauses: [],
            joins: [],
            order_by: [],
            group_by: [],
            having: [],
            limit_val: None,
            offset_val: None,
            dialect: SqlDialect.Postgres
        }
    }
    
    fn dialect(d: SqlDialect) -> Self { self.dialect = d; self }
    fn columns(cols: [String]) -> Self { self.columns = cols; self }
    fn column(col: String) -> Self { self.columns.push(col); self }
    fn distinct() -> Self { self.distinct = true; self }
    
    fn count() -> Self {
        self.columns = ["COUNT(*) as count"]
        self
    }
    
    fn sum(col: String) -> Self {
        self.columns.push(format!("SUM({}) as sum_{}", col, col))
        self
    }
    
    fn avg(col: String) -> Self {
        self.columns.push(format!("AVG({}) as avg_{}", col, col))
        self
    }
    
    fn min(col: String) -> Self {
        self.columns.push(format!("MIN({}) as min_{}", col, col))
        self
    }
    
    fn max(col: String) -> Self {
        self.columns.push(format!("MAX({}) as max_{}", col, col))
        self
    }
    
    fn where_clause(clause: WhereClause) -> Self {
        self.where_clauses.push(clause)
        self
    }
    
    fn where_eq(col: String, val: Value) -> Self {
        self.where_clauses.push(WhereClause.Eq(col, val))
        self
    }
    
    fn where_ne(col: String, val: Value) -> Self {
        self.where_clauses.push(WhereClause.Ne(col, val))
        self
    }
    
    fn where_gt(col: String, val: Value) -> Self {
        self.where_clauses.push(WhereClause.Gt(col, val))
        self
    }
    
    fn where_lt(col: String, val: Value) -> Self {
        self.where_clauses.push(WhereClause.Lt(col, val))
        self
    }
    
    fn where_in(col: String, vals: [Value]) -> Self {
        self.where_clauses.push(WhereClause.In(col, vals))
        self
    }
    
    fn where_null(col: String) -> Self {
        self.where_clauses.push(WhereClause.IsNull(col))
        self
    }
    
    fn where_not_null(col: String) -> Self {
        self.where_clauses.push(WhereClause.IsNotNull(col))
        self
    }
    
    fn join(table: String, left: String, right: String) -> Self {
        self.joins.push(JoinClause { join_type: JoinType.Inner, table: table, on_left: left, on_right: right })
        self
    }
    
    fn left_join(table: String, left: String, right: String) -> Self {
        self.joins.push(JoinClause { join_type: JoinType.Left, table: table, on_left: left, on_right: right })
        self
    }
    
    fn order_by(col: String, dir: OrderDirection) -> Self {
        self.order_by.push((col, dir))
        self
    }
    
    fn group_by(col: String) -> Self {
        self.group_by.push(col)
        self
    }
    
    fn limit(n: Int) -> Self { self.limit_val = Some(n); self }
    fn offset(n: Int) -> Self { self.offset_val = Some(n); self }
    
    fn build() -> Query {
        var sql = "SELECT "
        if self.distinct { sql += "DISTINCT " }
        sql += self.columns.join(", ")
        sql += format!(" FROM {}", self.table)
        
        for j in self.joins {
            sql += format!(" {} {} ON {} = {}", j.join_type.to_sql(), j.table, j.on_left, j.on_right)
        }
        
        var params: [Value] = []
        var idx = 1
        
        if !self.where_clauses.is_empty() {
            sql += " WHERE "
            var conditions: [String] = []
            for clause in self.where_clauses {
                let (cond, p, new_idx) = build_where_clause(clause, idx, self.dialect)
                conditions.push(cond)
                params.extend(p)
                idx = new_idx
            }
            sql += conditions.join(" AND ")
        }
        
        if !self.group_by.is_empty() {
            sql += format!(" GROUP BY {}", self.group_by.join(", "))
        }
        
        if !self.order_by.is_empty() {
            let orders = self.order_by.iter().map(|(c, d)| format!("{} {}", c, d.to_sql())).collect()
            sql += format!(" ORDER BY {}", orders.join(", "))
        }
        
        if let Some(l) = self.limit_val { sql += format!(" LIMIT {}", l) }
        if let Some(o) = self.offset_val { sql += format!(" OFFSET {}", o) }
        
        Query.new(sql, params)
    }
}

/// Join clause
struct JoinClause {
    join_type: JoinType
    table: String
    on_left: String
    on_right: String
}

// =============================================================================
// Insert Builder
// =============================================================================

/// INSERT query builder
struct InsertBuilder {
    table: String
    columns: [String]
    values: [[Value]]
    returning: [String]
    on_conflict: Option<OnConflict>
    dialect: SqlDialect
    
    fn new(table: String) -> Self {
        InsertBuilder {
            table: table,
            columns: [],
            values: [],
            returning: [],
            on_conflict: None,
            dialect: SqlDialect.Postgres
        }
    }
    
    fn dialect(d: SqlDialect) -> Self { self.dialect = d; self }
    
    fn columns(cols: [String]) -> Self {
        self.columns = cols
        self
    }
    
    fn values(vals: [Value]) -> Self {
        self.values.push(vals)
        self
    }
    
    fn returning(cols: [String]) -> Self {
        self.returning = cols
        self
    }
    
    fn on_conflict_do_nothing() -> Self {
        self.on_conflict = Some(OnConflict.DoNothing)
        self
    }
    
    fn on_conflict_update(cols: [String]) -> Self {
        self.on_conflict = Some(OnConflict.Update(cols))
        self
    }
    
    fn build() -> Query {
        var sql = format!("INSERT INTO {} ({})", self.table, self.columns.join(", "))
        var params: [Value] = []
        var idx = 1
        
        var value_groups: [String] = []
        for row in self.values {
            var placeholders: [String] = []
            for val in row {
                placeholders.push(self.dialect.placeholder(idx))
                params.push(val)
                idx += 1
            }
            value_groups.push(format!("({})", placeholders.join(", ")))
        }
        sql += format!(" VALUES {}", value_groups.join(", "))
        
        if let Some(conflict) = self.on_conflict {
            match conflict {
                OnConflict.DoNothing => sql += " ON CONFLICT DO NOTHING"
                OnConflict.Update(cols) => {
                    let updates = cols.iter().map(|c| format!("{} = EXCLUDED.{}", c, c)).join(", ")
                    sql += format!(" ON CONFLICT DO UPDATE SET {}", updates)
                }
            }
        }
        
        if !self.returning.is_empty() {
            sql += format!(" RETURNING {}", self.returning.join(", "))
        }
        
        Query.new(sql, params)
    }
}

enum OnConflict {
    DoNothing
    Update([String])
}

// =============================================================================
// Update Builder
// =============================================================================

/// UPDATE query builder
struct UpdateBuilder {
    table: String
    sets: [(String, Value)]
    where_clauses: [WhereClause]
    returning: [String]
    dialect: SqlDialect
    
    fn new(table: String) -> Self {
        UpdateBuilder {
            table: table,
            sets: [],
            where_clauses: [],
            returning: [],
            dialect: SqlDialect.Postgres
        }
    }
    
    fn dialect(d: SqlDialect) -> Self { self.dialect = d; self }
    
    fn set(col: String, val: Value) -> Self {
        self.sets.push((col, val))
        self
    }
    
    fn where_clause(clause: WhereClause) -> Self {
        self.where_clauses.push(clause)
        self
    }
    
    fn where_eq(col: String, val: Value) -> Self {
        self.where_clauses.push(WhereClause.Eq(col, val))
        self
    }
    
    fn returning(cols: [String]) -> Self {
        self.returning = cols
        self
    }
    
    fn build() -> Query {
        var params: [Value] = []
        var idx = 1
        
        var set_parts: [String] = []
        for (col, val) in self.sets {
            set_parts.push(format!("{} = {}", col, self.dialect.placeholder(idx)))
            params.push(val)
            idx += 1
        }
        
        var sql = format!("UPDATE {} SET {}", self.table, set_parts.join(", "))
        
        if !self.where_clauses.is_empty() {
            sql += " WHERE "
            var conditions: [String] = []
            for clause in self.where_clauses {
                let (cond, p, new_idx) = build_where_clause(clause, idx, self.dialect)
                conditions.push(cond)
                params.extend(p)
                idx = new_idx
            }
            sql += conditions.join(" AND ")
        }
        
        if !self.returning.is_empty() {
            sql += format!(" RETURNING {}", self.returning.join(", "))
        }
        
        Query.new(sql, params)
    }
}

// =============================================================================
// Delete Builder
// =============================================================================

/// DELETE query builder
struct DeleteBuilder {
    table: String
    where_clauses: [WhereClause]
    returning: [String]
    dialect: SqlDialect
    
    fn new(table: String) -> Self {
        DeleteBuilder {
            table: table,
            where_clauses: [],
            returning: [],
            dialect: SqlDialect.Postgres
        }
    }
    
    fn dialect(d: SqlDialect) -> Self { self.dialect = d; self }
    
    fn where_clause(clause: WhereClause) -> Self {
        self.where_clauses.push(clause)
        self
    }
    
    fn where_eq(col: String, val: Value) -> Self {
        self.where_clauses.push(WhereClause.Eq(col, val))
        self
    }
    
    fn returning(cols: [String]) -> Self {
        self.returning = cols
        self
    }
    
    fn build() -> Query {
        var sql = format!("DELETE FROM {}", self.table)
        var params: [Value] = []
        var idx = 1
        
        if !self.where_clauses.is_empty() {
            sql += " WHERE "
            var conditions: [String] = []
            for clause in self.where_clauses {
                let (cond, p, new_idx) = build_where_clause(clause, idx, self.dialect)
                conditions.push(cond)
                params.extend(p)
                idx = new_idx
            }
            sql += conditions.join(" AND ")
        }
        
        if !self.returning.is_empty() {
            sql += format!(" RETURNING {}", self.returning.join(", "))
        }
        
        Query.new(sql, params)
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn build_where_clause(clause: WhereClause, start_idx: Int, dialect: SqlDialect) -> (String, [Value], Int) {
    var idx = start_idx
    var params: [Value] = []
    
    let sql = match clause {
        WhereClause.Eq(col, val) => {
            params.push(val)
            let s = format!("{} = {}", col, dialect.placeholder(idx))
            idx += 1
            s
        }
        WhereClause.Ne(col, val) => {
            params.push(val)
            let s = format!("{} != {}", col, dialect.placeholder(idx))
            idx += 1
            s
        }
        WhereClause.Gt(col, val) => {
            params.push(val)
            let s = format!("{} > {}", col, dialect.placeholder(idx))
            idx += 1
            s
        }
        WhereClause.Lt(col, val) => {
            params.push(val)
            let s = format!("{} < {}", col, dialect.placeholder(idx))
            idx += 1
            s
        }
        WhereClause.In(col, vals) => {
            var placeholders: [String] = []
            for v in vals {
                placeholders.push(dialect.placeholder(idx))
                params.push(v)
                idx += 1
            }
            format!("{} IN ({})", col, placeholders.join(", "))
        }
        WhereClause.IsNull(col) => format!("{} IS NULL", col)
        WhereClause.IsNotNull(col) => format!("{} IS NOT NULL", col)
        WhereClause.Like(col, pattern) => {
            params.push(Value.String(pattern))
            let s = format!("{} LIKE {}", col, dialect.placeholder(idx))
            idx += 1
            s
        }
        WhereClause.Between(col, min, max) => {
            params.push(min)
            params.push(max)
            let s = format!("{} BETWEEN {} AND {}", col, dialect.placeholder(idx), dialect.placeholder(idx + 1))
            idx += 2
            s
        }
        WhereClause.Raw(sql, p) => {
            params.extend(p)
            idx += p.len()
            sql
        }
        _ => ""
    }
    
    (sql, params, idx)
}

// =============================================================================
// Raw Query Builder
// =============================================================================

/// Raw SQL query builder
struct RawQuery {
    sql: String
    params: [Value]
    
    fn new(sql: String) -> Self {
        RawQuery { sql: sql, params: [] }
    }
    
    fn bind(val: Value) -> Self {
        self.params.push(val)
        self
    }
    
    fn build() -> Query {
        Query.new(self.sql.clone(), self.params.clone())
    }
}

// =============================================================================
// Tests
// =============================================================================

test "select_builder" {
    let query = SelectBuilder.new("users")
        .columns(["id", "name", "email"])
        .where_eq("status", Value.String("active"))
        .order_by("created_at", OrderDirection.Desc)
        .limit(10)
        .build()
    
    assert(query.sql.contains("SELECT id, name, email FROM users"))?
    assert(query.sql.contains("WHERE"))?
    assert(query.sql.contains("ORDER BY"))?
    assert(query.sql.contains("LIMIT 10"))?
}

test "insert_builder" {
    let query = InsertBuilder.new("users")
        .columns(["name", "email"])
        .values([Value.String("John"), Value.String("john@test.com")])
        .returning(["id"])
        .build()
    
    assert(query.sql.contains("INSERT INTO users"))?
    assert(query.sql.contains("RETURNING id"))?
    assert_eq(query.params.len(), 2)?
}

test "update_builder" {
    let query = UpdateBuilder.new("users")
        .set("name", Value.String("Jane"))
        .where_eq("id", Value.Int(1))
        .build()
    
    assert(query.sql.contains("UPDATE users SET"))?
    assert(query.sql.contains("WHERE"))?
}

test "delete_builder" {
    let query = DeleteBuilder.new("users")
        .where_eq("id", Value.Int(1))
        .build()
    
    assert(query.sql.contains("DELETE FROM users"))?
    assert(query.sql.contains("WHERE"))?
}
