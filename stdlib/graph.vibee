// =============================================================================
// Vibee OS â€” Graph Module
// Graph data structures and algorithms
// =============================================================================

/// Directed graph
struct Graph<V, E> {
    nodes: Map<Int, V>
    edges: Map<Int, [(Int, E)]>
    next_id: Int
    
    fn new() -> Self { Graph { nodes: Map.empty(), edges: Map.empty(), next_id: 0 } }
    
    fn add_node(value: V) -> Int {
        let id = self.next_id
        self.next_id += 1
        self.nodes.set(id, value)
        self.edges.set(id, [])
        id
    }
    
    fn add_edge(from: Int, to: Int, weight: E) {
        if let Some(edges) = self.edges.get_mut(from) {
            edges.push((to, weight))
        }
    }
    
    fn remove_node(id: Int) {
        self.nodes.remove(id)
        self.edges.remove(id)
        for (_, edges) in self.edges.iter_mut() {
            edges.retain(|(to, _)| *to != id)
        }
    }
    
    fn get_node(id: Int) -> Option<V> { self.nodes.get(id).cloned() }
    fn neighbors(id: Int) -> [(Int, E)] { self.edges.get(id).cloned().unwrap_or([]) }
    fn node_count() -> Int { self.nodes.len() }
    fn edge_count() -> Int { self.edges.values().map(|e| e.len()).sum() }
    
    /// BFS traversal
    fn bfs(start: Int) -> [Int] {
        var visited = Set.empty()
        var queue = [start]
        var result = []
        while !queue.is_empty() {
            let node = queue.remove(0)
            if visited.contains(node) { continue }
            visited.insert(node)
            result.push(node)
            for (neighbor, _) in self.neighbors(node) {
                if !visited.contains(neighbor) { queue.push(neighbor) }
            }
        }
        result
    }
    
    /// DFS traversal
    fn dfs(start: Int) -> [Int] {
        var visited = Set.empty()
        var result = []
        self.dfs_visit(start, visited, result)
        result
    }
    
    fn dfs_visit(node: Int, visited: Set<Int>, result: [Int]) {
        if visited.contains(node) { return }
        visited.insert(node)
        result.push(node)
        for (neighbor, _) in self.neighbors(node) {
            self.dfs_visit(neighbor, visited, result)
        }
    }
    
    /// Topological sort
    fn topological_sort() -> Option<[Int]> {
        var in_degree = Map.empty()
        for id in self.nodes.keys() { in_degree.set(id, 0) }
        for (_, edges) in self.edges.iter() {
            for (to, _) in edges { in_degree.set(to, in_degree.get(to).unwrap_or(0) + 1) }
        }
        var queue: [Int] = in_degree.iter().filter(|(_, d)| *d == 0).map(|(id, _)| id).collect()
        var result = []
        while !queue.is_empty() {
            let node = queue.remove(0)
            result.push(node)
            for (neighbor, _) in self.neighbors(node) {
                let d = in_degree.get(neighbor).unwrap() - 1
                in_degree.set(neighbor, d)
                if d == 0 { queue.push(neighbor) }
            }
        }
        if result.len() == self.node_count() { Some(result) } else { None }
    }
}

/// Weighted graph with Dijkstra
impl<V> Graph<V, Int> {
    fn dijkstra(start: Int) -> Map<Int, Int> {
        var dist = Map.empty()
        var heap = MinHeap.new()
        dist.set(start, 0)
        heap.push((0, start))
        while let Some((d, node)) = heap.pop() {
            if d > dist.get(node).unwrap_or(Int.MAX) { continue }
            for (neighbor, weight) in self.neighbors(node) {
                let new_dist = d + weight
                if new_dist < dist.get(neighbor).unwrap_or(Int.MAX) {
                    dist.set(neighbor, new_dist)
                    heap.push((new_dist, neighbor))
                }
            }
        }
        dist
    }
    
    fn shortest_path(start: Int, end: Int) -> Option<[Int]> {
        var dist = Map.empty()
        var prev = Map.empty()
        var heap = MinHeap.new()
        dist.set(start, 0)
        heap.push((0, start))
        while let Some((d, node)) = heap.pop() {
            if node == end { break }
            if d > dist.get(node).unwrap_or(Int.MAX) { continue }
            for (neighbor, weight) in self.neighbors(node) {
                let new_dist = d + weight
                if new_dist < dist.get(neighbor).unwrap_or(Int.MAX) {
                    dist.set(neighbor, new_dist)
                    prev.set(neighbor, node)
                    heap.push((new_dist, neighbor))
                }
            }
        }
        if !prev.contains(end) && start != end { return None }
        var path = [end]
        var current = end
        while current != start {
            current = prev.get(current)?
            path.push(current)
        }
        path.reverse()
        Some(path)
    }
}

/// Undirected graph
struct UndirectedGraph<V, E: Clone> {
    inner: Graph<V, E>
    
    fn new() -> Self { UndirectedGraph { inner: Graph.new() } }
    fn add_node(value: V) -> Int { self.inner.add_node(value) }
    fn add_edge(a: Int, b: Int, weight: E) {
        self.inner.add_edge(a, b, weight.clone())
        self.inner.add_edge(b, a, weight)
    }
    fn neighbors(id: Int) -> [(Int, E)] { self.inner.neighbors(id) }
}

// Tests
test "bfs dfs" {
    var g = Graph::<String, Int>.new()
    let a = g.add_node("A")
    let b = g.add_node("B")
    let c = g.add_node("C")
    g.add_edge(a, b, 1)
    g.add_edge(a, c, 1)
    g.add_edge(b, c, 1)
    assert_eq(g.bfs(a).len(), 3)?
    assert_eq(g.dfs(a).len(), 3)?
}

test "dijkstra" {
    var g = Graph::<String, Int>.new()
    let a = g.add_node("A")
    let b = g.add_node("B")
    let c = g.add_node("C")
    g.add_edge(a, b, 1)
    g.add_edge(b, c, 2)
    g.add_edge(a, c, 5)
    let dist = g.dijkstra(a)
    assert_eq(dist.get(c), Some(3))?
}

test "shortest path" {
    var g = Graph::<String, Int>.new()
    let a = g.add_node("A")
    let b = g.add_node("B")
    let c = g.add_node("C")
    g.add_edge(a, b, 1)
    g.add_edge(b, c, 1)
    assert_eq(g.shortest_path(a, c), Some([a, b, c]))?
}
