// =============================================================================
// Vibee OS â€” SQLite Module
// SQLite embedded database
// =============================================================================

/// SQLite connection
struct SqliteConnection {
    inner: @native("SqliteConn")
    path: String
}

impl SqliteConnection {
    fn open(path: String) -> Result<Self, SqliteError> {
        let inner = @native("sqlite_open", path)?
        Ok(SqliteConnection { inner: inner, path: path })
    }
    
    fn memory() -> Result<Self, SqliteError> { Self.open(":memory:") }
    
    fn execute(sql: String, params: [SqliteValue]) -> Result<Int64, SqliteError> {
        @native("sqlite_execute", self.inner, sql, params)
    }
    
    fn query(sql: String, params: [SqliteValue]) -> Result<SqliteRows, SqliteError> {
        let rows = @native("sqlite_query", self.inner, sql, params)?
        Ok(SqliteRows { inner: rows })
    }
    
    fn query_one(sql: String, params: [SqliteValue]) -> Result<SqliteRow, SqliteError> {
        self.query(sql, params)?.next().ok_or(SqliteError.NoRows)
    }
    
    fn prepare(sql: String) -> Result<SqliteStatement, SqliteError> {
        let stmt = @native("sqlite_prepare", self.inner, sql)?
        Ok(SqliteStatement { inner: stmt })
    }
    
    fn begin() -> Result<SqliteTransaction, SqliteError> {
        self.execute("BEGIN", [])?
        Ok(SqliteTransaction { conn: self, done: false })
    }
    
    fn last_insert_rowid() -> Int64 { @native("sqlite_last_insert_rowid", self.inner) }
    fn changes() -> Int64 { @native("sqlite_changes", self.inner) }
    fn close() { @native("sqlite_close", self.inner) }
}

impl Drop for SqliteConnection { fn drop() { self.close() } }

/// Prepared statement
struct SqliteStatement { inner: @native("SqliteStmt") }

impl SqliteStatement {
    fn execute(params: [SqliteValue]) -> Result<Int64, SqliteError> {
        @native("sqlite_stmt_execute", self.inner, params)
    }
    
    fn query(params: [SqliteValue]) -> Result<SqliteRows, SqliteError> {
        Ok(SqliteRows { inner: @native("sqlite_stmt_query", self.inner, params)? })
    }
}

/// Transaction
struct SqliteTransaction { conn: SqliteConnection, done: Bool }

impl SqliteTransaction {
    fn execute(sql: String, params: [SqliteValue]) -> Result<Int64, SqliteError> {
        self.conn.execute(sql, params)
    }
    
    fn query(sql: String, params: [SqliteValue]) -> Result<SqliteRows, SqliteError> {
        self.conn.query(sql, params)
    }
    
    fn commit() -> Result<(), SqliteError> {
        self.conn.execute("COMMIT", [])?
        self.done = true
        Ok(())
    }
    
    fn rollback() -> Result<(), SqliteError> {
        self.conn.execute("ROLLBACK", [])?
        self.done = true
        Ok(())
    }
}

impl Drop for SqliteTransaction {
    fn drop() { if !self.done { let _ = self.rollback() } }
}

/// Query rows
struct SqliteRows { inner: @native("SqliteRows") }

impl SqliteRows {
    fn next() -> Option<SqliteRow> {
        @native("sqlite_rows_next", self.inner).map(|r| SqliteRow { inner: r })
    }
    
    fn columns() -> [String] { @native("sqlite_rows_columns", self.inner) }
}

impl Iterator for SqliteRows {
    type Item = SqliteRow
    fn next() -> Option<SqliteRow> { self.next() }
}

/// Single row
struct SqliteRow { inner: @native("SqliteRow") }

impl SqliteRow {
    fn get<T: FromSqlite>(index: Int) -> Result<T, SqliteError> {
        T.from_sqlite(@native("sqlite_row_get", self.inner, index)?)
    }
    
    fn get_by_name<T: FromSqlite>(name: String) -> Result<T, SqliteError> {
        T.from_sqlite(@native("sqlite_row_get_by_name", self.inner, name)?)
    }
}

/// SQLite values
enum SqliteValue { Null, Integer(Int64), Real(Float64), Text(String), Blob([UInt8]) }

impl SqliteValue {
    fn null() -> Self { SqliteValue.Null }
    fn int(v: Int64) -> Self { SqliteValue.Integer(v) }
    fn real(v: Float64) -> Self { SqliteValue.Real(v) }
    fn text(v: String) -> Self { SqliteValue.Text(v) }
    fn blob(v: [UInt8]) -> Self { SqliteValue.Blob(v) }
    fn is_null() -> Bool { matches!(self, Null) }
}

/// Convert from SQLite value
trait FromSqlite { fn from_sqlite(value: SqliteValue) -> Result<Self, SqliteError> }

impl FromSqlite for Int64 {
    fn from_sqlite(value: SqliteValue) -> Result<Self, SqliteError> {
        match value { SqliteValue.Integer(v) => Ok(v), _ => Err(SqliteError.TypeMismatch) }
    }
}

impl FromSqlite for String {
    fn from_sqlite(value: SqliteValue) -> Result<Self, SqliteError> {
        match value { SqliteValue.Text(v) => Ok(v), _ => Err(SqliteError.TypeMismatch) }
    }
}

impl<T: FromSqlite> FromSqlite for Option<T> {
    fn from_sqlite(value: SqliteValue) -> Result<Self, SqliteError> {
        match value { SqliteValue.Null => Ok(None), v => Ok(Some(T.from_sqlite(v)?)) }
    }
}

/// Errors
enum SqliteError {
    OpenFailed(String), QueryFailed(String), NoRows, TypeMismatch, Busy, Locked, Io(String)
}

impl Display for SqliteError {
    fn fmt(f: Formatter) {
        match self {
            OpenFailed(s) => f.write(format!("Open failed: {}", s))
            QueryFailed(s) => f.write(format!("Query failed: {}", s))
            NoRows => f.write("No rows")
            TypeMismatch => f.write("Type mismatch")
            Busy => f.write("Database busy")
            Locked => f.write("Database locked")
            Io(s) => f.write(format!("IO: {}", s))
        }
    }
}

/// Quick open
fn open(path: String) -> Result<SqliteConnection, SqliteError> { SqliteConnection.open(path) }
fn memory() -> Result<SqliteConnection, SqliteError> { SqliteConnection.memory() }

// Tests
test "open memory" {
    let db = SqliteConnection.memory()?
    db.execute("CREATE TABLE test (id INTEGER PRIMARY KEY, name TEXT)", [])?
    db.execute("INSERT INTO test (name) VALUES (?)", [SqliteValue.text("hello")])?
    let row = db.query_one("SELECT name FROM test WHERE id = 1", [])?
    assert_eq(row.get::<String>(0)?, "hello")?
}

test "sqlite value" {
    let v = SqliteValue.int(42)
    assert(!v.is_null())?
    assert(SqliteValue.null().is_null())?
}
