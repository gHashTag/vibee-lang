// =============================================================================
// Vibee OS â€” Conversation Module
// Chat conversations, rooms, and group management
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}
use chat_message::{ChatMessage, MessageContent}

// =============================================================================
// Conversation Types
// =============================================================================

/// Conversation type
enum ConversationType {
    Direct,
    Group,
    Channel,
    Broadcast,
    Support
}

impl ConversationType {
    fn allows_multiple_admins() -> Bool {
        match self {
            ConversationType.Direct => false,
            _ => true
        }
    }
    
    fn max_members() -> Option<Int> {
        match self {
            ConversationType.Direct => Some(2),
            ConversationType.Group => Some(500),
            ConversationType.Channel => None,
            ConversationType.Broadcast => None,
            ConversationType.Support => Some(10)
        }
    }
}

/// Member role in conversation
enum MemberRole {
    Owner,
    Admin,
    Moderator,
    Member,
    Restricted,
    Banned
}

impl MemberRole {
    fn can_send_messages() -> Bool {
        match self {
            MemberRole.Restricted | MemberRole.Banned => false,
            _ => true
        }
    }
    
    fn can_manage_members() -> Bool {
        match self {
            MemberRole.Owner | MemberRole.Admin | MemberRole.Moderator => true,
            _ => false
        }
    }
    
    fn can_delete_messages() -> Bool {
        match self {
            MemberRole.Owner | MemberRole.Admin | MemberRole.Moderator => true,
            _ => false
        }
    }
    
    fn can_change_settings() -> Bool {
        match self {
            MemberRole.Owner | MemberRole.Admin => true,
            _ => false
        }
    }
    
    fn priority() -> Int {
        match self {
            MemberRole.Owner => 100,
            MemberRole.Admin => 80,
            MemberRole.Moderator => 60,
            MemberRole.Member => 40,
            MemberRole.Restricted => 20,
            MemberRole.Banned => 0
        }
    }
}

// =============================================================================
// Conversation Member
// =============================================================================

/// Conversation member
struct ConversationMember {
    user_id: String,
    username: String,
    display_name: String,
    avatar_url: Option<String>,
    role: MemberRole,
    joined_at: DateTime,
    last_read_at: Option<DateTime>,
    last_read_message_id: Option<String>,
    is_muted: Bool,
    muted_until: Option<DateTime>,
    custom_title: Option<String>,
    permissions: MemberPermissions
}

impl ConversationMember {
    fn new(user_id: String, username: String, display_name: String) -> Self {
        ConversationMember {
            user_id: user_id,
            username: username,
            display_name: display_name,
            avatar_url: None,
            role: MemberRole.Member,
            joined_at: DateTime.now(),
            last_read_at: None,
            last_read_message_id: None,
            is_muted: false,
            muted_until: None,
            custom_title: None,
            permissions: MemberPermissions.default()
        }
    }
    
    fn as_owner(user_id: String, username: String, display_name: String) -> Self {
        var member = Self.new(user_id, username, display_name)
        member.role = MemberRole.Owner
        member.permissions = MemberPermissions.all()
        member
    }
    
    fn is_active() -> Bool {
        self.role != MemberRole.Banned && self.role != MemberRole.Restricted
    }
    
    fn can_send() -> Bool {
        if !self.role.can_send_messages() { return false }
        if let Some(until) = self.muted_until {
            if DateTime.now() < until { return false }
        }
        true
    }
    
    fn unread_count(last_message_id: Option<String>) -> Int {
        // Would be calculated based on message IDs
        0
    }
    
    fn mute(duration: Duration) {
        self.is_muted = true
        self.muted_until = Some(DateTime.now() + duration)
    }
    
    fn unmute() {
        self.is_muted = false
        self.muted_until = None
    }
    
    fn promote(new_role: MemberRole) {
        if new_role.priority() > self.role.priority() {
            self.role = new_role
        }
    }
    
    fn demote(new_role: MemberRole) {
        if new_role.priority() < self.role.priority() {
            self.role = new_role
        }
    }
}

/// Member permissions
struct MemberPermissions {
    can_send_text: Bool,
    can_send_media: Bool,
    can_send_stickers: Bool,
    can_send_polls: Bool,
    can_add_members: Bool,
    can_pin_messages: Bool,
    can_change_info: Bool
}

impl MemberPermissions {
    fn default() -> Self {
        MemberPermissions {
            can_send_text: true,
            can_send_media: true,
            can_send_stickers: true,
            can_send_polls: false,
            can_add_members: false,
            can_pin_messages: false,
            can_change_info: false
        }
    }
    
    fn all() -> Self {
        MemberPermissions {
            can_send_text: true,
            can_send_media: true,
            can_send_stickers: true,
            can_send_polls: true,
            can_add_members: true,
            can_pin_messages: true,
            can_change_info: true
        }
    }
    
    fn read_only() -> Self {
        MemberPermissions {
            can_send_text: false,
            can_send_media: false,
            can_send_stickers: false,
            can_send_polls: false,
            can_add_members: false,
            can_pin_messages: false,
            can_change_info: false
        }
    }
}

// =============================================================================
// Conversation Settings
// =============================================================================

/// Conversation settings
struct ConversationSettings {
    is_public: Bool,
    join_by_link: Bool,
    join_by_request: Bool,
    members_can_add: Bool,
    slow_mode_seconds: Option<Int>,
    auto_delete_seconds: Option<Int>,
    history_visible_to_new: Bool,
    signature_enabled: Bool
}

impl ConversationSettings {
    fn default() -> Self {
        ConversationSettings {
            is_public: false,
            join_by_link: true,
            join_by_request: false,
            members_can_add: true,
            slow_mode_seconds: None,
            auto_delete_seconds: None,
            history_visible_to_new: true,
            signature_enabled: false
        }
    }
    
    fn private() -> Self {
        ConversationSettings {
            is_public: false,
            join_by_link: false,
            join_by_request: false,
            members_can_add: false,
            slow_mode_seconds: None,
            auto_delete_seconds: None,
            history_visible_to_new: false,
            signature_enabled: false
        }
    }
    
    fn public_channel() -> Self {
        ConversationSettings {
            is_public: true,
            join_by_link: true,
            join_by_request: false,
            members_can_add: false,
            slow_mode_seconds: None,
            auto_delete_seconds: None,
            history_visible_to_new: true,
            signature_enabled: true
        }
    }
}

// =============================================================================
// Conversation
// =============================================================================

/// Main conversation structure
struct Conversation {
    id: String,
    type: ConversationType,
    name: Option<String>,
    description: Option<String>,
    avatar_url: Option<String>,
    members: Map<String, ConversationMember>,
    settings: ConversationSettings,
    created_at: DateTime,
    updated_at: DateTime,
    last_message: Option<ChatMessage>,
    last_message_at: Option<DateTime>,
    pinned_messages: [String],
    invite_link: Option<String>,
    metadata: Map<String, String>
}

impl Conversation {
    fn new(conv_type: ConversationType, creator: ConversationMember) -> Self {
        let creator_id = creator.user_id.clone()
        var members = Map.empty()
        members.insert(creator_id, ConversationMember.as_owner(
            creator.user_id,
            creator.username,
            creator.display_name
        ))
        
        Conversation {
            id: @native("uuid_v4"),
            type: conv_type,
            name: None,
            description: None,
            avatar_url: None,
            members: members,
            settings: ConversationSettings.default(),
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            last_message: None,
            last_message_at: None,
            pinned_messages: [],
            invite_link: None,
            metadata: Map.empty()
        }
    }
    
    fn direct(user1: ConversationMember, user2: ConversationMember) -> Self {
        var conv = Self.new(ConversationType.Direct, user1)
        conv.add_member(user2)
        conv
    }
    
    fn group(name: String, creator: ConversationMember) -> Self {
        var conv = Self.new(ConversationType.Group, creator)
        conv.name = Some(name)
        conv
    }
    
    fn channel(name: String, creator: ConversationMember) -> Self {
        var conv = Self.new(ConversationType.Channel, creator)
        conv.name = Some(name)
        conv.settings = ConversationSettings.public_channel()
        conv
    }
    
    // Member management
    fn add_member(member: ConversationMember) -> Result<(), ConversationError> {
        if let Some(max) = self.type.max_members() {
            if self.members.len() >= max {
                return Err(ConversationError.MaxMembersReached(max))
            }
        }
        
        if self.members.contains_key(member.user_id) {
            return Err(ConversationError.AlreadyMember(member.user_id))
        }
        
        self.members.insert(member.user_id.clone(), member)
        self.updated_at = DateTime.now()
        Ok(())
    }
    
    fn remove_member(user_id: String) -> Result<ConversationMember, ConversationError> {
        let member = self.members.remove(user_id)
            .ok_or(ConversationError.NotMember(user_id))?
        self.updated_at = DateTime.now()
        Ok(member)
    }
    
    fn get_member(user_id: String) -> Option<ConversationMember> {
        self.members.get(user_id).cloned()
    }
    
    fn is_member(user_id: String) -> Bool {
        self.members.contains_key(user_id)
    }
    
    fn member_count() -> Int {
        self.members.len()
    }
    
    fn active_members() -> [ConversationMember] {
        self.members.values().filter(|m| m.is_active()).collect()
    }
    
    fn admins() -> [ConversationMember] {
        self.members.values()
            .filter(|m| m.role == MemberRole.Owner || m.role == MemberRole.Admin)
            .collect()
    }
    
    fn owner() -> Option<ConversationMember> {
        self.members.values().find(|m| m.role == MemberRole.Owner).cloned()
    }
    
    // Message handling
    fn update_last_message(message: ChatMessage) {
        self.last_message = Some(message)
        self.last_message_at = Some(DateTime.now())
        self.updated_at = DateTime.now()
    }
    
    fn pin_message(message_id: String) -> Result<(), ConversationError> {
        if self.pinned_messages.contains(message_id) {
            return Err(ConversationError.AlreadyPinned(message_id))
        }
        self.pinned_messages.push(message_id)
        Ok(())
    }
    
    fn unpin_message(message_id: String) -> Bool {
        let idx = self.pinned_messages.iter().position(|id| id == message_id)
        if let Some(i) = idx {
            self.pinned_messages.remove(i)
            true
        } else {
            false
        }
    }
    
    // Settings
    fn update_name(name: String) {
        self.name = Some(name)
        self.updated_at = DateTime.now()
    }
    
    fn update_description(description: String) {
        self.description = Some(description)
        self.updated_at = DateTime.now()
    }
    
    fn update_avatar(url: String) {
        self.avatar_url = Some(url)
        self.updated_at = DateTime.now()
    }
    
    fn generate_invite_link() -> String {
        let link = "chat://invite/" + @native("random_string", 16)
        self.invite_link = Some(link.clone())
        link
    }
    
    fn revoke_invite_link() {
        self.invite_link = None
    }
    
    // Display
    fn display_name(for_user: String) -> String {
        match self.type {
            ConversationType.Direct => {
                // Return other user's name
                self.members.values()
                    .find(|m| m.user_id != for_user)
                    .map(|m| m.display_name.clone())
                    .unwrap_or("Unknown")
            },
            _ => self.name.clone().unwrap_or("Unnamed")
        }
    }
    
    fn preview() -> String {
        match self.last_message {
            Some(msg) => msg.preview(50),
            None => "No messages yet"
        }
    }
}

/// Conversation errors
enum ConversationError {
    NotFound(String),
    NotMember(String),
    AlreadyMember(String),
    MaxMembersReached(Int),
    PermissionDenied(String),
    AlreadyPinned(String),
    InvalidOperation(String)
}

// =============================================================================
// Conversation Builder
// =============================================================================

struct ConversationBuilder {
    conv_type: ConversationType,
    name: Option<String>,
    description: Option<String>,
    avatar_url: Option<String>,
    members: [ConversationMember],
    settings: ConversationSettings
}

impl ConversationBuilder {
    fn new(conv_type: ConversationType) -> Self {
        ConversationBuilder {
            conv_type: conv_type,
            name: None,
            description: None,
            avatar_url: None,
            members: [],
            settings: ConversationSettings.default()
        }
    }
    
    fn group() -> Self { Self.new(ConversationType.Group) }
    fn channel() -> Self { Self.new(ConversationType.Channel) }
    
    fn name(self, name: String) -> Self { self.name = Some(name); self }
    fn description(self, desc: String) -> Self { self.description = Some(desc); self }
    fn avatar(self, url: String) -> Self { self.avatar_url = Some(url); self }
    fn add_member(self, member: ConversationMember) -> Self { self.members.push(member); self }
    fn settings(self, settings: ConversationSettings) -> Self { self.settings = settings; self }
    fn public(self) -> Self { self.settings.is_public = true; self }
    fn private(self) -> Self { self.settings.is_public = false; self }
    
    fn build(creator: ConversationMember) -> Result<Conversation, ConversationError> {
        var conv = Conversation.new(self.conv_type, creator)
        conv.name = self.name
        conv.description = self.description
        conv.avatar_url = self.avatar_url
        conv.settings = self.settings
        
        for member in self.members {
            conv.add_member(member)?
        }
        
        Ok(conv)
    }
}

// =============================================================================
// Conversation Manager Actor
// =============================================================================

actor ConversationManager {
    state conversations: Map<String, Conversation>
    state user_conversations: Map<String, [String]>
    state on_created: [fn(Conversation)]
    state on_updated: [fn(Conversation)]
    state on_deleted: [fn(String)]
    
    fn new() -> Self {
        ConversationManager {
            conversations: Map.empty(),
            user_conversations: Map.empty(),
            on_created: [],
            on_updated: [],
            on_deleted: []
        }
    }
    
    on create(conv: Conversation) -> String {
        let id = conv.id.clone()
        
        // Index by user
        for (user_id, _) in conv.members {
            if let Some(ids) = self.user_conversations.get(user_id) {
                ids.push(id.clone())
            } else {
                self.user_conversations.insert(user_id.clone(), [id.clone()])
            }
        }
        
        self.conversations.insert(id.clone(), conv.clone())
        
        for handler in self.on_created { handler(conv.clone()) }
        id
    }
    
    on get(id: String) -> Option<Conversation> {
        self.conversations.get(id).cloned()
    }
    
    on get_for_user(user_id: String) -> [Conversation] {
        let ids = self.user_conversations.get(user_id).unwrap_or([])
        ids.iter()
            .filter_map(|id| self.conversations.get(id).cloned())
            .collect()
    }
    
    on get_direct(user1: String, user2: String) -> Option<Conversation> {
        let user1_convs = self.user_conversations.get(user1).unwrap_or([])
        
        for conv_id in user1_convs {
            if let Some(conv) = self.conversations.get(conv_id) {
                if conv.type == ConversationType.Direct && conv.is_member(user2) {
                    return Some(conv.clone())
                }
            }
        }
        None
    }
    
    on update(id: String, updater: fn(Conversation) -> Conversation) -> Option<Conversation> {
        if let Some(conv) = self.conversations.get(id) {
            let updated = updater(conv.clone())
            self.conversations.insert(id, updated.clone())
            for handler in self.on_updated { handler(updated.clone()) }
            Some(updated)
        } else {
            None
        }
    }
    
    on add_member(conv_id: String, member: ConversationMember) -> Result<(), ConversationError> {
        let conv = self.conversations.get(conv_id)
            .ok_or(ConversationError.NotFound(conv_id.clone()))?
        
        conv.add_member(member.clone())?
        
        // Update user index
        if let Some(ids) = self.user_conversations.get(member.user_id) {
            ids.push(conv_id.clone())
        } else {
            self.user_conversations.insert(member.user_id.clone(), [conv_id])
        }
        
        Ok(())
    }
    
    on remove_member(conv_id: String, user_id: String) -> Result<(), ConversationError> {
        let conv = self.conversations.get(conv_id)
            .ok_or(ConversationError.NotFound(conv_id.clone()))?
        
        conv.remove_member(user_id.clone())?
        
        // Update user index
        if let Some(ids) = self.user_conversations.get(user_id) {
            ids.retain(|id| id != conv_id)
        }
        
        Ok(())
    }
    
    on delete(id: String) -> Bool {
        if let Some(conv) = self.conversations.remove(id.clone()) {
            // Remove from user indices
            for (user_id, _) in conv.members {
                if let Some(ids) = self.user_conversations.get(user_id) {
                    ids.retain(|cid| cid != id)
                }
            }
            for handler in self.on_deleted { handler(id) }
            true
        } else {
            false
        }
    }
    
    on search(user_id: String, query: String) -> [Conversation] {
        let query_lower = query.to_lowercase()
        self.get_for_user(user_id)
            .iter()
            .filter(|conv| {
                conv.name.map(|n| n.to_lowercase().contains(query_lower)).unwrap_or(false) ||
                conv.members.values().any(|m| m.display_name.to_lowercase().contains(query_lower))
            })
            .collect()
    }
    
    fn on_conversation_created(handler: fn(Conversation)) {
        self.on_created.push(handler)
    }
    
    fn on_conversation_updated(handler: fn(Conversation)) {
        self.on_updated.push(handler)
    }
    
    fn on_conversation_deleted(handler: fn(String)) {
        self.on_deleted.push(handler)
    }
}

// =============================================================================
// Conversation List
// =============================================================================

/// Sorted conversation list for UI
struct ConversationList {
    conversations: [Conversation],
    sort_by: ConversationSort
}

enum ConversationSort {
    LastMessage,
    Name,
    Unread,
    Pinned
}

impl ConversationList {
    fn new(conversations: [Conversation]) -> Self {
        ConversationList {
            conversations: conversations,
            sort_by: ConversationSort.LastMessage
        }
    }
    
    fn sorted() -> [Conversation] {
        match self.sort_by {
            ConversationSort.LastMessage => {
                self.conversations.sort_by(|a, b| {
                    let a_time = a.last_message_at.unwrap_or(a.created_at)
                    let b_time = b.last_message_at.unwrap_or(b.created_at)
                    b_time.cmp(a_time)
                })
            },
            ConversationSort.Name => {
                self.conversations.sort_by(|a, b| {
                    a.name.unwrap_or("").cmp(b.name.unwrap_or(""))
                })
            },
            _ => self.conversations.clone()
        }
    }
    
    fn filter_unread() -> [Conversation] {
        // Would filter by unread count
        self.conversations.clone()
    }
}

// =============================================================================
// Tests
// =============================================================================

test "create direct conversation" {
    let user1 = ConversationMember.new("u1", "alice", "Alice")
    let user2 = ConversationMember.new("u2", "bob", "Bob")
    
    let conv = Conversation.direct(user1, user2)
    assert_eq(conv.type, ConversationType.Direct)?
    assert_eq(conv.member_count(), 2)?
}

test "create group conversation" {
    let creator = ConversationMember.new("u1", "alice", "Alice")
    let conv = Conversation.group("Team Chat", creator)
    
    assert_eq(conv.type, ConversationType.Group)?
    assert_eq(conv.name, Some("Team Chat"))?
    assert_eq(conv.member_count(), 1)?
}

test "add and remove members" {
    let creator = ConversationMember.new("u1", "alice", "Alice")
    var conv = Conversation.group("Team", creator)
    
    let member = ConversationMember.new("u2", "bob", "Bob")
    conv.add_member(member)?
    assert_eq(conv.member_count(), 2)?
    
    conv.remove_member("u2")?
    assert_eq(conv.member_count(), 1)?
}

test "member roles" {
    assert(MemberRole.Owner.can_manage_members())?
    assert(MemberRole.Admin.can_manage_members())?
    assert(!MemberRole.Member.can_manage_members())?
    assert(!MemberRole.Banned.can_send_messages())?
}

test "conversation builder" {
    let creator = ConversationMember.new("u1", "alice", "Alice")
    let conv = ConversationBuilder.group()
        .name("Dev Team")
        .description("Development discussion")
        .public()
        .build(creator)?
    
    assert_eq(conv.name, Some("Dev Team"))?
    assert(conv.settings.is_public)?
}

test "pin messages" {
    let creator = ConversationMember.new("u1", "alice", "Alice")
    var conv = Conversation.group("Team", creator)
    
    conv.pin_message("msg1")?
    conv.pin_message("msg2")?
    assert_eq(conv.pinned_messages.len(), 2)?
    
    conv.unpin_message("msg1")
    assert_eq(conv.pinned_messages.len(), 1)?
}
