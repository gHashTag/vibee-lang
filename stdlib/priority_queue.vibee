// =============================================================================
// Vibee OS â€” Priority Queue Module
// Priority-based message queue with configurable ordering
// =============================================================================

// -----------------------------------------------------------------------------
// Priority Types
// -----------------------------------------------------------------------------

/// Priority level enum
enum Priority {
    Critical = 0
    High = 1
    Normal = 2
    Low = 3
    Background = 4
    
    fn value() -> Int {
        match self {
            Critical => 0
            High => 1
            Normal => 2
            Low => 3
            Background => 4
        }
    }
    
    fn from_int(v: Int) -> Self {
        match v {
            0 => Critical
            1 => High
            2 => Normal
            3 => Low
            _ => Background
        }
    }
}

impl Ord for Priority {
    fn cmp(other: Priority) -> Ordering {
        self.value().cmp(other.value())
    }
}

/// Prioritized item wrapper
struct PrioritizedItem<T> {
    priority: Priority
    sequence: Int
    data: T
    enqueued_at: Instant
}

impl<T> Ord for PrioritizedItem<T> {
    fn cmp(other: PrioritizedItem<T>) -> Ordering {
        // First compare by priority, then by sequence (FIFO within same priority)
        match self.priority.cmp(other.priority) {
            Ordering.Equal => self.sequence.cmp(other.sequence)
            ord => ord
        }
    }
}

// -----------------------------------------------------------------------------
// Priority Queue
// -----------------------------------------------------------------------------

/// Generic priority queue
struct PriorityQueue<T> {
    heap: MinHeap<PrioritizedItem<T>>
    sequence_counter: Int
    
    fn new() -> Self {
        PriorityQueue {
            heap: MinHeap.new(),
            sequence_counter: 0
        }
    }
    
    /// Push item with priority
    fn push(item: T, priority: Priority) {
        let prioritized = PrioritizedItem {
            priority: priority,
            sequence: self.sequence_counter,
            data: item,
            enqueued_at: Instant.now()
        }
        self.sequence_counter += 1
        self.heap.push(prioritized)
    }
    
    /// Push with default normal priority
    fn push_default(item: T) {
        self.push(item, Priority.Normal)
    }
    
    /// Pop highest priority item
    fn pop() -> Option<T> {
        self.heap.pop().map(|p| p.data)
    }
    
    /// Peek highest priority item
    fn peek() -> Option<T> {
        self.heap.peek().map(|p| p.data.clone())
    }
    
    /// Peek with priority info
    fn peek_with_priority() -> Option<(T, Priority)> {
        self.heap.peek().map(|p| (p.data.clone(), p.priority))
    }
    
    fn len() -> Int { self.heap.len() }
    fn is_empty() -> Bool { self.heap.is_empty() }
    fn clear() { self.heap.clear() }
}

// -----------------------------------------------------------------------------
// Concurrent Priority Queue Actor
// -----------------------------------------------------------------------------

/// Thread-safe priority queue actor
actor ConcurrentPriorityQueue<T> {
    state queue: PriorityQueue<T>
    state waiters: [fn(Option<T>)]
    state closed: Bool
    state max_size: Option<Int>
    
    fn new() -> Self {
        ConcurrentPriorityQueue {
            queue: PriorityQueue.new(),
            waiters: [],
            closed: false,
            max_size: None
        }
    }
    
    fn with_max_size(size: Int) -> Self {
        ConcurrentPriorityQueue {
            queue: PriorityQueue.new(),
            waiters: [],
            closed: false,
            max_size: Some(size)
        }
    }
    
    /// Enqueue with priority
    fn enqueue(item: T, priority: Priority) -> Result<(), QueueError> {
        if self.closed {
            return Err(QueueError.Closed)
        }
        
        if let Some(max) = self.max_size {
            if self.queue.len() >= max {
                return Err(QueueError.Full)
            }
        }
        
        // If there are waiters, deliver directly
        if !self.waiters.is_empty() {
            let waiter = self.waiters.remove(0)
            waiter(Some(item))
            return Ok(())
        }
        
        self.queue.push(item, priority)
        Ok(())
    }
    
    /// Enqueue with normal priority
    fn enqueue_default(item: T) -> Result<(), QueueError> {
        self.enqueue(item, Priority.Normal)
    }
    
    /// Dequeue highest priority item (blocking)
    fn dequeue() -> Option<T> {
        if let Some(item) = self.queue.pop() {
            return Some(item)
        }
        
        if self.closed {
            return None
        }
        
        // Block until item available
        @native("priority_queue_wait", self)
    }
    
    /// Try dequeue without blocking
    fn try_dequeue() -> Option<T> {
        self.queue.pop()
    }
    
    /// Dequeue with timeout
    fn dequeue_timeout(timeout: Duration) -> Option<T> {
        if let Some(item) = self.queue.pop() {
            return Some(item)
        }
        
        if self.closed {
            return None
        }
        
        @native("priority_queue_wait_timeout", self, timeout)
    }
    
    /// Peek without removing
    fn peek() -> Option<T> {
        self.queue.peek()
    }
    
    /// Close the queue
    fn close() {
        self.closed = true
        for waiter in self.waiters {
            waiter(None)
        }
        self.waiters.clear()
    }
    
    fn len() -> Int { self.queue.len() }
    fn is_empty() -> Bool { self.queue.is_empty() }
    fn is_closed() -> Bool { self.closed }
}

// -----------------------------------------------------------------------------
// Priority Message Queue
// -----------------------------------------------------------------------------

/// Priority message with metadata
struct PriorityMessage {
    id: String
    priority: Priority
    payload: [Byte]
    headers: Map<String, String>
    created_at: Instant
    expires_at: Option<Instant>
    retry_count: Int
    max_retries: Int
    
    fn new(payload: [Byte], priority: Priority) -> Self {
        PriorityMessage {
            id: UUID.v4(),
            priority: priority,
            payload: payload,
            headers: Map.empty(),
            created_at: Instant.now(),
            expires_at: None,
            retry_count: 0,
            max_retries: 3
        }
    }
    
    fn text(content: String, priority: Priority) -> Self {
        Self.new(content.bytes(), priority)
    }
    
    fn json<T: Serialize>(data: T, priority: Priority) -> Self {
        let mut msg = Self.new(JSON.stringify(data).bytes(), priority)
        msg.headers.set("content-type", "application/json")
        msg
    }
    
    fn with_ttl(ttl: Duration) -> Self {
        self.expires_at = Some(Instant.now() + ttl)
        self
    }
    
    fn with_max_retries(max: Int) -> Self {
        self.max_retries = max
        self
    }
    
    fn is_expired() -> Bool {
        match self.expires_at {
            Some(exp) => Instant.now() > exp
            None => false
        }
    }
    
    fn can_retry() -> Bool {
        self.retry_count < self.max_retries
    }
    
    fn as_string() -> Result<String, DecodeError> {
        String.from_utf8(self.payload)
    }
    
    fn as_json<T: Deserialize>() -> Result<T, DecodeError> {
        JSON.parse(self.as_string()?)
    }
}

/// Priority message queue actor
actor PriorityMessageQueue {
    state queue: PriorityQueue<PriorityMessage>
    state pending_acks: Map<String, PriorityMessage>
    state dead_letter: Option<DeadLetterQueue>
    state metrics: QueueMetrics
    state closed: Bool
    
    fn new() -> Self {
        PriorityMessageQueue {
            queue: PriorityQueue.new(),
            pending_acks: Map.empty(),
            dead_letter: None,
            metrics: QueueMetrics.new(),
            closed: false
        }
    }
    
    fn with_dead_letter(dlq: DeadLetterQueue) -> Self {
        let mut q = Self.new()
        q.dead_letter = Some(dlq)
        q
    }
    
    /// Send message
    fn send(message: PriorityMessage) -> Result<String, QueueError> {
        if self.closed {
            return Err(QueueError.Closed)
        }
        
        if message.is_expired() {
            self.metrics.expired += 1
            return Err(QueueError.MessageExpired)
        }
        
        let id = message.id.clone()
        self.queue.push(message, message.priority)
        self.metrics.enqueued += 1
        Ok(id)
    }
    
    /// Receive message (blocking)
    fn receive() -> Option<PriorityMessage> {
        loop {
            match self.queue.pop() {
                Some(msg) => {
                    if msg.is_expired() {
                        self.metrics.expired += 1
                        continue
                    }
                    self.pending_acks.set(msg.id.clone(), msg.clone())
                    self.metrics.dequeued += 1
                    return Some(msg)
                }
                None => {
                    if self.closed { return None }
                    @native("yield")
                }
            }
        }
    }
    
    /// Try receive without blocking
    fn try_receive() -> Option<PriorityMessage> {
        while let Some(msg) = self.queue.pop() {
            if msg.is_expired() {
                self.metrics.expired += 1
                continue
            }
            self.pending_acks.set(msg.id.clone(), msg.clone())
            self.metrics.dequeued += 1
            return Some(msg)
        }
        None
    }
    
    /// Acknowledge message
    fn ack(message_id: String) -> Result<(), QueueError> {
        match self.pending_acks.remove(message_id) {
            Some(_) => {
                self.metrics.acknowledged += 1
                Ok(())
            }
            None => Err(QueueError.MessageNotFound)
        }
    }
    
    /// Negative acknowledge (retry or dead letter)
    fn nack(message_id: String, requeue: Bool) -> Result<(), QueueError> {
        match self.pending_acks.remove(message_id) {
            Some(mut msg) => {
                msg.retry_count += 1
                
                if requeue && msg.can_retry() {
                    self.queue.push(msg, msg.priority)
                    self.metrics.requeued += 1
                } else if let Some(dlq) = self.dead_letter {
                    dlq.send(msg, "max_retries_exceeded")
                    self.metrics.dead_lettered += 1
                }
                
                Ok(())
            }
            None => Err(QueueError.MessageNotFound)
        }
    }
    
    /// Get queue metrics
    fn metrics() -> QueueMetrics {
        self.metrics.clone()
    }
    
    fn close() {
        self.closed = true
    }
    
    fn len() -> Int { self.queue.len() }
    fn pending_count() -> Int { self.pending_acks.len() }
}

/// Queue metrics
struct QueueMetrics {
    enqueued: Int
    dequeued: Int
    acknowledged: Int
    requeued: Int
    expired: Int
    dead_lettered: Int
    
    fn new() -> Self {
        QueueMetrics {
            enqueued: 0,
            dequeued: 0,
            acknowledged: 0,
            requeued: 0,
            expired: 0,
            dead_lettered: 0
        }
    }
}

// -----------------------------------------------------------------------------
// Multi-Level Priority Queue
// -----------------------------------------------------------------------------

/// Multi-level feedback queue with aging
actor MultiLevelPriorityQueue<T> {
    state levels: [Deque<(T, Instant)>; 5]  // 5 priority levels
    state aging_threshold: Duration
    state closed: Bool
    
    fn new() -> Self {
        MultiLevelPriorityQueue {
            levels: [Deque.new(); 5],
            aging_threshold: Duration.seconds(30),
            closed: false
        }
    }
    
    fn with_aging_threshold(threshold: Duration) -> Self {
        let mut q = Self.new()
        q.aging_threshold = threshold
        q
    }
    
    /// Enqueue with priority
    fn enqueue(item: T, priority: Priority) -> Result<(), QueueError> {
        if self.closed {
            return Err(QueueError.Closed)
        }
        
        let level = priority.value()
        self.levels[level].push_back((item, Instant.now()))
        Ok(())
    }
    
    /// Dequeue with aging promotion
    fn dequeue() -> Option<T> {
        // Apply aging - promote old items to higher priority
        self.apply_aging()
        
        // Dequeue from highest priority non-empty level
        for level in 0..5 {
            if let Some((item, _)) = self.levels[level].pop_front() {
                return Some(item)
            }
        }
        
        None
    }
    
    /// Apply aging to prevent starvation
    fn apply_aging() {
        let now = Instant.now()
        
        // Check levels from low to high priority (skip highest)
        for level in (1..5).rev() {
            let mut promoted = []
            
            // Check items at front of queue
            while let Some((item, enqueued)) = self.levels[level].front() {
                if now - enqueued > self.aging_threshold {
                    self.levels[level].pop_front()
                    promoted.push(item)
                } else {
                    break
                }
            }
            
            // Promote to next higher priority level
            for item in promoted {
                self.levels[level - 1].push_back((item, now))
            }
        }
    }
    
    fn len() -> Int {
        self.levels.iter().map(|l| l.len()).sum()
    }
    
    fn len_at_level(priority: Priority) -> Int {
        self.levels[priority.value()].len()
    }
    
    fn close() {
        self.closed = true
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum QueueError {
    Closed
    Full
    Empty
    MessageNotFound
    MessageExpired
    Timeout
    
    fn message() -> String {
        match self {
            Closed => "Queue is closed"
            Full => "Queue is full"
            Empty => "Queue is empty"
            MessageNotFound => "Message not found"
            MessageExpired => "Message has expired"
            Timeout => "Operation timed out"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "priority ordering" {
    var pq = PriorityQueue::<String>.new()
    
    pq.push("low", Priority.Low)
    pq.push("critical", Priority.Critical)
    pq.push("normal", Priority.Normal)
    pq.push("high", Priority.High)
    
    assert_eq(pq.pop(), Some("critical"))?
    assert_eq(pq.pop(), Some("high"))?
    assert_eq(pq.pop(), Some("normal"))?
    assert_eq(pq.pop(), Some("low"))?
}

test "fifo within same priority" {
    var pq = PriorityQueue::<Int>.new()
    
    pq.push(1, Priority.Normal)
    pq.push(2, Priority.Normal)
    pq.push(3, Priority.Normal)
    
    assert_eq(pq.pop(), Some(1))?
    assert_eq(pq.pop(), Some(2))?
    assert_eq(pq.pop(), Some(3))?
}

test "priority message" {
    let msg = PriorityMessage.text("hello", Priority.High)
    assert_eq(msg.priority, Priority.High)?
    assert_eq(msg.as_string()?, "hello")?
}

test "message expiration" {
    let msg = PriorityMessage.text("test", Priority.Normal)
        .with_ttl(Duration.milliseconds(1))
    
    // Wait for expiration
    @native("sleep", Duration.milliseconds(10))
    
    assert(msg.is_expired())?
}

test "concurrent priority queue" {
    let pq = ConcurrentPriorityQueue::<Int>.new()
    
    pq.enqueue(1, Priority.Low)?
    pq.enqueue(2, Priority.High)?
    pq.enqueue(3, Priority.Normal)?
    
    assert_eq(pq.try_dequeue(), Some(2))?
    assert_eq(pq.try_dequeue(), Some(3))?
    assert_eq(pq.try_dequeue(), Some(1))?
}
