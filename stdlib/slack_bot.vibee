// =============================================================================
// Vibee OS â€” Slack Bot Module
// Slack Bot API client with Events API and Web API support
// =============================================================================

use http::{Client as HttpClient, Request, Response}
use websocket::{WebSocket, Message as WsMessage}
use json::{JsonValue, Serialize, Deserialize}
use result::{Result, Ok, Err}

// =============================================================================
// Core Types
// =============================================================================

/// Slack event types
enum EventType {
    Message, AppMention, ReactionAdded, ReactionRemoved, MemberJoinedChannel, MemberLeftChannel,
    ChannelCreated, ChannelDeleted, ChannelRenamed, FileShared, AppHomeOpened, UrlVerification
}

impl EventType {
    fn from_str(s: String) -> Option<Self> {
        match s {
            "message" => Some(EventType.Message), "app_mention" => Some(EventType.AppMention),
            "reaction_added" => Some(EventType.ReactionAdded), "reaction_removed" => Some(EventType.ReactionRemoved),
            "member_joined_channel" => Some(EventType.MemberJoinedChannel), "member_left_channel" => Some(EventType.MemberLeftChannel),
            "channel_created" => Some(EventType.ChannelCreated), "channel_deleted" => Some(EventType.ChannelDeleted),
            "channel_renamed" => Some(EventType.ChannelRenamed), "file_shared" => Some(EventType.FileShared),
            "app_home_opened" => Some(EventType.AppHomeOpened), "url_verification" => Some(EventType.UrlVerification),
            _ => None
        }
    }
}

/// Channel types
enum ChannelType { Public, Private, DirectMessage, MultiPartyDM }

// =============================================================================
// Slack Entities
// =============================================================================

/// Slack User
struct User { id: String, team_id: String, name: String, real_name: String, display_name: String, email: Option<String>, is_bot: Bool, is_admin: Bool, tz: Option<String> }

impl User {
    fn mention() -> String { format!("<@{}>", self.id) }
}

/// Slack Channel
struct Channel { id: String, name: String, is_channel: Bool, is_private: Bool, is_im: Bool, is_mpim: Bool, topic: Option<ChannelTopic>, purpose: Option<ChannelPurpose> }

impl Channel {
    fn mention() -> String { format!("<#{}>", self.id) }
    fn channel_type() -> ChannelType {
        if self.is_im { ChannelType.DirectMessage }
        else if self.is_mpim { ChannelType.MultiPartyDM }
        else if self.is_private { ChannelType.Private }
        else { ChannelType.Public }
    }
}

struct ChannelTopic { value: String, creator: String, last_set: Int64 }
struct ChannelPurpose { value: String, creator: String, last_set: Int64 }

/// Slack Message
struct Message {
    ts: String, channel: String, user: Option<String>, text: String, thread_ts: Option<String>,
    reply_count: Option<Int>, reactions: [Reaction], attachments: [Attachment], blocks: [Block]
}

impl Message {
    fn is_thread_reply() -> Bool { self.thread_ts.is_some() && self.thread_ts != Some(self.ts.clone()) }
    fn is_thread_parent() -> Bool { self.reply_count.map(|c| c > 0).unwrap_or(false) }
    fn get_thread_ts() -> String { self.thread_ts.clone().unwrap_or(self.ts.clone()) }
}

/// Reaction
struct Reaction { name: String, count: Int, users: [String] }

/// File attachment
struct Attachment { fallback: String, color: Option<String>, pretext: Option<String>, author_name: Option<String>, title: Option<String>, text: Option<String>, image_url: Option<String>, footer: Option<String> }

impl Attachment {
    fn new() -> Self { Attachment { fallback: "", color: None, pretext: None, author_name: None, title: None, text: None, image_url: None, footer: None } }
    fn fallback(text: String) -> Self { self.fallback = text; self }
    fn color(c: String) -> Self { self.color = Some(c); self }
    fn title(t: String) -> Self { self.title = Some(t); self }
    fn text(t: String) -> Self { self.text = Some(t); self }
    fn author(name: String) -> Self { self.author_name = Some(name); self }
    fn image(url: String) -> Self { self.image_url = Some(url); self }
    fn footer(f: String) -> Self { self.footer = Some(f); self }
}

// =============================================================================
// Block Kit
// =============================================================================

/// Block types
enum Block {
    Section(SectionBlock), Divider, Image(ImageBlock), Actions(ActionsBlock),
    Context(ContextBlock), Header(HeaderBlock), Input(InputBlock)
}

impl Block {
    fn section(text: String) -> Self { Block.Section(SectionBlock { text: TextObject.markdown(text), accessory: None, fields: [] }) }
    fn divider() -> Self { Block.Divider }
    fn header(text: String) -> Self { Block.Header(HeaderBlock { text: TextObject.plain(text) }) }
    fn image(url: String, alt_text: String) -> Self { Block.Image(ImageBlock { image_url: url, alt_text: alt_text, title: None }) }
    fn actions(elements: [BlockElement]) -> Self { Block.Actions(ActionsBlock { elements: elements }) }
    fn context(elements: [ContextElement]) -> Self { Block.Context(ContextBlock { elements: elements }) }
}

struct SectionBlock { text: TextObject, accessory: Option<BlockElement>, fields: [TextObject] }
struct ImageBlock { image_url: String, alt_text: String, title: Option<TextObject> }
struct ActionsBlock { elements: [BlockElement] }
struct ContextBlock { elements: [ContextElement] }
struct HeaderBlock { text: TextObject }
struct InputBlock { label: TextObject, element: BlockElement, hint: Option<TextObject>, optional: Bool }

/// Text object
struct TextObject { text_type: String, text: String, emoji: Bool }

impl TextObject {
    fn plain(text: String) -> Self { TextObject { text_type: "plain_text", text: text, emoji: true } }
    fn markdown(text: String) -> Self { TextObject { text_type: "mrkdwn", text: text, emoji: false } }
}

/// Block elements
enum BlockElement {
    Button(ButtonElement), StaticSelect(SelectElement), ExternalSelect(SelectElement),
    UsersSelect(UsersSelectElement), ConversationsSelect(ConversationsSelectElement),
    DatePicker(DatePickerElement), TimePicker(TimePickerElement), Overflow(OverflowElement)
}

struct ButtonElement { text: TextObject, action_id: String, value: Option<String>, url: Option<String>, style: Option<String> }
struct SelectElement { placeholder: TextObject, action_id: String, options: [OptionObject] }
struct UsersSelectElement { placeholder: TextObject, action_id: String, initial_user: Option<String> }
struct ConversationsSelectElement { placeholder: TextObject, action_id: String, initial_conversation: Option<String> }
struct DatePickerElement { action_id: String, placeholder: Option<TextObject>, initial_date: Option<String> }
struct TimePickerElement { action_id: String, placeholder: Option<TextObject>, initial_time: Option<String> }
struct OverflowElement { action_id: String, options: [OptionObject] }
struct OptionObject { text: TextObject, value: String }

impl BlockElement {
    fn button(text: String, action_id: String, value: String) -> Self {
        BlockElement.Button(ButtonElement { text: TextObject.plain(text), action_id: action_id, value: Some(value), url: None, style: None })
    }
    fn primary_button(text: String, action_id: String, value: String) -> Self {
        BlockElement.Button(ButtonElement { text: TextObject.plain(text), action_id: action_id, value: Some(value), url: None, style: Some("primary") })
    }
    fn danger_button(text: String, action_id: String, value: String) -> Self {
        BlockElement.Button(ButtonElement { text: TextObject.plain(text), action_id: action_id, value: Some(value), url: None, style: Some("danger") })
    }
    fn link_button(text: String, url: String) -> Self {
        BlockElement.Button(ButtonElement { text: TextObject.plain(text), action_id: "link", value: None, url: Some(url), style: None })
    }
}

enum ContextElement { Text(TextObject), Image { image_url: String, alt_text: String } }

// =============================================================================
// Events
// =============================================================================

/// Slack event wrapper
struct SlackEvent { token: String, team_id: String, event: EventPayload, event_id: String, event_time: Int64 }

/// Event payload
enum EventPayload {
    Message(MessageEvent), AppMention(AppMentionEvent), ReactionAdded(ReactionEvent),
    ReactionRemoved(ReactionEvent), MemberJoined(MemberEvent), MemberLeft(MemberEvent),
    ChannelCreated(ChannelEvent), AppHomeOpened(AppHomeEvent), Unknown(JsonValue)
}

struct MessageEvent { channel: String, user: String, text: String, ts: String, thread_ts: Option<String>, subtype: Option<String> }
struct AppMentionEvent { channel: String, user: String, text: String, ts: String }
struct ReactionEvent { user: String, reaction: String, item_user: String, item: ReactionItem }
struct ReactionItem { item_type: String, channel: String, ts: String }
struct MemberEvent { user: String, channel: String, inviter: Option<String> }
struct ChannelEvent { channel: ChannelInfo }
struct ChannelInfo { id: String, name: String, creator: String }
struct AppHomeEvent { user: String, channel: String, tab: String }

/// Interaction payload (buttons, selects, etc.)
struct InteractionPayload {
    interaction_type: String, trigger_id: String, user: InteractionUser, channel: InteractionChannel,
    actions: [InteractionAction], response_url: String, message: Option<Message>
}

struct InteractionUser { id: String, username: String, name: String }
struct InteractionChannel { id: String, name: String }
struct InteractionAction { action_id: String, block_id: String, value: Option<String>, selected_option: Option<OptionObject> }

// =============================================================================
// Bot Client
// =============================================================================

/// Slack API error
enum SlackError { NetworkError(String), ApiError { code: String, message: String }, RateLimited(Int), InvalidToken }

/// Slack Bot client
actor SlackBot {
    state bot_token: String
    state app_token: Option<String>
    state signing_secret: String
    state api_url: String
    state http: HttpClient
    state ws: Option<WebSocket>
    state message_handlers: [fn(MessageEvent) -> ()]
    state mention_handlers: [fn(AppMentionEvent) -> ()]
    state reaction_handlers: [fn(ReactionEvent) -> ()]
    state action_handlers: Map<String, fn(InteractionPayload, InteractionAction) -> ()>
    state command_handlers: Map<String, fn(MessageEvent) -> ()>
    state prefix: String
    
    fn new(bot_token: String, signing_secret: String) -> Self {
        SlackBot {
            bot_token: bot_token, app_token: None, signing_secret: signing_secret,
            api_url: "https://slack.com/api", http: HttpClient.new().timeout(30000),
            ws: None, message_handlers: [], mention_handlers: [], reaction_handlers: [],
            action_handlers: Map.new(), command_handlers: Map.new(), prefix: "!"
        }
    }
    
    fn with_socket_mode(bot_token: String, app_token: String, signing_secret: String) -> Self {
        let mut bot = Self.new(bot_token, signing_secret);
        bot.app_token = Some(app_token);
        bot
    }
    
    fn set_prefix(prefix: String) -> Self { self.prefix = prefix; self }
    
    // -------------------------------------------------------------------------
    // Web API Methods
    // -------------------------------------------------------------------------
    
    fn api_call<T: Deserialize>(method: String, params: JsonValue) -> Result<T, SlackError> {
        let url = format!("{}/{}", self.api_url, method);
        let response = self.http.send(
            Request.post(url).header("Authorization", format!("Bearer {}", self.bot_token)).json(params)
        ).map_err(|e| SlackError.NetworkError(e.to_string()))?;
        
        if response.status.code == 429 {
            let retry_after = response.headers.get("Retry-After").and_then(|s| Int.parse(s).ok()).unwrap_or(5);
            return Err(SlackError.RateLimited(retry_after));
        }
        
        let body: JsonValue = response.json().map_err(|e| SlackError.NetworkError(e.to_string()))?;
        if !body["ok"].as_bool().unwrap_or(false) {
            return Err(SlackError.ApiError { code: body["error"].as_str().unwrap_or("unknown").to_string(), message: body["error"].as_str().unwrap_or("").to_string() });
        }
        json::from_value(body).map_err(|e| SlackError.NetworkError(e.to_string()))
    }
    
    fn auth_test() -> Result<AuthTestResponse, SlackError> { self.api_call("auth.test", {}) }
    
    fn post_message(channel: String, text: String) -> Result<PostMessageResponse, SlackError> {
        self.api_call("chat.postMessage", { "channel": channel, "text": text })
    }
    
    fn post_message_with_blocks(channel: String, text: String, blocks: [Block]) -> Result<PostMessageResponse, SlackError> {
        self.api_call("chat.postMessage", { "channel": channel, "text": text, "blocks": blocks })
    }
    
    fn post_ephemeral(channel: String, user: String, text: String) -> Result<PostMessageResponse, SlackError> {
        self.api_call("chat.postEphemeral", { "channel": channel, "user": user, "text": text })
    }
    
    fn reply_in_thread(channel: String, thread_ts: String, text: String) -> Result<PostMessageResponse, SlackError> {
        self.api_call("chat.postMessage", { "channel": channel, "thread_ts": thread_ts, "text": text })
    }
    
    fn update_message(channel: String, ts: String, text: String) -> Result<UpdateMessageResponse, SlackError> {
        self.api_call("chat.update", { "channel": channel, "ts": ts, "text": text })
    }
    
    fn delete_message(channel: String, ts: String) -> Result<(), SlackError> {
        self.api_call("chat.delete", { "channel": channel, "ts": ts })
    }
    
    fn add_reaction(channel: String, timestamp: String, name: String) -> Result<(), SlackError> {
        self.api_call("reactions.add", { "channel": channel, "timestamp": timestamp, "name": name })
    }
    
    fn remove_reaction(channel: String, timestamp: String, name: String) -> Result<(), SlackError> {
        self.api_call("reactions.remove", { "channel": channel, "timestamp": timestamp, "name": name })
    }
    
    fn get_user_info(user_id: String) -> Result<UserInfoResponse, SlackError> {
        self.api_call("users.info", { "user": user_id })
    }
    
    fn get_channel_info(channel_id: String) -> Result<ChannelInfoResponse, SlackError> {
        self.api_call("conversations.info", { "channel": channel_id })
    }
    
    fn list_channels() -> Result<ChannelListResponse, SlackError> {
        self.api_call("conversations.list", { "types": "public_channel,private_channel" })
    }
    
    fn open_dm(user_id: String) -> Result<OpenDMResponse, SlackError> {
        self.api_call("conversations.open", { "users": user_id })
    }
    
    fn upload_file(channels: [String], content: String, filename: String, title: Option<String>) -> Result<FileUploadResponse, SlackError> {
        let mut params = { "channels": channels.join(","), "content": content, "filename": filename };
        if let Some(t) = title { params["title"] = t; }
        self.api_call("files.upload", params)
    }
    
    // -------------------------------------------------------------------------
    // Modals and Views
    // -------------------------------------------------------------------------
    
    fn open_modal(trigger_id: String, view: ModalView) -> Result<(), SlackError> {
        self.api_call("views.open", { "trigger_id": trigger_id, "view": view })
    }
    
    fn update_modal(view_id: String, view: ModalView) -> Result<(), SlackError> {
        self.api_call("views.update", { "view_id": view_id, "view": view })
    }
    
    fn publish_home_tab(user_id: String, view: HomeTabView) -> Result<(), SlackError> {
        self.api_call("views.publish", { "user_id": user_id, "view": view })
    }
    
    // -------------------------------------------------------------------------
    // Event Handlers
    // -------------------------------------------------------------------------
    
    fn on_message(handler: fn(MessageEvent) -> ()) -> Self { self.message_handlers.push(handler); self }
    fn on_mention(handler: fn(AppMentionEvent) -> ()) -> Self { self.mention_handlers.push(handler); self }
    fn on_reaction(handler: fn(ReactionEvent) -> ()) -> Self { self.reaction_handlers.push(handler); self }
    fn on_action(action_id: String, handler: fn(InteractionPayload, InteractionAction) -> ()) -> Self { self.action_handlers.insert(action_id, handler); self }
    fn on_command(command: String, handler: fn(MessageEvent) -> ()) -> Self { self.command_handlers.insert(command, handler); self }
    
    fn process_event(event: SlackEvent) {
        match event.event {
            EventPayload.Message(msg) => {
                if msg.subtype.is_none() {
                    // Check for commands
                    if msg.text.starts_with(self.prefix) {
                        let cmd = msg.text.strip_prefix(self.prefix).and_then(|s| s.split_whitespace().first().map(|c| c.to_string()));
                        if let Some(c) = cmd {
                            if let Some(handler) = self.command_handlers.get(&c) { handler(msg.clone()); return; }
                        }
                    }
                    for handler in self.message_handlers.iter() { handler(msg.clone()); }
                }
            },
            EventPayload.AppMention(mention) => {
                for handler in self.mention_handlers.iter() { handler(mention.clone()); }
            },
            EventPayload.ReactionAdded(reaction) | EventPayload.ReactionRemoved(reaction) => {
                for handler in self.reaction_handlers.iter() { handler(reaction.clone()); }
            },
            _ => {}
        }
    }
    
    fn process_interaction(payload: InteractionPayload) {
        for action in payload.actions.iter() {
            if let Some(handler) = self.action_handlers.get(&action.action_id) {
                handler(payload.clone(), action.clone());
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // Request Verification
    // -------------------------------------------------------------------------
    
    fn verify_request(timestamp: String, body: String, signature: String) -> Bool {
        let base_string = format!("v0:{}:{}", timestamp, body);
        let expected = format!("v0={}", crypto::hmac_sha256_hex(self.signing_secret.as_bytes(), base_string.as_bytes()));
        crypto::constant_time_eq(signature.as_bytes(), expected.as_bytes())
    }
    
    // -------------------------------------------------------------------------
    // Socket Mode
    // -------------------------------------------------------------------------
    
    fn connect_socket_mode() -> Result<(), SlackError> {
        let app_token = self.app_token.clone().ok_or(SlackError.InvalidToken)?;
        let response = self.http.send(
            Request.post(format!("{}/apps.connections.open", self.api_url))
                .header("Authorization", format!("Bearer {}", app_token))
                .json({})
        ).map_err(|e| SlackError.NetworkError(e.to_string()))?;
        
        let body: JsonValue = response.json().map_err(|e| SlackError.NetworkError(e.to_string()))?;
        let ws_url = body["url"].as_str().ok_or(SlackError.NetworkError("No WebSocket URL".to_string()))?;
        self.ws = Some(WebSocket.connect(ws_url).map_err(|e| SlackError.NetworkError(e.to_string()))?);
        Ok(())
    }
    
    fn run_socket_mode() -> Result<(), SlackError> {
        self.connect_socket_mode()?;
        loop {
            if let Some(ws) = self.ws.as_mut() {
                while let Some(msg) = ws.try_recv() {
                    if let WsMessage.Text(text) = msg {
                        if let Ok(envelope) = json::decode::<JsonValue>(text) {
                            let envelope_id = envelope["envelope_id"].as_str();
                            // Acknowledge the event
                            if let Some(id) = envelope_id {
                                ws.send(WsMessage.Text(json::encode({ "envelope_id": id })));
                            }
                            // Process the event
                            let event_type = envelope["type"].as_str().unwrap_or("");
                            match event_type {
                                "events_api" => {
                                    if let Ok(event) = json::from_value::<SlackEvent>(envelope["payload"].clone()) {
                                        self.process_event(event);
                                    }
                                },
                                "interactive" => {
                                    if let Ok(payload) = json::from_value::<InteractionPayload>(envelope["payload"].clone()) {
                                        self.process_interaction(payload);
                                    }
                                },
                                _ => {}
                            }
                        }
                    }
                }
            }
            @native("sleep_ms", 100);
        }
    }
}

// =============================================================================
// Response Types
// =============================================================================

struct AuthTestResponse { ok: Bool, url: String, team: String, user: String, team_id: String, user_id: String, bot_id: Option<String> }
struct PostMessageResponse { ok: Bool, channel: String, ts: String, message: Message }
struct UpdateMessageResponse { ok: Bool, channel: String, ts: String, text: String }
struct UserInfoResponse { ok: Bool, user: User }
struct ChannelInfoResponse { ok: Bool, channel: Channel }
struct ChannelListResponse { ok: Bool, channels: [Channel] }
struct OpenDMResponse { ok: Bool, channel: Channel }
struct FileUploadResponse { ok: Bool, file: FileInfo }
struct FileInfo { id: String, name: String, url_private: String }

// =============================================================================
// Modal and Home Tab Views
// =============================================================================

struct ModalView { view_type: String, title: TextObject, submit: Option<TextObject>, close: Option<TextObject>, blocks: [Block], private_metadata: Option<String>, callback_id: Option<String> }

impl ModalView {
    fn new(title: String) -> Self {
        ModalView { view_type: "modal", title: TextObject.plain(title), submit: None, close: None, blocks: [], private_metadata: None, callback_id: None }
    }
    fn submit(text: String) -> Self { self.submit = Some(TextObject.plain(text)); self }
    fn close(text: String) -> Self { self.close = Some(TextObject.plain(text)); self }
    fn block(b: Block) -> Self { self.blocks.push(b); self }
    fn callback_id(id: String) -> Self { self.callback_id = Some(id); self }
}

struct HomeTabView { view_type: String, blocks: [Block] }

impl HomeTabView {
    fn new() -> Self { HomeTabView { view_type: "home", blocks: [] } }
    fn block(b: Block) -> Self { self.blocks.push(b); self }
}

// =============================================================================
// Tests
// =============================================================================

test "user mention" {
    let user = User { id: "U123", team_id: "T456", name: "testuser", real_name: "Test User", display_name: "Test", email: None, is_bot: false, is_admin: false, tz: None };
    assert_eq(user.mention(), "<@U123>")?
}

test "channel mention" {
    let channel = Channel { id: "C123", name: "general", is_channel: true, is_private: false, is_im: false, is_mpim: false, topic: None, purpose: None };
    assert_eq(channel.mention(), "<#C123>")?
}

test "text object" {
    let plain = TextObject.plain("Hello");
    let mrkdwn = TextObject.markdown("*Bold*");
    assert_eq(plain.text_type, "plain_text")?
    assert_eq(mrkdwn.text_type, "mrkdwn")?
}

test "block builder" {
    let section = Block.section("Hello *world*");
    let divider = Block.divider();
    let header = Block.header("Title");
    assert(matches!(section, Block.Section(_)))?
    assert(matches!(divider, Block.Divider))?
}

test "button element" {
    let btn = BlockElement.primary_button("Click me", "btn_click", "clicked");
    assert(matches!(btn, BlockElement.Button(_)))?
}

test "modal view builder" {
    let modal = ModalView.new("My Modal").submit("Submit").close("Cancel").block(Block.section("Content"));
    assert_eq(modal.title.text, "My Modal")?
    assert_eq(modal.blocks.len(), 1)?
}
