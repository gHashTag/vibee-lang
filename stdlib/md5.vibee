// =============================================================================
// Vibee OS â€” MD5 Module
// MD5 cryptographic hash function (RFC 1321)
// =============================================================================
//
// WARNING: MD5 is cryptographically broken and should NOT be used for security
// purposes. Use SHA-256 or BLAKE3 for security-critical applications.
// MD5 is provided for legacy compatibility and non-security use cases like
// checksums and cache keys.
// =============================================================================

const DIGEST_SIZE: Int = 16
const BLOCK_SIZE: Int = 64

// Initial hash values (little-endian)
const H0: UInt32 = 0x67452301
const H1: UInt32 = 0xefcdab89
const H2: UInt32 = 0x98badcfe
const H3: UInt32 = 0x10325476

// Per-round shift amounts
const S: [Int; 64] = [
    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
]

// Pre-computed constants (floor(2^32 * abs(sin(i + 1))))
const K: [UInt32; 64] = [
    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
    0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
    0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
    0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
    0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
    0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
]

// =============================================================================
// Core Functions
// =============================================================================

/// Compute MD5 hash of byte array
fn hash(data: [UInt8]) -> [UInt8; 16] {
    @native("md5", data)
}

/// Compute MD5 hash and return as hex string
fn hash_hex(data: [UInt8]) -> String {
    hex.encode(hash(data))
}

/// Compute MD5 hash of string
fn hash_string(s: String) -> [UInt8; 16] {
    hash(s.as_bytes())
}

/// Compute MD5 hash of string and return as hex string
fn hash_string_hex(s: String) -> String {
    hex.encode(hash_string(s))
}

/// Compute MD5 hash of file
fn hash_file(path: String) -> Result<[UInt8; 16], Md5Error> {
    let data = fs.read_bytes(path).map_err(|e| Md5Error.IoError(e.to_string()))?
    Ok(hash(data))
}

/// Compute MD5 hash of file and return as hex string
fn hash_file_hex(path: String) -> Result<String, Md5Error> {
    Ok(hex.encode(hash_file(path)?))
}

// =============================================================================
// MD5 Digest Struct
// =============================================================================

/// Fixed-size MD5 digest (16 bytes / 128 bits)
struct Md5Digest {
    bytes: [UInt8; 16]
}

impl Md5Digest {
    /// Create digest from bytes
    fn from_bytes(bytes: [UInt8; 16]) -> Self {
        Md5Digest { bytes: bytes }
    }
    
    /// Create digest from hex string
    fn from_hex(s: String) -> Result<Self, Md5Error> {
        let bytes = hex.decode(s).map_err(|_| Md5Error.InvalidHex)?
        if bytes.len() != 16 {
            return Err(Md5Error.InvalidLength)
        }
        Ok(Md5Digest { bytes: bytes.try_into().unwrap() })
    }
    
    /// Get bytes
    fn as_bytes() -> [UInt8; 16] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to uppercase hex string
    fn to_hex_upper() -> String {
        hex.encode_upper(self.bytes)
    }
    
    /// Compare digests in constant time
    fn eq(other: Md5Digest) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
}

impl Display for Md5Digest {
    fn fmt(f: Formatter) {
        f.write(self.to_hex())
    }
}

impl Hash for Md5Digest {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

// =============================================================================
// Incremental Hasher
// =============================================================================

/// Incremental MD5 hasher for streaming data
struct Md5Hasher {
    inner: @native("Md5Hasher")
}

impl Md5Hasher {
    /// Create new MD5 hasher
    fn new() -> Self {
        Md5Hasher { inner: @native("md5_hasher_new") }
    }
    
    /// Update hasher with data
    fn update(data: [UInt8]) -> Self {
        @native("md5_hasher_update", self.inner, data)
        self
    }
    
    /// Update hasher with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Finalize and get digest
    fn finalize() -> Md5Digest {
        let bytes = @native("md5_hasher_finalize", self.inner)
        Md5Digest { bytes: bytes }
    }
    
    /// Finalize and get hex string
    fn finalize_hex() -> String {
        self.finalize().to_hex()
    }
    
    /// Reset hasher for reuse
    fn reset() {
        @native("md5_hasher_reset", self.inner)
    }
    
    /// Clone hasher state
    fn clone() -> Self {
        Md5Hasher { inner: @native("md5_hasher_clone", self.inner) }
    }
}

// =============================================================================
// Streaming Actor
// =============================================================================

/// Actor for streaming MD5 computation
actor Md5Stream {
    state hasher: Md5Hasher
    state total_bytes: Int
    
    fn new() -> Self {
        Md5Stream { hasher: Md5Hasher.new(), total_bytes: 0 }
    }
    
    /// Write data to stream
    fn write(data: [UInt8]) {
        self.hasher.update(data)
        self.total_bytes += data.len()
    }
    
    /// Write string to stream
    fn write_str(s: String) {
        self.write(s.as_bytes())
    }
    
    /// Get current byte count
    fn bytes_processed() -> Int {
        self.total_bytes
    }
    
    /// Finalize and get digest
    fn finalize() -> Md5Digest {
        self.hasher.finalize()
    }
    
    /// Reset stream
    fn reset() {
        self.hasher.reset()
        self.total_bytes = 0
    }
}

// =============================================================================
// HMAC-MD5
// =============================================================================

/// Compute HMAC-MD5
fn hmac(key: [UInt8], data: [UInt8]) -> [UInt8; 16] {
    @native("hmac_md5", key, data)
}

/// Compute HMAC-MD5 and return as hex string
fn hmac_hex(key: [UInt8], data: [UInt8]) -> String {
    hex.encode(hmac(key, data))
}

/// HMAC-MD5 with string inputs
fn hmac_string(key: String, data: String) -> [UInt8; 16] {
    hmac(key.as_bytes(), data.as_bytes())
}

// =============================================================================
// Verification
// =============================================================================

/// Verify data against expected MD5 hash (hex string)
fn verify(data: [UInt8], expected_hex: String) -> Bool {
    let computed = hash_hex(data)
    crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes())
}

/// Verify string against expected MD5 hash
fn verify_string(s: String, expected_hex: String) -> Bool {
    verify(s.as_bytes(), expected_hex)
}

/// Verify file against expected MD5 hash
fn verify_file(path: String, expected_hex: String) -> Result<Bool, Md5Error> {
    let computed = hash_file_hex(path)?
    Ok(crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes()))
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Check if string is valid MD5 hex hash
fn is_valid_hash(s: String) -> Bool {
    s.len() == 32 && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Parse MD5 hash from various formats
fn parse(s: String) -> Result<Md5Digest, Md5Error> {
    let s = s.trim().to_lowercase()
    
    // Remove common prefixes
    let s = if s.starts_with("md5:") { s[4..] } else { s }
    let s = if s.starts_with("0x") { s[2..] } else { s }
    
    Md5Digest.from_hex(s)
}

/// Format digest with prefix
fn format_with_prefix(digest: Md5Digest) -> String {
    format!("md5:{}", digest.to_hex())
}

// =============================================================================
// Errors
// =============================================================================

enum Md5Error {
    InvalidHex
    InvalidLength
    IoError(String)
}

impl Display for Md5Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidLength => f.write("Invalid MD5 hash length (expected 16 bytes)")
            IoError(s) => f.write(format!("I/O error: {}", s))
        }
    }
}

// =============================================================================
// Trait Implementations
// =============================================================================

trait Md5Hashable {
    fn md5() -> Md5Digest
}

impl Md5Hashable for [UInt8] {
    fn md5() -> Md5Digest {
        Md5Digest { bytes: hash(self) }
    }
}

impl Md5Hashable for String {
    fn md5() -> Md5Digest {
        Md5Digest { bytes: hash_string(self) }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "empty string" {
    assert_eq(hash_string_hex(""), "d41d8cd98f00b204e9800998ecf8427e")?
}

test "hello world" {
    assert_eq(hash_string_hex("hello"), "5d41402abc4b2a76b9719d911017c592")?
    assert_eq(hash_string_hex("Hello, World!"), "65a8e27d8879283831b664bd8b7f0ad4")?
}

test "incremental hashing" {
    var hasher = Md5Hasher.new()
    hasher.update_str("hello")
    hasher.update_str(" ")
    hasher.update_str("world")
    assert_eq(hasher.finalize_hex(), hash_string_hex("hello world"))?
}

test "digest from hex" {
    let digest = Md5Digest.from_hex("d41d8cd98f00b204e9800998ecf8427e")?
    assert_eq(digest.to_hex(), "d41d8cd98f00b204e9800998ecf8427e")?
}

test "verify" {
    assert(verify_string("hello", "5d41402abc4b2a76b9719d911017c592"))?
    assert(!verify_string("hello", "0000000000000000000000000000000"))?
}

test "is_valid_hash" {
    assert(is_valid_hash("d41d8cd98f00b204e9800998ecf8427e"))?
    assert(!is_valid_hash("invalid"))?
    assert(!is_valid_hash("d41d8cd98f00b204e9800998ecf8427"))?  // Too short
}

test "hmac" {
    let mac = hmac_string("key", "message")
    assert_eq(mac.len(), 16)?
}

test "streaming actor" {
    var stream = Md5Stream.new()
    stream.write_str("hello")
    stream.write_str(" world")
    assert_eq(stream.bytes_processed(), 11)?
    assert_eq(stream.finalize().to_hex(), hash_string_hex("hello world"))?
}

test "trait implementation" {
    let digest = "hello".md5()
    assert_eq(digest.to_hex(), "5d41402abc4b2a76b9719d911017c592")?
}
