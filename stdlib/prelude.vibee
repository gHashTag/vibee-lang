// =============================================================================
// Vibee OS â€” Prelude Module
// Automatically imported types and traits for every Vibee program
// =============================================================================

// -----------------------------------------------------------------------------
// Core Type Re-exports (automatically available in every module)
// -----------------------------------------------------------------------------

pub use core.{
    // Primitive types
    Bool, Int, Int8, Int16, Int32, Int64,
    UInt, UInt8, UInt16, UInt32, UInt64,
    Float, Float32, Float64,
    Char, String, Str,
    
    // Fundamental types
    Option, Some, None,
    Result, Ok, Err,
    
    // Collections
    Vec, Array, Map, Set, HashMap, HashSet,
    
    // Smart pointers
    Box, Rc, Arc, Weak,
    
    // Ranges
    Range, RangeInclusive, RangeFull,
    
    // Unit and Never types
    Unit, Never
}

// -----------------------------------------------------------------------------
// Core Traits (automatically implemented or available)
// -----------------------------------------------------------------------------

pub use core.traits.{
    // Comparison
    Eq, PartialEq,
    Ord, PartialOrd,
    
    // Conversion
    From, Into, TryFrom, TryInto,
    AsRef, AsMut,
    
    // Display and Debug
    Display, Debug, ToString,
    
    // Clone and Copy
    Clone, Copy,
    
    // Default
    Default,
    
    // Iterator
    Iterator, IntoIterator, FromIterator, Extend,
    
    // Operators
    Add, Sub, Mul, Div, Rem, Neg,
    BitAnd, BitOr, BitXor, Not, Shl, Shr,
    Index, IndexMut,
    
    // Function traits
    Fn, FnMut, FnOnce,
    
    // Memory
    Drop, Sized,
    
    // Hashing
    Hash, Hasher
}

// -----------------------------------------------------------------------------
// Core Functions (globally available)
// -----------------------------------------------------------------------------

pub use builtin.{
    // Output
    print, println, eprint, eprintln,
    format, dbg,
    
    // Assertions
    assert, assert_eq, assert_ne,
    debug_assert, debug_assert_eq, debug_assert_ne,
    
    // Control flow
    panic, unreachable, todo, unimplemented,
    
    // Memory
    drop, forget, size_of, align_of,
    take, replace, swap,
    
    // Type utilities
    type_name, type_id,
    
    // Option/Result helpers
    some, none, ok, err
}

// -----------------------------------------------------------------------------
// Core Macros (automatically available)
// -----------------------------------------------------------------------------

pub use core.macros.{
    vec!, map!, set!,
    format!, print!, println!,
    assert!, assert_eq!, assert_ne!,
    debug!, trace!, info!, warn!, error!,
    matches!, cfg!, env!,
    include!, include_str!, include_bytes!,
    concat!, stringify!,
    file!, line!, column!, module_path!
}

// -----------------------------------------------------------------------------
// Prelude Traits Implementation Helpers
// -----------------------------------------------------------------------------

/// Marker trait for types that are automatically in prelude
trait Prelude {}

/// Extension trait for prelude types
trait PreludeExt {
    /// Convert to debug string
    fn debug_str() -> String where Self: Debug {
        format!("{:?}", self)
    }
    
    /// Check if value equals default
    fn is_default() -> Bool where Self: Default + Eq {
        self == Self.default()
    }
}

impl<T> PreludeExt for T {}

// -----------------------------------------------------------------------------
// Common Type Aliases
// -----------------------------------------------------------------------------

/// Byte type alias
pub type Byte = UInt8

/// Size type (platform-dependent)
pub type Size = UInt

/// Signed size type
pub type ISize = Int

/// Character code point
pub type CodePoint = UInt32

/// Raw pointer types
pub type RawPtr<T> = *T
pub type RawMutPtr<T> = *mut T

// -----------------------------------------------------------------------------
// Common Result Type Aliases
// -----------------------------------------------------------------------------

/// IO Result with standard error
pub type IoResult<T> = Result<T, IoError>

/// Parse Result
pub type ParseResult<T> = Result<T, ParseError>

/// Generic Result with string error
pub type SimpleResult<T> = Result<T, String>

// -----------------------------------------------------------------------------
// Utility Functions
// -----------------------------------------------------------------------------

/// Identity function
fn identity<T>(x: T) -> T { x }

/// Constant function
fn constant<T, U>(x: T) -> fn(U) -> T { |_| x }

/// Compose two functions
fn compose<A, B, C>(f: fn(A) -> B, g: fn(B) -> C) -> fn(A) -> C {
    |x| g(f(x))
}

/// Pipe value through function
fn pipe<T, U>(value: T, f: fn(T) -> U) -> U { f(value) }

/// Apply function to value (flip of pipe)
fn apply<T, U>(f: fn(T) -> U, value: T) -> U { f(value) }

/// Flip function arguments
fn flip<A, B, C>(f: fn(A, B) -> C) -> fn(B, A) -> C {
    |b, a| f(a, b)
}

/// Curry a two-argument function
fn curry<A, B, C>(f: fn(A, B) -> C) -> fn(A) -> fn(B) -> C {
    |a| |b| f(a, b)
}

/// Uncurry a curried function
fn uncurry<A, B, C>(f: fn(A) -> fn(B) -> C) -> fn(A, B) -> C {
    |a, b| f(a)(b)
}

// -----------------------------------------------------------------------------
// Tuple Extensions
// -----------------------------------------------------------------------------

impl<A, B> (A, B) {
    fn first() -> A { self.0 }
    fn second() -> B { self.1 }
    fn swap() -> (B, A) { (self.1, self.0) }
    fn map_first<C>(f: fn(A) -> C) -> (C, B) { (f(self.0), self.1) }
    fn map_second<C>(f: fn(B) -> C) -> (A, C) { (self.0, f(self.1)) }
}

impl<A, B, C> (A, B, C) {
    fn first() -> A { self.0 }
    fn second() -> B { self.1 }
    fn third() -> C { self.2 }
}

// -----------------------------------------------------------------------------
// Boolean Extensions
// -----------------------------------------------------------------------------

impl Bool {
    /// Convert to Option
    fn then<T>(value: T) -> Option<T> {
        if self { Some(value) } else { None }
    }
    
    /// Convert to Option with lazy evaluation
    fn then_some<T>(f: fn() -> T) -> Option<T> {
        if self { Some(f()) } else { None }
    }
    
    /// Convert to Result
    fn ok_or<T, E>(value: T, err: E) -> Result<T, E> {
        if self { Ok(value) } else { Err(err) }
    }
}

// -----------------------------------------------------------------------------
// Numeric Extensions
// -----------------------------------------------------------------------------

impl Int {
    fn abs() -> Int { if self < 0 { -self } else { self } }
    fn signum() -> Int { if self > 0 { 1 } else if self < 0 { -1 } else { 0 } }
    fn clamp(min: Int, max: Int) -> Int { 
        if self < min { min } else if self > max { max } else { self } 
    }
    fn is_positive() -> Bool { self > 0 }
    fn is_negative() -> Bool { self < 0 }
    fn is_zero() -> Bool { self == 0 }
    fn is_even() -> Bool { self % 2 == 0 }
    fn is_odd() -> Bool { self % 2 != 0 }
}

impl Float {
    fn abs() -> Float { if self < 0.0 { -self } else { self } }
    fn floor() -> Float { @native("floor", self) }
    fn ceil() -> Float { @native("ceil", self) }
    fn round() -> Float { @native("round", self) }
    fn trunc() -> Float { @native("trunc", self) }
    fn is_nan() -> Bool { self != self }
    fn is_infinite() -> Bool { self == Float.INFINITY || self == Float.NEG_INFINITY }
    fn is_finite() -> Bool { !self.is_nan() && !self.is_infinite() }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "identity" { assert_eq(identity(42), 42)? }
test "compose" { assert_eq(compose(|x| x + 1, |x| x * 2)(5), 12)? }
test "tuple swap" { assert_eq((1, 2).swap(), (2, 1))? }
test "bool then" { assert_eq(true.then(42), Some(42))?; assert_eq(false.then(42), None)? }
test "int extensions" { assert((-5).abs() == 5)?; assert(4.is_even())? }
