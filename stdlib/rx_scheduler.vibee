// =============================================================================
// Vibee OS â€” Rx Scheduler Module
// Schedulers for controlling execution context of reactive operations
// =============================================================================

use observable::{Observable, Observer, Subscription, create, observer}

/// Scheduler trait - controls when and where work is executed
trait Scheduler {
    /// Schedule work to be executed
    fn schedule(work: fn()) -> Disposable
    
    /// Schedule work with delay
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable
    
    /// Schedule periodic work
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable
    
    /// Get current time
    fn now() -> Int64
}

/// Disposable - cancellable scheduled work
struct Disposable {
    cancel_fn: fn()
    disposed: Bool
}

impl Disposable {
    fn new(cancel: fn()) -> Self {
        Disposable { cancel_fn: cancel, disposed: false }
    }
    
    fn empty() -> Self {
        Disposable { cancel_fn: || {}, disposed: true }
    }
    
    fn dispose() {
        if !self.disposed {
            self.disposed = true
            (self.cancel_fn)()
        }
    }
    
    fn is_disposed() -> Bool { self.disposed }
}

/// Composite disposable - manages multiple disposables
struct CompositeDisposable {
    disposables: [Disposable]
    disposed: Bool
}

impl CompositeDisposable {
    fn new() -> Self {
        CompositeDisposable { disposables: [], disposed: false }
    }
    
    fn add(d: Disposable) {
        if self.disposed {
            d.dispose()
        } else {
            self.disposables.push(d)
        }
    }
    
    fn remove(d: Disposable) {
        self.disposables.retain(|x| x != d)
    }
    
    fn dispose() {
        if !self.disposed {
            self.disposed = true
            for d in self.disposables.drain(..) {
                d.dispose()
            }
        }
    }
    
    fn clear() {
        for d in self.disposables.drain(..) {
            d.dispose()
        }
    }
}

// =============================================================================
// Immediate Scheduler
// =============================================================================

/// Executes work immediately on current thread
struct ImmediateScheduler {}

impl ImmediateScheduler {
    fn new() -> Self { ImmediateScheduler {} }
}

impl Scheduler for ImmediateScheduler {
    fn schedule(work: fn()) -> Disposable {
        work()
        Disposable.empty()
    }
    
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable {
        @native("sleep_ms", delay_ms)
        work()
        Disposable.empty()
    }
    
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        spawn {
            while !cancelled {
                work()
                @native("sleep_ms", period_ms)
            }
        }
        Disposable.new(|| cancelled = true)
    }
    
    fn now() -> Int64 { @native("timestamp_ms") }
}

// =============================================================================
// Async Scheduler
// =============================================================================

/// Executes work asynchronously using timers
struct AsyncScheduler {}

impl AsyncScheduler {
    fn new() -> Self { AsyncScheduler {} }
}

impl Scheduler for AsyncScheduler {
    fn schedule(work: fn()) -> Disposable {
        var cancelled = false
        let id = @native("set_timeout", 0, || {
            if !cancelled { work() }
        })
        Disposable.new(|| {
            cancelled = true
            @native("clear_timeout", id)
        })
    }
    
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        let id = @native("set_timeout", delay_ms, || {
            if !cancelled { work() }
        })
        Disposable.new(|| {
            cancelled = true
            @native("clear_timeout", id)
        })
    }
    
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        let id = @native("set_interval", period_ms, || {
            if !cancelled { work() }
        })
        Disposable.new(|| {
            cancelled = true
            @native("clear_interval", id)
        })
    }
    
    fn now() -> Int64 { @native("timestamp_ms") }
}

// =============================================================================
// Queue Scheduler
// =============================================================================

/// Queues work for sequential execution
actor QueueScheduler {
    state queue: [fn()]
    state running: Bool
    
    fn new() -> Self {
        QueueScheduler { queue: [], running: false }
    }
    
    fn process() {
        if self.running { return }
        self.running = true
        
        while !self.queue.is_empty() {
            let work = self.queue.remove(0)
            work()
        }
        
        self.running = false
    }
}

impl Scheduler for QueueScheduler {
    fn schedule(work: fn()) -> Disposable {
        var cancelled = false
        self.queue.push(|| {
            if !cancelled { work() }
        })
        self.process()
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        @native("set_timeout", delay_ms, || {
            if !cancelled {
                self.queue.push(work)
                self.process()
            }
        })
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        let id = @native("set_interval", period_ms, || {
            if !cancelled {
                self.queue.push(work)
                self.process()
            }
        })
        Disposable.new(|| {
            cancelled = true
            @native("clear_interval", id)
        })
    }
    
    fn now() -> Int64 { @native("timestamp_ms") }
}

// =============================================================================
// Thread Pool Scheduler
// =============================================================================

/// Executes work on thread pool
actor ThreadPoolScheduler {
    state pool: ThreadPool
    
    fn new(threads: Int) -> Self {
        ThreadPoolScheduler { pool: ThreadPool.new(threads) }
    }
    
    fn default() -> Self {
        Self.new(@native("cpu_count"))
    }
}

impl Scheduler for ThreadPoolScheduler {
    fn schedule(work: fn()) -> Disposable {
        var cancelled = false
        self.pool.execute(|| {
            if !cancelled { work() }
        })
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        @native("set_timeout", delay_ms, || {
            if !cancelled {
                self.pool.execute(work)
            }
        })
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        let id = @native("set_interval", period_ms, || {
            if !cancelled {
                self.pool.execute(work)
            }
        })
        Disposable.new(|| {
            cancelled = true
            @native("clear_interval", id)
        })
    }
    
    fn now() -> Int64 { @native("timestamp_ms") }
}

// =============================================================================
// Virtual Time Scheduler (for testing)
// =============================================================================

/// Virtual time scheduler for deterministic testing
struct VirtualTimeScheduler {
    current_time: Int64
    scheduled: [(Int64, fn())]
}

impl VirtualTimeScheduler {
    fn new() -> Self {
        VirtualTimeScheduler { current_time: 0, scheduled: [] }
    }
    
    /// Advance time by specified amount
    fn advance_by(ms: Int64) {
        let target = self.current_time + ms
        self.advance_to(target)
    }
    
    /// Advance time to specific point
    fn advance_to(time: Int64) {
        while !self.scheduled.is_empty() {
            // Sort by time
            self.scheduled.sort_by(|(t, _)| *t)
            
            let (next_time, _) = self.scheduled[0]
            if next_time > time { break }
            
            let (t, work) = self.scheduled.remove(0)
            self.current_time = t
            work()
        }
        self.current_time = time
    }
    
    /// Run all scheduled work
    fn flush() {
        while !self.scheduled.is_empty() {
            self.scheduled.sort_by(|(t, _)| *t)
            let (t, work) = self.scheduled.remove(0)
            self.current_time = t
            work()
        }
    }
    
    /// Reset scheduler
    fn reset() {
        self.current_time = 0
        self.scheduled.clear()
    }
}

impl Scheduler for VirtualTimeScheduler {
    fn schedule(work: fn()) -> Disposable {
        var cancelled = false
        self.scheduled.push((self.current_time, || {
            if !cancelled { work() }
        }))
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        let time = self.current_time + delay_ms
        self.scheduled.push((time, || {
            if !cancelled { work() }
        }))
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable {
        var cancelled = false
        var next_time = self.current_time + period_ms
        
        fn schedule_next() {
            if cancelled { return }
            self.scheduled.push((next_time, || {
                if !cancelled {
                    work()
                    next_time += period_ms
                    schedule_next()
                }
            }))
        }
        
        schedule_next()
        Disposable.new(|| cancelled = true)
    }
    
    fn now() -> Int64 { self.current_time }
}

// =============================================================================
// Trampoline Scheduler
// =============================================================================

/// Trampoline scheduler - prevents stack overflow for recursive scheduling
struct TrampolineScheduler {
    queue: [fn()]
    running: Bool
}

impl TrampolineScheduler {
    fn new() -> Self {
        TrampolineScheduler { queue: [], running: false }
    }
}

impl Scheduler for TrampolineScheduler {
    fn schedule(work: fn()) -> Disposable {
        var cancelled = false
        self.queue.push(|| {
            if !cancelled { work() }
        })
        
        if !self.running {
            self.running = true
            while !self.queue.is_empty() {
                let w = self.queue.remove(0)
                w()
            }
            self.running = false
        }
        
        Disposable.new(|| cancelled = true)
    }
    
    fn schedule_delayed(delay_ms: Int64, work: fn()) -> Disposable {
        // Trampoline doesn't support delays, execute immediately
        self.schedule(work)
    }
    
    fn schedule_periodic(period_ms: Int64, work: fn()) -> Disposable {
        // Not supported
        Disposable.empty()
    }
    
    fn now() -> Int64 { @native("timestamp_ms") }
}

// =============================================================================
// Scheduler Operators
// =============================================================================

/// Subscribe on specific scheduler
fn subscribe_on<S: Observable>(source: S, scheduler: impl Scheduler) -> impl Observable<Item = S.Item> {
    create(|obs| {
        var sub: Option<Subscription> = None
        let disposable = scheduler.schedule(|| {
            sub = Some(source.subscribe(obs))
        })
        Subscription.new(|| {
            disposable.dispose()
            if let Some(s) = sub { s.unsubscribe() }
        })
    })
}

/// Observe on specific scheduler
fn observe_on<S: Observable>(source: S, scheduler: impl Scheduler) -> impl Observable<Item = S.Item> where S.Item: Clone {
    create(|obs| {
        source.subscribe(observer(
            |v| scheduler.schedule(|| obs.on_next(v)),
            |e| scheduler.schedule(|| obs.on_error(e)),
            || scheduler.schedule(|| obs.on_complete())
        ))
    })
}

/// Delay subscription
fn delay_subscription<S: Observable>(source: S, delay_ms: Int64, scheduler: impl Scheduler) -> impl Observable<Item = S.Item> {
    create(|obs| {
        var sub: Option<Subscription> = None
        let disposable = scheduler.schedule_delayed(delay_ms, || {
            sub = Some(source.subscribe(obs))
        })
        Subscription.new(|| {
            disposable.dispose()
            if let Some(s) = sub { s.unsubscribe() }
        })
    })
}

// =============================================================================
// Global Schedulers
// =============================================================================

/// Default schedulers
static IMMEDIATE: ImmediateScheduler = ImmediateScheduler.new()
static ASYNC: AsyncScheduler = AsyncScheduler.new()
static TRAMPOLINE: TrampolineScheduler = TrampolineScheduler.new()

fn immediate() -> ImmediateScheduler { IMMEDIATE }
fn async_scheduler() -> AsyncScheduler { ASYNC }
fn trampoline() -> TrampolineScheduler { TRAMPOLINE }
fn new_thread() -> ThreadPoolScheduler { ThreadPoolScheduler.new(1) }
fn computation() -> ThreadPoolScheduler { ThreadPoolScheduler.default() }

// =============================================================================
// Tests
// =============================================================================

test "immediate scheduler" {
    let scheduler = ImmediateScheduler.new()
    var executed = false
    scheduler.schedule(|| executed = true)
    assert(executed)?
}

test "virtual time scheduler" {
    let scheduler = VirtualTimeScheduler.new()
    var result = []
    
    scheduler.schedule_delayed(100, || result.push(1))
    scheduler.schedule_delayed(50, || result.push(2))
    scheduler.schedule_delayed(150, || result.push(3))
    
    assert_eq(result, [])?  // Nothing executed yet
    
    scheduler.advance_by(60)
    assert_eq(result, [2])?  // Only 50ms task
    
    scheduler.advance_by(100)
    assert_eq(result, [2, 1, 3])?  // All tasks
}

test "queue scheduler" {
    let scheduler = QueueScheduler.new()
    var result = []
    
    scheduler.schedule(|| {
        result.push(1)
        scheduler.schedule(|| result.push(2))
    })
    scheduler.schedule(|| result.push(3))
    
    assert_eq(result, [1, 3, 2])?  // Queued order
}

test "composite disposable" {
    var disposed_count = 0
    let composite = CompositeDisposable.new()
    
    composite.add(Disposable.new(|| disposed_count += 1))
    composite.add(Disposable.new(|| disposed_count += 1))
    composite.add(Disposable.new(|| disposed_count += 1))
    
    composite.dispose()
    assert_eq(disposed_count, 3)?
}
