// =============================================================================
// Vibee OS â€” Versioning Module
// Version management and changelog generation
// =============================================================================

// -----------------------------------------------------------------------------
// Semantic Version
// -----------------------------------------------------------------------------

/// Semantic version (SemVer 2.0.0)
struct SemVer {
    major: Int
    minor: Int
    patch: Int
    prerelease: Option<String>
    build: Option<String>
    
    fn new(major: Int, minor: Int, patch: Int) -> Self {
        SemVer { major: major, minor: minor, patch: patch, prerelease: None, build: None }
    }
    
    fn parse(s: String) -> Result<Self, VersionError> {
        let s = s.trim().trim_start("v").trim_start("V")
        
        let (version_pre, build) = match s.split_once("+") {
            Some((v, b)) => (v, Some(b))
            None => (s, None)
        }
        
        let (version, prerelease) = match version_pre.split_once("-") {
            Some((v, p)) => (v, Some(p))
            None => (version_pre, None)
        }
        
        let parts = version.split(".")
        if parts.len() < 1 || parts.len() > 3 {
            return Err(VersionError.InvalidFormat(s))
        }
        
        let major = Int.parse(parts[0]).map_err(|_| VersionError.InvalidFormat(s))?
        let minor = parts.get(1).map(|p| Int.parse(p)).transpose()?.unwrap_or(0)
        let patch = parts.get(2).map(|p| Int.parse(p)).transpose()?.unwrap_or(0)
        
        Ok(SemVer { major, minor, patch, prerelease, build })
    }
    
    fn with_prerelease(self, pre: String) -> Self {
        SemVer { prerelease: Some(pre), ..self }
    }
    
    fn with_build(self, b: String) -> Self {
        SemVer { build: Some(b), ..self }
    }
    
    fn bump_major() -> Self {
        SemVer::new(self.major + 1, 0, 0)
    }
    
    fn bump_minor() -> Self {
        SemVer::new(self.major, self.minor + 1, 0)
    }
    
    fn bump_patch() -> Self {
        SemVer::new(self.major, self.minor, self.patch + 1)
    }
    
    fn is_prerelease() -> Bool { self.prerelease.is_some() }
    fn is_stable() -> Bool { self.major >= 1 && self.prerelease.is_none() }
    
    fn to_string() -> String {
        var s = format!("{}.{}.{}", self.major, self.minor, self.patch)
        if let Some(pre) = self.prerelease { s = format!("{}-{}", s, pre) }
        if let Some(b) = self.build { s = format!("{}+{}", s, b) }
        s
    }
}

impl Eq for SemVer {
    fn eq(other: SemVer) -> Bool {
        self.major == other.major && self.minor == other.minor && 
        self.patch == other.patch && self.prerelease == other.prerelease
    }
}

impl Ord for SemVer {
    fn cmp(other: SemVer) -> Ordering {
        match self.major.cmp(other.major) { Ordering.Equal => {}, o => return o }
        match self.minor.cmp(other.minor) { Ordering.Equal => {}, o => return o }
        match self.patch.cmp(other.patch) { Ordering.Equal => {}, o => return o }
        match (self.prerelease.is_some(), other.prerelease.is_some()) {
            (false, true) => Ordering.Greater
            (true, false) => Ordering.Less
            _ => Ordering.Equal
        }
    }
}

// -----------------------------------------------------------------------------
// Version Manager
// -----------------------------------------------------------------------------

actor VersionManager {
    state manifest_path: String
    state changelog_path: String
    state current: SemVer
    
    init() {
        self.manifest_path = "vibee.toml"
        self.changelog_path = "CHANGELOG.md"
        self.current = SemVer::new(0, 1, 0)
    }
    
    on load() -> Result<(), VersionError> {
        let content = fs::read_string(self.manifest_path)?
        let toml = toml::parse(content)?
        let version_str = toml.path("package.version")?.as_str()
            .ok_or(VersionError.MissingVersion)?
        self.current = SemVer::parse(version_str)?
        Ok(())
    }
    
    on bump(bump_type: BumpType) -> Result<SemVer, VersionError> {
        let new_version = match bump_type {
            BumpType.Major => self.current.bump_major()
            BumpType.Minor => self.current.bump_minor()
            BumpType.Patch => self.current.bump_patch()
            BumpType.Prerelease(tag) => self.current.with_prerelease(tag)
            BumpType.Release => SemVer { prerelease: None, build: None, ..self.current }
        }
        self.current = new_version.clone()
        self.save()?
        Ok(new_version)
    }
    
    on set(version: String) -> Result<SemVer, VersionError> {
        self.current = SemVer::parse(version)?
        self.save()?
        Ok(self.current.clone())
    }
    
    fn save() -> Result<(), VersionError> {
        let content = fs::read_string(self.manifest_path)?
        let updated = content.replace_regex(
            r#"version\s*=\s*"[^"]*""#,
            format!("version = \"{}\"", self.current.to_string())
        )
        fs::write_string(self.manifest_path, updated)?
        Ok(())
    }
}

enum BumpType {
    Major
    Minor
    Patch
    Prerelease(String)
    Release
}

// -----------------------------------------------------------------------------
// Changelog Generator
// -----------------------------------------------------------------------------

actor ChangelogGenerator {
    state path: String
    state entries: [ChangelogEntry]
    
    init() {
        self.path = "CHANGELOG.md"
        self.entries = []
    }
    
    on load() -> Result<(), VersionError> {
        if !fs::exists(self.path) { return Ok(()) }
        let content = fs::read_string(self.path)?
        self.entries = Self.parse_changelog(content)
        Ok(())
    }
    
    on add_entry(version: String, changes: [Change]) -> Self {
        self.entries.insert(0, ChangelogEntry {
            version: version,
            date: DateTime.now().format("%Y-%m-%d"),
            changes: changes
        })
        self
    }
    
    on generate() -> String {
        var content = "# Changelog\n\n"
        content += "All notable changes documented here.\n\n"
        
        for entry in self.entries {
            content += format!("## [{}] - {}\n\n", entry.version, entry.date)
            
            let grouped = Self.group_changes(entry.changes)
            for (category, items) in grouped {
                content += format!("### {}\n\n", category)
                for item in items { content += format!("- {}\n", item) }
                content += "\n"
            }
        }
        content
    }
    
    on save() -> Result<(), VersionError> {
        fs::write_string(self.path, self.generate())?
        Ok(())
    }
    
    fn parse_changelog(content: String) -> [ChangelogEntry] {
        // Simplified parsing
        []
    }
    
    fn group_changes(changes: [Change]) -> Map<String, [String]> {
        var grouped = Map::empty()
        for change in changes {
            let cat = change.category.to_string()
            grouped.entry(cat).or_insert([]).append(change.description)
        }
        grouped
    }
}

struct ChangelogEntry {
    version: String
    date: String
    changes: [Change]
}

struct Change {
    category: ChangeCategory
    description: String
    issue: Option<String>
}

enum ChangeCategory {
    Added
    Changed
    Deprecated
    Removed
    Fixed
    Security
    
    fn to_string() -> String {
        match self {
            Added => "Added"
            Changed => "Changed"
            Deprecated => "Deprecated"
            Removed => "Removed"
            Fixed => "Fixed"
            Security => "Security"
        }
    }
}

// -----------------------------------------------------------------------------
// Git Tag Manager
// -----------------------------------------------------------------------------

actor GitTagManager {
    state prefix: String
    state sign: Bool
    
    init() { self.prefix = "v"; self.sign = false }
    
    on prefix(p: String) -> Self { self.prefix = p; self }
    on sign(s: Bool) -> Self { self.sign = s; self }
    
    on create_tag(version: String, message: Option<String>) -> Result<(), VersionError> {
        let tag = format!("{}{}", self.prefix, version)
        var args = ["tag"]
        if self.sign { args.append("-s") }
        if let Some(msg) = message {
            args.extend(["-m", msg])
        }
        args.append(tag)
        
        let result = shell::exec("git", args)?
        if result.exit_code != 0 {
            return Err(VersionError.GitError(result.stderr))
        }
        Ok(())
    }
    
    on list_tags() -> Result<[String], VersionError> {
        let result = shell::exec("git", ["tag", "-l", format!("{}*", self.prefix)])?
        Ok(result.stdout.lines().filter(|l| !l.is_empty()).collect())
    }
    
    on push_tag(version: String) -> Result<(), VersionError> {
        let tag = format!("{}{}", self.prefix, version)
        let result = shell::exec("git", ["push", "origin", tag])?
        if result.exit_code != 0 {
            return Err(VersionError.GitError(result.stderr))
        }
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Errors & Convenience
// -----------------------------------------------------------------------------

enum VersionError {
    InvalidFormat(String)
    MissingVersion
    GitError(String)
    IOError(String)
    
    fn message() -> String {
        match self {
            .InvalidFormat(s) => format!("Invalid version: {}", s)
            .MissingVersion => "Version not found in manifest"
            .GitError(m) => format!("Git error: {}", m)
            .IOError(m) => format!("I/O error: {}", m)
        }
    }
}

fn parse(s: String) -> Result<SemVer, VersionError> { SemVer::parse(s) }
fn bump_major() -> Result<SemVer, VersionError> { let vm = VersionManager::new(); vm.load()?; vm.bump(BumpType.Major) }
fn bump_minor() -> Result<SemVer, VersionError> { let vm = VersionManager::new(); vm.load()?; vm.bump(BumpType.Minor) }
fn bump_patch() -> Result<SemVer, VersionError> { let vm = VersionManager::new(); vm.load()?; vm.bump(BumpType.Patch) }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "semver parse" {
    let v = SemVer::parse("1.2.3")?
    assert_eq(v.major, 1)?
    assert_eq(v.minor, 2)?
    assert_eq(v.patch, 3)?
}

test "semver bump" {
    let v = SemVer::new(1, 2, 3)
    assert_eq(v.bump_major(), SemVer::new(2, 0, 0))?
    assert_eq(v.bump_minor(), SemVer::new(1, 3, 0))?
    assert_eq(v.bump_patch(), SemVer::new(1, 2, 4))?
}

test "semver comparison" {
    assert(SemVer::new(1, 0, 0) < SemVer::new(2, 0, 0))?
    assert(SemVer::new(1, 0, 0) > SemVer::parse("1.0.0-alpha")?)?
}
