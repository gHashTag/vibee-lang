// =============================================================================
// Vibee OS â€” CodeGen Module
// Code Generation for Vibee Language
// =============================================================================

use ast::*
use ir::*

// =============================================================================
// Code Generator
// =============================================================================

/// Code generator state
struct CodeGen {
    builder: IrBuilder
    symbols: SymbolTable
    types: TypeTable
    errors: [CodeGenError]
}

struct CodeGenError { message: String, span: Span }

impl CodeGen {
    fn new(module_name: String) -> Self {
        CodeGen { builder: IrBuilder.new(module_name), symbols: SymbolTable.new(), types: TypeTable.new(), errors: [] }
    }
    
    fn generate(program: Program) -> Result<IrModule, [CodeGenError]> {
        for module in program.modules {
            for item in module.items { self.gen_item(item) }
        }
        if self.errors.is_empty() { Ok(self.builder.build()) } else { Err(self.errors) }
    }
    
    fn gen_item(item: Item) {
        match item {
            Item.Function(f) => self.gen_function(f)
            Item.Struct(s) => self.gen_struct(s)
            Item.Enum(e) => self.gen_enum(e)
            Item.Actor(a) => self.gen_actor(a)
            _ => {}
        }
    }
    
    fn gen_function(func: FunctionDef) {
        let params = func.params.iter().map(|p| IrParam { name: p.name.name, ty: self.convert_type(p.ty) }).collect()
        let ret = func.return_type.map(|t| self.convert_type(t)).unwrap_or(IrType.Void)
        
        self.builder.begin_function(func.name.name, params, ret)
        self.symbols.push_scope()
        
        let entry = self.builder.create_block("entry")
        self.builder.set_block(entry)
        
        // Allocate params
        for (i, p) in func.params.iter().enumerate() {
            let ty = self.convert_type(p.ty)
            let alloca = self.builder.alloca(ty)
            self.symbols.define(p.name.name, Symbol { kind: SymbolKind.Local(alloca), ty: ty })
        }
        
        // Generate body
        if let Some(body) = func.body {
            let result = self.gen_block(body)
            if !self.builder.current_block().map(|b| b.is_terminated()).unwrap_or(true) {
                if ret == IrType.Void { self.builder.ret(None) }
                else { self.builder.ret(result) }
            }
        }
        
        self.symbols.pop_scope()
        self.builder.end_function()
    }
    
    fn gen_struct(s: StructDef) {
        let fields = s.fields.iter().enumerate().map(|(i, f)| {
            let ty = self.convert_type(f.ty)
            IrField { name: f.name.name, ty: ty, offset: i }
        }).collect()
        self.builder.module.add_type(StructType { name: s.name.name, fields: fields })
    }
    
    fn gen_enum(e: EnumDef) {
        // Generate tag type + variant structs
        let tag_ty = IrType.I32
        for (i, v) in e.variants.iter().enumerate() {
            match v.fields {
                VariantFields.Unit => {}
                VariantFields.Tuple(types) => {
                    let fields = types.iter().enumerate().map(|(j, t)| IrField { name: format!("_{}", j), ty: self.convert_type(t), offset: j }).collect()
                    self.builder.module.add_type(StructType { name: format!("{}_{}", e.name.name, v.name.name), fields: fields })
                }
                _ => {}
            }
        }
    }
    
    fn gen_actor(a: ActorDef) {
        // Generate actor struct with state
        let fields = a.state.iter().enumerate().map(|(i, s)| IrField { name: s.name.name, ty: self.convert_type(s.ty), offset: i }).collect()
        self.builder.module.add_type(StructType { name: a.name.name, fields: fields })
        
        // Generate methods
        for method in a.methods { self.gen_function(method) }
    }
    
    fn gen_block(block: Block) -> Option<ValueId> {
        var last = None
        for stmt in block.stmts { last = self.gen_stmt(stmt) }
        if let Some(expr) = block.expr { last = self.gen_expr(*expr) }
        last
    }
    
    fn gen_stmt(stmt: Statement) -> Option<ValueId> {
        match stmt {
            Statement.Let(l) => { self.gen_let(l); None }
            Statement.Expr(e) => self.gen_expr(e.expr)
            _ => None
        }
    }
    
    fn gen_let(l: LetStmt) {
        let ty = l.ty.map(|t| self.convert_type(t)).unwrap_or(IrType.I64)
        let alloca = self.builder.alloca(ty)
        
        if let Some(init) = l.init {
            if let Some(val) = self.gen_expr(init) { self.builder.store(val, alloca) }
        }
        
        if let Pattern.Ident(p) = l.pattern {
            self.symbols.define(p.name.name, Symbol { kind: SymbolKind.Local(alloca), ty: ty })
        }
    }
    
    fn gen_expr(expr: Expr) -> Option<ValueId> {
        match expr {
            Expr.Literal(lit) => Some(self.gen_literal(lit))
            Expr.Path(path) => self.gen_path(path)
            Expr.Binary(b) => self.gen_binary(b)
            Expr.Unary(u) => self.gen_unary(u)
            Expr.If(i) => self.gen_if(i)
            Expr.Call(c) => self.gen_call(c)
            Expr.Block(b) => self.gen_block(b)
            Expr.Return(r) => { self.builder.ret(r.map(|e| self.gen_expr(*e)).flatten()); None }
            Expr.Assign(a) => { self.gen_assign(a); None }
            _ => None
        }
    }
    
    fn gen_literal(lit: Literal) -> ValueId {
        match lit.kind {
            LiteralKind.Int(n) => self.builder.const_int(n, IrType.I64)
            LiteralKind.Float(n) => self.builder.const_float(n, IrType.F64)
            LiteralKind.Bool(b) => self.builder.const_bool(b)
            LiteralKind.Char(c) => self.builder.const_int(c as Int64, IrType.I32)
            LiteralKind.String(s) => self.builder.const_int(0, IrType.I64) // Simplified
        }
    }
    
    fn gen_path(path: TypePath) -> Option<ValueId> {
        let name = path.segments.first()?.name.name
        let sym = self.symbols.lookup(name)?
        match sym.kind {
            SymbolKind.Local(ptr) => Some(self.builder.load(ptr, sym.ty))
            SymbolKind.Global(name) => Some(self.builder.const_int(0, IrType.I64))
            _ => None
        }
    }
    
    fn gen_binary(b: BinaryExpr) -> Option<ValueId> {
        let lhs = self.gen_expr(*b.left)?
        let rhs = self.gen_expr(*b.right)?
        let ty = IrType.I64
        
        Some(match b.op {
            BinaryOp.Add => self.builder.add(lhs, rhs, ty)
            BinaryOp.Sub => self.builder.sub(lhs, rhs, ty)
            BinaryOp.Mul => self.builder.mul(lhs, rhs, ty)
            BinaryOp.Div => self.builder.div(lhs, rhs, ty)
            BinaryOp.Rem => self.builder.rem(lhs, rhs, ty)
            BinaryOp.Eq => self.builder.eq(lhs, rhs)
            BinaryOp.Ne => self.builder.ne(lhs, rhs)
            BinaryOp.Lt => self.builder.lt(lhs, rhs, true)
            BinaryOp.Le => self.builder.le(lhs, rhs, true)
            BinaryOp.Gt => self.builder.gt(lhs, rhs, true)
            BinaryOp.Ge => self.builder.ge(lhs, rhs, true)
            BinaryOp.And => self.builder.and(lhs, rhs)
            BinaryOp.Or => self.builder.or(lhs, rhs)
            _ => self.builder.const_int(0, ty)
        })
    }
    
    fn gen_unary(u: UnaryExpr) -> Option<ValueId> {
        let val = self.gen_expr(*u.expr)?
        Some(match u.op {
            UnaryOp.Neg => self.builder.neg(val, IrType.I64)
            UnaryOp.Not => self.builder.not(val)
            _ => val
        })
    }
    
    fn gen_if(i: IfExpr) -> Option<ValueId> {
        let cond = self.gen_expr(*i.cond)?
        let then_block = self.builder.create_block("then")
        let else_block = self.builder.create_block("else")
        let merge_block = self.builder.create_block("merge")
        
        self.builder.cond_br(cond, then_block, else_block)
        
        self.builder.set_block(then_block)
        let then_val = self.gen_block(i.then_branch)
        if !self.builder.current_block().map(|b| b.is_terminated()).unwrap_or(true) {
            self.builder.br(merge_block)
        }
        
        self.builder.set_block(else_block)
        let else_val = if let Some(e) = i.else_branch { self.gen_expr(*e) } else { None }
        if !self.builder.current_block().map(|b| b.is_terminated()).unwrap_or(true) {
            self.builder.br(merge_block)
        }
        
        self.builder.set_block(merge_block)
        
        match (then_val, else_val) {
            (Some(t), Some(e)) => Some(self.builder.phi([(then_block, t), (else_block, e)], IrType.I64))
            _ => None
        }
    }
    
    fn gen_call(c: CallExpr) -> Option<ValueId> {
        let args = c.args.iter().filter_map(|a| self.gen_expr(a)).collect()
        
        if let Expr.Path(path) = *c.callee {
            let name = path.segments.first()?.name.name
            Some(self.builder.call(name, args, IrType.I64))
        } else { None }
    }
    
    fn gen_assign(a: AssignExpr) {
        if let Expr.Path(path) = *a.target {
            let name = path.segments.first().map(|s| s.name.name).unwrap_or("")
            if let Some(sym) = self.symbols.lookup(name) {
                if let SymbolKind.Local(ptr) = sym.kind {
                    if let Some(val) = self.gen_expr(*a.value) { self.builder.store(val, ptr) }
                }
            }
        }
    }
    
    fn convert_type(ty: Type) -> IrType {
        match ty {
            Type.Path(p) => {
                let name = p.segments.first().map(|s| s.name.name).unwrap_or("")
                match name.as_str() {
                    "Int" | "Int64" | "i64" => IrType.I64
                    "Int32" | "i32" => IrType.I32
                    "Float" | "Float64" | "f64" => IrType.F64
                    "Float32" | "f32" => IrType.F32
                    "Bool" | "bool" => IrType.Bool
                    "String" => IrType.Ptr(Box.new(IrType.I8))
                    _ => IrType.Named(name)
                }
            }
            Type.Tuple(types) if types.is_empty() => IrType.Void
            Type.Array(inner, _) => IrType.Ptr(Box.new(self.convert_type(*inner)))
            Type.Reference(inner, _) => IrType.Ptr(Box.new(self.convert_type(*inner)))
            _ => IrType.I64
        }
    }
    
    fn error(msg: String, span: Span) { self.errors.push(CodeGenError { message: msg, span: span }) }
}

// =============================================================================
// Symbol Table
// =============================================================================

struct SymbolTable { scopes: [Map<String, Symbol>] }

struct Symbol { kind: SymbolKind, ty: IrType }

enum SymbolKind { Local(ValueId), Global(String), Function(String), Type(String) }

impl SymbolTable {
    fn new() -> Self { SymbolTable { scopes: [Map.new()] } }
    fn push_scope() { self.scopes.push(Map.new()) }
    fn pop_scope() { self.scopes.pop() }
    
    fn define(name: String, sym: Symbol) {
        if let Some(scope) = self.scopes.last_mut() { scope.insert(name, sym) }
    }
    
    fn lookup(name: String) -> Option<Symbol> {
        for scope in self.scopes.iter().rev() {
            if let Some(sym) = scope.get(name) { return Some(sym) }
        }
        None
    }
}

// =============================================================================
// Type Table
// =============================================================================

struct TypeTable { types: Map<String, TypeInfo> }

struct TypeInfo { ir_type: IrType, size: Int, align: Int }

impl TypeTable {
    fn new() -> Self {
        var t = TypeTable { types: Map.new() }
        t.register("Int", IrType.I64)
        t.register("Int64", IrType.I64)
        t.register("Int32", IrType.I32)
        t.register("Float", IrType.F64)
        t.register("Float64", IrType.F64)
        t.register("Bool", IrType.Bool)
        t
    }
    
    fn register(name: String, ty: IrType) {
        self.types.insert(name, TypeInfo { ir_type: ty, size: ty.size(), align: ty.align() })
    }
    
    fn get(name: String) -> Option<TypeInfo> { self.types.get(name) }
}

// =============================================================================
// Compile Function
// =============================================================================

/// Compile AST to IR
fn compile(program: Program, module_name: String) -> Result<IrModule, [CodeGenError]> {
    CodeGen.new(module_name).generate(program)
}

/// Compile source to IR
fn compile_source(source: String, file: String) -> Result<IrModule, String> {
    let program = parser::parse(source, file).map_err(|e| e.iter().map(|x| x.message).join("\n"))?
    compile(program, file).map_err(|e| e.iter().map(|x| x.message).join("\n"))
}

// =============================================================================
// Tests
// =============================================================================

test "compile simple function" {
    let ir = compile_source("fn add(a: Int, b: Int) -> Int { a + b }", "test")?
    assert_eq(ir.functions.len(), 1)?
    assert_eq(ir.functions[0].name, "add")?
}

test "compile struct" {
    let ir = compile_source("struct Point { x: Int, y: Int }", "test")?
    assert_eq(ir.types.len(), 1)?
}
