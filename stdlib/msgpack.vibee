// =============================================================================
// Vibee OS â€” MessagePack Module
// MessagePack binary serialization format
// =============================================================================

// -----------------------------------------------------------------------------
// Value Type
// -----------------------------------------------------------------------------

enum Value {
    Nil
    Bool(Bool)
    Int(Int64)
    UInt(UInt64)
    Float(Float32)
    Double(Float64)
    String(String)
    Binary([UInt8])
    Array([Value])
    Map(Map<Value, Value>)
    Ext(Int8, [UInt8])
    
    fn is_nil() -> Bool { match self { .Nil => true, _ => false } }
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    fn as_int() -> Option<Int64> { match self { .Int(i) => Some(i), .UInt(u) => Some(u as Int64), _ => None } }
    fn as_float() -> Option<Float64> { match self { .Float(f) => Some(f as Float64), .Double(d) => Some(d), _ => None } }
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_bytes() -> Option<[UInt8]> { match self { .Binary(b) => Some(b), _ => None } }
    fn as_array() -> Option<[Value]> { match self { .Array(a) => Some(a), _ => None } }
    fn as_map() -> Option<Map<Value, Value>> { match self { .Map(m) => Some(m), _ => None } }
}

// -----------------------------------------------------------------------------
// Encoder
// -----------------------------------------------------------------------------

actor Encoder {
    state buffer: [UInt8]
    
    fn new() -> Self { Encoder { buffer: [] } }
    
    fn encode(value: Value) -> [UInt8] {
        self.buffer.clear()
        self.write_value(value)
        self.buffer.clone()
    }
    
    fn write_value(value: Value) {
        match value {
            .Nil => self.buffer.push(0xc0)
            .Bool(false) => self.buffer.push(0xc2)
            .Bool(true) => self.buffer.push(0xc3)
            .Int(i) => self.write_int(i)
            .UInt(u) => self.write_uint(u)
            .Float(f) => { self.buffer.push(0xca); self.write_be32(f.to_bits()) }
            .Double(d) => { self.buffer.push(0xcb); self.write_be64(d.to_bits()) }
            .String(s) => self.write_string(s)
            .Binary(b) => self.write_binary(b)
            .Array(a) => self.write_array(a)
            .Map(m) => self.write_map(m)
            .Ext(t, d) => self.write_ext(t, d)
        }
    }
    
    fn write_int(i: Int64) {
        if i >= 0 { self.write_uint(i as UInt64) }
        else if i >= -32 { self.buffer.push((i as Int8) as UInt8) }
        else if i >= -128 { self.buffer.push(0xd0); self.buffer.push(i as UInt8) }
        else if i >= -32768 { self.buffer.push(0xd1); self.write_be16(i as UInt16) }
        else if i >= -2147483648 { self.buffer.push(0xd2); self.write_be32(i as UInt32) }
        else { self.buffer.push(0xd3); self.write_be64(i as UInt64) }
    }
    
    fn write_uint(u: UInt64) {
        if u < 128 { self.buffer.push(u as UInt8) }
        else if u <= 0xFF { self.buffer.push(0xcc); self.buffer.push(u as UInt8) }
        else if u <= 0xFFFF { self.buffer.push(0xcd); self.write_be16(u as UInt16) }
        else if u <= 0xFFFFFFFF { self.buffer.push(0xce); self.write_be32(u as UInt32) }
        else { self.buffer.push(0xcf); self.write_be64(u) }
    }
    
    fn write_string(s: String) {
        let bytes = s.as_bytes()
        let len = bytes.len()
        if len < 32 { self.buffer.push(0xa0 | len as UInt8) }
        else if len <= 0xFF { self.buffer.push(0xd9); self.buffer.push(len as UInt8) }
        else if len <= 0xFFFF { self.buffer.push(0xda); self.write_be16(len as UInt16) }
        else { self.buffer.push(0xdb); self.write_be32(len as UInt32) }
        self.buffer.extend(bytes)
    }
    
    fn write_binary(b: [UInt8]) {
        let len = b.len()
        if len <= 0xFF { self.buffer.push(0xc4); self.buffer.push(len as UInt8) }
        else if len <= 0xFFFF { self.buffer.push(0xc5); self.write_be16(len as UInt16) }
        else { self.buffer.push(0xc6); self.write_be32(len as UInt32) }
        self.buffer.extend(b)
    }
    
    fn write_array(a: [Value]) {
        let len = a.len()
        if len < 16 { self.buffer.push(0x90 | len as UInt8) }
        else if len <= 0xFFFF { self.buffer.push(0xdc); self.write_be16(len as UInt16) }
        else { self.buffer.push(0xdd); self.write_be32(len as UInt32) }
        for v in a { self.write_value(v) }
    }
    
    fn write_map(m: Map<Value, Value>) {
        let len = m.len()
        if len < 16 { self.buffer.push(0x80 | len as UInt8) }
        else if len <= 0xFFFF { self.buffer.push(0xde); self.write_be16(len as UInt16) }
        else { self.buffer.push(0xdf); self.write_be32(len as UInt32) }
        for (k, v) in m { self.write_value(k); self.write_value(v) }
    }
    
    fn write_ext(type_id: Int8, data: [UInt8]) {
        let len = data.len()
        match len {
            1 => self.buffer.push(0xd4)
            2 => self.buffer.push(0xd5)
            4 => self.buffer.push(0xd6)
            8 => self.buffer.push(0xd7)
            16 => self.buffer.push(0xd8)
            _ if len <= 0xFF => { self.buffer.push(0xc7); self.buffer.push(len as UInt8) }
            _ if len <= 0xFFFF => { self.buffer.push(0xc8); self.write_be16(len as UInt16) }
            _ => { self.buffer.push(0xc9); self.write_be32(len as UInt32) }
        }
        self.buffer.push(type_id as UInt8)
        self.buffer.extend(data)
    }
    
    fn write_be16(v: UInt16) { self.buffer.push((v >> 8) as UInt8); self.buffer.push(v as UInt8) }
    fn write_be32(v: UInt32) { for i in [24, 16, 8, 0] { self.buffer.push((v >> i) as UInt8) } }
    fn write_be64(v: UInt64) { for i in [56, 48, 40, 32, 24, 16, 8, 0] { self.buffer.push((v >> i) as UInt8) } }
}

// -----------------------------------------------------------------------------
// Decoder
// -----------------------------------------------------------------------------

actor Decoder {
    state data: [UInt8]
    state pos: Int
    
    fn new(data: [UInt8]) -> Self { Decoder { data: data, pos: 0 } }
    
    fn decode(data: [UInt8]) -> Result<Value, MsgPackError> {
        var d = Decoder.new(data)
        d.read_value()
    }
    
    fn read_value() -> Result<Value, MsgPackError> {
        let b = self.read_byte()?
        match b {
            0xc0 => Ok(Value.Nil)
            0xc2 => Ok(Value.Bool(false))
            0xc3 => Ok(Value.Bool(true))
            0xc4 => { let len = self.read_byte()? as Int; Ok(Value.Binary(self.read_bytes(len)?)) }
            0xc5 => { let len = self.read_be16()? as Int; Ok(Value.Binary(self.read_bytes(len)?)) }
            0xc6 => { let len = self.read_be32()? as Int; Ok(Value.Binary(self.read_bytes(len)?)) }
            0xca => Ok(Value.Float(Float32.from_bits(self.read_be32()?)))
            0xcb => Ok(Value.Double(Float64.from_bits(self.read_be64()?)))
            0xcc => Ok(Value.UInt(self.read_byte()? as UInt64))
            0xcd => Ok(Value.UInt(self.read_be16()? as UInt64))
            0xce => Ok(Value.UInt(self.read_be32()? as UInt64))
            0xcf => Ok(Value.UInt(self.read_be64()?))
            0xd0 => Ok(Value.Int(self.read_byte()? as Int8 as Int64))
            0xd1 => Ok(Value.Int(self.read_be16()? as Int16 as Int64))
            0xd2 => Ok(Value.Int(self.read_be32()? as Int32 as Int64))
            0xd3 => Ok(Value.Int(self.read_be64()? as Int64))
            0xd9 => { let len = self.read_byte()? as Int; self.read_string(len) }
            0xda => { let len = self.read_be16()? as Int; self.read_string(len) }
            0xdb => { let len = self.read_be32()? as Int; self.read_string(len) }
            0xdc => { let len = self.read_be16()? as Int; self.read_array(len) }
            0xdd => { let len = self.read_be32()? as Int; self.read_array(len) }
            0xde => { let len = self.read_be16()? as Int; self.read_map(len) }
            0xdf => { let len = self.read_be32()? as Int; self.read_map(len) }
            _ if b <= 0x7f => Ok(Value.UInt(b as UInt64))
            _ if b >= 0xe0 => Ok(Value.Int((b as Int8) as Int64))
            _ if (b & 0xe0) == 0xa0 => { let len = (b & 0x1f) as Int; self.read_string(len) }
            _ if (b & 0xf0) == 0x90 => { let len = (b & 0x0f) as Int; self.read_array(len) }
            _ if (b & 0xf0) == 0x80 => { let len = (b & 0x0f) as Int; self.read_map(len) }
            _ => Err(MsgPackError.InvalidFormat(b))
        }
    }
    
    fn read_string(len: Int) -> Result<Value, MsgPackError> {
        let bytes = self.read_bytes(len)?
        Ok(Value.String(String.from_utf8(bytes).map_err(|_| MsgPackError.InvalidUtf8)?))
    }
    
    fn read_array(len: Int) -> Result<Value, MsgPackError> {
        var arr = []
        for _ in 0..len { arr.push(self.read_value()?) }
        Ok(Value.Array(arr))
    }
    
    fn read_map(len: Int) -> Result<Value, MsgPackError> {
        var map = Map.new()
        for _ in 0..len { let k = self.read_value()?; let v = self.read_value()?; map.insert(k, v) }
        Ok(Value.Map(map))
    }
    
    fn read_byte() -> Result<UInt8, MsgPackError> {
        if self.pos >= self.data.len() { return Err(MsgPackError.UnexpectedEof) }
        let b = self.data[self.pos]; self.pos += 1; Ok(b)
    }
    
    fn read_bytes(len: Int) -> Result<[UInt8], MsgPackError> {
        if self.pos + len > self.data.len() { return Err(MsgPackError.UnexpectedEof) }
        let r = self.data[self.pos..(self.pos + len)].to_vec(); self.pos += len; Ok(r)
    }
    
    fn read_be16() -> Result<UInt16, MsgPackError> {
        let b = self.read_bytes(2)?
        Ok(((b[0] as UInt16) << 8) | (b[1] as UInt16))
    }
    
    fn read_be32() -> Result<UInt32, MsgPackError> {
        let b = self.read_bytes(4)?
        Ok(((b[0] as UInt32) << 24) | ((b[1] as UInt32) << 16) | ((b[2] as UInt32) << 8) | (b[3] as UInt32))
    }
    
    fn read_be64() -> Result<UInt64, MsgPackError> {
        let b = self.read_bytes(8)?
        var r: UInt64 = 0
        for i in 0..8 { r = (r << 8) | (b[i] as UInt64) }
        Ok(r)
    }
}

// -----------------------------------------------------------------------------
// Errors & API
// -----------------------------------------------------------------------------

enum MsgPackError {
    UnexpectedEof
    InvalidFormat(UInt8)
    InvalidUtf8
    TypeMismatch(String)
}

fn encode(value: Value) -> [UInt8] { Encoder.new().encode(value) }
fn decode(data: [UInt8]) -> Result<Value, MsgPackError> { Decoder.decode(data) }

trait MsgPackSerializable {
    fn to_msgpack() -> Value
    fn from_msgpack(v: Value) -> Result<Self, MsgPackError>
}

test "roundtrip primitives" {
    assert(decode(encode(Value.Nil))? == Value.Nil)
    assert(decode(encode(Value.Bool(true)))?.as_bool() == Some(true))
    assert(decode(encode(Value.Int(42)))?.as_int() == Some(42))
    assert(decode(encode(Value.String("hello")))?.as_str() == Some("hello"))
}

test "roundtrip array" {
    let arr = Value.Array([Value.Int(1), Value.Int(2), Value.String("three")])
    let decoded = decode(encode(arr))?
    assert(decoded.as_array()?.len() == 3)
}
