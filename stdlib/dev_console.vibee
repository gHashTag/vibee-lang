// =============================================================================
// Vibee OS — Developer Console Module
// Interactive developer console with REPL, logging, and command execution
// =============================================================================

// -----------------------------------------------------------------------------
// Console Configuration
// -----------------------------------------------------------------------------

struct DevConsoleConfig {
    max_history: Int
    max_output_lines: Int
    auto_complete: Bool
    syntax_highlight: Bool
    timestamp_format: String
    log_level: LogLevel
    persist_history: Bool
    history_file: String
    
    fn default() -> Self {
        DevConsoleConfig {
            max_history: 1000,
            max_output_lines: 5000,
            auto_complete: true,
            syntax_highlight: true,
            timestamp_format: "%H:%M:%S",
            log_level: LogLevel.Debug,
            persist_history: true,
            history_file: ".vibee_console_history"
        }
    }
}

enum LogLevel {
    Trace
    Debug
    Info
    Warn
    Error
    Fatal
    
    fn priority() -> Int {
        match self {
            Trace => 0, Debug => 1, Info => 2, Warn => 3, Error => 4, Fatal => 5
        }
    }
    
    fn color() -> String {
        match self {
            Trace => "\x1b[90m"    // Gray
            Debug => "\x1b[36m"    // Cyan
            Info => "\x1b[32m"     // Green
            Warn => "\x1b[33m"     // Yellow
            Error => "\x1b[31m"    // Red
            Fatal => "\x1b[35m"    // Magenta
        }
    }
    
    fn label() -> String {
        match self {
            Trace => "TRACE", Debug => "DEBUG", Info => "INFO", Warn => "WARN", Error => "ERROR", Fatal => "FATAL"
        }
    }
}

// -----------------------------------------------------------------------------
// Console Entry Types
// -----------------------------------------------------------------------------

enum ConsoleEntry {
    Input(InputEntry)
    Output(OutputEntry)
    Log(LogEntry)
    Error(ErrorEntry)
    System(SystemEntry)
    Table(TableEntry)
    Object(ObjectEntry)
}

struct InputEntry {
    timestamp: Instant
    command: String
    execution_time: Option<Duration>
}

struct OutputEntry {
    timestamp: Instant
    content: String
    content_type: ContentType
}

struct LogEntry {
    timestamp: Instant
    level: LogLevel
    message: String
    source: Option<SourceInfo>
    context: Map<String, String>
}

struct ErrorEntry {
    timestamp: Instant
    error_type: String
    message: String
    stack_trace: Option<String>
    source: Option<SourceInfo>
}

struct SystemEntry {
    timestamp: Instant
    message: String
    entry_type: SystemEntryType
}

struct TableEntry {
    timestamp: Instant
    headers: [String]
    rows: [[String]]
}

struct ObjectEntry {
    timestamp: Instant
    type_name: String
    properties: Map<String, String>
    expanded: Bool
}

struct SourceInfo {
    file: String
    line: Int
    function: String
}

enum ContentType { Text, Json, Html, Markdown, Code(String) }
enum SystemEntryType { Info, Warning, Clear, GroupStart, GroupEnd }

// -----------------------------------------------------------------------------
// Command System
// -----------------------------------------------------------------------------

struct Command {
    name: String
    aliases: [String]
    description: String
    usage: String
    handler: fn([String]) -> Result<String, String>
}

impl Command {
    fn new(name: String, description: String, handler: fn([String]) -> Result<String, String>) -> Self {
        Command {
            name: name,
            aliases: [],
            description: description,
            usage: "",
            handler: handler
        }
    }
    
    fn with_aliases(aliases: [String]) -> Self {
        self.aliases = aliases
        self
    }
    
    fn with_usage(usage: String) -> Self {
        self.usage = usage
        self
    }
    
    fn matches(input: String) -> Bool {
        self.name == input || self.aliases.contains(input)
    }
}

// -----------------------------------------------------------------------------
// Auto-Complete
// -----------------------------------------------------------------------------

struct AutoComplete {
    commands: [String]
    variables: [String]
    keywords: [String]
    history: [String]
}

impl AutoComplete {
    fn new() -> Self {
        AutoComplete {
            commands: [],
            variables: [],
            keywords: ["fn", "struct", "enum", "actor", "trait", "impl", "let", "var", "if", "else", "match", "for", "while", "loop", "return", "break", "continue"],
            history: []
        }
    }
    
    fn suggest(prefix: String) -> [String] {
        var suggestions = []
        
        // Commands
        for cmd in self.commands {
            if cmd.starts_with(prefix) {
                suggestions.push(cmd.clone())
            }
        }
        
        // Variables
        for var in self.variables {
            if var.starts_with(prefix) {
                suggestions.push(var.clone())
            }
        }
        
        // Keywords
        for kw in self.keywords {
            if kw.starts_with(prefix) {
                suggestions.push(kw.clone())
            }
        }
        
        // History
        for hist in self.history {
            if hist.starts_with(prefix) && !suggestions.contains(hist) {
                suggestions.push(hist.clone())
            }
        }
        
        suggestions.sort()
        suggestions.dedup()
        suggestions
    }
    
    fn add_command(cmd: String) {
        if !self.commands.contains(cmd) {
            self.commands.push(cmd)
        }
    }
    
    fn add_variable(var: String) {
        if !self.variables.contains(var) {
            self.variables.push(var)
        }
    }
    
    fn add_to_history(input: String) {
        self.history.push(input)
        if self.history.len() > 100 {
            self.history.remove(0)
        }
    }
}

// -----------------------------------------------------------------------------
// Developer Console
// -----------------------------------------------------------------------------

actor DevConsole {
    state config: DevConsoleConfig
    state entries: [ConsoleEntry]
    state input_history: [String]
    state history_index: Int
    state commands: Map<String, Command>
    state auto_complete: AutoComplete
    state variables: Map<String, Any>
    state groups: [String]
    state filters: [LogLevel]
    state listeners: [fn(ConsoleEntry) -> ()]
    
    fn new() -> Self {
        Self.with_config(DevConsoleConfig.default())
    }
    
    fn with_config(config: DevConsoleConfig) -> Self {
        var console = DevConsole {
            config: config,
            entries: [],
            input_history: [],
            history_index: 0,
            commands: Map.new(),
            auto_complete: AutoComplete.new(),
            variables: Map.new(),
            groups: [],
            filters: [],
            listeners: []
        }
        
        console.register_builtin_commands()
        console
    }
    
    fn register_builtin_commands() {
        self.register_command(Command.new("help", "Show available commands", |args| {
            Ok(self.help_text())
        }))
        
        self.register_command(Command.new("clear", "Clear console", |_| {
            self.clear()
            Ok("Console cleared".to_string())
        }).with_aliases(["cls"]))
        
        self.register_command(Command.new("history", "Show command history", |_| {
            Ok(self.input_history.iter().enumerate()
                .map(|(i, cmd)| format!("{}: {}", i, cmd))
                .join("\n"))
        }))
        
        self.register_command(Command.new("vars", "Show defined variables", |_| {
            Ok(self.variables.iter()
                .map(|(k, v)| format!("{} = {:?}", k, v))
                .join("\n"))
        }))
        
        self.register_command(Command.new("type", "Show type of expression", |args| {
            if args.is_empty() {
                return Err("Usage: type <expression>".to_string())
            }
            let expr = args.join(" ")
            match self.evaluate(expr) {
                Ok(value) => Ok(format!("Type: {}", @native("type_name", value)))
                Err(e) => Err(e)
            }
        }))
        
        self.register_command(Command.new("time", "Measure execution time", |args| {
            if args.is_empty() {
                return Err("Usage: time <expression>".to_string())
            }
            let expr = args.join(" ")
            let start = Instant.now()
            let result = self.evaluate(expr)
            let elapsed = start.elapsed()
            match result {
                Ok(value) => Ok(format!("Result: {:?}\nTime: {:?}", value, elapsed))
                Err(e) => Err(format!("Error: {}\nTime: {:?}", e, elapsed))
            }
        }))
        
        self.register_command(Command.new("filter", "Set log level filter", |args| {
            if args.is_empty() {
                return Ok(format!("Current filters: {:?}", self.filters))
            }
            match args[0].to_lower().as_str() {
                "trace" => self.filters = [LogLevel.Trace]
                "debug" => self.filters = [LogLevel.Debug, LogLevel.Trace]
                "info" => self.filters = [LogLevel.Info, LogLevel.Debug, LogLevel.Trace]
                "warn" => self.filters = [LogLevel.Warn, LogLevel.Info, LogLevel.Debug, LogLevel.Trace]
                "error" => self.filters = [LogLevel.Error, LogLevel.Warn, LogLevel.Info, LogLevel.Debug, LogLevel.Trace]
                "none" => self.filters = []
                _ => return Err("Invalid level. Use: trace, debug, info, warn, error, none".to_string())
            }
            Ok(format!("Filter set to: {}", args[0]))
        }))
        
        self.register_command(Command.new("export", "Export console to file", |args| {
            if args.is_empty() {
                return Err("Usage: export <filename>".to_string())
            }
            let content = self.export_text()
            fs.write_string(args[0].clone(), content)?
            Ok(format!("Exported to {}", args[0]))
        }))
    }
    
    // -------------------------------------------------------------------------
    // Command Registration
    // -------------------------------------------------------------------------
    
    on register_command(cmd: Command) {
        self.commands.insert(cmd.name.clone(), cmd.clone())
        self.auto_complete.add_command(cmd.name.clone())
        for alias in cmd.aliases {
            self.auto_complete.add_command(alias)
        }
    }
    
    fn help_text() -> String {
        var output = StringBuilder.new()
        output.append("Available Commands:\n")
        output.append("─────────────────────\n")
        
        for (name, cmd) in self.commands {
            let aliases = if cmd.aliases.is_empty() {
                "".to_string()
            } else {
                format!(" ({})", cmd.aliases.join(", "))
            }
            output.append(format!("  {}{} - {}\n", name, aliases, cmd.description))
        }
        
        output.build()
    }
    
    // -------------------------------------------------------------------------
    // Input/Output
    // -------------------------------------------------------------------------
    
    /// Execute command or expression
    on execute(input: String) -> Result<String, String> {
        let trimmed = input.trim()
        if trimmed.is_empty() {
            return Ok("".to_string())
        }
        
        // Add to history
        self.input_history.push(trimmed.to_string())
        self.history_index = self.input_history.len()
        self.auto_complete.add_to_history(trimmed.to_string())
        
        let start = Instant.now()
        
        // Record input
        self.add_entry(ConsoleEntry.Input(InputEntry {
            timestamp: Instant.now(),
            command: trimmed.to_string(),
            execution_time: None
        }))
        
        // Parse command
        let parts = trimmed.split_whitespace().collect::<Vec<_>>()
        let cmd_name = parts.first().unwrap_or("")
        let args = parts.iter().skip(1).cloned().collect::<Vec<_>>()
        
        // Check for built-in command
        if let Some(cmd) = self.commands.get(cmd_name) {
            let result = (cmd.handler)(args)
            let elapsed = start.elapsed()
            
            match result {
                Ok(output) => {
                    self.add_entry(ConsoleEntry.Output(OutputEntry {
                        timestamp: Instant.now(),
                        content: output.clone(),
                        content_type: ContentType.Text
                    }))
                    Ok(output)
                }
                Err(e) => {
                    self.add_entry(ConsoleEntry.Error(ErrorEntry {
                        timestamp: Instant.now(),
                        error_type: "CommandError".to_string(),
                        message: e.clone(),
                        stack_trace: None,
                        source: None
                    }))
                    Err(e)
                }
            }
        } else {
            // Try to evaluate as expression
            self.evaluate(trimmed.to_string())
        }
    }
    
    /// Evaluate expression
    fn evaluate(expr: String) -> Result<String, String> {
        // Check for variable assignment
        if expr.contains("=") && !expr.contains("==") {
            let parts = expr.splitn(2, "=").collect::<Vec<_>>()
            if parts.len() == 2 {
                let var_name = parts[0].trim()
                let value_expr = parts[1].trim()
                
                match @native("eval", value_expr) {
                    Ok(value) => {
                        self.variables.insert(var_name.to_string(), value)
                        self.auto_complete.add_variable(var_name.to_string())
                        return Ok(format!("{} = {:?}", var_name, value))
                    }
                    Err(e) => return Err(e)
                }
            }
        }
        
        // Evaluate expression
        match @native("eval", expr) {
            Ok(value) => {
                let output = format!("{:?}", value)
                self.add_entry(ConsoleEntry.Output(OutputEntry {
                    timestamp: Instant.now(),
                    content: output.clone(),
                    content_type: ContentType.Text
                }))
                Ok(output)
            }
            Err(e) => {
                self.add_entry(ConsoleEntry.Error(ErrorEntry {
                    timestamp: Instant.now(),
                    error_type: "EvalError".to_string(),
                    message: e.clone(),
                    stack_trace: None,
                    source: None
                }))
                Err(e)
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // Logging
    // -------------------------------------------------------------------------
    
    /// Log message at level
    on log(level: LogLevel, message: String) {
        if level.priority() < self.config.log_level.priority() {
            return
        }
        
        self.add_entry(ConsoleEntry.Log(LogEntry {
            timestamp: Instant.now(),
            level: level,
            message: message,
            source: None,
            context: Map.new()
        }))
    }
    
    /// Log with source info
    on log_with_source(level: LogLevel, message: String, file: String, line: Int, function: String) {
        if level.priority() < self.config.log_level.priority() {
            return
        }
        
        self.add_entry(ConsoleEntry.Log(LogEntry {
            timestamp: Instant.now(),
            level: level,
            message: message,
            source: Some(SourceInfo { file: file, line: line, function: function }),
            context: Map.new()
        }))
    }
    
    /// Convenience logging methods
    on trace(message: String) { self.log(LogLevel.Trace, message) }
    on debug(message: String) { self.log(LogLevel.Debug, message) }
    on info(message: String) { self.log(LogLevel.Info, message) }
    on warn(message: String) { self.log(LogLevel.Warn, message) }
    on error(message: String) { self.log(LogLevel.Error, message) }
    on fatal(message: String) { self.log(LogLevel.Fatal, message) }
    
    /// Log error with stack trace
    on log_error(error: String, stack_trace: String) {
        self.add_entry(ConsoleEntry.Error(ErrorEntry {
            timestamp: Instant.now(),
            error_type: "Error".to_string(),
            message: error,
            stack_trace: Some(stack_trace),
            source: None
        }))
    }
    
    // -------------------------------------------------------------------------
    // Structured Output
    // -------------------------------------------------------------------------
    
    /// Log table
    on table(headers: [String], rows: [[String]]) {
        self.add_entry(ConsoleEntry.Table(TableEntry {
            timestamp: Instant.now(),
            headers: headers,
            rows: rows
        }))
    }
    
    /// Log object
    on object<T>(value: T) {
        let type_name = @native("type_name", value)
        let properties = @native("get_properties", value)
        
        self.add_entry(ConsoleEntry.Object(ObjectEntry {
            timestamp: Instant.now(),
            type_name: type_name,
            properties: properties,
            expanded: false
        }))
    }
    
    /// Start group
    on group(name: String) {
        self.groups.push(name.clone())
        self.add_entry(ConsoleEntry.System(SystemEntry {
            timestamp: Instant.now(),
            message: name,
            entry_type: SystemEntryType.GroupStart
        }))
    }
    
    /// End group
    on group_end() {
        if !self.groups.is_empty() {
            self.groups.pop()
            self.add_entry(ConsoleEntry.System(SystemEntry {
                timestamp: Instant.now(),
                message: "".to_string(),
                entry_type: SystemEntryType.GroupEnd
            }))
        }
    }
    
    // -------------------------------------------------------------------------
    // History Navigation
    // -------------------------------------------------------------------------
    
    fn previous_history() -> Option<String> {
        if self.history_index > 0 {
            self.history_index -= 1
            Some(self.input_history[self.history_index].clone())
        } else {
            None
        }
    }
    
    fn next_history() -> Option<String> {
        if self.history_index < self.input_history.len() - 1 {
            self.history_index += 1
            Some(self.input_history[self.history_index].clone())
        } else {
            None
        }
    }
    
    // -------------------------------------------------------------------------
    // Auto-Complete
    // -------------------------------------------------------------------------
    
    fn suggest(prefix: String) -> [String] {
        self.auto_complete.suggest(prefix)
    }
    
    // -------------------------------------------------------------------------
    // Console Management
    // -------------------------------------------------------------------------
    
    fn add_entry(entry: ConsoleEntry) {
        self.entries.push(entry.clone())
        
        if self.entries.len() > self.config.max_output_lines {
            self.entries.remove(0)
        }
        
        for listener in self.listeners {
            listener(entry.clone())
        }
    }
    
    on clear() {
        self.entries.clear()
        self.add_entry(ConsoleEntry.System(SystemEntry {
            timestamp: Instant.now(),
            message: "Console cleared".to_string(),
            entry_type: SystemEntryType.Clear
        }))
    }
    
    on add_listener(listener: fn(ConsoleEntry) -> ()) {
        self.listeners.push(listener)
    }
    
    // -------------------------------------------------------------------------
    // Export
    // -------------------------------------------------------------------------
    
    fn export_text() -> String {
        var output = StringBuilder.new()
        
        for entry in self.entries {
            match entry {
                ConsoleEntry.Input(e) => {
                    output.append(format!("[{}] > {}\n", self.format_time(e.timestamp), e.command))
                }
                ConsoleEntry.Output(e) => {
                    output.append(format!("[{}] {}\n", self.format_time(e.timestamp), e.content))
                }
                ConsoleEntry.Log(e) => {
                    let source = e.source.map(|s| format!(" ({}:{})", s.file, s.line)).unwrap_or("")
                    output.append(format!("[{}] [{}]{} {}\n", 
                        self.format_time(e.timestamp), e.level.label(), source, e.message))
                }
                ConsoleEntry.Error(e) => {
                    output.append(format!("[{}] ERROR: {} - {}\n", 
                        self.format_time(e.timestamp), e.error_type, e.message))
                    if let Some(stack) = e.stack_trace {
                        output.append(format!("{}\n", stack))
                    }
                }
                ConsoleEntry.System(e) => {
                    output.append(format!("[{}] --- {} ---\n", self.format_time(e.timestamp), e.message))
                }
                ConsoleEntry.Table(e) => {
                    output.append(format!("[{}] Table:\n", self.format_time(e.timestamp)))
                    output.append(format!("  {}\n", e.headers.join(" | ")))
                    for row in e.rows {
                        output.append(format!("  {}\n", row.join(" | ")))
                    }
                }
                ConsoleEntry.Object(e) => {
                    output.append(format!("[{}] Object: {}\n", self.format_time(e.timestamp), e.type_name))
                    for (k, v) in e.properties {
                        output.append(format!("  {}: {}\n", k, v))
                    }
                }
            }
        }
        
        output.build()
    }
    
    fn export_json() -> String {
        @native("json_encode", self.entries)
    }
    
    fn format_time(instant: Instant) -> String {
        instant.format(self.config.timestamp_format)
    }
    
    // -------------------------------------------------------------------------
    // Rendering
    // -------------------------------------------------------------------------
    
    fn render() -> String {
        var output = StringBuilder.new()
        let indent_level = self.groups.len()
        let indent = "  ".repeat(indent_level)
        
        for entry in self.entries {
            match entry {
                ConsoleEntry.Input(e) => {
                    output.append(format!("{}\x1b[36m> {}\x1b[0m\n", indent, e.command))
                }
                ConsoleEntry.Output(e) => {
                    output.append(format!("{}{}\n", indent, e.content))
                }
                ConsoleEntry.Log(e) => {
                    if self.filters.is_empty() || self.filters.contains(e.level) {
                        let color = e.level.color()
                        let source = e.source.map(|s| format!(" \x1b[90m{}:{}\x1b[0m", s.file, s.line)).unwrap_or("")
                        output.append(format!("{}{}[{}]\x1b[0m{} {}\n", 
                            indent, color, e.level.label(), source, e.message))
                    }
                }
                ConsoleEntry.Error(e) => {
                    output.append(format!("{}\x1b[31m✗ {}: {}\x1b[0m\n", indent, e.error_type, e.message))
                    if let Some(stack) = e.stack_trace {
                        output.append(format!("{}\x1b[90m{}\x1b[0m\n", indent, stack))
                    }
                }
                ConsoleEntry.System(e) => {
                    match e.entry_type {
                        SystemEntryType.GroupStart => {
                            output.append(format!("{}\x1b[1m▼ {}\x1b[0m\n", indent, e.message))
                        }
                        SystemEntryType.GroupEnd => {
                            output.append(format!("{}\x1b[90m▲\x1b[0m\n", indent))
                        }
                        _ => {
                            output.append(format!("{}\x1b[90m{}\x1b[0m\n", indent, e.message))
                        }
                    }
                }
                ConsoleEntry.Table(e) => {
                    output.append(self.render_table(e.headers, e.rows, indent))
                }
                ConsoleEntry.Object(e) => {
                    output.append(format!("{}\x1b[33m{}\x1b[0m {{\n", indent, e.type_name))
                    for (k, v) in e.properties {
                        output.append(format!("{}  {}: {}\n", indent, k, v))
                    }
                    output.append(format!("{}}}\n", indent))
                }
            }
        }
        
        output.build()
    }
    
    fn render_table(headers: [String], rows: [[String]], indent: String) -> String {
        var output = StringBuilder.new()
        
        // Calculate column widths
        var widths = headers.iter().map(|h| h.len()).collect::<Vec<_>>()
        for row in rows {
            for (i, cell) in row.enumerate() {
                if i < widths.len() {
                    widths[i] = widths[i].max(cell.len())
                }
            }
        }
        
        // Header
        output.append(indent)
        for (i, header) in headers.enumerate() {
            output.append(format!("\x1b[1m{:width$}\x1b[0m", header, width = widths[i]))
            if i < headers.len() - 1 { output.append(" │ ") }
        }
        output.append("\n")
        
        // Separator
        output.append(indent)
        for (i, width) in widths.enumerate() {
            output.append("─".repeat(width))
            if i < widths.len() - 1 { output.append("─┼─") }
        }
        output.append("\n")
        
        // Rows
        for row in rows {
            output.append(indent)
            for (i, cell) in row.enumerate() {
                if i < widths.len() {
                    output.append(format!("{:width$}", cell, width = widths[i]))
                    if i < row.len() - 1 { output.append(" │ ") }
                }
            }
            output.append("\n")
        }
        
        output.build()
    }
}

// -----------------------------------------------------------------------------
// Global Console Instance
// -----------------------------------------------------------------------------

var CONSOLE = DevConsole.new()

/// Quick logging functions
fn console_log(message: String) { CONSOLE.info(message) }
fn console_debug(message: String) { CONSOLE.debug(message) }
fn console_warn(message: String) { CONSOLE.warn(message) }
fn console_error(message: String) { CONSOLE.error(message) }
fn console_table(headers: [String], rows: [[String]]) { CONSOLE.table(headers, rows) }

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "console_creation" {
    let console = DevConsole.new()
    assert(console.entries.is_empty())?
}

test "log_levels" {
    assert_eq(LogLevel.Trace.priority(), 0)?
    assert_eq(LogLevel.Fatal.priority(), 5)?
}

test "auto_complete" {
    var ac = AutoComplete.new()
    ac.add_command("help")
    ac.add_command("history")
    
    let suggestions = ac.suggest("h")
    assert(suggestions.contains("help"))?
    assert(suggestions.contains("history"))?
}

test "command_registration" {
    let console = DevConsole.new()
    assert(console.commands.contains_key("help"))?
    assert(console.commands.contains_key("clear"))?
}
