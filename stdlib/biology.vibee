// =============================================================================
// Vibee OS â€” Biology Module
// Bioinformatics: DNA, RNA, proteins, and molecular biology
// =============================================================================

use math::{ln, exp, pow, sqrt}

// -----------------------------------------------------------------------------
// Nucleotide Bases
// -----------------------------------------------------------------------------

enum DNABase { A, T, G, C }
enum RNABase { A, U, G, C }

impl DNABase {
    fn complement() -> DNABase {
        match self { A => T, T => A, G => C, C => G }
    }
    
    fn to_rna() -> RNABase {
        match self { A => RNABase.A, T => RNABase.U, G => RNABase.G, C => RNABase.C }
    }
    
    fn to_char() -> Char {
        match self { A => 'A', T => 'T', G => 'G', C => 'C' }
    }
}

impl RNABase {
    fn complement() -> RNABase {
        match self { A => U, U => A, G => C, C => G }
    }
    
    fn to_char() -> Char {
        match self { A => 'A', U => 'U', G => 'G', C => 'C' }
    }
}

// -----------------------------------------------------------------------------
// DNA Sequence
// -----------------------------------------------------------------------------

struct DNA {
    sequence: String
    
    fn new(seq: String) -> Self { DNA { sequence: seq.to_uppercase() } }
    
    fn len() -> Int { self.sequence.len() }
    
    fn complement() -> DNA {
        let comp = self.sequence.chars().map(|c| match c {
            'A' => 'T', 'T' => 'A', 'G' => 'C', 'C' => 'G', _ => c
        }).collect()
        DNA { sequence: comp }
    }
    
    fn reverse_complement() -> DNA {
        DNA { sequence: self.complement().sequence.chars().rev().collect() }
    }
    
    fn transcribe() -> RNA {
        let rna = self.sequence.chars().map(|c| match c {
            'A' => 'A', 'T' => 'U', 'G' => 'G', 'C' => 'C', _ => c
        }).collect()
        RNA { sequence: rna }
    }
    
    fn gc_content() -> Float {
        let gc = self.sequence.chars().filter(|c| c == 'G' || c == 'C').count()
        gc as Float / self.len() as Float * 100.0
    }
    
    fn count_base(base: Char) -> Int {
        self.sequence.chars().filter(|c| c == base).count()
    }
    
    fn find_motif(motif: String) -> [Int] {
        var positions = []
        for i in 0..(self.len() - motif.len() + 1) {
            if self.sequence[i..i+motif.len()] == motif {
                positions.push(i)
            }
        }
        positions
    }
    
    fn melting_temp() -> Float {
        let a = self.count_base('A')
        let t = self.count_base('T')
        let g = self.count_base('G')
        let c = self.count_base('C')
        if self.len() < 14 {
            (a + t) as Float * 2.0 + (g + c) as Float * 4.0
        } else {
            64.9 + 41.0 * (g + c - 16.4) as Float / self.len() as Float
        }
    }
}

// -----------------------------------------------------------------------------
// RNA Sequence
// -----------------------------------------------------------------------------

struct RNA {
    sequence: String
    
    fn new(seq: String) -> Self { RNA { sequence: seq.to_uppercase() } }
    fn len() -> Int { self.sequence.len() }
    
    fn translate() -> Protein {
        var amino_acids = []
        let codons = self.sequence.as_bytes().chunks(3)
        for codon in codons {
            if codon.len() == 3 {
                let aa = codon_to_amino_acid(String.from_utf8(codon.to_vec()).unwrap())
                if aa == "*" { break }
                amino_acids.push(aa)
            }
        }
        Protein { sequence: amino_acids.join("") }
    }
    
    fn gc_content() -> Float {
        let gc = self.sequence.chars().filter(|c| c == 'G' || c == 'C').count()
        gc as Float / self.len() as Float * 100.0
    }
}

// -----------------------------------------------------------------------------
// Codon Table
// -----------------------------------------------------------------------------

fn codon_to_amino_acid(codon: String) -> String {
    match codon.as_str() {
        "UUU" | "UUC" => "F", "UUA" | "UUG" | "CUU" | "CUC" | "CUA" | "CUG" => "L",
        "AUU" | "AUC" | "AUA" => "I", "AUG" => "M",
        "GUU" | "GUC" | "GUA" | "GUG" => "V",
        "UCU" | "UCC" | "UCA" | "UCG" | "AGU" | "AGC" => "S",
        "CCU" | "CCC" | "CCA" | "CCG" => "P",
        "ACU" | "ACC" | "ACA" | "ACG" => "T",
        "GCU" | "GCC" | "GCA" | "GCG" => "A",
        "UAU" | "UAC" => "Y", "UAA" | "UAG" | "UGA" => "*",
        "CAU" | "CAC" => "H", "CAA" | "CAG" => "Q",
        "AAU" | "AAC" => "N", "AAA" | "AAG" => "K",
        "GAU" | "GAC" => "D", "GAA" | "GAG" => "E",
        "UGU" | "UGC" => "C", "UGG" => "W",
        "CGU" | "CGC" | "CGA" | "CGG" | "AGA" | "AGG" => "R",
        "GGU" | "GGC" | "GGA" | "GGG" => "G",
        _ => "X"
    }
}

// -----------------------------------------------------------------------------
// Protein / Amino Acid Sequence
// -----------------------------------------------------------------------------

struct AminoAcid {
    code: Char
    name: String
    abbrev: String
    mw: Float
    hydrophobicity: Float
    
    fn is_hydrophobic() -> Bool { self.hydrophobicity > 0.0 }
    fn is_polar() -> Bool { self.hydrophobicity < 0.0 }
}

fn get_amino_acid(code: Char) -> AminoAcid {
    match code {
        'A' => AminoAcid { code: 'A', name: "Alanine", abbrev: "Ala", mw: 89.1, hydrophobicity: 1.8 },
        'R' => AminoAcid { code: 'R', name: "Arginine", abbrev: "Arg", mw: 174.2, hydrophobicity: -4.5 },
        'N' => AminoAcid { code: 'N', name: "Asparagine", abbrev: "Asn", mw: 132.1, hydrophobicity: -3.5 },
        'D' => AminoAcid { code: 'D', name: "Aspartate", abbrev: "Asp", mw: 133.1, hydrophobicity: -3.5 },
        'C' => AminoAcid { code: 'C', name: "Cysteine", abbrev: "Cys", mw: 121.2, hydrophobicity: 2.5 },
        'E' => AminoAcid { code: 'E', name: "Glutamate", abbrev: "Glu", mw: 147.1, hydrophobicity: -3.5 },
        'Q' => AminoAcid { code: 'Q', name: "Glutamine", abbrev: "Gln", mw: 146.2, hydrophobicity: -3.5 },
        'G' => AminoAcid { code: 'G', name: "Glycine", abbrev: "Gly", mw: 75.1, hydrophobicity: -0.4 },
        'H' => AminoAcid { code: 'H', name: "Histidine", abbrev: "His", mw: 155.2, hydrophobicity: -3.2 },
        'I' => AminoAcid { code: 'I', name: "Isoleucine", abbrev: "Ile", mw: 131.2, hydrophobicity: 4.5 },
        'L' => AminoAcid { code: 'L', name: "Leucine", abbrev: "Leu", mw: 131.2, hydrophobicity: 3.8 },
        'K' => AminoAcid { code: 'K', name: "Lysine", abbrev: "Lys", mw: 146.2, hydrophobicity: -3.9 },
        'M' => AminoAcid { code: 'M', name: "Methionine", abbrev: "Met", mw: 149.2, hydrophobicity: 1.9 },
        'F' => AminoAcid { code: 'F', name: "Phenylalanine", abbrev: "Phe", mw: 165.2, hydrophobicity: 2.8 },
        'P' => AminoAcid { code: 'P', name: "Proline", abbrev: "Pro", mw: 115.1, hydrophobicity: -1.6 },
        'S' => AminoAcid { code: 'S', name: "Serine", abbrev: "Ser", mw: 105.1, hydrophobicity: -0.8 },
        'T' => AminoAcid { code: 'T', name: "Threonine", abbrev: "Thr", mw: 119.1, hydrophobicity: -0.7 },
        'W' => AminoAcid { code: 'W', name: "Tryptophan", abbrev: "Trp", mw: 204.2, hydrophobicity: -0.9 },
        'Y' => AminoAcid { code: 'Y', name: "Tyrosine", abbrev: "Tyr", mw: 181.2, hydrophobicity: -1.3 },
        'V' => AminoAcid { code: 'V', name: "Valine", abbrev: "Val", mw: 117.1, hydrophobicity: 4.2 },
        _ => AminoAcid { code: 'X', name: "Unknown", abbrev: "Xaa", mw: 0.0, hydrophobicity: 0.0 }
    }
}

struct Protein {
    sequence: String
    
    fn new(seq: String) -> Self { Protein { sequence: seq.to_uppercase() } }
    fn len() -> Int { self.sequence.len() }
    
    fn molecular_weight() -> Float {
        var mw = 18.015  // Water
        for c in self.sequence.chars() {
            mw += get_amino_acid(c).mw - 18.015
        }
        mw
    }
    
    fn isoelectric_point() -> Float {
        // Simplified pI calculation
        var pos = 0; var neg = 0
        for c in self.sequence.chars() {
            match c { 'K' | 'R' | 'H' => pos += 1, 'D' | 'E' => neg += 1, _ => {} }
        }
        if pos > neg { 10.0 } else if neg > pos { 4.0 } else { 7.0 }
    }
    
    fn hydrophobicity_index() -> Float {
        let sum: Float = self.sequence.chars().map(|c| get_amino_acid(c).hydrophobicity).sum()
        sum / self.len() as Float
    }
    
    fn count_amino_acid(aa: Char) -> Int {
        self.sequence.chars().filter(|c| c == aa).count()
    }
}

// -----------------------------------------------------------------------------
// Sequence Alignment
// -----------------------------------------------------------------------------

fn hamming_distance(s1: String, s2: String) -> Int {
    s1.chars().zip(s2.chars()).filter(|(a, b)| a != b).count()
}

fn levenshtein_distance(s1: String, s2: String) -> Int {
    let m = s1.len(); let n = s2.len()
    var dp = vec![vec![0; n + 1]; m + 1]
    for i in 0..=m { dp[i][0] = i }
    for j in 0..=n { dp[0][j] = j }
    for i in 1..=m {
        for j in 1..=n {
            let cost = if s1.chars().nth(i-1) == s2.chars().nth(j-1) { 0 } else { 1 }
            dp[i][j] = min(min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + cost)
        }
    }
    dp[m][n]
}

fn sequence_identity(s1: String, s2: String) -> Float {
    let matches = s1.chars().zip(s2.chars()).filter(|(a, b)| a == b).count()
    matches as Float / max(s1.len(), s2.len()) as Float * 100.0
}

// -----------------------------------------------------------------------------
// Population Genetics
// -----------------------------------------------------------------------------

/// Hardy-Weinberg equilibrium frequencies
fn hardy_weinberg(p: Float) -> (Float, Float, Float) {
    let q = 1.0 - p
    (p * p, 2.0 * p * q, q * q)  // AA, Aa, aa
}

/// Calculate allele frequency from genotype counts
fn allele_frequency(aa: Int, ab: Int, bb: Int) -> Float {
    let total = 2 * (aa + ab + bb)
    (2 * aa + ab) as Float / total as Float
}

/// Chi-square test for Hardy-Weinberg equilibrium
fn hw_chi_square(obs_aa: Int, obs_ab: Int, obs_bb: Int) -> Float {
    let n = obs_aa + obs_ab + obs_bb
    let p = allele_frequency(obs_aa, obs_ab, obs_bb)
    let (exp_aa, exp_ab, exp_bb) = hardy_weinberg(p)
    let e_aa = exp_aa * n as Float
    let e_ab = exp_ab * n as Float
    let e_bb = exp_bb * n as Float
    pow(obs_aa as Float - e_aa, 2.0) / e_aa +
    pow(obs_ab as Float - e_ab, 2.0) / e_ab +
    pow(obs_bb as Float - e_bb, 2.0) / e_bb
}

// -----------------------------------------------------------------------------
// Phylogenetics
// -----------------------------------------------------------------------------

/// Jukes-Cantor distance
fn jukes_cantor_distance(p: Float) -> Float {
    -0.75 * ln(1.0 - 4.0 * p / 3.0)
}

/// Kimura 2-parameter distance
fn kimura_distance(transitions: Float, transversions: Float) -> Float {
    -0.5 * ln((1.0 - 2.0 * transitions - transversions) * sqrt(1.0 - 2.0 * transversions))
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "dna operations" {
    let dna = DNA.new("ATGCGATCG")
    assert_eq(dna.complement().sequence, "TACGCTAGC")?
    assert_eq(dna.transcribe().sequence, "AUGCGAUCG")?
}

test "gc content" {
    let dna = DNA.new("ATGCGC")
    assert((dna.gc_content() - 66.67).abs() < 0.1)?
}

test "protein molecular weight" {
    let protein = Protein.new("MK")
    assert(protein.molecular_weight() > 200.0)?
}

test "hardy weinberg" {
    let (aa, ab, bb) = hardy_weinberg(0.5)
    assert((aa - 0.25).abs() < 0.001)?
    assert((ab - 0.50).abs() < 0.001)?
}

fn min(a: Int, b: Int) -> Int { if a < b { a } else { b } }
fn max(a: Int, b: Int) -> Int { if a > b { a } else { b } }
