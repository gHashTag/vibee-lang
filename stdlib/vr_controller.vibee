// =============================================================================
// Vibee OS â€” VR Controller Module
// Virtual Reality controller input and haptics
// =============================================================================

use geometry::{Point3D}
use transform::{Transform3D, Quaternion}
use channel::{Channel, Sender, Receiver}

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const CONTROLLER_DEADZONE: Float = 0.1
const HAPTIC_MAX_DURATION_MS: Int = 5000
const HAPTIC_MAX_INTENSITY: Float = 1.0
const TRACKING_PREDICTION_MS: Float = 20.0

// -----------------------------------------------------------------------------
// Controller Types
// -----------------------------------------------------------------------------

/// Controller hand
enum ControllerHand {
    Left
    Right
    
    fn opposite() -> Self {
        match self {
            Left => Right,
            Right => Left
        }
    }
    
    fn index() -> Int {
        match self {
            Left => 0,
            Right => 1
        }
    }
}

/// Controller type/model
enum ControllerType {
    Unknown
    OculusTouch
    OculusTouchPro
    ValveIndex
    ViveWand
    ViveFocus
    WindowsMR
    PicoNeo
    QuestPro
    
    fn has_finger_tracking() -> Bool {
        match self {
            ValveIndex | QuestPro => true,
            _ => false
        }
    }
    
    fn has_capacitive_touch() -> Bool {
        match self {
            OculusTouch | OculusTouchPro | ValveIndex | QuestPro => true,
            _ => false
        }
    }
    
    fn button_count() -> Int {
        match self {
            OculusTouch | OculusTouchPro => 7,
            ValveIndex => 8,
            ViveWand => 4,
            WindowsMR => 6,
            _ => 4
        }
    }
}

/// Controller connection state
enum ControllerConnectionState {
    Disconnected
    Connecting
    Connected
    LowBattery
    
    fn is_available() -> Bool {
        match self {
            Connected | LowBattery => true,
            _ => false
        }
    }
}

// -----------------------------------------------------------------------------
// Controller Buttons
// -----------------------------------------------------------------------------

/// Standard VR controller buttons
enum ControllerButton {
    Trigger
    Grip
    Primary       // A/X button
    Secondary     // B/Y button
    Thumbstick
    ThumbstickTouch
    Menu
    System
    
    fn to_mask() -> UInt32 {
        match self {
            Trigger => 0x0001,
            Grip => 0x0002,
            Primary => 0x0004,
            Secondary => 0x0008,
            Thumbstick => 0x0010,
            ThumbstickTouch => 0x0020,
            Menu => 0x0040,
            System => 0x0080
        }
    }
}

/// Button state
enum ButtonState {
    Released
    Pressed
    JustPressed
    JustReleased
    
    fn is_down() -> Bool {
        match self {
            Pressed | JustPressed => true,
            _ => false
        }
    }
    
    fn is_up() -> Bool {
        match self {
            Released | JustReleased => true,
            _ => false
        }
    }
    
    fn just_changed() -> Bool {
        match self {
            JustPressed | JustReleased => true,
            _ => false
        }
    }
}

/// Touch state for capacitive buttons
enum TouchState {
    NotTouching
    Touching
    JustTouched
    JustReleased
    
    fn is_touching() -> Bool {
        match self {
            Touching | JustTouched => true,
            _ => false
        }
    }
}

// -----------------------------------------------------------------------------
// Controller Input State
// -----------------------------------------------------------------------------

/// Analog axis values
struct ControllerAxes {
    trigger: Float          // 0.0 - 1.0
    grip: Float             // 0.0 - 1.0
    thumbstick_x: Float     // -1.0 - 1.0
    thumbstick_y: Float     // -1.0 - 1.0
    
    fn new() -> Self {
        ControllerAxes {
            trigger: 0.0,
            grip: 0.0,
            thumbstick_x: 0.0,
            thumbstick_y: 0.0
        }
    }
    
    fn thumbstick() -> (Float, Float) {
        (self.thumbstick_x, self.thumbstick_y)
    }
    
    fn thumbstick_magnitude() -> Float {
        (self.thumbstick_x * self.thumbstick_x + self.thumbstick_y * self.thumbstick_y).sqrt()
    }
    
    fn thumbstick_angle() -> Float {
        self.thumbstick_y.atan2(self.thumbstick_x)
    }
    
    fn thumbstick_with_deadzone(deadzone: Float) -> (Float, Float) {
        let mag = self.thumbstick_magnitude()
        if mag < deadzone {
            (0.0, 0.0)
        } else {
            let scale = (mag - deadzone) / (1.0 - deadzone) / mag
            (self.thumbstick_x * scale, self.thumbstick_y * scale)
        }
    }
    
    fn is_trigger_pressed() -> Bool { self.trigger > 0.5 }
    fn is_grip_pressed() -> Bool { self.grip > 0.5 }
}

/// Controller pose (position and orientation)
struct ControllerPose {
    position: Point3D
    rotation: Quaternion
    velocity: Point3D
    angular_velocity: Point3D
    is_valid: Bool
    
    fn new() -> Self {
        ControllerPose {
            position: Point3D.origin(),
            rotation: Quaternion.identity(),
            velocity: Point3D.origin(),
            angular_velocity: Point3D.origin(),
            is_valid: false
        }
    }
    
    fn from_transform(transform: Transform3D) -> Self {
        ControllerPose {
            position: transform.position(),
            rotation: transform.rotation(),
            velocity: Point3D.origin(),
            angular_velocity: Point3D.origin(),
            is_valid: true
        }
    }
    
    fn transform() -> Transform3D {
        Transform3D.from_position_rotation(self.position, self.rotation)
    }
    
    fn forward() -> Point3D {
        self.rotation.rotate_vector(Point3D.new(0.0, 0.0, -1.0))
    }
    
    fn up() -> Point3D {
        self.rotation.rotate_vector(Point3D.new(0.0, 1.0, 0.0))
    }
    
    fn right() -> Point3D {
        self.rotation.rotate_vector(Point3D.new(1.0, 0.0, 0.0))
    }
    
    fn predict(delta_time: Float) -> Self {
        ControllerPose {
            position: Point3D.new(
                self.position.x + self.velocity.x * delta_time,
                self.position.y + self.velocity.y * delta_time,
                self.position.z + self.velocity.z * delta_time
            ),
            rotation: self.rotation.integrate_angular_velocity(self.angular_velocity, delta_time),
            velocity: self.velocity,
            angular_velocity: self.angular_velocity,
            is_valid: self.is_valid
        }
    }
    
    fn speed() -> Float {
        (self.velocity.x * self.velocity.x + 
         self.velocity.y * self.velocity.y + 
         self.velocity.z * self.velocity.z).sqrt()
    }
}

/// Complete controller input state
struct ControllerState {
    hand: ControllerHand
    controller_type: ControllerType
    connection_state: ControllerConnectionState
    pose: ControllerPose
    axes: ControllerAxes
    button_states: Map<ControllerButton, ButtonState>
    touch_states: Map<ControllerButton, TouchState>
    battery_level: Float
    timestamp: Float64
    
    fn new(hand: ControllerHand) -> Self {
        ControllerState {
            hand: hand,
            controller_type: ControllerType.Unknown,
            connection_state: ControllerConnectionState.Disconnected,
            pose: ControllerPose.new(),
            axes: ControllerAxes.new(),
            button_states: Map.new(),
            touch_states: Map.new(),
            battery_level: 1.0,
            timestamp: 0.0
        }
    }
    
    fn is_connected() -> Bool {
        self.connection_state.is_available()
    }
    
    fn is_tracking() -> Bool {
        self.pose.is_valid
    }
    
    fn button(btn: ControllerButton) -> ButtonState {
        self.button_states.get(btn).unwrap_or(ButtonState.Released)
    }
    
    fn is_button_pressed(btn: ControllerButton) -> Bool {
        self.button(btn).is_down()
    }
    
    fn is_button_just_pressed(btn: ControllerButton) -> Bool {
        self.button(btn) == ButtonState.JustPressed
    }
    
    fn is_button_just_released(btn: ControllerButton) -> Bool {
        self.button(btn) == ButtonState.JustReleased
    }
    
    fn touch(btn: ControllerButton) -> TouchState {
        self.touch_states.get(btn).unwrap_or(TouchState.NotTouching)
    }
    
    fn is_touching(btn: ControllerButton) -> Bool {
        self.touch(btn).is_touching()
    }
    
    fn trigger() -> Float { self.axes.trigger }
    fn grip() -> Float { self.axes.grip }
    fn thumbstick() -> (Float, Float) { self.axes.thumbstick() }
}

// -----------------------------------------------------------------------------
// Haptic Feedback
// -----------------------------------------------------------------------------

/// Haptic pulse parameters
struct HapticPulse {
    duration_ms: Int
    intensity: Float      // 0.0 - 1.0
    frequency: Float      // Hz, 0 for default
    
    fn new(duration_ms: Int, intensity: Float) -> Self {
        HapticPulse {
            duration_ms: duration_ms.min(HAPTIC_MAX_DURATION_MS),
            intensity: intensity.clamp(0.0, HAPTIC_MAX_INTENSITY),
            frequency: 0.0
        }
    }
    
    fn with_frequency(duration_ms: Int, intensity: Float, frequency: Float) -> Self {
        HapticPulse {
            duration_ms: duration_ms.min(HAPTIC_MAX_DURATION_MS),
            intensity: intensity.clamp(0.0, HAPTIC_MAX_INTENSITY),
            frequency: frequency
        }
    }
    
    fn short() -> Self { HapticPulse.new(50, 0.5) }
    fn medium() -> Self { HapticPulse.new(100, 0.7) }
    fn strong() -> Self { HapticPulse.new(200, 1.0) }
    fn light() -> Self { HapticPulse.new(30, 0.3) }
}

/// Haptic pattern for complex feedback
struct HapticPattern {
    pulses: [(Int, HapticPulse)]  // (delay_ms, pulse)
    repeat_count: Int
    
    fn new() -> Self {
        HapticPattern { pulses: [], repeat_count: 1 }
    }
    
    fn add_pulse(delay_ms: Int, pulse: HapticPulse) -> Self {
        self.pulses.push((delay_ms, pulse))
        self
    }
    
    fn repeat(count: Int) -> Self {
        self.repeat_count = count
        self
    }
    
    fn click() -> Self {
        HapticPattern.new().add_pulse(0, HapticPulse.short())
    }
    
    fn double_click() -> Self {
        HapticPattern.new()
            .add_pulse(0, HapticPulse.short())
            .add_pulse(100, HapticPulse.short())
    }
    
    fn success() -> Self {
        HapticPattern.new()
            .add_pulse(0, HapticPulse.light())
            .add_pulse(50, HapticPulse.medium())
            .add_pulse(100, HapticPulse.strong())
    }
    
    fn error() -> Self {
        HapticPattern.new()
            .add_pulse(0, HapticPulse.strong())
            .add_pulse(150, HapticPulse.strong())
            .add_pulse(300, HapticPulse.strong())
    }
    
    fn heartbeat() -> Self {
        HapticPattern.new()
            .add_pulse(0, HapticPulse.medium())
            .add_pulse(100, HapticPulse.light())
            .repeat(3)
    }
    
    fn total_duration_ms() -> Int {
        var max_end = 0
        for (delay, pulse) in self.pulses {
            max_end = max_end.max(delay + pulse.duration_ms)
        }
        max_end * self.repeat_count
    }
}

// -----------------------------------------------------------------------------
// Controller Events
// -----------------------------------------------------------------------------

/// Controller event types
enum ControllerEvent {
    Connected(ControllerHand, ControllerType)
    Disconnected(ControllerHand)
    ButtonPressed(ControllerHand, ControllerButton)
    ButtonReleased(ControllerHand, ControllerButton)
    TouchStarted(ControllerHand, ControllerButton)
    TouchEnded(ControllerHand, ControllerButton)
    TriggerChanged(ControllerHand, Float)
    GripChanged(ControllerHand, Float)
    ThumbstickMoved(ControllerHand, Float, Float)
    PoseUpdated(ControllerHand, ControllerPose)
    BatteryLow(ControllerHand, Float)
    TrackingLost(ControllerHand)
    TrackingRestored(ControllerHand)
}

/// Controller event handler trait
trait ControllerEventHandler {
    fn on_event(event: ControllerEvent)
}

// -----------------------------------------------------------------------------
// VR Controller Actor
// -----------------------------------------------------------------------------

/// VR controller manager actor
actor VRControllerManager {
    state left_controller: ControllerState
    state right_controller: ControllerState
    state event_handlers: [ControllerEventHandler]
    state event_channel: Option<Sender<ControllerEvent>>
    state is_running: Bool
    
    fn new() -> Self {
        VRControllerManager {
            left_controller: ControllerState.new(ControllerHand.Left),
            right_controller: ControllerState.new(ControllerHand.Right),
            event_handlers: [],
            event_channel: None,
            is_running: false
        }
    }
    
    fn start() -> Result<(), ControllerError> {
        if self.is_running { return Ok(()) }
        
        @native("vr_controller_init")?
        self.is_running = true
        Ok(())
    }
    
    fn stop() {
        if self.is_running {
            @native("vr_controller_shutdown")
            self.is_running = false
        }
    }
    
    fn update() {
        if !self.is_running { return }
        
        // Update controller states
        let left_state = @native("vr_controller_get_state", ControllerHand.Left)
        let right_state = @native("vr_controller_get_state", ControllerHand.Right)
        
        self.process_state_update(ControllerHand.Left, left_state)
        self.process_state_update(ControllerHand.Right, right_state)
    }
    
    fn get_controller(hand: ControllerHand) -> ControllerState {
        match hand {
            ControllerHand.Left => self.left_controller.clone(),
            ControllerHand.Right => self.right_controller.clone()
        }
    }
    
    fn left() -> ControllerState { self.left_controller.clone() }
    fn right() -> ControllerState { self.right_controller.clone() }
    
    fn is_controller_connected(hand: ControllerHand) -> Bool {
        self.get_controller(hand).is_connected()
    }
    
    fn both_connected() -> Bool {
        self.left_controller.is_connected() && self.right_controller.is_connected()
    }
    
    fn any_connected() -> Bool {
        self.left_controller.is_connected() || self.right_controller.is_connected()
    }
    
    fn vibrate(hand: ControllerHand, pulse: HapticPulse) {
        if !self.get_controller(hand).is_connected() { return }
        @native("vr_controller_vibrate", hand, pulse)
    }
    
    fn vibrate_pattern(hand: ControllerHand, pattern: HapticPattern) {
        if !self.get_controller(hand).is_connected() { return }
        @native("vr_controller_vibrate_pattern", hand, pattern)
    }
    
    fn vibrate_both(pulse: HapticPulse) {
        self.vibrate(ControllerHand.Left, pulse.clone())
        self.vibrate(ControllerHand.Right, pulse)
    }
    
    fn stop_vibration(hand: ControllerHand) {
        @native("vr_controller_stop_vibration", hand)
    }
    
    fn stop_all_vibration() {
        self.stop_vibration(ControllerHand.Left)
        self.stop_vibration(ControllerHand.Right)
    }
    
    fn add_event_handler(handler: ControllerEventHandler) {
        self.event_handlers.push(handler)
    }
    
    fn subscribe_events() -> Receiver<ControllerEvent> {
        let (tx, rx) = Channel.new()
        self.event_channel = Some(tx)
        rx
    }
    
    // Internal methods
    fn process_state_update(hand: ControllerHand, new_state: ControllerState) {
        let old_state = match hand {
            ControllerHand.Left => self.left_controller.clone(),
            ControllerHand.Right => self.right_controller.clone()
        }
        
        // Detect connection changes
        if !old_state.is_connected() && new_state.is_connected() {
            self.emit_event(ControllerEvent.Connected(hand, new_state.controller_type))
        } else if old_state.is_connected() && !new_state.is_connected() {
            self.emit_event(ControllerEvent.Disconnected(hand))
        }
        
        // Detect button changes
        for btn in [ControllerButton.Trigger, ControllerButton.Grip, 
                    ControllerButton.Primary, ControllerButton.Secondary,
                    ControllerButton.Thumbstick, ControllerButton.Menu] {
            let old_pressed = old_state.is_button_pressed(btn)
            let new_pressed = new_state.is_button_pressed(btn)
            
            if !old_pressed && new_pressed {
                self.emit_event(ControllerEvent.ButtonPressed(hand, btn))
            } else if old_pressed && !new_pressed {
                self.emit_event(ControllerEvent.ButtonReleased(hand, btn))
            }
        }
        
        // Detect tracking changes
        if old_state.is_tracking() && !new_state.is_tracking() {
            self.emit_event(ControllerEvent.TrackingLost(hand))
        } else if !old_state.is_tracking() && new_state.is_tracking() {
            self.emit_event(ControllerEvent.TrackingRestored(hand))
        }
        
        // Update stored state
        match hand {
            ControllerHand.Left => self.left_controller = new_state,
            ControllerHand.Right => self.right_controller = new_state
        }
    }
    
    fn emit_event(event: ControllerEvent) {
        for handler in self.event_handlers {
            handler.on_event(event.clone())
        }
        if let Some(tx) = self.event_channel {
            tx.send(event)
        }
    }
}

// -----------------------------------------------------------------------------
// Controller Errors
// -----------------------------------------------------------------------------

enum ControllerError {
    NotInitialized
    DeviceNotFound
    TrackingLost
    HapticFailed
    InternalError(String)
    
    fn message() -> String {
        match self {
            NotInitialized => "Controller system not initialized",
            DeviceNotFound => "Controller device not found",
            TrackingLost => "Controller tracking lost",
            HapticFailed => "Haptic feedback failed",
            InternalError(msg) => format!("Internal error: {}", msg)
        }
    }
}

// -----------------------------------------------------------------------------
// Gesture Detection
// -----------------------------------------------------------------------------

/// Controller gesture types
enum ControllerGesture {
    None
    Point
    Fist
    ThumbsUp
    Peace
    OpenHand
    Pinch
    Grab
    
    fn requires_finger_tracking() -> Bool {
        match self {
            Point | Fist | ThumbsUp | Peace | OpenHand => true,
            _ => false
        }
    }
}

/// Gesture detector for controllers
struct GestureDetector {
    sensitivity: Float
    
    fn new() -> Self {
        GestureDetector { sensitivity: 0.7 }
    }
    
    fn with_sensitivity(sensitivity: Float) -> Self {
        GestureDetector { sensitivity: sensitivity.clamp(0.0, 1.0) }
    }
    
    fn detect(state: ControllerState) -> ControllerGesture {
        // Simple gesture detection based on button states
        let trigger = state.axes.trigger
        let grip = state.axes.grip
        
        if trigger > 0.8 && grip > 0.8 {
            return ControllerGesture.Fist
        }
        if trigger > 0.8 && grip < 0.2 {
            return ControllerGesture.Point
        }
        if trigger < 0.2 && grip > 0.8 {
            return ControllerGesture.Grab
        }
        if trigger > 0.5 && grip > 0.5 {
            return ControllerGesture.Pinch
        }
        
        ControllerGesture.None
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Create and initialize controller manager
fn init_controllers() -> Result<VRControllerManager, ControllerError> {
    let manager = VRControllerManager.new()
    manager.start()?
    Ok(manager)
}

/// Quick haptic feedback
fn vibrate(hand: ControllerHand, intensity: Float, duration_ms: Int) {
    @native("vr_controller_vibrate", hand, HapticPulse.new(duration_ms, intensity))
}

/// Check if VR controllers are supported
fn controllers_supported() -> Bool {
    @native("vr_controllers_supported")
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "controller_hand" {
    assert_eq(ControllerHand.Left.opposite(), ControllerHand.Right)?
    assert_eq(ControllerHand.Right.opposite(), ControllerHand.Left)?
    assert_eq(ControllerHand.Left.index(), 0)?
}

test "controller_type_features" {
    assert(ControllerType.ValveIndex.has_finger_tracking())?
    assert(!ControllerType.ViveWand.has_finger_tracking())?
    assert(ControllerType.OculusTouch.has_capacitive_touch())?
}

test "button_state" {
    assert(ButtonState.Pressed.is_down())?
    assert(ButtonState.JustPressed.is_down())?
    assert(!ButtonState.Released.is_down())?
    assert(ButtonState.JustPressed.just_changed())?
}

test "controller_axes_deadzone" {
    let mut axes = ControllerAxes.new()
    axes.thumbstick_x = 0.05
    axes.thumbstick_y = 0.05
    
    let (x, y) = axes.thumbstick_with_deadzone(0.1)
    assert_eq(x, 0.0)?
    assert_eq(y, 0.0)?
}

test "haptic_pulse" {
    let pulse = HapticPulse.new(100, 0.8)
    assert_eq(pulse.duration_ms, 100)?
    assert_eq(pulse.intensity, 0.8)?
}

test "haptic_pattern" {
    let pattern = HapticPattern.double_click()
    assert_eq(pattern.pulses.len(), 2)?
}

test "controller_pose_prediction" {
    let mut pose = ControllerPose.new()
    pose.position = Point3D.new(0.0, 1.0, 0.0)
    pose.velocity = Point3D.new(1.0, 0.0, 0.0)
    pose.is_valid = true
    
    let predicted = pose.predict(0.1)
    assert_eq(predicted.position.x, 0.1)?
    assert_eq(predicted.position.y, 1.0)?
}

test "gesture_detection" {
    let mut state = ControllerState.new(ControllerHand.Right)
    state.axes.trigger = 0.9
    state.axes.grip = 0.9
    
    let detector = GestureDetector.new()
    assert_eq(detector.detect(state), ControllerGesture.Fist)?
}
