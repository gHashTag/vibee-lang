// =============================================================================
// Vibee OS â€” BLAKE3 Module
// BLAKE3 cryptographic hash function
// =============================================================================
//
// BLAKE3 is a modern cryptographic hash function that offers:
// - Extremely high performance (faster than MD5 on modern CPUs)
// - Security equivalent to SHA-3
// - Built-in support for keyed hashing (MAC)
// - Built-in key derivation function (KDF)
// - Extendable output (XOF)
// - Tree hashing for parallelism
// - Incremental updates
//
// BLAKE3 is the recommended hash function for new applications.
// =============================================================================

const DIGEST_SIZE: Int = 32
const KEY_SIZE: Int = 32
const BLOCK_SIZE: Int = 64
const CHUNK_SIZE: Int = 1024

// Initial vector (same as BLAKE2s)
const IV: [UInt32; 8] = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]

// Message permutation schedule
const MSG_SCHEDULE: [[Int; 16]; 7] = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8],
    [3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1],
    [10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6],
    [12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4],
    [9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7],
    [11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13]
]

// =============================================================================
// Core Functions
// =============================================================================

/// Compute BLAKE3 hash of byte array (default 32 bytes)
fn hash(data: [UInt8]) -> [UInt8; 32] {
    @native("blake3", data)
}

/// Compute BLAKE3 hash with custom output length
fn hash_xof(data: [UInt8], output_len: Int) -> [UInt8] {
    @native("blake3_xof", data, output_len)
}

/// Compute BLAKE3 hash and return as hex string
fn hash_hex(data: [UInt8]) -> String {
    hex.encode(hash(data))
}

/// Compute BLAKE3 hash of string
fn hash_string(s: String) -> [UInt8; 32] {
    hash(s.as_bytes())
}

/// Compute BLAKE3 hash of string and return as hex string
fn hash_string_hex(s: String) -> String {
    hex.encode(hash_string(s))
}

/// Compute BLAKE3 hash of file
fn hash_file(path: String) -> Result<[UInt8; 32], Blake3Error> {
    let data = fs.read_bytes(path).map_err(|e| Blake3Error.IoError(e.to_string()))?
    Ok(hash(data))
}

/// Compute BLAKE3 hash of file and return as hex string
fn hash_file_hex(path: String) -> Result<String, Blake3Error> {
    Ok(hex.encode(hash_file(path)?))
}

/// Compute BLAKE3 hash of file with memory-mapped I/O for large files
fn hash_file_mmap(path: String) -> Result<[UInt8; 32], Blake3Error> {
    @native("blake3_file_mmap", path).map_err(|e| Blake3Error.IoError(e))
}

// =============================================================================
// Keyed Hashing (MAC)
// =============================================================================

/// Compute keyed BLAKE3 hash (MAC)
fn keyed_hash(key: [UInt8; 32], data: [UInt8]) -> [UInt8; 32] {
    @native("blake3_keyed", key, data)
}

/// Compute keyed BLAKE3 hash and return as hex string
fn keyed_hash_hex(key: [UInt8; 32], data: [UInt8]) -> String {
    hex.encode(keyed_hash(key, data))
}

/// Compute keyed BLAKE3 hash with string inputs
fn keyed_hash_string(key: [UInt8; 32], data: String) -> [UInt8; 32] {
    keyed_hash(key, data.as_bytes())
}

/// Verify keyed hash in constant time
fn verify_keyed(key: [UInt8; 32], data: [UInt8], expected: [UInt8; 32]) -> Bool {
    crypto.constant_time_eq(keyed_hash(key, data), expected)
}

// =============================================================================
// Key Derivation Function (KDF)
// =============================================================================

/// Derive key using BLAKE3 KDF
fn derive_key(context: String, key_material: [UInt8], output_len: Int) -> [UInt8] {
    @native("blake3_derive_key", context, key_material, output_len)
}

/// Derive 32-byte key
fn derive_key_32(context: String, key_material: [UInt8]) -> [UInt8; 32] {
    derive_key(context, key_material, 32).try_into().unwrap()
}

/// Derive key from password (with salt in context)
fn derive_key_from_password(context: String, password: String, output_len: Int) -> [UInt8] {
    derive_key(context, password.as_bytes(), output_len)
}

// =============================================================================
// BLAKE3 Digest Struct
// =============================================================================

/// Fixed-size BLAKE3 digest (32 bytes / 256 bits)
struct Blake3Digest {
    bytes: [UInt8; 32]
}

impl Blake3Digest {
    /// Create digest from bytes
    fn from_bytes(bytes: [UInt8; 32]) -> Self {
        Blake3Digest { bytes: bytes }
    }
    
    /// Create digest from hex string
    fn from_hex(s: String) -> Result<Self, Blake3Error> {
        let bytes = hex.decode(s).map_err(|_| Blake3Error.InvalidHex)?
        if bytes.len() != 32 {
            return Err(Blake3Error.InvalidLength)
        }
        Ok(Blake3Digest { bytes: bytes.try_into().unwrap() })
    }
    
    /// Create zero digest
    fn zero() -> Self {
        Blake3Digest { bytes: [0; 32] }
    }
    
    /// Get bytes
    fn as_bytes() -> [UInt8; 32] {
        self.bytes
    }
    
    /// Convert to hex string
    fn to_hex() -> String {
        hex.encode(self.bytes)
    }
    
    /// Convert to uppercase hex string
    fn to_hex_upper() -> String {
        hex.encode_upper(self.bytes)
    }
    
    /// Convert to base64
    fn to_base64() -> String {
        base64.encode(self.bytes)
    }
    
    /// Convert to base64 URL-safe
    fn to_base64_url() -> String {
        base64.encode_url_safe(self.bytes)
    }
    
    /// Compare digests in constant time
    fn eq(other: Blake3Digest) -> Bool {
        crypto.constant_time_eq(self.bytes, other.bytes)
    }
    
    /// Check if zero
    fn is_zero() -> Bool {
        self.bytes.iter().all(|b| b == 0)
    }
    
    /// Get first N bytes as hex (for short identifiers)
    fn short(len: Int) -> String {
        hex.encode(self.bytes[0..len.min(32)])
    }
    
    /// XOR with another digest
    fn xor(other: Blake3Digest) -> Blake3Digest {
        var result = [0u8; 32]
        for i in 0..32 {
            result[i] = self.bytes[i] ^ other.bytes[i]
        }
        Blake3Digest { bytes: result }
    }
}

impl Display for Blake3Digest {
    fn fmt(f: Formatter) {
        f.write(self.to_hex())
    }
}

impl Hash for Blake3Digest {
    fn hash(hasher: Hasher) {
        hasher.write(self.bytes)
    }
}

impl Ord for Blake3Digest {
    fn cmp(other: Blake3Digest) -> Ordering {
        for i in 0..32 {
            if self.bytes[i] < other.bytes[i] { return Ordering.Less }
            if self.bytes[i] > other.bytes[i] { return Ordering.Greater }
        }
        Ordering.Equal
    }
}

// =============================================================================
// Incremental Hasher
// =============================================================================

/// Incremental BLAKE3 hasher for streaming data
struct Blake3Hasher {
    inner: @native("Blake3Hasher")
}

impl Blake3Hasher {
    /// Create new BLAKE3 hasher
    fn new() -> Self {
        Blake3Hasher { inner: @native("blake3_hasher_new") }
    }
    
    /// Create keyed hasher
    fn new_keyed(key: [UInt8; 32]) -> Self {
        Blake3Hasher { inner: @native("blake3_hasher_new_keyed", key) }
    }
    
    /// Create KDF hasher
    fn new_derive_key(context: String) -> Self {
        Blake3Hasher { inner: @native("blake3_hasher_new_derive_key", context) }
    }
    
    /// Update hasher with data
    fn update(data: [UInt8]) -> Self {
        @native("blake3_hasher_update", self.inner, data)
        self
    }
    
    /// Update hasher with string
    fn update_str(s: String) -> Self {
        self.update(s.as_bytes())
    }
    
    /// Update hasher with integer (little-endian, BLAKE3 native)
    fn update_u32_le(v: UInt32) -> Self {
        self.update([v as UInt8, (v >> 8) as UInt8, (v >> 16) as UInt8, (v >> 24) as UInt8])
    }
    
    /// Update hasher with integer (little-endian)
    fn update_u64_le(v: UInt64) -> Self {
        self.update([
            v as UInt8, (v >> 8) as UInt8, (v >> 16) as UInt8, (v >> 24) as UInt8,
            (v >> 32) as UInt8, (v >> 40) as UInt8, (v >> 48) as UInt8, (v >> 56) as UInt8
        ])
    }
    
    /// Finalize and get digest (32 bytes)
    fn finalize() -> Blake3Digest {
        let bytes = @native("blake3_hasher_finalize", self.inner)
        Blake3Digest { bytes: bytes }
    }
    
    /// Finalize with custom output length (XOF)
    fn finalize_xof(output_len: Int) -> [UInt8] {
        @native("blake3_hasher_finalize_xof", self.inner, output_len)
    }
    
    /// Finalize and get hex string
    fn finalize_hex() -> String {
        self.finalize().to_hex()
    }
    
    /// Reset hasher for reuse
    fn reset() {
        @native("blake3_hasher_reset", self.inner)
    }
    
    /// Clone hasher state
    fn clone() -> Self {
        Blake3Hasher { inner: @native("blake3_hasher_clone", self.inner) }
    }
    
    /// Get number of bytes processed
    fn count() -> UInt64 {
        @native("blake3_hasher_count", self.inner)
    }
}

// =============================================================================
// Streaming Actor
// =============================================================================

/// Actor for streaming BLAKE3 computation
actor Blake3Stream {
    state hasher: Blake3Hasher
    state total_bytes: Int
    
    fn new() -> Self {
        Blake3Stream { hasher: Blake3Hasher.new(), total_bytes: 0 }
    }
    
    fn new_keyed(key: [UInt8; 32]) -> Self {
        Blake3Stream { hasher: Blake3Hasher.new_keyed(key), total_bytes: 0 }
    }
    
    /// Write data to stream
    fn write(data: [UInt8]) {
        self.hasher.update(data)
        self.total_bytes += data.len()
    }
    
    /// Write string to stream
    fn write_str(s: String) {
        self.write(s.as_bytes())
    }
    
    /// Get current byte count
    fn bytes_processed() -> Int {
        self.total_bytes
    }
    
    /// Finalize and get digest
    fn finalize() -> Blake3Digest {
        self.hasher.finalize()
    }
    
    /// Finalize with custom output length
    fn finalize_xof(output_len: Int) -> [UInt8] {
        self.hasher.finalize_xof(output_len)
    }
    
    /// Reset stream
    fn reset() {
        self.hasher.reset()
        self.total_bytes = 0
    }
}

// =============================================================================
// Parallel Hashing
// =============================================================================

/// Hash multiple chunks in parallel
fn hash_parallel(chunks: [[UInt8]]) -> [Blake3Digest] {
    @native("blake3_parallel", chunks)
}

/// Hash file using parallel tree hashing
fn hash_file_parallel(path: String, num_threads: Int) -> Result<Blake3Digest, Blake3Error> {
    @native("blake3_file_parallel", path, num_threads).map_err(|e| Blake3Error.IoError(e))
}

// =============================================================================
// Verification
// =============================================================================

/// Verify data against expected BLAKE3 hash (hex string)
fn verify(data: [UInt8], expected_hex: String) -> Bool {
    let computed = hash_hex(data)
    crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes())
}

/// Verify string against expected BLAKE3 hash
fn verify_string(s: String, expected_hex: String) -> Bool {
    verify(s.as_bytes(), expected_hex)
}

/// Verify file against expected BLAKE3 hash
fn verify_file(path: String, expected_hex: String) -> Result<Bool, Blake3Error> {
    let computed = hash_file_hex(path)?
    Ok(crypto.constant_time_eq(computed.as_bytes(), expected_hex.to_lowercase().as_bytes()))
}

// =============================================================================
// Merkle Tree Support
// =============================================================================

/// Compute Merkle parent hash using BLAKE3
fn merkle_parent(left: Blake3Digest, right: Blake3Digest) -> Blake3Digest {
    var hasher = Blake3Hasher.new()
    hasher.update(left.bytes)
    hasher.update(right.bytes)
    hasher.finalize()
}

/// Compute Merkle root from list of hashes
fn merkle_root(hashes: [Blake3Digest]) -> Option<Blake3Digest> {
    if hashes.is_empty() { return None }
    if hashes.len() == 1 { return Some(hashes[0]) }
    
    var current = hashes
    while current.len() > 1 {
        var next = []
        for i in (0..current.len()).step_by(2) {
            let left = current[i]
            let right = if i + 1 < current.len() { current[i + 1] } else { current[i] }
            next.push(merkle_parent(left, right))
        }
        current = next
    }
    
    Some(current[0])
}

// =============================================================================
// Content-Addressable Storage
// =============================================================================

/// Content ID based on BLAKE3 hash
struct ContentId {
    digest: Blake3Digest
}

impl ContentId {
    fn from_data(data: [UInt8]) -> Self {
        ContentId { digest: Blake3Digest { bytes: hash(data) } }
    }
    
    fn from_string(s: String) -> Self {
        Self.from_data(s.as_bytes())
    }
    
    fn from_hex(s: String) -> Result<Self, Blake3Error> {
        Ok(ContentId { digest: Blake3Digest.from_hex(s)? })
    }
    
    fn to_hex() -> String {
        self.digest.to_hex()
    }
    
    fn to_path() -> String {
        let hex = self.to_hex()
        format!("{}/{}/{}", hex[0..2], hex[2..4], hex)
    }
    
    fn eq(other: ContentId) -> Bool {
        self.digest.eq(other.digest)
    }
}

impl Display for ContentId {
    fn fmt(f: Formatter) {
        f.write(format!("blake3:{}", self.to_hex()))
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Check if string is valid BLAKE3 hex hash
fn is_valid_hash(s: String) -> Bool {
    s.len() == 64 && s.chars().all(|c| c.is_ascii_hexdigit())
}

/// Parse BLAKE3 hash from various formats
fn parse(s: String) -> Result<Blake3Digest, Blake3Error> {
    let s = s.trim().to_lowercase()
    
    // Remove common prefixes
    let s = if s.starts_with("blake3:") { s[7..] } else { s }
    let s = if s.starts_with("b3:") { s[3..] } else { s }
    let s = if s.starts_with("0x") { s[2..] } else { s }
    
    Blake3Digest.from_hex(s)
}

/// Format digest with prefix
fn format_with_prefix(digest: Blake3Digest) -> String {
    format!("blake3:{}", digest.to_hex())
}

/// Generate random key for keyed hashing
fn generate_key() -> [UInt8; 32] {
    crypto.random_bytes(32).try_into().unwrap()
}

// =============================================================================
// Errors
// =============================================================================

enum Blake3Error {
    InvalidHex
    InvalidLength
    InvalidKey
    IoError(String)
}

impl Display for Blake3Error {
    fn fmt(f: Formatter) {
        match self {
            InvalidHex => f.write("Invalid hexadecimal string")
            InvalidLength => f.write("Invalid BLAKE3 hash length (expected 32 bytes)")
            InvalidKey => f.write("Invalid key length (expected 32 bytes)")
            IoError(s) => f.write(format!("I/O error: {}", s))
        }
    }
}

// =============================================================================
// Trait Implementations
// =============================================================================

trait Blake3Hashable {
    fn blake3() -> Blake3Digest
}

impl Blake3Hashable for [UInt8] {
    fn blake3() -> Blake3Digest {
        Blake3Digest { bytes: hash(self) }
    }
}

impl Blake3Hashable for String {
    fn blake3() -> Blake3Digest {
        Blake3Digest { bytes: hash_string(self) }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "empty string" {
    // BLAKE3 hash of empty input
    let expected = "af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262"
    assert_eq(hash_string_hex(""), expected)?
}

test "hello world" {
    let digest = hash_string("hello")
    assert_eq(digest.len(), 32)?
}

test "incremental hashing" {
    var hasher = Blake3Hasher.new()
    hasher.update_str("hello")
    hasher.update_str(" ")
    hasher.update_str("world")
    assert_eq(hasher.finalize_hex(), hash_string_hex("hello world"))?
}

test "xof output" {
    let short = hash_xof("hello".as_bytes(), 16)
    let long = hash_xof("hello".as_bytes(), 64)
    assert_eq(short.len(), 16)?
    assert_eq(long.len(), 64)?
    // First 16 bytes should match
    assert_eq(short, long[0..16])?
}

test "keyed hashing" {
    let key = [0u8; 32]
    let mac1 = keyed_hash(key, "hello".as_bytes())
    let mac2 = keyed_hash(key, "hello".as_bytes())
    assert_eq(mac1, mac2)?
    
    let mac3 = keyed_hash(key, "world".as_bytes())
    assert_ne(mac1, mac3)?
}

test "key derivation" {
    let context = "my-app v1.0 encryption key"
    let key_material = "user-password".as_bytes()
    let key1 = derive_key_32(context, key_material)
    let key2 = derive_key_32(context, key_material)
    assert_eq(key1, key2)?
    
    // Different context = different key
    let key3 = derive_key_32("different context", key_material)
    assert_ne(key1, key3)?
}

test "digest from hex" {
    let hex_str = "af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262"
    let digest = Blake3Digest.from_hex(hex_str)?
    assert_eq(digest.to_hex(), hex_str)?
}

test "verify" {
    let expected = hash_string_hex("hello")
    assert(verify_string("hello", expected))?
    assert(!verify_string("hello", "0".repeat(64)))?
}

test "is_valid_hash" {
    assert(is_valid_hash("af1349b9f5f9a1a6a0404dea36dcc9499bcb25c9adc112b7cc9a93cae41f3262"))?
    assert(!is_valid_hash("invalid"))?
}

test "merkle root" {
    let h1 = "hello".blake3()
    let h2 = "world".blake3()
    let root = merkle_root([h1, h2])
    assert(root.is_some())?
}

test "content id" {
    let cid = ContentId.from_string("hello")
    assert_eq(cid.to_hex().len(), 64)?
    assert(cid.to_path().contains("/"))?
}

test "streaming actor" {
    var stream = Blake3Stream.new()
    stream.write_str("hello")
    stream.write_str(" world")
    assert_eq(stream.bytes_processed(), 11)?
    assert_eq(stream.finalize().to_hex(), hash_string_hex("hello world"))?
}

test "trait implementation" {
    let digest = "hello".blake3()
    assert_eq(digest.to_hex().len(), 64)?
}

test "hasher clone" {
    var hasher1 = Blake3Hasher.new()
    hasher1.update_str("hello")
    var hasher2 = hasher1.clone()
    hasher1.update_str(" world")
    hasher2.update_str(" there")
    assert_ne(hasher1.finalize_hex(), hasher2.finalize_hex())?
}
