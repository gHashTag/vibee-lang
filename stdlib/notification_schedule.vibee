// =============================================================================
// Vibee OS â€” Notification Schedule Module
// Scheduling and timing for notifications
// =============================================================================

use datetime.{DateTime, Duration, Weekday}

// =============================================================================
// Schedule Types & Enums
// =============================================================================

enum ScheduleType {
    Once,
    Recurring,
    Interval,
    Calendar,
    Location,
    Conditional
}

enum RecurrenceRule {
    Daily,
    Weekly([Weekday]),
    Monthly([Int]),
    Yearly,
    Custom(String)
}

enum TriggerType {
    Time(DateTime),
    Interval(Duration),
    Location(GeoTrigger),
    Calendar(CalendarTrigger),
    Event(String)
}

// =============================================================================
// Scheduled Notification
// =============================================================================

struct ScheduledNotification {
    id: String
    notification_id: String
    trigger: TriggerType
    schedule_type: ScheduleType
    recurrence: Option<RecurrenceRule>
    repeat_count: Option<Int>
    end_date: Option<DateTime>
    timezone: String
    enabled: Bool
    created_at: DateTime
    next_fire: Option<DateTime>
    last_fired: Option<DateTime>
    fire_count: Int
}

impl ScheduledNotification {
    fn new(notification_id: String, trigger: TriggerType) -> Self {
        ScheduledNotification {
            id: UUID.v4(),
            notification_id: notification_id,
            trigger: trigger,
            schedule_type: ScheduleType.Once,
            recurrence: None,
            repeat_count: None,
            end_date: None,
            timezone: "UTC",
            enabled: true,
            created_at: DateTime.now(),
            next_fire: None,
            last_fired: None,
            fire_count: 0
        }
    }
    
    fn at_time(notification_id: String, time: DateTime) -> Self {
        let mut sched = ScheduledNotification.new(notification_id, TriggerType.Time(time));
        sched.next_fire = Some(time);
        sched
    }
    
    fn after_interval(notification_id: String, interval: Duration) -> Self {
        let fire_time = DateTime.now().add(interval);
        let mut sched = ScheduledNotification.new(notification_id, TriggerType.Interval(interval));
        sched.next_fire = Some(fire_time);
        sched
    }
    
    fn recurring(recurrence: RecurrenceRule) -> Self {
        self.schedule_type = ScheduleType.Recurring;
        self.recurrence = Some(recurrence);
        self.calculate_next_fire();
        self
    }
    
    fn repeat(count: Int) -> Self { self.repeat_count = Some(count); self }
    fn until(date: DateTime) -> Self { self.end_date = Some(date); self }
    fn timezone(tz: String) -> Self { self.timezone = tz; self }
    fn enable() -> Self { self.enabled = true; self }
    fn disable() -> Self { self.enabled = false; self }
    
    fn is_due() -> Bool {
        match self.next_fire {
            Some(fire) => DateTime.now() >= fire && self.enabled,
            None => false
        }
    }
    
    fn is_expired() -> Bool {
        match self.end_date {
            Some(end) => DateTime.now() > end,
            None => match self.repeat_count {
                Some(count) => self.fire_count >= count,
                None => false
            }
        }
    }
    
    fn fire() -> Self {
        self.last_fired = Some(DateTime.now());
        self.fire_count += 1;
        self.calculate_next_fire();
        self
    }
    
    fn calculate_next_fire() {
        if self.is_expired() {
            self.next_fire = None;
            return;
        }
        
        match self.recurrence.clone() {
            Some(RecurrenceRule.Daily) => {
                let base = self.last_fired.unwrap_or(DateTime.now());
                self.next_fire = Some(base.add(Duration.from_days(1)));
            },
            Some(RecurrenceRule.Weekly(days)) => {
                let base = self.last_fired.unwrap_or(DateTime.now());
                self.next_fire = Some(self.next_weekday(base, days));
            },
            Some(RecurrenceRule.Monthly(days_of_month)) => {
                let base = self.last_fired.unwrap_or(DateTime.now());
                self.next_fire = Some(self.next_month_day(base, days_of_month));
            },
            _ => {}
        }
    }
    
    fn next_weekday(from: DateTime, days: [Weekday]) -> DateTime {
        var current = from.add(Duration.from_days(1));
        for _ in 0..7 {
            if days.contains(current.weekday()) {
                return current
            }
            current = current.add(Duration.from_days(1));
        }
        current
    }
    
    fn next_month_day(from: DateTime, days: [Int]) -> DateTime {
        var current = from.add(Duration.from_days(1));
        for _ in 0..31 {
            if days.contains(current.day()) {
                return current
            }
            current = current.add(Duration.from_days(1));
        }
        current
    }
}

// =============================================================================
// Geo Trigger
// =============================================================================

struct GeoTrigger {
    latitude: Float
    longitude: Float
    radius: Float
    trigger_on: GeoTriggerEvent
    notify_once: Bool
}

enum GeoTriggerEvent { Enter, Exit, Both }

impl GeoTrigger {
    fn new(lat: Float, lon: Float, radius: Float) -> Self {
        GeoTrigger {
            latitude: lat,
            longitude: lon,
            radius: radius,
            trigger_on: GeoTriggerEvent.Enter,
            notify_once: false
        }
    }
    
    fn on_enter() -> Self { self.trigger_on = GeoTriggerEvent.Enter; self }
    fn on_exit() -> Self { self.trigger_on = GeoTriggerEvent.Exit; self }
    fn on_both() -> Self { self.trigger_on = GeoTriggerEvent.Both; self }
    fn once() -> Self { self.notify_once = true; self }
}

// =============================================================================
// Calendar Trigger
// =============================================================================

struct CalendarTrigger {
    year: Option<Int>
    month: Option<Int>
    day: Option<Int>
    hour: Option<Int>
    minute: Option<Int>
    weekday: Option<Weekday>
    repeats: Bool
}

impl CalendarTrigger {
    fn new() -> Self {
        CalendarTrigger {
            year: None, month: None, day: None,
            hour: None, minute: None, weekday: None,
            repeats: false
        }
    }
    
    fn year(y: Int) -> Self { self.year = Some(y); self }
    fn month(m: Int) -> Self { self.month = Some(m); self }
    fn day(d: Int) -> Self { self.day = Some(d); self }
    fn hour(h: Int) -> Self { self.hour = Some(h); self }
    fn minute(m: Int) -> Self { self.minute = Some(m); self }
    fn weekday(w: Weekday) -> Self { self.weekday = Some(w); self }
    fn repeating() -> Self { self.repeats = true; self }
    
    fn daily_at(hour: Int, minute: Int) -> Self {
        CalendarTrigger.new().hour(hour).minute(minute).repeating()
    }
    
    fn weekly_on(weekday: Weekday, hour: Int, minute: Int) -> Self {
        CalendarTrigger.new().weekday(weekday).hour(hour).minute(minute).repeating()
    }
}

// =============================================================================
// Notification Scheduler Actor
// =============================================================================

actor NotificationScheduler {
    state scheduled: Map<String, ScheduledNotification>
    state pending_queue: [String]
    state settings: SchedulerSettings
    state running: Bool
    
    fn new() -> Self {
        NotificationScheduler {
            scheduled: Map.empty(),
            pending_queue: [],
            settings: SchedulerSettings.default(),
            running: false
        }
    }
    
    on schedule(sched: ScheduledNotification) -> String {
        let id = sched.id.clone();
        self.scheduled.set(id.clone(), sched);
        self.update_queue();
        id
    }
    
    on cancel(id: String) -> Bool {
        self.scheduled.remove(id.clone()).is_some()
    }
    
    on cancel_for_notification(notification_id: String) -> Int {
        let ids: [String] = self.scheduled.iter()
            .filter(|(_, s)| s.notification_id == notification_id)
            .map(|(id, _)| id.clone())
            .collect();
        
        for id in ids.iter() {
            self.scheduled.remove(id.clone());
        }
        ids.len()
    }
    
    fn get(id: String) -> Option<ScheduledNotification> {
        self.scheduled.get(id)
    }
    
    fn get_pending() -> [ScheduledNotification] {
        self.scheduled.values()
            .iter()
            .filter(|s| s.enabled && !s.is_expired())
            .collect()
    }
    
    fn get_due() -> [ScheduledNotification] {
        self.scheduled.values()
            .iter()
            .filter(|s| s.is_due())
            .collect()
    }
    
    on process_due() -> [String] {
        let due = self.get_due();
        let mut fired: [String] = [];
        
        for sched in due {
            if let Some(s) = self.scheduled.get_mut(sched.id.clone()) {
                s.fire();
                fired.push(s.notification_id.clone());
                
                if s.is_expired() {
                    self.scheduled.remove(s.id.clone());
                }
            }
        }
        
        self.update_queue();
        fired
    }
    
    fn update_queue() {
        self.pending_queue = self.scheduled.values()
            .iter()
            .filter(|s| s.enabled && s.next_fire.is_some())
            .collect::<Vec<_>>()
            .sort_by(|a, b| a.next_fire.cmp(b.next_fire))
            .iter()
            .map(|s| s.id.clone())
            .collect();
    }
    
    fn next_scheduled() -> Option<ScheduledNotification> {
        self.pending_queue.first()
            .and_then(|id| self.scheduled.get(id.clone()))
    }
    
    fn time_until_next() -> Option<Duration> {
        self.next_scheduled()
            .and_then(|s| s.next_fire)
            .map(|fire| fire.duration_since(DateTime.now()))
    }
    
    on start() { self.running = true }
    on stop() { self.running = false }
    fn is_running() -> Bool { self.running }
}

// =============================================================================
// Scheduler Settings
// =============================================================================

struct SchedulerSettings {
    max_scheduled: Int
    check_interval: Duration
    coalesce_window: Duration
    respect_quiet_hours: Bool
}

impl SchedulerSettings {
    fn default() -> Self {
        SchedulerSettings {
            max_scheduled: 64,
            check_interval: Duration.from_seconds(60),
            coalesce_window: Duration.from_seconds(5),
            respect_quiet_hours: true
        }
    }
}

// =============================================================================
// Schedule Builder
// =============================================================================

struct ScheduleBuilder {
    notification_id: String
    trigger: Option<TriggerType>
    recurrence: Option<RecurrenceRule>
    repeat_count: Option<Int>
    end_date: Option<DateTime>
    timezone: String
}

impl ScheduleBuilder {
    fn new(notification_id: String) -> Self {
        ScheduleBuilder {
            notification_id: notification_id,
            trigger: None,
            recurrence: None,
            repeat_count: None,
            end_date: None,
            timezone: "UTC"
        }
    }
    
    fn at(time: DateTime) -> Self {
        self.trigger = Some(TriggerType.Time(time)); self
    }
    
    fn after(duration: Duration) -> Self {
        self.trigger = Some(TriggerType.Interval(duration)); self
    }
    
    fn daily() -> Self { self.recurrence = Some(RecurrenceRule.Daily); self }
    fn weekly(days: [Weekday]) -> Self { self.recurrence = Some(RecurrenceRule.Weekly(days)); self }
    fn monthly(days: [Int]) -> Self { self.recurrence = Some(RecurrenceRule.Monthly(days)); self }
    fn repeat(count: Int) -> Self { self.repeat_count = Some(count); self }
    fn until(date: DateTime) -> Self { self.end_date = Some(date); self }
    fn timezone(tz: String) -> Self { self.timezone = tz; self }
    
    fn build() -> Result<ScheduledNotification, ScheduleError> {
        let trigger = self.trigger.ok_or(ScheduleError.NoTrigger)?;
        
        let mut sched = ScheduledNotification.new(self.notification_id.clone(), trigger);
        sched.timezone = self.timezone.clone();
        
        if let Some(rec) = self.recurrence.clone() {
            sched = sched.recurring(rec);
        }
        if let Some(count) = self.repeat_count {
            sched = sched.repeat(count);
        }
        if let Some(end) = self.end_date.clone() {
            sched = sched.until(end);
        }
        
        Ok(sched)
    }
}

// =============================================================================
// Errors
// =============================================================================

enum ScheduleError {
    NotFound(String),
    NoTrigger,
    InvalidTime,
    MaxScheduled,
    Expired,
    Unknown(String)
}

// =============================================================================
// Tests
// =============================================================================

test "schedule at time" {
    let future = DateTime.now().add(Duration.from_hours(1));
    let sched = ScheduledNotification.at_time("notif1", future);
    
    assert_eq(sched.notification_id, "notif1")?
    assert(!sched.is_due())?
}

test "schedule after interval" {
    let sched = ScheduledNotification.after_interval("notif1", Duration.from_minutes(30));
    assert(sched.next_fire.is_some())?
}

test "recurring daily" {
    let sched = ScheduledNotification.at_time("notif1", DateTime.now())
        .recurring(RecurrenceRule.Daily);
    
    assert_eq(sched.schedule_type, ScheduleType.Recurring)?
}

test "schedule builder" {
    let sched = ScheduleBuilder.new("notif1")
        .at(DateTime.now().add(Duration.from_hours(1)))
        .daily()
        .repeat(5)
        .build()
        .unwrap();
    
    assert_eq(sched.repeat_count, Some(5))?
}

test "calendar trigger daily" {
    let trigger = CalendarTrigger.daily_at(9, 0);
    assert_eq(trigger.hour, Some(9))?
    assert(trigger.repeats)?
}

test "geo trigger" {
    let trigger = GeoTrigger.new(37.7749, -122.4194, 100.0)
        .on_enter()
        .once();
    
    assert_eq(trigger.trigger_on, GeoTriggerEvent.Enter)?
    assert(trigger.notify_once)?
}
