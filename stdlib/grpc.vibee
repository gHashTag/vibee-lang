// =============================================================================
// Vibee OS â€” gRPC Module
// gRPC client and server implementation with Protocol Buffers
// =============================================================================

// -----------------------------------------------------------------------------
// gRPC Client
// -----------------------------------------------------------------------------

/// gRPC channel (connection to server)
actor Channel {
    state target: String
    state credentials: Credentials
    state options: ChannelOptions
    state connection: Option<HTTP2Connection>
    
    /// Create insecure channel
    fn insecure(target: String) -> Self {
        Channel {
            target: target,
            credentials: Credentials.Insecure,
            options: ChannelOptions.default()
        }
    }
    
    /// Create secure channel with TLS
    fn secure(target: String, creds: Credentials) -> Self {
        Channel {
            target: target,
            credentials: creds,
            options: ChannelOptions.default()
        }
    }
    
    /// Set channel options
    on options(opts: ChannelOptions) -> Self {
        self.options = opts
        self
    }
    
    /// Connect to server
    on connect() -> Result<(), GRPCError> {
        let (host, port) = self.parse_target()?
        
        let conn = match self.credentials {
            .Insecure => HTTP2Connection.connect(host, port)?
            .TLS(config) => HTTP2Connection.connect_tls(host, port, config)?
            .Token(_) => HTTP2Connection.connect_tls(host, port, TLSConfig.default())?
        }
        
        self.connection = Some(conn)
        Ok(())
    }
    
    fn parse_target() -> Result<(String, Int), GRPCError> {
        let parts = self.target.split(":")
        if parts.len() != 2 {
            return Err(GRPCError.InvalidTarget(self.target))
        }
        let port = Int.parse(parts[1]).map_err(|_| GRPCError.InvalidTarget(self.target))?
        Ok((parts[0], port))
    }
    
    /// Create stub for service
    fn stub<S: ServiceStub>() -> S {
        S.new(self)
    }
    
    /// Close channel
    on close() {
        if let conn = self.connection {
            conn.close()
        }
        self.connection = None
    }
}

/// Channel options
struct ChannelOptions {
    max_message_size: Int
    keepalive_time: Duration
    keepalive_timeout: Duration
    connect_timeout: Duration
    initial_reconnect_backoff: Duration
    max_reconnect_backoff: Duration
    
    fn default() -> Self {
        ChannelOptions {
            max_message_size: 4 * 1024 * 1024,  // 4MB
            keepalive_time: Duration.seconds(30),
            keepalive_timeout: Duration.seconds(10),
            connect_timeout: Duration.seconds(20),
            initial_reconnect_backoff: Duration.seconds(1),
            max_reconnect_backoff: Duration.seconds(120)
        }
    }
}

/// Credentials
enum Credentials {
    Insecure
    TLS(TLSConfig)
    Token(String)
    
    fn with_token(token: String) -> Self {
        .Token(token)
    }
}

/// Service stub trait
trait ServiceStub {
    fn new(channel: Channel) -> Self
}

// -----------------------------------------------------------------------------
// gRPC Call
// -----------------------------------------------------------------------------

/// Unary RPC call
actor UnaryCall<Req: Message, Res: Message> {
    state channel: Channel
    state method: String
    state metadata: Metadata
    state timeout: Option<Duration>
    state compression: Option<Compression>
    
    fn new(channel: Channel, method: String) -> Self {
        UnaryCall {
            channel: channel,
            method: method,
            metadata: Metadata.new()
        }
    }
    
    /// Add metadata
    on metadata(key: String, value: String) -> Self {
        self.metadata.set(key, value)
        self
    }
    
    /// Set timeout
    on timeout(d: Duration) -> Self {
        self.timeout = Some(d)
        self
    }
    
    /// Set compression
    on compression(c: Compression) -> Self {
        self.compression = Some(c)
        self
    }
    
    /// Execute call
    on call(request: Req) -> Result<Res, GRPCError> {
        guard let conn = self.channel.connection else {
            return Err(GRPCError.NotConnected)
        }
        
        // Serialize request
        let request_bytes = request.encode()?
        
        // Build headers
        var headers = [
            (":method", "POST"),
            (":path", self.method),
            (":scheme", "http"),
            ("content-type", "application/grpc"),
            ("te", "trailers")
        ]
        
        if let timeout = self.timeout {
            headers.append(("grpc-timeout", format_timeout(timeout)))
        }
        
        if let comp = self.compression {
            headers.append(("grpc-encoding", comp.name()))
        }
        
        for (key, value) in self.metadata.entries() {
            headers.append((key, value))
        }
        
        // Send request
        let stream = conn.new_stream()?
        stream.send_headers(headers)?
        stream.send_data(frame_message(request_bytes), end_stream: true)?
        
        // Receive response
        let response_headers = stream.recv_headers()?
        let response_data = stream.recv_data()?
        let trailers = stream.recv_trailers()?
        
        // Check status
        let status = trailers.get("grpc-status")
            .and_then(|s| Int.parse(s).ok())
            .unwrap_or(0)
        
        if status != 0 {
            let message = trailers.get("grpc-message").unwrap_or("")
            return Err(GRPCError.Status(Status.from_code(status), message))
        }
        
        // Deserialize response
        let response_bytes = unframe_message(response_data)?
        Res.decode(response_bytes)
    }
}

/// Server streaming RPC
actor ServerStreamingCall<Req: Message, Res: Message> {
    state channel: Channel
    state method: String
    state metadata: Metadata
    
    fn new(channel: Channel, method: String) -> Self {
        ServerStreamingCall {
            channel: channel,
            method: method,
            metadata: Metadata.new()
        }
    }
    
    on metadata(key: String, value: String) -> Self {
        self.metadata.set(key, value)
        self
    }
    
    /// Execute and return stream of responses
    on call(request: Req) -> Result<Stream<Res>, GRPCError> {
        guard let conn = self.channel.connection else {
            return Err(GRPCError.NotConnected)
        }
        
        let request_bytes = request.encode()?
        
        let headers = [
            (":method", "POST"),
            (":path", self.method),
            ("content-type", "application/grpc"),
            ("te", "trailers")
        ]
        
        let stream = conn.new_stream()?
        stream.send_headers(headers)?
        stream.send_data(frame_message(request_bytes), end_stream: true)?
        
        // Return stream that yields responses
        Ok(Stream.from_fn(|| {
            match stream.recv_data() {
                Ok(data) if !data.is_empty() => {
                    let bytes = unframe_message(data)?
                    Some(Res.decode(bytes)?)
                }
                _ => None
            }
        }))
    }
}

/// Client streaming RPC
actor ClientStreamingCall<Req: Message, Res: Message> {
    state channel: Channel
    state method: String
    state metadata: Metadata
    state stream: Option<HTTP2Stream>
    
    fn new(channel: Channel, method: String) -> Self {
        ClientStreamingCall {
            channel: channel,
            method: method,
            metadata: Metadata.new()
        }
    }
    
    /// Start streaming
    on start() -> Result<(), GRPCError> {
        guard let conn = self.channel.connection else {
            return Err(GRPCError.NotConnected)
        }
        
        let headers = [
            (":method", "POST"),
            (":path", self.method),
            ("content-type", "application/grpc"),
            ("te", "trailers")
        ]
        
        let stream = conn.new_stream()?
        stream.send_headers(headers)?
        self.stream = Some(stream)
        Ok(())
    }
    
    /// Send request message
    on send(request: Req) -> Result<(), GRPCError> {
        guard let stream = self.stream else {
            return Err(GRPCError.NotConnected)
        }
        
        let bytes = request.encode()?
        stream.send_data(frame_message(bytes), end_stream: false)?
        Ok(())
    }
    
    /// Close and get response
    on close_and_recv() -> Result<Res, GRPCError> {
        guard let stream = self.stream else {
            return Err(GRPCError.NotConnected)
        }
        
        stream.send_data([], end_stream: true)?
        
        let response_data = stream.recv_data()?
        let trailers = stream.recv_trailers()?
        
        let status = trailers.get("grpc-status")
            .and_then(|s| Int.parse(s).ok())
            .unwrap_or(0)
        
        if status != 0 {
            let message = trailers.get("grpc-message").unwrap_or("")
            return Err(GRPCError.Status(Status.from_code(status), message))
        }
        
        let bytes = unframe_message(response_data)?
        Res.decode(bytes)
    }
}

/// Bidirectional streaming RPC
actor BidiStreamingCall<Req: Message, Res: Message> {
    state channel: Channel
    state method: String
    state metadata: Metadata
    state stream: Option<HTTP2Stream>
    
    fn new(channel: Channel, method: String) -> Self {
        BidiStreamingCall {
            channel: channel,
            method: method,
            metadata: Metadata.new()
        }
    }
    
    /// Start streaming
    on start() -> Result<(), GRPCError> {
        guard let conn = self.channel.connection else {
            return Err(GRPCError.NotConnected)
        }
        
        let headers = [
            (":method", "POST"),
            (":path", self.method),
            ("content-type", "application/grpc"),
            ("te", "trailers")
        ]
        
        let stream = conn.new_stream()?
        stream.send_headers(headers)?
        self.stream = Some(stream)
        Ok(())
    }
    
    /// Send request
    on send(request: Req) -> Result<(), GRPCError> {
        guard let stream = self.stream else {
            return Err(GRPCError.NotConnected)
        }
        
        let bytes = request.encode()?
        stream.send_data(frame_message(bytes), end_stream: false)?
        Ok(())
    }
    
    /// Receive response
    on recv() -> Result<Option<Res>, GRPCError> {
        guard let stream = self.stream else {
            return Err(GRPCError.NotConnected)
        }
        
        match stream.recv_data() {
            Ok(data) if !data.is_empty() => {
                let bytes = unframe_message(data)?
                Ok(Some(Res.decode(bytes)?))
            }
            _ => Ok(None)
        }
    }
    
    /// Close send side
    on close_send() -> Result<(), GRPCError> {
        guard let stream = self.stream else {
            return Err(GRPCError.NotConnected)
        }
        stream.send_data([], end_stream: true)?
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// gRPC Server
// -----------------------------------------------------------------------------

/// gRPC server
actor Server {
    state address: String
    state port: Int
    state services: Map<String, ServiceHandler>
    state interceptors: [Interceptor]
    state credentials: Option<ServerCredentials>
    state running: Bool
    
    /// Create server
    fn new() -> Self {
        Server {
            address: "0.0.0.0",
            port: 50051,
            services: Map.empty(),
            interceptors: [],
            running: false
        }
    }
    
    /// Set address
    on address(addr: String) -> Self {
        self.address = addr
        self
    }
    
    /// Set port
    on port(p: Int) -> Self {
        self.port = p
        self
    }
    
    /// Add service
    on service<S: Service>(svc: S) -> Self {
        let handler = ServiceHandler.from_service(svc)
        self.services.set(S.service_name(), handler)
        self
    }
    
    /// Add interceptor
    on interceptor(i: Interceptor) -> Self {
        self.interceptors.append(i)
        self
    }
    
    /// Set TLS credentials
    on tls(creds: ServerCredentials) -> Self {
        self.credentials = Some(creds)
        self
    }
    
    /// Start server
    on serve() -> Result<(), GRPCError> {
        let listener = match self.credentials {
            Some(creds) => HTTP2Listener.listen_tls(self.address, self.port, creds)?
            None => HTTP2Listener.listen(self.address, self.port)?
        }
        
        self.running = true
        println("gRPC server listening on \(self.address):\(self.port)")
        
        while self.running {
            let conn = listener.accept()?
            async {
                self.handle_connection(conn)
            }
        }
        
        Ok(())
    }
    
    fn handle_connection(conn: HTTP2Connection) {
        while let Ok(stream) = conn.accept_stream() {
            async {
                self.handle_stream(stream)
            }
        }
    }
    
    fn handle_stream(stream: HTTP2Stream) {
        // Read headers
        let headers = stream.recv_headers().unwrap_or([])
        let path = headers.iter()
            .find(|(k, _)| k == ":path")
            .map(|(_, v)| v)
            .unwrap_or("")
        
        // Parse service and method
        let parts = path.trim_start("/").split("/")
        if parts.len() != 2 {
            self.send_error(stream, Status.Unimplemented, "Invalid path")
            return
        }
        
        let service_name = parts[0]
        let method_name = parts[1]
        
        // Find service handler
        let handler = match self.services.get(service_name) {
            Some(h) => h
            None => {
                self.send_error(stream, Status.Unimplemented, "Service not found")
                return
            }
        }
        
        // Build context
        let metadata = Metadata.from_headers(headers)
        let ctx = Context {
            metadata: metadata,
            deadline: None
        }
        
        // Apply interceptors
        for interceptor in self.interceptors {
            match interceptor.intercept(ctx, method_name) {
                Ok(new_ctx) => ctx = new_ctx
                Err(status) => {
                    self.send_error(stream, status.code, status.message)
                    return
                }
            }
        }
        
        // Handle request
        match handler.handle(method_name, ctx, stream) {
            Ok(()) => {}
            Err(e) => {
                self.send_error(stream, Status.Internal, e.message())
            }
        }
    }
    
    fn send_error(stream: HTTP2Stream, status: Status, message: String) {
        let trailers = [
            ("grpc-status", "\(status.code())"),
            ("grpc-message", message)
        ]
        stream.send_headers([
            (":status", "200"),
            ("content-type", "application/grpc")
        ])
        stream.send_trailers(trailers)
    }
    
    /// Stop server
    on stop() {
        self.running = false
    }
}

/// Service trait
trait Service {
    fn service_name() -> String
}

/// Service handler
struct ServiceHandler {
    methods: Map<String, MethodHandler>
    
    fn from_service<S: Service>(svc: S) -> Self {
        // Generated code populates this
        @native("grpc_service_handler", svc)
    }
    
    fn handle(method: String, ctx: Context, stream: HTTP2Stream) -> Result<(), GRPCError> {
        let handler = self.methods.get(method)
            .ok_or(GRPCError.Status(Status.Unimplemented, "Method not found"))?
        handler.handle(ctx, stream)
    }
}

type MethodHandler = (Context, HTTP2Stream) -> Result<(), GRPCError>

/// Server credentials
struct ServerCredentials {
    cert_chain: [Byte]
    private_key: [Byte]
    
    fn from_files(cert_path: String, key_path: String) -> Result<Self, IOError> {
        Ok(ServerCredentials {
            cert_chain: File.read_bytes(cert_path)?,
            private_key: File.read_bytes(key_path)?
        })
    }
}

// -----------------------------------------------------------------------------
// Metadata & Context
// -----------------------------------------------------------------------------

/// gRPC metadata (headers/trailers)
actor Metadata {
    state entries: Map<String, [String]>
    
    fn new() -> Self {
        Metadata { entries: Map.empty() }
    }
    
    fn from_headers(headers: [(String, String)]) -> Self {
        let meta = Metadata.new()
        for (key, value) in headers {
            if !key.starts_with(":") {
                meta.append(key, value)
            }
        }
        meta
    }
    
    /// Set metadata value (replaces existing)
    on set(key: String, value: String) {
        self.entries.set(key.to_lower(), [value])
    }
    
    /// Append metadata value
    on append(key: String, value: String) {
        self.entries.entry(key.to_lower()).or_default().append(value)
    }
    
    /// Get first value
    fn get(key: String) -> Option<String> {
        self.entries.get(key.to_lower()).and_then(|v| v.first())
    }
    
    /// Get all values
    fn get_all(key: String) -> [String] {
        self.entries.get(key.to_lower()).unwrap_or([])
    }
    
    /// Get all entries
    fn entries() -> [(String, String)] {
        self.entries.flat_map(|(k, vs)| vs.map(|v| (k, v)))
    }
}

/// Request context
struct Context {
    metadata: Metadata
    deadline: Option<Instant>
    
    fn with_deadline(deadline: Instant) -> Self {
        Context {
            metadata: Metadata.new(),
            deadline: Some(deadline)
        }
    }
    
    fn with_timeout(timeout: Duration) -> Self {
        Context {
            metadata: Metadata.new(),
            deadline: Some(Instant.now() + timeout)
        }
    }
}

// -----------------------------------------------------------------------------
// Interceptors
// -----------------------------------------------------------------------------

/// Server interceptor
trait Interceptor {
    fn intercept(ctx: Context, method: String) -> Result<Context, StatusError>
}

/// Logging interceptor
struct LoggingInterceptor {}

impl Interceptor for LoggingInterceptor {
    fn intercept(ctx: Context, method: String) -> Result<Context, StatusError> {
        println("[gRPC] \(method)")
        Ok(ctx)
    }
}

/// Auth interceptor
actor AuthInterceptor: Interceptor {
    state validator: (String) -> Result<(), String>
    
    fn new(validator: (String) -> Result<(), String>) -> Self {
        AuthInterceptor { validator: validator }
    }
    
    fn intercept(ctx: Context, method: String) -> Result<Context, StatusError> {
        let token = ctx.metadata.get("authorization")
            .ok_or(StatusError { code: Status.Unauthenticated, message: "Missing auth" })?
        
        self.validator(token).map_err(|msg| StatusError {
            code: Status.Unauthenticated,
            message: msg
        })?
        
        Ok(ctx)
    }
}

struct StatusError {
    code: Status
    message: String
}

// -----------------------------------------------------------------------------
// Status Codes
// -----------------------------------------------------------------------------

/// gRPC status code
enum Status {
    Ok
    Cancelled
    Unknown
    InvalidArgument
    DeadlineExceeded
    NotFound
    AlreadyExists
    PermissionDenied
    ResourceExhausted
    FailedPrecondition
    Aborted
    OutOfRange
    Unimplemented
    Internal
    Unavailable
    DataLoss
    Unauthenticated
    
    fn code() -> Int {
        match self {
            .Ok => 0
            .Cancelled => 1
            .Unknown => 2
            .InvalidArgument => 3
            .DeadlineExceeded => 4
            .NotFound => 5
            .AlreadyExists => 6
            .PermissionDenied => 7
            .ResourceExhausted => 8
            .FailedPrecondition => 9
            .Aborted => 10
            .OutOfRange => 11
            .Unimplemented => 12
            .Internal => 13
            .Unavailable => 14
            .DataLoss => 15
            .Unauthenticated => 16
        }
    }
    
    fn from_code(code: Int) -> Status {
        match code {
            0 => .Ok
            1 => .Cancelled
            2 => .Unknown
            3 => .InvalidArgument
            4 => .DeadlineExceeded
            5 => .NotFound
            6 => .AlreadyExists
            7 => .PermissionDenied
            8 => .ResourceExhausted
            9 => .FailedPrecondition
            10 => .Aborted
            11 => .OutOfRange
            12 => .Unimplemented
            13 => .Internal
            14 => .Unavailable
            15 => .DataLoss
            16 => .Unauthenticated
            _ => .Unknown
        }
    }
    
    fn message() -> String {
        match self {
            .Ok => "OK"
            .Cancelled => "Cancelled"
            .Unknown => "Unknown"
            .InvalidArgument => "Invalid argument"
            .DeadlineExceeded => "Deadline exceeded"
            .NotFound => "Not found"
            .AlreadyExists => "Already exists"
            .PermissionDenied => "Permission denied"
            .ResourceExhausted => "Resource exhausted"
            .FailedPrecondition => "Failed precondition"
            .Aborted => "Aborted"
            .OutOfRange => "Out of range"
            .Unimplemented => "Unimplemented"
            .Internal => "Internal error"
            .Unavailable => "Unavailable"
            .DataLoss => "Data loss"
            .Unauthenticated => "Unauthenticated"
        }
    }
}

// -----------------------------------------------------------------------------
// Message Framing
// -----------------------------------------------------------------------------

/// Frame message for gRPC wire format
fn frame_message(data: [Byte]) -> [Byte] {
    var frame = []
    frame.append(0)  // Compression flag
    
    // Length (4 bytes, big-endian)
    let len = data.len()
    frame.append((len >> 24) as Byte)
    frame.append((len >> 16) as Byte)
    frame.append((len >> 8) as Byte)
    frame.append(len as Byte)
    
    frame.extend(data)
    frame
}

/// Unframe message
fn unframe_message(frame: [Byte]) -> Result<[Byte], GRPCError> {
    if frame.len() < 5 {
        return Err(GRPCError.InvalidFrame)
    }
    
    let compressed = frame[0] != 0
    let len = (frame[1] as Int << 24) |
              (frame[2] as Int << 16) |
              (frame[3] as Int << 8) |
              (frame[4] as Int)
    
    if frame.len() < 5 + len {
        return Err(GRPCError.InvalidFrame)
    }
    
    let data = frame[5..(5 + len)]
    
    if compressed {
        // Decompress
        @native("grpc_decompress", data)
    } else {
        Ok(data)
    }
}

fn format_timeout(d: Duration) -> String {
    let ms = d.as_millis()
    if ms < 1000 {
        "\(ms)m"
    } else if ms < 60000 {
        "\(ms / 1000)S"
    } else {
        "\(ms / 60000)M"
    }
}

// -----------------------------------------------------------------------------
// Compression
// -----------------------------------------------------------------------------

enum Compression {
    None
    Gzip
    Deflate
    
    fn name() -> String {
        match self {
            .None => "identity"
            .Gzip => "gzip"
            .Deflate => "deflate"
        }
    }
}

// -----------------------------------------------------------------------------
// Protocol Buffers Message Trait
// -----------------------------------------------------------------------------

/// Protocol Buffers message trait
trait Message {
    fn encode() -> Result<[Byte], EncodeError>
    fn decode(bytes: [Byte]) -> Result<Self, DecodeError>
}

enum EncodeError {
    InvalidField(String)
    BufferOverflow
}

enum DecodeError {
    InvalidWireType
    UnexpectedEOF
    InvalidData(String)
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum GRPCError {
    NotConnected
    InvalidTarget(String)
    Status(Status, String)
    InvalidFrame
    ConnectionError(String)
    Timeout
    
    fn message() -> String {
        match self {
            .NotConnected => "Not connected"
            .InvalidTarget(t) => "Invalid target: \(t)"
            .Status(s, msg) => "\(s.message()): \(msg)"
            .InvalidFrame => "Invalid frame"
            .ConnectionError(msg) => "Connection error: \(msg)"
            .Timeout => "Request timed out"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "status codes" {
    assert(Status.Ok.code() == 0)
    assert(Status.from_code(3) == .InvalidArgument)
    assert(Status.NotFound.message() == "Not found")
}

test "message framing" {
    let data = [1, 2, 3, 4, 5]
    let framed = frame_message(data)
    
    assert(framed[0] == 0)  // Not compressed
    assert(framed[4] == 5)  // Length
    
    let unframed = unframe_message(framed)?
    assert(unframed == data)
}

test "metadata" {
    let meta = Metadata.new()
    meta.set("authorization", "Bearer token")
    meta.append("x-custom", "value1")
    meta.append("x-custom", "value2")
    
    assert(meta.get("authorization") == Some("Bearer token"))
    assert(meta.get_all("x-custom").len() == 2)
}
