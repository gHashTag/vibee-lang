// =============================================================================
// Vibee OS â€” Mutex Module
// Mutual exclusion primitives
// =============================================================================

/// Mutex - mutual exclusion lock
actor Mutex<T> {
    state value: T
    state locked: Bool
    state waiters: [fn()]
    
    fn new(value: T) -> Self { Mutex { value: value, locked: false, waiters: [] } }
    
    fn lock() -> MutexGuard<T> {
        while self.locked { @native("mutex_wait", self) }
        self.locked = true
        MutexGuard { mutex: self }
    }
    
    fn try_lock() -> Option<MutexGuard<T>> {
        if self.locked { None } else { self.locked = true; Some(MutexGuard { mutex: self }) }
    }
    
    fn unlock() {
        self.locked = false
        if !self.waiters.is_empty() { let w = self.waiters.remove(0); w() }
    }
    
    fn is_locked() -> Bool { self.locked }
    
    fn with<R>(f: fn(T) -> R) -> R {
        let guard = self.lock()
        let result = f(guard.value)
        drop(guard)
        result
    }
}

struct MutexGuard<T> { mutex: Mutex<T> }
impl<T> MutexGuard<T> {
    fn get() -> T { self.mutex.value }
    fn set(value: T) { self.mutex.value = value }
}
impl<T> Drop for MutexGuard<T> { fn drop() { self.mutex.unlock() } }
impl<T> Deref for MutexGuard<T> { type Target = T; fn deref() -> T { self.mutex.value } }
impl<T> DerefMut for MutexGuard<T> { fn deref_mut() -> T { self.mutex.value } }

/// RwLock - read-write lock
actor RwLock<T> {
    state value: T
    state readers: Int
    state writer: Bool
    
    fn new(value: T) -> Self { RwLock { value: value, readers: 0, writer: false } }
    
    fn read() -> ReadGuard<T> {
        while self.writer { @native("yield") }
        self.readers += 1
        ReadGuard { lock: self }
    }
    
    fn write() -> WriteGuard<T> {
        while self.writer || self.readers > 0 { @native("yield") }
        self.writer = true
        WriteGuard { lock: self }
    }
    
    fn try_read() -> Option<ReadGuard<T>> {
        if self.writer { None } else { self.readers += 1; Some(ReadGuard { lock: self }) }
    }
    
    fn try_write() -> Option<WriteGuard<T>> {
        if self.writer || self.readers > 0 { None } else { self.writer = true; Some(WriteGuard { lock: self }) }
    }
}

struct ReadGuard<T> { lock: RwLock<T> }
impl<T> Drop for ReadGuard<T> { fn drop() { self.lock.readers -= 1 } }
impl<T> Deref for ReadGuard<T> { type Target = T; fn deref() -> T { self.lock.value } }

struct WriteGuard<T> { lock: RwLock<T> }
impl<T> Drop for WriteGuard<T> { fn drop() { self.lock.writer = false } }
impl<T> Deref for WriteGuard<T> { type Target = T; fn deref() -> T { self.lock.value } }
impl<T> DerefMut for WriteGuard<T> { fn deref_mut() -> T { self.lock.value } }

/// Once - run initialization once
actor Once {
    state done: Bool
    state running: Bool
    
    fn new() -> Self { Once { done: false, running: false } }
    
    fn call_once(f: fn()) {
        if self.done { return }
        while self.running { @native("yield") }
        if self.done { return }
        self.running = true
        f()
        self.done = true
        self.running = false
    }
    
    fn is_completed() -> Bool { self.done }
}

/// Lazy - lazy initialization
struct Lazy<T> {
    once: Once
    value: Option<T>
    init: fn() -> T
    
    fn new(init: fn() -> T) -> Self { Lazy { once: Once.new(), value: None, init: init } }
    
    fn get() -> T {
        self.once.call_once(|| { self.value = Some((self.init)()) })
        self.value.unwrap()
    }
    
    fn is_initialized() -> Bool { self.once.is_completed() }
}

/// Condition variable
actor Condvar {
    state waiters: [fn()]
    
    fn new() -> Self { Condvar { waiters: [] } }
    fn wait<T>(guard: MutexGuard<T>) { guard.mutex.unlock(); @native("condvar_wait", self); guard.mutex.lock() }
    fn notify_one() { if !self.waiters.is_empty() { let w = self.waiters.remove(0); w() } }
    fn notify_all() { while !self.waiters.is_empty() { let w = self.waiters.remove(0); w() } }
}

// Tests
test "mutex lock" {
    let m = Mutex.new(0)
    { let g = m.lock(); *g = 42 }
    assert_eq(m.lock().get(), 42)?
}

test "rwlock" {
    let rw = RwLock.new(0)
    { let w = rw.write(); *w = 42 }
    { let r = rw.read(); assert_eq(*r, 42)? }
}

test "once" {
    let once = Once.new()
    var count = 0
    once.call_once(|| count += 1)
    once.call_once(|| count += 1)
    assert_eq(count, 1)?
}

test "lazy" {
    var initialized = false
    let lazy = Lazy.new(|| { initialized = true; 42 })
    assert(!initialized)?
    assert_eq(lazy.get(), 42)?
    assert(initialized)?
}
