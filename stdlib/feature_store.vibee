// =============================================================================
// Vibee OS â€” Feature Store Module
// Centralized feature management for ML pipelines
// =============================================================================

use datetime::{DateTime, Duration}
use uuid::{UUID}
use result::{Result, Ok, Err}
use tensor::{Tensor}

// -----------------------------------------------------------------------------
// Feature Types
// -----------------------------------------------------------------------------

/// Data type for features
enum FeatureType {
    Int64
    Float64
    String
    Bool
    IntArray
    FloatArray
    StringArray
    Embedding(Int)
    
    fn to_string() -> String {
        match self {
            Int64 => "int64",
            Float64 => "float64",
            String => "string",
            Bool => "bool",
            IntArray => "int64[]",
            FloatArray => "float64[]",
            StringArray => "string[]",
            Embedding(dim) => "embedding[\(dim)]"
        }
    }
}

/// Feature value
enum FeatureValue {
    Int(Int)
    Float(Float)
    Str(String)
    Boolean(Bool)
    IntList([Int])
    FloatList([Float])
    StrList([String])
    Vector(Tensor)
    Null
    
    fn as_float() -> Option<Float> {
        match self {
            Float(v) => Some(v),
            Int(v) => Some(v as Float),
            _ => None
        }
    }
    
    fn as_tensor() -> Option<Tensor> {
        match self {
            Vector(t) => Some(t),
            FloatList(v) => Some(Tensor.from_vec(v)),
            _ => None
        }
    }
}

// -----------------------------------------------------------------------------
// Feature Definition
// -----------------------------------------------------------------------------

/// Feature schema definition
struct Feature {
    name: String
    dtype: FeatureType
    description: String
    tags: [String]
    owner: String
    created_at: DateTime
    
    fn new(name: String, dtype: FeatureType) -> Self {
        Feature {
            name: name,
            dtype: dtype,
            description: "",
            tags: [],
            owner: "",
            created_at: DateTime.now()
        }
    }
    
    fn with_description(description: String) -> Self {
        self.description = description
        self
    }
    
    fn with_owner(owner: String) -> Self {
        self.owner = owner
        self
    }
    
    fn with_tags(tags: [String]) -> Self {
        self.tags = tags
        self
    }
}

// -----------------------------------------------------------------------------
// Entity
// -----------------------------------------------------------------------------

/// Entity definition (e.g., user, product)
struct Entity {
    name: String
    join_keys: [String]
    description: String
    
    fn new(name: String, join_keys: [String]) -> Self {
        Entity { name: name, join_keys: join_keys, description: "" }
    }
}

// -----------------------------------------------------------------------------
// Feature View
// -----------------------------------------------------------------------------

/// Feature view grouping related features
struct FeatureView {
    name: String
    entities: [Entity]
    features: [Feature]
    ttl: Option<Duration>
    online: Bool
    offline: Bool
    source: String
    created_at: DateTime
    
    fn new(name: String) -> Self {
        FeatureView {
            name: name,
            entities: [],
            features: [],
            ttl: None,
            online: true,
            offline: true,
            source: "",
            created_at: DateTime.now()
        }
    }
    
    fn with_entity(entity: Entity) -> Self {
        self.entities.push(entity)
        self
    }
    
    fn with_feature(feature: Feature) -> Self {
        self.features.push(feature)
        self
    }
    
    fn with_ttl(ttl: Duration) -> Self {
        self.ttl = Some(ttl)
        self
    }
    
    fn with_source(source: String) -> Self {
        self.source = source
        self
    }
    
    fn feature_names() -> [String] {
        self.features.iter().map(|f| f.name.clone()).collect()
    }
}

// -----------------------------------------------------------------------------
// Feature Store Backend
// -----------------------------------------------------------------------------

trait FeatureStoreBackend {
    fn write_features(view: String, entity_key: Map<String, String>, features: Map<String, FeatureValue>, ts: DateTime) -> Result<(), String>
    fn read_features(view: String, entity_key: Map<String, String>, feature_names: [String]) -> Result<Map<String, FeatureValue>, String>
    fn read_batch(view: String, entity_keys: [Map<String, String>], feature_names: [String]) -> Result<[Map<String, FeatureValue>], String>
}

/// In-memory feature store
struct InMemoryFeatureStore {
    data: Map<String, Map<String, FeatureValue>>
    
    fn new() -> Self {
        InMemoryFeatureStore { data: Map.empty() }
    }
    
    fn make_key(view: String, entity_key: Map<String, String>) -> String {
        let parts: [String] = entity_key.iter()
            .map(|(k, v)| "\(k)=\(v)")
            .collect()
        "\(view):\(parts.join(","))"
    }
}

impl FeatureStoreBackend for InMemoryFeatureStore {
    fn write_features(view: String, entity_key: Map<String, String>, features: Map<String, FeatureValue>, ts: DateTime) -> Result<(), String> {
        let key = self.make_key(view, entity_key)
        self.data.insert(key, features)
        Ok(())
    }
    
    fn read_features(view: String, entity_key: Map<String, String>, feature_names: [String]) -> Result<Map<String, FeatureValue>, String> {
        let key = self.make_key(view, entity_key)
        let all = self.data.get(key).cloned().unwrap_or(Map.empty())
        var result = Map.empty()
        for name in feature_names {
            result.insert(name.clone(), all.get(name).cloned().unwrap_or(FeatureValue.Null))
        }
        Ok(result)
    }
    
    fn read_batch(view: String, entity_keys: [Map<String, String>], feature_names: [String]) -> Result<[Map<String, FeatureValue>], String> {
        var results = []
        for ek in entity_keys {
            results.push(self.read_features(view, ek, feature_names.clone())?)
        }
        Ok(results)
    }
}

// -----------------------------------------------------------------------------
// Feature Store Actor
// -----------------------------------------------------------------------------

actor FeatureStore {
    backend: Box<dyn FeatureStoreBackend>
    views: Map<String, FeatureView>
    
    fn new(backend: Box<dyn FeatureStoreBackend>) -> Self {
        FeatureStore { backend: backend, views: Map.empty() }
    }
    
    fn default() -> Self {
        FeatureStore.new(Box.new(InMemoryFeatureStore.new()))
    }
    
    fn register_view(view: FeatureView) {
        self.views.insert(view.name.clone(), view)
    }
    
    fn get_view(name: String) -> Option<FeatureView> {
        self.views.get(name).cloned()
    }
    
    fn ingest(view: String, entity_key: Map<String, String>, features: Map<String, FeatureValue>) -> Result<(), String> {
        self.backend.write_features(view, entity_key, features, DateTime.now())
    }
    
    fn get_online_features(view: String, entity_key: Map<String, String>, features: [String]) -> Result<Map<String, FeatureValue>, String> {
        self.backend.read_features(view, entity_key, features)
    }
    
    fn get_batch_features(view: String, entity_keys: [Map<String, String>], features: [String]) -> Result<[Map<String, FeatureValue>], String> {
        self.backend.read_batch(view, entity_keys, features)
    }
    
    fn get_training_data(view: String, entity_keys: [Map<String, String>], features: [String]) -> Result<Tensor, String> {
        let batch = self.get_batch_features(view, entity_keys, features)?
        var data = []
        for row in batch {
            for name in features {
                if let Some(val) = row.get(name) {
                    if let Some(f) = val.as_float() {
                        data.push(f)
                    }
                }
            }
        }
        Ok(Tensor.from_vec(data).reshape([entity_keys.len(), features.len()]))
    }
}

// -----------------------------------------------------------------------------
// Global Instance
// -----------------------------------------------------------------------------

static STORE: FeatureStore = FeatureStore.default()

fn register_view(view: FeatureView) { STORE.register_view(view) }
fn ingest(view: String, entity_key: Map<String, String>, features: Map<String, FeatureValue>) -> Result<(), String> {
    STORE.ingest(view, entity_key, features)
}
fn get_features(view: String, entity_key: Map<String, String>, features: [String]) -> Result<Map<String, FeatureValue>, String> {
    STORE.get_online_features(view, entity_key, features)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "feature_view" {
    let view = FeatureView.new("user_features")
        .with_entity(Entity.new("user", ["user_id"]))
        .with_feature(Feature.new("age", FeatureType.Int64))
    assert_eq(view.features.len(), 1)?
}

test "feature_ingest_and_read" {
    var store = FeatureStore.default()
    let entity = Map.from([("user_id", "123")])
    let features = Map.from([("age", FeatureValue.Int(25))])
    
    store.ingest("users", entity.clone(), features)?
    let result = store.get_online_features("users", entity, ["age"])?
    
    assert_eq(result.get("age"), Some(FeatureValue.Int(25)))?
}
