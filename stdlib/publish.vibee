// =============================================================================
// Vibee OS â€” Publish Module
// Package publishing and distribution
// =============================================================================

// -----------------------------------------------------------------------------
// Publisher
// -----------------------------------------------------------------------------

/// Package publisher actor
actor Publisher {
    state registry_url: String
    state token: Option<String>
    state dry_run: Bool
    state allow_dirty: Bool
    
    init() {
        self.registry_url = "https://registry.vibee.dev"
        self.token = None
        self.dry_run = false
        self.allow_dirty = false
    }
    
    /// Set registry URL
    on registry(url: String) -> Self {
        self.registry_url = url
        self
    }
    
    /// Set authentication token
    on authenticate(token: String) -> Self {
        self.token = Some(token)
        self
    }
    
    /// Enable dry run mode
    on dry_run(enabled: Bool) -> Self {
        self.dry_run = enabled
        self
    }
    
    /// Allow publishing with uncommitted changes
    on allow_dirty(enabled: Bool) -> Self {
        self.allow_dirty = enabled
        self
    }
    
    /// Publish package
    on publish(path: String = ".") -> Result<PublishResult, PublishError> {
        // Load manifest
        let manifest = PackageManifest.load(format!("{}/vibee.toml", path))?
        
        // Validate package
        self.validate(path, manifest)?
        
        // Check git status
        if !self.allow_dirty && !self.dry_run {
            self.check_git_clean(path)?
        }
        
        // Build package archive
        let archive = self.build_archive(path, manifest)?
        
        // Verify archive
        self.verify_archive(archive)?
        
        if self.dry_run {
            println!("[DRY RUN] Would publish {} v{}", manifest.package.name, manifest.package.version)
            return Ok(PublishResult {
                name: manifest.package.name,
                version: manifest.package.version,
                url: "",
                dry_run: true
            })
        }
        
        // Upload to registry
        let url = self.upload(archive, manifest)?
        
        // Cleanup
        fs::remove(archive.path)?
        
        Ok(PublishResult {
            name: manifest.package.name,
            version: manifest.package.version,
            url: url,
            dry_run: false
        })
    }
    
    /// Validate package before publishing
    fn validate(path: String, manifest: PackageManifest) -> Result<(), PublishError> {
        var errors = []
        
        // Check required fields
        if manifest.package.name.is_empty() {
            errors.append("Package name is required")
        }
        
        if manifest.package.version.is_empty() {
            errors.append("Package version is required")
        }
        
        // Validate package name
        if !Self.is_valid_name(manifest.package.name) {
            errors.append("Invalid package name")
        }
        
        // Check for README
        let readme_exists = manifest.package.readme
            .map(|r| fs::exists(format!("{}/{}", path, r)))
            .unwrap_or(false)
        
        if !readme_exists && !fs::exists(format!("{}/README.md", path)) {
            errors.append("README file is recommended")
        }
        
        // Check license
        if manifest.package.license.is_empty() {
            errors.append("License is required")
        }
        
        // Check for source files
        let has_sources = fs::exists(format!("{}/src", path)) || 
                          fs::exists(format!("{}/lib", path))
        if !has_sources {
            errors.append("No source files found")
        }
        
        // Check version format
        if !Self.is_valid_version(manifest.package.version) {
            errors.append("Invalid version format (use semver)")
        }
        
        if !errors.is_empty() {
            return Err(PublishError.ValidationFailed(errors))
        }
        
        Ok(())
    }
    
    /// Check if git working directory is clean
    fn check_git_clean(path: String) -> Result<(), PublishError> {
        let result = shell::exec_in(path, "git", ["status", "--porcelain"])?
        
        if !result.stdout.trim().is_empty() {
            return Err(PublishError.DirtyWorkingDirectory)
        }
        
        Ok(())
    }
    
    /// Build package archive
    fn build_archive(path: String, manifest: PackageManifest) -> Result<PackageArchive, PublishError> {
        let archive_name = format!("{}-{}.tar.gz", manifest.package.name, manifest.package.version)
        let archive_path = format!("{}/target/{}", path, archive_name)
        
        fs::create_dir_all(format!("{}/target", path))?
        
        // Collect files to include
        let files = self.collect_files(path, manifest)?
        
        // Create archive
        let mut builder = tar::Builder.new()
        
        for file in files {
            let rel_path = path::strip_prefix(file, path).unwrap_or(file)
            builder.add_file(file, rel_path)?
        }
        
        // Add manifest
        builder.add_file(format!("{}/vibee.toml", path), "vibee.toml")?
        
        // Compress
        builder.finish_gzip(archive_path)?
        
        // Calculate checksum
        let checksum = crypto::sha256_file(archive_path)?
        let size = fs::metadata(archive_path)?.size
        
        Ok(PackageArchive {
            path: archive_path,
            name: archive_name,
            checksum: checksum,
            size: size,
            files: files.len()
        })
    }
    
    /// Collect files to include in archive
    fn collect_files(path: String, manifest: PackageManifest) -> Result<[String], PublishError> {
        var files = []
        
        // Include patterns
        let include = [
            "src/**/*.vibee",
            "lib/**/*.vibee",
            "README.md",
            "README",
            "LICENSE",
            "LICENSE-*",
            "CHANGELOG.md",
            "CHANGELOG"
        ]
        
        // Exclude patterns
        let exclude = [
            "target/**",
            ".git/**",
            ".gitignore",
            ".vibee-cache/**",
            "**/*.log",
            "**/test/**",
            "**/tests/**",
            "**/benches/**"
        ]
        
        for entry in fs::walk(path) {
            let entry = entry?
            if entry.is_file() {
                let rel = path::strip_prefix(entry.path, path).unwrap_or(entry.path)
                
                // Check exclude patterns
                let excluded = exclude.iter().any(|p| glob::matches(p, rel))
                if excluded { continue }
                
                // Check include patterns
                let included = include.iter().any(|p| glob::matches(p, rel))
                if included {
                    files.append(entry.path)
                }
            }
        }
        
        Ok(files)
    }
    
    /// Verify archive integrity
    fn verify_archive(archive: PackageArchive) -> Result<(), PublishError> {
        // Check size limits
        let max_size = 10 * 1024 * 1024  // 10 MB
        if archive.size > max_size {
            return Err(PublishError.ArchiveTooLarge(archive.size, max_size))
        }
        
        // Verify checksum
        let actual = crypto::sha256_file(archive.path)?
        if actual != archive.checksum {
            return Err(PublishError.ChecksumMismatch)
        }
        
        Ok(())
    }
    
    /// Upload archive to registry
    fn upload(archive: PackageArchive, manifest: PackageManifest) -> Result<String, PublishError> {
        let token = self.token.as_ref().ok_or(PublishError.NotAuthenticated)?
        
        let url = format!("{}/api/v1/crates/new", self.registry_url)
        
        // Prepare metadata
        let metadata = json::object({
            "name": manifest.package.name,
            "vers": manifest.package.version,
            "deps": manifest.dependencies.iter().map(|(name, spec)| {
                json::object({
                    "name": name,
                    "version_req": match spec {
                        DependencySpec.Version(v) => v
                        _ => "*"
                    },
                    "optional": false
                })
            }).collect(),
            "features": manifest.features,
            "authors": manifest.package.authors,
            "description": manifest.package.description,
            "documentation": manifest.package.documentation,
            "homepage": manifest.package.homepage,
            "readme": manifest.package.readme,
            "keywords": manifest.package.keywords,
            "categories": manifest.package.categories,
            "license": manifest.package.license,
            "repository": manifest.package.repository
        })
        
        // Upload
        let response = http::post_multipart(url, [
            ("metadata", metadata.to_string()),
            ("crate", fs::read_bytes(archive.path)?)
        ], [
            ("Authorization", format!("Bearer {}", token))
        ])?
        
        if response.status != 200 {
            let error = json::parse(response.body)?.get("error")?.as_str().unwrap_or("Unknown error")
            return Err(PublishError.UploadFailed(error))
        }
        
        let result = json::parse(response.body)?
        Ok(result.get("url")?.as_str().unwrap_or(""))
    }
    
    fn is_valid_name(name: String) -> Bool {
        if name.is_empty() || name.len() > 64 { return false }
        
        // Must start with letter
        let first = name.chars().next().unwrap()
        if !first.is_alphabetic() { return false }
        
        // Only alphanumeric, dash, underscore
        name.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_')
    }
    
    fn is_valid_version(version: String) -> Bool {
        semver::Version.parse(version).is_ok()
    }
}

// -----------------------------------------------------------------------------
// Yank / Unyank
// -----------------------------------------------------------------------------

/// Yank a published version
fn yank(name: String, version: String, token: String) -> Result<(), PublishError> {
    let url = format!("https://registry.vibee.dev/api/v1/crates/{}/{}/yank", name, version)
    
    let response = http::delete(url, [
        ("Authorization", format!("Bearer {}", token))
    ])?
    
    if response.status != 200 {
        return Err(PublishError.YankFailed(response.body))
    }
    
    Ok(())
}

/// Unyank a yanked version
fn unyank(name: String, version: String, token: String) -> Result<(), PublishError> {
    let url = format!("https://registry.vibee.dev/api/v1/crates/{}/{}/unyank", name, version)
    
    let response = http::put(url, "", [
        ("Authorization", format!("Bearer {}", token))
    ])?
    
    if response.status != 200 {
        return Err(PublishError.UnyankFailed(response.body))
    }
    
    Ok(())
}

// -----------------------------------------------------------------------------
// Ownership Management
// -----------------------------------------------------------------------------

/// Package ownership manager
actor OwnershipManager {
    state registry_url: String
    state token: String
    
    init(token: String) {
        self.registry_url = "https://registry.vibee.dev"
        self.token = token
    }
    
    /// Add owner to package
    on add_owner(package: String, user: String) -> Result<(), PublishError> {
        let url = format!("{}/api/v1/crates/{}/owners", self.registry_url, package)
        
        let body = json::object({ "users": [user] })
        
        let response = http::put(url, body.to_string(), [
            ("Authorization", format!("Bearer {}", self.token)),
            ("Content-Type", "application/json")
        ])?
        
        if response.status != 200 {
            return Err(PublishError.OwnershipError(response.body))
        }
        
        Ok(())
    }
    
    /// Remove owner from package
    on remove_owner(package: String, user: String) -> Result<(), PublishError> {
        let url = format!("{}/api/v1/crates/{}/owners", self.registry_url, package)
        
        let body = json::object({ "users": [user] })
        
        let response = http::delete_with_body(url, body.to_string(), [
            ("Authorization", format!("Bearer {}", self.token)),
            ("Content-Type", "application/json")
        ])?
        
        if response.status != 200 {
            return Err(PublishError.OwnershipError(response.body))
        }
        
        Ok(())
    }
    
    /// List owners of package
    on list_owners(package: String) -> Result<[Owner], PublishError> {
        let url = format!("{}/api/v1/crates/{}/owners", self.registry_url, package)
        
        let response = http::get(url, [
            ("Authorization", format!("Bearer {}", self.token))
        ])?
        
        if response.status != 200 {
            return Err(PublishError.OwnershipError(response.body))
        }
        
        let json = json::parse(response.body)?
        let owners = json.get("users")?.as_array()?
            .filter_map(|u| {
                Some(Owner {
                    id: u.get("id")?.as_int()? as Int,
                    login: u.get("login")?.as_str()?,
                    name: u.get("name")?.as_str()
                })
            })
            .collect()
        
        Ok(owners)
    }
}

struct Owner {
    id: Int
    login: String
    name: Option<String>
}

// -----------------------------------------------------------------------------
// Token Management
// -----------------------------------------------------------------------------

/// API token manager
actor TokenManager {
    state registry_url: String
    state config_path: String
    
    init() {
        self.registry_url = "https://registry.vibee.dev"
        self.config_path = "~/.vibee/credentials.toml"
    }
    
    /// Login and save token
    on login(token: String) -> Result<(), PublishError> {
        let config_dir = path::parent(self.config_path)
        fs::create_dir_all(config_dir)?
        
        let content = format!("[registry]\ntoken = \"{}\"\n", token)
        fs::write_string(self.config_path, content)?
        
        // Set restrictive permissions
        fs::set_permissions(self.config_path, 0o600)?
        
        Ok(())
    }
    
    /// Logout and remove token
    on logout() -> Result<(), PublishError> {
        if fs::exists(self.config_path) {
            fs::remove(self.config_path)?
        }
        Ok(())
    }
    
    /// Get saved token
    on get_token() -> Result<String, PublishError> {
        if !fs::exists(self.config_path) {
            return Err(PublishError.NotAuthenticated)
        }
        
        let content = fs::read_string(self.config_path)?
        let toml = toml::parse(content)?
        
        toml.path("registry.token")?.as_str()
            .ok_or(PublishError.NotAuthenticated)
    }
    
    /// Create new API token
    on create_token(name: String, scopes: [TokenScope]) -> Result<String, PublishError> {
        let token = self.get_token()?
        let url = format!("{}/api/v1/me/tokens", self.registry_url)
        
        let body = json::object({
            "name": name,
            "scopes": scopes.map(|s| s.to_string())
        })
        
        let response = http::post(url, body.to_string(), [
            ("Authorization", format!("Bearer {}", token)),
            ("Content-Type", "application/json")
        ])?
        
        if response.status != 200 {
            return Err(PublishError.TokenError(response.body))
        }
        
        let result = json::parse(response.body)?
        Ok(result.get("token")?.as_str()?)
    }
    
    /// Revoke API token
    on revoke_token(token_id: Int) -> Result<(), PublishError> {
        let token = self.get_token()?
        let url = format!("{}/api/v1/me/tokens/{}", self.registry_url, token_id)
        
        let response = http::delete(url, [
            ("Authorization", format!("Bearer {}", token))
        ])?
        
        if response.status != 200 {
            return Err(PublishError.TokenError(response.body))
        }
        
        Ok(())
    }
    
    /// List API tokens
    on list_tokens() -> Result<[TokenInfo], PublishError> {
        let token = self.get_token()?
        let url = format!("{}/api/v1/me/tokens", self.registry_url)
        
        let response = http::get(url, [
            ("Authorization", format!("Bearer {}", token))
        ])?
        
        if response.status != 200 {
            return Err(PublishError.TokenError(response.body))
        }
        
        let json = json::parse(response.body)?
        let tokens = json.get("tokens")?.as_array()?
            .filter_map(|t| {
                Some(TokenInfo {
                    id: t.get("id")?.as_int()? as Int,
                    name: t.get("name")?.as_str()?,
                    scopes: t.get("scopes")?.as_array()?.filter_map(|s| s.as_str()).collect(),
                    created_at: t.get("created_at")?.as_str()?,
                    last_used: t.get("last_used_at")?.as_str()
                })
            })
            .collect()
        
        Ok(tokens)
    }
}

enum TokenScope {
    Publish
    Yank
    ChangeOwners
    
    fn to_string() -> String {
        match self {
            Publish => "publish"
            Yank => "yank"
            ChangeOwners => "change-owners"
        }
    }
}

struct TokenInfo {
    id: Int
    name: String
    scopes: [String]
    created_at: String
    last_used: Option<String>
}

// -----------------------------------------------------------------------------
// Supporting Types
// -----------------------------------------------------------------------------

struct PackageArchive {
    path: String
    name: String
    checksum: String
    size: Int64
    files: Int
}

struct PublishResult {
    name: String
    version: String
    url: String
    dry_run: Bool
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum PublishError {
    ValidationFailed([String])
    DirtyWorkingDirectory
    NotAuthenticated
    ArchiveTooLarge(Int64, Int64)
    ChecksumMismatch
    UploadFailed(String)
    YankFailed(String)
    UnyankFailed(String)
    OwnershipError(String)
    TokenError(String)
    NetworkError(String)
    IOError(String)
    
    fn message() -> String {
        match self {
            .ValidationFailed(errs) => format!("Validation failed: {}", errs.join(", "))
            .DirtyWorkingDirectory => "Working directory has uncommitted changes. Use --allow-dirty to override."
            .NotAuthenticated => "Not authenticated. Run 'vibee login' first."
            .ArchiveTooLarge(size, max) => format!("Archive too large: {} bytes (max: {} bytes)", size, max)
            .ChecksumMismatch => "Archive checksum mismatch"
            .UploadFailed(m) => format!("Upload failed: {}", m)
            .YankFailed(m) => format!("Yank failed: {}", m)
            .UnyankFailed(m) => format!("Unyank failed: {}", m)
            .OwnershipError(m) => format!("Ownership error: {}", m)
            .TokenError(m) => format!("Token error: {}", m)
            .NetworkError(m) => format!("Network error: {}", m)
            .IOError(m) => format!("I/O error: {}", m)
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Publish current package
fn publish() -> Result<PublishResult, PublishError> {
    let token_mgr = TokenManager.new()
    let token = token_mgr.get_token()?
    
    let publisher = Publisher.new()
        .authenticate(token)
    
    publisher.publish(".")
}

/// Publish with dry run
fn publish_dry_run() -> Result<PublishResult, PublishError> {
    let publisher = Publisher.new()
        .dry_run(true)
    
    publisher.publish(".")
}

/// Login to registry
fn login(token: String) -> Result<(), PublishError> {
    let token_mgr = TokenManager.new()
    token_mgr.login(token)
}

/// Logout from registry
fn logout() -> Result<(), PublishError> {
    let token_mgr = TokenManager.new()
    token_mgr.logout()
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "valid package name" {
    assert(Publisher.is_valid_name("my-package"))?
    assert(Publisher.is_valid_name("my_package"))?
    assert(Publisher.is_valid_name("mypackage123"))?
    assert(!Publisher.is_valid_name(""))?
    assert(!Publisher.is_valid_name("123package"))?
    assert(!Publisher.is_valid_name("my package"))?
}

test "valid version" {
    assert(Publisher.is_valid_version("1.0.0"))?
    assert(Publisher.is_valid_version("0.1.0-alpha"))?
    assert(Publisher.is_valid_version("2.0.0+build.123"))?
    assert(!Publisher.is_valid_version("invalid"))?
}

test "token scope to string" {
    assert_eq(TokenScope.Publish.to_string(), "publish")?
    assert_eq(TokenScope.Yank.to_string(), "yank")?
}

test "publish error messages" {
    let err = PublishError.NotAuthenticated
    assert(err.message().contains("Not authenticated"))?
}
