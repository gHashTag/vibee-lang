// =============================================================================
// Vibee OS â€” Excel Module
// Reading, writing, and manipulating Excel files (.xlsx, .xls)
// =============================================================================

use fs::{File, IoError}
use datetime::DateTime

// =============================================================================
// Excel Workbook
// =============================================================================

/// Excel workbook
struct Workbook {
    handle: @native("ExcelWorkbookHandle")
    path: Option<String>
    sheets: [Sheet]
}

impl Workbook {
    /// Create new empty workbook
    fn new() -> Self {
        let handle = @native("excel_workbook_new")
        Workbook { handle: handle, path: None, sheets: [] }
    }
    
    /// Open workbook from file
    fn open(path: String) -> Result<Self, ExcelError> {
        let handle = @native("excel_workbook_open", path)?
        let sheets = @native("excel_workbook_sheets", handle)?
        Ok(Workbook { handle: handle, path: Some(path), sheets: sheets })
    }
    
    /// Open password-protected workbook
    fn open_encrypted(path: String, password: String) -> Result<Self, ExcelError> {
        let handle = @native("excel_workbook_open_encrypted", path, password)?
        let sheets = @native("excel_workbook_sheets", handle)?
        Ok(Workbook { handle: handle, path: Some(path), sheets: sheets })
    }
    
    /// Create workbook from bytes
    fn from_bytes(data: [UInt8]) -> Result<Self, ExcelError> {
        let handle = @native("excel_workbook_from_bytes", data)?
        let sheets = @native("excel_workbook_sheets", handle)?
        Ok(Workbook { handle: handle, path: None, sheets: sheets })
    }
    
    /// Get sheet by index
    fn sheet(index: Int) -> Result<Sheet, ExcelError> {
        if index < 0 || index >= self.sheets.len() {
            return Err(ExcelError.SheetNotFound(index.to_string()))
        }
        Ok(self.sheets[index].clone())
    }
    
    /// Get sheet by name
    fn sheet_by_name(name: String) -> Result<Sheet, ExcelError> {
        self.sheets.iter()
            .find(|s| s.name == name)
            .ok_or(ExcelError.SheetNotFound(name))
    }
    
    /// Add new sheet
    fn add_sheet(name: String) -> Result<Sheet, ExcelError> {
        let sheet = @native("excel_workbook_add_sheet", self.handle, name)?
        self.sheets.push(sheet.clone())
        Ok(sheet)
    }
    
    /// Remove sheet by index
    fn remove_sheet(index: Int) -> Result<(), ExcelError> {
        if index < 0 || index >= self.sheets.len() {
            return Err(ExcelError.SheetNotFound(index.to_string()))
        }
        @native("excel_workbook_remove_sheet", self.handle, index)?
        self.sheets.remove(index)
        Ok(())
    }
    
    /// Get sheet count
    fn sheet_count() -> Int { self.sheets.len() }
    
    /// Get all sheet names
    fn sheet_names() -> [String] {
        self.sheets.iter().map(|s| s.name.clone()).collect()
    }
    
    /// Save workbook to file
    fn save(path: String) -> Result<(), ExcelError> {
        @native("excel_workbook_save", self.handle, path)
    }
    
    /// Save with password protection
    fn save_encrypted(path: String, password: String) -> Result<(), ExcelError> {
        @native("excel_workbook_save_encrypted", self.handle, path, password)
    }
    
    /// Export to bytes
    fn to_bytes() -> Result<[UInt8], ExcelError> {
        @native("excel_workbook_to_bytes", self.handle)
    }
    
    /// Close workbook
    fn close() { @native("excel_workbook_close", self.handle) }
}

impl Drop for Workbook { fn drop() { self.close() } }

// =============================================================================
// Sheet
// =============================================================================

/// Excel worksheet
struct Sheet {
    handle: @native("ExcelSheetHandle")
    name: String
    index: Int
}

impl Sheet {
    /// Get cell value
    fn cell(row: Int, col: Int) -> Result<Cell, ExcelError> {
        @native("excel_sheet_cell", self.handle, row, col)
    }
    
    /// Get cell by address (e.g., "A1", "B2")
    fn cell_at(address: String) -> Result<Cell, ExcelError> {
        let (row, col) = parse_cell_address(address)?
        self.cell(row, col)
    }
    
    /// Set cell value
    fn set_cell(row: Int, col: Int, value: CellValue) -> Result<(), ExcelError> {
        @native("excel_sheet_set_cell", self.handle, row, col, value)
    }
    
    /// Set cell at address
    fn set_cell_at(address: String, value: CellValue) -> Result<(), ExcelError> {
        let (row, col) = parse_cell_address(address)?
        self.set_cell(row, col, value)
    }
    
    /// Get row
    fn row(index: Int) -> Result<Row, ExcelError> {
        @native("excel_sheet_row", self.handle, index)
    }
    
    /// Get column
    fn column(index: Int) -> Result<Column, ExcelError> {
        @native("excel_sheet_column", self.handle, index)
    }
    
    /// Get range
    fn range(start: String, end: String) -> Result<Range, ExcelError> {
        let (sr, sc) = parse_cell_address(start)?
        let (er, ec) = parse_cell_address(end)?
        Ok(Range { sheet: self.clone(), start_row: sr, start_col: sc, end_row: er, end_col: ec })
    }
    
    /// Get used range
    fn used_range() -> Result<Range, ExcelError> {
        @native("excel_sheet_used_range", self.handle)
    }
    
    /// Get row count
    fn row_count() -> Int { @native("excel_sheet_row_count", self.handle) }
    
    /// Get column count
    fn col_count() -> Int { @native("excel_sheet_col_count", self.handle) }
    
    /// Insert row
    fn insert_row(index: Int) -> Result<(), ExcelError> {
        @native("excel_sheet_insert_row", self.handle, index)
    }
    
    /// Insert column
    fn insert_column(index: Int) -> Result<(), ExcelError> {
        @native("excel_sheet_insert_column", self.handle, index)
    }
    
    /// Delete row
    fn delete_row(index: Int) -> Result<(), ExcelError> {
        @native("excel_sheet_delete_row", self.handle, index)
    }
    
    /// Delete column
    fn delete_column(index: Int) -> Result<(), ExcelError> {
        @native("excel_sheet_delete_column", self.handle, index)
    }
    
    /// Merge cells
    fn merge_cells(start: String, end: String) -> Result<(), ExcelError> {
        @native("excel_sheet_merge_cells", self.handle, start, end)
    }
    
    /// Unmerge cells
    fn unmerge_cells(start: String, end: String) -> Result<(), ExcelError> {
        @native("excel_sheet_unmerge_cells", self.handle, start, end)
    }
    
    /// Set column width
    fn set_column_width(col: Int, width: Float64) -> Result<(), ExcelError> {
        @native("excel_sheet_set_column_width", self.handle, col, width)
    }
    
    /// Set row height
    fn set_row_height(row: Int, height: Float64) -> Result<(), ExcelError> {
        @native("excel_sheet_set_row_height", self.handle, row, height)
    }
    
    /// Auto-fit column width
    fn autofit_column(col: Int) -> Result<(), ExcelError> {
        @native("excel_sheet_autofit_column", self.handle, col)
    }
    
    /// Freeze panes
    fn freeze_panes(row: Int, col: Int) -> Result<(), ExcelError> {
        @native("excel_sheet_freeze_panes", self.handle, row, col)
    }
    
    /// Add chart
    fn add_chart(chart: Chart, position: String) -> Result<(), ExcelError> {
        @native("excel_sheet_add_chart", self.handle, chart, position)
    }
    
    /// Add image
    fn add_image(path: String, position: String) -> Result<(), ExcelError> {
        @native("excel_sheet_add_image", self.handle, path, position)
    }
    
    /// Convert to 2D array
    fn to_array() -> Result<[[CellValue]], ExcelError> {
        @native("excel_sheet_to_array", self.handle)
    }
    
    /// Load from 2D array
    fn from_array(data: [[CellValue]]) -> Result<(), ExcelError> {
        @native("excel_sheet_from_array", self.handle, data)
    }
}

// =============================================================================
// Cell
// =============================================================================

/// Excel cell
struct Cell {
    row: Int
    col: Int
    value: CellValue
    formula: Option<String>
    style: CellStyle
}

impl Cell {
    fn string_value() -> Option<String> {
        match self.value {
            CellValue.String(s) => Some(s)
            CellValue.Number(n) => Some(n.to_string())
            CellValue.Boolean(b) => Some(b.to_string())
            _ => None
        }
    }
    
    fn number_value() -> Option<Float64> {
        match self.value {
            CellValue.Number(n) => Some(n)
            CellValue.String(s) => s.parse::<Float64>().ok()
            _ => None
        }
    }
    
    fn bool_value() -> Option<Bool> {
        match self.value {
            CellValue.Boolean(b) => Some(b)
            _ => None
        }
    }
    
    fn date_value() -> Option<DateTime> {
        match self.value {
            CellValue.Date(d) => Some(d)
            _ => None
        }
    }
    
    fn is_empty() -> Bool {
        match self.value {
            CellValue.Empty => true
            _ => false
        }
    }
    
    fn has_formula() -> Bool { self.formula.is_some() }
    
    fn address() -> String { cell_address(self.row, self.col) }
}

/// Cell value types
enum CellValue {
    Empty
    String(String)
    Number(Float64)
    Boolean(Bool)
    Date(DateTime)
    Error(String)
}

impl CellValue {
    fn from_string(s: String) -> Self { CellValue.String(s) }
    fn from_number(n: Float64) -> Self { CellValue.Number(n) }
    fn from_int(n: Int) -> Self { CellValue.Number(n as Float64) }
    fn from_bool(b: Bool) -> Self { CellValue.Boolean(b) }
    fn from_date(d: DateTime) -> Self { CellValue.Date(d) }
}

// =============================================================================
// Cell Style
// =============================================================================

/// Cell styling
struct CellStyle {
    font: Option<FontStyle>
    fill: Option<FillStyle>
    border: Option<BorderStyle>
    alignment: Option<AlignmentStyle>
    number_format: Option<String>
}

impl CellStyle {
    fn new() -> Self {
        CellStyle { font: None, fill: None, border: None, alignment: None, number_format: None }
    }
    
    fn font(f: FontStyle) -> Self { self.font = Some(f); self }
    fn fill(f: FillStyle) -> Self { self.fill = Some(f); self }
    fn border(b: BorderStyle) -> Self { self.border = Some(b); self }
    fn alignment(a: AlignmentStyle) -> Self { self.alignment = Some(a); self }
    fn number_format(fmt: String) -> Self { self.number_format = Some(fmt); self }
}

struct FontStyle {
    name: String
    size: Float64
    bold: Bool
    italic: Bool
    underline: Bool
    color: String
}

impl FontStyle {
    fn new() -> Self {
        FontStyle { name: "Calibri", size: 11.0, bold: false, italic: false, underline: false, color: "#000000" }
    }
    fn name(n: String) -> Self { self.name = n; self }
    fn size(s: Float64) -> Self { self.size = s; self }
    fn bold() -> Self { self.bold = true; self }
    fn italic() -> Self { self.italic = true; self }
    fn underline() -> Self { self.underline = true; self }
    fn color(c: String) -> Self { self.color = c; self }
}

struct FillStyle {
    pattern: FillPattern
    fg_color: String
    bg_color: String
}

enum FillPattern { None, Solid, Gray125, Gray0625 }

impl FillStyle {
    fn solid(color: String) -> Self {
        FillStyle { pattern: FillPattern.Solid, fg_color: color, bg_color: "#FFFFFF" }
    }
}

struct BorderStyle {
    left: Option<BorderEdge>
    right: Option<BorderEdge>
    top: Option<BorderEdge>
    bottom: Option<BorderEdge>
}

struct BorderEdge { style: BorderLineStyle, color: String }
enum BorderLineStyle { Thin, Medium, Thick, Double, Dotted, Dashed }

struct AlignmentStyle {
    horizontal: HorizontalAlign
    vertical: VerticalAlign
    wrap_text: Bool
}

enum HorizontalAlign { Left, Center, Right, Justify }
enum VerticalAlign { Top, Center, Bottom }

// =============================================================================
// Row and Column
// =============================================================================

struct Row {
    sheet: Sheet
    index: Int
}

impl Row {
    fn cell(col: Int) -> Result<Cell, ExcelError> { self.sheet.cell(self.index, col) }
    fn cells() -> Result<[Cell], ExcelError> { @native("excel_row_cells", self.sheet.handle, self.index) }
    fn values() -> Result<[CellValue], ExcelError> {
        Ok(self.cells()?.iter().map(|c| c.value.clone()).collect())
    }
    fn set_values(values: [CellValue]) -> Result<(), ExcelError> {
        for (i, v) in values.iter().enumerate() {
            self.sheet.set_cell(self.index, i, v.clone())?
        }
        Ok(())
    }
}

struct Column {
    sheet: Sheet
    index: Int
}

impl Column {
    fn cell(row: Int) -> Result<Cell, ExcelError> { self.sheet.cell(row, self.index) }
    fn cells() -> Result<[Cell], ExcelError> { @native("excel_column_cells", self.sheet.handle, self.index) }
}

// =============================================================================
// Range
// =============================================================================

struct Range {
    sheet: Sheet
    start_row: Int
    start_col: Int
    end_row: Int
    end_col: Int
}

impl Range {
    fn cells() -> Result<[[Cell]], ExcelError> {
        var result: [[Cell]] = []
        for r in self.start_row..=self.end_row {
            var row_cells: [Cell] = []
            for c in self.start_col..=self.end_col {
                row_cells.push(self.sheet.cell(r, c)?)
            }
            result.push(row_cells)
        }
        Ok(result)
    }
    
    fn values() -> Result<[[CellValue]], ExcelError> {
        Ok(self.cells()?.iter().map(|row| row.iter().map(|c| c.value.clone()).collect()).collect())
    }
    
    fn set_values(values: [[CellValue]]) -> Result<(), ExcelError> {
        for (ri, row) in values.iter().enumerate() {
            for (ci, val) in row.iter().enumerate() {
                self.sheet.set_cell(self.start_row + ri, self.start_col + ci, val.clone())?
            }
        }
        Ok(())
    }
    
    fn apply_style(style: CellStyle) -> Result<(), ExcelError> {
        @native("excel_range_apply_style", self.sheet.handle, self, style)
    }
    
    fn sum() -> Result<Float64, ExcelError> {
        var total = 0.0
        for row in self.values()? {
            for val in row {
                if let CellValue.Number(n) = val { total += n }
            }
        }
        Ok(total)
    }
    
    fn average() -> Result<Float64, ExcelError> {
        var total = 0.0
        var count = 0
        for row in self.values()? {
            for val in row {
                if let CellValue.Number(n) = val { total += n; count += 1 }
            }
        }
        if count == 0 { return Err(ExcelError.InvalidOperation("No numeric values")) }
        Ok(total / count as Float64)
    }
}

// =============================================================================
// Charts
// =============================================================================

/// Chart types
enum ChartType { Bar, Column, Line, Pie, Area, Scatter, Doughnut }

struct Chart {
    chart_type: ChartType
    title: Option<String>
    data_range: String
    categories_range: Option<String>
    width: Int
    height: Int
}

impl Chart {
    fn new(chart_type: ChartType, data_range: String) -> Self {
        Chart { chart_type: chart_type, title: None, data_range: data_range, categories_range: None, width: 480, height: 300 }
    }
    
    fn title(t: String) -> Self { self.title = Some(t); self }
    fn categories(range: String) -> Self { self.categories_range = Some(range); self }
    fn size(w: Int, h: Int) -> Self { self.width = w; self.height = h; self }
    
    fn bar(data_range: String) -> Self { Chart.new(ChartType.Bar, data_range) }
    fn column(data_range: String) -> Self { Chart.new(ChartType.Column, data_range) }
    fn line(data_range: String) -> Self { Chart.new(ChartType.Line, data_range) }
    fn pie(data_range: String) -> Self { Chart.new(ChartType.Pie, data_range) }
}

// =============================================================================
// Formula Builder
// =============================================================================

struct Formula {}

impl Formula {
    fn sum(range: String) -> String { format!("=SUM({})", range) }
    fn average(range: String) -> String { format!("=AVERAGE({})", range) }
    fn count(range: String) -> String { format!("=COUNT({})", range) }
    fn max(range: String) -> String { format!("=MAX({})", range) }
    fn min(range: String) -> String { format!("=MIN({})", range) }
    fn if_then(condition: String, true_val: String, false_val: String) -> String {
        format!("=IF({},{},{})", condition, true_val, false_val)
    }
    fn vlookup(value: String, range: String, col: Int, exact: Bool) -> String {
        format!("=VLOOKUP({},{},{},{})", value, range, col, if exact { "FALSE" } else { "TRUE" })
    }
    fn concatenate(values: [String]) -> String {
        format!("=CONCATENATE({})", values.join(","))
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

fn parse_cell_address(address: String) -> Result<(Int, Int), ExcelError> {
    let upper = address.to_uppercase()
    var col = 0
    var row_start = 0
    
    for (i, c) in upper.chars().enumerate() {
        if c.is_alphabetic() {
            col = col * 26 + (c as Int - 'A' as Int + 1)
        } else {
            row_start = i
            break
        }
    }
    
    let row = upper[row_start..].parse::<Int>().map_err(|_| ExcelError.InvalidAddress(address.clone()))?
    Ok((row - 1, col - 1))
}

fn cell_address(row: Int, col: Int) -> String {
    var col_str = String.new()
    var c = col + 1
    while c > 0 {
        c -= 1
        col_str = String.from_char(('A' as Int + c % 26) as Char) + col_str
        c /= 26
    }
    format!("{}{}", col_str, row + 1)
}

// =============================================================================
// Convenience Functions
// =============================================================================

fn open(path: String) -> Result<Workbook, ExcelError> { Workbook.open(path) }
fn create() -> Workbook { Workbook.new() }

fn read_sheet(path: String, sheet: Int) -> Result<[[CellValue]], ExcelError> {
    let wb = Workbook.open(path)?
    wb.sheet(sheet)?.to_array()
}

fn write_sheet(path: String, data: [[CellValue]]) -> Result<(), ExcelError> {
    let wb = Workbook.new()
    let sheet = wb.add_sheet("Sheet1")?
    sheet.from_array(data)?
    wb.save(path)
}

// =============================================================================
// Errors
// =============================================================================

enum ExcelError {
    FileNotFound(String)
    InvalidFormat
    SheetNotFound(String)
    InvalidAddress(String)
    InvalidOperation(String)
    PasswordRequired
    InvalidPassword
    IoError(IoError)
    Other(String)
}

impl Display for ExcelError {
    fn fmt(f: Formatter) {
        match self {
            FileNotFound(p) => f.write(format!("File not found: {}", p))
            InvalidFormat => f.write("Invalid Excel format")
            SheetNotFound(n) => f.write(format!("Sheet not found: {}", n))
            InvalidAddress(a) => f.write(format!("Invalid cell address: {}", a))
            Other(m) => f.write(m)
            _ => f.write("Excel error")
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "cell address parsing" {
    let (row, col) = parse_cell_address("A1")?
    assert_eq(row, 0)?
    assert_eq(col, 0)?
    
    let (row2, col2) = parse_cell_address("B2")?
    assert_eq(row2, 1)?
    assert_eq(col2, 1)?
}

test "cell address generation" {
    assert_eq(cell_address(0, 0), "A1")?
    assert_eq(cell_address(1, 1), "B2")?
    assert_eq(cell_address(0, 26), "AA1")?
}

test "formula builder" {
    assert_eq(Formula.sum("A1:A10"), "=SUM(A1:A10)")?
    assert_eq(Formula.average("B1:B5"), "=AVERAGE(B1:B5)")?
}

test "cell value types" {
    let s = CellValue.from_string("Hello")
    let n = CellValue.from_number(42.5)
    let b = CellValue.from_bool(true)
    
    match s { CellValue.String(_) => assert(true), _ => assert(false) }
    match n { CellValue.Number(_) => assert(true), _ => assert(false) }
    match b { CellValue.Boolean(_) => assert(true), _ => assert(false) }
}
