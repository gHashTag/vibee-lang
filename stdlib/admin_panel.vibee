// =============================================================================
// Vibee OS â€” Admin Panel Module
// Administrative dashboard and management interface
// =============================================================================

use auth.{AuthResult, Credentials}
use rbac.{Role, RoleManager}
use session.{Session, SessionManager}
use logger.{Logger, Level}
use datetime.{DateTime, Duration}

// =============================================================================
// Core Types
// =============================================================================

/// Admin user representation
struct AdminUser {
    id: String
    username: String
    email: String
    display_name: String
    avatar_url: Option<String>
    roles: [String]
    permissions: Set<String>
    is_super_admin: Bool
    last_login: Option<DateTime>
    created_at: DateTime
    updated_at: DateTime
    metadata: Map<String, Any>
}

impl AdminUser {
    fn new(id: String, username: String, email: String) -> Self {
        AdminUser {
            id: id,
            username: username,
            email: email,
            display_name: username.clone(),
            avatar_url: None,
            roles: [],
            permissions: Set.new(),
            is_super_admin: false,
            last_login: None,
            created_at: DateTime.now(),
            updated_at: DateTime.now(),
            metadata: Map.new()
        }
    }
    
    fn with_display_name(name: String) -> Self {
        self.display_name = name
        self
    }
    
    fn with_avatar(url: String) -> Self {
        self.avatar_url = Some(url)
        self
    }
    
    fn with_role(role: String) -> Self {
        self.roles.push(role)
        self
    }
    
    fn with_permission(permission: String) -> Self {
        self.permissions.insert(permission)
        self
    }
    
    fn as_super_admin() -> Self {
        self.is_super_admin = true
        self
    }
    
    fn has_permission(permission: String) -> Bool {
        self.is_super_admin || self.permissions.contains(permission)
    }
    
    fn has_role(role: String) -> Bool {
        self.roles.contains(role)
    }
    
    fn update_last_login() -> Self {
        self.last_login = Some(DateTime.now())
        self.updated_at = DateTime.now()
        self
    }
}

// =============================================================================
// Admin Panel Configuration
// =============================================================================

/// Admin panel configuration
struct AdminPanelConfig {
    title: String
    logo_url: Option<String>
    favicon_url: Option<String>
    theme: AdminTheme
    sidebar_collapsed: Bool
    items_per_page: Int
    session_timeout: Duration
    require_mfa: Bool
    allowed_ips: Option<[String]>
    custom_css: Option<String>
    custom_js: Option<String>
    footer_text: Option<String>
}

impl AdminPanelConfig {
    fn default() -> Self {
        AdminPanelConfig {
            title: "Admin Panel",
            logo_url: None,
            favicon_url: None,
            theme: AdminTheme.Light,
            sidebar_collapsed: false,
            items_per_page: 25,
            session_timeout: Duration.hours(2),
            require_mfa: false,
            allowed_ips: None,
            custom_css: None,
            custom_js: None,
            footer_text: None
        }
    }
    
    fn with_title(title: String) -> Self {
        self.title = title
        self
    }
    
    fn with_logo(url: String) -> Self {
        self.logo_url = Some(url)
        self
    }
    
    fn with_theme(theme: AdminTheme) -> Self {
        self.theme = theme
        self
    }
    
    fn with_mfa_required() -> Self {
        self.require_mfa = true
        self
    }
    
    fn with_ip_whitelist(ips: [String]) -> Self {
        self.allowed_ips = Some(ips)
        self
    }
}

/// Admin panel theme
enum AdminTheme {
    Light
    Dark
    System
    Custom(String)
    
    fn css_class() -> String {
        match self {
            Light => "theme-light"
            Dark => "theme-dark"
            System => "theme-system"
            Custom(name) => "theme-\(name)"
        }
    }
}

// =============================================================================
// Dashboard Widgets
// =============================================================================

/// Dashboard widget types
enum WidgetType {
    Counter
    Chart
    Table
    List
    Progress
    Status
    Custom(String)
}

/// Dashboard widget
struct DashboardWidget {
    id: String
    title: String
    widget_type: WidgetType
    data_source: String
    refresh_interval: Option<Duration>
    size: WidgetSize
    position: WidgetPosition
    config: Map<String, Any>
}

impl DashboardWidget {
    fn new(id: String, title: String, widget_type: WidgetType) -> Self {
        DashboardWidget {
            id: id,
            title: title,
            widget_type: widget_type,
            data_source: "",
            refresh_interval: None,
            size: WidgetSize.Medium,
            position: WidgetPosition { row: 0, col: 0 },
            config: Map.new()
        }
    }
    
    fn with_data_source(source: String) -> Self {
        self.data_source = source
        self
    }
    
    fn with_refresh(interval: Duration) -> Self {
        self.refresh_interval = Some(interval)
        self
    }
    
    fn with_size(size: WidgetSize) -> Self {
        self.size = size
        self
    }
    
    fn with_position(row: Int, col: Int) -> Self {
        self.position = WidgetPosition { row: row, col: col }
        self
    }
    
    fn with_config(key: String, value: Any) -> Self {
        self.config.insert(key, value)
        self
    }
}

/// Widget size
enum WidgetSize {
    Small      // 1x1
    Medium     // 2x1
    Large      // 2x2
    Wide       // 4x1
    Tall       // 1x2
    Full       // 4x2
}

/// Widget position on grid
struct WidgetPosition {
    row: Int
    col: Int
}

/// Dashboard configuration
struct Dashboard {
    id: String
    name: String
    description: Option<String>
    widgets: [DashboardWidget]
    is_default: Bool
    owner_id: Option<String>
    shared_with: [String]
    created_at: DateTime
    updated_at: DateTime
}

impl Dashboard {
    fn new(id: String, name: String) -> Self {
        Dashboard {
            id: id,
            name: name,
            description: None,
            widgets: [],
            is_default: false,
            owner_id: None,
            shared_with: [],
            created_at: DateTime.now(),
            updated_at: DateTime.now()
        }
    }
    
    fn add_widget(widget: DashboardWidget) -> Self {
        self.widgets.push(widget)
        self.updated_at = DateTime.now()
        self
    }
    
    fn remove_widget(widget_id: String) -> Self {
        self.widgets.retain(|w| w.id != widget_id)
        self.updated_at = DateTime.now()
        self
    }
    
    fn set_default() -> Self {
        self.is_default = true
        self
    }
    
    fn share_with(user_id: String) -> Self {
        if !self.shared_with.contains(user_id) {
            self.shared_with.push(user_id)
        }
        self
    }
}

// =============================================================================
// Menu System
// =============================================================================

/// Menu item
struct MenuItem {
    id: String
    label: String
    icon: Option<String>
    route: Option<String>
    children: [MenuItem]
    permission: Option<String>
    badge: Option<MenuBadge>
    is_active: Bool
    is_expanded: Bool
    order: Int
}

impl MenuItem {
    fn new(id: String, label: String) -> Self {
        MenuItem {
            id: id,
            label: label,
            icon: None,
            route: None,
            children: [],
            permission: None,
            badge: None,
            is_active: false,
            is_expanded: false,
            order: 0
        }
    }
    
    fn with_icon(icon: String) -> Self {
        self.icon = Some(icon)
        self
    }
    
    fn with_route(route: String) -> Self {
        self.route = Some(route)
        self
    }
    
    fn with_child(child: MenuItem) -> Self {
        self.children.push(child)
        self
    }
    
    fn with_permission(permission: String) -> Self {
        self.permission = Some(permission)
        self
    }
    
    fn with_badge(badge: MenuBadge) -> Self {
        self.badge = Some(badge)
        self
    }
    
    fn with_order(order: Int) -> Self {
        self.order = order
        self
    }
    
    fn is_visible_for(user: AdminUser) -> Bool {
        match self.permission {
            Some(perm) => user.has_permission(perm)
            None => true
        }
    }
}

/// Menu badge
struct MenuBadge {
    text: String
    color: BadgeColor
}

enum BadgeColor {
    Primary
    Secondary
    Success
    Warning
    Danger
    Info
}

/// Admin menu
struct AdminMenu {
    items: [MenuItem]
}

impl AdminMenu {
    fn new() -> Self {
        AdminMenu { items: [] }
    }
    
    fn add_item(item: MenuItem) -> Self {
        self.items.push(item)
        self.items.sort_by(|a, b| a.order.cmp(b.order))
        self
    }
    
    fn filter_for_user(user: AdminUser) -> AdminMenu {
        let filtered = self.items
            .iter()
            .filter(|item| item.is_visible_for(user))
            .map(|item| {
                var filtered_item = item.clone()
                filtered_item.children = item.children
                    .iter()
                    .filter(|child| child.is_visible_for(user))
                    .collect()
                filtered_item
            })
            .collect()
        
        AdminMenu { items: filtered }
    }
    
    fn find_by_route(route: String) -> Option<MenuItem> {
        for item in self.items.iter() {
            if item.route == Some(route.clone()) {
                return Some(item.clone())
            }
            for child in item.children.iter() {
                if child.route == Some(route.clone()) {
                    return Some(child.clone())
                }
            }
        }
        None
    }
}

// =============================================================================
// Admin Panel Trait
// =============================================================================

/// Admin panel interface
trait AdminPanelProvider {
    fn authenticate(credentials: Credentials) -> Result<AdminUser, AdminError>
    fn get_user(user_id: String) -> Result<Option<AdminUser>, AdminError>
    fn get_dashboard(user: AdminUser) -> Result<Dashboard, AdminError>
    fn get_menu(user: AdminUser) -> Result<AdminMenu, AdminError>
    fn log_action(user: AdminUser, action: String, details: Map<String, Any>)
}

// =============================================================================
// Admin Panel
// =============================================================================

/// Main admin panel
struct AdminPanel {
    config: AdminPanelConfig
    menu: AdminMenu
    dashboards: Map<String, Dashboard>
    current_user: Option<AdminUser>
    session_manager: SessionManager
    logger: Logger
}

impl AdminPanel {
    fn new(config: AdminPanelConfig) -> Self {
        AdminPanel {
            config: config,
            menu: AdminMenu.new(),
            dashboards: Map.new(),
            current_user: None,
            session_manager: SessionManager.new(),
            logger: Logger.new("admin_panel")
        }
    }
    
    fn with_menu(menu: AdminMenu) -> Self {
        self.menu = menu
        self
    }
    
    fn add_dashboard(dashboard: Dashboard) -> Self {
        self.dashboards.insert(dashboard.id.clone(), dashboard)
        self
    }
    
    /// Authenticate admin user
    fn login(credentials: Credentials) -> Result<AdminUser, AdminError> {
        self.logger.info("Admin login attempt")
        
        // Check IP whitelist
        if let Some(allowed_ips) = self.config.allowed_ips.as_ref() {
            let client_ip = self.get_client_ip()
            if !allowed_ips.contains(client_ip) {
                self.logger.warn_with("Login blocked: IP not whitelisted", {
                    "ip": client_ip
                })
                return Err(AdminError.AccessDenied("IP not whitelisted"))
            }
        }
        
        // Authenticate (implementation depends on auth provider)
        let user = self.authenticate_user(credentials)?
        
        // Check MFA if required
        if self.config.require_mfa && !user.metadata.get("mfa_verified").unwrap_or(false) {
            return Err(AdminError.MfaRequired)
        }
        
        // Create session
        let session = self.session_manager.create(user.id.clone())
        session.set("admin_user", user.clone())
        
        self.current_user = Some(user.clone())
        self.logger.info_with("Admin login successful", {
            "user_id": user.id,
            "username": user.username
        })
        
        Ok(user)
    }
    
    /// Logout current user
    fn logout() -> Result<(), AdminError> {
        if let Some(user) = self.current_user.as_ref() {
            self.logger.info_with("Admin logout", {
                "user_id": user.id,
                "username": user.username
            })
            self.session_manager.destroy_current()
        }
        self.current_user = None
        Ok(())
    }
    
    /// Get current authenticated user
    fn current_user() -> Option<AdminUser> {
        self.current_user.clone()
    }
    
    /// Check if user is authenticated
    fn is_authenticated() -> Bool {
        self.current_user.is_some()
    }
    
    /// Get menu for current user
    fn get_menu() -> AdminMenu {
        match self.current_user.as_ref() {
            Some(user) => self.menu.filter_for_user(user.clone())
            None => AdminMenu.new()
        }
    }
    
    /// Get default dashboard for current user
    fn get_dashboard() -> Option<Dashboard> {
        let user = self.current_user.as_ref()?
        
        // Try user's custom dashboard first
        if let Some(dashboard_id) = user.metadata.get("default_dashboard") {
            if let Some(dashboard) = self.dashboards.get(dashboard_id) {
                return Some(dashboard.clone())
            }
        }
        
        // Fall back to default dashboard
        self.dashboards.values()
            .find(|d| d.is_default)
            .cloned()
    }
    
    /// Check permission for current user
    fn can(permission: String) -> Bool {
        match self.current_user.as_ref() {
            Some(user) => user.has_permission(permission)
            None => false
        }
    }
    
    /// Require permission (throws if not allowed)
    fn require_permission(permission: String) -> Result<(), AdminError> {
        if !self.can(permission) {
            return Err(AdminError.PermissionDenied(permission))
        }
        Ok(())
    }
    
    // Private methods
    fn authenticate_user(credentials: Credentials) -> Result<AdminUser, AdminError> {
        // This would be implemented by the actual auth provider
        Err(AdminError.AuthenticationFailed("Not implemented"))
    }
    
    fn get_client_ip() -> String {
        // This would get the actual client IP
        "127.0.0.1"
    }
}

// =============================================================================
// Admin Panel Actor
// =============================================================================

/// Async admin panel actor
actor AdminPanelActor {
    panel: AdminPanel
    active_sessions: Map<String, AdminSession>
    
    fn new(config: AdminPanelConfig) -> Self {
        AdminPanelActor {
            panel: AdminPanel.new(config),
            active_sessions: Map.new()
        }
    }
    
    async fn login(credentials: Credentials) -> Result<AdminSession, AdminError> {
        let user = self.panel.login(credentials)?
        let session = AdminSession.new(user.clone())
        self.active_sessions.insert(session.id.clone(), session.clone())
        Ok(session)
    }
    
    async fn logout(session_id: String) -> Result<(), AdminError> {
        self.active_sessions.remove(session_id)
        self.panel.logout()
    }
    
    async fn get_session(session_id: String) -> Option<AdminSession> {
        self.active_sessions.get(session_id).cloned()
    }
    
    async fn get_active_sessions() -> [AdminSession] {
        self.active_sessions.values().cloned().collect()
    }
    
    async fn broadcast_notification(notification: AdminNotification) {
        for session in self.active_sessions.values() {
            session.send_notification(notification.clone())
        }
    }
}

/// Admin session
struct AdminSession {
    id: String
    user: AdminUser
    started_at: DateTime
    last_activity: DateTime
    notifications: [AdminNotification]
}

impl AdminSession {
    fn new(user: AdminUser) -> Self {
        AdminSession {
            id: uuid(),
            user: user,
            started_at: DateTime.now(),
            last_activity: DateTime.now(),
            notifications: []
        }
    }
    
    fn touch() -> Self {
        self.last_activity = DateTime.now()
        self
    }
    
    fn send_notification(notification: AdminNotification) {
        self.notifications.push(notification)
    }
    
    fn is_expired(timeout: Duration) -> Bool {
        DateTime.now() - self.last_activity > timeout
    }
}

/// Admin notification
struct AdminNotification {
    id: String
    title: String
    message: String
    notification_type: NotificationType
    created_at: DateTime
    read: Bool
}

enum NotificationType {
    Info
    Success
    Warning
    Error
    System
}

// =============================================================================
// Admin Errors
// =============================================================================

/// Admin panel errors
enum AdminError {
    AuthenticationFailed(String)
    AccessDenied(String)
    PermissionDenied(String)
    MfaRequired
    SessionExpired
    UserNotFound(String)
    InvalidInput(String)
    InternalError(String)
    
    fn message() -> String {
        match self {
            AuthenticationFailed(msg) => "Authentication failed: \(msg)"
            AccessDenied(msg) => "Access denied: \(msg)"
            PermissionDenied(perm) => "Permission denied: \(perm)"
            MfaRequired => "Multi-factor authentication required"
            SessionExpired => "Session has expired"
            UserNotFound(id) => "User not found: \(id)"
            InvalidInput(msg) => "Invalid input: \(msg)"
            InternalError(msg) => "Internal error: \(msg)"
        }
    }
}

impl Error for AdminError {
    fn description() -> String { self.message() }
}

// =============================================================================
// Builder
// =============================================================================

/// Admin panel builder
struct AdminPanelBuilder {
    config: AdminPanelConfig
    menu_items: [MenuItem]
    dashboards: [Dashboard]
}

impl AdminPanelBuilder {
    fn new() -> Self {
        AdminPanelBuilder {
            config: AdminPanelConfig.default(),
            menu_items: [],
            dashboards: []
        }
    }
    
    fn title(title: String) -> Self {
        self.config.title = title
        self
    }
    
    fn logo(url: String) -> Self {
        self.config.logo_url = Some(url)
        self
    }
    
    fn theme(theme: AdminTheme) -> Self {
        self.config.theme = theme
        self
    }
    
    fn require_mfa() -> Self {
        self.config.require_mfa = true
        self
    }
    
    fn session_timeout(duration: Duration) -> Self {
        self.config.session_timeout = duration
        self
    }
    
    fn ip_whitelist(ips: [String]) -> Self {
        self.config.allowed_ips = Some(ips)
        self
    }
    
    fn menu_item(item: MenuItem) -> Self {
        self.menu_items.push(item)
        self
    }
    
    fn dashboard(dashboard: Dashboard) -> Self {
        self.dashboards.push(dashboard)
        self
    }
    
    fn build() -> AdminPanel {
        var menu = AdminMenu.new()
        for item in self.menu_items {
            menu = menu.add_item(item)
        }
        
        var panel = AdminPanel.new(self.config)
            .with_menu(menu)
        
        for dashboard in self.dashboards {
            panel = panel.add_dashboard(dashboard)
        }
        
        panel
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Create default admin menu
fn default_menu() -> AdminMenu {
    AdminMenu.new()
        .add_item(MenuItem.new("dashboard", "Dashboard")
            .with_icon("home")
            .with_route("/admin")
            .with_order(0))
        .add_item(MenuItem.new("users", "Users")
            .with_icon("users")
            .with_route("/admin/users")
            .with_permission("users:read")
            .with_order(10))
        .add_item(MenuItem.new("settings", "Settings")
            .with_icon("settings")
            .with_route("/admin/settings")
            .with_permission("settings:read")
            .with_order(100))
}

/// Create default dashboard
fn default_dashboard() -> Dashboard {
    Dashboard.new("default", "Overview")
        .set_default()
        .add_widget(DashboardWidget.new("users_count", "Total Users", WidgetType.Counter)
            .with_data_source("/api/stats/users")
            .with_size(WidgetSize.Small)
            .with_position(0, 0))
        .add_widget(DashboardWidget.new("activity_chart", "Activity", WidgetType.Chart)
            .with_data_source("/api/stats/activity")
            .with_size(WidgetSize.Large)
            .with_position(0, 1)
            .with_refresh(Duration.minutes(5)))
}

// =============================================================================
// Tests
// =============================================================================

test "admin user creation" {
    let user = AdminUser.new("1", "admin", "admin@example.com")
        .with_display_name("Administrator")
        .with_role("admin")
        .with_permission("users:read")
    
    assert_eq(user.username, "admin")?
    assert(user.has_role("admin"))?
    assert(user.has_permission("users:read"))?
    assert(!user.has_permission("users:delete"))?
}

test "super admin has all permissions" {
    let user = AdminUser.new("1", "superadmin", "super@example.com")
        .as_super_admin()
    
    assert(user.has_permission("any:permission"))?
    assert(user.has_permission("another:permission"))?
}

test "menu filtering by permission" {
    let menu = AdminMenu.new()
        .add_item(MenuItem.new("public", "Public").with_order(0))
        .add_item(MenuItem.new("admin", "Admin Only")
            .with_permission("admin:access")
            .with_order(1))
    
    let user = AdminUser.new("1", "user", "user@example.com")
    let filtered = menu.filter_for_user(user)
    
    assert_eq(filtered.items.len(), 1)?
    assert_eq(filtered.items[0].id, "public")?
}

test "dashboard widget creation" {
    let widget = DashboardWidget.new("test", "Test Widget", WidgetType.Counter)
        .with_data_source("/api/test")
        .with_size(WidgetSize.Medium)
        .with_refresh(Duration.seconds(30))
    
    assert_eq(widget.id, "test")?
    assert_eq(widget.refresh_interval, Some(Duration.seconds(30)))?
}

test "admin panel builder" {
    let panel = AdminPanelBuilder.new()
        .title("My Admin")
        .theme(AdminTheme.Dark)
        .require_mfa()
        .session_timeout(Duration.hours(1))
        .build()
    
    assert_eq(panel.config.title, "My Admin")?
    assert(panel.config.require_mfa)?
}

test "admin session expiry" {
    let user = AdminUser.new("1", "admin", "admin@example.com")
    var session = AdminSession.new(user)
    
    // Simulate old activity
    session.last_activity = DateTime.now() - Duration.hours(3)
    
    assert(session.is_expired(Duration.hours(2)))?
    assert(!session.is_expired(Duration.hours(4)))?
}
