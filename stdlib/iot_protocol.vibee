// =============================================================================
// Vibee OS â€” IoT Protocol Module
// IoT communication protocols: CoAP, LwM2M, Modbus, BLE
// =============================================================================

// -----------------------------------------------------------------------------
// CoAP Protocol
// -----------------------------------------------------------------------------

/// CoAP method types
enum CoapMethod { Get, Post, Put, Delete }

/// CoAP response codes
enum CoapCode {
    Created
    Deleted
    Valid
    Changed
    Content
    BadRequest
    Unauthorized
    NotFound
    MethodNotAllowed
    InternalError
    
    fn to_code() -> (Int, Int) {
        match self {
            .Created => (2, 1)
            .Deleted => (2, 2)
            .Valid => (2, 3)
            .Changed => (2, 4)
            .Content => (2, 5)
            .BadRequest => (4, 0)
            .Unauthorized => (4, 1)
            .NotFound => (4, 4)
            .MethodNotAllowed => (4, 5)
            .InternalError => (5, 0)
        }
    }
}

/// CoAP message
struct CoapMessage {
    method: CoapMethod
    uri: String
    payload: [Byte]
    token: [Byte]
    message_id: UInt16
    options: Map<Int, [Byte]>
    
    fn new(method: CoapMethod, uri: String) -> Self {
        CoapMessage {
            method: method,
            uri: uri,
            payload: [],
            token: @native("random_bytes", 4),
            message_id: @native("random_u16"),
            options: Map.empty()
        }
    }
    
    fn with_payload(payload: [Byte]) -> Self { self.payload = payload; self }
    fn with_json<T: Serialize>(data: T) -> Self { self.payload = JSON.stringify(data).bytes(); self }
}

/// CoAP client
actor CoapClient {
    state host: String
    state port: UInt16
    
    fn new(host: String, port: UInt16) -> Self {
        CoapClient { host: host, port: port }
    }
    
    on get(uri: String) -> Result<CoapResponse, ProtocolError> {
        self.send(CoapMessage.new(CoapMethod.Get, uri))
    }
    
    on post(uri: String, payload: [Byte]) -> Result<CoapResponse, ProtocolError> {
        self.send(CoapMessage.new(CoapMethod.Post, uri).with_payload(payload))
    }
    
    on put(uri: String, payload: [Byte]) -> Result<CoapResponse, ProtocolError> {
        self.send(CoapMessage.new(CoapMethod.Put, uri).with_payload(payload))
    }
    
    on delete(uri: String) -> Result<CoapResponse, ProtocolError> {
        self.send(CoapMessage.new(CoapMethod.Delete, uri))
    }
    
    on send(msg: CoapMessage) -> Result<CoapResponse, ProtocolError> {
        @native("coap_send", self.host, self.port, msg)
    }
}

struct CoapResponse {
    code: CoapCode
    payload: [Byte]
    token: [Byte]
    
    fn payload_string() -> Result<String, ProtocolError> { String.from_utf8(self.payload).map_err(|_| ProtocolError.DecodeError) }
    fn payload_json<T: Deserialize>() -> Result<T, ProtocolError> { JSON.parse(self.payload_string()?).map_err(|_| ProtocolError.DecodeError) }
}

// -----------------------------------------------------------------------------
// LwM2M Protocol
// -----------------------------------------------------------------------------

/// LwM2M object
struct Lwm2mObject {
    object_id: UInt16
    instances: Map<UInt16, Lwm2mInstance>
    
    fn new(object_id: UInt16) -> Self {
        Lwm2mObject { object_id: object_id, instances: Map.empty() }
    }
    
    fn add_instance(instance_id: UInt16) -> Lwm2mInstance {
        let instance = Lwm2mInstance.new(self.object_id, instance_id)
        self.instances.set(instance_id, instance)
        instance
    }
}

struct Lwm2mInstance {
    object_id: UInt16
    instance_id: UInt16
    resources: Map<UInt16, Lwm2mResource>
    
    fn new(object_id: UInt16, instance_id: UInt16) -> Self {
        Lwm2mInstance { object_id: object_id, instance_id: instance_id, resources: Map.empty() }
    }
    
    fn set_resource(resource_id: UInt16, value: Lwm2mValue) {
        self.resources.set(resource_id, Lwm2mResource { id: resource_id, value: value })
    }
}

struct Lwm2mResource {
    id: UInt16
    value: Lwm2mValue
}

enum Lwm2mValue {
    String(String)
    Integer(Int64)
    Float(Float64)
    Boolean(Bool)
    Opaque([Byte])
    Time(Int64)
}

/// LwM2M client
actor Lwm2mClient {
    state endpoint: String
    state server_uri: String
    state objects: Map<UInt16, Lwm2mObject>
    state registered: Bool
    
    fn new(endpoint: String, server_uri: String) -> Self {
        Lwm2mClient { endpoint: endpoint, server_uri: server_uri, objects: Map.empty(), registered: false }
    }
    
    on add_object(object: Lwm2mObject) { self.objects.set(object.object_id, object) }
    
    on register() -> Result<(), ProtocolError> {
        @native("lwm2m_register", self.server_uri, self.endpoint, self.objects)?
        self.registered = true
        Ok(())
    }
    
    on update() -> Result<(), ProtocolError> {
        if !self.registered { return Err(ProtocolError.NotConnected) }
        @native("lwm2m_update", self.server_uri, self.endpoint)
    }
    
    on deregister() -> Result<(), ProtocolError> {
        @native("lwm2m_deregister", self.server_uri, self.endpoint)?
        self.registered = false
        Ok(())
    }
}

// -----------------------------------------------------------------------------
// Modbus Protocol
// -----------------------------------------------------------------------------

/// Modbus client
actor ModbusClient {
    state host: String
    state port: UInt16
    state unit_id: UInt8
    
    fn new(host: String, port: UInt16, unit_id: UInt8) -> Self {
        ModbusClient { host: host, port: port, unit_id: unit_id }
    }
    
    on read_coils(address: UInt16, count: UInt16) -> Result<[Bool], ProtocolError> {
        @native("modbus_read_coils", self.host, self.port, self.unit_id, address, count)
    }
    
    on read_discrete_inputs(address: UInt16, count: UInt16) -> Result<[Bool], ProtocolError> {
        @native("modbus_read_discrete", self.host, self.port, self.unit_id, address, count)
    }
    
    on read_holding_registers(address: UInt16, count: UInt16) -> Result<[UInt16], ProtocolError> {
        @native("modbus_read_holding", self.host, self.port, self.unit_id, address, count)
    }
    
    on read_input_registers(address: UInt16, count: UInt16) -> Result<[UInt16], ProtocolError> {
        @native("modbus_read_input", self.host, self.port, self.unit_id, address, count)
    }
    
    on write_single_coil(address: UInt16, value: Bool) -> Result<(), ProtocolError> {
        @native("modbus_write_coil", self.host, self.port, self.unit_id, address, value)
    }
    
    on write_single_register(address: UInt16, value: UInt16) -> Result<(), ProtocolError> {
        @native("modbus_write_register", self.host, self.port, self.unit_id, address, value)
    }
    
    on write_multiple_coils(address: UInt16, values: [Bool]) -> Result<(), ProtocolError> {
        @native("modbus_write_coils", self.host, self.port, self.unit_id, address, values)
    }
    
    on write_multiple_registers(address: UInt16, values: [UInt16]) -> Result<(), ProtocolError> {
        @native("modbus_write_registers", self.host, self.port, self.unit_id, address, values)
    }
}

/// Modbus RTU client (serial)
actor ModbusRtuClient {
    state port: String
    state baud_rate: Int
    state unit_id: UInt8
    
    fn new(port: String, baud_rate: Int, unit_id: UInt8) -> Self {
        ModbusRtuClient { port: port, baud_rate: baud_rate, unit_id: unit_id }
    }
    
    on read_holding_registers(address: UInt16, count: UInt16) -> Result<[UInt16], ProtocolError> {
        @native("modbus_rtu_read_holding", self.port, self.baud_rate, self.unit_id, address, count)
    }
    
    on write_single_register(address: UInt16, value: UInt16) -> Result<(), ProtocolError> {
        @native("modbus_rtu_write_register", self.port, self.baud_rate, self.unit_id, address, value)
    }
}

// -----------------------------------------------------------------------------
// BLE Protocol
// -----------------------------------------------------------------------------

/// BLE device
struct BleDevice {
    address: String
    name: Option<String>
    rssi: Int
    services: [BleService]
    
    fn new(address: String) -> Self {
        BleDevice { address: address, name: None, rssi: 0, services: [] }
    }
}

struct BleService {
    uuid: String
    characteristics: [BleCharacteristic]
}

struct BleCharacteristic {
    uuid: String
    properties: BleProperties
    value: [Byte]
}

struct BleProperties {
    read: Bool
    write: Bool
    notify: Bool
    indicate: Bool
}

/// BLE scanner
actor BleScanner {
    state scanning: Bool
    state devices: Map<String, BleDevice>
    
    fn new() -> Self { BleScanner { scanning: false, devices: Map.empty() } }
    
    on start_scan(duration_ms: Int64) -> Result<[BleDevice], ProtocolError> {
        self.scanning = true
        self.devices.clear()
        @native("ble_start_scan", duration_ms, |device| { self.devices.set(device.address, device) })?
        self.scanning = false
        Ok(self.devices.values().collect())
    }
    
    on stop_scan() { self.scanning = false; @native("ble_stop_scan") }
}

/// BLE client
actor BleClient {
    state device: Option<BleDevice>
    state connected: Bool
    
    fn new() -> Self { BleClient { device: None, connected: false } }
    
    on connect(address: String) -> Result<BleDevice, ProtocolError> {
        let device = @native("ble_connect", address)?
        self.device = Some(device)
        self.connected = true
        Ok(device)
    }
    
    on disconnect() -> Result<(), ProtocolError> {
        if let Some(device) = self.device {
            @native("ble_disconnect", device.address)?
        }
        self.device = None
        self.connected = false
        Ok(())
    }
    
    on read_characteristic(service_uuid: String, char_uuid: String) -> Result<[Byte], ProtocolError> {
        let device = self.device.as_ref().ok_or(ProtocolError.NotConnected)?
        @native("ble_read_char", device.address, service_uuid, char_uuid)
    }
    
    on write_characteristic(service_uuid: String, char_uuid: String, value: [Byte]) -> Result<(), ProtocolError> {
        let device = self.device.as_ref().ok_or(ProtocolError.NotConnected)?
        @native("ble_write_char", device.address, service_uuid, char_uuid, value)
    }
    
    on subscribe(service_uuid: String, char_uuid: String, handler: fn([Byte])) -> Result<(), ProtocolError> {
        let device = self.device.as_ref().ok_or(ProtocolError.NotConnected)?
        @native("ble_subscribe", device.address, service_uuid, char_uuid, handler)
    }
}

// -----------------------------------------------------------------------------
// Zigbee Protocol
// -----------------------------------------------------------------------------

struct ZigbeeDevice {
    ieee_address: String
    network_address: UInt16
    device_type: ZigbeeDeviceType
    endpoints: [ZigbeeEndpoint]
}

enum ZigbeeDeviceType { Coordinator, Router, EndDevice }

struct ZigbeeEndpoint {
    id: UInt8
    profile_id: UInt16
    clusters: [ZigbeeCluster]
}

struct ZigbeeCluster {
    id: UInt16
    attributes: Map<UInt16, ZigbeeAttribute>
}

struct ZigbeeAttribute {
    id: UInt16
    value: [Byte]
}

actor ZigbeeCoordinator {
    state devices: Map<String, ZigbeeDevice>
    state permit_join: Bool
    
    fn new() -> Self { ZigbeeCoordinator { devices: Map.empty(), permit_join: false } }
    
    on start() -> Result<(), ProtocolError> { @native("zigbee_start") }
    on stop() -> Result<(), ProtocolError> { @native("zigbee_stop") }
    
    on permit_joining(duration_sec: Int) -> Result<(), ProtocolError> {
        self.permit_join = true
        @native("zigbee_permit_join", duration_sec)
    }
    
    on get_devices() -> [ZigbeeDevice] { self.devices.values().collect() }
    
    on send_command(address: String, cluster_id: UInt16, command_id: UInt8, payload: [Byte]) -> Result<(), ProtocolError> {
        @native("zigbee_send_command", address, cluster_id, command_id, payload)
    }
    
    on read_attribute(address: String, cluster_id: UInt16, attr_id: UInt16) -> Result<[Byte], ProtocolError> {
        @native("zigbee_read_attribute", address, cluster_id, attr_id)
    }
}

// -----------------------------------------------------------------------------
// Z-Wave Protocol
// -----------------------------------------------------------------------------

struct ZwaveNode {
    node_id: UInt8
    device_class: ZwaveDeviceClass
    command_classes: [UInt8]
}

struct ZwaveDeviceClass {
    basic: UInt8
    generic: UInt8
    specific: UInt8
}

actor ZwaveController {
    state nodes: Map<UInt8, ZwaveNode>
    
    fn new() -> Self { ZwaveController { nodes: Map.empty() } }
    
    on start() -> Result<(), ProtocolError> { @native("zwave_start") }
    on stop() -> Result<(), ProtocolError> { @native("zwave_stop") }
    
    on add_node() -> Result<ZwaveNode, ProtocolError> { @native("zwave_add_node") }
    on remove_node(node_id: UInt8) -> Result<(), ProtocolError> { @native("zwave_remove_node", node_id) }
    
    on send_command(node_id: UInt8, command_class: UInt8, command: UInt8, params: [Byte]) -> Result<[Byte], ProtocolError> {
        @native("zwave_send_command", node_id, command_class, command, params)
    }
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum ProtocolError {
    NotConnected
    ConnectionFailed(String)
    Timeout
    DecodeError
    InvalidResponse
    DeviceNotFound
    Unauthorized
    
    fn to_string() -> String {
        match self {
            .NotConnected => "Not connected"
            .ConnectionFailed(msg) => "Connection failed: \(msg)"
            .Timeout => "Operation timeout"
            .DecodeError => "Decode error"
            .InvalidResponse => "Invalid response"
            .DeviceNotFound => "Device not found"
            .Unauthorized => "Unauthorized"
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "coap message creation" {
    let msg = CoapMessage.new(CoapMethod.Get, "/sensor/temperature")
    assert_eq(msg.method, CoapMethod.Get)?
    assert_eq(msg.uri, "/sensor/temperature")?
}

test "coap response codes" {
    assert_eq(CoapCode.Content.to_code(), (2, 5))?
    assert_eq(CoapCode.NotFound.to_code(), (4, 4))?
}

test "lwm2m object creation" {
    let mut obj = Lwm2mObject.new(3303)  // Temperature object
    let instance = obj.add_instance(0)
    instance.set_resource(5700, Lwm2mValue.Float(25.5))
    assert_eq(obj.instances.len(), 1)?
}

test "ble device creation" {
    let device = BleDevice.new("AA:BB:CC:DD:EE:FF")
    assert_eq(device.address, "AA:BB:CC:DD:EE:FF")?
}
