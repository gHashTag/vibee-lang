// =============================================================================
// Vibee OS â€” Session Module
// User session management with multiple storage backends
// =============================================================================

// =============================================================================
// Session Configuration
// =============================================================================

/// Session configuration
struct SessionConfig {
    name: String
    max_age: Int64
    path: String
    domain: Option<String>
    secure: Bool
    http_only: Bool
    same_site: SameSite
    id_generator: fn() -> String
}

impl SessionConfig {
    /// Create default configuration
    fn new() -> Self {
        SessionConfig {
            name: "session_id",
            max_age: 86400 * 7,  // 7 days
            path: "/",
            domain: None,
            secure: true,
            http_only: true,
            same_site: SameSite.Lax,
            id_generator: || uuid.v4()
        }
    }
    
    /// Set session cookie name
    fn name(n: String) -> Self {
        self.name = n
        self
    }
    
    /// Set max age in seconds
    fn max_age(seconds: Int64) -> Self {
        self.max_age = seconds
        self
    }
    
    /// Set cookie path
    fn path(p: String) -> Self {
        self.path = p
        self
    }
    
    /// Set cookie domain
    fn domain(d: String) -> Self {
        self.domain = Some(d)
        self
    }
    
    /// Set secure flag
    fn secure(s: Bool) -> Self {
        self.secure = s
        self
    }
    
    /// Set HTTP only flag
    fn http_only(h: Bool) -> Self {
        self.http_only = h
        self
    }
    
    /// Set SameSite policy
    fn same_site(s: SameSite) -> Self {
        self.same_site = s
        self
    }
    
    /// Set custom ID generator
    fn id_generator(gen: fn() -> String) -> Self {
        self.id_generator = gen
        self
    }
    
    /// Build cookie from session
    fn build_cookie(session_id: String) -> Cookie {
        var cookie = Cookie.new(self.name.clone(), session_id)
            .max_age(self.max_age)
            .path(self.path.clone())
            .secure(self.secure)
            .http_only(self.http_only)
            .same_site(self.same_site)
        
        if let Some(d) = self.domain {
            cookie = cookie.domain(d)
        }
        
        cookie
    }
    
    /// Build deletion cookie
    fn delete_cookie() -> Cookie {
        Cookie.new(self.name.clone(), "")
            .max_age(0)
            .path(self.path.clone())
    }
}

// =============================================================================
// Session Data
// =============================================================================

/// Session data container
struct Session {
    id: String
    data: Map<String, SessionValue>
    created_at: Int64
    accessed_at: Int64
    modified: Bool
    is_new: Bool
}

impl Session {
    /// Create new session
    fn new(id: String) -> Self {
        let now = @native("timestamp_ms") / 1000
        Session {
            id: id,
            data: Map.empty(),
            created_at: now,
            accessed_at: now,
            modified: false,
            is_new: true
        }
    }
    
    /// Get session ID
    fn id() -> String {
        self.id.clone()
    }
    
    /// Check if session is new
    fn is_new() -> Bool {
        self.is_new
    }
    
    /// Get value from session
    fn get<T: Deserialize>(key: String) -> Option<T> {
        self.data.get(key).and_then(|v| v.as::<T>())
    }
    
    /// Get value with default
    fn get_or<T: Deserialize>(key: String, default: T) -> T {
        self.get::<T>(key).unwrap_or(default)
    }
    
    /// Set value in session
    fn set<T: Serialize>(key: String, value: T) {
        self.data.set(key, SessionValue.from(value))
        self.modified = true
    }
    
    /// Remove value from session
    fn remove(key: String) -> Option<SessionValue> {
        self.modified = true
        self.data.remove(key)
    }
    
    /// Check if key exists
    fn contains(key: String) -> Bool {
        self.data.contains(key)
    }
    
    /// Get all keys
    fn keys() -> [String] {
        self.data.keys().collect()
    }
    
    /// Clear all session data
    fn clear() {
        self.data.clear()
        self.modified = true
    }
    
    /// Get session age in seconds
    fn age() -> Int64 {
        @native("timestamp_ms") / 1000 - self.created_at
    }
    
    /// Check if session was modified
    fn is_modified() -> Bool {
        self.modified
    }
    
    /// Flash message - get and remove
    fn flash(key: String) -> Option<String> {
        self.remove(key).and_then(|v| v.as::<String>())
    }
    
    /// Set flash message
    fn set_flash(key: String, message: String) {
        self.set(format!("_flash_{}", key), message)
    }
    
    /// Get flash message
    fn get_flash(key: String) -> Option<String> {
        self.flash(format!("_flash_{}", key))
    }
    
    /// Regenerate session ID
    fn regenerate(new_id: String) {
        self.id = new_id
        self.modified = true
    }
}

/// Session value wrapper
enum SessionValue {
    String(String)
    Int(Int64)
    Float(Float64)
    Bool(Bool)
    Array([SessionValue])
    Object(Map<String, SessionValue>)
    Null
}

impl SessionValue {
    fn from<T: Serialize>(value: T) -> Self {
        // Convert to JSON and back for type-safe storage
        let json_str = json.encode(value)
        match json.decode::<JsonValue>(json_str) {
            Ok(jv) => Self.from_json(jv),
            Err(_) => SessionValue.Null
        }
    }
    
    fn from_json(jv: JsonValue) -> Self {
        match jv {
            JsonValue.String(s) => SessionValue.String(s),
            JsonValue.Number(n) => {
                if n.fract() == 0.0 {
                    SessionValue.Int(n as Int64)
                } else {
                    SessionValue.Float(n)
                }
            }
            JsonValue.Bool(b) => SessionValue.Bool(b),
            JsonValue.Array(arr) => SessionValue.Array(arr.iter().map(|v| Self.from_json(v)).collect()),
            JsonValue.Object(obj) => SessionValue.Object(obj.iter().map(|(k, v)| (k, Self.from_json(v))).collect()),
            JsonValue.Null => SessionValue.Null
        }
    }
    
    fn as<T: Deserialize>() -> Option<T> {
        let json_str = self.to_json_string()
        json.decode::<T>(json_str).ok()
    }
    
    fn to_json_string() -> String {
        match self {
            String(s) => format!("\"{}\"", s.replace("\"", "\\\"")),
            Int(i) => i.to_string(),
            Float(f) => f.to_string(),
            Bool(b) => if b { "true" } else { "false" },
            Array(arr) => format!("[{}]", arr.iter().map(|v| v.to_json_string()).join(",")),
            Object(obj) => format!("{{{}}}", obj.iter().map(|(k, v)| format!("\"{}\":{}", k, v.to_json_string())).join(",")),
            Null => "null"
        }
    }
}

// =============================================================================
// Session Store Trait
// =============================================================================

/// Session storage backend trait
trait SessionStore {
    /// Load session by ID
    fn load(id: String) -> Option<Session>
    
    /// Save session
    fn save(session: Session) -> Result<(), SessionError>
    
    /// Delete session
    fn delete(id: String) -> Result<(), SessionError>
    
    /// Check if session exists
    fn exists(id: String) -> Bool
    
    /// Clean up expired sessions
    fn cleanup() -> Result<Int, SessionError>
}

// =============================================================================
// Memory Store
// =============================================================================

/// In-memory session store (for development/testing)
actor MemorySessionStore {
    state sessions: Map<String, StoredSession>
    state max_age: Int64
    
    fn new() -> Self {
        MemorySessionStore {
            sessions: Map.empty(),
            max_age: 86400 * 7
        }
    }
    
    fn with_max_age(max_age: Int64) -> Self {
        MemorySessionStore {
            sessions: Map.empty(),
            max_age: max_age
        }
    }
}

impl SessionStore for MemorySessionStore {
    fn load(id: String) -> Option<Session> {
        let stored = self.sessions.get(id)?
        let now = @native("timestamp_ms") / 1000
        
        // Check expiration
        if now > stored.expires_at {
            self.sessions.remove(id)
            return None
        }
        
        var session = Session {
            id: id,
            data: stored.data.clone(),
            created_at: stored.created_at,
            accessed_at: now,
            modified: false,
            is_new: false
        }
        
        Some(session)
    }
    
    fn save(session: Session) -> Result<(), SessionError> {
        let now = @native("timestamp_ms") / 1000
        self.sessions.set(session.id.clone(), StoredSession {
            data: session.data.clone(),
            created_at: session.created_at,
            expires_at: now + self.max_age
        })
        Ok(())
    }
    
    fn delete(id: String) -> Result<(), SessionError> {
        self.sessions.remove(id)
        Ok(())
    }
    
    fn exists(id: String) -> Bool {
        self.sessions.contains(id)
    }
    
    fn cleanup() -> Result<Int, SessionError> {
        let now = @native("timestamp_ms") / 1000
        let expired: [String] = self.sessions.iter()
            .filter(|(_, s)| now > s.expires_at)
            .map(|(k, _)| k.clone())
            .collect()
        
        let count = expired.len()
        for id in expired {
            self.sessions.remove(id)
        }
        
        Ok(count)
    }
}

struct StoredSession {
    data: Map<String, SessionValue>
    created_at: Int64
    expires_at: Int64
}

// =============================================================================
// Redis Store
// =============================================================================

/// Redis-backed session store
struct RedisSessionStore {
    client: redis.RedisConnection
    prefix: String
    max_age: Int64
}

impl RedisSessionStore {
    fn new(client: redis.RedisConnection) -> Self {
        RedisSessionStore {
            client: client,
            prefix: "session:",
            max_age: 86400 * 7
        }
    }
    
    fn prefix(p: String) -> Self {
        self.prefix = p
        self
    }
    
    fn max_age(seconds: Int64) -> Self {
        self.max_age = seconds
        self
    }
    
    fn key(id: String) -> String {
        format!("{}{}", self.prefix, id)
    }
}

impl SessionStore for RedisSessionStore {
    fn load(id: String) -> Option<Session> {
        let key = self.key(id.clone())
        let data = self.client.get(key).ok()??
        
        let stored: StoredSession = json.decode(data).ok()?
        let now = @native("timestamp_ms") / 1000
        
        Some(Session {
            id: id,
            data: stored.data,
            created_at: stored.created_at,
            accessed_at: now,
            modified: false,
            is_new: false
        })
    }
    
    fn save(session: Session) -> Result<(), SessionError> {
        let key = self.key(session.id.clone())
        let now = @native("timestamp_ms") / 1000
        
        let stored = StoredSession {
            data: session.data.clone(),
            created_at: session.created_at,
            expires_at: now + self.max_age
        }
        
        let data = json.encode(stored)
        self.client.setex(key, self.max_age as Int, data)
            .map_err(|e| SessionError.StoreError(e.to_string()))?
        
        Ok(())
    }
    
    fn delete(id: String) -> Result<(), SessionError> {
        let key = self.key(id)
        self.client.del(key)
            .map_err(|e| SessionError.StoreError(e.to_string()))?
        Ok(())
    }
    
    fn exists(id: String) -> Bool {
        let key = self.key(id)
        self.client.exists(key).unwrap_or(false)
    }
    
    fn cleanup() -> Result<Int, SessionError> {
        // Redis handles expiration automatically
        Ok(0)
    }
}

// =============================================================================
// File Store
// =============================================================================

/// File-based session store
struct FileSessionStore {
    directory: String
    max_age: Int64
}

impl FileSessionStore {
    fn new(directory: String) -> Self {
        // Ensure directory exists
        fs.create_dir_all(directory.clone()).ok()
        
        FileSessionStore {
            directory: directory,
            max_age: 86400 * 7
        }
    }
    
    fn max_age(seconds: Int64) -> Self {
        self.max_age = seconds
        self
    }
    
    fn path(id: String) -> String {
        // Sanitize ID to prevent directory traversal
        let safe_id = id.chars().filter(|c| c.is_alphanumeric() || c == '-').collect::<String>()
        path.join(self.directory.clone(), format!("{}.session", safe_id))
    }
}

impl SessionStore for FileSessionStore {
    fn load(id: String) -> Option<Session> {
        let file_path = self.path(id.clone())
        let data = fs.read_string(file_path).ok()?
        
        let stored: StoredSession = json.decode(data).ok()?
        let now = @native("timestamp_ms") / 1000
        
        if now > stored.expires_at {
            fs.remove(self.path(id)).ok()
            return None
        }
        
        Some(Session {
            id: id,
            data: stored.data,
            created_at: stored.created_at,
            accessed_at: now,
            modified: false,
            is_new: false
        })
    }
    
    fn save(session: Session) -> Result<(), SessionError> {
        let file_path = self.path(session.id.clone())
        let now = @native("timestamp_ms") / 1000
        
        let stored = StoredSession {
            data: session.data.clone(),
            created_at: session.created_at,
            expires_at: now + self.max_age
        }
        
        let data = json.encode(stored)
        fs.write_string(file_path, data)
            .map_err(|e| SessionError.StoreError(e.to_string()))?
        
        Ok(())
    }
    
    fn delete(id: String) -> Result<(), SessionError> {
        let file_path = self.path(id)
        fs.remove(file_path).ok()
        Ok(())
    }
    
    fn exists(id: String) -> Bool {
        let file_path = self.path(id)
        fs.exists(file_path)
    }
    
    fn cleanup() -> Result<Int, SessionError> {
        let now = @native("timestamp_ms") / 1000
        var count = 0
        
        for entry in fs.read_dir(self.directory.clone()).unwrap_or([]) {
            if !entry.name.ends_with(".session") { continue }
            
            let file_path = path.join(self.directory.clone(), entry.name)
            if let Ok(data) = fs.read_string(file_path.clone()) {
                if let Ok(stored) = json.decode::<StoredSession>(data) {
                    if now > stored.expires_at {
                        fs.remove(file_path).ok()
                        count += 1
                    }
                }
            }
        }
        
        Ok(count)
    }
}

// =============================================================================
// Session Manager
// =============================================================================

/// Session manager for handling session lifecycle
struct SessionManager<S: SessionStore> {
    store: S
    config: SessionConfig
}

impl<S: SessionStore> SessionManager<S> {
    fn new(store: S) -> Self {
        SessionManager {
            store: store,
            config: SessionConfig.new()
        }
    }
    
    fn config(cfg: SessionConfig) -> Self {
        self.config = cfg
        self
    }
    
    /// Get or create session from request
    fn get_session(req: http.Request) -> Session {
        // Try to get session ID from cookie
        let session_id = Cookie.parse_all(req.headers.get("Cookie").unwrap_or(""))
            .iter()
            .find(|c| c.name == self.config.name)
            .map(|c| c.value.clone());
        
        match session_id {
            Some(id) => {
                // Try to load existing session
                match self.store.load(id.clone()) {
                    Some(session) => session,
                    None => {
                        // Session expired or invalid, create new
                        let new_id = (self.config.id_generator)()
                        Session.new(new_id)
                    }
                }
            }
            None => {
                // No session cookie, create new session
                let new_id = (self.config.id_generator)()
                Session.new(new_id)
            }
        }
    }
    
    /// Save session and get response cookie
    fn save_session(session: Session) -> Result<Cookie, SessionError> {
        if session.is_modified() || session.is_new() {
            self.store.save(session.clone())?
        }
        Ok(self.config.build_cookie(session.id()))
    }
    
    /// Destroy session
    fn destroy_session(session: Session) -> Result<Cookie, SessionError> {
        self.store.delete(session.id())?
        Ok(self.config.delete_cookie())
    }
    
    /// Regenerate session ID (for security after login)
    fn regenerate(session: Session) -> Session {
        let new_id = (self.config.id_generator)()
        let old_id = session.id()
        
        // Delete old session
        self.store.delete(old_id).ok()
        
        // Update session with new ID
        session.regenerate(new_id)
        session
    }
    
    /// Create middleware
    fn middleware() -> fn(Context, fn(Context) -> Response) -> Response {
        let manager = self.clone()
        
        |ctx, next| {
            // Load session
            let session = manager.get_session(ctx.request.clone())
            ctx.set("session", session.clone())
            
            // Process request
            var response = next(ctx)
            
            // Get potentially modified session
            let session = ctx.get::<Session>("session").unwrap_or(session)
            
            // Save session and set cookie
            match manager.save_session(session) {
                Ok(cookie) => response.with_cookie(cookie),
                Err(_) => response
            }
        }
    }
}

// =============================================================================
// Session Middleware Helper
// =============================================================================

/// Create session middleware with memory store
fn memory_sessions() -> fn(Context, fn(Context) -> Response) -> Response {
    SessionManager.new(MemorySessionStore.new()).middleware()
}

/// Create session middleware with Redis store
fn redis_sessions(client: redis.RedisConnection) -> fn(Context, fn(Context) -> Response) -> Response {
    SessionManager.new(RedisSessionStore.new(client)).middleware()
}

/// Create session middleware with file store
fn file_sessions(directory: String) -> fn(Context, fn(Context) -> Response) -> Response {
    SessionManager.new(FileSessionStore.new(directory)).middleware()
}

// =============================================================================
// Context Extensions
// =============================================================================

/// Extension methods for Context to work with sessions
impl Context {
    /// Get session from context
    fn session() -> Option<Session> {
        self.get::<Session>("session")
    }
    
    /// Get session value
    fn session_get<T: Deserialize>(key: String) -> Option<T> {
        self.session()?.get::<T>(key)
    }
    
    /// Set session value
    fn session_set<T: Serialize>(key: String, value: T) {
        if let Some(session) = self.get::<Session>("session") {
            session.set(key, value)
            self.set("session", session)
        }
    }
    
    /// Get flash message
    fn flash(key: String) -> Option<String> {
        self.session()?.get_flash(key)
    }
    
    /// Set flash message
    fn set_flash(key: String, message: String) {
        if let Some(session) = self.get::<Session>("session") {
            session.set_flash(key, message)
            self.set("session", session)
        }
    }
}

// =============================================================================
// Errors
// =============================================================================

enum SessionError {
    NotFound
    Expired
    StoreError(String)
    SerializationError(String)
}

impl Display for SessionError {
    fn fmt(f: Formatter) {
        match self {
            NotFound => f.write("Session not found"),
            Expired => f.write("Session expired"),
            StoreError(s) => f.write(format!("Store error: {}", s)),
            SerializationError(s) => f.write(format!("Serialization error: {}", s))
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "session creation" {
    let session = Session.new("test-id-123")
    assert(session.is_new())?
    assert_eq(session.id(), "test-id-123")?
    assert(session.keys().is_empty())?
}

test "session data" {
    let session = Session.new("test")
    
    session.set("name", "Alice")
    session.set("age", 30)
    session.set("active", true)
    
    assert_eq(session.get::<String>("name"), Some("Alice"))?
    assert_eq(session.get::<Int>("age"), Some(30))?
    assert_eq(session.get::<Bool>("active"), Some(true))?
    assert(session.is_modified())?
}

test "session flash" {
    let session = Session.new("test")
    
    session.set_flash("success", "Operation completed")
    
    // First read returns value
    assert_eq(session.get_flash("success"), Some("Operation completed"))?
    
    // Second read returns None (flash is consumed)
    assert_eq(session.get_flash("success"), None)?
}

test "memory store" {
    let store = MemorySessionStore.new()
    
    // Create and save session
    let session = Session.new("mem-test")
    session.set("key", "value")
    store.save(session)?
    
    // Load session
    let loaded = store.load("mem-test")?
    assert_eq(loaded.get::<String>("key"), Some("value"))?
    
    // Delete session
    store.delete("mem-test")?
    assert(store.load("mem-test").is_none())?
}

test "session config" {
    let config = SessionConfig.new()
        .name("my_session")
        .max_age(3600)
        .secure(true)
        .http_only(true)
        .same_site(SameSite.Strict)
    
    let cookie = config.build_cookie("session-123")
    assert_eq(cookie.name, "my_session")?
    assert_eq(cookie.value, "session-123")?
    assert(cookie.secure)?
    assert(cookie.http_only)?
}

test "session value serialization" {
    let sv = SessionValue.from("hello")
    assert_eq(sv.as::<String>(), Some("hello"))?
    
    let sv_int = SessionValue.from(42)
    assert_eq(sv_int.as::<Int>(), Some(42))?
    
    let sv_bool = SessionValue.from(true)
    assert_eq(sv_bool.as::<Bool>(), Some(true))?
}
