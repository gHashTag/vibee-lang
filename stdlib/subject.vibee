// =============================================================================
// Vibee OS â€” Subject Module
// Reactive subjects - both Observable and Observer
// =============================================================================

use observable::{Observable, Observer, Subscription, observer, next_observer}

/// Subject trait - acts as both Observable and Observer
trait Subject<T>: Observable<Item = T> + Observer<T> {
    fn as_observable() -> impl Observable<Item = T>
}

/// Basic Subject - multicast to multiple observers
actor PublishSubject<T> {
    state observers: [impl Observer<T>]
    state completed: Bool
    state error: Option<Error>
    
    fn new() -> Self {
        PublishSubject {
            observers: [],
            completed: false,
            error: None
        }
    }
}

impl<T: Clone> Observer<T> for PublishSubject<T> {
    fn on_next(value: T) {
        if self.completed || self.error.is_some() { return }
        for obs in self.observers.iter() {
            obs.on_next(value.clone())
        }
    }
    
    fn on_error(err: Error) {
        if self.completed || self.error.is_some() { return }
        self.error = Some(err)
        for obs in self.observers.iter() {
            obs.on_error(err)
        }
        self.observers.clear()
    }
    
    fn on_complete() {
        if self.completed || self.error.is_some() { return }
        self.completed = true
        for obs in self.observers.iter() {
            obs.on_complete()
        }
        self.observers.clear()
    }
}

impl<T: Clone> Observable for PublishSubject<T> {
    type Item = T
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        if self.completed {
            observer.on_complete()
            return Subscription.empty()
        }
        if let Some(err) = self.error {
            observer.on_error(err)
            return Subscription.empty()
        }
        
        self.observers.push(observer)
        let idx = self.observers.len() - 1
        
        Subscription.new(|| {
            if idx < self.observers.len() {
                self.observers.remove(idx)
            }
        })
    }
}

impl<T: Clone> Subject<T> for PublishSubject<T> {
    fn as_observable() -> impl Observable<Item = T> { self }
}

impl<T: Clone> PublishSubject<T> {
    fn next(value: T) { self.on_next(value) }
    fn error(err: Error) { self.on_error(err) }
    fn complete() { self.on_complete() }
    fn observer_count() -> Int { self.observers.len() }
    fn is_completed() -> Bool { self.completed }
    fn has_error() -> Bool { self.error.is_some() }
}

/// BehaviorSubject - emits current value to new subscribers
actor BehaviorSubject<T: Clone> {
    state current: T
    state observers: [impl Observer<T>]
    state completed: Bool
    state error: Option<Error>
    
    fn new(initial: T) -> Self {
        BehaviorSubject {
            current: initial,
            observers: [],
            completed: false,
            error: None
        }
    }
    
    fn value() -> T { self.current.clone() }
}

impl<T: Clone> Observer<T> for BehaviorSubject<T> {
    fn on_next(value: T) {
        if self.completed || self.error.is_some() { return }
        self.current = value.clone()
        for obs in self.observers.iter() {
            obs.on_next(value.clone())
        }
    }
    
    fn on_error(err: Error) {
        if self.completed || self.error.is_some() { return }
        self.error = Some(err)
        for obs in self.observers.iter() {
            obs.on_error(err)
        }
        self.observers.clear()
    }
    
    fn on_complete() {
        if self.completed || self.error.is_some() { return }
        self.completed = true
        for obs in self.observers.iter() {
            obs.on_complete()
        }
        self.observers.clear()
    }
}

impl<T: Clone> Observable for BehaviorSubject<T> {
    type Item = T
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        if let Some(err) = self.error {
            observer.on_error(err)
            return Subscription.empty()
        }
        
        // Emit current value immediately
        observer.on_next(self.current.clone())
        
        if self.completed {
            observer.on_complete()
            return Subscription.empty()
        }
        
        self.observers.push(observer)
        let idx = self.observers.len() - 1
        
        Subscription.new(|| {
            if idx < self.observers.len() {
                self.observers.remove(idx)
            }
        })
    }
}

impl<T: Clone> Subject<T> for BehaviorSubject<T> {
    fn as_observable() -> impl Observable<Item = T> { self }
}

impl<T: Clone> BehaviorSubject<T> {
    fn next(value: T) { self.on_next(value) }
    fn error(err: Error) { self.on_error(err) }
    fn complete() { self.on_complete() }
    fn get_value() -> T { self.current.clone() }
}

/// ReplaySubject - replays buffered values to new subscribers
actor ReplaySubject<T: Clone> {
    state buffer: [T]
    state buffer_size: Int
    state observers: [impl Observer<T>]
    state completed: Bool
    state error: Option<Error>
    
    fn new(buffer_size: Int) -> Self {
        ReplaySubject {
            buffer: [],
            buffer_size: buffer_size,
            observers: [],
            completed: false,
            error: None
        }
    }
    
    /// Create unbounded replay subject
    fn unbounded() -> Self {
        Self.new(Int.MAX)
    }
}

impl<T: Clone> Observer<T> for ReplaySubject<T> {
    fn on_next(value: T) {
        if self.completed || self.error.is_some() { return }
        
        // Add to buffer
        self.buffer.push(value.clone())
        if self.buffer.len() > self.buffer_size {
            self.buffer.remove(0)
        }
        
        for obs in self.observers.iter() {
            obs.on_next(value.clone())
        }
    }
    
    fn on_error(err: Error) {
        if self.completed || self.error.is_some() { return }
        self.error = Some(err)
        for obs in self.observers.iter() {
            obs.on_error(err)
        }
        self.observers.clear()
    }
    
    fn on_complete() {
        if self.completed || self.error.is_some() { return }
        self.completed = true
        for obs in self.observers.iter() {
            obs.on_complete()
        }
        self.observers.clear()
    }
}

impl<T: Clone> Observable for ReplaySubject<T> {
    type Item = T
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        // Replay buffered values
        for value in self.buffer.iter() {
            observer.on_next(value.clone())
        }
        
        if let Some(err) = self.error {
            observer.on_error(err)
            return Subscription.empty()
        }
        
        if self.completed {
            observer.on_complete()
            return Subscription.empty()
        }
        
        self.observers.push(observer)
        let idx = self.observers.len() - 1
        
        Subscription.new(|| {
            if idx < self.observers.len() {
                self.observers.remove(idx)
            }
        })
    }
}

impl<T: Clone> Subject<T> for ReplaySubject<T> {
    fn as_observable() -> impl Observable<Item = T> { self }
}

impl<T: Clone> ReplaySubject<T> {
    fn next(value: T) { self.on_next(value) }
    fn error(err: Error) { self.on_error(err) }
    fn complete() { self.on_complete() }
    fn get_buffer() -> [T] { self.buffer.clone() }
}

/// AsyncSubject - emits only last value on complete
actor AsyncSubject<T: Clone> {
    state last_value: Option<T>
    state observers: [impl Observer<T>]
    state completed: Bool
    state error: Option<Error>
    
    fn new() -> Self {
        AsyncSubject {
            last_value: None,
            observers: [],
            completed: false,
            error: None
        }
    }
}

impl<T: Clone> Observer<T> for AsyncSubject<T> {
    fn on_next(value: T) {
        if self.completed || self.error.is_some() { return }
        self.last_value = Some(value)
    }
    
    fn on_error(err: Error) {
        if self.completed || self.error.is_some() { return }
        self.error = Some(err)
        for obs in self.observers.iter() {
            obs.on_error(err)
        }
        self.observers.clear()
    }
    
    fn on_complete() {
        if self.completed || self.error.is_some() { return }
        self.completed = true
        
        if let Some(value) = self.last_value.clone() {
            for obs in self.observers.iter() {
                obs.on_next(value.clone())
            }
        }
        
        for obs in self.observers.iter() {
            obs.on_complete()
        }
        self.observers.clear()
    }
}

impl<T: Clone> Observable for AsyncSubject<T> {
    type Item = T
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        if let Some(err) = self.error {
            observer.on_error(err)
            return Subscription.empty()
        }
        
        if self.completed {
            if let Some(value) = self.last_value.clone() {
                observer.on_next(value)
            }
            observer.on_complete()
            return Subscription.empty()
        }
        
        self.observers.push(observer)
        let idx = self.observers.len() - 1
        
        Subscription.new(|| {
            if idx < self.observers.len() {
                self.observers.remove(idx)
            }
        })
    }
}

impl<T: Clone> Subject<T> for AsyncSubject<T> {
    fn as_observable() -> impl Observable<Item = T> { self }
}

impl<T: Clone> AsyncSubject<T> {
    fn next(value: T) { self.on_next(value) }
    fn error(err: Error) { self.on_error(err) }
    fn complete() { self.on_complete() }
}

/// UnicastSubject - single subscriber only
actor UnicastSubject<T> {
    state observer: Option<impl Observer<T>>
    state buffer: [T]
    state completed: Bool
    state error: Option<Error>
    
    fn new() -> Self {
        UnicastSubject {
            observer: None,
            buffer: [],
            completed: false,
            error: None
        }
    }
}

impl<T: Clone> Observer<T> for UnicastSubject<T> {
    fn on_next(value: T) {
        if self.completed || self.error.is_some() { return }
        
        match self.observer {
            Some(ref obs) => obs.on_next(value),
            None => self.buffer.push(value)
        }
    }
    
    fn on_error(err: Error) {
        if self.completed || self.error.is_some() { return }
        self.error = Some(err)
        if let Some(ref obs) = self.observer {
            obs.on_error(err)
        }
    }
    
    fn on_complete() {
        if self.completed || self.error.is_some() { return }
        self.completed = true
        if let Some(ref obs) = self.observer {
            obs.on_complete()
        }
    }
}

impl<T: Clone> Observable for UnicastSubject<T> {
    type Item = T
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        if self.observer.is_some() {
            observer.on_error(Error.new("UnicastSubject already has subscriber"))
            return Subscription.empty()
        }
        
        // Flush buffer
        for value in self.buffer.drain(..) {
            observer.on_next(value)
        }
        
        if let Some(err) = self.error {
            observer.on_error(err)
            return Subscription.empty()
        }
        
        if self.completed {
            observer.on_complete()
            return Subscription.empty()
        }
        
        self.observer = Some(observer)
        
        Subscription.new(|| {
            self.observer = None
        })
    }
}

/// Signal - like BehaviorSubject but distinct values only
actor Signal<T: Clone + Eq> {
    state current: T
    state observers: [impl Observer<T>]
    state completed: Bool
    
    fn new(initial: T) -> Self {
        Signal {
            current: initial,
            observers: [],
            completed: false
        }
    }
    
    fn value() -> T { self.current.clone() }
    
    fn set(value: T) {
        if self.completed { return }
        if self.current == value { return }  // Distinct only
        
        self.current = value.clone()
        for obs in self.observers.iter() {
            obs.on_next(value.clone())
        }
    }
}

impl<T: Clone + Eq> Observable for Signal<T> {
    type Item = T
    
    fn subscribe(observer: impl Observer<T>) -> Subscription {
        observer.on_next(self.current.clone())
        
        if self.completed {
            observer.on_complete()
            return Subscription.empty()
        }
        
        self.observers.push(observer)
        let idx = self.observers.len() - 1
        
        Subscription.new(|| {
            if idx < self.observers.len() {
                self.observers.remove(idx)
            }
        })
    }
}

/// Variable - mutable reactive value (alias for BehaviorSubject)
struct Variable<T: Clone> {
    subject: BehaviorSubject<T>
}

impl<T: Clone> Variable<T> {
    fn new(initial: T) -> Self {
        Variable { subject: BehaviorSubject.new(initial) }
    }
    
    fn get() -> T { self.subject.value() }
    fn set(value: T) { self.subject.next(value) }
    
    fn as_observable() -> impl Observable<Item = T> {
        self.subject.as_observable()
    }
    
    fn update(f: fn(T) -> T) {
        self.set(f(self.get()))
    }
}

// Tests
test "publish subject" {
    let subject = PublishSubject::<Int>.new()
    var result = []
    
    subject.subscribe(next_observer(|v| result.push(v)))
    subject.next(1)
    subject.next(2)
    subject.next(3)
    
    assert_eq(result, [1, 2, 3])?
}

test "behavior subject initial value" {
    let subject = BehaviorSubject.new(42)
    var result = []
    
    subject.subscribe(next_observer(|v| result.push(v)))
    
    assert_eq(result, [42])?  // Gets initial value immediately
}

test "behavior subject updates" {
    let subject = BehaviorSubject.new(0)
    var result = []
    
    subject.next(1)
    subject.next(2)
    subject.subscribe(next_observer(|v| result.push(v)))
    subject.next(3)
    
    assert_eq(result, [2, 3])?  // Gets current value (2) then new value (3)
}

test "replay subject" {
    let subject = ReplaySubject::<Int>.new(2)
    
    subject.next(1)
    subject.next(2)
    subject.next(3)
    
    var result = []
    subject.subscribe(next_observer(|v| result.push(v)))
    
    assert_eq(result, [2, 3])?  // Replays last 2 values
}

test "async subject" {
    let subject = AsyncSubject::<Int>.new()
    var result = []
    
    subject.subscribe(next_observer(|v| result.push(v)))
    subject.next(1)
    subject.next(2)
    subject.next(3)
    
    assert_eq(result, [])?  // Nothing emitted yet
    
    subject.complete()
    assert_eq(result, [3])?  // Only last value on complete
}

test "signal distinct" {
    let signal = Signal.new(0)
    var result = []
    
    signal.subscribe(next_observer(|v| result.push(v)))
    signal.set(1)
    signal.set(1)  // Duplicate, ignored
    signal.set(2)
    
    assert_eq(result, [0, 1, 2])?
}

test "variable" {
    let var_x = Variable.new(10)
    
    assert_eq(var_x.get(), 10)?
    var_x.set(20)
    assert_eq(var_x.get(), 20)?
    
    var_x.update(|x| x * 2)
    assert_eq(var_x.get(), 40)?
}
