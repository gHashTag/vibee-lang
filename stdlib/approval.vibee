// =============================================================================
// Vibee OS â€” Approval Module
// Approval workflows and human-in-the-loop processes
// =============================================================================

use result::{Result, Ok, Err}
use datetime::{DateTime, Duration}

// =============================================================================
// Approval Status
// =============================================================================

enum ApprovalStatus {
    Pending
    Approved
    Rejected
    Expired
    Cancelled
    Escalated
    
    fn is_terminal() -> Bool {
        match self {
            Approved | Rejected | Expired | Cancelled => true
            _ => false
        }
    }
    
    fn is_approved() -> Bool {
        matches!(self, Approved)
    }
}

// =============================================================================
// Approval Request
// =============================================================================

struct ApprovalRequest {
    id: String
    workflow_id: String
    step_id: String
    title: String
    description: String
    requester: String
    approvers: [String]
    status: ApprovalStatus
    created_at: DateTime
    expires_at: Option<DateTime>
    decided_at: Option<DateTime>
    decided_by: Option<String>
    decision_comment: Option<String>
    metadata: Map<String, Any>
    
    fn new(workflow_id: String, step_id: String, title: String) -> Self {
        ApprovalRequest {
            id: UUID.v4(),
            workflow_id: workflow_id,
            step_id: step_id,
            title: title,
            description: "",
            requester: "",
            approvers: [],
            status: ApprovalStatus.Pending,
            created_at: DateTime.now(),
            expires_at: None,
            decided_at: None,
            decided_by: None,
            decision_comment: None,
            metadata: Map.empty()
        }
    }
    
    fn with_description(desc: String) -> Self {
        self.description = desc
        self
    }
    
    fn with_requester(requester: String) -> Self {
        self.requester = requester
        self
    }
    
    fn with_approvers(approvers: [String]) -> Self {
        self.approvers = approvers
        self
    }
    
    fn with_expiry(duration: Duration) -> Self {
        self.expires_at = Some(DateTime.now() + duration)
        self
    }
    
    fn with_metadata(key: String, value: Any) -> Self {
        self.metadata.set(key, value)
        self
    }
    
    fn is_expired() -> Bool {
        match self.expires_at {
            Some(exp) => DateTime.now() > exp
            None => false
        }
    }
    
    fn can_approve(user: String) -> Bool {
        self.status == ApprovalStatus.Pending && 
        !self.is_expired() &&
        self.approvers.contains(user)
    }
    
    fn approve(user: String, comment: Option<String>) -> Result<(), ApprovalError> {
        if !self.can_approve(user.clone()) {
            return Err(ApprovalError.NotAuthorized)
        }
        
        self.status = ApprovalStatus.Approved
        self.decided_at = Some(DateTime.now())
        self.decided_by = Some(user)
        self.decision_comment = comment
        Ok(())
    }
    
    fn reject(user: String, comment: Option<String>) -> Result<(), ApprovalError> {
        if !self.can_approve(user.clone()) {
            return Err(ApprovalError.NotAuthorized)
        }
        
        self.status = ApprovalStatus.Rejected
        self.decided_at = Some(DateTime.now())
        self.decided_by = Some(user)
        self.decision_comment = comment
        Ok(())
    }
    
    fn cancel(reason: String) {
        self.status = ApprovalStatus.Cancelled
        self.decided_at = Some(DateTime.now())
        self.decision_comment = Some(reason)
    }
    
    fn escalate(new_approvers: [String]) {
        self.status = ApprovalStatus.Escalated
        self.approvers = new_approvers
    }
}

// =============================================================================
// Approval Policy
// =============================================================================

enum ApprovalPolicy {
    AnyOne                          // Any single approver
    All                             // All approvers must approve
    Majority                        // More than 50%
    Quorum(Int)                     // Specific number required
    Sequential([String])            // Approvers in order
    Hierarchical(ApprovalHierarchy) // Based on hierarchy
    
    fn required_approvals(total_approvers: Int) -> Int {
        match self {
            AnyOne => 1
            All => total_approvers
            Majority => (total_approvers / 2) + 1
            Quorum(n) => n.min(total_approvers)
            Sequential(_) => 1
            Hierarchical(_) => 1
        }
    }
}

struct ApprovalHierarchy {
    levels: [ApprovalLevel]
    
    fn new() -> Self {
        ApprovalHierarchy { levels: [] }
    }
    
    fn add_level(level: ApprovalLevel) -> Self {
        self.levels.push(level)
        self
    }
    
    fn get_approvers_for_amount(amount: Float) -> [String] {
        for level in self.levels.iter().rev() {
            if amount >= level.threshold {
                return level.approvers.clone()
            }
        }
        self.levels.first().map(|l| l.approvers.clone()).unwrap_or([])
    }
}

struct ApprovalLevel {
    name: String
    threshold: Float
    approvers: [String]
    
    fn new(name: String, threshold: Float, approvers: [String]) -> Self {
        ApprovalLevel { name: name, threshold: threshold, approvers: approvers }
    }
}

// =============================================================================
// Approval Chain
// =============================================================================

struct ApprovalChain {
    id: String
    request: ApprovalRequest
    policy: ApprovalPolicy
    decisions: [ApprovalDecision]
    current_step: Int
    
    fn new(request: ApprovalRequest, policy: ApprovalPolicy) -> Self {
        ApprovalChain {
            id: UUID.v4(),
            request: request,
            policy: policy,
            decisions: [],
            current_step: 0
        }
    }
    
    fn add_decision(decision: ApprovalDecision) {
        self.decisions.push(decision)
        
        if let ApprovalPolicy.Sequential(_) = self.policy {
            self.current_step += 1
        }
    }
    
    fn is_complete() -> Bool {
        let required = self.policy.required_approvals(self.request.approvers.len())
        let approved = self.decisions.iter().filter(|d| d.approved).count()
        let rejected = self.decisions.iter().filter(|d| !d.approved).count()
        
        match self.policy {
            ApprovalPolicy.All => {
                approved == self.request.approvers.len() || rejected > 0
            }
            ApprovalPolicy.Sequential(approvers) => {
                self.current_step >= approvers.len() || rejected > 0
            }
            _ => approved >= required || rejected > 0
        }
    }
    
    fn is_approved() -> Bool {
        if !self.is_complete() { return false }
        
        let required = self.policy.required_approvals(self.request.approvers.len())
        let approved = self.decisions.iter().filter(|d| d.approved).count()
        
        match self.policy {
            ApprovalPolicy.All => {
                approved == self.request.approvers.len()
            }
            _ => approved >= required
        }
    }
    
    fn current_approvers() -> [String] {
        match self.policy {
            ApprovalPolicy.Sequential(approvers) => {
                if self.current_step < approvers.len() {
                    [approvers[self.current_step].clone()]
                } else {
                    []
                }
            }
            _ => {
                let decided: Set<String> = self.decisions.iter()
                    .map(|d| d.approver.clone())
                    .collect()
                self.request.approvers.iter()
                    .filter(|a| !decided.contains(a))
                    .cloned()
                    .collect()
            }
        }
    }
}

struct ApprovalDecision {
    approver: String
    approved: Bool
    comment: Option<String>
    timestamp: DateTime
    
    fn approve(approver: String, comment: Option<String>) -> Self {
        ApprovalDecision {
            approver: approver,
            approved: true,
            comment: comment,
            timestamp: DateTime.now()
        }
    }
    
    fn reject(approver: String, comment: Option<String>) -> Self {
        ApprovalDecision {
            approver: approver,
            approved: false,
            comment: comment,
            timestamp: DateTime.now()
        }
    }
}

// =============================================================================
// Approval Manager
// =============================================================================

actor ApprovalManager {
    state requests: Map<String, ApprovalRequest>
    state chains: Map<String, ApprovalChain>
    state by_workflow: Map<String, [String]>
    state by_approver: Map<String, [String]>
    state notifications: Option<fn(ApprovalNotification)>
    
    fn new() -> Self {
        ApprovalManager {
            requests: Map.empty(),
            chains: Map.empty(),
            by_workflow: Map.empty(),
            by_approver: Map.empty(),
            notifications: None
        }
    }
    
    fn with_notifications(handler: fn(ApprovalNotification)) -> Self {
        self.notifications = Some(handler)
        self
    }
    
    fn create_request(request: ApprovalRequest) -> String {
        let id = request.id.clone()
        let workflow_id = request.workflow_id.clone()
        
        for approver in request.approvers.iter() {
            let list = self.by_approver.entry(approver.clone()).or_insert([])
            list.push(id.clone())
        }
        
        let wf_list = self.by_workflow.entry(workflow_id).or_insert([])
        wf_list.push(id.clone())
        
        self.requests.set(id.clone(), request.clone())
        
        self.notify(ApprovalNotification.RequestCreated(request))
        
        id
    }
    
    fn create_chain(request: ApprovalRequest, policy: ApprovalPolicy) -> String {
        let request_id = self.create_request(request.clone())
        let chain = ApprovalChain.new(request, policy)
        let chain_id = chain.id.clone()
        self.chains.set(chain_id.clone(), chain)
        chain_id
    }
    
    fn approve(request_id: String, user: String, comment: Option<String>) -> Result<ApprovalStatus, ApprovalError> {
        let request = self.requests.get_mut(request_id.clone())
            .ok_or(ApprovalError.NotFound)?
        
        request.approve(user.clone(), comment.clone())?
        
        // Update chain if exists
        for (_, chain) in self.chains.iter_mut() {
            if chain.request.id == request_id {
                chain.add_decision(ApprovalDecision.approve(user.clone(), comment.clone()))
                
                if chain.is_complete() {
                    if chain.is_approved() {
                        request.status = ApprovalStatus.Approved
                    } else {
                        request.status = ApprovalStatus.Rejected
                    }
                }
                break
            }
        }
        
        self.notify(ApprovalNotification.Approved {
            request_id: request_id,
            approver: user
        })
        
        Ok(request.status.clone())
    }
    
    fn reject(request_id: String, user: String, comment: Option<String>) -> Result<ApprovalStatus, ApprovalError> {
        let request = self.requests.get_mut(request_id.clone())
            .ok_or(ApprovalError.NotFound)?
        
        request.reject(user.clone(), comment.clone())?
        
        // Update chain if exists
        for (_, chain) in self.chains.iter_mut() {
            if chain.request.id == request_id {
                chain.add_decision(ApprovalDecision.reject(user.clone(), comment.clone()))
                request.status = ApprovalStatus.Rejected
                break
            }
        }
        
        self.notify(ApprovalNotification.Rejected {
            request_id: request_id,
            approver: user
        })
        
        Ok(request.status.clone())
    }
    
    fn get_request(request_id: String) -> Option<ApprovalRequest> {
        self.requests.get(request_id)
    }
    
    fn get_pending_for_user(user: String) -> [ApprovalRequest] {
        self.by_approver.get(user)
            .map(|ids| {
                ids.iter()
                    .filter_map(|id| self.requests.get(id))
                    .filter(|r| r.status == ApprovalStatus.Pending && !r.is_expired())
                    .collect()
            })
            .unwrap_or([])
    }
    
    fn get_for_workflow(workflow_id: String) -> [ApprovalRequest] {
        self.by_workflow.get(workflow_id)
            .map(|ids| ids.iter().filter_map(|id| self.requests.get(id)).collect())
            .unwrap_or([])
    }
    
    fn check_expirations() {
        for (id, request) in self.requests.iter_mut() {
            if request.status == ApprovalStatus.Pending && request.is_expired() {
                request.status = ApprovalStatus.Expired
                self.notify(ApprovalNotification.Expired { request_id: id.clone() })
            }
        }
    }
    
    fn escalate(request_id: String, new_approvers: [String]) -> Result<(), ApprovalError> {
        let request = self.requests.get_mut(request_id.clone())
            .ok_or(ApprovalError.NotFound)?
        
        request.escalate(new_approvers.clone())
        
        for approver in new_approvers {
            let list = self.by_approver.entry(approver).or_insert([])
            list.push(request_id.clone())
        }
        
        self.notify(ApprovalNotification.Escalated { request_id: request_id })
        
        Ok(())
    }
    
    fn notify(notification: ApprovalNotification) {
        if let Some(handler) = self.notifications {
            handler(notification)
        }
    }
}

// =============================================================================
// Notifications
// =============================================================================

enum ApprovalNotification {
    RequestCreated(ApprovalRequest)
    Approved { request_id: String, approver: String }
    Rejected { request_id: String, approver: String }
    Expired { request_id: String }
    Escalated { request_id: String }
    Reminder { request_id: String, approver: String }
}

// =============================================================================
// Approval Step (for workflow integration)
// =============================================================================

struct ApprovalStep {
    id: String
    name: String
    title: String
    description: String
    approvers: [String]
    policy: ApprovalPolicy
    timeout: Option<Duration>
    on_timeout: ApprovalTimeoutAction
    
    fn new(id: String, title: String, approvers: [String]) -> Self {
        ApprovalStep {
            id: id,
            name: title.clone(),
            title: title,
            description: "",
            approvers: approvers,
            policy: ApprovalPolicy.AnyOne,
            timeout: None,
            on_timeout: ApprovalTimeoutAction.Reject
        }
    }
    
    fn with_policy(policy: ApprovalPolicy) -> Self {
        self.policy = policy
        self
    }
    
    fn with_timeout(duration: Duration, action: ApprovalTimeoutAction) -> Self {
        self.timeout = Some(duration)
        self.on_timeout = action
        self
    }
    
    fn create_request(workflow_id: String, requester: String) -> ApprovalRequest {
        var request = ApprovalRequest.new(workflow_id, self.id.clone(), self.title.clone())
            .with_description(self.description.clone())
            .with_requester(requester)
            .with_approvers(self.approvers.clone())
        
        if let Some(timeout) = self.timeout {
            request = request.with_expiry(timeout)
        }
        
        request
    }
}

enum ApprovalTimeoutAction {
    Reject
    Approve
    Escalate([String])
    Skip
}

// =============================================================================
// Approval Builder
// =============================================================================

struct ApprovalBuilder {
    title: String
    description: String
    approvers: [String]
    policy: ApprovalPolicy
    timeout: Option<Duration>
    metadata: Map<String, Any>
    
    fn new(title: String) -> Self {
        ApprovalBuilder {
            title: title,
            description: "",
            approvers: [],
            policy: ApprovalPolicy.AnyOne,
            timeout: None,
            metadata: Map.empty()
        }
    }
    
    fn description(desc: String) -> Self {
        self.description = desc
        self
    }
    
    fn approver(user: String) -> Self {
        self.approvers.push(user)
        self
    }
    
    fn approvers(users: [String]) -> Self {
        self.approvers.extend(users)
        self
    }
    
    fn require_all() -> Self {
        self.policy = ApprovalPolicy.All
        self
    }
    
    fn require_any() -> Self {
        self.policy = ApprovalPolicy.AnyOne
        self
    }
    
    fn require_majority() -> Self {
        self.policy = ApprovalPolicy.Majority
        self
    }
    
    fn require_quorum(n: Int) -> Self {
        self.policy = ApprovalPolicy.Quorum(n)
        self
    }
    
    fn sequential() -> Self {
        self.policy = ApprovalPolicy.Sequential(self.approvers.clone())
        self
    }
    
    fn expires_in(duration: Duration) -> Self {
        self.timeout = Some(duration)
        self
    }
    
    fn with_metadata(key: String, value: Any) -> Self {
        self.metadata.set(key, value)
        self
    }
    
    fn build(workflow_id: String, step_id: String) -> ApprovalRequest {
        var request = ApprovalRequest.new(workflow_id, step_id, self.title.clone())
            .with_description(self.description.clone())
            .with_approvers(self.approvers.clone())
        
        if let Some(timeout) = self.timeout {
            request = request.with_expiry(timeout)
        }
        
        for (key, value) in self.metadata {
            request = request.with_metadata(key, value)
        }
        
        request
    }
}

// =============================================================================
// Errors
// =============================================================================

enum ApprovalError {
    NotFound
    NotAuthorized
    AlreadyDecided
    Expired
    InvalidPolicy
    
    fn to_string() -> String {
        match self {
            NotFound => "Approval request not found"
            NotAuthorized => "User not authorized to approve"
            AlreadyDecided => "Approval already decided"
            Expired => "Approval request expired"
            InvalidPolicy => "Invalid approval policy"
        }
    }
}

// =============================================================================
// Tests
// =============================================================================

test "approval request" {
    var request = ApprovalRequest.new("wf-1", "step-1", "Approve deployment")
        .with_approvers(["alice", "bob"])
        .with_expiry(Duration.hours(24))
    
    assert_eq(request.status, ApprovalStatus.Pending)?
    assert(request.can_approve("alice"))?
    assert(!request.can_approve("charlie"))?
}

test "approve request" {
    var request = ApprovalRequest.new("wf-1", "step-1", "Test")
        .with_approvers(["alice"])
    
    request.approve("alice", Some("LGTM"))?
    assert_eq(request.status, ApprovalStatus.Approved)?
    assert_eq(request.decided_by, Some("alice"))?
}

test "reject request" {
    var request = ApprovalRequest.new("wf-1", "step-1", "Test")
        .with_approvers(["alice"])
    
    request.reject("alice", Some("Not ready"))?
    assert_eq(request.status, ApprovalStatus.Rejected)?
}

test "approval chain - any one" {
    let request = ApprovalRequest.new("wf-1", "step-1", "Test")
        .with_approvers(["alice", "bob", "charlie"])
    
    var chain = ApprovalChain.new(request, ApprovalPolicy.AnyOne)
    
    assert(!chain.is_complete())?
    
    chain.add_decision(ApprovalDecision.approve("alice", None))
    
    assert(chain.is_complete())?
    assert(chain.is_approved())?
}

test "approval chain - all" {
    let request = ApprovalRequest.new("wf-1", "step-1", "Test")
        .with_approvers(["alice", "bob"])
    
    var chain = ApprovalChain.new(request, ApprovalPolicy.All)
    
    chain.add_decision(ApprovalDecision.approve("alice", None))
    assert(!chain.is_complete())?
    
    chain.add_decision(ApprovalDecision.approve("bob", None))
    assert(chain.is_complete())?
    assert(chain.is_approved())?
}

test "approval chain - majority" {
    let request = ApprovalRequest.new("wf-1", "step-1", "Test")
        .with_approvers(["alice", "bob", "charlie"])
    
    var chain = ApprovalChain.new(request, ApprovalPolicy.Majority)
    
    chain.add_decision(ApprovalDecision.approve("alice", None))
    assert(!chain.is_complete())?
    
    chain.add_decision(ApprovalDecision.approve("bob", None))
    assert(chain.is_complete())?
    assert(chain.is_approved())?
}

test "approval manager" {
    let manager = ApprovalManager.new()
    
    let request = ApprovalRequest.new("wf-1", "step-1", "Deploy to prod")
        .with_approvers(["alice", "bob"])
    
    let id = manager.create_request(request)
    
    let pending = manager.get_pending_for_user("alice")
    assert_eq(pending.len(), 1)?
    
    manager.approve(id.clone(), "alice", Some("Approved"))?
    
    let req = manager.get_request(id)?
    assert_eq(req.status, ApprovalStatus.Approved)?
}

test "approval builder" {
    let request = ApprovalBuilder.new("Release v2.0")
        .description("Release new version to production")
        .approvers(["lead", "manager"])
        .require_all()
        .expires_in(Duration.hours(48))
        .build("wf-1", "release-step")
    
    assert_eq(request.title, "Release v2.0")?
    assert_eq(request.approvers.len(), 2)?
}

test "approval hierarchy" {
    let hierarchy = ApprovalHierarchy.new()
        .add_level(ApprovalLevel.new("Team Lead", 0.0, ["lead"]))
        .add_level(ApprovalLevel.new("Manager", 1000.0, ["manager"]))
        .add_level(ApprovalLevel.new("Director", 10000.0, ["director"]))
    
    assert_eq(hierarchy.get_approvers_for_amount(500.0), ["lead"])?
    assert_eq(hierarchy.get_approvers_for_amount(5000.0), ["manager"])?
    assert_eq(hierarchy.get_approvers_for_amount(50000.0), ["director"])?
}
