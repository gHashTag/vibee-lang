// =============================================================================
// Vibee OS â€” Future Module
// Asynchronous operations
// =============================================================================

/// Future state
enum FutureState<T> { Pending, Ready(T), Failed(Error) }

/// Future - represents async computation
struct Future<T> {
    state: FutureState<T>
    callbacks: [fn(Result<T, Error>)]
    
    fn new() -> Self { Future { state: FutureState.Pending, callbacks: [] } }
    fn ready(value: T) -> Self { Future { state: FutureState.Ready(value), callbacks: [] } }
    fn failed(err: Error) -> Self { Future { state: FutureState.Failed(err), callbacks: [] } }
    
    fn is_pending() -> Bool { matches!(self.state, FutureState.Pending) }
    fn is_ready() -> Bool { matches!(self.state, FutureState.Ready(_)) }
    fn is_failed() -> Bool { matches!(self.state, FutureState.Failed(_)) }
    
    fn resolve(value: T) {
        self.state = FutureState.Ready(value)
        for cb in self.callbacks { cb(Ok(value.clone())) }
        self.callbacks.clear()
    }
    
    fn reject(err: Error) {
        self.state = FutureState.Failed(err)
        for cb in self.callbacks { cb(Err(err.clone())) }
        self.callbacks.clear()
    }
    
    fn map<U>(f: fn(T) -> U) -> Future<U> {
        let result = Future.new()
        self.on_complete(|r| match r {
            Ok(v) => result.resolve(f(v))
            Err(e) => result.reject(e)
        })
        result
    }
    
    fn flat_map<U>(f: fn(T) -> Future<U>) -> Future<U> {
        let result = Future.new()
        self.on_complete(|r| match r {
            Ok(v) => f(v).on_complete(|r2| match r2 {
                Ok(v2) => result.resolve(v2)
                Err(e) => result.reject(e)
            })
            Err(e) => result.reject(e)
        })
        result
    }
    
    fn recover(f: fn(Error) -> T) -> Future<T> {
        let result = Future.new()
        self.on_complete(|r| match r {
            Ok(v) => result.resolve(v)
            Err(e) => result.resolve(f(e))
        })
        result
    }
    
    fn on_complete(f: fn(Result<T, Error>)) {
        match self.state {
            FutureState.Ready(v) => f(Ok(v))
            FutureState.Failed(e) => f(Err(e))
            FutureState.Pending => self.callbacks.push(f)
        }
    }
    
    fn on_success(f: fn(T)) { self.on_complete(|r| if let Ok(v) = r { f(v) }) }
    fn on_failure(f: fn(Error)) { self.on_complete(|r| if let Err(e) = r { f(e) }) }
    
    fn await() -> Result<T, Error> {
        while self.is_pending() { @native("yield") }
        match self.state {
            FutureState.Ready(v) => Ok(v)
            FutureState.Failed(e) => Err(e)
            _ => unreachable()
        }
    }
    
    fn timeout(ms: Int64) -> Future<T> {
        let result = Future.new()
        let timer = @native("set_timeout", ms, || {
            if result.is_pending() { result.reject(Error.Timeout) }
        })
        self.on_complete(|r| { @native("clear_timeout", timer); match r { Ok(v) => result.resolve(v), Err(e) => result.reject(e) } })
        result
    }
}

/// Combine futures
fn all<T>(futures: [Future<T>]) -> Future<[T]> {
    let result = Future.new()
    let count = futures.len()
    var completed = 0
    var results = [None; count]
    var failed = false
    
    for (i, f) in futures.iter().enumerate() {
        f.on_complete(|r| {
            if failed { return }
            match r {
                Ok(v) => { results[i] = Some(v); completed += 1; if completed == count { result.resolve(results.iter().map(|o| o.unwrap()).collect()) } }
                Err(e) => { failed = true; result.reject(e) }
            }
        })
    }
    if count == 0 { result.resolve([]) }
    result
}

fn race<T>(futures: [Future<T>]) -> Future<T> {
    let result = Future.new()
    for f in futures {
        f.on_complete(|r| if result.is_pending() { match r { Ok(v) => result.resolve(v), Err(e) => result.reject(e) } })
    }
    result
}

fn any<T>(futures: [Future<T>]) -> Future<T> {
    let result = Future.new()
    var errors = []
    var remaining = futures.len()
    for f in futures {
        f.on_complete(|r| {
            if !result.is_pending() { return }
            match r {
                Ok(v) => result.resolve(v)
                Err(e) => { errors.push(e); remaining -= 1; if remaining == 0 { result.reject(Error.AllFailed(errors)) } }
            }
        })
    }
    result
}

fn delay<T>(ms: Int64, value: T) -> Future<T> {
    let result = Future.new()
    @native("set_timeout", ms, || result.resolve(value))
    result
}

/// Promise (writable future)
struct Promise<T> {
    future: Future<T>
    
    fn new() -> Self { Promise { future: Future.new() } }
    fn resolve(value: T) { self.future.resolve(value) }
    fn reject(err: Error) { self.future.reject(err) }
    fn future() -> Future<T> { self.future }
}

/// Async task
actor Task<T> {
    state future: Future<T>
    state cancelled: Bool
    
    fn new(f: fn() -> T) -> Self {
        let task = Task { future: Future.new(), cancelled: false }
        spawn { if !task.cancelled { task.future.resolve(f()) } }
        task
    }
    
    fn cancel() { self.cancelled = true; self.future.reject(Error.Cancelled) }
    fn await() -> Result<T, Error> { self.future.await() }
    fn is_done() -> Bool { !self.future.is_pending() }
}

// Tests
test "ready future" {
    let f = Future.ready(42)
    assert(f.is_ready())?
    assert_eq(f.await()?, 42)?
}

test "map" {
    let f = Future.ready(2).map(|x| x * 3)
    assert_eq(f.await()?, 6)?
}

test "all" {
    let f = all([Future.ready(1), Future.ready(2), Future.ready(3)])
    assert_eq(f.await()?, [1, 2, 3])?
}
