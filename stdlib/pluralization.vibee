// =============================================================================
// Vibee OS — Pluralization Module
// CLDR-based plural rules for internationalization
// =============================================================================

use locale.{Locale, Locales}

// -----------------------------------------------------------------------------
// Plural Categories
// -----------------------------------------------------------------------------

/// CLDR plural categories
enum PluralCategory {
    Zero    // 0 items (Arabic, Latvian, etc.)
    One     // 1 item (most languages)
    Two     // 2 items (Arabic, Hebrew, Slovenian, etc.)
    Few     // 2-4 items (Slavic languages, etc.)
    Many    // 5+ items (Slavic languages, Arabic, etc.)
    Other   // Default/fallback
    
    fn to_string() -> String {
        match self {
            .Zero => "zero"
            .One => "one"
            .Two => "two"
            .Few => "few"
            .Many => "many"
            .Other => "other"
        }
    }
    
    fn from_string(s: String) -> Self {
        match s.to_lower() {
            "zero" => .Zero
            "one" => .One
            "two" => .Two
            "few" => .Few
            "many" => .Many
            _ => .Other
        }
    }
}

impl Eq for PluralCategory {
    fn eq(other: PluralCategory) -> Bool {
        self.to_string() == other.to_string()
    }
}

impl Hash for PluralCategory {
    fn hash(h: Hasher) {
        h.write(self.to_string().as_bytes())
    }
}

// -----------------------------------------------------------------------------
// Plural Operands
// -----------------------------------------------------------------------------

/// Operands for plural rule evaluation (CLDR specification)
struct PluralOperands {
    n: Float    // Absolute value of the source number
    i: Int      // Integer digits of n
    v: Int      // Number of visible fraction digits (with trailing zeros)
    w: Int      // Number of visible fraction digits (without trailing zeros)
    f: Int      // Visible fraction digits (with trailing zeros)
    t: Int      // Visible fraction digits (without trailing zeros)
    c: Int      // Compact decimal exponent (for compact notation)
    
    fn from_int(n: Int) -> Self {
        PluralOperands {
            n: n.abs() as Float,
            i: n.abs(),
            v: 0,
            w: 0,
            f: 0,
            t: 0,
            c: 0
        }
    }
    
    fn from_float(n: Float) -> Self {
        let abs_n = n.abs()
        let i = abs_n.floor() as Int
        
        // Calculate fraction digits
        let s = abs_n.to_string()
        let (v, f, w, t) = if let Some(dot_pos) = s.find('.') {
            let frac_str = s[(dot_pos + 1)..]
            let v = frac_str.len() as Int
            let f = Int.parse(frac_str).unwrap_or(0)
            let trimmed = frac_str.trim_end_matches('0')
            let w = trimmed.len() as Int
            let t = if trimmed.is_empty() { 0 } else { Int.parse(trimmed).unwrap_or(0) }
            (v, f, w, t)
        } else {
            (0, 0, 0, 0)
        }
        
        PluralOperands { n: abs_n, i: i, v: v, w: w, f: f, t: t, c: 0 }
    }
    
    fn from_decimal(d: Decimal) -> Self {
        Self.from_float(d.to_float())
    }
    
    /// Check if n is in range [start, end]
    fn n_in_range(start: Float, end: Float) -> Bool {
        self.n >= start && self.n <= end
    }
    
    /// Check if i is in range [start, end]
    fn i_in_range(start: Int, end: Int) -> Bool {
        self.i >= start && self.i <= end
    }
    
    /// Check if n mod divisor is in range
    fn n_mod_in_range(divisor: Float, start: Float, end: Float) -> Bool {
        let remainder = self.n % divisor
        remainder >= start && remainder <= end
    }
    
    /// Check if i mod divisor is in range
    fn i_mod_in_range(divisor: Int, start: Int, end: Int) -> Bool {
        let remainder = self.i % divisor
        remainder >= start && remainder <= end
    }
}

// -----------------------------------------------------------------------------
// Plural Rules
// -----------------------------------------------------------------------------

/// Plural rules for a specific locale
struct PluralRules {
    locale: Locale
    rule_type: PluralRuleType
    
    /// Get plural rules for locale
    fn for_locale(locale: Locale) -> Self {
        PluralRules { locale: locale, rule_type: PluralRuleType.Cardinal }
    }
    
    /// Get ordinal rules for locale
    fn ordinal_for_locale(locale: Locale) -> Self {
        PluralRules { locale: locale, rule_type: PluralRuleType.Ordinal }
    }
    
    /// Select plural category for integer
    fn select(n: Int) -> PluralCategory {
        let operands = PluralOperands.from_int(n)
        self.select_with_operands(operands)
    }
    
    /// Select plural category for float
    fn select_float(n: Float) -> PluralCategory {
        let operands = PluralOperands.from_float(n)
        self.select_with_operands(operands)
    }
    
    /// Select plural category for decimal
    fn select_decimal(n: Decimal) -> PluralCategory {
        let operands = PluralOperands.from_decimal(n)
        self.select_with_operands(operands)
    }
    
    /// Select with operands
    fn select_with_operands(op: PluralOperands) -> PluralCategory {
        match self.rule_type {
            .Cardinal => self.select_cardinal(op)
            .Ordinal => self.select_ordinal(op)
        }
    }
    
    /// Select cardinal plural category
    fn select_cardinal(op: PluralOperands) -> PluralCategory {
        let lang = self.locale.language
        
        match lang {
            // English, German, Dutch, Swedish, Danish, Norwegian, etc.
            "en" | "de" | "nl" | "sv" | "da" | "no" | "nb" | "nn" | "it" | "pt" | "es" | "ca" => {
                if op.i == 1 && op.v == 0 { .One } else { .Other }
            }
            
            // French, Portuguese (Brazil)
            "fr" => {
                if op.i == 0 || op.i == 1 { .One } else { .Other }
            }
            
            // Russian, Ukrainian, Belarusian
            "ru" | "uk" | "be" => {
                self.select_slavic_east(op)
            }
            
            // Polish
            "pl" => {
                self.select_polish(op)
            }
            
            // Czech, Slovak
            "cs" | "sk" => {
                self.select_czech(op)
            }
            
            // Arabic
            "ar" => {
                self.select_arabic(op)
            }
            
            // Hebrew
            "he" | "iw" => {
                self.select_hebrew(op)
            }
            
            // Chinese, Japanese, Korean, Vietnamese, Thai, Indonesian, Malay
            "zh" | "ja" | "ko" | "vi" | "th" | "id" | "ms" => {
                .Other  // No plural forms
            }
            
            // Turkish, Hungarian, Finnish, Estonian
            "tr" | "hu" | "fi" | "et" => {
                if op.n == 1.0 { .One } else { .Other }
            }
            
            // Latvian
            "lv" => {
                self.select_latvian(op)
            }
            
            // Lithuanian
            "lt" => {
                self.select_lithuanian(op)
            }
            
            // Romanian, Moldavian
            "ro" | "mo" => {
                self.select_romanian(op)
            }
            
            // Slovenian
            "sl" => {
                self.select_slovenian(op)
            }
            
            // Croatian, Serbian, Bosnian
            "hr" | "sr" | "bs" => {
                self.select_slavic_south(op)
            }
            
            // Irish
            "ga" => {
                self.select_irish(op)
            }
            
            // Welsh
            "cy" => {
                self.select_welsh(op)
            }
            
            // Default: simple one/other
            _ => {
                if op.n == 1.0 && op.v == 0 { .One } else { .Other }
            }
        }
    }
    
    /// Select ordinal plural category
    fn select_ordinal(op: PluralOperands) -> PluralCategory {
        let lang = self.locale.language
        
        match lang {
            // English: 1st, 2nd, 3rd, 4th...
            "en" => {
                let n10 = op.i % 10
                let n100 = op.i % 100
                
                if n10 == 1 && n100 != 11 { .One }
                else if n10 == 2 && n100 != 12 { .Two }
                else if n10 == 3 && n100 != 13 { .Few }
                else { .Other }
            }
            
            // Welsh
            "cy" => {
                match op.i {
                    0 | 7 | 8 | 9 => .Zero
                    1 => .One
                    2 => .Two
                    3 | 4 => .Few
                    5 | 6 => .Many
                    _ => .Other
                }
            }
            
            // Most languages don't have ordinal distinctions
            _ => .Other
        }
    }
    
    // Language-specific rules
    
    fn select_slavic_east(op: PluralOperands) -> PluralCategory {
        // Russian, Ukrainian, Belarusian
        let n10 = op.i % 10
        let n100 = op.i % 100
        
        if op.v == 0 {
            if n10 == 1 && n100 != 11 { .One }
            else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { .Few }
            else if n10 == 0 || (n10 >= 5 && n10 <= 9) || (n100 >= 11 && n100 <= 14) { .Many }
            else { .Other }
        } else {
            .Other
        }
    }
    
    fn select_polish(op: PluralOperands) -> PluralCategory {
        let n10 = op.i % 10
        let n100 = op.i % 100
        
        if op.v == 0 {
            if op.i == 1 { .One }
            else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { .Few }
            else if op.i != 1 && (n10 == 0 || n10 == 1) || (n10 >= 5 && n10 <= 9) || (n100 >= 12 && n100 <= 14) { .Many }
            else { .Other }
        } else {
            .Other
        }
    }
    
    fn select_czech(op: PluralOperands) -> PluralCategory {
        if op.v == 0 {
            if op.i == 1 { .One }
            else if op.i >= 2 && op.i <= 4 { .Few }
            else { .Many }
        } else {
            .Many
        }
    }
    
    fn select_arabic(op: PluralOperands) -> PluralCategory {
        let n100 = op.i % 100
        
        if op.n == 0.0 { .Zero }
        else if op.n == 1.0 { .One }
        else if op.n == 2.0 { .Two }
        else if n100 >= 3 && n100 <= 10 { .Few }
        else if n100 >= 11 && n100 <= 99 { .Many }
        else { .Other }
    }
    
    fn select_hebrew(op: PluralOperands) -> PluralCategory {
        if op.v == 0 {
            if op.i == 1 { .One }
            else if op.i == 2 { .Two }
            else if op.i >= 11 && op.i % 10 == 0 { .Many }
            else { .Other }
        } else {
            .Other
        }
    }
    
    fn select_latvian(op: PluralOperands) -> PluralCategory {
        let n10 = op.i % 10
        let n100 = op.i % 100
        let f10 = op.f % 10
        let f100 = op.f % 100
        
        if op.n == 0.0 { .Zero }
        else if (n10 == 1 && n100 != 11) || (op.v != 0 && f10 == 1 && f100 != 11) { .One }
        else { .Other }
    }
    
    fn select_lithuanian(op: PluralOperands) -> PluralCategory {
        let n10 = op.i % 10
        let n100 = op.i % 100
        
        if op.v == 0 {
            if n10 == 1 && (n100 < 11 || n100 > 19) { .One }
            else if n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) { .Few }
            else { .Many }
        } else {
            .Many
        }
    }
    
    fn select_romanian(op: PluralOperands) -> PluralCategory {
        let n100 = op.i % 100
        
        if op.i == 1 && op.v == 0 { .One }
        else if op.v != 0 || op.n == 0.0 || (n100 >= 2 && n100 <= 19) { .Few }
        else { .Other }
    }
    
    fn select_slovenian(op: PluralOperands) -> PluralCategory {
        let n100 = op.i % 100
        
        if op.v == 0 {
            if n100 == 1 { .One }
            else if n100 == 2 { .Two }
            else if n100 == 3 || n100 == 4 { .Few }
            else { .Other }
        } else {
            .Other
        }
    }
    
    fn select_slavic_south(op: PluralOperands) -> PluralCategory {
        // Croatian, Serbian, Bosnian
        let n10 = op.i % 10
        let n100 = op.i % 100
        let f10 = op.f % 10
        let f100 = op.f % 100
        
        if op.v == 0 && n10 == 1 && n100 != 11 || f10 == 1 && f100 != 11 { .One }
        else if op.v == 0 && n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ||
                f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) { .Few }
        else { .Other }
    }
    
    fn select_irish(op: PluralOperands) -> PluralCategory {
        if op.n == 1.0 { .One }
        else if op.n == 2.0 { .Two }
        else if op.i >= 3 && op.i <= 6 { .Few }
        else if op.i >= 7 && op.i <= 10 { .Many }
        else { .Other }
    }
    
    fn select_welsh(op: PluralOperands) -> PluralCategory {
        if op.n == 0.0 { .Zero }
        else if op.n == 1.0 { .One }
        else if op.n == 2.0 { .Two }
        else if op.n == 3.0 { .Few }
        else if op.n == 6.0 { .Many }
        else { .Other }
    }
    
    /// Get all categories used by this locale
    fn categories() -> [PluralCategory] {
        let lang = self.locale.language
        
        match lang {
            // No plural forms
            "zh" | "ja" | "ko" | "vi" | "th" | "id" | "ms" => {
                [.Other]
            }
            
            // One/Other
            "en" | "de" | "nl" | "sv" | "da" | "no" | "it" | "es" | "pt" | "fr" | "tr" | "hu" | "fi" | "et" => {
                [.One, .Other]
            }
            
            // One/Two/Other
            "he" => {
                [.One, .Two, .Other]
            }
            
            // One/Few/Many/Other (Slavic)
            "ru" | "uk" | "be" | "pl" | "cs" | "sk" => {
                [.One, .Few, .Many, .Other]
            }
            
            // Zero/One/Two/Few/Many/Other (Arabic)
            "ar" => {
                [.Zero, .One, .Two, .Few, .Many, .Other]
            }
            
            // Default
            _ => {
                [.One, .Other]
            }
        }
    }
}

/// Type of plural rules
enum PluralRuleType {
    Cardinal    // For counting (1 item, 2 items)
    Ordinal     // For ordering (1st, 2nd, 3rd)
}

// -----------------------------------------------------------------------------
// Plural Formatter
// -----------------------------------------------------------------------------

/// Format numbers with plural forms
struct PluralFormatter {
    rules: PluralRules
    forms: Map<PluralCategory, String>
    
    fn new(locale: Locale, forms: Map<PluralCategory, String>) -> Self {
        PluralFormatter {
            rules: PluralRules.for_locale(locale),
            forms: forms
        }
    }
    
    /// Format integer with plural
    fn format(n: Int) -> String {
        let category = self.rules.select(n)
        let template = self.forms.get(category)
            .or_else(|| self.forms.get(PluralCategory.Other))
            .unwrap_or("{n}")
        template.replace("{n}", n.to_string())
    }
    
    /// Format float with plural
    fn format_float(n: Float) -> String {
        let category = self.rules.select_float(n)
        let template = self.forms.get(category)
            .or_else(|| self.forms.get(PluralCategory.Other))
            .unwrap_or("{n}")
        template.replace("{n}", n.to_string())
    }
}

// -----------------------------------------------------------------------------
// Ordinal Formatter
// -----------------------------------------------------------------------------

/// Format ordinal numbers (1st, 2nd, 3rd, etc.)
struct OrdinalFormatter {
    locale: Locale
    
    fn for_locale(locale: Locale) -> Self {
        OrdinalFormatter { locale: locale }
    }
    
    fn format(n: Int) -> String {
        let lang = self.locale.language
        
        match lang {
            "en" => self.format_english(n)
            "ru" => self.format_russian(n)
            "de" => self.format_german(n)
            "fr" => self.format_french(n)
            "es" => self.format_spanish(n)
            "it" => self.format_italian(n)
            "pt" => self.format_portuguese(n)
            "zh" => self.format_chinese(n)
            "ja" => self.format_japanese(n)
            _ => n.to_string() + "."  // Default: number with period
        }
    }
    
    fn format_english(n: Int) -> String {
        let suffix = match n % 100 {
            11 | 12 | 13 => "th"
            _ => match n % 10 {
                1 => "st"
                2 => "nd"
                3 => "rd"
                _ => "th"
            }
        }
        n.to_string() + suffix
    }
    
    fn format_russian(n: Int) -> String {
        n.to_string() + "-й"  // Simplified, actual depends on gender
    }
    
    fn format_german(n: Int) -> String {
        n.to_string() + "."
    }
    
    fn format_french(n: Int) -> String {
        if n == 1 { "1er" } else { n.to_string() + "e" }
    }
    
    fn format_spanish(n: Int) -> String {
        n.to_string() + "º"  // Masculine, feminine would be ª
    }
    
    fn format_italian(n: Int) -> String {
        n.to_string() + "º"
    }
    
    fn format_portuguese(n: Int) -> String {
        n.to_string() + "º"
    }
    
    fn format_chinese(n: Int) -> String {
        "第" + n.to_string()
    }
    
    fn format_japanese(n: Int) -> String {
        "第" + n.to_string()
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

/// Get plural category for number in current locale
fn plural_category(n: Int) -> PluralCategory {
    let locale = Locale.current()
    PluralRules.for_locale(locale).select(n)
}

/// Get plural category for number in specific locale
fn plural_category_for(n: Int, locale: Locale) -> PluralCategory {
    PluralRules.for_locale(locale).select(n)
}

/// Format ordinal in current locale
fn ordinal(n: Int) -> String {
    let locale = Locale.current()
    OrdinalFormatter.for_locale(locale).format(n)
}

/// Format ordinal in specific locale
fn ordinal_for(n: Int, locale: Locale) -> String {
    OrdinalFormatter.for_locale(locale).format(n)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "english plurals" {
    let rules = PluralRules.for_locale(Locales.en_US())
    
    assert_eq(rules.select(0), PluralCategory.Other)?
    assert_eq(rules.select(1), PluralCategory.One)?
    assert_eq(rules.select(2), PluralCategory.Other)?
    assert_eq(rules.select(5), PluralCategory.Other)?
}

test "russian plurals" {
    let rules = PluralRules.for_locale(Locales.ru_RU())
    
    assert_eq(rules.select(1), PluralCategory.One)?
    assert_eq(rules.select(2), PluralCategory.Few)?
    assert_eq(rules.select(5), PluralCategory.Many)?
    assert_eq(rules.select(21), PluralCategory.One)?
    assert_eq(rules.select(22), PluralCategory.Few)?
    assert_eq(rules.select(25), PluralCategory.Many)?
    assert_eq(rules.select(11), PluralCategory.Many)?
}

test "arabic plurals" {
    let rules = PluralRules.for_locale(Locales.ar_SA())
    
    assert_eq(rules.select(0), PluralCategory.Zero)?
    assert_eq(rules.select(1), PluralCategory.One)?
    assert_eq(rules.select(2), PluralCategory.Two)?
    assert_eq(rules.select(5), PluralCategory.Few)?
    assert_eq(rules.select(15), PluralCategory.Many)?
    assert_eq(rules.select(100), PluralCategory.Other)?
}

test "chinese no plurals" {
    let rules = PluralRules.for_locale(Locales.zh_CN())
    
    assert_eq(rules.select(0), PluralCategory.Other)?
    assert_eq(rules.select(1), PluralCategory.Other)?
    assert_eq(rules.select(100), PluralCategory.Other)?
}

test "english ordinals" {
    let formatter = OrdinalFormatter.for_locale(Locales.en_US())
    
    assert_eq(formatter.format(1), "1st")?
    assert_eq(formatter.format(2), "2nd")?
    assert_eq(formatter.format(3), "3rd")?
    assert_eq(formatter.format(4), "4th")?
    assert_eq(formatter.format(11), "11th")?
    assert_eq(formatter.format(12), "12th")?
    assert_eq(formatter.format(13), "13th")?
    assert_eq(formatter.format(21), "21st")?
    assert_eq(formatter.format(22), "22nd")?
    assert_eq(formatter.format(23), "23rd")?
}

test "plural formatter" {
    let forms = Map.from([
        (PluralCategory.One, "{n} item"),
        (PluralCategory.Other, "{n} items")
    ])
    let formatter = PluralFormatter.new(Locales.en_US(), forms)
    
    assert_eq(formatter.format(1), "1 item")?
    assert_eq(formatter.format(5), "5 items")?
}

test "russian plural formatter" {
    let forms = Map.from([
        (PluralCategory.One, "{n} яблоко"),
        (PluralCategory.Few, "{n} яблока"),
        (PluralCategory.Many, "{n} яблок"),
        (PluralCategory.Other, "{n} яблок")
    ])
    let formatter = PluralFormatter.new(Locales.ru_RU(), forms)
    
    assert_eq(formatter.format(1), "1 яблоко")?
    assert_eq(formatter.format(2), "2 яблока")?
    assert_eq(formatter.format(5), "5 яблок")?
    assert_eq(formatter.format(21), "21 яблоко")?
}

test "operands" {
    let op = PluralOperands.from_float(1.5)
    assert_eq(op.i, 1)?
    assert_eq(op.v, 1)?
    assert_eq(op.f, 5)?
    
    let op2 = PluralOperands.from_float(1.50)
    assert_eq(op2.v, 1)?  // Trailing zeros may be stripped
}
