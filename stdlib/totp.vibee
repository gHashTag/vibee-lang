// =============================================================================
// Vibee OS â€” TOTP Module
// Time-based One-Time Passwords (RFC 6238)
// =============================================================================

/// TOTP Generator
struct Totp {
    secret: [UInt8]
    digits: Int
    period: Int
    algorithm: TotpAlgorithm
}

enum TotpAlgorithm { SHA1, SHA256, SHA512 }

impl Totp {
    /// Create from base32 secret
    fn new(secret: String) -> Result<Self, TotpError> {
        let decoded = base32_decode(secret.replace(" ", "").to_upper())?
        Ok(Totp { secret: decoded, digits: 6, period: 30, algorithm: TotpAlgorithm.SHA1 })
    }
    
    /// Create from raw bytes
    fn from_bytes(secret: [UInt8]) -> Self {
        Totp { secret: secret, digits: 6, period: 30, algorithm: TotpAlgorithm.SHA1 }
    }
    
    fn digits(d: Int) -> Self { self.digits = d.clamp(6, 8); self }
    fn period(p: Int) -> Self { self.period = p; self }
    fn algorithm(a: TotpAlgorithm) -> Self { self.algorithm = a; self }
    fn sha256() -> Self { self.algorithm = TotpAlgorithm.SHA256; self }
    fn sha512() -> Self { self.algorithm = TotpAlgorithm.SHA512; self }
    
    /// Generate current code
    fn generate() -> String { self.generate_at(DateTime.now().timestamp()) }
    
    /// Generate code at specific time
    fn generate_at(timestamp: Int64) -> String {
        let counter = timestamp / self.period as Int64
        self.generate_hotp(counter)
    }
    
    /// Generate HOTP (counter-based)
    fn generate_hotp(counter: Int64) -> String {
        var counter_bytes = [0u8; 8]
        for i in 0..8 { counter_bytes[7 - i] = ((counter >> (i * 8)) & 0xff) as UInt8 }
        
        let hmac = match self.algorithm {
            SHA1 => @native("hmac_sha1", self.secret, counter_bytes)
            SHA256 => crypto.hmac_sha256(self.secret, counter_bytes).to_vec()
            SHA512 => crypto.hmac_sha512(self.secret, counter_bytes).to_vec()
        }
        
        let offset = (hmac[hmac.len() - 1] & 0x0f) as Int
        let code = ((hmac[offset] & 0x7f) as UInt32) << 24 |
                   (hmac[offset + 1] as UInt32) << 16 |
                   (hmac[offset + 2] as UInt32) << 8 |
                   (hmac[offset + 3] as UInt32)
        
        let otp = code % (10u32.pow(self.digits as UInt32))
        format!("{:0>width$}", otp, width = self.digits)
    }
    
    /// Verify code with time window
    fn verify(code: String) -> Bool { self.verify_with_window(code, 1) }
    
    fn verify_with_window(code: String, window: Int) -> Bool {
        let now = DateTime.now().timestamp()
        for i in -window..=window {
            let timestamp = now + (i * self.period) as Int64
            if self.generate_at(timestamp) == code { return true }
        }
        false
    }
    
    /// Time remaining until next code
    fn time_remaining() -> Int {
        let now = DateTime.now().timestamp()
        self.period - (now % self.period as Int64) as Int
    }
    
    /// Generate provisioning URI for authenticator apps
    fn provisioning_uri(issuer: String, account: String) -> String {
        let secret_b32 = base32_encode(self.secret)
        let algo = match self.algorithm { SHA1 => "SHA1", SHA256 => "SHA256", SHA512 => "SHA512" }
        format!("otpauth://totp/{}:{}?secret={}&issuer={}&algorithm={}&digits={}&period={}",
            url.encode_uri_component(issuer), url.encode_uri_component(account),
            secret_b32, url.encode_uri_component(issuer), algo, self.digits, self.period)
    }
    
    /// Generate random secret
    fn generate_secret() -> Self {
        let secret = crypto.random_bytes(20)
        Self.from_bytes(secret)
    }
    
    /// Get secret as base32
    fn secret_base32() -> String { base32_encode(self.secret) }
}

/// HOTP Generator (counter-based)
struct Hotp {
    secret: [UInt8]
    digits: Int
    counter: Int64
}

impl Hotp {
    fn new(secret: String) -> Result<Self, TotpError> {
        let decoded = base32_decode(secret.replace(" ", "").to_upper())?
        Ok(Hotp { secret: decoded, digits: 6, counter: 0 })
    }
    
    fn from_bytes(secret: [UInt8]) -> Self { Hotp { secret: secret, digits: 6, counter: 0 } }
    fn counter(c: Int64) -> Self { self.counter = c; self }
    fn digits(d: Int) -> Self { self.digits = d.clamp(6, 8); self }
    
    fn generate() -> String {
        let totp = Totp.from_bytes(self.secret).digits(self.digits)
        let code = totp.generate_hotp(self.counter)
        self.counter += 1
        code
    }
    
    fn verify(code: String, look_ahead: Int) -> Option<Int64> {
        let totp = Totp.from_bytes(self.secret).digits(self.digits)
        for i in 0..look_ahead {
            let c = self.counter + i as Int64
            if totp.generate_hotp(c) == code {
                self.counter = c + 1
                return Some(c)
            }
        }
        None
    }
}

// =============================================================================
// Base32 Encoding
// =============================================================================

const BASE32_ALPHABET: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

fn base32_encode(data: [UInt8]) -> String {
    var result = ""
    var buffer: UInt64 = 0
    var bits = 0
    
    for byte in data {
        buffer = (buffer << 8) | byte as UInt64
        bits += 8
        while bits >= 5 {
            bits -= 5
            result.push(BASE32_ALPHABET[((buffer >> bits) & 0x1f) as Int])
        }
    }
    
    if bits > 0 {
        buffer <<= 5 - bits
        result.push(BASE32_ALPHABET[(buffer & 0x1f) as Int])
    }
    
    result
}

fn base32_decode(s: String) -> Result<[UInt8], TotpError> {
    let s = s.trim_end("=")
    var result = []
    var buffer: UInt64 = 0
    var bits = 0
    
    for c in s.chars() {
        let idx = BASE32_ALPHABET.find(c).ok_or(TotpError.InvalidBase32)?
        buffer = (buffer << 5) | idx as UInt64
        bits += 5
        if bits >= 8 {
            bits -= 8
            result.push(((buffer >> bits) & 0xff) as UInt8)
        }
    }
    
    Ok(result)
}

// =============================================================================
// Recovery Codes
// =============================================================================

struct RecoveryCodes { codes: [String], used: Set<String> }

impl RecoveryCodes {
    fn generate(count: Int) -> Self {
        let codes = (0..count).map(|_| {
            let bytes = crypto.random_bytes(5)
            format!("{}-{}", hex.encode(bytes[0..2]).to_upper(), hex.encode(bytes[2..5]).to_upper())
        }).collect()
        RecoveryCodes { codes: codes, used: Set.empty() }
    }
    
    fn verify(code: String) -> Bool {
        let code = code.replace("-", "").to_upper()
        for c in self.codes {
            let c_clean = c.replace("-", "")
            if c_clean == code && !self.used.contains(c) {
                self.used.insert(c.clone())
                return true
            }
        }
        false
    }
    
    fn remaining() -> Int { self.codes.len() - self.used.len() }
    fn all_codes() -> [String] { self.codes.clone() }
}

enum TotpError { InvalidBase32, InvalidSecret, Other(String) }
impl Display for TotpError { fn fmt(f: Formatter) { match self { InvalidBase32 => f.write("Invalid base32 encoding"), InvalidSecret => f.write("Invalid secret"), Other(s) => f.write(s) } } }

// Tests
test "generate and verify" {
    let totp = Totp.generate_secret()
    let code = totp.generate()
    assert_eq(code.len(), 6)?
    assert(totp.verify(code))?
}

test "provisioning uri" {
    let totp = Totp.new("JBSWY3DPEHPK3PXP")?
    let uri = totp.provisioning_uri("Example", "user@example.com")
    assert(uri.starts_with("otpauth://totp/"))?
    assert(uri.contains("secret=JBSWY3DPEHPK3PXP"))?
}

test "base32" {
    let encoded = base32_encode("Hello".as_bytes())
    let decoded = base32_decode(encoded)?
    assert_eq(String.from_utf8(decoded)?, "Hello")?
}

test "recovery codes" {
    var codes = RecoveryCodes.generate(10)
    assert_eq(codes.remaining(), 10)?
    let code = codes.all_codes()[0].clone()
    assert(codes.verify(code))?
    assert_eq(codes.remaining(), 9)?
    assert(!codes.verify(code))?  // Can't reuse
}
