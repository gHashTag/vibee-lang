// =============================================================================
// Vibee OS â€” FS Module
// File system operations
// =============================================================================

/// Read entire file as string
fn read_string(path: String) -> Result<String, IoError> { @native("fs_read_string", path) }

/// Read entire file as bytes
fn read_bytes(path: String) -> Result<[UInt8], IoError> { @native("fs_read_bytes", path) }

/// Write string to file
fn write_string(path: String, content: String) -> Result<(), IoError> { @native("fs_write_string", path, content) }

/// Write bytes to file
fn write_bytes(path: String, data: [UInt8]) -> Result<(), IoError> { @native("fs_write_bytes", path, data) }

/// Append to file
fn append_string(path: String, content: String) -> Result<(), IoError> { @native("fs_append_string", path, content) }
fn append_bytes(path: String, data: [UInt8]) -> Result<(), IoError> { @native("fs_append_bytes", path, data) }

/// Copy file
fn copy(from: String, to: String) -> Result<Int64, IoError> { @native("fs_copy", from, to) }

/// Rename/move file
fn rename(from: String, to: String) -> Result<(), IoError> { @native("fs_rename", from, to) }

/// Remove file
fn remove(path: String) -> Result<(), IoError> { @native("fs_remove", path) }

/// Remove directory (empty)
fn remove_dir(path: String) -> Result<(), IoError> { @native("fs_remove_dir", path) }

/// Remove directory recursively
fn remove_dir_all(path: String) -> Result<(), IoError> { @native("fs_remove_dir_all", path) }

/// Create directory
fn create_dir(path: String) -> Result<(), IoError> { @native("fs_create_dir", path) }

/// Create directory and parents
fn create_dir_all(path: String) -> Result<(), IoError> { @native("fs_create_dir_all", path) }

/// Check if path exists
fn exists(path: String) -> Bool { @native("fs_exists", path) }

/// Check if path is file
fn is_file(path: String) -> Bool { @native("fs_is_file", path) }

/// Check if path is directory
fn is_dir(path: String) -> Bool { @native("fs_is_dir", path) }

/// Check if path is symlink
fn is_symlink(path: String) -> Bool { @native("fs_is_symlink", path) }

/// Get file metadata
fn metadata(path: String) -> Result<Metadata, IoError> { @native("fs_metadata", path) }

/// Get symlink metadata (doesn't follow)
fn symlink_metadata(path: String) -> Result<Metadata, IoError> { @native("fs_symlink_metadata", path) }

/// Read directory entries
fn read_dir(path: String) -> Result<[DirEntry], IoError> { @native("fs_read_dir", path) }

/// Create symlink
fn symlink(original: String, link: String) -> Result<(), IoError> { @native("fs_symlink", original, link) }

/// Read symlink target
fn read_link(path: String) -> Result<String, IoError> { @native("fs_read_link", path) }

/// Get canonical path
fn canonicalize(path: String) -> Result<String, IoError> { @native("fs_canonicalize", path) }

/// Set permissions
fn set_permissions(path: String, mode: Int) -> Result<(), IoError> { @native("fs_set_permissions", path, mode) }

/// File metadata
struct Metadata {
    size: Int64
    is_file: Bool
    is_dir: Bool
    is_symlink: Bool
    created: Option<DateTime>
    modified: Option<DateTime>
    accessed: Option<DateTime>
    permissions: Permissions
    readonly: Bool
}

/// File permissions
struct Permissions { mode: Int }
impl Permissions {
    fn readonly() -> Bool { self.mode & 0o222 == 0 }
    fn set_readonly(readonly: Bool) { if readonly { self.mode &= !0o222 } else { self.mode |= 0o644 } }
    fn mode() -> Int { self.mode }
}

/// Directory entry
struct DirEntry {
    path: String
    name: String
    file_type: FileType
}
impl DirEntry {
    fn metadata() -> Result<Metadata, IoError> { metadata(self.path) }
    fn is_file() -> Bool { self.file_type == FileType.File }
    fn is_dir() -> Bool { self.file_type == FileType.Dir }
}

enum FileType { File, Dir, Symlink, Other }

/// File handle
struct File { fd: @native("FileDescriptor") }
impl File {
    fn open(path: String) -> Result<Self, IoError> { Self.open_with(path, OpenOptions.read()) }
    fn create(path: String) -> Result<Self, IoError> { Self.open_with(path, OpenOptions.write().create().truncate()) }
    fn open_with(path: String, opts: OpenOptions) -> Result<Self, IoError> { Ok(File { fd: @native("fs_open", path, opts)? }) }
    
    fn read(buf: [UInt8]) -> Result<Int, IoError> { @native("fs_file_read", self.fd, buf) }
    fn read_all() -> Result<[UInt8], IoError> { @native("fs_file_read_all", self.fd) }
    fn write(data: [UInt8]) -> Result<Int, IoError> { @native("fs_file_write", self.fd, data) }
    fn write_all(data: [UInt8]) -> Result<(), IoError> { @native("fs_file_write_all", self.fd, data) }
    fn flush() -> Result<(), IoError> { @native("fs_file_flush", self.fd) }
    fn sync() -> Result<(), IoError> { @native("fs_file_sync", self.fd) }
    fn seek(pos: SeekFrom) -> Result<Int64, IoError> { @native("fs_file_seek", self.fd, pos) }
    fn metadata() -> Result<Metadata, IoError> { @native("fs_file_metadata", self.fd) }
    fn set_len(size: Int64) -> Result<(), IoError> { @native("fs_file_set_len", self.fd, size) }
}
impl Drop for File { fn drop() { @native("fs_file_close", self.fd) } }

/// Open options
struct OpenOptions { read: Bool, write: Bool, append: Bool, truncate: Bool, create: Bool, create_new: Bool }
impl OpenOptions {
    fn new() -> Self { OpenOptions { read: false, write: false, append: false, truncate: false, create: false, create_new: false } }
    fn read() -> Self { Self.new().read(true) }
    fn write() -> Self { Self.new().write(true) }
    fn read(r: Bool) -> Self { self.read = r; self }
    fn write(w: Bool) -> Self { self.write = w; self }
    fn append(a: Bool) -> Self { self.append = a; self }
    fn truncate(t: Bool) -> Self { self.truncate = t; self }
    fn create(c: Bool) -> Self { self.create = c; self }
    fn create_new(c: Bool) -> Self { self.create_new = c; self }
}

enum SeekFrom { Start(Int64), End(Int64), Current(Int64) }

/// Walk directory tree
fn walk(path: String) -> WalkDir { WalkDir.new(path) }

struct WalkDir { root: String, stack: [String], follow_symlinks: Bool, max_depth: Option<Int> }
impl WalkDir {
    fn new(path: String) -> Self { WalkDir { root: path, stack: [path], follow_symlinks: true, max_depth: None } }
    fn follow_symlinks(f: Bool) -> Self { self.follow_symlinks = f; self }
    fn max_depth(d: Int) -> Self { self.max_depth = Some(d); self }
}
impl Iterator for WalkDir {
    type Item = Result<DirEntry, IoError>
    fn next() -> Option<Self.Item> {
        while !self.stack.is_empty() {
            let path = self.stack.pop().unwrap()
            match read_dir(path) {
                Ok(entries) => {
                    for e in entries {
                        if e.is_dir() && (self.follow_symlinks || !is_symlink(e.path)) {
                            self.stack.push(e.path.clone())
                        }
                        return Some(Ok(e))
                    }
                }
                Err(e) => return Some(Err(e))
            }
        }
        None
    }
}

/// Temp file
fn temp_file() -> Result<(File, String), IoError> { @native("fs_temp_file") }
fn temp_dir() -> String { @native("fs_temp_dir") }

enum IoError { NotFound, PermissionDenied, AlreadyExists, InvalidInput, Interrupted, Other(String) }
impl Display for IoError {
    fn fmt(f: Formatter) { match self { NotFound => f.write("Not found"), PermissionDenied => f.write("Permission denied"), AlreadyExists => f.write("Already exists"), InvalidInput => f.write("Invalid input"), Interrupted => f.write("Interrupted"), Other(s) => f.write(s) } }
}

// Tests
test "read write" {
    let path = "/tmp/test_vibee.txt"
    write_string(path, "hello")?
    assert_eq(read_string(path)?, "hello")?
    remove(path)?
}

test "exists" {
    assert(exists("/tmp"))?
    assert(!exists("/nonexistent_path_12345"))?
}

test "is_dir" {
    assert(is_dir("/tmp"))?
    assert(!is_file("/tmp"))?
}
