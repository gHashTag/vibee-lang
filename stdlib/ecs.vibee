// =============================================================================
// Vibee OS â€” ECS Module
// Entity Component System for game development
// =============================================================================

use vector::{Vec2, Vec3}

// -----------------------------------------------------------------------------
// Entity
// -----------------------------------------------------------------------------

/// Unique entity identifier with generational index
struct Entity {
    id: UInt64
    generation: UInt32
    
    fn new(id: UInt64, generation: UInt32) -> Self { Entity { id: id, generation: generation } }
    fn null() -> Self { Entity { id: 0, generation: 0 } }
    fn is_valid() -> Bool { self.id != 0 }
    fn index() -> UInt64 { self.id }
}

impl Eq for Entity {
    fn eq(other: Entity) -> Bool { self.id == other.id && self.generation == other.generation }
}

impl Hash for Entity {
    fn hash() -> UInt64 { self.id ^ (self.generation as UInt64 << 32) }
}

// -----------------------------------------------------------------------------
// Component Trait
// -----------------------------------------------------------------------------

/// Trait for all components
trait Component {
    fn type_id() -> TypeId
}

/// Type identifier for components
struct TypeId {
    id: UInt64
    fn of<T>() -> Self { TypeId { id: @native("type_id_of", T) } }
}

impl Eq for TypeId { fn eq(other: TypeId) -> Bool { self.id == other.id } }
impl Hash for TypeId { fn hash() -> UInt64 { self.id } }

// -----------------------------------------------------------------------------
// Sparse Set Storage
// -----------------------------------------------------------------------------

/// Sparse set for efficient component storage
struct SparseSet<T: Component> {
    sparse: [Option<UInt64>]
    dense: [Entity]
    components: [T]
    
    fn new() -> Self { SparseSet { sparse: [], dense: [], components: [] } }
    
    fn insert(entity: Entity, component: T) {
        let idx = entity.index() as Int
        while self.sparse.len() <= idx { self.sparse.push(None) }
        
        if let Some(di) = self.sparse[idx] {
            self.components[di as Int] = component
        } else {
            self.sparse[idx] = Some(self.dense.len() as UInt64)
            self.dense.push(entity)
            self.components.push(component)
        }
    }
    
    fn get(entity: Entity) -> Option<&T> {
        let idx = entity.index() as Int
        if idx >= self.sparse.len() { return None }
        self.sparse[idx].map(|di| &self.components[di as Int])
    }
    
    fn get_mut(entity: Entity) -> Option<&mut T> {
        let idx = entity.index() as Int
        if idx >= self.sparse.len() { return None }
        self.sparse[idx].map(|di| &mut self.components[di as Int])
    }
    
    fn has(entity: Entity) -> Bool {
        let idx = entity.index() as Int
        idx < self.sparse.len() && self.sparse[idx].is_some()
    }
    
    fn remove(entity: Entity) -> Option<T> {
        let idx = entity.index() as Int
        if idx >= self.sparse.len() { return None }
        
        if let Some(di) = self.sparse[idx] {
            let last = self.dense[self.dense.len() - 1]
            self.sparse[last.index() as Int] = Some(di)
            self.sparse[idx] = None
            self.dense.swap_remove(di as Int)
            Some(self.components.swap_remove(di as Int))
        } else { None }
    }
    
    fn len() -> Int { self.dense.len() }
    fn is_empty() -> Bool { self.dense.is_empty() }
    fn clear() { self.sparse.clear(); self.dense.clear(); self.components.clear() }
}

// -----------------------------------------------------------------------------
// World
// -----------------------------------------------------------------------------

/// The main ECS world containing all entities and components
struct World {
    entities: [EntityEntry]
    free_list: [UInt64]
    storages: Map<TypeId, Any>
    resources: Map<TypeId, Any>
    
    fn new() -> Self {
        World { entities: [], free_list: [], storages: Map.new(), resources: Map.new() }
    }
    
    /// Create a new entity
    fn spawn() -> Entity {
        if let Some(id) = self.free_list.pop() {
            self.entities[id as Int].alive = true
            Entity.new(id + 1, self.entities[id as Int].generation)
        } else {
            let id = self.entities.len() as UInt64
            self.entities.push(EntityEntry { generation: 0, alive: true })
            Entity.new(id + 1, 0)
        }
    }
    
    /// Spawn entity with builder pattern
    fn spawn_with() -> EntityBuilder {
        EntityBuilder { world: self, entity: self.spawn() }
    }
    
    /// Destroy an entity
    fn despawn(entity: Entity) -> Bool {
        let idx = (entity.id - 1) as Int
        if idx >= self.entities.len() { return false }
        let entry = &mut self.entities[idx]
        if !entry.alive || entry.generation != entity.generation { return false }
        entry.alive = false
        entry.generation += 1
        self.free_list.push(entity.id - 1)
        true
    }
    
    /// Check if entity is alive
    fn is_alive(entity: Entity) -> Bool {
        let idx = (entity.id - 1) as Int
        idx < self.entities.len() && self.entities[idx].alive && 
        self.entities[idx].generation == entity.generation
    }
    
    /// Add component to entity
    fn add<T: Component>(entity: Entity, component: T) {
        let tid = TypeId.of::<T>()
        if !self.storages.contains_key(tid) {
            self.storages.insert(tid, SparseSet::<T>.new())
        }
        (self.storages.get_mut(tid).unwrap() as &mut SparseSet<T>).insert(entity, component)
    }
    
    /// Get component reference
    fn get<T: Component>(entity: Entity) -> Option<&T> {
        let tid = TypeId.of::<T>()
        self.storages.get(tid).and_then(|s| (s as &SparseSet<T>).get(entity))
    }
    
    /// Get mutable component reference
    fn get_mut<T: Component>(entity: Entity) -> Option<&mut T> {
        let tid = TypeId.of::<T>()
        self.storages.get_mut(tid).and_then(|s| (s as &mut SparseSet<T>).get_mut(entity))
    }
    
    /// Check if entity has component
    fn has<T: Component>(entity: Entity) -> Bool {
        let tid = TypeId.of::<T>()
        self.storages.get(tid).map(|s| (s as &SparseSet<T>).has(entity)).unwrap_or(false)
    }
    
    /// Remove component from entity
    fn remove<T: Component>(entity: Entity) -> Option<T> {
        let tid = TypeId.of::<T>()
        self.storages.get_mut(tid).and_then(|s| (s as &mut SparseSet<T>).remove(entity))
    }
    
    /// Add global resource
    fn insert_resource<T>(resource: T) {
        self.resources.insert(TypeId.of::<T>(), resource)
    }
    
    /// Get resource reference
    fn resource<T>() -> Option<&T> {
        self.resources.get(TypeId.of::<T>()).map(|r| r as &T)
    }
    
    /// Get mutable resource reference
    fn resource_mut<T>() -> Option<&mut T> {
        self.resources.get_mut(TypeId.of::<T>()).map(|r| r as &mut T)
    }
    
    /// Query single component
    fn query<T: Component>() -> Query<T> { Query { world: self } }
    
    /// Query two components
    fn query2<A: Component, B: Component>() -> Query2<A, B> { Query2 { world: self } }
    
    /// Query three components
    fn query3<A: Component, B: Component, C: Component>() -> Query3<A, B, C> { Query3 { world: self } }
    
    /// Get entity count
    fn entity_count() -> Int {
        self.entities.iter().filter(|e| e.alive).count()
    }
    
    /// Clear all entities
    fn clear() {
        self.entities.clear()
        self.free_list.clear()
        for (_, s) in self.storages.iter_mut() { s.clear() }
    }
}

struct EntityEntry { generation: UInt32, alive: Bool }

// -----------------------------------------------------------------------------
// Entity Builder
// -----------------------------------------------------------------------------

/// Builder pattern for creating entities with components
struct EntityBuilder {
    world: &mut World
    entity: Entity
    
    fn with<T: Component>(component: T) -> Self {
        self.world.add(self.entity, component)
        self
    }
    
    fn build() -> Entity { self.entity }
}

// -----------------------------------------------------------------------------
// Queries
// -----------------------------------------------------------------------------

/// Query for single component type
struct Query<T: Component> {
    world: &World
    
    fn for_each(f: fn(Entity, &T)) {
        let tid = TypeId.of::<T>()
        if let Some(s) = self.world.storages.get(tid) {
            let storage = s as &SparseSet<T>
            for i in 0..storage.len() {
                f(storage.dense[i], &storage.components[i])
            }
        }
    }
    
    fn for_each_mut(f: fn(Entity, &mut T)) {
        let tid = TypeId.of::<T>()
        if let Some(s) = self.world.storages.get_mut(tid) {
            let storage = s as &mut SparseSet<T>
            for i in 0..storage.len() {
                f(storage.dense[i], &mut storage.components[i])
            }
        }
    }
    
    fn count() -> Int {
        let tid = TypeId.of::<T>()
        self.world.storages.get(tid).map(|s| (s as &SparseSet<T>).len()).unwrap_or(0)
    }
}

/// Query for two component types
struct Query2<A: Component, B: Component> {
    world: &World
    
    fn for_each(f: fn(Entity, &A, &B)) {
        let ta = TypeId.of::<A>()
        let tb = TypeId.of::<B>()
        if let (Some(sa), Some(sb)) = (self.world.storages.get(ta), self.world.storages.get(tb)) {
            let storage_a = sa as &SparseSet<A>
            let storage_b = sb as &SparseSet<B>
            for i in 0..storage_a.len() {
                let entity = storage_a.dense[i]
                if let Some(b) = storage_b.get(entity) {
                    f(entity, &storage_a.components[i], b)
                }
            }
        }
    }
}

/// Query for three component types
struct Query3<A: Component, B: Component, C: Component> {
    world: &World
    
    fn for_each(f: fn(Entity, &A, &B, &C)) {
        let ta = TypeId.of::<A>()
        let tb = TypeId.of::<B>()
        let tc = TypeId.of::<C>()
        if let (Some(sa), Some(sb), Some(sc)) = (
            self.world.storages.get(ta), 
            self.world.storages.get(tb),
            self.world.storages.get(tc)
        ) {
            let storage_a = sa as &SparseSet<A>
            let storage_b = sb as &SparseSet<B>
            let storage_c = sc as &SparseSet<C>
            for i in 0..storage_a.len() {
                let entity = storage_a.dense[i]
                if let (Some(b), Some(c)) = (storage_b.get(entity), storage_c.get(entity)) {
                    f(entity, &storage_a.components[i], b, c)
                }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// System Trait
// -----------------------------------------------------------------------------

/// Trait for systems that process entities
trait System {
    fn run(world: &mut World)
    fn name() -> String { "System" }
}

/// System scheduler
struct Scheduler {
    systems: [Box<dyn System>]
    
    fn new() -> Self { Scheduler { systems: [] } }
    
    fn add<S: System>(system: S) -> Self { 
        self.systems.push(Box.new(system))
        self 
    }
    
    fn run(world: &mut World) { 
        for s in self.systems.iter() { s.run(world) } 
    }
    
    fn run_parallel(world: &mut World) {
        @native("ecs_run_parallel", self.systems, world)
    }
}

// -----------------------------------------------------------------------------
// Common Components
// -----------------------------------------------------------------------------

/// 3D Transform component
struct Transform {
    position: Vec3
    rotation: Vec3
    scale: Vec3
    
    fn new() -> Self { 
        Transform { position: Vec3.zero(), rotation: Vec3.zero(), scale: Vec3.one() } 
    }
    
    fn from_position(p: Vec3) -> Self { 
        Transform { position: p, rotation: Vec3.zero(), scale: Vec3.one() } 
    }
    
    fn translate(delta: Vec3) { self.position = self.position + delta }
    fn rotate(delta: Vec3) { self.rotation = self.rotation + delta }
    
    fn forward() -> Vec3 {
        let yaw = self.rotation.y
        Vec3.new(-yaw.sin(), 0.0, -yaw.cos()).normalize()
    }
    
    fn right() -> Vec3 {
        let yaw = self.rotation.y
        Vec3.new(yaw.cos(), 0.0, -yaw.sin()).normalize()
    }
}

impl Component for Transform { fn type_id() -> TypeId { TypeId.of::<Transform>() } }

/// 2D Transform component
struct Transform2D {
    position: Vec2
    rotation: Float
    scale: Vec2
    
    fn new() -> Self { 
        Transform2D { position: Vec2.zero(), rotation: 0.0, scale: Vec2.one() } 
    }
    
    fn from_position(p: Vec2) -> Self { 
        Transform2D { position: p, rotation: 0.0, scale: Vec2.one() } 
    }
    
    fn translate(delta: Vec2) { self.position = self.position + delta }
    fn rotate(delta: Float) { self.rotation += delta }
}

impl Component for Transform2D { fn type_id() -> TypeId { TypeId.of::<Transform2D>() } }

/// 3D Velocity component
struct Velocity {
    linear: Vec3
    angular: Vec3
    
    fn new() -> Self { Velocity { linear: Vec3.zero(), angular: Vec3.zero() } }
    fn from_linear(v: Vec3) -> Self { Velocity { linear: v, angular: Vec3.zero() } }
}

impl Component for Velocity { fn type_id() -> TypeId { TypeId.of::<Velocity>() } }

/// 2D Velocity component
struct Velocity2D {
    linear: Vec2
    angular: Float
    
    fn new() -> Self { Velocity2D { linear: Vec2.zero(), angular: 0.0 } }
    fn from_linear(v: Vec2) -> Self { Velocity2D { linear: v, angular: 0.0 } }
}

impl Component for Velocity2D { fn type_id() -> TypeId { TypeId.of::<Velocity2D>() } }

/// Tag component for marking entities
struct Tag {
    name: String
    fn new(name: String) -> Self { Tag { name: name } }
}

impl Component for Tag { fn type_id() -> TypeId { TypeId.of::<Tag>() } }

/// Parent component for hierarchy
struct Parent { entity: Entity }
impl Component for Parent { fn type_id() -> TypeId { TypeId.of::<Parent>() } }

/// Children component for hierarchy
struct Children {
    entities: [Entity]
    
    fn new() -> Self { Children { entities: [] } }
    fn add(child: Entity) { self.entities.push(child) }
    fn remove(child: Entity) -> Bool {
        if let Some(idx) = self.entities.iter().position(|e| e == child) {
            self.entities.remove(idx)
            true
        } else { false }
    }
}

impl Component for Children { fn type_id() -> TypeId { TypeId.of::<Children>() } }

// -----------------------------------------------------------------------------
// Events
// -----------------------------------------------------------------------------

/// Event queue for communication between systems
struct Events<T> {
    events: [T]
    read_index: Int
    
    fn new() -> Self { Events { events: [], read_index: 0 } }
    fn send(event: T) { self.events.push(event) }
    fn iter() -> &[T] { &self.events[self.read_index..] }
    fn clear() { self.read_index = self.events.len() }
    fn flush() { self.events.clear(); self.read_index = 0 }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "entity creation" {
    var world = World.new()
    let e1 = world.spawn()
    let e2 = world.spawn()
    assert(e1.is_valid() && e2.is_valid())?
    assert(e1 != e2)?
}

test "component operations" {
    var world = World.new()
    let e = world.spawn()
    world.add(e, Transform.new())
    assert(world.has::<Transform>(e))?
    let t = world.get::<Transform>(e)?
    assert_eq(t.position, Vec3.zero())?
}

test "entity despawn" {
    var world = World.new()
    let e = world.spawn()
    assert(world.is_alive(e))?
    world.despawn(e)
    assert(!world.is_alive(e))?
}

test "query iteration" {
    var world = World.new()
    for i in 0..5 { 
        let e = world.spawn()
        world.add(e, Transform2D.from_position(Vec2.new(i as Float, 0.0))) 
    }
    var count = 0
    world.query::<Transform2D>().for_each(|_, _| { count += 1 })
    assert_eq(count, 5)?
}

test "entity builder" {
    var world = World.new()
    let e = world.spawn_with()
        .with(Transform.new())
        .with(Velocity.new())
        .with(Tag.new("player"))
        .build()
    assert(world.has::<Transform>(e) && world.has::<Velocity>(e) && world.has::<Tag>(e))?
}
