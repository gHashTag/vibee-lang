// =============================================================================
// Vibee OS â€” Dead Letter Queue Module
// Failed message handling and recovery
// =============================================================================

// -----------------------------------------------------------------------------
// Dead Letter Entry
// -----------------------------------------------------------------------------

/// Dead letter entry with failure context
struct DeadLetterEntry {
    id: String
    original_id: String
    payload: [Byte]
    headers: Map<String, String>
    source_queue: String
    failure_reason: String
    failure_time: Instant
    original_created_at: Instant
    retry_count: Int
    error_details: Option<String>
    stack_trace: Option<String>
    
    fn new(payload: [Byte], source: String, reason: String) -> Self {
        DeadLetterEntry {
            id: UUID.v4(),
            original_id: "",
            payload: payload,
            headers: Map.empty(),
            source_queue: source,
            failure_reason: reason,
            failure_time: Instant.now(),
            original_created_at: Instant.now(),
            retry_count: 0,
            error_details: None,
            stack_trace: None
        }
    }
    
    fn from_message<M: HasPayload + HasId>(msg: M, source: String, reason: String) -> Self {
        DeadLetterEntry {
            id: UUID.v4(),
            original_id: msg.id(),
            payload: msg.payload(),
            headers: msg.headers().unwrap_or(Map.empty()),
            source_queue: source,
            failure_reason: reason,
            failure_time: Instant.now(),
            original_created_at: msg.created_at().unwrap_or(Instant.now()),
            retry_count: msg.retry_count().unwrap_or(0),
            error_details: None,
            stack_trace: None
        }
    }
    
    fn with_error_details(details: String) -> Self {
        self.error_details = Some(details)
        self
    }
    
    fn with_stack_trace(trace: String) -> Self {
        self.stack_trace = Some(trace)
        self
    }
    
    fn age() -> Duration {
        Instant.now() - self.failure_time
    }
    
    fn as_string() -> Result<String, DecodeError> {
        String.from_utf8(self.payload)
    }
    
    fn as_json<T: Deserialize>() -> Result<T, DecodeError> {
        JSON.parse(self.as_string()?)
    }
}

/// Trait for messages that can be dead-lettered
trait HasPayload {
    fn payload() -> [Byte]
}

trait HasId {
    fn id() -> String
    fn headers() -> Option<Map<String, String>> { None }
    fn created_at() -> Option<Instant> { None }
    fn retry_count() -> Option<Int> { None }
}

// -----------------------------------------------------------------------------
// Dead Letter Queue
// -----------------------------------------------------------------------------

/// Dead letter queue for failed messages
actor DeadLetterQueue {
    state entries: Deque<DeadLetterEntry>
    state by_source: Map<String, [DeadLetterEntry]>
    state by_reason: Map<String, [DeadLetterEntry]>
    state max_size: Int
    state retention_period: Duration
    state metrics: DeadLetterMetrics
    state handlers: Map<String, fn(DeadLetterEntry) -> ReprocessResult>
    
    fn new() -> Self {
        DeadLetterQueue {
            entries: Deque.new(),
            by_source: Map.empty(),
            by_reason: Map.empty(),
            max_size: 10000,
            retention_period: Duration.days(7),
            metrics: DeadLetterMetrics.new(),
            handlers: Map.empty()
        }
    }
    
    fn with_max_size(size: Int) -> Self {
        let mut q = Self.new()
        q.max_size = size
        q
    }
    
    fn with_retention(period: Duration) -> Self {
        let mut q = Self.new()
        q.retention_period = period
        q
    }
    
    /// Send message to dead letter queue
    fn send(entry: DeadLetterEntry) {
        // Enforce max size
        while self.entries.len() >= self.max_size {
            if let Some(old) = self.entries.pop_front() {
                self.remove_from_indexes(old)
                self.metrics.evicted += 1
            }
        }
        
        // Add to indexes
        self.by_source.entry(entry.source_queue.clone())
            .or_default().push(entry.clone())
        self.by_reason.entry(entry.failure_reason.clone())
            .or_default().push(entry.clone())
        
        self.entries.push_back(entry)
        self.metrics.received += 1
    }
    
    /// Send with simple parameters
    fn send_simple(payload: [Byte], source: String, reason: String) {
        self.send(DeadLetterEntry.new(payload, source, reason))
    }
    
    /// Get all entries
    fn get_all() -> [DeadLetterEntry] {
        self.entries.to_vec()
    }
    
    /// Get entries by source queue
    fn get_by_source(source: String) -> [DeadLetterEntry] {
        self.by_source.get(source).unwrap_or([])
    }
    
    /// Get entries by failure reason
    fn get_by_reason(reason: String) -> [DeadLetterEntry] {
        self.by_reason.get(reason).unwrap_or([])
    }
    
    /// Get entry by ID
    fn get(id: String) -> Option<DeadLetterEntry> {
        self.entries.iter().find(|e| e.id == id)
    }
    
    /// Remove entry
    fn remove(id: String) -> Option<DeadLetterEntry> {
        var found_idx = None
        for (i, entry) in self.entries.iter().enumerate() {
            if entry.id == id {
                found_idx = Some(i)
                break
            }
        }
        
        match found_idx {
            Some(idx) => {
                // Remove from deque (rebuild without this entry)
                var new_entries = Deque.new()
                var removed = None
                for (i, entry) in self.entries.iter().enumerate() {
                    if i == idx {
                        removed = Some(entry)
                        self.remove_from_indexes(entry)
                    } else {
                        new_entries.push_back(entry)
                    }
                }
                self.entries = new_entries
                removed
            }
            None => None
        }
    }
    
    fn remove_from_indexes(entry: DeadLetterEntry) {
        if let Some(list) = self.by_source.get_mut(entry.source_queue) {
            list.retain(|e| e.id != entry.id)
        }
        if let Some(list) = self.by_reason.get_mut(entry.failure_reason) {
            list.retain(|e| e.id != entry.id)
        }
    }
    
    /// Register reprocess handler for source queue
    fn register_handler(source: String, handler: fn(DeadLetterEntry) -> ReprocessResult) {
        self.handlers.set(source, handler)
    }
    
    /// Reprocess single entry
    fn reprocess(id: String) -> Result<ReprocessResult, DeadLetterError> {
        let entry = self.get(id).ok_or(DeadLetterError.EntryNotFound)?
        
        let handler = self.handlers.get(entry.source_queue.clone())
            .ok_or(DeadLetterError.NoHandler)?
        
        let result = handler(entry.clone())
        
        match result {
            ReprocessResult.Success => {
                self.remove(id)
                self.metrics.reprocessed += 1
            }
            ReprocessResult.PermanentFailure(_) => {
                self.metrics.permanent_failures += 1
            }
            ReprocessResult.RetryLater => {
                // Keep in queue
            }
        }
        
        Ok(result)
    }
    
    /// Reprocess all entries for a source
    fn reprocess_source(source: String) -> ReprocessSummary {
        let entries = self.get_by_source(source)
        var summary = ReprocessSummary.new()
        
        for entry in entries {
            match self.reprocess(entry.id) {
                Ok(ReprocessResult.Success) => summary.success += 1
                Ok(ReprocessResult.PermanentFailure(_)) => summary.permanent_failures += 1
                Ok(ReprocessResult.RetryLater) => summary.retry_later += 1
                Err(_) => summary.errors += 1
            }
        }
        
        summary
    }
    
    /// Reprocess all entries
    fn reprocess_all() -> ReprocessSummary {
        var summary = ReprocessSummary.new()
        let entries = self.get_all()
        
        for entry in entries {
            match self.reprocess(entry.id) {
                Ok(ReprocessResult.Success) => summary.success += 1
                Ok(ReprocessResult.PermanentFailure(_)) => summary.permanent_failures += 1
                Ok(ReprocessResult.RetryLater) => summary.retry_later += 1
                Err(_) => summary.errors += 1
            }
        }
        
        summary
    }
    
    /// Purge old entries
    fn purge_expired() -> Int {
        let cutoff = Instant.now() - self.retention_period
        var purged = 0
        
        while let Some(entry) = self.entries.front() {
            if entry.failure_time < cutoff {
                self.entries.pop_front()
                self.remove_from_indexes(entry)
                purged += 1
                self.metrics.purged += 1
            } else {
                break
            }
        }
        
        purged
    }
    
    /// Purge all entries
    fn purge_all() -> Int {
        let count = self.entries.len()
        self.entries.clear()
        self.by_source.clear()
        self.by_reason.clear()
        self.metrics.purged += count
        count
    }
    
    /// Get statistics
    fn stats() -> DeadLetterStats {
        var by_source = Map.empty()
        for (source, entries) in self.by_source {
            by_source.set(source, entries.len())
        }
        
        var by_reason = Map.empty()
        for (reason, entries) in self.by_reason {
            by_reason.set(reason, entries.len())
        }
        
        DeadLetterStats {
            total_count: self.entries.len(),
            by_source: by_source,
            by_reason: by_reason,
            oldest_age: self.entries.front().map(|e| e.age()),
            newest_age: self.entries.back().map(|e| e.age())
        }
    }
    
    fn metrics() -> DeadLetterMetrics { self.metrics.clone() }
    fn len() -> Int { self.entries.len() }
    fn is_empty() -> Bool { self.entries.is_empty() }
}

/// Reprocess result
enum ReprocessResult {
    Success
    PermanentFailure(String)
    RetryLater
}

/// Reprocess summary
struct ReprocessSummary {
    success: Int
    permanent_failures: Int
    retry_later: Int
    errors: Int
    
    fn new() -> Self {
        ReprocessSummary { success: 0, permanent_failures: 0, retry_later: 0, errors: 0 }
    }
    
    fn total() -> Int {
        self.success + self.permanent_failures + self.retry_later + self.errors
    }
}

/// Dead letter statistics
struct DeadLetterStats {
    total_count: Int
    by_source: Map<String, Int>
    by_reason: Map<String, Int>
    oldest_age: Option<Duration>
    newest_age: Option<Duration>
}

/// Dead letter metrics
struct DeadLetterMetrics {
    received: Int
    reprocessed: Int
    permanent_failures: Int
    purged: Int
    evicted: Int
    
    fn new() -> Self {
        DeadLetterMetrics {
            received: 0, reprocessed: 0, permanent_failures: 0, purged: 0, evicted: 0
        }
    }
}

// -----------------------------------------------------------------------------
// Dead Letter Policy
// -----------------------------------------------------------------------------

/// Policy for when to dead-letter messages
struct DeadLetterPolicy {
    max_retries: Int
    max_age: Option<Duration>
    dead_letter_on_rejection: Bool
    dead_letter_on_timeout: Bool
    dead_letter_on_error: Bool
    
    fn default() -> Self {
        DeadLetterPolicy {
            max_retries: 3,
            max_age: None,
            dead_letter_on_rejection: true,
            dead_letter_on_timeout: true,
            dead_letter_on_error: true
        }
    }
    
    fn strict() -> Self {
        DeadLetterPolicy {
            max_retries: 0,
            max_age: Some(Duration.hours(1)),
            dead_letter_on_rejection: true,
            dead_letter_on_timeout: true,
            dead_letter_on_error: true
        }
    }
    
    fn lenient() -> Self {
        DeadLetterPolicy {
            max_retries: 10,
            max_age: Some(Duration.days(1)),
            dead_letter_on_rejection: false,
            dead_letter_on_timeout: false,
            dead_letter_on_error: true
        }
    }
    
    fn should_dead_letter(reason: FailureReason, retry_count: Int, age: Duration) -> Bool {
        // Check retry limit
        if retry_count >= self.max_retries {
            return true
        }
        
        // Check age limit
        if let Some(max_age) = self.max_age {
            if age > max_age {
                return true
            }
        }
        
        // Check reason-specific policies
        match reason {
            FailureReason.Rejected => self.dead_letter_on_rejection
            FailureReason.Timeout => self.dead_letter_on_timeout
            FailureReason.Error(_) => self.dead_letter_on_error
            FailureReason.MaxRetries => true
            FailureReason.Expired => true
        }
    }
}

/// Failure reason
enum FailureReason {
    Rejected
    Timeout
    Error(String)
    MaxRetries
    Expired
    
    fn to_string() -> String {
        match self {
            Rejected => "rejected"
            Timeout => "timeout"
            Error(e) => format!("error: {}", e)
            MaxRetries => "max_retries_exceeded"
            Expired => "expired"
        }
    }
}

// -----------------------------------------------------------------------------
// Dead Letter Monitor
// -----------------------------------------------------------------------------

/// Monitor for dead letter queue alerts
actor DeadLetterMonitor {
    state dlq: DeadLetterQueue
    state thresholds: AlertThresholds
    state alert_handlers: [fn(DeadLetterAlert)]
    state running: Bool
    state check_interval: Duration
    
    fn new(dlq: DeadLetterQueue) -> Self {
        DeadLetterMonitor {
            dlq: dlq,
            thresholds: AlertThresholds.default(),
            alert_handlers: [],
            running: false,
            check_interval: Duration.minutes(1)
        }
    }
    
    fn with_thresholds(thresholds: AlertThresholds) -> Self {
        self.thresholds = thresholds
        self
    }
    
    /// Register alert handler
    fn on_alert(handler: fn(DeadLetterAlert)) {
        self.alert_handlers.push(handler)
    }
    
    /// Start monitoring
    fn start() {
        if self.running { return }
        self.running = true
        spawn { self.monitor_loop() }
    }
    
    /// Stop monitoring
    fn stop() {
        self.running = false
    }
    
    fn monitor_loop() {
        while self.running {
            self.check_alerts()
            @native("sleep", self.check_interval)
        }
    }
    
    fn check_alerts() {
        let stats = self.dlq.stats()
        
        // Check total count threshold
        if stats.total_count >= self.thresholds.max_count {
            self.emit_alert(DeadLetterAlert.CountThreshold(stats.total_count))
        }
        
        // Check rate threshold
        let metrics = self.dlq.metrics()
        // Would need rate calculation here
        
        // Check age threshold
        if let Some(oldest) = stats.oldest_age {
            if oldest > self.thresholds.max_age {
                self.emit_alert(DeadLetterAlert.AgeThreshold(oldest))
            }
        }
        
        // Check per-source thresholds
        for (source, count) in stats.by_source {
            if count >= self.thresholds.max_per_source {
                self.emit_alert(DeadLetterAlert.SourceThreshold(source, count))
            }
        }
    }
    
    fn emit_alert(alert: DeadLetterAlert) {
        for handler in self.alert_handlers {
            handler(alert.clone())
        }
    }
}

/// Alert thresholds
struct AlertThresholds {
    max_count: Int
    max_rate_per_minute: Int
    max_age: Duration
    max_per_source: Int
    
    fn default() -> Self {
        AlertThresholds {
            max_count: 1000,
            max_rate_per_minute: 100,
            max_age: Duration.hours(24),
            max_per_source: 100
        }
    }
}

/// Dead letter alert
enum DeadLetterAlert {
    CountThreshold(Int)
    RateThreshold(Int)
    AgeThreshold(Duration)
    SourceThreshold(String, Int)
    
    fn message() -> String {
        match self {
            CountThreshold(n) => format!("Dead letter count threshold exceeded: {}", n)
            RateThreshold(r) => format!("Dead letter rate threshold exceeded: {}/min", r)
            AgeThreshold(d) => format!("Dead letter age threshold exceeded: {:?}", d)
            SourceThreshold(s, n) => format!("Dead letter threshold exceeded for {}: {}", s, n)
        }
    }
    
    fn severity() -> AlertSeverity {
        match self {
            CountThreshold(n) if n > 5000 => AlertSeverity.Critical
            CountThreshold(_) => AlertSeverity.Warning
            RateThreshold(r) if r > 500 => AlertSeverity.Critical
            RateThreshold(_) => AlertSeverity.Warning
            AgeThreshold(d) if d > Duration.days(3) => AlertSeverity.Critical
            AgeThreshold(_) => AlertSeverity.Warning
            SourceThreshold(_, n) if n > 500 => AlertSeverity.Critical
            SourceThreshold(_, _) => AlertSeverity.Warning
        }
    }
}

enum AlertSeverity {
    Info
    Warning
    Critical
}

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum DeadLetterError {
    EntryNotFound
    NoHandler
    ReprocessFailed(String)
    
    fn message() -> String {
        match self {
            EntryNotFound => "Dead letter entry not found"
            NoHandler => "No reprocess handler registered"
            ReprocessFailed(e) => format!("Reprocess failed: {}", e)
        }
    }
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "dead letter queue basic" {
    let dlq = DeadLetterQueue.new()
    
    dlq.send_simple("test".bytes(), "orders", "validation_failed")
    
    assert_eq(dlq.len(), 1)?
    
    let entries = dlq.get_by_source("orders")
    assert_eq(entries.len(), 1)?
    assert_eq(entries[0].failure_reason, "validation_failed")?
}

test "dead letter queue indexes" {
    let dlq = DeadLetterQueue.new()
    
    dlq.send_simple("msg1".bytes(), "orders", "timeout")
    dlq.send_simple("msg2".bytes(), "orders", "validation")
    dlq.send_simple("msg3".bytes(), "payments", "timeout")
    
    assert_eq(dlq.get_by_source("orders").len(), 2)?
    assert_eq(dlq.get_by_reason("timeout").len(), 2)?
}

test "dead letter reprocess" {
    let dlq = DeadLetterQueue.new()
    
    dlq.send_simple("test".bytes(), "orders", "temp_failure")
    let entry = dlq.get_all()[0]
    
    dlq.register_handler("orders", |e| ReprocessResult.Success)
    
    let result = dlq.reprocess(entry.id)?
    assert_eq(result, ReprocessResult.Success)?
    assert_eq(dlq.len(), 0)?
}

test "dead letter policy" {
    let policy = DeadLetterPolicy.default()
    
    assert(policy.should_dead_letter(FailureReason.MaxRetries, 3, Duration.zero()))?
    assert(!policy.should_dead_letter(FailureReason.Error("test".to_string()), 1, Duration.zero()))?
}

test "dead letter stats" {
    let dlq = DeadLetterQueue.new()
    
    dlq.send_simple("a".bytes(), "q1", "r1")
    dlq.send_simple("b".bytes(), "q1", "r2")
    dlq.send_simple("c".bytes(), "q2", "r1")
    
    let stats = dlq.stats()
    assert_eq(stats.total_count, 3)?
    assert_eq(stats.by_source.get("q1"), Some(2))?
    assert_eq(stats.by_reason.get("r1"), Some(2))?
}

test "dead letter purge" {
    let dlq = DeadLetterQueue.with_retention(Duration.milliseconds(10))
    
    dlq.send_simple("old".bytes(), "test", "reason")
    @native("sleep", Duration.milliseconds(20))
    
    let purged = dlq.purge_expired()
    assert_eq(purged, 1)?
    assert(dlq.is_empty())?
}
