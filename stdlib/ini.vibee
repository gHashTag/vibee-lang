// =============================================================================
// Vibee OS â€” INI Module
// INI file parsing and generation
// =============================================================================

// -----------------------------------------------------------------------------
// INI Value Types
// -----------------------------------------------------------------------------

enum Value {
    String(String)
    Int(Int)
    Float(Float)
    Bool(Bool)
    
    fn as_str() -> Option<String> { match self { .String(s) => Some(s), _ => None } }
    fn as_int() -> Option<Int> { match self { .Int(i) => Some(i), _ => None } }
    fn as_float() -> Option<Float> { match self { .Float(f) => Some(f), _ => None } }
    fn as_bool() -> Option<Bool> { match self { .Bool(b) => Some(b), _ => None } }
    
    fn to_string() -> String {
        match self {
            .String(s) => s
            .Int(i) => "\(i)"
            .Float(f) => "\(f)"
            .Bool(b) => if b { "true" } else { "false" }
        }
    }
}

struct Section {
    name: String
    values: Map<String, Value>
    comments: Map<String, String>
    
    fn new(name: String) -> Self {
        Section { name: name, values: Map.empty(), comments: Map.empty() }
    }
    
    fn get(key: String) -> Option<Value> { self.values.get(key) }
    fn get_str(key: String) -> Option<String> { self.values.get(key)?.as_str() }
    fn get_int(key: String) -> Option<Int> { self.values.get(key)?.as_int() }
    fn get_float(key: String) -> Option<Float> { self.values.get(key)?.as_float() }
    fn get_bool(key: String) -> Option<Bool> { self.values.get(key)?.as_bool() }
    
    fn get_or(key: String, default: String) -> String { self.get_str(key).unwrap_or(default) }
    fn get_int_or(key: String, default: Int) -> Int { self.get_int(key).unwrap_or(default) }
    fn get_bool_or(key: String, default: Bool) -> Bool { self.get_bool(key).unwrap_or(default) }
    
    fn set(key: String, value: Value) -> Self { self.values.set(key, value); self }
    fn set_str(key: String, value: String) -> Self { self.set(key, Value.String(value)) }
    fn set_int(key: String, value: Int) -> Self { self.set(key, Value.Int(value)) }
    fn set_bool(key: String, value: Bool) -> Self { self.set(key, Value.Bool(value)) }
    fn set_comment(key: String, comment: String) -> Self { self.comments.set(key, comment); self }
    
    fn remove(key: String) -> Self { self.values.remove(key); self }
    fn keys() -> [String] { self.values.keys() }
    fn len() -> Int { self.values.len() }
    fn is_empty() -> Bool { self.values.is_empty() }
}

impl Index<String> for Section {
    type Output = Option<Value>
    fn index(key: String) -> Option<Value> { self.get(key) }
}

// -----------------------------------------------------------------------------
// INI Document
// -----------------------------------------------------------------------------

struct Document {
    sections: Map<String, Section>
    global: Section
    header_comment: Option<String>
    
    fn new() -> Self {
        Document { sections: Map.empty(), global: Section.new(""), header_comment: None }
    }
    
    fn parse(ini: String) -> Result<Document, INIError> { Parser.new(ini).parse() }
    
    fn parse_file(path: String) -> Result<Document, INIError> {
        let content = File.read_string(path)?
        Self.parse(content)
    }
    
    fn section(name: String) -> Option<Section> { self.sections.get(name) }
    
    fn get(section: String, key: String) -> Option<Value> {
        self.sections.get(section)?.get(key)
    }
    
    fn get_global(key: String) -> Option<Value> { self.global.get(key) }
    
    fn set(section: String, key: String, value: Value) -> Self {
        let sec = self.sections.entry(section).or_insert(Section.new(section))
        sec.set(key, value)
        self
    }
    
    fn set_global(key: String, value: Value) -> Self { self.global.set(key, value); self }
    
    fn add_section(name: String) -> Self {
        if !self.sections.contains(name) {
            self.sections.set(name, Section.new(name))
        }
        self
    }
    
    fn remove_section(name: String) -> Self { self.sections.remove(name); self }
    fn section_names() -> [String] { self.sections.keys() }
    fn has_section(name: String) -> Bool { self.sections.contains(name) }
    fn set_header_comment(comment: String) -> Self { self.header_comment = Some(comment); self }
    
    fn to_ini() -> String { Emitter.new().emit(self) }
    fn to_ini_with_options(options: EmitOptions) -> String { Emitter.with_options(options).emit(self) }
    
    fn save(path: String) -> Result<(), INIError> {
        File.write_string(path, self.to_ini())?
        Ok(())
    }
    
    fn merge(other: Document) -> Self {
        for (name, section) in other.sections {
            let existing = self.sections.entry(name).or_insert(Section.new(name))
            for (key, value) in section.values { existing.set(key, value) }
        }
        for (key, value) in other.global.values { self.global.set(key, value) }
        self
    }
}

impl Index<String> for Document {
    type Output = Option<Section>
    fn index(name: String) -> Option<Section> { self.section(name) }
}

// -----------------------------------------------------------------------------
// Parser
// -----------------------------------------------------------------------------

struct ParseOptions {
    allow_multiline: Bool
    comment_chars: [Char]
    delimiter: Char
    case_sensitive: Bool
    
    fn default() -> Self {
        ParseOptions {
            allow_multiline: false,
            comment_chars: [';', '#'],
            delimiter: '=',
            case_sensitive: true
        }
    }
}

actor Parser {
    state input: String
    state pos: Int
    state line: Int
    state options: ParseOptions
    
    fn new(input: String) -> Self {
        Parser { input: input, pos: 0, line: 1, options: ParseOptions.default() }
    }
    
    fn with_options(input: String, options: ParseOptions) -> Self {
        Parser { input: input, pos: 0, line: 1, options: options }
    }
    
    fn parse() -> Result<Document, INIError> {
        var doc = Document.new()
        var current_section = doc.global
        var header_comments = []
        
        while self.pos < self.input.len() {
            self.skip_whitespace()
            if self.pos >= self.input.len() { break }
            
            let c = self.input[self.pos]
            
            if self.is_comment_char(c) {
                let comment = self.parse_comment()
                if doc.sections.is_empty() && current_section.is_empty() {
                    header_comments.append(comment)
                }
            } else if c == '[' {
                let name = self.parse_section_header()?
                current_section = doc.sections.entry(name).or_insert(Section.new(name))
            } else if c == '\n' {
                self.pos += 1
                self.line += 1
            } else if !c.is_whitespace() {
                let (key, value, comment) = self.parse_key_value()?
                current_section.set(key, value)
                if let Some(c) = comment { current_section.set_comment(key, c) }
            }
        }
        
        if !header_comments.is_empty() {
            doc.header_comment = Some(header_comments.join("\n"))
        }
        
        Ok(doc)
    }
    
    fn parse_section_header() -> Result<String, INIError> {
        self.expect('[')?
        self.skip_whitespace_inline()
        
        let start = self.pos
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c == ']' || c == '\n' { break }
            self.pos += 1
        }
        let name = self.input[start..self.pos].trim()
        if name.is_empty() { return Err(INIError.EmptySectionName(self.line)) }
        
        self.skip_whitespace_inline()
        self.expect(']')?
        self.skip_to_eol()
        
        Ok(if self.options.case_sensitive { name } else { name.to_lowercase() })
    }
    
    fn parse_key_value() -> Result<(String, Value, Option<String>), INIError> {
        let start = self.pos
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            if c == self.options.delimiter || c == '\n' { break }
            self.pos += 1
        }
        let key = self.input[start..self.pos].trim()
        if key.is_empty() { return Err(INIError.EmptyKey(self.line)) }
        
        self.expect(self.options.delimiter)?
        self.skip_whitespace_inline()
        
        let value = self.parse_value()?
        let comment = self.parse_inline_comment()
        self.skip_to_eol()
        
        Ok((key, value, comment))
    }
    
    fn parse_value() -> Result<Value, INIError> {
        let c = self.peek_char()
        
        if c == Some('"') || c == Some('\'') {
            return Ok(Value.String(self.parse_quoted_string()?))
        }
        
        let start = self.pos
        while self.pos < self.input.len() {
            let ch = self.input[self.pos]
            if ch == '\n' || self.is_comment_char(ch) { break }
            self.pos += 1
        }
        
        let raw = self.input[start..self.pos].trim()
        Ok(self.parse_typed_value(raw))
    }
    
    fn parse_typed_value(raw: String) -> Value {
        let lower = raw.to_lowercase()
        if lower == "true" || lower == "yes" || lower == "on" || lower == "1" { return Value.Bool(true) }
        if lower == "false" || lower == "no" || lower == "off" || lower == "0" { return Value.Bool(false) }
        if let Ok(i) = Int.parse(raw) { return Value.Int(i) }
        if let Ok(f) = Float.parse(raw) { return Value.Float(f) }
        Value.String(raw)
    }
    
    fn parse_quoted_string() -> Result<String, INIError> {
        let quote = self.input[self.pos]
        self.pos += 1
        
        var result = StringBuilder.new()
        while self.pos < self.input.len() {
            let c = self.input[self.pos]
            self.pos += 1
            
            if c == quote { return Ok(result.build()) }
            if c == '\\' && self.pos < self.input.len() {
                let escaped = self.input[self.pos]
                self.pos += 1
                match escaped {
                    'n' => result.append('\n')
                    't' => result.append('\t')
                    'r' => result.append('\r')
                    '\\' => result.append('\\')
                    '"' => result.append('"')
                    '\'' => result.append('\'')
                    _ => { result.append('\\'); result.append(escaped) }
                }
            } else {
                result.append(c)
            }
        }
        Err(INIError.UnterminatedString(self.line))
    }
    
    fn parse_comment() -> String {
        self.pos += 1
        let start = self.pos
        while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1 }
        self.input[start..self.pos].trim()
    }
    
    fn parse_inline_comment() -> Option<String> {
        self.skip_whitespace_inline()
        if let Some(c) = self.peek_char() {
            if self.is_comment_char(c) { return Some(self.parse_comment()) }
        }
        None
    }
    
    fn is_comment_char(c: Char) -> Bool { self.options.comment_chars.contains(c) }
    fn peek_char() -> Option<Char> { if self.pos < self.input.len() { Some(self.input[self.pos]) } else { None } }
    fn expect(c: Char) -> Result<(), INIError> {
        if self.peek_char() == Some(c) { self.pos += 1; Ok(()) }
        else { Err(INIError.Expected(c, self.line)) }
    }
    fn skip_whitespace() { while self.pos < self.input.len() && (self.input[self.pos] == ' ' || self.input[self.pos] == '\t' || self.input[self.pos] == '\r') { self.pos += 1 } }
    fn skip_whitespace_inline() { while self.pos < self.input.len() && (self.input[self.pos] == ' ' || self.input[self.pos] == '\t') { self.pos += 1 } }
    fn skip_to_eol() {
        while self.pos < self.input.len() && self.input[self.pos] != '\n' { self.pos += 1 }
        if self.pos < self.input.len() { self.pos += 1; self.line += 1 }
    }
}

// -----------------------------------------------------------------------------
// Emitter
// -----------------------------------------------------------------------------

struct EmitOptions {
    delimiter: String
    comment_char: Char
    space_around_delimiter: Bool
    blank_line_between_sections: Bool
    quote_strings: Bool
    
    fn default() -> Self {
        EmitOptions {
            delimiter: "=",
            comment_char: ';',
            space_around_delimiter: true,
            blank_line_between_sections: true,
            quote_strings: false
        }
    }
}

actor Emitter {
    state options: EmitOptions
    
    fn new() -> Self { Emitter { options: EmitOptions.default() } }
    fn with_options(options: EmitOptions) -> Self { Emitter { options: options } }
    
    fn emit(doc: Document) -> String {
        var result = StringBuilder.new()
        
        if let Some(comment) = doc.header_comment {
            for line in comment.lines() {
                result.append("\(self.options.comment_char) \(line)\n")
            }
            result.append("\n")
        }
        
        self.emit_section_values(result, doc.global)
        
        for (name, section) in doc.sections {
            if self.options.blank_line_between_sections { result.append("\n") }
            result.append("[\(name)]\n")
            self.emit_section_values(result, section)
        }
        
        result.build()
    }
    
    fn emit_section_values(result: StringBuilder, section: Section) {
        let delim = if self.options.space_around_delimiter { " \(self.options.delimiter) " } else { self.options.delimiter }
        
        for (key, value) in section.values {
            let value_str = self.emit_value(value)
            result.append("\(key)\(delim)\(value_str)")
            if let Some(comment) = section.comments.get(key) {
                result.append(" \(self.options.comment_char) \(comment)")
            }
            result.append("\n")
        }
    }
    
    fn emit_value(value: Value) -> String {
        match value {
            .String(s) => {
                if self.options.quote_strings || s.contains(" ") || s.contains(";") || s.contains("#") {
                    "\"" + s.replace("\\", "\\\\").replace("\"", "\\\"") + "\""
                } else { s }
            }
            .Int(i) => "\(i)"
            .Float(f) => "\(f)"
            .Bool(b) => if b { "true" } else { "false" }
        }
    }
}

// -----------------------------------------------------------------------------
// Builder
// -----------------------------------------------------------------------------

struct Builder {
    doc: Document
    current_section: Option<String>
    
    fn new() -> Self { Builder { doc: Document.new(), current_section: None } }
    
    fn section(name: String) -> Self {
        self.doc.add_section(name)
        self.current_section = Some(name)
        self
    }
    
    fn set(key: String, value: String) -> Self {
        if let Some(section) = self.current_section {
            self.doc.set(section, key, Value.String(value))
        } else { self.doc.set_global(key, Value.String(value)) }
        self
    }
    
    fn set_int(key: String, value: Int) -> Self {
        if let Some(section) = self.current_section {
            self.doc.set(section, key, Value.Int(value))
        } else { self.doc.set_global(key, Value.Int(value)) }
        self
    }
    
    fn set_bool(key: String, value: Bool) -> Self {
        if let Some(section) = self.current_section {
            self.doc.set(section, key, Value.Bool(value))
        } else { self.doc.set_global(key, Value.Bool(value)) }
        self
    }
    
    fn comment(text: String) -> Self { self.doc.set_header_comment(text); self }
    fn build() -> Document { self.doc }
}

fn builder() -> Builder { Builder.new() }

// -----------------------------------------------------------------------------
// Errors
// -----------------------------------------------------------------------------

enum INIError {
    EmptySectionName(Int)
    EmptyKey(Int)
    Expected(Char, Int)
    UnterminatedString(Int)
    IOError(String)
    
    fn message() -> String {
        match self {
            .EmptySectionName(l) => "Empty section name at line \(l)"
            .EmptyKey(l) => "Empty key at line \(l)"
            .Expected(c, l) => "Expected '\(c)' at line \(l)"
            .UnterminatedString(l) => "Unterminated string at line \(l)"
            .IOError(m) => "I/O error: \(m)"
        }
    }
}

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn parse(ini: String) -> Result<Document, INIError> { Document.parse(ini) }
fn parse_file(path: String) -> Result<Document, INIError> { Document.parse_file(path) }

fn from_map(sections: Map<String, Map<String, String>>) -> Document {
    var doc = Document.new()
    for (section_name, values) in sections {
        for (key, value) in values { doc.set(section_name, key, Value.String(value)) }
    }
    doc
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "parse basic ini" {
    let ini = "[database]\nhost = localhost\nport = 5432"
    let doc = parse(ini)?
    
    assert(doc.has_section("database"))
    assert(doc.get("database", "host")?.as_str() == Some("localhost"))
    assert(doc.get("database", "port")?.as_int() == Some(5432))
}

test "parse with comments" {
    let ini = "; Config file\n[server]\nhost = 127.0.0.1 ; local address"
    let doc = parse(ini)?
    
    assert(doc.header_comment.is_some())
    assert(doc.get("server", "host")?.as_str() == Some("127.0.0.1"))
}

test "parse boolean values" {
    let ini = "[flags]\nenabled = true\ndisabled = false\nyes_flag = yes\nno_flag = no"
    let doc = parse(ini)?
    
    assert(doc.get("flags", "enabled")?.as_bool() == Some(true))
    assert(doc.get("flags", "disabled")?.as_bool() == Some(false))
    assert(doc.get("flags", "yes_flag")?.as_bool() == Some(true))
    assert(doc.get("flags", "no_flag")?.as_bool() == Some(false))
}

test "emit ini" {
    let doc = builder()
        .section("database")
        .set("host", "localhost")
        .set_int("port", 5432)
        .set_bool("ssl", true)
        .build()
    
    let ini = doc.to_ini()
    assert(ini.contains("[database]"))
    assert(ini.contains("host = localhost"))
}

test "global section" {
    let ini = "global_key = value\n[section]\nkey = value"
    let doc = parse(ini)?
    
    assert(doc.get_global("global_key")?.as_str() == Some("value"))
    assert(doc.get("section", "key")?.as_str() == Some("value"))
}
