// =============================================================================
// Vibee OS — DateTime Format Module
// Locale-aware date and time formatting
// =============================================================================

use locale.{Locale, Locales}
use datetime.{DateTime, Date, Time, Weekday, Month}

// -----------------------------------------------------------------------------
// DateTime Format
// -----------------------------------------------------------------------------

/// Locale-aware date/time formatter
struct DateTimeFormat {
    locale: Locale
    
    fn for_locale(locale: Locale) -> Self {
        DateTimeFormat { locale: locale }
    }
    
    fn current() -> Self {
        Self.for_locale(Locale.current())
    }
    
    /// Format date with style
    fn format_date(dt: DateTime, style: String = "medium") -> String {
        let pattern = self.get_date_pattern(style)
        self.format_pattern(dt, pattern)
    }
    
    /// Format time with style
    fn format_time(dt: DateTime, style: String = "medium") -> String {
        let pattern = self.get_time_pattern(style)
        self.format_pattern(dt, pattern)
    }
    
    /// Format date and time
    fn format(dt: DateTime, date_style: String = "medium", time_style: String = "medium") -> String {
        let date_part = self.format_date(dt, date_style)
        let time_part = self.format_time(dt, time_style)
        self.combine_datetime(date_part, time_part)
    }
    
    /// Format with custom pattern
    fn format_pattern(dt: DateTime, pattern: String) -> String {
        var result = pattern
        let (y, m, d, h, mi, s, ms) = dt.components()
        
        // Year
        result = result.replace("yyyy", y.to_string().pad_left(4, '0'))
        result = result.replace("yy", (y % 100).to_string().pad_left(2, '0'))
        
        // Month
        result = result.replace("MMMM", self.month_name(m))
        result = result.replace("MMM", self.month_short(m))
        result = result.replace("MM", m.to_string().pad_left(2, '0'))
        result = result.replace("M", m.to_string())
        
        // Day
        result = result.replace("dd", d.to_string().pad_left(2, '0'))
        result = result.replace("d", d.to_string())
        
        // Weekday
        result = result.replace("EEEE", self.weekday_name(dt.weekday()))
        result = result.replace("EEE", self.weekday_short(dt.weekday()))
        result = result.replace("E", self.weekday_narrow(dt.weekday()))
        
        // Hour (24h)
        result = result.replace("HH", h.to_string().pad_left(2, '0'))
        result = result.replace("H", h.to_string())
        
        // Hour (12h)
        let h12 = if h == 0 { 12 } else if h > 12 { h - 12 } else { h }
        result = result.replace("hh", h12.to_string().pad_left(2, '0'))
        result = result.replace("h", h12.to_string())
        
        // AM/PM
        let ampm = if h < 12 { self.am_symbol() } else { self.pm_symbol() }
        result = result.replace("a", ampm)
        
        // Minute
        result = result.replace("mm", mi.to_string().pad_left(2, '0'))
        result = result.replace("m", mi.to_string())
        
        // Second
        result = result.replace("ss", s.to_string().pad_left(2, '0'))
        result = result.replace("s", s.to_string())
        
        result
    }
    
    // Pattern getters
    fn get_date_pattern(style: String) -> String {
        let lang = self.locale.language
        match style {
            "full" => self.full_date_pattern()
            "long" => self.long_date_pattern()
            "short" => self.short_date_pattern()
            _ => self.medium_date_pattern()
        }
    }
    
    fn get_time_pattern(style: String) -> String {
        match style {
            "full" => self.full_time_pattern()
            "long" => self.long_time_pattern()
            "short" => self.short_time_pattern()
            _ => self.medium_time_pattern()
        }
    }
    
    fn full_date_pattern() -> String {
        match self.locale.language {
            "en" => "EEEE, MMMM d, yyyy"
            "ru" => "EEEE, d MMMM yyyy г."
            "de" => "EEEE, d. MMMM yyyy"
            "fr" => "EEEE d MMMM yyyy"
            "es" => "EEEE, d 'de' MMMM 'de' yyyy"
            "zh" => "yyyy年M月d日EEEE"
            "ja" => "yyyy年M月d日EEEE"
            _ => "EEEE, MMMM d, yyyy"
        }
    }
    
    fn long_date_pattern() -> String {
        match self.locale.language {
            "en" => "MMMM d, yyyy"
            "ru" => "d MMMM yyyy г."
            "de" => "d. MMMM yyyy"
            "fr" => "d MMMM yyyy"
            "es" => "d 'de' MMMM 'de' yyyy"
            "zh" => "yyyy年M月d日"
            "ja" => "yyyy年M月d日"
            _ => "MMMM d, yyyy"
        }
    }
    
    fn medium_date_pattern() -> String {
        match self.locale.language {
            "en" => "MMM d, yyyy"
            "ru" => "d MMM yyyy г."
            "de" => "dd.MM.yyyy"
            "fr" => "d MMM yyyy"
            "es" => "d MMM yyyy"
            "zh" => "yyyy年M月d日"
            "ja" => "yyyy/MM/dd"
            _ => "MMM d, yyyy"
        }
    }
    
    fn short_date_pattern() -> String {
        match self.locale.language {
            "en" => if self.locale.region == Some("US") { "M/d/yy" } else { "dd/MM/yy" }
            "ru" => "dd.MM.yy"
            "de" => "dd.MM.yy"
            "fr" => "dd/MM/yy"
            "es" => "d/M/yy"
            "zh" => "yy/M/d"
            "ja" => "yy/MM/dd"
            _ => "M/d/yy"
        }
    }
    
    fn full_time_pattern() -> String {
        if self.uses_24h() { "HH:mm:ss" } else { "h:mm:ss a" }
    }
    
    fn long_time_pattern() -> String {
        if self.uses_24h() { "HH:mm:ss" } else { "h:mm:ss a" }
    }
    
    fn medium_time_pattern() -> String {
        if self.uses_24h() { "HH:mm:ss" } else { "h:mm:ss a" }
    }
    
    fn short_time_pattern() -> String {
        if self.uses_24h() { "HH:mm" } else { "h:mm a" }
    }
    
    fn uses_24h() -> Bool {
        match self.locale.language {
            "en" => self.locale.region != Some("US")
            "zh" | "ja" | "ko" => false
            _ => true
        }
    }
    
    fn combine_datetime(date: String, time: String) -> String {
        match self.locale.language {
            "zh" | "ja" => date + " " + time
            _ => date + ", " + time
        }
    }
    
    // Localized names
    fn month_name(m: Int) -> String {
        let names = match self.locale.language {
            "ru" => ["января", "февраля", "марта", "апреля", "мая", "июня",
                     "июля", "августа", "сентября", "октября", "ноября", "декабря"]
            "de" => ["Januar", "Februar", "März", "April", "Mai", "Juni",
                     "Juli", "August", "September", "Oktober", "November", "Dezember"]
            "fr" => ["janvier", "février", "mars", "avril", "mai", "juin",
                     "juillet", "août", "septembre", "octobre", "novembre", "décembre"]
            "es" => ["enero", "febrero", "marzo", "abril", "mayo", "junio",
                     "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"]
            "zh" => ["一月", "二月", "三月", "四月", "五月", "六月",
                     "七月", "八月", "九月", "十月", "十一月", "十二月"]
            "ja" => ["1月", "2月", "3月", "4月", "5月", "6月",
                     "7月", "8月", "9月", "10月", "11月", "12月"]
            _ => ["January", "February", "March", "April", "May", "June",
                  "July", "August", "September", "October", "November", "December"]
        }
        names[m - 1]
    }
    
    fn month_short(m: Int) -> String {
        let names = match self.locale.language {
            "ru" => ["янв.", "февр.", "март", "апр.", "май", "июнь",
                     "июль", "авг.", "сент.", "окт.", "нояб.", "дек."]
            "de" => ["Jan.", "Feb.", "März", "Apr.", "Mai", "Juni",
                     "Juli", "Aug.", "Sept.", "Okt.", "Nov.", "Dez."]
            "fr" => ["janv.", "févr.", "mars", "avr.", "mai", "juin",
                     "juil.", "août", "sept.", "oct.", "nov.", "déc."]
            _ => ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        }
        names[m - 1]
    }
    
    fn weekday_name(w: Weekday) -> String {
        let names = match self.locale.language {
            "ru" => ["понедельник", "вторник", "среда", "четверг", "пятница", "суббота", "воскресенье"]
            "de" => ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag"]
            "fr" => ["lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi", "dimanche"]
            "es" => ["lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo"]
            _ => ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        }
        names[w.to_int() - 1]
    }
    
    fn weekday_short(w: Weekday) -> String {
        let names = match self.locale.language {
            "ru" => ["пн", "вт", "ср", "чт", "пт", "сб", "вс"]
            "de" => ["Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa.", "So."]
            "fr" => ["lun.", "mar.", "mer.", "jeu.", "ven.", "sam.", "dim."]
            _ => ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        }
        names[w.to_int() - 1]
    }
    
    fn weekday_narrow(w: Weekday) -> String {
        let names = match self.locale.language {
            "ru" => ["П", "В", "С", "Ч", "П", "С", "В"]
            _ => ["M", "T", "W", "T", "F", "S", "S"]
        }
        names[w.to_int() - 1]
    }
    
    fn am_symbol() -> String {
        match self.locale.language {
            "zh" => "上午"
            "ja" => "午前"
            "ko" => "오전"
            _ => "AM"
        }
    }
    
    fn pm_symbol() -> String {
        match self.locale.language {
            "zh" => "下午"
            "ja" => "午後"
            "ko" => "오후"
            _ => "PM"
        }
    }
}

// -----------------------------------------------------------------------------
// Relative Time Format
// -----------------------------------------------------------------------------

/// Format relative time (e.g., "2 days ago", "in 3 hours")
struct RelativeTimeFormat {
    locale: Locale
    style: RelativeTimeStyle
    
    fn for_locale(locale: Locale) -> Self {
        RelativeTimeFormat { locale: locale, style: RelativeTimeStyle.Long }
    }
    
    fn with_style(style: RelativeTimeStyle) -> Self {
        RelativeTimeFormat { locale: self.locale, style: style }
    }
    
    /// Format relative to now
    fn format(dt: DateTime) -> String {
        let now = DateTime.now()
        let diff = dt.diff(now)
        self.format_duration(diff)
    }
    
    /// Format duration as relative time
    fn format_duration(d: Duration) -> String {
        let secs = d.as_seconds()
        let future = secs > 0.0
        let abs_secs = secs.abs()
        
        let (value, unit) = if abs_secs < 60.0 {
            (abs_secs as Int, RelativeTimeUnit.Second)
        } else if abs_secs < 3600.0 {
            ((abs_secs / 60.0) as Int, RelativeTimeUnit.Minute)
        } else if abs_secs < 86400.0 {
            ((abs_secs / 3600.0) as Int, RelativeTimeUnit.Hour)
        } else if abs_secs < 604800.0 {
            ((abs_secs / 86400.0) as Int, RelativeTimeUnit.Day)
        } else if abs_secs < 2592000.0 {
            ((abs_secs / 604800.0) as Int, RelativeTimeUnit.Week)
        } else if abs_secs < 31536000.0 {
            ((abs_secs / 2592000.0) as Int, RelativeTimeUnit.Month)
        } else {
            ((abs_secs / 31536000.0) as Int, RelativeTimeUnit.Year)
        }
        
        self.format_relative(value, unit, future)
    }
    
    fn format_relative(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        let lang = self.locale.language
        
        match lang {
            "en" => self.format_english(value, unit, future)
            "ru" => self.format_russian(value, unit, future)
            "de" => self.format_german(value, unit, future)
            "fr" => self.format_french(value, unit, future)
            "es" => self.format_spanish(value, unit, future)
            "zh" => self.format_chinese(value, unit, future)
            _ => self.format_english(value, unit, future)
        }
    }
    
    fn format_english(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        if value == 0 { return "now" }
        
        let unit_str = match unit {
            .Second => if value == 1 { "second" } else { "seconds" }
            .Minute => if value == 1 { "minute" } else { "minutes" }
            .Hour => if value == 1 { "hour" } else { "hours" }
            .Day => if value == 1 { "day" } else { "days" }
            .Week => if value == 1 { "week" } else { "weeks" }
            .Month => if value == 1 { "month" } else { "months" }
            .Year => if value == 1 { "year" } else { "years" }
        }
        
        if future { "in " + value.to_string() + " " + unit_str }
        else { value.to_string() + " " + unit_str + " ago" }
    }
    
    fn format_russian(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        let unit_str = self.russian_unit(value, unit)
        if future { "через " + value.to_string() + " " + unit_str }
        else { value.to_string() + " " + unit_str + " назад" }
    }
    
    fn russian_unit(n: Int, unit: RelativeTimeUnit) -> String {
        let n10 = n % 10
        let n100 = n % 100
        
        match unit {
            .Second => if n10 == 1 && n100 != 11 { "секунду" }
                       else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "секунды" }
                       else { "секунд" }
            .Minute => if n10 == 1 && n100 != 11 { "минуту" }
                       else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "минуты" }
                       else { "минут" }
            .Hour => if n10 == 1 && n100 != 11 { "час" }
                     else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "часа" }
                     else { "часов" }
            .Day => if n10 == 1 && n100 != 11 { "день" }
                    else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "дня" }
                    else { "дней" }
            .Week => if n10 == 1 && n100 != 11 { "неделю" }
                     else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "недели" }
                     else { "недель" }
            .Month => if n10 == 1 && n100 != 11 { "месяц" }
                      else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "месяца" }
                      else { "месяцев" }
            .Year => if n10 == 1 && n100 != 11 { "год" }
                     else if n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) { "года" }
                     else { "лет" }
        }
    }
    
    fn format_german(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        let unit_str = match unit {
            .Second => if value == 1 { "Sekunde" } else { "Sekunden" }
            .Minute => if value == 1 { "Minute" } else { "Minuten" }
            .Hour => if value == 1 { "Stunde" } else { "Stunden" }
            .Day => if value == 1 { "Tag" } else { "Tagen" }
            .Week => if value == 1 { "Woche" } else { "Wochen" }
            .Month => if value == 1 { "Monat" } else { "Monaten" }
            .Year => if value == 1 { "Jahr" } else { "Jahren" }
        }
        if future { "in " + value.to_string() + " " + unit_str }
        else { "vor " + value.to_string() + " " + unit_str }
    }
    
    fn format_french(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        let unit_str = match unit {
            .Second => if value == 1 { "seconde" } else { "secondes" }
            .Minute => if value == 1 { "minute" } else { "minutes" }
            .Hour => if value == 1 { "heure" } else { "heures" }
            .Day => if value == 1 { "jour" } else { "jours" }
            .Week => if value == 1 { "semaine" } else { "semaines" }
            .Month => "mois"
            .Year => if value == 1 { "an" } else { "ans" }
        }
        if future { "dans " + value.to_string() + " " + unit_str }
        else { "il y a " + value.to_string() + " " + unit_str }
    }
    
    fn format_spanish(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        let unit_str = match unit {
            .Second => if value == 1 { "segundo" } else { "segundos" }
            .Minute => if value == 1 { "minuto" } else { "minutos" }
            .Hour => if value == 1 { "hora" } else { "horas" }
            .Day => if value == 1 { "día" } else { "días" }
            .Week => if value == 1 { "semana" } else { "semanas" }
            .Month => if value == 1 { "mes" } else { "meses" }
            .Year => if value == 1 { "año" } else { "años" }
        }
        if future { "dentro de " + value.to_string() + " " + unit_str }
        else { "hace " + value.to_string() + " " + unit_str }
    }
    
    fn format_chinese(value: Int, unit: RelativeTimeUnit, future: Bool) -> String {
        let unit_str = match unit {
            .Second => "秒"
            .Minute => "分钟"
            .Hour => "小时"
            .Day => "天"
            .Week => "周"
            .Month => "个月"
            .Year => "年"
        }
        if future { value.to_string() + unit_str + "后" }
        else { value.to_string() + unit_str + "前" }
    }
}

enum RelativeTimeUnit { Second, Minute, Hour, Day, Week, Month, Year }
enum RelativeTimeStyle { Long, Short, Narrow }

// -----------------------------------------------------------------------------
// Convenience Functions
// -----------------------------------------------------------------------------

fn format_date(dt: DateTime, style: String = "medium") -> String {
    DateTimeFormat.current().format_date(dt, style)
}

fn format_time(dt: DateTime, style: String = "medium") -> String {
    DateTimeFormat.current().format_time(dt, style)
}

fn format_datetime(dt: DateTime, date_style: String = "medium", time_style: String = "medium") -> String {
    DateTimeFormat.current().format(dt, date_style, time_style)
}

fn format_relative(dt: DateTime) -> String {
    RelativeTimeFormat.for_locale(Locale.current()).format(dt)
}

// -----------------------------------------------------------------------------
// Tests
// -----------------------------------------------------------------------------

test "date formatting" {
    let dt = DateTime.new(2024, 6, 15, 14, 30, 0)
    let fmt = DateTimeFormat.for_locale(Locales.en_US())
    
    assert(fmt.format_date(dt, "short").contains("6/15"))?
    assert(fmt.format_date(dt, "long").contains("June"))?
}

test "time formatting" {
    let dt = DateTime.new(2024, 6, 15, 14, 30, 0)
    let fmt = DateTimeFormat.for_locale(Locales.en_US())
    
    assert(fmt.format_time(dt, "short").contains("2:30"))?
    assert(fmt.format_time(dt, "short").contains("PM"))?
}

test "russian date" {
    let dt = DateTime.new(2024, 6, 15)
    let fmt = DateTimeFormat.for_locale(Locales.ru_RU())
    
    assert(fmt.format_date(dt, "long").contains("июня"))?
}

test "relative time" {
    let fmt = RelativeTimeFormat.for_locale(Locales.en_US())
    let result = fmt.format_relative(5, RelativeTimeUnit.Day, false)
    assert_eq(result, "5 days ago")?
}
