/// CLI Application Example
/// A task manager CLI built with Vibee

use std::fs
use std::json
use std::io
use std::args::{Parser, Command, Arg}
use std::color::{green, red, yellow, blue, bold}

const DATA_FILE: String = "tasks.json"

struct Task {
    id: Int,
    title: String,
    description: String,
    status: TaskStatus,
    priority: Priority,
    created_at: String,
    due_date: Option<String>,
    tags: Vec<String>,
}

enum TaskStatus {
    Todo,
    InProgress,
    Done,
}

enum Priority {
    Low,
    Medium,
    High,
}

impl Task {
    fn to_json(self) -> json::Value {
        json::object!{
            "id": self.id,
            "title": self.title,
            "description": self.description,
            "status": self.status.to_string(),
            "priority": self.priority.to_string(),
            "created_at": self.created_at,
            "due_date": self.due_date,
            "tags": self.tags
        }
    }
    
    fn from_json(value: json::Value) -> Task {
        Task {
            id: value["id"].as_int().unwrap(),
            title: value["title"].as_str().unwrap().to_string(),
            description: value["description"].as_str().unwrap_or("").to_string(),
            status: TaskStatus::from_str(value["status"].as_str().unwrap()),
            priority: Priority::from_str(value["priority"].as_str().unwrap()),
            created_at: value["created_at"].as_str().unwrap().to_string(),
            due_date: value["due_date"].as_str().map(|s| s.to_string()),
            tags: value["tags"].as_array().unwrap_or(&vec![])
                .iter().map(|v| v.as_str().unwrap().to_string()).collect(),
        }
    }
}

impl TaskStatus {
    fn to_string(self) -> String {
        match self {
            TaskStatus::Todo => "todo",
            TaskStatus::InProgress => "in_progress",
            TaskStatus::Done => "done",
        }.to_string()
    }
    
    fn from_str(s: &str) -> TaskStatus {
        match s {
            "in_progress" => TaskStatus::InProgress,
            "done" => TaskStatus::Done,
            _ => TaskStatus::Todo,
        }
    }
    
    fn icon(self) -> String {
        match self {
            TaskStatus::Todo => "â¬œ",
            TaskStatus::InProgress => "ðŸ”„",
            TaskStatus::Done => "âœ…",
        }.to_string()
    }
}

impl Priority {
    fn to_string(self) -> String {
        match self {
            Priority::Low => "low",
            Priority::Medium => "medium",
            Priority::High => "high",
        }.to_string()
    }
    
    fn from_str(s: &str) -> Priority {
        match s {
            "high" => Priority::High,
            "medium" => Priority::Medium,
            _ => Priority::Low,
        }
    }
    
    fn color(self, text: String) -> String {
        match self {
            Priority::High => red(text),
            Priority::Medium => yellow(text),
            Priority::Low => green(text),
        }
    }
}

struct TaskManager {
    tasks: Vec<Task>,
    next_id: Int,
}

impl TaskManager {
    fn new() -> TaskManager {
        TaskManager { tasks: Vec::new(), next_id: 1 }
    }
    
    fn load(mut self) {
        if fs::exists(DATA_FILE) {
            let content = fs::read_to_string(DATA_FILE)
            let data = json::parse(content)
            self.tasks = data["tasks"].as_array().unwrap()
                .iter().map(|v| Task::from_json(v.clone())).collect()
            self.next_id = data["next_id"].as_int().unwrap_or(1)
        }
    }
    
    fn save(self) {
        let data = json::object!{
            "tasks": self.tasks.iter().map(|t| t.to_json()).collect::<Vec<_>>(),
            "next_id": self.next_id
        }
        fs::write(DATA_FILE, json::stringify_pretty(data))
    }
    
    fn add(mut self, title: String, description: String, priority: Priority, due_date: Option<String>, tags: Vec<String>) {
        let task = Task {
            id: self.next_id,
            title,
            description,
            status: TaskStatus::Todo,
            priority,
            created_at: std::time::now().format("%Y-%m-%d %H:%M:%S"),
            due_date,
            tags,
        }
        self.next_id += 1
        self.tasks.push(task)
        self.save()
        println("{} Task added with ID: {}", green("âœ“"), self.next_id - 1)
    }
    
    fn list(self, filter_status: Option<TaskStatus>, filter_priority: Option<Priority>) {
        let filtered: Vec<&Task> = self.tasks.iter()
            .filter(|t| {
                let status_match = filter_status.map(|s| t.status == s).unwrap_or(true)
                let priority_match = filter_priority.map(|p| t.priority == p).unwrap_or(true)
                status_match && priority_match
            })
            .collect()
        
        if filtered.is_empty() {
            println("{}", yellow("No tasks found"))
            return
        }
        
        println("{}", bold("Tasks:"))
        println("{}", "-".repeat(60))
        
        for task in filtered.iter() {
            let priority_str = task.priority.color(format!("[{}]", task.priority.to_string().to_uppercase()))
            let tags_str = if task.tags.is_empty() { 
                String::new() 
            } else { 
                blue(format!(" #{}", task.tags.join(" #")))
            }
            
            println("{} {} {} {}{}", 
                task.status.icon(),
                bold(format!("#{}", task.id)),
                priority_str,
                task.title,
                tags_str)
            
            if !task.description.is_empty() {
                println("   {}", task.description)
            }
            
            if let Some(due) = task.due_date.clone() {
                println("   ðŸ“… Due: {}", due)
            }
        }
        
        println("{}", "-".repeat(60))
        println("Total: {} tasks", filtered.len())
    }
    
    fn update_status(mut self, id: Int, status: TaskStatus) {
        if let Some(task) = self.tasks.iter_mut().find(|t| t.id == id) {
            task.status = status
            self.save()
            println("{} Task #{} updated to {}", green("âœ“"), id, status.to_string())
        } else {
            println("{} Task #{} not found", red("âœ—"), id)
        }
    }
    
    fn delete(mut self, id: Int) {
        let len_before = self.tasks.len()
        self.tasks.retain(|t| t.id != id)
        
        if self.tasks.len() < len_before {
            self.save()
            println("{} Task #{} deleted", green("âœ“"), id)
        } else {
            println("{} Task #{} not found", red("âœ—"), id)
        }
    }
    
    fn stats(self) {
        let total = self.tasks.len()
        let todo = self.tasks.iter().filter(|t| t.status == TaskStatus::Todo).count()
        let in_progress = self.tasks.iter().filter(|t| t.status == TaskStatus::InProgress).count()
        let done = self.tasks.iter().filter(|t| t.status == TaskStatus::Done).count()
        
        let high = self.tasks.iter().filter(|t| t.priority == Priority::High).count()
        let medium = self.tasks.iter().filter(|t| t.priority == Priority::Medium).count()
        let low = self.tasks.iter().filter(|t| t.priority == Priority::Low).count()
        
        println("{}", bold("Task Statistics:"))
        println("{}", "-".repeat(30))
        println("Total tasks: {}", total)
        println("")
        println("By Status:")
        println("  â¬œ Todo:        {}", todo)
        println("  ðŸ”„ In Progress: {}", in_progress)
        println("  âœ… Done:        {}", done)
        println("")
        println("By Priority:")
        println("  {} High:   {}", red("â—"), high)
        println("  {} Medium: {}", yellow("â—"), medium)
        println("  {} Low:    {}", green("â—"), low)
        
        if total > 0 {
            let completion = (done as Float / total as Float * 100.0) as Int
            println("")
            println("Completion: {}%", completion)
        }
    }
}

fn main() {
    let parser = Parser::new("task")
        .version("0.1.0")
        .about("A simple task manager CLI")
        .subcommand(
            Command::new("add")
                .about("Add a new task")
                .arg(Arg::new("title").required(true).help("Task title"))
                .arg(Arg::new("description").short('d').long("desc").help("Task description"))
                .arg(Arg::new("priority").short('p').long("priority").default("medium").help("Priority: low, medium, high"))
                .arg(Arg::new("due").long("due").help("Due date (YYYY-MM-DD)"))
                .arg(Arg::new("tags").short('t').long("tags").multiple(true).help("Tags"))
        )
        .subcommand(
            Command::new("list")
                .about("List tasks")
                .arg(Arg::new("status").short('s').long("status").help("Filter by status"))
                .arg(Arg::new("priority").short('p').long("priority").help("Filter by priority"))
        )
        .subcommand(
            Command::new("done")
                .about("Mark task as done")
                .arg(Arg::new("id").required(true).help("Task ID"))
        )
        .subcommand(
            Command::new("start")
                .about("Start working on a task")
                .arg(Arg::new("id").required(true).help("Task ID"))
        )
        .subcommand(
            Command::new("delete")
                .about("Delete a task")
                .arg(Arg::new("id").required(true).help("Task ID"))
        )
        .subcommand(
            Command::new("stats")
                .about("Show task statistics")
        )
    
    let matches = parser.parse()
    let mut manager = TaskManager::new()
    manager.load()
    
    match matches.subcommand() {
        Some(("add", sub)) => {
            let title = sub.value_of("title").unwrap()
            let description = sub.value_of("description").unwrap_or("")
            let priority = Priority::from_str(sub.value_of("priority").unwrap_or("medium"))
            let due_date = sub.value_of("due").map(|s| s.to_string())
            let tags: Vec<String> = sub.values_of("tags").unwrap_or(vec![])
                .iter().map(|s| s.to_string()).collect()
            
            manager.add(title.to_string(), description.to_string(), priority, due_date, tags)
        },
        Some(("list", sub)) => {
            let status = sub.value_of("status").map(|s| TaskStatus::from_str(s))
            let priority = sub.value_of("priority").map(|s| Priority::from_str(s))
            manager.list(status, priority)
        },
        Some(("done", sub)) => {
            let id: Int = sub.value_of("id").unwrap().parse().unwrap()
            manager.update_status(id, TaskStatus::Done)
        },
        Some(("start", sub)) => {
            let id: Int = sub.value_of("id").unwrap().parse().unwrap()
            manager.update_status(id, TaskStatus::InProgress)
        },
        Some(("delete", sub)) => {
            let id: Int = sub.value_of("id").unwrap().parse().unwrap()
            manager.delete(id)
        },
        Some(("stats", _)) => {
            manager.stats()
        },
        _ => {
            parser.print_help()
        },
    }
}
