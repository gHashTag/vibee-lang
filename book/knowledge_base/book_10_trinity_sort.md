# Книга 10: Trinity Sort — База знаний

## Научное содержание

### Теория сортировки

**Нижняя граница сортировки сравнениями:**
Ω(n log n) — доказано через дерево решений.

**Текущие алгоритмы:**
- QuickSort: O(n log n) в среднем, O(n²) в худшем
- MergeSort: O(n log n) всегда, но требует O(n) памяти
- HeapSort: O(n log n) всегда, in-place

### Trinity Sort — троичная сортировка

**Идея:** Вместо деления на 2 части (как в QuickSort), делим на 3 части:
- Меньше pivot1
- Между pivot1 и pivot2
- Больше pivot2

**Преимущества:**
1. Меньше сравнений: log₃(n) < log₂(n)
2. Лучшая локальность кэша при правильном выборе pivot'ов
3. Естественная параллелизация на 3 потока

**Сложность:**
- Среднее: O(n log₃ n) ≈ O(0.63 n log₂ n)
- Худшее: O(n²) — как у QuickSort

### Научные работы

**Dual-Pivot QuickSort (Yaroslavskiy, 2009):**
- Используется в Java 7+ для Arrays.sort()
- Два pivot'а делят массив на три части
- На 20% быстрее классического QuickSort

**Multi-Pivot QuickSort (Aumüller, 2013):**
- Обобщение на k pivot'ов
- Оптимум при k = 2-3 для современных CPU

## Уникальная история для Книги 10

### Турнир алгоритмов

В Серебряном царстве проходил великий турнир алгоритмов сортировки. Собрались все: QuickSort — быстрый, но непредсказуемый; MergeSort — надёжный, но прожорливый; HeapSort — стабильный, но медленный.

И вот вышел на арену новый участник — TrinitySort.

«Три части лучше двух!» — провозгласил он и разделил массив на три.

Судьи замерли. Счётчики сравнений показали: TrinitySort сделал на 37% меньше сравнений, чем QuickSort!

«Как это возможно?» — спросил QuickSort.

«Секрет в числе 3,» — ответил TrinitySort. — «log₃(n) < log₂(n). Математика не обманывает.»

## Примеры кода для Книги 10

### Trinity Sort — полная реализация

```999
// Trinity Sort — троичная сортировка
// O(n log₃ n) в среднем
ⲙⲟⲇⲩⲗⲉ ⲧⲣⲓⲛⲓⲧⲩ_ⲥⲟⲣⲧ;

ⲫⲩⲛⲕ trinity_sort(arr: []i32) void {
    ⲓⲫ (arr.len <= 1) ⲣⲉⲧⲩⲣⲛ;
    
    // Выбираем два pivot'а
    ⲕⲟⲛⲥⲧ третина = arr.len / 3;
    ⲃⲁⲣ pivot1 = arr[третина];
    ⲃⲁⲣ pivot2 = arr[2 * третина];
    
    // Упорядочиваем pivot'ы
    ⲓⲫ (pivot1 > pivot2) {
        ⲕⲟⲛⲥⲧ tmp = pivot1;
        pivot1 = pivot2;
        pivot2 = tmp;
    }
    
    // Разделяем на три части
    ⲃⲁⲣ low: usize = 0;      // < pivot1
    ⲃⲁⲣ mid: usize = 0;      // pivot1 <= x <= pivot2
    ⲃⲁⲣ high: usize = arr.len - 1;  // > pivot2
    
    ⲱⲏⲓⲗⲉ (mid <= high) {
        ⲓⲫ (arr[mid] < pivot1) {
            // Меньше pivot1 — в левую часть
            swap(&arr[low], &arr[mid]);
            low += 1;
            mid += 1;
        } ⲉⲗⲥⲉ ⲓⲫ (arr[mid] > pivot2) {
            // Больше pivot2 — в правую часть
            swap(&arr[mid], &arr[high]);
            high -= 1;
        } ⲉⲗⲥⲉ {
            // Между pivot'ами — остаётся на месте
            mid += 1;
        }
    }
    
    // Рекурсивно сортируем три части
    trinity_sort(arr[0..low]);
    trinity_sort(arr[low..high+1]);
    trinity_sort(arr[high+1..]);
}

ⲫⲩⲛⲕ swap(a: *i32, b: *i32) void {
    ⲕⲟⲛⲥⲧ tmp = a.*;
    a.* = b.*;
    b.* = tmp;
}

// Бенчмарк
ⲫⲩⲛⲕ main() !void {
    ⲃⲁⲣ данные = [_]i32{ 64, 34, 25, 12, 22, 11, 90, 5, 77, 30 };
    
    ⲡⲣⲓⲛⲧ("До сортировки: {any}", данные);
    
    trinity_sort(&данные);
    
    ⲡⲣⲓⲛⲧ("После TrinitySort: {any}", данные);
}
```

### Сравнение с QuickSort

```999
// Сравнение количества сравнений
ⲙⲟⲇⲩⲗⲉ ⲃⲉⲛⲭⲙⲁⲣⲕ;

ⲃⲁⲣ сравнений_quick: u64 = 0;
ⲃⲁⲣ сравнений_trinity: u64 = 0;

ⲫⲩⲛⲕ quick_sort_count(arr: []i32) void {
    // ... реализация с подсчётом сравнений
    сравнений_quick += 1;  // каждое сравнение
}

ⲫⲩⲛⲕ trinity_sort_count(arr: []i32) void {
    // ... реализация с подсчётом сравнений
    сравнений_trinity += 1;  // каждое сравнение
}

ⲫⲩⲛⲕ main() !void {
    ⲕⲟⲛⲥⲧ N = 10000;
    
    // Генерируем случайные данные
    ⲃⲁⲣ данные1: [N]i32 = undefined;
    ⲃⲁⲣ данные2: [N]i32 = undefined;
    // ... заполняем одинаковыми случайными числами
    
    quick_sort_count(&данные1);
    trinity_sort_count(&данные2);
    
    ⲡⲣⲓⲛⲧ("QuickSort: {} сравнений", сравнений_quick);
    ⲡⲣⲓⲛⲧ("TrinitySort: {} сравнений", сравнений_trinity);
    ⲡⲣⲓⲛⲧ("Экономия: {d:.1}%", 
        100.0 * (1.0 - @intToFloat(f64, сравнений_trinity) / 
                       @intToFloat(f64, сравнений_quick)));
}
```

## Упражнения для Книги 10

### Уровень 1 (Интуиция)

1. Почему деление на 3 части лучше, чем на 2?
2. Нарисуйте дерево рекурсии для TrinitySort на массиве из 27 элементов
3. В каких случаях TrinitySort будет работать плохо?

### Уровень 2 (Анализ)

1. Докажите, что log₃(n) = log₂(n) / log₂(3) ≈ 0.63 log₂(n)
2. Реализуйте выбор pivot'ов методом "медиана трёх"
3. Измерьте реальное время работы TrinitySort vs QuickSort

### Уровень 3 (Синтез)

1. Как адаптировать TrinitySort для параллельного выполнения?
2. Предложите гибридный алгоритм Trinity + Insertion Sort
3. Исследуйте: при каком размере массива TrinitySort становится лучше?

## Мудрости для Книги 10

1. «Разделяй на три — и властвуй» — принцип TrinitySort
2. «Лучшее — враг хорошего, но три лучше двух» — алгоритмическая мудрость
3. «Не всё, что быстро, — хорошо; не всё, что хорошо, — быстро» — о trade-offs
