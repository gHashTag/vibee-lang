# Глава 7: Trinity Neural — Три Решения Разума

---

*«Три раза закинул старик невод в море:*
*первый раз — пусто, второй раз — тина,*
*третий раз — золотая рыбка.»*
— А.С. Пушкин, «Сказка о рыбаке и рыбке»

---

## Три Попытки Нейросети

Как старик закидывал невод три раза, так и нейросеть принимает решения в три этапа:

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   ТРИ РЕШЕНИЯ НЕЙРОСЕТИ                                │
│                                                         │
│   ПЕРВЫЙ ЗАБРОС    ВТОРОЙ ЗАБРОС    ТРЕТИЙ ЗАБРОС      │
│   ─────────────    ─────────────    ─────────────      │
│   REJECT           DEFER            ACCEPT             │
│   (Отвергнуть)     (Отложить)       (Принять)          │
│                                                         │
│   Уверен: НЕТ      Не уверен        Уверен: ДА         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Three-Way Decision: Три Решения

### Проблема Бинарной Классификации

```
Стандартная классификация:
  if P(A|x) > 0.5:
      return "ДА"
  else:
      return "НЕТ"

Проблема: что если P(A|x) = 0.51?
  Мы говорим "ДА" с уверенностью 51%!
  Это почти случайное угадывание.
```

### Решение: Три Зоны

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   THREE-WAY DECISION (Yao, 2010)                       │
│                                                         │
│   0.0 ──────── β ──────── α ──────── 1.0               │
│        REJECT     DEFER      ACCEPT                    │
│                                                         │
│   P(A|x) ≤ β  →  REJECT  (уверен: НЕТ)                │
│   P(A|x) ≥ α  →  ACCEPT  (уверен: ДА)                 │
│   β < P(A|x) < α  →  DEFER  (не уверен)               │
│                                                         │
│   Типичные значения: α = 0.7, β = 0.3                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Код

```python
def three_way_classify(probability, alpha=0.7, beta=0.3):
    """
    Три решения классификации
    
    Как три заброса невода:
    - Первый (REJECT): пусто, уверены что нет
    - Второй (DEFER): тина, не уверены
    - Третий (ACCEPT): золотая рыбка!
    """
    if probability >= alpha:
        return "ACCEPT"   # Третий заброс — успех!
    elif probability <= beta:
        return "REJECT"   # Первый заброс — пусто
    else:
        return "DEFER"    # Второй заброс — нужно ещё раз
```

### Применение

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   ПРИМЕРЫ ПРИМЕНЕНИЯ                                   │
│                                                         │
│   МЕДИЦИНА:                                            │
│   • ACCEPT: Диагноз подтверждён, лечить               │
│   • REJECT: Диагноз исключён, здоров                  │
│   • DEFER: Нужны дополнительные анализы               │
│                                                         │
│   МОДЕРАЦИЯ:                                           │
│   • ACCEPT: Контент безопасен, публиковать            │
│   • REJECT: Контент опасен, удалить                   │
│   • DEFER: Отправить на ручную проверку               │
│                                                         │
│   КРЕДИТНЫЙ СКОРИНГ:                                   │
│   • ACCEPT: Выдать кредит                             │
│   • REJECT: Отказать                                  │
│   • DEFER: Запросить дополнительные документы         │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Ternary Weight Networks: Три Веса

### Идея

Вместо 32-битных float весов используем только **три значения**: {-1, 0, +1}

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   TERNARY WEIGHTS: ТРИ БОГАТЫРЯ ВЕСОВ                  │
│                                                         │
│   -1              0               +1                    │
│   ──              ─               ──                    │
│   Отрицательный   Нейтральный     Положительный        │
│   вклад           (отключён)      вклад                │
│                                                         │
│   ПРЕИМУЩЕСТВА:                                        │
│   • 2 бита вместо 32 → 16x меньше памяти              │
│   • Умножение → сложение/вычитание                    │
│   • Быстрее на специализированном железе              │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Квантизация

```python
def ternarize_weights(weights):
    """
    Преобразование float весов в ternary {-1, 0, +1}
    
    Как три сына мельника:
    - Старший (+1): большие положительные веса
    - Средний (0): малые веса (отключены)
    - Младший (-1): большие отрицательные веса
    """
    # Порог = 0.7 × среднее абсолютное значение
    mean_abs = sum(abs(w) for w in weights) / len(weights)
    threshold = 0.7 * mean_abs
    
    ternary = []
    for w in weights:
        if w > threshold:
            ternary.append(1)    # Старший сын
        elif w < -threshold:
            ternary.append(-1)   # Младший сын
        else:
            ternary.append(0)    # Средний сын
    
    # Масштабирующий коэффициент
    non_zero = [abs(w) for w, t in zip(weights, ternary) if t != 0]
    scale = sum(non_zero) / len(non_zero) if non_zero else 1.0
    
    return ternary, scale
```

### Результаты

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   СРАВНЕНИЕ: FLOAT vs TERNARY                          │
│                                                         │
│   Метрика          Float32     Ternary     Разница     │
│   ─────────────────────────────────────────────────    │
│   Память           32 бита     2 бита      16x ↓       │
│   Умножение        FP MUL      ADD/SUB     10x ↓       │
│   Точность         100%        ~95%        5% ↓        │
│   Энергия          100%        ~10%        10x ↓       │
│                                                         │
│   ВЫВОД: Потеря 5% точности за 16x экономию памяти    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Ternary Matrix Multiplication

```python
def ternary_matmul(weights, x, scale):
    """
    Умножение матрицы с ternary весами
    
    Вместо: result[i] = sum(w[i][j] * x[j])
    Делаем: result[i] = sum(x[j] if w=+1 else -x[j] if w=-1 else 0)
    
    Нет умножений! Только сложения и вычитания.
    """
    result = []
    for row in weights:
        total = 0.0
        for w, xi in zip(row, x):
            if w == 1:
                total += xi      # Старший сын добавляет
            elif w == -1:
                total -= xi      # Младший сын вычитает
            # w == 0: средний сын молчит
        result.append(total * scale)
    return result
```

---

## Ternary Activation: Три Состояния Нейрона

### Стандартные Активации

```
ReLU:    max(0, x)           — 2 состояния (0 или +)
Sigmoid: 1/(1+e^-x)          — непрерывно [0, 1]
Tanh:    (e^x-e^-x)/(e^x+e^-x) — непрерывно [-1, 1]
```

### Ternary Activation

```python
def hard_ternary(x, threshold=0.5):
    """
    Жёсткая тернарная активация: {-1, 0, +1}
    
    Как три дороги:
    - x > threshold  → +1 (направо)
    - x < -threshold → -1 (налево)
    - иначе          → 0  (прямо/стоп)
    """
    if x > threshold:
        return 1
    elif x < -threshold:
        return -1
    return 0

def soft_ternary(x, k=5.0):
    """
    Мягкая тернарная активация (дифференцируемая)
    
    Аппроксимация hard_ternary для обучения
    """
    import math
    return math.tanh(k * (x - 0.5)) / 2 + math.tanh(k * (x + 0.5)) / 2

def leaky_ternary(x, alpha=0.1):
    """
    Leaky тернарная: 3 линейных региона
    
    Как три царства:
    - x > 1:  1 + α(x-1)   (за пределами)
    - x < -1: -1 + α(x+1)  (за пределами)
    - иначе:  x            (в царстве)
    """
    if x > 1:
        return 1 + alpha * (x - 1)
    elif x < -1:
        return -1 + alpha * (x + 1)
    return x
```

### Сравнение

```
┌─────────┬─────────┬─────────────┬─────────────┬─────────────┐
│ x       │ ReLU    │ Hard Tern   │ Soft Tern   │ Leaky Tern  │
├─────────┼─────────┼─────────────┼─────────────┼─────────────┤
│ -2.0    │ 0.00    │ -1          │ -1.000      │ -1.100      │
│ -1.0    │ 0.00    │ -1          │ -0.993      │ -1.000      │
│ -0.5    │ 0.00    │ 0           │ -0.500      │ -0.500      │
│ 0.0     │ 0.00    │ 0           │ 0.000       │ 0.000       │
│ 0.5     │ 0.50    │ 0           │ 0.500       │ 0.500       │
│ 1.0     │ 1.00    │ 1           │ 0.993       │ 1.000       │
│ 2.0     │ 2.00    │ 1           │ 1.000       │ 1.100       │
└─────────┴─────────┴─────────────┴─────────────┴─────────────┘
```

---

## Edge of Chaos: Критическая Инициализация

### Три Состояния Сети

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   ТРИ СОСТОЯНИЯ НЕЙРОСЕТИ                              │
│                                                         │
│   ЗАТУХАНИЕ        КРИТИЧНОСТЬ      ВЗРЫВ              │
│   ─────────        ───────────      ─────              │
│   σ² < 1           σ² = 1           σ² > 1             │
│                                                         │
│   Сигнал           Сигнал           Сигнал             │
│   исчезает         сохраняется      взрывается         │
│                                                         │
│   Не обучается     ОБУЧАЕТСЯ!       Не обучается       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Условие Критичности

```
σ_w² × σ_b² = 1

Где:
  σ_w² = дисперсия весов
  σ_b² = дисперсия активаций (≈1 для tanh)

Для tanh: σ_w² = 1/n_in  (Xavier initialization)
Для ReLU: σ_w² = 2/n_in  (He initialization)
```

### Эксперимент

```python
def simulate_signal(n_layers, width, sigma_w):
    """Симуляция распространения сигнала"""
    import random
    import math
    
    # Начальный сигнал
    signal = [random.gauss(0, 1) for _ in range(width)]
    
    for _ in range(n_layers):
        new_signal = []
        for _ in range(width):
            z = sum(random.gauss(0, sigma_w) * s for s in signal) / math.sqrt(width)
            new_signal.append(math.tanh(z))
        signal = new_signal
    
    # Норма сигнала
    return math.sqrt(sum(s**2 for s in signal) / width)

# Результаты (10 слоёв, ширина 100)
# σ_w = 0.5: норма → 0.0007 (ЗАТУХАНИЕ)
# σ_w = 0.8: норма → 0.0408 (ЗАТУХАНИЕ)
# σ_w = 1.0: норма → 0.2424 (КРИТИЧНОСТЬ) ✓
# σ_w = 1.2: норма → 0.4568 (КРИТИЧНОСТЬ) ✓
# σ_w = 1.5: норма → 0.5912 (КРИТИЧНОСТЬ) ✓
```

---

## Trinity Perceptron: Три Выхода

### Идея

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   СТАНДАРТНЫЙ PERCEPTRON                               │
│   y = sign(w·x + b) → {-1, +1}                         │
│                                                         │
│   TRINITY PERCEPTRON                                   │
│   y = ternary(w·x + b) → {-1, 0, +1}                   │
│                                                         │
│   Третий выход (0) = "не знаю" / "нейтрально"          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### Код

```python
class TrinityPerceptron:
    """
    Перцептрон с тремя выходами
    
    Как три дороги:
    - +1: уверен в положительном классе
    - -1: уверен в отрицательном классе
    - 0:  не уверен / нейтрально
    """
    
    def __init__(self, n_features, threshold=0.5):
        import random
        self.weights = [random.gauss(0, 0.1) for _ in range(n_features)]
        self.bias = 0.0
        self.threshold = threshold
    
    def predict(self, x):
        z = sum(w * xi for w, xi in zip(self.weights, x)) + self.bias
        
        if z > self.threshold:
            return 1    # Направо — положительный
        elif z < -self.threshold:
            return -1   # Налево — отрицательный
        return 0        # Прямо — нейтрально
    
    def train(self, X, y, epochs=100, lr=0.1):
        for _ in range(epochs):
            for xi, yi in zip(X, y):
                pred = self.predict(xi)
                error = yi - pred
                
                for j in range(len(self.weights)):
                    self.weights[j] += lr * error * xi[j]
                self.bias += lr * error
```

---

## Сводка: Число 3 в Нейросетях

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   ЧИСЛО 3 В НЕЙРОСЕТЯХ                                 │
│                                                         │
│   КОНЦЕПЦИЯ           ПРИМЕНЕНИЕ                       │
│   ─────────────────────────────────────────────────    │
│   3-way decision      Accept / Reject / Defer          │
│   Ternary weights     {-1, 0, +1} → 16x меньше памяти │
│   Ternary activation  3 региона активации              │
│   Edge of chaos       3 состояния: затух./крит./взрыв │
│   Trinity perceptron  3 выхода: +1, 0, -1              │
│                                                         │
│   ПРАКТИКА:                                            │
│   • Mobile/edge deployment (TWN)                       │
│   • Uncertainty quantification (3-way)                 │
│   • Efficient inference (ternary ops)                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## Мудрость Главы

> *И понял Иван-программист пятую истину:*
>
> *Три заброса невода — три решения нейросети:*
> *первый — пусто (REJECT),*
> *второй — тина (DEFER),*
> *третий — золотая рыбка (ACCEPT).*
>
> *Три веса нейрона — три сына мельника:*
> *старший (+1) добавляет,*
> *младший (-1) вычитает,*
> *средний (0) молчит.*
>
> *Три состояния сети — три царства:*
> *затухание (Навь),*
> *критичность (Явь),*
> *взрыв (Правь).*
>
> *Только на границе хаоса и порядка*
> *сеть обучается.*
>
> *Как герой сказки на распутье —*
> *нейросеть выбирает из трёх дорог.*
>
> *Древние знали.*

---

[← Глава 6](06_trinity_compression.md) | [Глава 8: Бенчмарки →](08_benchmarks.md)
