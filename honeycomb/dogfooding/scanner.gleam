// Generated manually from specs/scanner.vibee
// TODO: Regenerate with vibeec when available

import gleam/dict.{type Dict}
import gleam/list
import gleam/string
import gleam/result
import gleam/option.{type Option, None, Some}
import simplifile

pub type ViolationRule {
  NoManualCode
  MissingSpec
  OutdatedCode
  InvalidGeneration
}

pub type Severity {
  Error
  Warning
  Info
}

pub type Violation {
  Violation(
    rule: ViolationRule,
    file_path: String,
    line_number: Int,
    severity: Severity,
    message: String,
    auto_fixable: Bool,
  )
}

pub type ScanResult {
  ScanResult(
    file_path: String,
    violations: List(Violation),
    scan_time_ms: Int,
  )
}

pub type ScanConfig {
  ScanConfig(
    rules: List(ViolationRule),
    exclude_patterns: List(String),
    auto_fix: Bool,
  )
}

pub type GenerationInfo {
  GenerationInfo(
    spec_file: String,
    generated_at: Int,
    vibeec_version: String,
  )
}

pub fn default_scan_config() -> ScanConfig {
  ScanConfig(
    rules: [NoManualCode, MissingSpec, OutdatedCode],
    exclude_patterns: ["build/", ".git/", "gleam/src/"],
    auto_fix: False,
  )
}

pub fn scan_file(path: String, config: ScanConfig) -> Result(ScanResult, String) {
  case simplifile.read(path) {
    Ok(content) -> {
      let violations = check_all_rules(path, content, config)
      Ok(ScanResult(file_path: path, violations: violations, scan_time_ms: 0))
    }
    Error(_) -> Error("Failed to read file: " <> path)
  }
}

pub fn scan_directory(
  path: String,
  config: ScanConfig,
) -> Result(List(ScanResult), String) {
  case simplifile.read_directory(path) {
    Ok(entries) -> {
      let results =
        list.filter_map(entries, fn(entry) {
          let full_path = path <> "/" <> entry
          case string.ends_with(entry, ".gleam") {
            True -> scan_file(full_path, config)
            False -> Error("Not a Gleam file")
          }
        })
      Ok(results)
    }
    Error(_) -> Error("Failed to read directory: " <> path)
  }
}

fn check_all_rules(
  path: String,
  content: String,
  config: ScanConfig,
) -> List(Violation) {
  let manual_code_violations = check_manual_code(content, path)
  let missing_spec_violation = check_missing_spec(path)
  let outdated_code_violation = check_outdated_code_from_content(path, content)

  list.flatten([
    manual_code_violations,
    option.to_list(missing_spec_violation),
    option.to_list(outdated_code_violation),
  ])
}

pub fn check_manual_code(content: String, path: String) -> List(Violation) {
  case is_generated_file(content) {
    True -> []
    False ->
      case has_manual_implementation(content) {
        True -> [
          Violation(
            rule: NoManualCode,
            file_path: path,
            line_number: 1,
            severity: Error,
            message: "Manual code detected. All code must be generated from specs.",
            auto_fixable: True,
          ),
        ]
        False -> []
      }
  }
}

pub fn check_missing_spec(module_path: String) -> Option(Violation) {
  case find_spec_for_module(module_path) {
    Some(_) -> None
    None ->
      Some(Violation(
        rule: MissingSpec,
        file_path: module_path,
        line_number: 1,
        severity: Warning,
        message: "No corresponding .vibee spec found.",
        auto_fixable: False,
      ))
  }
}

fn check_outdated_code_from_content(
  path: String,
  content: String,
) -> Option(Violation) {
  case parse_generation_marker(content) {
    Some(gen_info) -> {
      case find_spec_for_module(path) {
        Some(spec_path) -> check_outdated_code(path, spec_path)
        None -> None
      }
    }
    None -> None
  }
}

pub fn check_outdated_code(
  code_path: String,
  spec_path: String,
) -> Option(Violation) {
  case simplifile.file_info(code_path), simplifile.file_info(spec_path) {
    Ok(code_info), Ok(spec_info) -> {
      // Compare modification times (simplified)
      None
    }
    _, _ -> None
  }
}

pub fn is_generated_file(content: String) -> Bool {
  string.contains(content, "Generated by vibeec")
  || string.contains(content, "DO NOT EDIT")
}

fn has_manual_implementation(content: String) -> Bool {
  // Simplified check: if file has function bodies with actual logic
  string.contains(content, "pub fn ")
  && !string.contains(content, "Error(\"Not implemented\")")
  && !string.contains(content, "@external")
}

pub fn find_spec_for_module(module_path: String) -> Option(String) {
  // Convert honeycomb/agent/core.gleam -> specs/agent_core.vibee
  let without_honeycomb = string.replace(module_path, "honeycomb/", "")
  let without_extension = string.replace(without_honeycomb, ".gleam", "")
  let spec_name = string.replace(without_extension, "/", "_")
  let spec_path = "specs/" <> spec_name <> ".vibee"

  case simplifile.verify_is_file(spec_path) {
    Ok(_) -> Some(spec_path)
    Error(_) -> None
  }
}

pub fn parse_generation_marker(content: String) -> Option(GenerationInfo) {
  case string.contains(content, "Generated by vibeec") {
    True ->
      Some(GenerationInfo(
        spec_file: "unknown",
        generated_at: 0,
        vibeec_version: "1.0.0",
      ))
    False -> None
  }
}

pub fn format_violation(violation: Violation) -> String {
  let severity_str = case violation.severity {
    Error -> "ERROR"
    Warning -> "WARNING"
    Info -> "INFO"
  }

  severity_str
  <> ": "
  <> violation.file_path
  <> ":"
  <> string.inspect(violation.line_number)
  <> " - "
  <> violation.message
}

pub fn group_violations_by_file(
  results: List(ScanResult),
) -> Dict(String, List(Violation)) {
  list.fold(results, dict.new(), fn(acc, result) {
    dict.insert(acc, result.file_path, result.violations)
  })
}
