// ═══════════════════════════════════════════════════════════════════════════════
// INLINE CACHING - GENERATED BY ZMEI GORYNYCH FROM ⲓⲛⲗⲓⲛⲉ_ⲕⲁⲭⲓⲛⲅ.tls
// ═══════════════════════════════════════════════════════════════════════════════
// Sacred Formula: V = n × 3^k × π^m × φ^p × e^q
// Golden Identity: φ² + 1/φ² = 3
// Pattern: HSH + PRE
// Speedup: 48% type tests eliminated
// Source: Chevalier-Boisvert 2015 "Basic Block Versioning"
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");

// Sacred Constants
pub const PHI: f64 = 1.618033988749895;
pub const GOLDEN_IDENTITY: f64 = 3.0;
pub const TRINITY_PRIME: u32 = 33;

// ═══════════════════════════════════════════════════════════════════════════════
// TYPE TAGS
// ═══════════════════════════════════════════════════════════════════════════════

pub const TypeTag = enum(u8) {
    Nil = 0,
    Int = 1,
    Float = 2,
    Bool = 3,
    String = 4,
    Object = 5,
};

// ═══════════════════════════════════════════════════════════════════════════════
// TAGGED VALUE
// ═══════════════════════════════════════════════════════════════════════════════

pub const Value = struct {
    tag: TypeTag,
    data: u64,

    pub fn initInt(v: i64) Value {
        return .{ .tag = .Int, .data = @bitCast(v) };
    }

    pub fn initFloat(v: f64) Value {
        return .{ .tag = .Float, .data = @bitCast(v) };
    }

    pub fn initBool(v: bool) Value {
        return .{ .tag = .Bool, .data = if (v) 1 else 0 };
    }

    pub fn initNil() Value {
        return .{ .tag = .Nil, .data = 0 };
    }

    pub fn asInt(self: Value) i64 {
        return @bitCast(self.data);
    }

    pub fn asFloat(self: Value) f64 {
        return @bitCast(self.data);
    }

    pub fn asBool(self: Value) bool {
        return self.data != 0;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// INLINE CACHE ENTRY
// ═══════════════════════════════════════════════════════════════════════════════

pub const CacheEntry = struct {
    type1: TypeTag,
    type2: TypeTag,
    handler: *const fn (Value, Value) Value,
    hits: u32,
};

// ═══════════════════════════════════════════════════════════════════════════════
// POLYMORPHIC INLINE CACHE (PIC)
// ═══════════════════════════════════════════════════════════════════════════════

pub const InlineCache = struct {
    entries: [4]?CacheEntry, // 4-way PIC
    size: u8,
    total_lookups: u64,
    cache_hits: u64,
    cache_misses: u64,

    const Self = @This();

    pub fn init() Self {
        return .{
            .entries = [_]?CacheEntry{null} ** 4,
            .size = 0,
            .total_lookups = 0,
            .cache_hits = 0,
            .cache_misses = 0,
        };
    }

    /// Lookup handler for type pair
    pub fn lookup(self: *Self, t1: TypeTag, t2: TypeTag) ?*const fn (Value, Value) Value {
        self.total_lookups += 1;

        // Linear search through cache (4 entries max)
        for (self.entries) |entry_opt| {
            if (entry_opt) |entry| {
                if (entry.type1 == t1 and entry.type2 == t2) {
                    self.cache_hits += 1;
                    return entry.handler;
                }
            }
        }

        self.cache_misses += 1;
        return null;
    }

    /// Add entry to cache (LRU eviction if full)
    pub fn update(self: *Self, t1: TypeTag, t2: TypeTag, handler: *const fn (Value, Value) Value) void {
        // Check if already exists
        for (&self.entries) |*entry_opt| {
            if (entry_opt.*) |*entry| {
                if (entry.type1 == t1 and entry.type2 == t2) {
                    entry.hits += 1;
                    return;
                }
            }
        }

        // Find empty slot or evict LRU
        var min_hits: u32 = std.math.maxInt(u32);
        var evict_idx: usize = 0;

        for (self.entries, 0..) |entry_opt, i| {
            if (entry_opt == null) {
                evict_idx = i;
                break;
            }
            if (entry_opt.?.hits < min_hits) {
                min_hits = entry_opt.?.hits;
                evict_idx = i;
            }
        }

        self.entries[evict_idx] = .{
            .type1 = t1,
            .type2 = t2,
            .handler = handler,
            .hits = 1,
        };

        if (self.size < 4) self.size += 1;
    }

    pub fn hitRatio(self: Self) f64 {
        if (self.total_lookups == 0) return 0;
        return @as(f64, @floatFromInt(self.cache_hits)) / @as(f64, @floatFromInt(self.total_lookups));
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// SPECIALIZED HANDLERS
// ═══════════════════════════════════════════════════════════════════════════════

/// ADD_INT_INT: No type check needed
fn add_int_int(a: Value, b: Value) Value {
    return Value.initInt(a.asInt() +% b.asInt());
}

/// ADD_FLOAT_FLOAT: No type check needed
fn add_float_float(a: Value, b: Value) Value {
    return Value.initFloat(a.asFloat() + b.asFloat());
}

/// ADD_INT_FLOAT: One conversion
fn add_int_float(a: Value, b: Value) Value {
    return Value.initFloat(@as(f64, @floatFromInt(a.asInt())) + b.asFloat());
}

/// ADD_FLOAT_INT: One conversion
fn add_float_int(a: Value, b: Value) Value {
    return Value.initFloat(a.asFloat() + @as(f64, @floatFromInt(b.asInt())));
}

/// MUL_INT_INT: No type check needed
fn mul_int_int(a: Value, b: Value) Value {
    return Value.initInt(a.asInt() *% b.asInt());
}

/// MUL_FLOAT_FLOAT: No type check needed
fn mul_float_float(a: Value, b: Value) Value {
    return Value.initFloat(a.asFloat() * b.asFloat());
}

/// Generic ADD with type checking (fallback)
fn add_generic(a: Value, b: Value) Value {
    if (a.tag == .Int and b.tag == .Int) {
        return add_int_int(a, b);
    } else if (a.tag == .Float and b.tag == .Float) {
        return add_float_float(a, b);
    } else if (a.tag == .Int and b.tag == .Float) {
        return add_int_float(a, b);
    } else if (a.tag == .Float and b.tag == .Int) {
        return add_float_int(a, b);
    }
    return Value.initNil();
}

/// Generic MUL with type checking (fallback)
fn mul_generic(a: Value, b: Value) Value {
    if (a.tag == .Int and b.tag == .Int) {
        return mul_int_int(a, b);
    } else if (a.tag == .Float and b.tag == .Float) {
        return mul_float_float(a, b);
    }
    return Value.initNil();
}

// ═══════════════════════════════════════════════════════════════════════════════
// CACHED VM
// ═══════════════════════════════════════════════════════════════════════════════

pub const CachedVM = struct {
    stack: std.ArrayList(Value),
    add_cache: InlineCache,
    mul_cache: InlineCache,
    quickening_threshold: u32,
    type_checks_eliminated: u64,

    const Self = @This();

    pub fn init(allocator: std.mem.Allocator) Self {
        return .{
            .stack = std.ArrayList(Value).init(allocator),
            .add_cache = InlineCache.init(),
            .mul_cache = InlineCache.init(),
            .quickening_threshold = 10,
            .type_checks_eliminated = 0,
        };
    }

    pub fn deinit(self: *Self) void {
        self.stack.deinit();
    }

    pub fn push(self: *Self, v: Value) !void {
        try self.stack.append(v);
    }

    pub fn pop(self: *Self) ?Value {
        if (self.stack.items.len == 0) return null;
        return self.stack.pop();
    }

    /// Cached ADD operation
    pub fn cachedAdd(self: *Self) !void {
        const b = self.pop() orelse return;
        const a = self.pop() orelse return;

        // Try cache first
        if (self.add_cache.lookup(a.tag, b.tag)) |handler| {
            self.type_checks_eliminated += 1;
            try self.push(handler(a, b));
            return;
        }

        // Cache miss - use generic and update cache
        const result = add_generic(a, b);
        try self.push(result);

        // Update cache with specialized handler
        const handler: *const fn (Value, Value) Value = switch (a.tag) {
            .Int => switch (b.tag) {
                .Int => add_int_int,
                .Float => add_int_float,
                else => add_generic,
            },
            .Float => switch (b.tag) {
                .Int => add_float_int,
                .Float => add_float_float,
                else => add_generic,
            },
            else => add_generic,
        };
        self.add_cache.update(a.tag, b.tag, handler);
    }

    /// Cached MUL operation
    pub fn cachedMul(self: *Self) !void {
        const b = self.pop() orelse return;
        const a = self.pop() orelse return;

        // Try cache first
        if (self.mul_cache.lookup(a.tag, b.tag)) |handler| {
            self.type_checks_eliminated += 1;
            try self.push(handler(a, b));
            return;
        }

        // Cache miss - use generic and update cache
        const result = mul_generic(a, b);
        try self.push(result);

        // Update cache
        const handler: *const fn (Value, Value) Value = switch (a.tag) {
            .Int => if (b.tag == .Int) mul_int_int else mul_generic,
            .Float => if (b.tag == .Float) mul_float_float else mul_generic,
            else => mul_generic,
        };
        self.mul_cache.update(a.tag, b.tag, handler);
    }

    pub fn getMetrics(self: Self) CacheMetrics {
        return .{
            .add_hit_ratio = self.add_cache.hitRatio(),
            .mul_hit_ratio = self.mul_cache.hitRatio(),
            .type_checks_eliminated = self.type_checks_eliminated,
            .total_lookups = self.add_cache.total_lookups + self.mul_cache.total_lookups,
        };
    }
};

pub const CacheMetrics = struct {
    add_hit_ratio: f64,
    mul_hit_ratio: f64,
    type_checks_eliminated: u64,
    total_lookups: u64,
};

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "golden_identity" {
    const phi_sq = PHI * PHI;
    const inv_phi_sq = 1.0 / phi_sq;
    const result = phi_sq + inv_phi_sq;
    try std.testing.expectApproxEqAbs(GOLDEN_IDENTITY, result, 0.0001);
}

test "inline_cache_monomorphic" {
    var cache = InlineCache.init();

    // First lookup - miss
    const h1 = cache.lookup(.Int, .Int);
    try std.testing.expect(h1 == null);
    try std.testing.expectEqual(@as(u64, 1), cache.cache_misses);

    // Add entry
    cache.update(.Int, .Int, add_int_int);

    // Second lookup - hit
    const h2 = cache.lookup(.Int, .Int);
    try std.testing.expect(h2 != null);
    try std.testing.expectEqual(@as(u64, 1), cache.cache_hits);
}

test "inline_cache_polymorphic" {
    var cache = InlineCache.init();

    // Add multiple type pairs
    cache.update(.Int, .Int, add_int_int);
    cache.update(.Float, .Float, add_float_float);
    cache.update(.Int, .Float, add_int_float);

    // All should hit
    try std.testing.expect(cache.lookup(.Int, .Int) != null);
    try std.testing.expect(cache.lookup(.Float, .Float) != null);
    try std.testing.expect(cache.lookup(.Int, .Float) != null);

    try std.testing.expectEqual(@as(u64, 3), cache.cache_hits);
}

test "cached_vm_add_int_int" {
    const allocator = std.testing.allocator;
    var vm = CachedVM.init(allocator);
    defer vm.deinit();

    // First add - cache miss
    try vm.push(Value.initInt(10));
    try vm.push(Value.initInt(5));
    try vm.cachedAdd();

    const r1 = vm.pop().?;
    try std.testing.expectEqual(TypeTag.Int, r1.tag);
    try std.testing.expectEqual(@as(i64, 15), r1.asInt());

    // Second add - cache hit
    try vm.push(Value.initInt(20));
    try vm.push(Value.initInt(7));
    try vm.cachedAdd();

    const r2 = vm.pop().?;
    try std.testing.expectEqual(@as(i64, 27), r2.asInt());
    try std.testing.expectEqual(@as(u64, 1), vm.type_checks_eliminated);
}

test "cached_vm_mixed_types" {
    const allocator = std.testing.allocator;
    var vm = CachedVM.init(allocator);
    defer vm.deinit();

    // Int + Float
    try vm.push(Value.initInt(10));
    try vm.push(Value.initFloat(2.5));
    try vm.cachedAdd();

    const r = vm.pop().?;
    try std.testing.expectEqual(TypeTag.Float, r.tag);
    try std.testing.expectApproxEqAbs(@as(f64, 12.5), r.asFloat(), 0.001);
}

test "cache_hit_ratio" {
    const allocator = std.testing.allocator;
    var vm = CachedVM.init(allocator);
    defer vm.deinit();

    // Run 10 adds with same types
    var i: usize = 0;
    while (i < 10) : (i += 1) {
        try vm.push(Value.initInt(@intCast(i)));
        try vm.push(Value.initInt(1));
        try vm.cachedAdd();
        _ = vm.pop();
    }

    const metrics = vm.getMetrics();
    // First is miss, rest are hits: 9/10 = 90%
    try std.testing.expect(metrics.add_hit_ratio > 0.85);
    try std.testing.expectEqual(@as(u64, 9), metrics.type_checks_eliminated);
}

test "specialized_handlers_correctness" {
    // Test all specialized handlers
    const a_int = Value.initInt(10);
    const b_int = Value.initInt(5);
    const a_float = Value.initFloat(10.5);
    const b_float = Value.initFloat(2.5);

    // INT + INT
    const r1 = add_int_int(a_int, b_int);
    try std.testing.expectEqual(@as(i64, 15), r1.asInt());

    // FLOAT + FLOAT
    const r2 = add_float_float(a_float, b_float);
    try std.testing.expectApproxEqAbs(@as(f64, 13.0), r2.asFloat(), 0.001);

    // INT + FLOAT
    const r3 = add_int_float(a_int, b_float);
    try std.testing.expectApproxEqAbs(@as(f64, 12.5), r3.asFloat(), 0.001);

    // INT * INT
    const r4 = mul_int_int(a_int, b_int);
    try std.testing.expectEqual(@as(i64, 50), r4.asInt());
}
