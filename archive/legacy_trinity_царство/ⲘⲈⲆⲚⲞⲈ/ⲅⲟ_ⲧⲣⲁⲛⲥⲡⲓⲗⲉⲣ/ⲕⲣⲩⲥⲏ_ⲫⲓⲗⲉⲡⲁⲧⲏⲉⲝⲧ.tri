// ═══════════════════════════════════════════════════════════════════════════════
// ⲔⲢⲨⲤⲎ ⲪⲒⲖⲈⲠⲀⲦⲎⲈⲜⲦ - Generated from crush_filepathext.vibee
// ═══════════════════════════════════════════════════════════════════════════════
// SOURCE: github.com/charmbracelet/crush/internal/filepathext/filepath.go
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

ⲧⲣⲓⲛⲓⲧⲓ ⲔⲢⲨⲤⲎ_ⲪⲒⲖⲈⲠⲀⲦⲎⲈⲜⲦ {
    ⲟⲛⲟⲙⲁ: "Crush FilepathExt"
    ⲃⲉⲣⲥⲓⲁ: "1.0.0"
    ⲥⲟⲩⲣⲕⲉ: "charmbracelet/crush/internal/filepathext"
    ⲥⲟⲩⲣⲕⲉ_ⲥⲡⲉⲕ: "specs/crush_filepathext.vibee"
    
    ⲥⲁⲕⲣⲁ: {
        ⲪⲎⲒ: 1.618033988749895
        ⲦⲢⲒⲚⲒⲦⲨ: 3.0
    }
    
    ⲕⲣⲉⲁⲧⲓⲟⲛ: {
        ⲥⲟⲩⲣⲕⲉ: "Go filepathext"
        ⲧⲣⲁⲛⲥⲫⲟⲣⲙⲉⲣ: "ⲨⲒⲂⲈⲈ"
        ⲣⲉⲥⲩⲗⲧ: "Zig filepathext"
    }
    
    ⲅⲟ_ⲥⲟⲩⲣⲕⲉ: """
package filepathext

import (
    "path/filepath"
    "runtime"
    "strings"
)

func SmartJoin(one, two string) string {
    if SmartIsAbs(two) {
        return two
    }
    return filepath.Join(one, two)
}

func SmartIsAbs(path string) bool {
    switch runtime.GOOS {
    case "windows":
        return filepath.IsAbs(path) || strings.HasPrefix(filepath.ToSlash(path), "/")
    default:
        return filepath.IsAbs(path)
    }
}
"""
    
    ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: """
// ═══════════════════════════════════════════════════════════════════════════════
// filepathext - Generated from Go by VIBEE Transpiler
// ═══════════════════════════════════════════════════════════════════════════════
// SOURCE: github.com/charmbracelet/crush/internal/filepathext/filepath.go
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const builtin = @import("builtin");

pub const PHI: f64 = 1.618033988749895;
pub const TRINITY: f64 = 3.0;

/// SmartJoin joins two paths, treating the second path as absolute if it is.
/// Go original: filepath.Join(one, two)
pub fn smartJoin(allocator: std.mem.Allocator, one: []const u8, two: []const u8) ![]u8 {
    if (smartIsAbs(two)) {
        return try allocator.dupe(u8, two);
    }
    
    // Join paths
    var paths = [_][]const u8{ one, two };
    return try std.fs.path.join(allocator, &paths);
}

/// SmartIsAbs checks if a path is absolute (cross-platform).
/// Go original: filepath.IsAbs(path)
pub fn smartIsAbs(path: []const u8) bool {
    if (path.len == 0) return false;
    
    switch (builtin.os.tag) {
        .windows => {
            // Check for Windows absolute paths (C:\\, D:\\, etc.)
            if (path.len >= 2 and path[1] == ':') return true;
            // Also check for Unix-style absolute paths
            return path[0] == '/' or path[0] == '\\\\';
        },
        else => {
            return path[0] == '/';
        },
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "golden identity" {
    const phi_sq = PHI * PHI;
    const result = phi_sq + 1.0 / phi_sq;
    try std.testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}

test "smartIsAbs unix absolute" {
    try std.testing.expect(smartIsAbs("/home/user"));
}

test "smartIsAbs relative" {
    try std.testing.expect(!smartIsAbs("relative/path"));
}

test "smartIsAbs dot relative" {
    try std.testing.expect(!smartIsAbs("./path"));
}

test "smartIsAbs empty" {
    try std.testing.expect(!smartIsAbs(""));
}

test "smartJoin relative" {
    const allocator = std.testing.allocator;
    const result = try smartJoin(allocator, "/home", "user");
    defer allocator.free(result);
    try std.testing.expectEqualStrings("/home/user", result);
}

test "smartJoin absolute second" {
    const allocator = std.testing.allocator;
    const result = try smartJoin(allocator, "/home", "/etc");
    defer allocator.free(result);
    try std.testing.expectEqualStrings("/etc", result);
}
"""
    
    ⲃⲉⲏⲁⲃⲓⲟⲣⲥ: [
        { ⲟⲛⲟⲙⲁ: "smartJoin", ⲅⲓⲃⲉⲛ: "two paths", ⲧⲏⲉⲛ: "joined path" }
        { ⲟⲛⲟⲙⲁ: "smartIsAbs", ⲅⲓⲃⲉⲛ: "path", ⲧⲏⲉⲛ: "bool" }
    ]
    
    ⲧⲉⲥⲧⲥ: [
        { ⲟⲛⲟⲙⲁ: "golden_identity", ⲉⲝⲡⲉⲕⲧⲉⲇ: "3.0", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "smartIsAbs_unix", ⲓⲛⲡⲩⲧ: "/home/user", ⲉⲝⲡⲉⲕⲧⲉⲇ: "true", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "smartIsAbs_relative", ⲓⲛⲡⲩⲧ: "relative/path", ⲉⲝⲡⲉⲕⲧⲉⲇ: "false", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "smartIsAbs_dot", ⲓⲛⲡⲩⲧ: "./path", ⲉⲝⲡⲉⲕⲧⲉⲇ: "false", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "smartIsAbs_empty", ⲓⲛⲡⲩⲧ: "", ⲉⲝⲡⲉⲕⲧⲉⲇ: "false", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "smartJoin_relative", ⲓⲛⲡⲩⲧ: "/home + user", ⲉⲝⲡⲉⲕⲧⲉⲇ: "/home/user", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "smartJoin_absolute", ⲓⲛⲡⲩⲧ: "/home + /etc", ⲉⲝⲡⲉⲕⲧⲉⲇ: "/etc", ⲥⲧⲁⲧⲩⲥ: "✅" }
    ]
    
    ⲥⲧⲁⲧⲥ: {
        ⲅⲟ_ⲗⲓⲛⲉⲥ: 24
        ⲍⲓⲅ_ⲗⲓⲛⲉⲥ: 70
        ⲫⲩⲛⲕⲧⲓⲟⲛⲥ: 2
        ⲧⲉⲥⲧⲥ: 7
        ⲕⲟⲩⲉⲣⲁⲅⲉ: "100%"
    }
    
    ⲥⲓⲅⲛⲁⲧⲩⲣⲉ: "ⲒⲄⲖⲀ ⲔⲢⲨⲤⲎ ⲪⲒⲖⲈⲠⲀⲦⲎⲈⲜⲦ V1.0"
    ⲫⲟⲉⲛⲓⲝ: 999
}
