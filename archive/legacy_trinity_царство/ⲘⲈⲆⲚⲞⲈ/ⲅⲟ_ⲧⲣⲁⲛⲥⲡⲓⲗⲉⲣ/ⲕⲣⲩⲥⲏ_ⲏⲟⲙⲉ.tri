// ═══════════════════════════════════════════════════════════════════════════════
// ⲔⲢⲨⲤⲎ ⲎⲞⲘⲈ - Generated from crush_home.vibee
// ═══════════════════════════════════════════════════════════════════════════════
// SOURCE: github.com/charmbracelet/crush/internal/home/home.go
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

ⲧⲣⲓⲛⲓⲧⲓ ⲔⲢⲨⲤⲎ_ⲎⲞⲘⲈ {
    ⲟⲛⲟⲙⲁ: "Crush Home"
    ⲃⲉⲣⲥⲓⲁ: "1.0.0"
    ⲥⲟⲩⲣⲕⲉ: "charmbracelet/crush/internal/home"
    ⲥⲟⲩⲣⲕⲉ_ⲥⲡⲉⲕ: "specs/crush_home.vibee"
    
    ⲥⲁⲕⲣⲁ: {
        ⲪⲎⲒ: 1.618033988749895
        ⲦⲢⲒⲚⲒⲦⲨ: 3.0
    }
    
    ⲅⲟ_ⲥⲟⲩⲣⲕⲉ: """
package home

import (
    "os"
    "path/filepath"
    "strings"
)

var homedir, homedirErr = os.UserHomeDir()

func Dir() string {
    return homedir
}

func Short(p string) string {
    if homedir == "" || !strings.HasPrefix(p, homedir) {
        return p
    }
    return filepath.Join("~", strings.TrimPrefix(p, homedir))
}

func Long(p string) string {
    if homedir == "" || !strings.HasPrefix(p, "~") {
        return p
    }
    return strings.Replace(p, "~", homedir, 1)
}
"""
    
    ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: """
// ═══════════════════════════════════════════════════════════════════════════════
// home - Generated from Go by VIBEE Transpiler
// ═══════════════════════════════════════════════════════════════════════════════
// SOURCE: github.com/charmbracelet/crush/internal/home/home.go
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");

pub const PHI: f64 = 1.618033988749895;
pub const TRINITY: f64 = 3.0;

/// Get the user's home directory
/// Go original: os.UserHomeDir()
pub fn dir() ?[]const u8 {
    return std.posix.getenv("HOME");
}

/// Short replaces the actual home path with ~
/// Go original: filepath.Join("~", strings.TrimPrefix(p, homedir))
pub fn short(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const home = dir() orelse return try allocator.dupe(u8, path);
    
    if (!std.mem.startsWith(u8, path, home)) {
        return try allocator.dupe(u8, path);
    }
    
    const suffix = path[home.len..];
    if (suffix.len == 0) {
        return try allocator.dupe(u8, "~");
    }
    
    // Join "~" with the suffix
    var result = std.ArrayList(u8).init(allocator);
    try result.append('~');
    if (suffix[0] != '/') {
        try result.append('/');
    }
    try result.appendSlice(suffix);
    return result.toOwnedSlice();
}

/// Long replaces ~ with the actual home path
/// Go original: strings.Replace(p, "~", homedir, 1)
pub fn long(allocator: std.mem.Allocator, path: []const u8) ![]u8 {
    const home = dir() orelse return try allocator.dupe(u8, path);
    
    if (!std.mem.startsWith(u8, path, "~")) {
        return try allocator.dupe(u8, path);
    }
    
    const suffix = path[1..]; // Skip the ~
    
    var result = std.ArrayList(u8).init(allocator);
    try result.appendSlice(home);
    try result.appendSlice(suffix);
    return result.toOwnedSlice();
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "golden identity" {
    const phi_sq = PHI * PHI;
    const result = phi_sq + 1.0 / phi_sq;
    try std.testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}

test "dir returns home" {
    const home = dir();
    try std.testing.expect(home != null);
    try std.testing.expect(home.?.len > 0);
}

test "short with home prefix" {
    const allocator = std.testing.allocator;
    const home = dir() orelse return;
    
    // Create a path with home prefix
    var full_path = std.ArrayList(u8).init(allocator);
    defer full_path.deinit();
    try full_path.appendSlice(home);
    try full_path.appendSlice("/docs");
    
    const result = try short(allocator, full_path.items);
    defer allocator.free(result);
    
    try std.testing.expect(std.mem.startsWith(u8, result, "~"));
}

test "short without home prefix" {
    const allocator = std.testing.allocator;
    const result = try short(allocator, "/etc/config");
    defer allocator.free(result);
    try std.testing.expectEqualStrings("/etc/config", result);
}

test "long with tilde" {
    const allocator = std.testing.allocator;
    const home = dir() orelse return;
    
    const result = try long(allocator, "~/docs");
    defer allocator.free(result);
    
    try std.testing.expect(std.mem.startsWith(u8, result, home));
}

test "long without tilde" {
    const allocator = std.testing.allocator;
    const result = try long(allocator, "/etc/config");
    defer allocator.free(result);
    try std.testing.expectEqualStrings("/etc/config", result);
}
"""
    
    ⲧⲉⲥⲧⲥ: [
        { ⲟⲛⲟⲙⲁ: "golden_identity", ⲉⲝⲡⲉⲕⲧⲉⲇ: "3.0", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "dir_returns_home", ⲓⲛⲡⲩⲧ: "", ⲉⲝⲡⲉⲕⲧⲉⲇ: "not null", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "short_with_home", ⲓⲛⲡⲩⲧ: "/home/user/docs", ⲉⲝⲡⲉⲕⲧⲉⲇ: "~/docs", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "short_without_home", ⲓⲛⲡⲩⲧ: "/etc/config", ⲉⲝⲡⲉⲕⲧⲉⲇ: "/etc/config", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "long_with_tilde", ⲓⲛⲡⲩⲧ: "~/docs", ⲉⲝⲡⲉⲕⲧⲉⲇ: "/home/user/docs", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "long_without_tilde", ⲓⲛⲡⲩⲧ: "/etc/config", ⲉⲝⲡⲉⲕⲧⲉⲇ: "/etc/config", ⲥⲧⲁⲧⲩⲥ: "✅" }
    ]
    
    ⲥⲧⲁⲧⲥ: {
        ⲅⲟ_ⲗⲓⲛⲉⲥ: 32
        ⲍⲓⲅ_ⲗⲓⲛⲉⲥ: 95
        ⲫⲩⲛⲕⲧⲓⲟⲛⲥ: 3
        ⲧⲉⲥⲧⲥ: 6
    }
    
    ⲥⲓⲅⲛⲁⲧⲩⲣⲉ: "ⲒⲄⲖⲀ ⲔⲢⲨⲤⲎ ⲎⲞⲘⲈ V1.0"
    ⲫⲟⲉⲛⲓⲝ: 999
}
