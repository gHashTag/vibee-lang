// ═══════════════════════════════════════════════════════════════════════════════
// ⲔⲢⲨⲤⲎ ⲀⲚⲤⲒⲈⲜⲦ - Generated from crush_ansiext.vibee
// ═══════════════════════════════════════════════════════════════════════════════
// SOURCE: github.com/charmbracelet/crush/internal/ansiext/ansi.go
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

ⲧⲣⲓⲛⲓⲧⲓ ⲔⲢⲨⲤⲎ_ⲀⲚⲤⲒⲈⲜⲦ {
    ⲟⲛⲟⲙⲁ: "Crush AnsiExt"
    ⲃⲉⲣⲥⲓⲁ: "1.0.0"
    ⲥⲟⲩⲣⲕⲉ: "charmbracelet/crush/internal/ansiext"
    ⲥⲟⲩⲣⲕⲉ_ⲥⲡⲉⲕ: "specs/crush_ansiext.vibee"
    
    ⲥⲁⲕⲣⲁ: {
        ⲪⲎⲒ: 1.618033988749895
        ⲦⲢⲒⲚⲒⲦⲨ: 3.0
    }
    
    ⲅⲟ_ⲥⲟⲩⲣⲕⲉ: """
package ansiext

import (
    "strings"
    "github.com/charmbracelet/x/ansi"
)

func Escape(content string) string {
    var sb strings.Builder
    sb.Grow(len(content))
    for _, r := range content {
        switch {
        case r >= 0 && r <= 0x1f:
            sb.WriteRune('\\u2400' + r)
        case r == ansi.DEL:
            sb.WriteRune('\\u2421')
        default:
            sb.WriteRune(r)
        }
    }
    return sb.String()
}
"""
    
    ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ: """
// ═══════════════════════════════════════════════════════════════════════════════
// ansiext - Generated from Go by VIBEE Transpiler
// ═══════════════════════════════════════════════════════════════════════════════
// SOURCE: github.com/charmbracelet/crush/internal/ansiext/ansi.go
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");

pub const PHI: f64 = 1.618033988749895;
pub const TRINITY: f64 = 3.0;

/// Unicode Control Pictures block start
pub const CONTROL_PICTURES_BASE: u21 = 0x2400;

/// Unicode symbol for DEL (0x7F)
pub const DEL_PICTURE: u21 = 0x2421;

/// ASCII DEL character
pub const DEL: u8 = 0x7F;

/// Escape replaces control characters with their Unicode Control Picture
/// representations to ensure they are displayed correctly in the UI.
/// Go original: func Escape(content string) string
pub fn escape(allocator: std.mem.Allocator, content: []const u8) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    errdefer result.deinit();
    
    var i: usize = 0;
    while (i < content.len) {
        const byte = content[i];
        
        if (byte <= 0x1F) {
            // Control character 0x00-0x1F -> Unicode Control Picture
            const codepoint: u21 = CONTROL_PICTURES_BASE + @as(u21, byte);
            var buf: [4]u8 = undefined;
            const len = std.unicode.utf8Encode(codepoint, &buf) catch unreachable;
            try result.appendSlice(buf[0..len]);
        } else if (byte == DEL) {
            // DEL (0x7F) -> ␡ (U+2421)
            var buf: [4]u8 = undefined;
            const len = std.unicode.utf8Encode(DEL_PICTURE, &buf) catch unreachable;
            try result.appendSlice(buf[0..len]);
        } else {
            // Normal character
            try result.append(byte);
        }
        
        i += 1;
    }
    
    return result.toOwnedSlice();
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "golden identity" {
    const phi_sq = PHI * PHI;
    const result = phi_sq + 1.0 / phi_sq;
    try std.testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}

test "escape null" {
    const allocator = std.testing.allocator;
    const result = try escape(allocator, "\\x00");
    defer allocator.free(result);
    // ␀ is U+2400, encoded as 0xE2 0x90 0x80 in UTF-8
    try std.testing.expectEqualStrings("\\xe2\\x90\\x80", result);
}

test "escape normal text" {
    const allocator = std.testing.allocator;
    const result = try escape(allocator, "hello");
    defer allocator.free(result);
    try std.testing.expectEqualStrings("hello", result);
}

test "escape del" {
    const allocator = std.testing.allocator;
    const result = try escape(allocator, "\\x7f");
    defer allocator.free(result);
    // ␡ is U+2421, encoded as 0xE2 0x90 0xA1 in UTF-8
    try std.testing.expectEqualStrings("\\xe2\\x90\\xa1", result);
}

test "escape tab" {
    const allocator = std.testing.allocator;
    const result = try escape(allocator, "\\t");
    defer allocator.free(result);
    // ␉ is U+2409, encoded as 0xE2 0x90 0x89 in UTF-8
    try std.testing.expectEqualStrings("\\xe2\\x90\\x89", result);
}

test "escape mixed" {
    const allocator = std.testing.allocator;
    const result = try escape(allocator, "a\\x00b");
    defer allocator.free(result);
    try std.testing.expect(result.len > 3); // "a" + 3-byte UTF-8 + "b"
}
"""
    
    ⲧⲉⲥⲧⲥ: [
        { ⲟⲛⲟⲙⲁ: "golden_identity", ⲉⲝⲡⲉⲕⲧⲉⲇ: "3.0", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "escape_null", ⲓⲛⲡⲩⲧ: "\\x00", ⲉⲝⲡⲉⲕⲧⲉⲇ: "␀", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "escape_normal", ⲓⲛⲡⲩⲧ: "hello", ⲉⲝⲡⲉⲕⲧⲉⲇ: "hello", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "escape_del", ⲓⲛⲡⲩⲧ: "\\x7f", ⲉⲝⲡⲉⲕⲧⲉⲇ: "␡", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "escape_tab", ⲓⲛⲡⲩⲧ: "\\t", ⲉⲝⲡⲉⲕⲧⲉⲇ: "␉", ⲥⲧⲁⲧⲩⲥ: "✅" }
        { ⲟⲛⲟⲙⲁ: "escape_mixed", ⲓⲛⲡⲩⲧ: "a\\x00b", ⲉⲝⲡⲉⲕⲧⲉⲇ: "a␀b", ⲥⲧⲁⲧⲩⲥ: "✅" }
    ]
    
    ⲥⲧⲁⲧⲥ: {
        ⲅⲟ_ⲗⲓⲛⲉⲥ: 22
        ⲍⲓⲅ_ⲗⲓⲛⲉⲥ: 75
        ⲫⲩⲛⲕⲧⲓⲟⲛⲥ: 1
        ⲧⲉⲥⲧⲥ: 6
    }
    
    ⲥⲓⲅⲛⲁⲧⲩⲣⲉ: "ⲒⲄⲖⲀ ⲔⲢⲨⲤⲎ ⲀⲚⲤⲒⲈⲜⲦ V1.0"
    ⲫⲟⲉⲛⲓⲝ: 999
}
