// ═══════════════════════════════════════════════════════════════════════════════
// SOCIAL DYNAMICS — Социальная Динамика
// ═══════════════════════════════════════════════════════════════════════════════
//
// S = Σᵢⱼ influence(aᵢ, aⱼ) × trust(aᵢ, aⱼ)
//
// Layers: 27 | Papers: 52 | Behaviors: 81 | V_social ≈ 10^27
//
// Generated from: specs/social_dynamics.vibee
// ═══════════════════════════════════════════════════════════════════════════════

ⵣ.module social_dynamics {
    ⵣ.version = "3.0.0"
    
    // ═══════════════════════════════════════════════════════════════════════════
    // КОНСТАНТЫ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.const LAYERS = 27
    ⵣ.const PAPERS = 52
    ⵣ.const BEHAVIORS = 81
    ⵣ.const V_SOCIAL_EXPONENT = 27
    
    // Параметры консенсуса
    ⵣ.const RAFT_HEARTBEAT_MS = 150
    ⵣ.const RAFT_ELECTION_TIMEOUT_MIN = 300
    ⵣ.const RAFT_ELECTION_TIMEOUT_MAX = 500
    
    // PageRank параметры
    ⵣ.const PAGERANK_DAMPING = 0.85
    ⵣ.const PAGERANK_ITERATIONS = 100
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ТИПЫ ДАННЫХ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type AgentId = u64
    
    ⵣ.type Agent = struct {
        id: AgentId,
        reputation: f64,
        trust_scores: []f64,  // Trust in other agents
        influence: f64,
        resources: f64
    }
    
    ⵣ.type Network = struct {
        agents: []Agent,
        adjacency: [][]bool,  // Connection matrix
        weights: [][]f64      // Interaction weights
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // CONSENSUS TYPES
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type NodeState = enum {
        Follower,
        Candidate,
        Leader
    }
    
    ⵣ.type LogEntry = struct {
        term: u64,
        index: u64,
        command: []const u8
    }
    
    ⵣ.type RaftNode = struct {
        id: AgentId,
        state: NodeState,
        current_term: u64,
        voted_for: ?AgentId,
        log: []LogEntry,
        commit_index: u64,
        last_applied: u64
    }
    
    ⵣ.type ConsensusResult = struct {
        achieved: bool,
        value: []const u8,
        rounds: u32,
        participants: usize
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // VOTING TYPES
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type Vote = struct {
        voter: AgentId,
        option: usize,
        weight: f64
    }
    
    ⵣ.type VotingResult = struct {
        winner: usize,
        scores: []f64,
        participation: f64
    }
    
    ⵣ.type QuadraticVote = struct {
        voter: AgentId,
        votes: []i32,  // Can be negative
        budget_used: f64
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // REPUTATION SYSTEMS
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn pagerank(network: Network, iterations: usize) -> []f64 {
        var n = network.agents.len
        var ranks = ⵣ.alloc(f64, n)
        var new_ranks = ⵣ.alloc(f64, n)
        
        // Initialize
        for (ranks) |*r| {
            r.* = 1.0 / @intToFloat(f64, n)
        }
        
        for (0..iterations) |_| {
            for (0..n) |i| {
                var sum: f64 = 0.0
                for (0..n) |j| {
                    if (network.adjacency[j][i]) {
                        var out_degree = count_outlinks(network, j)
                        if (out_degree > 0) {
                            sum += ranks[j] / @intToFloat(f64, out_degree)
                        }
                    }
                }
                new_ranks[i] = (1.0 - PAGERANK_DAMPING) / @intToFloat(f64, n) + 
                               PAGERANK_DAMPING * sum
            }
            @memcpy(ranks, new_ranks)
        }
        
        return ranks
    }
    
    ⵣ.fn count_outlinks(network: Network, node: usize) -> usize {
        var count: usize = 0
        for (network.adjacency[node]) |connected| {
            if (connected) count += 1
        }
        return count
    }
    
    ⵣ.fn eigentrust(network: Network, iterations: usize) -> []f64 {
        var n = network.agents.len
        var trust = ⵣ.alloc(f64, n)
        
        // Initialize with uniform trust
        for (trust) |*t| {
            t.* = 1.0 / @intToFloat(f64, n)
        }
        
        // Iterate: t = C^T × t
        for (0..iterations) |_| {
            var new_trust = ⵣ.alloc(f64, n)
            for (0..n) |i| {
                var sum: f64 = 0.0
                for (0..n) |j| {
                    sum += network.weights[j][i] * trust[j]
                }
                new_trust[i] = sum
            }
            
            // Normalize
            var total: f64 = 0.0
            for (new_trust) |t| total += t
            for (new_trust) |*t| t.* /= total
            
            trust = new_trust
        }
        
        return trust
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // CONSENSUS PROTOCOLS
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn raft_elect_leader(nodes: []RaftNode) -> ?AgentId {
        // Simplified Raft leader election
        var max_term: u64 = 0
        var leader: ?AgentId = null
        
        for (nodes) |*node| {
            if (node.state == .Leader and node.current_term > max_term) {
                max_term = node.current_term
                leader = node.id
            }
        }
        
        if (leader == null) {
            // Start election
            var candidate_idx = ⵣ.random_int(0, nodes.len)
            nodes[candidate_idx].state = .Candidate
            nodes[candidate_idx].current_term += 1
            
            var votes: usize = 1  // Vote for self
            for (nodes) |*node, i| {
                if (i != candidate_idx and node.voted_for == null) {
                    node.voted_for = nodes[candidate_idx].id
                    votes += 1
                }
            }
            
            if (votes > nodes.len / 2) {
                nodes[candidate_idx].state = .Leader
                leader = nodes[candidate_idx].id
            }
        }
        
        return leader
    }
    
    ⵣ.fn raft_replicate(leader: *RaftNode, followers: []RaftNode, entry: LogEntry) -> bool {
        // Append to leader's log
        leader.log = ⵣ.append(leader.log, entry)
        
        // Replicate to followers
        var acks: usize = 1  // Leader counts as ack
        for (followers) |*follower| {
            if (follower.current_term <= leader.current_term) {
                follower.log = ⵣ.append(follower.log, entry)
                acks += 1
            }
        }
        
        // Commit if majority
        if (acks > (followers.len + 1) / 2) {
            leader.commit_index = entry.index
            return true
        }
        
        return false
    }
    
    ⵣ.fn byzantine_consensus(nodes: []Agent, value: []const u8, f: usize) -> ConsensusResult {
        // PBFT-style consensus (simplified)
        // Requires n >= 3f + 1
        var n = nodes.len
        if (n < 3 * f + 1) {
            return ConsensusResult{
                .achieved = false,
                .value = "",
                .rounds = 0,
                .participants = n
            }
        }
        
        // Pre-prepare, Prepare, Commit phases
        var prepare_votes: usize = 0
        var commit_votes: usize = 0
        
        // Simulate voting (honest nodes agree)
        for (nodes) |node, i| {
            if (i >= f) {  // Assume first f nodes are Byzantine
                prepare_votes += 1
            }
        }
        
        if (prepare_votes >= 2 * f + 1) {
            for (nodes) |node, i| {
                if (i >= f) {
                    commit_votes += 1
                }
            }
        }
        
        return ConsensusResult{
            .achieved = commit_votes >= 2 * f + 1,
            .value = value,
            .rounds = 3,
            .participants = n - f
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // VOTING MECHANISMS
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn majority_vote(votes: []Vote, options: usize) -> VotingResult {
        var scores = ⵣ.alloc(f64, options)
        for (scores) |*s| s.* = 0.0
        
        var total_weight: f64 = 0.0
        for (votes) |vote| {
            scores[vote.option] += vote.weight
            total_weight += vote.weight
        }
        
        var winner: usize = 0
        var max_score: f64 = 0.0
        for (scores) |score, i| {
            if (score > max_score) {
                max_score = score
                winner = i
            }
        }
        
        return VotingResult{
            .winner = winner,
            .scores = scores,
            .participation = @intToFloat(f64, votes.len)
        }
    }
    
    ⵣ.fn quadratic_vote(votes: []QuadraticVote, options: usize) -> VotingResult {
        var scores = ⵣ.alloc(f64, options)
        for (scores) |*s| s.* = 0.0
        
        for (votes) |vote| {
            for (vote.votes) |v, i| {
                // Cost = votes^2, so effective votes = sign(v) * sqrt(|v|)
                var effective = @copysign(@sqrt(@fabs(@intToFloat(f64, v))), @intToFloat(f64, v))
                scores[i] += effective
            }
        }
        
        var winner: usize = 0
        var max_score: f64 = -1e10
        for (scores) |score, i| {
            if (score > max_score) {
                max_score = score
                winner = i
            }
        }
        
        return VotingResult{
            .winner = winner,
            .scores = scores,
            .participation = @intToFloat(f64, votes.len)
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // NETWORK DYNAMICS
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn gossip_propagate(network: *Network, source: usize, message: []const u8) -> usize {
        var informed = ⵣ.alloc(bool, network.agents.len)
        for (informed) |*i| i.* = false
        informed[source] = true
        
        var count: usize = 1
        var rounds: usize = 0
        var fanout: usize = 3
        
        while (count < network.agents.len and rounds < 100) {
            var newly_informed = ⵣ.alloc(bool, network.agents.len)
            @memcpy(newly_informed, informed)
            
            for (0..network.agents.len) |i| {
                if (informed[i]) {
                    // Send to random neighbors
                    var sent: usize = 0
                    while (sent < fanout) {
                        var target = ⵣ.random_int(0, network.agents.len)
                        if (network.adjacency[i][target] and !informed[target]) {
                            newly_informed[target] = true
                            count += 1
                            sent += 1
                        }
                    }
                }
            }
            
            informed = newly_informed
            rounds += 1
        }
        
        return rounds
    }
    
    ⵣ.fn compute_clustering_coefficient(network: Network, node: usize) -> f64 {
        var neighbors = ⵣ.alloc(usize, 0)
        for (network.adjacency[node]) |connected, i| {
            if (connected) {
                neighbors = ⵣ.append(neighbors, i)
            }
        }
        
        var k = neighbors.len
        if (k < 2) return 0.0
        
        var triangles: usize = 0
        for (0..k) |i| {
            for (i + 1..k) |j| {
                if (network.adjacency[neighbors[i]][neighbors[j]]) {
                    triangles += 1
                }
            }
        }
        
        var possible = k * (k - 1) / 2
        return @intToFloat(f64, triangles) / @intToFloat(f64, possible)
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // GAME THEORY
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type Strategy = enum {
        Cooperate,
        Defect
    }
    
    ⵣ.fn prisoners_dilemma(s1: Strategy, s2: Strategy) -> [2]f64 {
        // Payoff matrix: (R, R), (S, T), (T, S), (P, P)
        // R=3 (reward), T=5 (temptation), S=0 (sucker), P=1 (punishment)
        return switch (s1) {
            .Cooperate => switch (s2) {
                .Cooperate => [2]f64{ 3.0, 3.0 },
                .Defect => [2]f64{ 0.0, 5.0 }
            },
            .Defect => switch (s2) {
                .Cooperate => [2]f64{ 5.0, 0.0 },
                .Defect => [2]f64{ 1.0, 1.0 }
            }
        }
    }
    
    ⵣ.fn tit_for_tat(history: []Strategy) -> Strategy {
        if (history.len == 0) return .Cooperate
        return history[history.len - 1]
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ТЕСТЫ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.test "pagerank_converges" {
        var network = create_test_network(10)
        var ranks = pagerank(network, 50)
        
        var sum: f64 = 0.0
        for (ranks) |r| sum += r
        ⵣ.expect_approx(sum, 1.0, 0.01)
    }
    
    ⵣ.test "consensus_achieved" {
        var nodes = create_test_agents(7)
        var result = byzantine_consensus(nodes, "value", 2)
        ⵣ.expect(result.achieved)
    }
    
    ⵣ.test "quadratic_voting_sybil_resistant" {
        var votes = [_]QuadraticVote{
            QuadraticVote{ .voter = 1, .votes = &[_]i32{4, 0, 0}, .budget_used = 16.0 },
            QuadraticVote{ .voter = 2, .votes = &[_]i32{0, 1, 0}, .budget_used = 1.0 },
            QuadraticVote{ .voter = 3, .votes = &[_]i32{0, 1, 0}, .budget_used = 1.0 },
            QuadraticVote{ .voter = 4, .votes = &[_]i32{0, 1, 0}, .budget_used = 1.0 }
        }
        var result = quadratic_vote(&votes, 3)
        // 4 votes for option 0 = 2 effective votes
        // 3 votes for option 1 = 3 effective votes
        ⵣ.expect_eq(result.winner, 1)
    }
    
    ⵣ.test "gossip_logarithmic" {
        var network = create_test_network(1000)
        var rounds = gossip_propagate(&network, 0, "message")
        ⵣ.expect(rounds < 20)  // O(log n)
    }
    
    // Helper functions
    ⵣ.fn create_test_network(n: usize) -> Network {
        var agents = ⵣ.alloc(Agent, n)
        var adjacency = ⵣ.alloc([]bool, n)
        var weights = ⵣ.alloc([]f64, n)
        
        for (0..n) |i| {
            agents[i] = Agent{
                .id = @intCast(AgentId, i),
                .reputation = 1.0,
                .trust_scores = ⵣ.alloc(f64, n),
                .influence = 1.0,
                .resources = 100.0
            }
            adjacency[i] = ⵣ.alloc(bool, n)
            weights[i] = ⵣ.alloc(f64, n)
            
            // Random connections
            for (0..n) |j| {
                adjacency[i][j] = ⵣ.random_f64() < 0.3
                weights[i][j] = if (adjacency[i][j]) ⵣ.random_f64() else 0.0
            }
        }
        
        return Network{
            .agents = agents,
            .adjacency = adjacency,
            .weights = weights
        }
    }
    
    ⵣ.fn create_test_agents(n: usize) -> []Agent {
        var agents = ⵣ.alloc(Agent, n)
        for (0..n) |i| {
            agents[i] = Agent{
                .id = @intCast(AgentId, i),
                .reputation = 1.0,
                .trust_scores = ⵣ.alloc(f64, n),
                .influence = 1.0,
                .resources = 100.0
            }
        }
        return agents
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ЭКСПОРТ
// ═══════════════════════════════════════════════════════════════════════════════

ⵣ.export {
    social_dynamics.pagerank,
    social_dynamics.eigentrust,
    social_dynamics.raft_elect_leader,
    social_dynamics.byzantine_consensus,
    social_dynamics.majority_vote,
    social_dynamics.quadratic_vote,
    social_dynamics.gossip_propagate,
    social_dynamics.prisoners_dilemma,
    social_dynamics.tit_for_tat
}
