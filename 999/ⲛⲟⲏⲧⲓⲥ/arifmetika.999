// ============================================
// ТРОИЧНАЯ АРИФМЕТИКА С БАЛАНСИРОВКОЙ
// Симметричная система счисления
// ============================================
//
// Основано на:
//   - Сетунь (МГУ, 1958)
//   - TREX (Трифонов, 2021)
//   - Balanced Ternary (Knuth)
//
// Преимущества троичной системы:
//   1. Округление = отбрасывание младшего разряда
//   2. Знак числа = знак старшего разряда
//   3. Инверсия = смена знаков всех разрядов
//   4. Нет переполнения при сложении двух чисел
//
// ============================================

Ⲩ yadro

// ============================================
// БАЗОВЫЕ ТИПЫ
// ============================================

// Трит: {Ⲃ, Ⲟ, Ⲁ} = {-1, 0, +1}
Ⲉ Ⲧ:
  Ⲃ    // -1
  Ⲟ    // 0
  Ⲁ    // +1

// Трибл: 3 трита = 27 значений [-13, +13]
Ⲏ Ⲧ3:
  Ⲁ: Ⲧ  // старший
  Ⲃ: Ⲧ  // средний
  Ⲅ: Ⲧ  // младший

// Трайт: 9 тритов = 3 трибла = [-9841, +9841]
Ⲏ Ⲧ9:
  Ⲁ: Ⲧ3  // старший трибл
  Ⲃ: Ⲧ3  // средний трибл
  Ⲅ: Ⲧ3  // младший трибл

// Длинное троичное: 27 тритов = 9 триблов
Ⲏ Ⲧ27:
  данные: [Ⲧ; 27]

// ============================================
// ПРЕОБРАЗОВАНИЯ
// ============================================

// Трит в число
Ⲫ Ⲧ_в_число(т: Ⲧ) -> Ⲋ:
  Ⲝ т:
    Ⲃ: Ⲣ -1
    Ⲟ: Ⲣ 0
    Ⲁ: Ⲣ +1

// Число в трит
Ⲫ число_в_Ⲧ(н: Ⲋ) -> Ⲧ:
  Ⲝ н < 0: Ⲣ Ⲃ
  Ⲝ н > 0: Ⲣ Ⲁ
  Ⲣ Ⲟ

// Трибл в число [-13, +13]
Ⲫ Ⲧ3_в_число(т: Ⲧ3) -> Ⲋ:
  Ⲣ Ⲧ_в_число(т.Ⲁ) * 9 + Ⲧ_в_число(т.Ⲃ) * 3 + Ⲧ_в_число(т.Ⲅ)

// Число в трибл (с балансировкой)
Ⲫ число_в_Ⲧ3(н: Ⲋ) -> Ⲧ3:
  Ⲙ остаток = н
  Ⲙ результат = Ⲧ3 { Ⲁ: Ⲟ, Ⲃ: Ⲟ, Ⲅ: Ⲟ }
  
  // Младший разряд
  Ⲙ (т, перенос) = балансировать(остаток % 3)
  результат.Ⲅ = т
  остаток = остаток / 3 + перенос
  
  // Средний разряд
  Ⲙ (т2, перенос2) = балансировать(остаток % 3)
  результат.Ⲃ = т2
  остаток = остаток / 3 + перенос2
  
  // Старший разряд
  результат.Ⲁ = число_в_Ⲧ(остаток)
  
  Ⲣ результат

// Балансировка: преобразование {0,1,2} в {-1,0,+1}
Ⲫ балансировать(н: Ⲋ) -> (Ⲧ, Ⲋ):
  Ⲝ н:
    0: Ⲣ (Ⲟ, 0)
    1: Ⲣ (Ⲁ, 0)
    2: Ⲣ (Ⲃ, 1)   // 2 = -1 + 3*1
    -1: Ⲣ (Ⲃ, 0)
    -2: Ⲣ (Ⲁ, -1)  // -2 = +1 + 3*(-1)
    _: Ⲣ (Ⲟ, н / 3)

// Трайт в число [-9841, +9841]
Ⲫ Ⲧ9_в_число(т: Ⲧ9) -> Ⲋ:
  Ⲣ Ⲧ3_в_число(т.Ⲁ) * 729 + Ⲧ3_в_число(т.Ⲃ) * 27 + Ⲧ3_в_число(т.Ⲅ)

// Число в трайт
Ⲫ число_в_Ⲧ9(н: Ⲋ) -> Ⲧ9:
  Ⲙ остаток = н
  Ⲙ результат = Ⲧ9 {}
  
  результат.Ⲅ = число_в_Ⲧ3(остаток % 27)
  остаток = остаток / 27
  результат.Ⲃ = число_в_Ⲧ3(остаток % 27)
  остаток = остаток / 27
  результат.Ⲁ = число_в_Ⲧ3(остаток)
  
  Ⲣ результат

// ============================================
// БАЗОВЫЕ ОПЕРАЦИИ
// ============================================

// Инверсия трита
Ⲫ Ⲧ_инв(т: Ⲧ) -> Ⲧ:
  Ⲝ т:
    Ⲃ: Ⲣ Ⲁ
    Ⲟ: Ⲣ Ⲟ
    Ⲁ: Ⲣ Ⲃ

// Инверсия трибла
Ⲫ Ⲧ3_инв(т: Ⲧ3) -> Ⲧ3:
  Ⲣ Ⲧ3 {
    Ⲁ: Ⲧ_инв(т.Ⲁ),
    Ⲃ: Ⲧ_инв(т.Ⲃ),
    Ⲅ: Ⲧ_инв(т.Ⲅ)
  }

// Инверсия трайта
Ⲫ Ⲧ9_инв(т: Ⲧ9) -> Ⲧ9:
  Ⲣ Ⲧ9 {
    Ⲁ: Ⲧ3_инв(т.Ⲁ),
    Ⲃ: Ⲧ3_инв(т.Ⲃ),
    Ⲅ: Ⲧ3_инв(т.Ⲅ)
  }

// Знак числа (по старшему разряду)
Ⲫ Ⲧ9_знак(т: Ⲧ9) -> Ⲧ:
  // Ищем первый ненулевой трит
  Ⲝ т.Ⲁ.Ⲁ != Ⲟ: Ⲣ т.Ⲁ.Ⲁ
  Ⲝ т.Ⲁ.Ⲃ != Ⲟ: Ⲣ т.Ⲁ.Ⲃ
  Ⲝ т.Ⲁ.Ⲅ != Ⲟ: Ⲣ т.Ⲁ.Ⲅ
  Ⲝ т.Ⲃ.Ⲁ != Ⲟ: Ⲣ т.Ⲃ.Ⲁ
  Ⲝ т.Ⲃ.Ⲃ != Ⲟ: Ⲣ т.Ⲃ.Ⲃ
  Ⲝ т.Ⲃ.Ⲅ != Ⲟ: Ⲣ т.Ⲃ.Ⲅ
  Ⲝ т.Ⲅ.Ⲁ != Ⲟ: Ⲣ т.Ⲅ.Ⲁ
  Ⲝ т.Ⲅ.Ⲃ != Ⲟ: Ⲣ т.Ⲅ.Ⲃ
  Ⲣ т.Ⲅ.Ⲅ

// Модуль числа
Ⲫ Ⲧ9_модуль(т: Ⲧ9) -> Ⲧ9:
  Ⲝ Ⲧ9_знак(т) == Ⲃ:
    Ⲁ: Ⲣ Ⲧ9_инв(т)
  Ⲣ т

// ============================================
// СЛОЖЕНИЕ
// ============================================

// Сложение тритов с переносом
Ⲫ Ⲧ_сложить(а: Ⲧ, б: Ⲧ, перенос: Ⲧ) -> (Ⲧ, Ⲧ):
  Ⲙ сумма = Ⲧ_в_число(а) + Ⲧ_в_число(б) + Ⲧ_в_число(перенос)
  
  Ⲝ сумма:
    -3: Ⲣ (Ⲟ, Ⲃ)   // -3 = 0 + (-1)*3
    -2: Ⲣ (Ⲁ, Ⲃ)   // -2 = +1 + (-1)*3
    -1: Ⲣ (Ⲃ, Ⲟ)   // -1 = -1 + 0*3
     0: Ⲣ (Ⲟ, Ⲟ)   // 0 = 0 + 0*3
    +1: Ⲣ (Ⲁ, Ⲟ)   // +1 = +1 + 0*3
    +2: Ⲣ (Ⲃ, Ⲁ)   // +2 = -1 + (+1)*3
    +3: Ⲣ (Ⲟ, Ⲁ)   // +3 = 0 + (+1)*3
    _: Ⲣ (Ⲟ, Ⲟ)    // не должно случиться

// Сложение триблов
Ⲫ Ⲧ3_сложить(а: Ⲧ3, б: Ⲧ3) -> (Ⲧ3, Ⲧ):
  Ⲙ перенос = Ⲟ
  Ⲙ результат = Ⲧ3 { Ⲁ: Ⲟ, Ⲃ: Ⲟ, Ⲅ: Ⲟ }
  
  // Младший разряд
  Ⲙ (т, п) = Ⲧ_сложить(а.Ⲅ, б.Ⲅ, перенос)
  результат.Ⲅ = т
  перенос = п
  
  // Средний разряд
  Ⲙ (т2, п2) = Ⲧ_сложить(а.Ⲃ, б.Ⲃ, перенос)
  результат.Ⲃ = т2
  перенос = п2
  
  // Старший разряд
  Ⲙ (т3, п3) = Ⲧ_сложить(а.Ⲁ, б.Ⲁ, перенос)
  результат.Ⲁ = т3
  
  Ⲣ (результат, п3)

// Сложение трайтов
Ⲫ Ⲧ9_сложить(а: Ⲧ9, б: Ⲧ9) -> Ⲧ9:
  Ⲙ результат = Ⲧ9 {}
  
  // Младший трибл
  Ⲙ (т1, п1) = Ⲧ3_сложить(а.Ⲅ, б.Ⲅ)
  результат.Ⲅ = т1
  
  // Средний трибл + перенос
  Ⲙ перенос_трибл = Ⲧ3 { Ⲁ: Ⲟ, Ⲃ: Ⲟ, Ⲅ: п1 }
  Ⲙ (т2_промеж, _) = Ⲧ3_сложить(а.Ⲃ, б.Ⲃ)
  Ⲙ (т2, п2) = Ⲧ3_сложить(т2_промеж, перенос_трибл)
  результат.Ⲃ = т2
  
  // Старший трибл + перенос
  Ⲙ перенос_трибл2 = Ⲧ3 { Ⲁ: Ⲟ, Ⲃ: Ⲟ, Ⲅ: п2 }
  Ⲙ (т3_промеж, _) = Ⲧ3_сложить(а.Ⲁ, б.Ⲁ)
  Ⲙ (т3, _) = Ⲧ3_сложить(т3_промеж, перенос_трибл2)
  результат.Ⲁ = т3
  
  Ⲣ результат

// Вычитание = сложение с инверсией
Ⲫ Ⲧ9_вычесть(а: Ⲧ9, б: Ⲧ9) -> Ⲧ9:
  Ⲣ Ⲧ9_сложить(а, Ⲧ9_инв(б))

// ============================================
// УМНОЖЕНИЕ
// ============================================

// Умножение тритов
Ⲫ Ⲧ_умножить(а: Ⲧ, б: Ⲧ) -> Ⲧ:
  Ⲝ а == Ⲟ || б == Ⲟ: Ⲣ Ⲟ
  Ⲝ а == б: Ⲣ Ⲁ
  Ⲣ Ⲃ

// Умножение трибла на трит
Ⲫ Ⲧ3_умножить_на_Ⲧ(а: Ⲧ3, б: Ⲧ) -> Ⲧ3:
  Ⲝ б == Ⲟ: Ⲣ Ⲧ3 { Ⲁ: Ⲟ, Ⲃ: Ⲟ, Ⲅ: Ⲟ }
  Ⲝ б == Ⲁ: Ⲣ а
  Ⲣ Ⲧ3_инв(а)

// Умножение триблов (школьный алгоритм)
Ⲫ Ⲧ3_умножить(а: Ⲧ3, б: Ⲧ3) -> (Ⲧ3, Ⲧ3):
  // Результат может быть до 6 тритов
  Ⲙ сумма = число_в_Ⲧ9(Ⲧ3_в_число(а) * Ⲧ3_в_число(б))
  Ⲣ (сумма.Ⲁ, Ⲧ3 { Ⲁ: сумма.Ⲃ.Ⲁ, Ⲃ: сумма.Ⲃ.Ⲃ, Ⲅ: сумма.Ⲃ.Ⲅ })

// Умножение трайтов
Ⲫ Ⲧ9_умножить(а: Ⲧ9, б: Ⲧ9) -> Ⲧ9:
  // Упрощённо: через числа
  Ⲙ результат = Ⲧ9_в_число(а) * Ⲧ9_в_число(б)
  Ⲣ число_в_Ⲧ9(результат)

// ============================================
// ДЕЛЕНИЕ
// ============================================

// Деление трайтов
Ⲫ Ⲧ9_делить(а: Ⲧ9, б: Ⲧ9) -> (Ⲧ9, Ⲧ9):
  Ⲙ делимое = Ⲧ9_в_число(а)
  Ⲙ делитель = Ⲧ9_в_число(б)
  
  Ⲝ делитель == 0:
    Ⲁ: ошибка("Деление на ноль")
  
  Ⲙ частное = делимое / делитель
  Ⲙ остаток = делимое % делитель
  
  // Балансировка остатка
  Ⲝ остаток > делитель / 2:
    Ⲁ:
      частное += 1
      остаток -= делитель
  Ⲝ остаток < -делитель / 2:
    Ⲁ:
      частное -= 1
      остаток += делитель
  
  Ⲣ (число_в_Ⲧ9(частное), число_в_Ⲧ9(остаток))

// ============================================
// СРАВНЕНИЕ
// ============================================

// Сравнение трайтов
Ⲫ Ⲧ9_сравнить(а: Ⲧ9, б: Ⲧ9) -> Ⲧ:
  // Сравниваем по первому отличающемуся разряду
  Ⲝ а.Ⲁ.Ⲁ != б.Ⲁ.Ⲁ: Ⲣ Ⲧ_сравнить(а.Ⲁ.Ⲁ, б.Ⲁ.Ⲁ)
  Ⲝ а.Ⲁ.Ⲃ != б.Ⲁ.Ⲃ: Ⲣ Ⲧ_сравнить(а.Ⲁ.Ⲃ, б.Ⲁ.Ⲃ)
  Ⲝ а.Ⲁ.Ⲅ != б.Ⲁ.Ⲅ: Ⲣ Ⲧ_сравнить(а.Ⲁ.Ⲅ, б.Ⲁ.Ⲅ)
  Ⲝ а.Ⲃ.Ⲁ != б.Ⲃ.Ⲁ: Ⲣ Ⲧ_сравнить(а.Ⲃ.Ⲁ, б.Ⲃ.Ⲁ)
  Ⲝ а.Ⲃ.Ⲃ != б.Ⲃ.Ⲃ: Ⲣ Ⲧ_сравнить(а.Ⲃ.Ⲃ, б.Ⲃ.Ⲃ)
  Ⲝ а.Ⲃ.Ⲅ != б.Ⲃ.Ⲅ: Ⲣ Ⲧ_сравнить(а.Ⲃ.Ⲅ, б.Ⲃ.Ⲅ)
  Ⲝ а.Ⲅ.Ⲁ != б.Ⲅ.Ⲁ: Ⲣ Ⲧ_сравнить(а.Ⲅ.Ⲁ, б.Ⲅ.Ⲁ)
  Ⲝ а.Ⲅ.Ⲃ != б.Ⲅ.Ⲃ: Ⲣ Ⲧ_сравнить(а.Ⲅ.Ⲃ, б.Ⲅ.Ⲃ)
  Ⲝ а.Ⲅ.Ⲅ != б.Ⲅ.Ⲅ: Ⲣ Ⲧ_сравнить(а.Ⲅ.Ⲅ, б.Ⲅ.Ⲅ)
  Ⲣ Ⲟ  // равны

// Сравнение тритов
Ⲫ Ⲧ_сравнить(а: Ⲧ, б: Ⲧ) -> Ⲧ:
  Ⲙ разница = Ⲧ_в_число(а) - Ⲧ_в_число(б)
  Ⲣ число_в_Ⲧ(разница)

// ============================================
// TREX ПРЕДСТАВЛЕНИЕ
// ============================================

// Трибл в TREX символ
Ⲫ Ⲧ3_в_TREX(т: Ⲧ3) -> Ⲥ:
  Ⲙ значение = Ⲧ3_в_число(т)
  Ⲝ значение < 0:
    Ⲁ: Ⲣ "mlkjihgfedcba"[-значение - 1]
  Ⲝ значение > 0:
    Ⲁ: Ⲣ "ABCDEFGHIJKLM"[значение - 1]
  Ⲣ "0"

// Трайт в TREX строку
Ⲫ Ⲧ9_в_TREX(т: Ⲧ9) -> Ⲥ:
  Ⲣ Ⲧ3_в_TREX(т.Ⲁ) + Ⲧ3_в_TREX(т.Ⲃ) + Ⲧ3_в_TREX(т.Ⲅ)

// TREX символ в трибл
Ⲫ TREX_в_Ⲧ3(с: Ⲥ) -> Ⲧ3:
  Ⲝ с == "0": Ⲣ число_в_Ⲧ3(0)
  Ⲝ с >= "a" && с <= "m":
    Ⲁ: Ⲣ число_в_Ⲧ3(-(с - 'a' + 1))
  Ⲝ с >= "A" && с <= "M":
    Ⲁ: Ⲣ число_в_Ⲧ3(с - 'A' + 1)
  Ⲣ число_в_Ⲧ3(0)

// ============================================
// ПРИМЕРЫ
// ============================================

// Пример: 10 + 5 = 15
// 10 = +0+ (в троичной)
// 5 = +-- (в троичной)
// 15 = +--0 (в троичной)

@Ⲧ
Ⲫ тест_сложение():
  Ⲙ а = число_в_Ⲧ9(10)
  Ⲙ б = число_в_Ⲧ9(5)
  Ⲙ сумма = Ⲧ9_сложить(а, б)
  assert_eq(Ⲧ9_в_число(сумма), 15)

@Ⲧ
Ⲫ тест_инверсия():
  Ⲙ а = число_в_Ⲧ9(42)
  Ⲙ минус_а = Ⲧ9_инв(а)
  assert_eq(Ⲧ9_в_число(минус_а), -42)
  
  // a + (-a) = 0
  Ⲙ сумма = Ⲧ9_сложить(а, минус_а)
  assert_eq(Ⲧ9_в_число(сумма), 0)

@Ⲧ
Ⲫ тест_TREX():
  Ⲙ а = число_в_Ⲧ9(100)
  Ⲙ trex = Ⲧ9_в_TREX(а)
  печать(trex)  // "0DK" или подобное
