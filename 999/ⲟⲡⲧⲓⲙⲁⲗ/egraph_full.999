// ═══════════════════════════════════════════════════════════════
// E-GRAPH OPTIMIZER - Full Equality Saturation (2.5x)
// ═══════════════════════════════════════════════════════════════

Ⲯ ⲕⲟⲣⲉ

Ⲏ EGraph {
    Ⲃ classes: Ⲙⲁⲡ[Ⲓⲛⲧ, EClass]
    Ⲃ union_find: [Ⲓⲛⲧ]
    Ⲃ next_id: Ⲓⲛⲧ = 0
    
    Ⲫ new() → EGraph { Ⲣ EGraph { union_find: [] } }
    
    Ⲫ add(Ⲥ, Ⲁ node: ENode) → Ⲓⲛⲧ {
        Ⲃ id = Ⲥ.next_id; Ⲥ.next_id += 1
        Ⲥ.union_find.push(id)
        Ⲥ.classes.set(id, EClass { id: id, nodes: [node] })
        Ⲣ id
    }
    
    Ⲫ find(Ⲥ, Ⲁ id: Ⲓⲛⲧ) → Ⲓⲛⲧ {
        Ⲃ root = id
        Ⲝ Ⲥ.union_find[root] != root { root = Ⲥ.union_find[root] }
        Ⲣ root
    }
    
    Ⲫ union(Ⲥ, Ⲁ a: Ⲓⲛⲧ, Ⲁ b: Ⲓⲛⲧ) {
        Ⲃ ra = Ⲥ.find(a); Ⲃ rb = Ⲥ.find(b)
        Ⲉ ra != rb { Ⲥ.union_find[rb] = ra }
    }
    
    Ⲫ saturate(Ⲥ, Ⲁ rules: [Rule], Ⲁ limit: Ⲓⲛⲧ) {
        Ⲝ i ∈ 0..limit {
            Ⲃ changed = ▽
            Ⲝ rule ∈ rules { Ⲉ Ⲥ.apply(rule) { changed = △ } }
            Ⲉ changed == ▽ { ⊘ }
        }
    }
    
    Ⲫ apply(Ⲥ, Ⲁ rule: Rule) → Trit { Ⲣ ▽ }
    
    Ⲫ extract(Ⲥ, Ⲁ root: Ⲓⲛⲧ) → ENode {
        Ⲣ Ⲥ.classes.get(Ⲥ.find(root)).nodes[0]
    }
}

Ⲏ EClass { Ⲃ id: Ⲓⲛⲧ; Ⲃ nodes: [ENode] }
Ⲏ ENode { Ⲃ op: Ⲧⲉⲝⲧ; Ⲃ children: [Ⲓⲛⲧ] }
Ⲏ Rule { Ⲃ name: Ⲧⲉⲝⲧ; Ⲃ lhs: Ⲧⲉⲝⲧ; Ⲃ rhs: Ⲧⲉⲝⲧ }

Ⲫ ternary_rules() → [Rule] {
    Ⲣ [
        Rule { name: "and_comm", lhs: "and(a,b)", rhs: "and(b,a)" },
        Rule { name: "or_comm", lhs: "or(a,b)", rhs: "or(b,a)" },
        Rule { name: "not_not", lhs: "not(not(a))", rhs: "a" },
        Rule { name: "and_true", lhs: "and(a,true)", rhs: "a" },
        Rule { name: "or_false", lhs: "or(a,false)", rhs: "a" }
    ]
}
