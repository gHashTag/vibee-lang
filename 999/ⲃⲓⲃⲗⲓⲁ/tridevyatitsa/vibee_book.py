#!/usr/bin/env python3
"""
ГЕНЕРАТОР КНИГИ 999 С ЯЗЫКОМ VIBEE
Каждая глава = буква алфавита + тема языка Vibee
"""

import json
from pathlib import Path

# 27 тем языка Vibee (по одной на букву)
VIBEE_TOPICS = {
    1: {
        "тема": "Начало — let и const",
        "код": '''// Ⲁ = 1 — НАЧАЛО
// Объявление переменных

let начало = 1           // изменяемая
const ИСТИНА = true      // неизменяемая
const π = 3.14159        // константа

// Всё начинается с объявления
let герой = "Иван"
let сила = 100''',
        "объяснение": "let создаёт изменяемую переменную, const — неизменяемую константу"
    },
    2: {
        "тема": "Двойственность — bool и Tribool",
        "код": '''// Ⲃ = 2 — ДВОЙСТВЕННОСТЬ
// Логические типы

let да: bool = true
let нет: bool = false

// Но в Vibee есть ТРЕТЬЕ!
type Tribool = enum {
    True,     // Истина
    False,    // Ложь  
    Unknown   // Неизвестно
}

let может_быть: Tribool = .Unknown''',
        "объяснение": "Tribool добавляет третье состояние — Unknown, как в реальном мире"
    },
    3: {
        "тема": "Троица — три типа данных",
        "код": '''// Ⲅ = 3 — ТРОИЦА
// Три царства типов

// Медное — простые типы
let число: i32 = 27
let дробь: f64 = 3.14
let символ: char = 'Ⲅ'

// Серебряное — составные
let массив: [i32; 3] = [1, 2, 3]
let кортеж: (i32, str) = (27, "царство")

// Золотое — пользовательские
struct Герой { имя: str, сила: i32 }''',
        "объяснение": "Три царства типов: примитивы, составные, пользовательские"
    },
    4: {
        "тема": "Основа — struct",
        "код": '''// Ⲇ = 4 — ОСНОВА
// Структуры — фундамент данных

struct Богатырь {
    имя: String,
    сила: i32,
    мудрость: i32,
    здоровье: i32,  // 4 поля = 4 стороны
}

let илья = Богатырь {
    имя: "Илья Муромец",
    сила: 100,
    мудрость: 80,
    здоровье: 100,
}''',
        "объяснение": "struct объединяет данные в единую структуру"
    },
    5: {
        "тема": "Жизнь — функции fn",
        "код": '''// Ⲉ = 5 — ЖИЗНЬ
// Функции оживляют код

fn дышать() {
    println!("Вдох... Выдох...")
}

fn жить(имя: str) -> String {
    format!("{} живёт!", имя)
}

fn сила_жизни(здоровье: i32) -> bool {
    здоровье > 0
}

// Вызов
дышать()
let статус = жить("Иван")''',
        "объяснение": "fn создаёт функцию — единицу действия в программе"
    },
    6: {
        "тема": "Гармония — impl методы",
        "код": '''// Ⲋ = 6 — ГАРМОНИЯ
// Методы связывают данные и действия

struct Гусли {
    струны: i32,
    настроены: bool,
}

impl Гусли {
    fn новые() -> Self {
        Гусли { струны: 6, настроены: false }
    }
    
    fn настроить(&mut self) {
        self.настроены = true
    }
    
    fn играть(&self) -> &str {
        if self.настроены { "♪♫♪" } else { "..." }
    }
}''',
        "объяснение": "impl добавляет методы к структуре, создавая гармонию данных и действий"
    },
    7: {
        "тема": "Тайна — Option",
        "код": '''// Ⲍ = 7 — ТАЙНА
// Option скрывает неизвестность

type Option<T> = enum {
    Some(T),  // Есть значение
    None,     // Пусто (тайна)
}

fn найти_клад(карта: &Карта) -> Option<Клад> {
    if карта.верная {
        Some(Клад::новый())
    } else {
        None  // Тайна не раскрыта
    }
}

match найти_клад(&карта) {
    Some(клад) => радоваться(клад),
    None => искать_дальше(),
}''',
        "объяснение": "Option<T> — значение может быть (Some) или отсутствовать (None)"
    },
    8: {
        "тема": "Бесконечность — циклы loop",
        "код": '''// Ⲏ = 8 — БЕСКОНЕЧНОСТЬ
// Циклы — вечное движение

// Бесконечный цикл
loop {
    жить()
    if устал { break }
}

// Цикл while
while герой.жив() {
    герой.сражаться()
}

// Цикл for (конечный в бесконечном)
for i in 1..=∞ {
    println!("Шаг {}", i)
    if достиг_цели { break }
}''',
        "объяснение": "loop — бесконечный цикл, while и for — управляемые циклы"
    },
    9: {
        "тема": "Завершение — return и Result",
        "код": '''// Ⲑ = 9 — ЗАВЕРШЕНИЕ
// Result завершает с успехом или ошибкой

type Result<T, E> = enum {
    Ok(T),    // Успех
    Err(E),   // Ошибка
}

fn победить_змея() -> Result<Победа, Поражение> {
    if сила > 100 {
        Ok(Победа::новая())
    } else {
        Err(Поражение::новое())
    }
}

// Обработка результата
match победить_змея() {
    Ok(победа) => праздновать(победа),
    Err(e) => учиться_на_ошибках(e),
}''',
        "объяснение": "Result<T,E> — операция завершается успехом Ok(T) или ошибкой Err(E)"
    },
    10: {
        "тема": "Движение — итераторы iter",
        "код": '''// Ⲓ = 10 — ДВИЖЕНИЕ
// Итераторы — движение по данным

let богатыри = ["Илья", "Добрыня", "Алёша"]

// Движение по массиву
for богатырь in богатыри.iter() {
    println!("{} в походе", богатырь)
}

// Цепочка преобразований
let сила_всех: i32 = богатыри
    .iter()
    .map(|б| б.сила)
    .filter(|с| *с > 50)
    .sum()''',
        "объяснение": "iter() создаёт итератор для последовательного обхода коллекции"
    },
    11: {
        "тема": "Сила — владение ownership",
        "код": '''// Ⲕ = 11 — СИЛА
// Владение — сила над памятью

let меч = Меч::новый()  // Иван владеет мечом

// Передача владения (move)
let новый_владелец = меч  // меч перешёл
// меч больше недоступен!

// Заимствование (borrow)
let меч2 = Меч::новый()
let ссылка = &меч2      // временно одолжил
использовать(ссылка)
// меч2 всё ещё у владельца''',
        "объяснение": "Ownership — каждое значение имеет одного владельца"
    },
    12: {
        "тема": "Свет — generics <T>",
        "код": '''// Ⲗ = 12 — СВЕТ
// Generics освещают путь для любых типов

// Функция для любого типа
fn осветить<T: Display>(что: T) {
    println!("Свет на: {}", что)
}

// Структура для любого типа
struct Сундук<T> {
    содержимое: T,
}

let золото = Сундук { содержимое: 1000 }
let меч = Сундук { содержимое: Меч::новый() }''',
        "объяснение": "Generics <T> позволяют писать код для любых типов"
    },
    13: {
        "тема": "Мудрость — trait",
        "код": '''// Ⲙ = 13 — МУДРОСТЬ
// Traits — мудрость поведения

trait Мудрый {
    fn думать(&self) -> String;
    fn советовать(&self, кому: &str) -> String;
}

impl Мудрый for Старец {
    fn думать(&self) -> String {
        "Размышляю о вечном...".into()
    }
    
    fn советовать(&self, кому: &str) -> String {
        format!("{}, иди туда, не знаю куда", кому)
    }
}''',
        "объяснение": "trait определяет поведение, которое типы могут реализовать"
    },
    14: {
        "тема": "Порядок — enum",
        "код": '''// Ⲛ = 14 — ПОРЯДОК
// Enum упорядочивает варианты

enum Путь {
    Направо,   // Коня потеряешь
    Налево,    // Себя потеряешь
    Прямо,     // Счастье найдёшь
}

enum Состояние {
    Жив { здоровье: i32 },
    Ранен { урон: i32 },
    Мёртв,
}

let выбор = Путь::Прямо
match выбор {
    Путь::Прямо => идти_к_счастью(),
    _ => сожалеть(),
}''',
        "объяснение": "enum создаёт тип с фиксированным набором вариантов"
    },
    15: {
        "тема": "Связь — references &",
        "код": '''// Ⲝ = 15 — СВЯЗЬ
// Ссылки связывают без владения

let герой = Герой::новый()

// Неизменяемая ссылка
let взгляд = &герой        // смотрим, не трогаем
println!("{}", взгляд.имя)

// Изменяемая ссылка  
let лечение = &mut герой   // можем изменить
лечение.здоровье += 10

// Только одна &mut ИЛИ много &
// Это закон Vibee!''',
        "объяснение": "& — неизменяемая ссылка, &mut — изменяемая. Нельзя смешивать"
    },
    16: {
        "тема": "Целостность — модули mod",
        "код": '''// Ⲟ = 16 — ЦЕЛОСТНОСТЬ
// Модули объединяют код в целое

mod царство {
    pub struct Царь { pub имя: String }
    
    mod тайное {
        fn секрет() { /* скрыто */ }
    }
    
    pub mod открытое {
        pub fn войти() { println!("Добро пожаловать!") }
    }
}

// Использование
use царство::Царь;
use царство::открытое::войти;

войти()''',
        "объяснение": "mod создаёт модуль, pub делает элементы публичными"
    },
    17: {
        "тема": "Путь — use и пути",
        "код": '''// Ⲡ = 17 — ПУТЬ
// use прокладывает путь к коду

// Полный путь
std::collections::HashMap::new()

// Сокращение пути
use std::collections::HashMap;
let карта = HashMap::new();

// Множественный импорт
use std::{
    io::{Read, Write},
    fs::File,
};

// Переименование
use std::io::Result as IoResult;''',
        "объяснение": "use импортирует элементы, сокращая пути в коде"
    },
    18: {
        "тема": "Речь — макросы macro",
        "код": '''// Ⲣ = 18 — РЕЧЬ
// Макросы — магические слова

// Встроенные макросы
println!("Говорю: {}", слово)  // вывод
format!("Имя: {}", имя)        // форматирование
vec![1, 2, 3]                  // создание вектора

// Свой макрос
macro_rules! трижды {
    ($x:expr) => {
        $x; $x; $x;
    };
}

трижды!(println!("Ура!"))  // выведет 3 раза''',
        "объяснение": "Макросы генерируют код во время компиляции"
    },
    19: {
        "тема": "Слово — String и &str",
        "код": '''// Ⲥ = 19 — СЛОВО
// Строки — слова программы

// &str — неизменяемый срез (слово высечено в камне)
let имя: &str = "Иван"

// String — изменяемая строка (слово на песке)
let mut приветствие = String::from("Здравствуй, ")
приветствие.push_str(имя)
приветствие.push('!')

// Преобразования
let s: String = имя.to_string()
let slice: &str = &приветствие''',
        "объяснение": "&str — срез строки, String — владеющая строка в куче"
    },
    20: {
        "тема": "Твердь — Vec и массивы",
        "код": '''// Ⲧ = 20 — ТВЕРДЬ
// Коллекции — твердь данных

// Массив (фиксированный размер)
let камни: [i32; 3] = [1, 2, 3]

// Вектор (динамический)
let mut дружина: Vec<Богатырь> = Vec::new()
дружина.push(илья)
дружина.push(добрыня)
дружина.push(алёша)

// Доступ
let первый = &дружина[0]
let может_быть = дружина.get(10)  // Option<&T>''',
        "объяснение": "Vec<T> — динамический массив, растёт по необходимости"
    },
    21: {
        "тема": "Высота — async/await",
        "код": '''// Ⲩ = 21 — ВЫСОТА
// Async поднимает над блокировками

async fn лететь() -> Результат {
    println!("Взлетаю...")
    подняться().await?;
    парить().await?;
    Ok(())
}

async fn жар_птица() {
    let перо = искать_перо().await;
    let свет = перо.светить().await;
}

// Запуск
#[tokio::main]
async fn main() {
    лететь().await.unwrap();
}''',
        "объяснение": "async/await — асинхронное выполнение без блокировки"
    },
    22: {
        "тема": "Огонь — unsafe",
        "код": '''// Ⲫ = 22 — ОГОНЬ
// Unsafe — опасная сила

// Обычный код безопасен
let x = 5;

// Unsafe снимает ограничения
unsafe {
    // Сырые указатели
    let ptr = &x as *const i32;
    println!("Значение: {}", *ptr);
    
    // Вызов unsafe функций
    опасная_функция();
}

// Unsafe нужен для:
// - FFI (вызов C кода)
// - Низкоуровневой оптимизации
// - Работы с железом''',
        "объяснение": "unsafe отключает проверки компилятора — используй осторожно!"
    },
    23: {
        "тема": "Дух — lifetime 'a",
        "код": '''// Ⲭ = 23 — ДУХ
// Lifetime — дух жизни ссылок

// Явное время жизни
fn длиннее<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

// В структурах
struct Книга<'a> {
    название: &'a str,
    автор: &'a str,
}

// 'static — живёт вечно
let вечное: &'static str = "Бессмертное слово"''',
        "объяснение": "Lifetime 'a гарантирует, что ссылки живут достаточно долго"
    },
    24: {
        "тема": "Душа — closure ||",
        "код": '''// Ⲯ = 24 — ДУША
// Замыкания — душа функций

// Простое замыкание
let удвоить = |x| x * 2;
println!("{}", удвоить(21));  // 42

// Захват окружения
let множитель = 3;
let утроить = |x| x * множитель;

// В итераторах
let числа = vec![1, 2, 3];
let удвоенные: Vec<_> = числа
    .iter()
    .map(|n| n * 2)
    .collect();''',
        "объяснение": "Замыкания |args| expr захватывают переменные из окружения"
    },
    25: {
        "тема": "Вечность — Box и умные указатели",
        "код": '''// Ⲱ = 25 — ВЕЧНОСТЬ
// Умные указатели управляют памятью

// Box — владение в куче
let кощей = Box::new(Кощей::новый());

// Rc — разделяемое владение
use std::rc::Rc;
let мудрость = Rc::new(Книга::новая());
let копия = Rc::clone(&мудрость);

// Arc — потокобезопасный Rc
use std::sync::Arc;
let общее = Arc::new(данные);''',
        "объяснение": "Box, Rc, Arc — умные указатели для разных сценариев владения"
    },
    26: {
        "тема": "Царство — crate и Cargo",
        "код": '''// Ⳁ = 26 — ЦАРСТВО
// Crate — царство кода

// Cargo.toml — манифест царства
[package]
name = "тридевятое"
version = "0.27.0"

[dependencies]
serde = "1.0"
tokio = { version = "1", features = ["full"] }

// Команды царя
// cargo new царство    — создать
// cargo build          — построить
// cargo run            — запустить
// cargo test           — испытать''',
        "объяснение": "Crate — единица компиляции, Cargo — менеджер пакетов"
    },
    27: {
        "тема": "Полнота — всё вместе",
        "код": '''// Ⳃ = 27 — ПОЛНОТА
// Всё вместе — полная программа

use std::collections::HashMap;

#[derive(Debug, Clone)]
struct Царство {
    имя: String,
    герои: Vec<Герой>,
    сокровища: HashMap<String, i32>,
}

impl Царство {
    fn новое(имя: &str) -> Self {
        Self {
            имя: имя.to_string(),
            герои: Vec::new(),
            сокровища: HashMap::new(),
        }
    }
    
    async fn процветать(&mut self) -> Result<(), Error> {
        for герой in &mut self.герои {
            герой.расти().await?;
        }
        Ok(())
    }
}

fn main() {
    let царство = Царство::новое("Тридевятое");
    println!("Да здравствует {:?}!", царство);
}''',
        "объяснение": "Полнота — все концепции Vibee работают вместе"
    },
}

# Алфавит
ALPHABET = [
    {"s": "Ⲁ", "n": "Альфа", "m": "Начало"},
    {"s": "Ⲃ", "n": "Вита", "m": "Разделение"},
    {"s": "Ⲅ", "n": "Гамма", "m": "Троица"},
    {"s": "Ⲇ", "n": "Дельта", "m": "Основа"},
    {"s": "Ⲉ", "n": "Эй", "m": "Жизнь"},
    {"s": "Ⲋ", "n": "Сау", "m": "Гармония"},
    {"s": "Ⲍ", "n": "Зета", "m": "Тайна"},
    {"s": "Ⲏ", "n": "Эта", "m": "Бесконечность"},
    {"s": "Ⲑ", "n": "Тета", "m": "Завершение"},
    {"s": "Ⲓ", "n": "Йота", "m": "Движение"},
    {"s": "Ⲕ", "n": "Каппа", "m": "Сила"},
    {"s": "Ⲗ", "n": "Лямбда", "m": "Свет"},
    {"s": "Ⲙ", "n": "Мю", "m": "Мудрость"},
    {"s": "Ⲛ", "n": "Ню", "m": "Порядок"},
    {"s": "Ⲝ", "n": "Кси", "m": "Связь"},
    {"s": "Ⲟ", "n": "Омикрон", "m": "Целостность"},
    {"s": "Ⲡ", "n": "Пи", "m": "Путь"},
    {"s": "Ⲣ", "n": "Ро", "m": "Речь"},
    {"s": "Ⲥ", "n": "Сигма", "m": "Слово"},
    {"s": "Ⲧ", "n": "Тау", "m": "Твердь"},
    {"s": "Ⲩ", "n": "Ипсилон", "m": "Высота"},
    {"s": "Ⲫ", "n": "Фи", "m": "Огонь"},
    {"s": "Ⲭ", "n": "Хи", "m": "Дух"},
    {"s": "Ⲯ", "n": "Пси", "m": "Душа"},
    {"s": "Ⲱ", "n": "Омега", "m": "Вечность"},
    {"s": "Ⳁ", "n": "Сампи", "m": "Царство"},
    {"s": "Ⳃ", "n": "Коппа", "m": "Полнота"},
]

import math
π = math.pi

def generate_chapter(num):
    n = ((num - 1) % 27) + 1
    k = min((num - 1) // 333, 2)
    m = 2 if num % 27 == 0 else 1 if num % 9 == 0 else 0.5 if num % 3 == 0 else 0
    v = n * (3 ** k) * (π ** m)
    
    letter = ALPHABET[n - 1]
    topic = VIBEE_TOPICS[n]
    kingdom = ["Медное", "Серебряное", "Золотое"][k]
    sacred = "священное" if m == 2 else "благословенное" if m == 1 else "благое" if m >= 0.5 else "обычное"
    
    return {
        "номер": num,
        "n": n, "k": k, "m": m, "v": round(v, 4),
        "буква": letter["s"],
        "имя": letter["n"],
        "смысл": letter["m"],
        "царство": kingdom,
        "священность": sacred,
        "vibee_тема": topic["тема"],
        "vibee_код": topic["код"],
        "vibee_объяснение": topic["объяснение"],
    }

def main():
    output = Path("generated_tridevyatitsa/vibee_book")
    output.mkdir(parents=True, exist_ok=True)
    
    chapters = [generate_chapter(i) for i in range(1, 1000)]
    
    (output / "chapters.json").write_text(
        json.dumps(chapters, ensure_ascii=False, indent=2),
        encoding="utf-8"
    )
    
    print(f"✨ Сгенерировано 999 глав с Vibee в {output}")

if __name__ == "__main__":
    main()
