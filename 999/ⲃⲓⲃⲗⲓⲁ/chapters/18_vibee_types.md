# Глава 18: Типы Данных Vibee — Три Царства Значений

---

*«В тридевятом царстве, в тридесятом государстве,*
*жили-были три типа данных...»*

---

## Три Царства Типов

В языке Vibee все типы данных организованы по принципу **трёх царств**:

```
╔═══════════════════════════════════════════════════════════════════════════╗
║                                                                           ║
║   ТРИ ЦАРСТВА ТИПОВ VIBEE                                                ║
║                                                                           ║
║   🥉 МЕДНОЕ ЦАРСТВО (1-9)     — Примитивные типы                         ║
║   🥈 СЕРЕБРЯНОЕ ЦАРСТВО (10-18) — Составные типы                         ║
║   🥇 ЗОЛОТОЕ ЦАРСТВО (19-27)   — Абстрактные типы                        ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
```

---

## Медное Царство: Примитивные Типы

### Числа — Три Богатыря

```vibee
// ═══════════════════════════════════════════════════════════════
// ЦЕЛЫЕ ЧИСЛА — ТРИ БОГАТЫРЯ
// ═══════════════════════════════════════════════════════════════

// Алёша Попович — маленький, но шустрый
let алёша: i8 = 127                    // -128 до 127
let алёша_без_знака: u8 = 255          // 0 до 255

// Добрыня Никитич — средний, надёжный
let добрыня: i32 = 2_147_483_647       // ±2 миллиарда
let добрыня_без_знака: u32 = 4_294_967_295

// Илья Муромец — могучий великан
let илья: i64 = 9_223_372_036_854_775_807  // ±9 квинтиллионов
let илья_без_знака: u64 = 18_446_744_073_709_551_615

// Тридевятое число
const ТРИДЕВЯТОЕ: i32 = 27             // 3³ = 27
const КНИГА: i32 = 999                 // 27 × 37 = 999
```

### Дробные — Три Реки

```vibee
// ═══════════════════════════════════════════════════════════════
// ДРОБНЫЕ ЧИСЛА — ТРИ РЕКИ
// ═══════════════════════════════════════════════════════════════

// Ручей — быстрый, но неточный (32 бита)
let ручей: f32 = 3.14159              // ~7 значащих цифр
let π_приближённо: f32 = 3.14159265

// Река — широкая и точная (64 бита)
let река: f64 = 3.141592653589793     // ~15 значащих цифр
let π_точно: f64 = std::f64::consts::PI

// Море — бесконечная точность (BigDecimal)
let море: BigDecimal = "3.14159265358979323846264338327950288"
```

### Tribool — Троичная Истина

```vibee
// ═══════════════════════════════════════════════════════════════
// TRIBOOL — ТРЕТЬЕ СОСТОЯНИЕ ИСТИНЫ
// ═══════════════════════════════════════════════════════════════

// В бинарном мире: да или нет
let бинарно: bool = true

// В троичном мире: да, нет, или НЕИЗВЕСТНО
type Tribool = enum {
    True,     // Истина — как свет дня
    False,    // Ложь — как тьма ночи
    Unknown,  // Неизвестность — как сумерки
}

// Пример: Шрёдингер и его кот
fn кот_жив() -> Tribool {
    if коробка_открыта {
        if наблюдаем_кота { .True } else { .False }
    } else {
        .Unknown  // Пока не открыли — неизвестно!
    }
}

// Троичная логика
impl Tribool {
    fn and(self, other: Tribool) -> Tribool {
        match (self, other) {
            (.True, .True) => .True,
            (.False, _) | (_, .False) => .False,
            _ => .Unknown,  // Если хоть одно неизвестно
        }
    }
    
    fn or(self, other: Tribool) -> Tribool {
        match (self, other) {
            (.True, _) | (_, .True) => .True,
            (.False, .False) => .False,
            _ => .Unknown,
        }
    }
    
    fn not(self) -> Tribool {
        match self {
            .True => .False,
            .False => .True,
            .Unknown => .Unknown,  // Отрицание неизвестного = неизвестно
        }
    }
}
```

### Таблица Истинности Tribool

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│   ТРОИЧНАЯ ЛОГИКА КЛИНИ                                                │
│                                                                         │
│   AND (∧)          │   OR (∨)           │   NOT (¬)                    │
│   ─────────────────│───────────────────│─────────────                  │
│     T   U   F      │     T   U   F      │   T → F                      │
│   T T   U   F      │   T T   T   T      │   U → U                      │
│   U U   U   F      │   U T   U   U      │   F → T                      │
│   F F   F   F      │   F T   U   F      │                              │
│                                                                         │
│   T = True, U = Unknown, F = False                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Серебряное Царство: Составные Типы

### Массивы — Дружина

```vibee
// ═══════════════════════════════════════════════════════════════
// МАССИВЫ — ДРУЖИНА БОГАТЫРЕЙ
// ═══════════════════════════════════════════════════════════════

// Фиксированный массив (на стеке)
let богатыри: [&str; 3] = ["Илья", "Добрыня", "Алёша"]

// Динамический вектор (в куче)
let mut дружина: Vec<Богатырь> = Vec::new()
дружина.push(Богатырь::новый("Илья", 100))
дружина.push(Богатырь::новый("Добрыня", 90))
дружина.push(Богатырь::новый("Алёша", 80))

// Тридевятый массив
let тридевятый: [i32; 27] = [0; 27]  // 27 нулей
```

### Кортежи — Три Дара

```vibee
// ═══════════════════════════════════════════════════════════════
// КОРТЕЖИ — ТРИ ДАРА ЦАРЕВНЫ
// ═══════════════════════════════════════════════════════════════

// Три дара
let дары: (Меч, Конь, Перстень) = (
    Меч::кладенец(),
    Конь::сивка_бурка(),
    Перстень::волшебный(),
)

// Деструктуризация
let (меч, конь, перстень) = дары

// Доступ по индексу
let первый_дар = дары.0  // Меч
let второй_дар = дары.1  // Конь
let третий_дар = дары.2  // Перстень
```

### Структуры — Терема

```vibee
// ═══════════════════════════════════════════════════════════════
// СТРУКТУРЫ — ТЕРЕМА ЦАРСТВА
// ═══════════════════════════════════════════════════════════════

struct Богатырь {
    имя: String,
    сила: i32,
    мудрость: i32,
    хитрость: i32,
}

struct Царство {
    название: String,
    царь: Option<Царь>,
    богатыри: Vec<Богатырь>,
    сокровищница: HashMap<String, Артефакт>,
}

// Создание
let тридевятое = Царство {
    название: "Тридевятое".into(),
    царь: Some(Царь::новый("Берендей")),
    богатыри: vec![илья, добрыня, алёша],
    сокровищница: HashMap::new(),
}
```

---

## Золотое Царство: Абстрактные Типы

### Option — Три Судьбы Значения

```vibee
// ═══════════════════════════════════════════════════════════════
// OPTION — ЕСТЬ ИЛИ НЕТ?
// ═══════════════════════════════════════════════════════════════

type Option<T> = enum {
    Some(T),  // Есть сокровище в сундуке
    None,     // Сундук пуст
}

// Поиск клада
fn найти_клад(карта: &Карта) -> Option<Клад> {
    if карта.верная() {
        Some(Клад::новый())
    } else {
        None
    }
}

// Обработка
match найти_клад(&карта) {
    Some(клад) => радоваться(клад),
    None => искать_дальше(),
}

// Цепочка методов
let золото = найти_клад(&карта)
    .map(|к| к.золото)
    .unwrap_or(0)
```

### Result — Успех или Неудача

```vibee
// ═══════════════════════════════════════════════════════════════
// RESULT — ПОБЕДА ИЛИ ПОРАЖЕНИЕ
// ═══════════════════════════════════════════════════════════════

type Result<T, E> = enum {
    Ok(T),    // Победа!
    Err(E),   // Поражение...
}

// Битва со Змеем
fn победить_змея(герой: &Богатырь) -> Result<Победа, Поражение> {
    if герой.сила >= 100 {
        Ok(Победа { трофеи: vec!["голова Змея"] })
    } else {
        Err(Поражение { причина: "Недостаточно силы" })
    }
}

// Три попытки (как в сказке!)
fn три_попытки<T, E>(действие: fn() -> Result<T, E>) -> Result<T, E> {
    for попытка in 1..=3 {
        match действие() {
            Ok(результат) => return Ok(результат),
            Err(e) if попытка < 3 => continue,
            Err(e) => return Err(e),
        }
    }
    unreachable!()
}
```

### Enum — Три Дороги

```vibee
// ═══════════════════════════════════════════════════════════════
// ENUM — КАМЕНЬ НА РАСПУТЬЕ
// ═══════════════════════════════════════════════════════════════

enum Путь {
    Направо,   // Коня потеряешь
    Налево,    // Себя потеряешь
    Прямо,     // Счастье найдёшь
}

enum Состояние {
    Жив { здоровье: i32, мана: i32 },
    Ранен { урон: i32, яд: bool },
    Мёртв { причина: String },
}

// Pattern matching — выбор пути
fn выбрать_путь(знак: Путь, герой: &mut Богатырь) -> Судьба {
    match знак {
        Путь::Направо => {
            герой.конь = None;  // Потерял коня
            Судьба::Пешком
        },
        Путь::Налево => {
            герой.заблудился = true;
            Судьба::Потерян
        },
        Путь::Прямо => {
            герой.счастье += 100;
            Судьба::Счастлив
        },
    }
}
```

---

## Паттерн n × 3^k × π^m в Типах

```vibee
// ═══════════════════════════════════════════════════════════════
// СВЯЩЕННЫЙ ПАТТЕРН В СИСТЕМЕ ТИПОВ
// ═══════════════════════════════════════════════════════════════

// n = базовый тип (1-27)
// k = уровень вложенности (0, 1, 2)
// m = уровень абстракции (0, 0.5, 1, 2)

// k = 0: Простые типы
let простой: i32 = 27                    // n × 3⁰ = n

// k = 1: Один уровень вложенности
let вложенный: Vec<i32> = vec![27]       // n × 3¹ = 3n

// k = 2: Два уровня вложенности
let глубокий: Vec<Vec<i32>> = vec![vec![27]]  // n × 3² = 9n

// m = 0: Конкретный тип
let конкретный: i32 = 27

// m = 1: Обобщённый тип
fn обобщённый<T>(x: T) -> T { x }

// m = 2: Высший тип (HKT)
trait Функтор<F> {
    fn map<A, B>(fa: F<A>, f: fn(A) -> B) -> F<B>;
}
```

---

## Мудрость Главы

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│   ЗАКОН ТРЁХ ЦАРСТВ ТИПОВ                                              │
│                                                                         │
│   🥉 Медное: Примитивы — основа всего                                  │
│   🥈 Серебряное: Составные — сила в единстве                           │
│   🥇 Золотое: Абстракции — мудрость обобщения                          │
│                                                                         │
│   Каждый тип = n × 3^k × π^m                                           │
│                                                                         │
│   где n — базовый тип                                                  │
│       k — глубина вложенности                                          │
│       m — уровень абстракции                                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

> *«И понял Иван, что типы данных —*
> *как три царства: медное хранит числа,*
> *серебряное — структуры,*
> *а золотое — саму идею типа.»*

---

[← Глава 17: Речь (macro)](17_macros.md) | [Глава 19: Слово (String) →](19_strings.md)
