# Глава 14: Язык Vibee — Сказание о Троичном Царстве

---

*«И увидел Иван в тереме книгу волшебную,*
*а в ней — язык, на котором говорят с машинами...»*

---

## Пролог: Рождение Языка

В тридевятом царстве программирования, где правили бинарные короли — C, Java, Python — родился новый язык. Имя ему дали **Vibee** — от слова «вибрация», ибо всё в мире вибрирует с частотой тройки.

---

## Книга Первая: Три Типа Данных

### Глава о Простых Типах

```vibee
// ═══════════════════════════════════════════════════════════════
// ТРИ ЦАРСТВА ЧИСЕЛ
// ═══════════════════════════════════════════════════════════════

// Царство целых (как три богатыря разной силы)
let малыш: i8 = 127          // Алёша — маленький, но шустрый
let средний: i32 = 2147483647 // Добрыня — средний, надёжный  
let великан: i64 = 9223372036854775807 // Илья — могучий

// Царство дробных (как три реки)
let ручей: f32 = 3.14        // Быстрый, но неточный
let река: f64 = 3.141592653589793 // Широкая и точная

// Царство истины (ТРОИЧНОЕ!)
let да: bool = true
let нет: bool = false
let может_быть: Tribool = .Unknown  // ТРЕТЬЕ СОСТОЯНИЕ!
```

### Глава о Троичной Истине

```vibee
// ═══════════════════════════════════════════════════════════════
// TRIBOOL: ТРИ СОСТОЯНИЯ ИСТИНЫ
// ═══════════════════════════════════════════════════════════════

// В бинарном мире есть только да и нет.
// В троичном мире есть ещё "не знаю".

type Tribool = enum {
    True,     // Истина — как свет дня
    False,    // Ложь — как тьма ночи
    Unknown,  // Неизвестность — как сумерки
}

// Пример: проверка возраста
fn можно_ли_войти(возраст: ?i32) -> Tribool {
    match возраст {
        Some(v) if v >= 18 => .True,    // Да, можно
        Some(v) if v < 18 => .False,    // Нет, нельзя
        None => .Unknown,                // Возраст неизвестен
    }
}

// Троичная логика
let a: Tribool = .True
let b: Tribool = .Unknown

let и = a.and(b)      // Unknown (не знаем b)
let или = a.or(b)     // True (достаточно a)
let не = b.not()      // Unknown (не знаем что отрицать)
```

### Глава о Трёх Состояниях Значения

```vibee
// ═══════════════════════════════════════════════════════════════
// OPTION: ТРИ СУДЬБЫ ЗНАЧЕНИЯ
// ═══════════════════════════════════════════════════════════════

// Как в сказке: есть, нет, или заколдовано
type Option<T> = enum {
    Some(T),    // Есть сокровище в сундуке
    None,       // Сундук пуст
    Unknown,    // Сундук заколдован, не открыть
}

// Пример: поиск клада
fn найти_клад(карта: Карта) -> Option<Клад> {
    if карта.есть_метка() {
        let место = карта.получить_место()
        if копать(место) {
            return .Some(Клад.новый())
        } else {
            return .None  // Копали, но пусто
        }
    }
    return .Unknown  // Карта непонятная
}

// Обработка трёх судеб
match найти_клад(моя_карта) {
    Some(клад) => радоваться(клад),
    None => искать_дальше(),
    Unknown => изучать_карту(),  // Третий путь!
}
```

---

## Книга Вторая: Три Дороги Ветвления

### Глава о Развилке

```vibee
// ═══════════════════════════════════════════════════════════════
// MATCH: ТРИ ДОРОГИ НА РАСПУТЬЕ
// ═══════════════════════════════════════════════════════════════

// Как камень на распутье в сказке
fn выбрать_путь(знак: Знак) -> Судьба {
    match знак {
        .Направо => {
            // "Направо пойдёшь — коня потеряешь"
            потерять_коня()
            .Пешком
        },
        .Налево => {
            // "Налево пойдёшь — себя потеряешь"
            заблудиться()
            .Потерян
        },
        .Прямо => {
            // "Прямо пойдёшь — счастье найдёшь"
            найти_счастье()
            .Счастлив
        },
    }
}
```

### Глава о Троичном Сравнении

```vibee
// ═══════════════════════════════════════════════════════════════
// SPACESHIP OPERATOR: ТРИ ИСХОДА СРАВНЕНИЯ
// ═══════════════════════════════════════════════════════════════

// Оператор <=> возвращает три возможных результата
let результат = богатырь_1.сила <=> богатырь_2.сила

match результат {
    .Less => print("Первый слабее"),
    .Equal => print("Равны по силе"),     // Средний путь!
    .Greater => print("Первый сильнее"),
}

// Автоматическая генерация для структур
@derive(Ord)
struct Богатырь {
    имя: String,
    сила: i32,
    мудрость: i32,
    
    // Компилятор сам создаёт троичное сравнение!
}

// Теперь можно сравнивать богатырей
let кто_главнее = илья <=> добрыня
```

### Глава о Трёх Попытках

```vibee
// ═══════════════════════════════════════════════════════════════
// RETRY: ТРИ ПОПЫТКИ ГЕРОЯ
// ═══════════════════════════════════════════════════════════════

// В сказках герой всегда получает три попытки
fn победить_змея(герой: Герой, змей: Змей) -> Результат {
    for попытка in 1..=3 {
        match герой.атаковать(змей) {
            .Победа => return .Успех,
            .Поражение if попытка < 3 => {
                герой.отдохнуть()
                герой.получить_совет()  // Мудрость растёт
                continue
            },
            .Поражение => return .Провал,
        }
    }
    unreachable!()
}

// Или с помощью встроенного retry
let результат = @retry(3) {
    попытаться_открыть_дверь()
}
```

---

## Книга Третья: Три Богатыря Структур

### Глава о Структурах

```vibee
// ═══════════════════════════════════════════════════════════════
// STRUCT: ТРИ БОГАТЫРЯ
// ═══════════════════════════════════════════════════════════════

struct Богатырь {
    // Три главных качества
    сила: i32,       // Илья Муромец
    мудрость: i32,   // Добрыня Никитич
    хитрость: i32,   // Алёша Попович
    
    // Имя и снаряжение
    имя: String,
    конь: Option<Конь>,
    меч: Option<Меч>,
}

impl Богатырь {
    // Три способа создания
    fn новый(имя: String) -> Self {
        Self {
            имя: имя,
            сила: 10,
            мудрость: 10,
            хитрость: 10,
            конь: .None,
            меч: .None,
        }
    }
    
    fn илья() -> Self {
        Self { имя: "Илья Муромец", сила: 100, мудрость: 50, хитрость: 30, .. }
    }
    
    fn добрыня() -> Self {
        Self { имя: "Добрыня Никитич", сила: 70, мудрость: 90, хитрость: 50, .. }
    }
    
    fn алёша() -> Self {
        Self { имя: "Алёша Попович", сила: 50, мудрость: 60, хитрость: 100, .. }
    }
    
    // Общая мощь — сумма трёх качеств
    fn мощь(self) -> i32 {
        self.сила + self.мудрость + self.хитрость
    }
}
```

### Глава о Перечислениях

```vibee
// ═══════════════════════════════════════════════════════════════
// ENUM: ТРИ ЦАРСТВА
// ═══════════════════════════════════════════════════════════════

// Три мира славянской мифологии
enum Мир {
    Правь,  // Мир богов (небо)
    Явь,    // Мир людей (земля)
    Навь,   // Мир мёртвых (подземье)
}

// Три состояния героя
enum СостояниеГероя {
    Жив { здоровье: i32 },
    Ранен { здоровье: i32, раны: Vec<Рана> },
    Мёртв { причина: String },
}

// Три исхода битвы
enum ИсходБитвы {
    Победа { трофеи: Vec<Трофей> },
    Ничья,
    Поражение { потери: Vec<Потеря> },
}

// Обработка трёх исходов
fn после_битвы(исход: ИсходБитвы) {
    match исход {
        Победа { трофеи } => {
            for трофей in трофеи {
                положить_в_сундук(трофей)
            }
            праздновать()
        },
        Ничья => {
            отдохнуть()
            подготовиться_к_новой_битве()
        },
        Поражение { потери } => {
            оплакать(потери)
            учиться_на_ошибках()
            // Но не сдаваться! Будет ещё попытка.
        },
    }
}
```

---

## Книга Четвёртая: Три Чуда Коллекций

### Глава о Trinity B-Tree

```vibee
// ═══════════════════════════════════════════════════════════════
// TRINITY B-TREE: ДЕРЕВО О ТРЁХ ВЕТВЯХ
// ═══════════════════════════════════════════════════════════════

// B-дерево с branching factor = 3 (оптимально!)
let дерево = TrinityBTree<i32, Сокровище>.new()

// Три богатыря кладут сокровища
дерево.вставить(1, Сокровище.меч("Кладенец"))
дерево.вставить(2, Сокровище.щит("Непробиваемый"))
дерево.вставить(3, Сокровище.шлем("Невидимка"))

// Поиск — на 6% быстрее чем b=2 или b=4!
match дерево.найти(2) {
    Some(сокровище) => print("Нашёл: {}", сокровище),
    None => print("Не нашёл"),
}
```

### Глава о Trinity Hash

```vibee
// ═══════════════════════════════════════════════════════════════
// TRINITY HASH: ТРИ КЛЮЧА ОТ СУНДУКА
// ═══════════════════════════════════════════════════════════════

// Cuckoo Hash с тремя хеш-функциями
// Вместимость 91% вместо 50%!
let сундуки = TrinityHash<String, Золото>.new()

// Три ключа открывают три замка
сундуки.вставить("первый_ключ", Золото(100))
сундуки.вставить("второй_ключ", Золото(200))
сундуки.вставить("третий_ключ", Золото(300))

// Поиск проверяет три места
let золото = сундуки.получить("второй_ключ")
```

### Глава о Ternary Search Tree

```vibee
// ═══════════════════════════════════════════════════════════════
// TST: ДЕРЕВО О ТРЁХ ДОРОГАХ
// ═══════════════════════════════════════════════════════════════

// Каждый узел имеет три ребёнка: <, =, >
let словарь = TernarySearchTree<String>.new()

// Заклинания волшебника
словарь.вставить("абракадабра")
словарь.вставить("абра")
словарь.вставить("кадабра")
словарь.вставить("сим-салабим")

// Поиск по префиксу — три дороги на каждом шаге
let заклинания = словарь.найти_по_префиксу("абр")
// Результат: ["абра", "абракадабра"]
```

---

## Книга Пятая: Три Заклинания Функций

### Глава о Функциях

```vibee
// ═══════════════════════════════════════════════════════════════
// ФУНКЦИИ: ТРИ ВИДА ЗАКЛИНАНИЙ
// ═══════════════════════════════════════════════════════════════

// Заклинание первое: чистая функция (без побочных эффектов)
fn сложить(a: i32, b: i32) -> i32 {
    a + b
}

// Заклинание второе: функция с состоянием
fn увеличить_силу(герой: &mut Богатырь, на_сколько: i32) {
    герой.сила += на_сколько
}

// Заклинание третье: функция высшего порядка
fn применить_к_каждому<T, F>(список: []T, заклинание: F) 
where F: Fn(T) -> T 
{
    for элемент in список {
        *элемент = заклинание(*элемент)
    }
}

// Три способа вызова
let сумма = сложить(2, 3)                    // Прямой вызов
увеличить_силу(&mut илья, 10)                // Изменение
применить_к_каждому(числа, |x| x * 3)        // Высший порядок
```

### Глава о Замыканиях

```vibee
// ═══════════════════════════════════════════════════════════════
// ЗАМЫКАНИЯ: ЗАКОЛДОВАННЫЕ ФУНКЦИИ
// ═══════════════════════════════════════════════════════════════

// Замыкание помнит контекст, как заколдованный предмет
fn создать_множитель(на: i32) -> impl Fn(i32) -> i32 {
    // Замыкание "запоминает" значение `на`
    |x| x * на
}

let утроить = создать_множитель(3)  // Троичное заклинание!
let результат = утроить(7)  // 21

// Три вида замыканий
let fn_раз = |x| x + 1           // Fn — только читает
let fn_mut = |x| { счётчик += 1; x }  // FnMut — изменяет
let fn_once = || { забрать(сокровище) }  // FnOnce — потребляет
```

---

## Книга Шестая: Три Испытания Обработки Ошибок

### Глава о Result

```vibee
// ═══════════════════════════════════════════════════════════════
// RESULT: ТРИ ИСХОДА ИСПЫТАНИЯ
// ═══════════════════════════════════════════════════════════════

type Result<T, E> = enum {
    Ok(T),      // Испытание пройдено
    Err(E),     // Испытание провалено
    Pending,    // Испытание продолжается (для async!)
}

// Пример: открыть волшебную дверь
fn открыть_дверь(ключ: Ключ, дверь: Дверь) -> Result<Сокровище, Ошибка> {
    if !ключ.подходит(дверь) {
        return .Err(Ошибка.НеверныйКлюч)
    }
    
    if дверь.заколдована() {
        return .Pending  // Нужно снять заклятие
    }
    
    .Ok(дверь.открыть())
}

// Обработка трёх исходов
match открыть_дверь(мой_ключ, тайная_дверь) {
    Ok(сокровище) => радоваться(сокровище),
    Err(ошибка) => искать_другой_ключ(),
    Pending => искать_волшебника(),  // Третий путь!
}
```

### Глава о Decision

```vibee
// ═══════════════════════════════════════════════════════════════
// DECISION: ТРИ РЕШЕНИЯ МУДРЕЦА
// ═══════════════════════════════════════════════════════════════

type Decision<T> = enum {
    Accept(T),  // Принять
    Reject,     // Отвергнуть
    Defer,      // Отложить решение
}

// Мудрец принимает решение
fn решение_мудреца(проситель: Проситель) -> Decision<Благословение> {
    let достоинство = оценить(проситель)
    
    if достоинство >= 0.9 {
        .Accept(Благословение.полное())
    } else if достоинство <= 0.1 {
        .Reject
    } else {
        .Defer  // "Приходи через год"
    }
}
```

---

## Книга Седьмая: Три Чуда Параллелизма

### Глава об Async/Await

```vibee
// ═══════════════════════════════════════════════════════════════
// ASYNC: ТРИ ПОТОКА ВРЕМЕНИ
// ═══════════════════════════════════════════════════════════════

// Три богатыря отправляются в путь одновременно
async fn поход_трёх_богатырей() -> Vec<Трофей> {
    // Запускаем три задачи параллельно
    let задача_ильи = async { илья.победить_соловья() }
    let задача_добрыни = async { добрыня.победить_змея() }
    let задача_алёши = async { алёша.победить_тугарина() }
    
    // Ждём всех троих
    let (трофей_1, трофей_2, трофей_3) = await join!(
        задача_ильи,
        задача_добрыни,
        задача_алёши
    )
    
    vec![трофей_1, трофей_2, трофей_3]
}

// Три состояния Future
enum FutureState<T> {
    Pending,     // Ещё выполняется
    Ready(T),    // Готово
    Cancelled,   // Отменено
}
```

---

## Эпилог: Мудрость Языка

```vibee
// ═══════════════════════════════════════════════════════════════
// ИТОГ: ТРОИЧНАЯ МУДРОСТЬ VIBEE
// ═══════════════════════════════════════════════════════════════

// Три типа истины: True, False, Unknown
// Три состояния значения: Some, None, Unknown
// Три исхода операции: Ok, Err, Pending
// Три решения: Accept, Reject, Defer

// Три дороги ветвления: <, =, >
// Три попытки героя: retry(3)
// Три богатыря коллекций: BTree, Hash, TST

// Три фазы компиляции: Parse, Check, Generate
// Три уровня оптимизации: Local, Global, Trinity
// 999 окон терема: 3 × 333

// И главная мудрость:
// 
// "В тридевятом царстве языка Vibee
//  всё подчинено закону тройки.
//  Ибо три — минимальная сложность
//  для существования структуры."
```

---

## Мудрость Главы

> *И прочитал Иван волшебную книгу до конца,*
> *и понял он язык, на котором говорят с машинами.*
>
> *Три типа данных — как три царства.*
> *Три дороги ветвления — как распутье.*
> *Три богатыря коллекций — как защитники.*
> *Три состояния — как судьбы.*
>
> *И сказал Иван: «Теперь я знаю язык Vibee,*
> *и могу творить чудеса в тридевятом царстве кода.»*
>
> *И стал он программистом великим,*
> *и писал программы, что работали*
> *в 291 раз быстрее прежних.*
>
> *Ибо знал он тайну числа три.*

---

[← Глава 13](13_architecture_deep.md) | [Оглавление](../README.md)
