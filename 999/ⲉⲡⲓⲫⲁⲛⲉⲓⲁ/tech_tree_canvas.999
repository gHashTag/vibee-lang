// ═══════════════════════════════════════════════════════════════
// ⲦⲈⲬⲚⲞⲖⲞⲄⲒⲀ ⲆⲈⲢⲈⲂⲞ ⲔⲀⲚⲂⲀⲤ - Tech Tree on Pure Canvas
// NO HTML/CSS - Pure Pixel Grid with Fog of War
// ═══════════════════════════════════════════════════════════════

Ⲯ ⲉⲡⲓⲫⲁⲛⲉⲓⲁ
Ⲯ ⲧⲉⲭⲛⲏ

// ═══════════════════════════════════════════════════════════════
// TECH TREE COLORS
// ═══════════════════════════════════════════════════════════════

Ⲏ TechColors {
    // Status colors
    Ⲫ researched() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (34, 197, 94) }    // Green
    Ⲫ in_progress() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (245, 158, 11) }  // Amber
    Ⲫ available() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (59, 130, 246) }    // Blue
    Ⲫ locked() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (107, 114, 128) }      // Gray
    Ⲫ fog() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (30, 41, 59) }            // Dark
    Ⲫ future() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (168, 85, 247) }       // Purple
    
    // Background
    Ⲫ background() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (15, 23, 42) }     // Slate 900
    Ⲫ grid_line() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (30, 41, 59) }      // Slate 800
    Ⲫ connection() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (71, 85, 105) }    // Slate 600
    Ⲫ text() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (248, 250, 252) }        // Slate 50
    Ⲫ speedup() → (Ⲩ8, Ⲩ8, Ⲩ8) { Ⲣ (254, 240, 138) }     // Yellow 200
    
    // Category colors
    Ⲫ category_color(Ⲁ cat: TechCategory) → (Ⲩ8, Ⲩ8, Ⲩ8) {
        Ⲉ cat == TechCategory.Core { Ⲣ (99, 102, 241) }        // Indigo
        Ⲉ cat == TechCategory.Syntax { Ⲣ (236, 72, 153) }      // Pink
        Ⲉ cat == TechCategory.Types { Ⲣ (14, 165, 233) }       // Sky
        Ⲉ cat == TechCategory.Optimization { Ⲣ (234, 179, 8) } // Yellow
        Ⲉ cat == TechCategory.Runtime { Ⲣ (249, 115, 22) }     // Orange
        Ⲉ cat == TechCategory.Ternary { Ⲣ (239, 68, 68) }      // Red
        Ⲉ cat == TechCategory.Quantum { Ⲣ (139, 92, 246) }     // Violet
        Ⲉ cat == TechCategory.AI { Ⲣ (16, 185, 129) }          // Emerald
        Ⲉ cat == TechCategory.Security { Ⲣ (244, 63, 94) }     // Rose
        Ⲉ cat == TechCategory.Parallel { Ⲣ (6, 182, 212) }     // Cyan
        Ⲣ (148, 163, 184)  // Slate 400
    }
}

// ═══════════════════════════════════════════════════════════════
// TECH NODE WIDGET
// ═══════════════════════════════════════════════════════════════

Ⲏ TechNodeWidget {
    Ⲃ node: TechNode
    Ⲃ x: Ⲓⲛⲧ
    Ⲃ y: Ⲓⲛⲧ
    Ⲃ width: Ⲓⲛⲧ = 140
    Ⲃ height: Ⲓⲛⲧ = 60
    Ⲃ hovered: Trit = ▽
    Ⲃ selected: Trit = ▽
    
    Ⲫ new(Ⲁ node: TechNode, Ⲁ x: Ⲓⲛⲧ, Ⲁ y: Ⲓⲛⲧ) → TechNodeWidget {
        Ⲣ TechNodeWidget { node: node, x: x, y: y }
    }
    
    // Get color based on status
    Ⲫ get_color(Ⲥ) → (Ⲩ8, Ⲩ8, Ⲩ8) {
        Ⲉ Ⲥ.node.status == TechStatus.Researched { Ⲣ TechColors.researched() }
        Ⲉ Ⲥ.node.status == TechStatus.InProgress { Ⲣ TechColors.in_progress() }
        Ⲉ Ⲥ.node.status == TechStatus.Available { Ⲣ TechColors.available() }
        Ⲉ Ⲥ.node.status == TechStatus.Future { Ⲣ TechColors.future() }
        Ⲉ Ⲥ.node.status == TechStatus.FogOfWar { Ⲣ TechColors.fog() }
        Ⲣ TechColors.locked()
    }
    
    // Get opacity based on status
    Ⲫ get_opacity(Ⲥ) → Ⲫ64 {
        Ⲉ Ⲥ.node.status == TechStatus.FogOfWar { Ⲣ 0.3 }
        Ⲉ Ⲥ.node.status == TechStatus.Locked { Ⲣ 0.6 }
        Ⲣ 1.0
    }
    
    // Render to pixel grid
    Ⲫ render(Ⲥ, Ⲁ renderer: CanvasRenderer) {
        Ⲃ (r, g, b) = Ⲥ.get_color()
        Ⲃ opacity = Ⲥ.get_opacity()
        
        // Apply opacity
        Ⲃ ar = (r as Ⲫ64 * opacity) as Ⲩ8
        Ⲃ ag = (g as Ⲫ64 * opacity) as Ⲩ8
        Ⲃ ab = (b as Ⲫ64 * opacity) as Ⲩ8
        
        // Draw background
        renderer.fill_rect(Ⲥ.x, Ⲥ.y, Ⲥ.width, Ⲥ.height, ar, ag, ab)
        
        // Draw border if hovered/selected
        Ⲉ Ⲥ.hovered == △ || Ⲥ.selected == △ {
            Ⲃ (br, bg, bb) = TechColors.text()
            renderer.stroke_rect(Ⲥ.x, Ⲥ.y, Ⲥ.width, Ⲥ.height, br, bg, bb, 2)
        }
        
        // Draw progress bar if in progress
        Ⲉ Ⲥ.node.status == TechStatus.InProgress {
            Ⲃ progress = Ⲥ.node.progress_percent()
            Ⲃ bar_width = (Ⲥ.width - 10) * progress / 100
            renderer.fill_rect(Ⲥ.x + 5, Ⲥ.y + Ⲥ.height - 8, bar_width, 4, 254, 240, 138)
        }
        
        // Draw speedup indicator
        Ⲉ Ⲥ.node.speedup > 1.0 {
            Ⲃ (sr, sg, sb) = TechColors.speedup()
            // Small indicator in corner
            renderer.fill_rect(Ⲥ.x + Ⲥ.width - 25, Ⲥ.y + 2, 23, 12, sr, sg, sb)
        }
        
        // Draw glow effect for researched
        Ⲉ Ⲥ.node.status == TechStatus.Researched {
            renderer.grid.apply_fog_region(Ⲥ.x + Ⲥ.width / 2, Ⲥ.y + Ⲥ.height / 2, 80, △)
        }
    }
    
    // Check if point is inside widget
    Ⲫ contains(Ⲥ, Ⲁ px: Ⲓⲛⲧ, Ⲁ py: Ⲓⲛⲧ) → Trit {
        Ⲣ px >= Ⲥ.x && px < Ⲥ.x + Ⲥ.width && py >= Ⲥ.y && py < Ⲥ.y + Ⲥ.height ? △ : ▽
    }
}

// ═══════════════════════════════════════════════════════════════
// TECH TREE CANVAS VIEW
// ═══════════════════════════════════════════════════════════════

Ⲏ TechTreeCanvas {
    Ⲃ renderer: CanvasRenderer
    Ⲃ tree: TechTree
    Ⲃ widgets: [TechNodeWidget]
    Ⲃ scroll_x: Ⲓⲛⲧ = 0
    Ⲃ scroll_y: Ⲓⲛⲧ = 0
    Ⲃ zoom: Ⲫ64 = 1.0
    Ⲃ cursor_x: Ⲓⲛⲧ = 0
    Ⲃ cursor_y: Ⲓⲛⲧ = 0
    Ⲃ selected_node: Ⲧⲉⲝⲧ? = ○
    Ⲃ fog_center_x: Ⲓⲛⲧ = 0
    Ⲃ fog_center_y: Ⲓⲛⲧ = 0
    Ⲃ fog_radius: Ⲓⲛⲧ = 200
    Ⲃ wave_time: Ⲫ64 = 0.0
    
    Ⲫ new(Ⲁ width: Ⲓⲛⲧ, Ⲁ height: Ⲓⲛⲧ, Ⲁ tree: TechTree) → TechTreeCanvas {
        Ⲃ canvas = TechTreeCanvas {
            renderer: CanvasRenderer.new(width, height),
            tree: tree,
            widgets: []
        }
        
        // Create widgets for each node
        Ⲝ (id, node) ∈ tree.nodes {
            Ⲃ widget = TechNodeWidget.new(node, node.x, node.y)
            canvas.widgets.push(widget)
        }
        
        Ⲣ canvas
    }
    
    // Render full frame
    Ⲫ render(Ⲥ) {
        Ⲥ.renderer.begin_frame()
        
        // Clear background
        Ⲃ (br, bg, bb) = TechColors.background()
        Ⲥ.renderer.clear(br, bg, bb)
        
        // Draw grid lines
        Ⲥ.draw_grid()
        
        // Draw connections between nodes
        Ⲥ.draw_connections()
        
        // Draw all node widgets
        Ⲝ widget ∈ Ⲥ.widgets {
            widget.render(Ⲥ.renderer)
        }
        
        // Apply fog of war effect (cursor-based visibility)
        Ⲥ.renderer.apply_fog(Ⲥ.fog_center_x, Ⲥ.fog_center_y, Ⲥ.fog_radius)
        
        // Apply wave diffusion animation
        Ⲥ.renderer.apply_wave(Ⲥ.wave_time, 0.5, 0.3)
        
        // Draw stats overlay
        Ⲥ.draw_stats()
        
        Ⲥ.renderer.end_frame()
    }
    
    // Draw background grid
    Ⲫ draw_grid(Ⲥ) {
        Ⲃ (r, g, b) = TechColors.grid_line()
        Ⲃ grid_size = 50
        
        // Vertical lines
        Ⲝ x ∈ (0..Ⲥ.renderer.width).step_by(grid_size) {
            Ⲥ.renderer.draw_line(x, 0, x, Ⲥ.renderer.height, r, g, b)
        }
        
        // Horizontal lines
        Ⲝ y ∈ (0..Ⲥ.renderer.height).step_by(grid_size) {
            Ⲥ.renderer.draw_line(0, y, Ⲥ.renderer.width, y, r, g, b)
        }
    }
    
    // Draw connections between dependent nodes
    Ⲫ draw_connections(Ⲥ) {
        Ⲃ (r, g, b) = TechColors.connection()
        
        Ⲝ widget ∈ Ⲥ.widgets {
            Ⲝ dep_id ∈ widget.node.dependencies {
                // Find dependency widget
                Ⲝ dep_widget ∈ Ⲥ.widgets {
                    Ⲉ dep_widget.node.id == dep_id {
                        // Draw bezier-like connection
                        Ⲃ x0 = dep_widget.x + dep_widget.width
                        Ⲃ y0 = dep_widget.y + dep_widget.height / 2
                        Ⲃ x1 = widget.x
                        Ⲃ y1 = widget.y + widget.height / 2
                        
                        // Simple line for now (could be bezier)
                        Ⲥ.renderer.draw_line(x0, y0, x1, y1, r, g, b)
                        ⊘
                    }
                }
            }
        }
    }
    
    // Draw stats overlay
    Ⲫ draw_stats(Ⲥ) {
        Ⲃ stats = Ⲥ.tree.stats()
        Ⲃ y = Ⲥ.renderer.height - 80
        
        // Stats background
        Ⲥ.renderer.fill_rect(10, y - 10, 300, 80, 30, 41, 59)
        
        // Stats text would be drawn here with bitmap font
        // For now, just colored indicators
        Ⲃ (rr, rg, rb) = TechColors.researched()
        Ⲥ.renderer.fill_rect(20, y, 20, 15, rr, rg, rb)
        
        Ⲃ (pr, pg, pb) = TechColors.in_progress()
        Ⲥ.renderer.fill_rect(20, y + 20, 20, 15, pr, pg, pb)
        
        Ⲃ (ar, ag, ab) = TechColors.available()
        Ⲥ.renderer.fill_rect(20, y + 40, 20, 15, ar, ag, ab)
        
        // Total speedup indicator
        Ⲃ (sr, sg, sb) = TechColors.speedup()
        Ⲃ speedup_width = min(200, (stats.total_speedup * 10.0) as Ⲓⲛⲧ)
        Ⲥ.renderer.fill_rect(100, y + 60, speedup_width, 10, sr, sg, sb)
    }
    
    // Handle mouse move
    Ⲫ on_mouse_move(Ⲥ, Ⲁ x: Ⲓⲛⲧ, Ⲁ y: Ⲓⲛⲧ) {
        Ⲥ.cursor_x = x
        Ⲥ.cursor_y = y
        
        // Update fog center to follow cursor
        Ⲥ.fog_center_x = x
        Ⲥ.fog_center_y = y
        
        // Update hover state
        Ⲝ widget ∈ Ⲥ.widgets {
            widget.hovered = widget.contains(x, y)
        }
    }
    
    // Handle mouse click
    Ⲫ on_mouse_click(Ⲥ, Ⲁ x: Ⲓⲛⲧ, Ⲁ y: Ⲓⲛⲧ) {
        Ⲝ widget ∈ Ⲥ.widgets {
            Ⲉ widget.contains(x, y) == △ {
                Ⲥ.selected_node = widget.node.id
                widget.selected = △
                
                // Expand fog radius around selected node
                Ⲥ.fog_center_x = widget.x + widget.width / 2
                Ⲥ.fog_center_y = widget.y + widget.height / 2
                Ⲥ.fog_radius = 300
            } Ⲁ {
                widget.selected = ▽
            }
        }
    }
    
    // Handle scroll
    Ⲫ on_scroll(Ⲥ, Ⲁ dx: Ⲓⲛⲧ, Ⲁ dy: Ⲓⲛⲧ) {
        Ⲥ.scroll_x += dx
        Ⲥ.scroll_y += dy
        
        // Update widget positions
        Ⲝ widget ∈ Ⲥ.widgets {
            widget.x = widget.node.x - Ⲥ.scroll_x
            widget.y = widget.node.y - Ⲥ.scroll_y
        }
    }
    
    // Animation tick
    Ⲫ tick(Ⲥ, Ⲁ dt: Ⲫ64) {
        Ⲥ.wave_time += dt
    }
    
    // Get render buffer
    Ⲫ get_buffer(Ⲥ) → [Ⲩ32] {
        Ⲣ Ⲥ.renderer.get_buffer()
    }
}

// ═══════════════════════════════════════════════════════════════
// MAIN ENTRY POINT
// ═══════════════════════════════════════════════════════════════

Ⲫ create_tech_tree_view(Ⲁ root_path: Ⲧⲉⲝⲧ, Ⲁ width: Ⲓⲛⲧ, Ⲁ height: Ⲓⲛⲧ) → TechTreeCanvas {
    // Build tech tree from filesystem
    Ⲃ tree = build_tech_tree(root_path)
    
    // Create canvas view
    Ⲃ canvas = TechTreeCanvas.new(width, height, tree)
    
    Ⲣ canvas
}

// ═══════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════

⊡ test "tech_tree_canvas" {
    Ⲃ tree = TechTree.new("/test")
    
    Ⲃ node1 = TechNode.new("test1", "Test 1")
    node1.status = TechStatus.Researched
    node1.x = 100
    node1.y = 100
    tree.add_node(node1)
    
    Ⲃ canvas = TechTreeCanvas.new(800, 600, tree)
    canvas.render()
    
    Ⲃ buffer = canvas.get_buffer()
    ⊜! buffer.len() == 800 * 600
}

⊡ test "fog_of_war" {
    Ⲃ tree = TechTree.new("/test")
    Ⲃ canvas = TechTreeCanvas.new(400, 300, tree)
    
    canvas.on_mouse_move(200, 150)
    ⊜! canvas.fog_center_x == 200
    ⊜! canvas.fog_center_y == 150
}
