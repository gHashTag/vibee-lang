// ============================================
// ПРОЦЕДУРНЫЕ МАКРОСЫ ЯЗЫКА 999
// AST → AST трансформации
// ============================================

Ⲩ makrosy
Ⲩ hvost

// ============================================
// ПРОЦЕДУРНЫЙ МАКРОС
// ============================================

// Определение процедурного макроса
Ⲏ ⲨⲘⲠ:
  Ⲁ: Ⲥ                    // имя
  Ⲃ: Ⲫ(ⲨⲂ, ⲨⲘⲇ) -> ⲨⲂ    // трансформер
  Ⲅ: Ⲉ ⲨⲘⲠⲀ              // тип

// Типы процедурных макросов
Ⲉ ⲨⲘⲠⲀ:
  Ⲁ    // function-like: имя!(...)
  Ⲃ    // attribute: @имя
  Ⲅ    // derive: @Ⲇ(Имя)

// Реестр процедурных макросов
Ⲏ ⲢⲘⲠ:
  Ⲁ: {Ⲥ: ⲨⲘⲠ}   // макросы
  Ⲃ: Ⲋ          // счётчик

// Создать реестр
Ⲫ ⲢⲘⲠ_новый() -> ⲢⲘⲠ:
  Ⲙ р = ⲢⲘⲠ { Ⲁ: {}, Ⲃ: 0 }
  
  // Встроенные процедурные макросы
  р = зарег_sql(р)
  р = зарег_html(р)
  р = зарег_json(р)
  р = зарег_regex(р)
  р = зарег_format(р)
  р = зарег_include(р)
  р = зарег_env(р)
  р = зарег_cfg(р)
  р = зарег_concat(р)
  р = зарег_stringify(р)
  
  Ⲣ р

// ============================================
// sql! — SQL ЗАПРОСЫ
// ============================================

Ⲫ зарег_sql(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["sql"] = ⲨⲘⲠ {
    Ⲁ: "sql",
    Ⲃ: трансформ_sql,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// sql!("SELECT * FROM users WHERE id = ?", id)
Ⲫ трансформ_sql(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ аргументы = ast.Ⲃ
  Ⲙ запрос = аргументы[0].Ⲅ  // строка SQL
  Ⲙ параметры = аргументы[1:]
  
  // Парсим SQL и проверяем на этапе компиляции
  Ⲙ parsed = parse_sql(запрос)
  Ⲝ parsed.ошибка:
    Ⲁ: ошибка_компиляции("SQL ошибка: " + parsed.ошибка)
  
  // Проверяем количество параметров
  Ⲙ плейсхолдеры = count_placeholders(запрос)
  Ⲝ плейсхолдеры != длина(параметры):
    Ⲁ: ошибка_компиляции("SQL: ожидалось " + плейсхолдеры + " параметров, получено " + длина(параметры))
  
  // Генерируем вызов
  Ⲣ ⲨⲂ_call("db.query", [
    ⲨⲂ_str(запрос),
    ⲨⲂ_list(параметры)
  ])

// ============================================
// html! — HTML ШАБЛОНЫ
// ============================================

Ⲫ зарег_html(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["html"] = ⲨⲘⲠ {
    Ⲁ: "html",
    Ⲃ: трансформ_html,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// html!(<div class={class}>{content}</div>)
Ⲫ трансформ_html(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ шаблон = ast.Ⲃ[0]
  
  // Парсим HTML
  Ⲙ dom = parse_html(шаблон)
  
  // Находим интерполяции {expr}
  Ⲙ части: [ⲨⲂ] = []
  Ⲙ текущий = ""
  Ⲙ в_интерполяции = Ⲃ
  Ⲙ выражение = ""
  
  Ⲯ символ шаблон:
    Ⲝ символ == '{' && !в_интерполяции:
      Ⲁ:
        Ⲝ текущий != "":
          Ⲁ: части += ⲨⲂ_str(текущий)
        текущий = ""
        в_интерполяции = Ⲁ
    Ⲝ символ == '}' && в_интерполяции:
      Ⲁ:
        части += ⲨⲂ_call("escape_html", [ⲨⲂ_var(выражение)])
        выражение = ""
        в_интерполяции = Ⲃ
    Ⲝ в_интерполяции:
      Ⲁ: выражение += символ
    _:
      текущий += символ
  
  Ⲝ текущий != "":
    Ⲁ: части += ⲨⲂ_str(текущий)
  
  // Конкатенация частей
  Ⲣ ⲨⲂ_call("concat", части)

// ============================================
// json! — JSON ЛИТЕРАЛЫ
// ============================================

Ⲫ зарег_json(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["json"] = ⲨⲘⲠ {
    Ⲁ: "json",
    Ⲃ: трансформ_json,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// json!({ "name": name, "age": 25 })
Ⲫ трансформ_json(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ объект = ast.Ⲃ[0]
  
  // Преобразуем в Map
  Ⲙ пары: [(Ⲥ, ⲨⲂ)] = []
  
  Ⲯ поле объект.Ⲃ:
    Ⲙ ключ = поле.Ⲁ
    Ⲙ значение = поле.Ⲃ
    пары += (ключ, значение)
  
  Ⲣ ⲨⲂ_call("JsonValue.object", [
    ⲨⲂ_list(пары.map((к, з) -> 
      ⲨⲂ_tuple([ⲨⲂ_str(к), ⲨⲂ_call("to_json", [з])])))
  ])

// ============================================
// regex! — РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
// ============================================

Ⲫ зарег_regex(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["regex"] = ⲨⲘⲠ {
    Ⲁ: "regex",
    Ⲃ: трансформ_regex,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// regex!(r"^\d{3}-\d{4}$")
Ⲫ трансформ_regex(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ паттерн = ast.Ⲃ[0].Ⲅ
  
  // Компилируем regex на этапе компиляции
  Ⲙ compiled = compile_regex(паттерн)
  Ⲝ compiled.ошибка:
    Ⲁ: ошибка_компиляции("Regex ошибка: " + compiled.ошибка)
  
  // Генерируем скомпилированный regex
  Ⲣ ⲨⲂ_call("Regex.from_compiled", [
    ⲨⲂ_bytes(compiled.байткод)
  ])

// ============================================
// format! — ФОРМАТИРОВАНИЕ СТРОК
// ============================================

Ⲫ зарег_format(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["format"] = ⲨⲘⲠ {
    Ⲁ: "format",
    Ⲃ: трансформ_format,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// format!("Hello, {}! You have {} messages.", name, count)
Ⲫ трансформ_format(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ шаблон = ast.Ⲃ[0].Ⲅ
  Ⲙ аргументы = ast.Ⲃ[1:]
  
  // Парсим плейсхолдеры
  Ⲙ части: [ⲨⲂ] = []
  Ⲙ текущий = ""
  Ⲙ индекс_арг = 0
  Ⲙ ⲓ = 0
  
  Ⲯ ⲓ < длина(шаблон):
    Ⲝ шаблон[ⲓ] == '{' && шаблон[ⲓ+1] == '}':
      Ⲁ:
        Ⲝ текущий != "":
          Ⲁ: части += ⲨⲂ_str(текущий)
        текущий = ""
        части += ⲨⲂ_call("to_string", [аргументы[индекс_арг]])
        индекс_арг += 1
        ⲓ += 2
    Ⲝ шаблон[ⲓ] == '{' && шаблон[ⲓ+1] == ':':
      Ⲁ:
        // Форматирование с спецификатором {:?}, {:x}, etc
        Ⲙ конец = найти(шаблон, '}', ⲓ)
        Ⲙ спец = шаблон[ⲓ+2:конец]
        Ⲝ текущий != "":
          Ⲁ: части += ⲨⲂ_str(текущий)
        текущий = ""
        части += ⲨⲂ_call("format_with", [аргументы[индекс_арг], ⲨⲂ_str(спец)])
        индекс_арг += 1
        ⲓ = конец + 1
    _:
      текущий += шаблон[ⲓ]
      ⲓ += 1
  
  Ⲝ текущий != "":
    Ⲁ: части += ⲨⲂ_str(текущий)
  
  Ⲣ ⲨⲂ_call("concat", части)

// ============================================
// include! — ВКЛЮЧЕНИЕ ФАЙЛОВ
// ============================================

Ⲫ зарег_include(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["include"] = ⲨⲘⲠ {
    Ⲁ: "include",
    Ⲃ: трансформ_include,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// include!("template.html")
Ⲫ трансформ_include(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ путь = ast.Ⲃ[0].Ⲅ
  
  // Читаем файл на этапе компиляции
  Ⲙ содержимое = читать_файл(путь)
  Ⲝ содержимое.ошибка:
    Ⲁ: ошибка_компиляции("Не удалось прочитать файл: " + путь)
  
  Ⲣ ⲨⲂ_str(содержимое.значение)

// ============================================
// env! — ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ
// ============================================

Ⲫ зарег_env(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["env"] = ⲨⲘⲠ {
    Ⲁ: "env",
    Ⲃ: трансформ_env,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// env!("DATABASE_URL")
Ⲫ трансформ_env(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ имя = ast.Ⲃ[0].Ⲅ
  
  // Проверяем на этапе компиляции
  Ⲙ значение = получить_env(имя)
  Ⲝ значение.пусто:
    Ⲁ: ошибка_компиляции("Переменная окружения не найдена: " + имя)
  
  Ⲣ ⲨⲂ_str(значение.значение)

// ============================================
// cfg! — УСЛОВНАЯ КОМПИЛЯЦИЯ
// ============================================

Ⲫ зарег_cfg(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["cfg"] = ⲨⲘⲠ {
    Ⲁ: "cfg",
    Ⲃ: трансформ_cfg,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// cfg!(target_os = "linux")
Ⲫ трансформ_cfg(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ условие = ast.Ⲃ[0]
  
  // Вычисляем условие на этапе компиляции
  Ⲙ результат = вычислить_cfg(условие)
  
  Ⲣ ⲨⲂ_bool(результат)

// ============================================
// concat! — КОНКАТЕНАЦИЯ ЛИТЕРАЛОВ
// ============================================

Ⲫ зарег_concat(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["concat"] = ⲨⲘⲠ {
    Ⲁ: "concat",
    Ⲃ: трансформ_concat,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// concat!("Hello", " ", "World")
Ⲫ трансформ_concat(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ части = ast.Ⲃ
  Ⲙ результат = ""
  
  Ⲯ часть части:
    Ⲝ часть.Ⲁ != Ⲙ:  // не литерал
      Ⲁ: ошибка_компиляции("concat! требует литералы")
    результат += часть.Ⲅ
  
  Ⲣ ⲨⲂ_str(результат)

// ============================================
// stringify! — ПРЕОБРАЗОВАНИЕ В СТРОКУ
// ============================================

Ⲫ зарег_stringify(р: ⲢⲘⲠ) -> ⲢⲘⲠ:
  р.Ⲁ["stringify"] = ⲨⲘⲠ {
    Ⲁ: "stringify",
    Ⲃ: трансформ_stringify,
    Ⲅ: Ⲁ
  }
  Ⲣ р

// stringify!(some_identifier)
Ⲫ трансформ_stringify(ast: ⲨⲂ, ctx: ⲨⲘⲇ) -> ⲨⲂ:
  Ⲙ выражение = ast.Ⲃ[0]
  
  // Преобразуем AST в строку
  Ⲣ ⲨⲂ_str(ast_to_string(выражение))

// ============================================
// ГЛАВНЫЙ ОБРАБОТЧИК
// ============================================

Ⲫ обработать_proc_макросы(р: ⲢⲘⲠ, ast: ⲨⲂ) -> ⲨⲂ:
  Ⲝ ast.Ⲁ == Ⲍ:  // вызов макроса
    Ⲁ:
      Ⲙ имя = ast.Ⲅ
      Ⲝ имя ∈ р.Ⲁ:
        Ⲁ:
          Ⲙ макрос = р.Ⲁ[имя]
          Ⲙ ctx = ⲨⲘⲇ { Ⲁ: {}, Ⲃ: р.Ⲃ, Ⲅ: [] }
          р.Ⲃ += 1
          Ⲣ макрос.Ⲃ(ast, ctx)
  
  // Рекурсивно для детей
  ast.Ⲃ = ast.Ⲃ.map(ребёнок -> обработать_proc_макросы(р, ребёнок))
  Ⲣ ast
