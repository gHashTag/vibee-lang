// ═══════════════════════════════════════════════════════════════
// COLLECTIONS MODULE - .999 Standard Library
// Version: 2.0.0 | Trinity: n=27 k=3 m=0
// ═══════════════════════════════════════════════════════════════

Ⲯ ⲕⲟⲣⲉ
Ⲯ ⲧⲣⲓⲛⲓⲧⲩ

// ═══════════════════════════════════════════════════════════════
// VECTOR - Dynamic Array
// ═══════════════════════════════════════════════════════════════
Ⲏ Vec[T] {
    Ⲃ data: [T] = []
    Ⲃ len: Ⲓⲛⲧ = 0
    Ⲃ capacity: Ⲓⲛⲧ = 0
    
    Ⲫ new() → Vec[T] { Ⲣ Vec {} }
    
    Ⲫ with_capacity(Ⲁ cap: Ⲓⲛⲧ) → Vec[T] {
        Ⲣ Vec { capacity: cap }
    }
    
    Ⲫ push(Ⲥ, Ⲁ item: T) {
        Ⲥ.data.push(item)
        Ⲥ.len += 1
    }
    
    Ⲫ pop(Ⲥ) → T? {
        Ⲉ Ⲥ.len == 0 { Ⲣ ○ }
        Ⲥ.len -= 1
        Ⲣ Ⲥ.data.pop()
    }
    
    Ⲫ get(Ⲥ, Ⲁ index: Ⲓⲛⲧ) → T? {
        Ⲉ index < 0 || index >= Ⲥ.len { Ⲣ ○ }
        Ⲣ Ⲥ.data[index]
    }
    
    Ⲫ set(Ⲥ, Ⲁ index: Ⲓⲛⲧ, Ⲁ value: T) → Trit {
        Ⲉ index < 0 || index >= Ⲥ.len { Ⲣ ▽ }
        Ⲥ.data[index] = value
        Ⲣ △
    }
    
    Ⲫ first(Ⲥ) → T? { Ⲣ Ⲥ.get(0) }
    Ⲫ last(Ⲥ) → T? { Ⲣ Ⲥ.get(Ⲥ.len - 1) }
    Ⲫ is_empty(Ⲥ) → Trit { Ⲣ Ⲥ.len == 0 ? △ : ▽ }
    
    Ⲫ map[U](Ⲥ, Ⲁ f: Ⲫⲛ(T) → U) → Vec[U] {
        Ⲃ result = Vec[U].new()
        Ⲝ item ∈ Ⲥ.data { result.push(f(item)) }
        Ⲣ result
    }
    
    Ⲫ filter(Ⲥ, Ⲁ pred: Ⲫⲛ(T) → Trit) → Vec[T] {
        Ⲃ result = Vec[T].new()
        Ⲝ item ∈ Ⲥ.data {
            Ⲉ pred(item) == △ { result.push(item) }
        }
        Ⲣ result
    }
    
    Ⲫ reduce[U](Ⲥ, Ⲁ init: U, Ⲁ f: Ⲫⲛ(U, T) → U) → U {
        Ⲃ acc = init
        Ⲝ item ∈ Ⲥ.data { acc = f(acc, item) }
        Ⲣ acc
    }
}

// ═══════════════════════════════════════════════════════════════
// HASHMAP - Key-Value Store
// ═══════════════════════════════════════════════════════════════
Ⲏ HashMap[K, V] {
    Ⲃ buckets: [[Entry[K, V]]]
    Ⲃ size: Ⲓⲛⲧ = 0
    Ⲃ capacity: Ⲓⲛⲧ = 16
    
    Ⲫ new() → HashMap[K, V] {
        Ⲣ HashMap { buckets: [[] ; 16] }
    }
    
    Ⲫ hash(Ⲥ, Ⲁ key: K) → Ⲓⲛⲧ {
        Ⲣ xxhash(key) % Ⲥ.capacity
    }
    
    Ⲫ set(Ⲥ, Ⲁ key: K, Ⲁ value: V) {
        Ⲃ idx = Ⲥ.hash(key)
        Ⲝ entry ∈ Ⲥ.buckets[idx] {
            Ⲉ entry.key == key { entry.value = value; Ⲣ }
        }
        Ⲥ.buckets[idx].push(Entry { key: key, value: value })
        Ⲥ.size += 1
    }
    
    Ⲫ get(Ⲥ, Ⲁ key: K) → V? {
        Ⲃ idx = Ⲥ.hash(key)
        Ⲝ entry ∈ Ⲥ.buckets[idx] {
            Ⲉ entry.key == key { Ⲣ entry.value }
        }
        Ⲣ ○
    }
    
    Ⲫ has(Ⲥ, Ⲁ key: K) → Trit {
        Ⲣ Ⲥ.get(key) != ○ ? △ : ▽
    }
    
    Ⲫ delete(Ⲥ, Ⲁ key: K) → Trit {
        Ⲃ idx = Ⲥ.hash(key)
        Ⲝ i, entry ∈ Ⲥ.buckets[idx].enumerate() {
            Ⲉ entry.key == key {
                Ⲥ.buckets[idx].remove(i)
                Ⲥ.size -= 1
                Ⲣ △
            }
        }
        Ⲣ ▽
    }
    
    Ⲫ keys(Ⲥ) → Vec[K] {
        Ⲃ result = Vec[K].new()
        Ⲝ bucket ∈ Ⲥ.buckets {
            Ⲝ entry ∈ bucket { result.push(entry.key) }
        }
        Ⲣ result
    }
    
    Ⲫ values(Ⲥ) → Vec[V] {
        Ⲃ result = Vec[V].new()
        Ⲝ bucket ∈ Ⲥ.buckets {
            Ⲝ entry ∈ bucket { result.push(entry.value) }
        }
        Ⲣ result
    }
}

Ⲏ Entry[K, V] {
    Ⲃ key: K
    Ⲃ value: V
}

// ═══════════════════════════════════════════════════════════════
// SET - Unique Collection
// ═══════════════════════════════════════════════════════════════
Ⲏ Set[T] {
    Ⲃ map: HashMap[T, Trit] = HashMap.new()
    
    Ⲫ new() → Set[T] { Ⲣ Set {} }
    
    Ⲫ add(Ⲥ, Ⲁ item: T) { Ⲥ.map.set(item, △) }
    Ⲫ has(Ⲥ, Ⲁ item: T) → Trit { Ⲣ Ⲥ.map.has(item) }
    Ⲫ remove(Ⲥ, Ⲁ item: T) → Trit { Ⲣ Ⲥ.map.delete(item) }
    Ⲫ len(Ⲥ) → Ⲓⲛⲧ { Ⲣ Ⲥ.map.size }
    
    Ⲫ union(Ⲥ, Ⲁ other: Set[T]) → Set[T] {
        Ⲃ result = Set[T].new()
        Ⲝ item ∈ Ⲥ.map.keys().data { result.add(item) }
        Ⲝ item ∈ other.map.keys().data { result.add(item) }
        Ⲣ result
    }
    
    Ⲫ intersection(Ⲥ, Ⲁ other: Set[T]) → Set[T] {
        Ⲃ result = Set[T].new()
        Ⲝ item ∈ Ⲥ.map.keys().data {
            Ⲉ other.has(item) == △ { result.add(item) }
        }
        Ⲣ result
    }
}

// ═══════════════════════════════════════════════════════════════
// QUEUE - FIFO
// ═══════════════════════════════════════════════════════════════
Ⲏ Queue[T] {
    Ⲃ data: Vec[T] = Vec.new()
    
    Ⲫ new() → Queue[T] { Ⲣ Queue {} }
    Ⲫ enqueue(Ⲥ, Ⲁ item: T) { Ⲥ.data.push(item) }
    Ⲫ dequeue(Ⲥ) → T? {
        Ⲉ Ⲥ.data.is_empty() == △ { Ⲣ ○ }
        Ⲣ Ⲥ.data.data.shift()
    }
    Ⲫ peek(Ⲥ) → T? { Ⲣ Ⲥ.data.first() }
    Ⲫ len(Ⲥ) → Ⲓⲛⲧ { Ⲣ Ⲥ.data.len }
}

// ═══════════════════════════════════════════════════════════════
// STACK - LIFO
// ═══════════════════════════════════════════════════════════════
Ⲏ Stack[T] {
    Ⲃ data: Vec[T] = Vec.new()
    
    Ⲫ new() → Stack[T] { Ⲣ Stack {} }
    Ⲫ push(Ⲥ, Ⲁ item: T) { Ⲥ.data.push(item) }
    Ⲫ pop(Ⲥ) → T? { Ⲣ Ⲥ.data.pop() }
    Ⲫ peek(Ⲥ) → T? { Ⲣ Ⲥ.data.last() }
    Ⲫ len(Ⲥ) → Ⲓⲛⲧ { Ⲣ Ⲥ.data.len }
}

// ═══════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════
⊡ test "vec_operations" {
    Ⲃ v = Vec[Ⲓⲛⲧ].new()
    v.push(1); v.push(2); v.push(3)
    ⊜! v.len == 3
    ⊜! v.get(1) == 2
    ⊜! v.pop() == 3
}

⊡ test "hashmap_operations" {
    Ⲃ m = HashMap[Ⲧⲉⲝⲧ, Ⲓⲛⲧ].new()
    m.set("a", 1); m.set("b", 2)
    ⊜! m.get("a") == 1
    ⊜! m.has("b") == △
}

⊡ test "set_operations" {
    Ⲃ s1 = Set[Ⲓⲛⲧ].new()
    s1.add(1); s1.add(2)
    Ⲃ s2 = Set[Ⲓⲛⲧ].new()
    s2.add(2); s2.add(3)
    Ⲃ u = s1.union(s2)
    ⊜! u.len() == 3
}
