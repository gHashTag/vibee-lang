// ═══════════════════════════════════════════════════════════════
// BALANCED TERNARY ARITHMETIC - Full Implementation (1.5x)
// Base-3 number system with digits {-1, 0, 1} (T, 0, 1)
// ═══════════════════════════════════════════════════════════════

Ⲯ ⲧⲣⲓⲧ

// Trit values: T=-1, O=0, I=1
Ⲏ Trit {
    Ⲃ value: Ⲓⲛⲧ  // -1, 0, or 1
    
    Ⲫ T() → Trit { Ⲣ Trit { value: -1 } }
    Ⲫ O() → Trit { Ⲣ Trit { value: 0 } }
    Ⲫ I() → Trit { Ⲣ Trit { value: 1 } }
    
    Ⲫ neg(Ⲥ) → Trit { Ⲣ Trit { value: -Ⲥ.value } }
    
    Ⲫ add(Ⲥ, Ⲁ other: Trit) → (Trit, Trit) {
        Ⲃ sum = Ⲥ.value + other.value
        Ⲉ sum == 2 { Ⲣ (Trit.T(), Trit.I()) }      // 1+1=2 → T,1 (carry 1, digit -1)
        Ⲉ sum == -2 { Ⲣ (Trit.I(), Trit.T()) }     // -1+-1=-2 → 1,T (carry -1, digit 1)
        Ⲣ (Trit.O(), Trit { value: sum })           // no carry
    }
    
    Ⲫ mul(Ⲥ, Ⲁ other: Trit) → Trit {
        Ⲣ Trit { value: Ⲥ.value * other.value }
    }
}

// Balanced Ternary Number (arbitrary precision)
Ⲏ BTNumber {
    Ⲃ trits: [Trit]  // LSB first
    Ⲃ sign: Ⲓⲛⲧ = 1
    
    Ⲫ zero() → BTNumber { Ⲣ BTNumber { trits: [Trit.O()] } }
    Ⲫ one() → BTNumber { Ⲣ BTNumber { trits: [Trit.I()] } }
    Ⲫ neg_one() → BTNumber { Ⲣ BTNumber { trits: [Trit.T()] } }
    
    // Convert from decimal integer
    Ⲫ from_int(Ⲁ n: Ⲓⲛⲧ) → BTNumber {
        Ⲉ n == 0 { Ⲣ BTNumber.zero() }
        
        Ⲃ result: [Trit] = []
        Ⲃ val = n
        
        Ⲝ val != 0 {
            Ⲃ rem = val % 3
            val = val / 3
            
            Ⲉ rem == 0 { result.push(Trit.O()) }
            Ⲉ rem == 1 { result.push(Trit.I()) }
            Ⲉ rem == 2 { 
                result.push(Trit.T())  // -1
                val = val + 1          // carry
            }
            Ⲉ rem == -1 { result.push(Trit.T()) }
            Ⲉ rem == -2 {
                result.push(Trit.I())  // 1
                val = val - 1          // borrow
            }
        }
        
        Ⲣ BTNumber { trits: result }
    }
    
    // Convert to decimal integer
    Ⲫ to_int(Ⲥ) → Ⲓⲛⲧ {
        Ⲃ result = 0
        Ⲃ power = 1
        
        Ⲝ i ∈ 0..Ⲥ.trits.len() {
            result = result + Ⲥ.trits[i].value * power
            power = power * 3
        }
        
        Ⲣ result
    }
    
    // Negation: flip all trits
    Ⲫ neg(Ⲥ) → BTNumber {
        Ⲃ result: [Trit] = []
        Ⲝ t ∈ Ⲥ.trits { result.push(t.neg()) }
        Ⲣ BTNumber { trits: result }
    }
    
    // Addition with carry propagation
    Ⲫ add(Ⲥ, Ⲁ other: BTNumber) → BTNumber {
        Ⲃ result: [Trit] = []
        Ⲃ carry = Trit.O()
        Ⲃ max_len = max(Ⲥ.trits.len(), other.trits.len())
        
        Ⲝ i ∈ 0..max_len {
            Ⲃ a = Ⲉ i < Ⲥ.trits.len() { Ⲥ.trits[i] } Ⲁ { Trit.O() }
            Ⲃ b = Ⲉ i < other.trits.len() { other.trits[i] } Ⲁ { Trit.O() }
            
            // Add a + b + carry
            Ⲃ (c1, s1) = a.add(b)
            Ⲃ (c2, s2) = s1.add(carry)
            Ⲃ (c3, final_carry) = c1.add(c2)
            
            result.push(s2)
            carry = final_carry
        }
        
        Ⲉ carry.value != 0 { result.push(carry) }
        
        Ⲣ BTNumber { trits: result }.normalize()
    }
    
    // Subtraction: add negation
    Ⲫ sub(Ⲥ, Ⲁ other: BTNumber) → BTNumber {
        Ⲣ Ⲥ.add(other.neg())
    }
    
    // Multiplication using shift-and-add
    Ⲫ mul(Ⲥ, Ⲁ other: BTNumber) → BTNumber {
        Ⲃ result = BTNumber.zero()
        
        Ⲝ i ∈ 0..other.trits.len() {
            Ⲃ trit = other.trits[i]
            Ⲉ trit.value != 0 {
                Ⲃ shifted = Ⲥ.shift_left(i)
                Ⲉ trit.value == -1 { shifted = shifted.neg() }
                result = result.add(shifted)
            }
        }
        
        Ⲣ result.normalize()
    }
    
    // Shift left by n positions (multiply by 3^n)
    Ⲫ shift_left(Ⲥ, Ⲁ n: Ⲓⲛⲧ) → BTNumber {
        Ⲃ result: [Trit] = []
        Ⲝ _ ∈ 0..n { result.push(Trit.O()) }
        Ⲝ t ∈ Ⲥ.trits { result.push(t) }
        Ⲣ BTNumber { trits: result }
    }
    
    // Remove leading zeros
    Ⲫ normalize(Ⲥ) → BTNumber {
        Ⲃ result = Ⲥ.trits
        Ⲝ result.len() > 1 && result[result.len()-1].value == 0 {
            result.pop()
        }
        Ⲣ BTNumber { trits: result }
    }
    
    // Comparison
    Ⲫ cmp(Ⲥ, Ⲁ other: BTNumber) → Ⲓⲛⲧ {
        Ⲃ a = Ⲥ.normalize()
        Ⲃ b = other.normalize()
        
        Ⲉ a.trits.len() != b.trits.len() {
            Ⲃ a_sign = a.trits[a.trits.len()-1].value
            Ⲃ b_sign = b.trits[b.trits.len()-1].value
            Ⲉ a_sign != b_sign { Ⲣ a_sign - b_sign }
            Ⲣ Ⲉ a_sign > 0 { a.trits.len() - b.trits.len() } Ⲁ { b.trits.len() - a.trits.len() }
        }
        
        Ⲝ i ∈ (0..a.trits.len()).rev() {
            Ⲉ a.trits[i].value != b.trits[i].value {
                Ⲣ a.trits[i].value - b.trits[i].value
            }
        }
        
        Ⲣ 0
    }
    
    // String representation: T=-1, 0=0, 1=1
    Ⲫ to_string(Ⲥ) → Ⲧⲉⲝⲧ {
        Ⲃ result = ""
        Ⲝ i ∈ (0..Ⲥ.trits.len()).rev() {
            Ⲃ t = Ⲥ.trits[i]
            Ⲉ t.value == -1 { result = result + "T" }
            Ⲉ t.value == 0 { result = result + "0" }
            Ⲉ t.value == 1 { result = result + "1" }
        }
        Ⲣ result
    }
}

// ═══════════════════════════════════════════════════════════════
// TERNARY LOGIC OPERATIONS
// ═══════════════════════════════════════════════════════════════

Ⲏ TernaryLogic {
    // Kleene's strong three-valued logic
    Ⲫ and(Ⲁ a: Trit, Ⲁ b: Trit) → Trit {
        Ⲣ Trit { value: min(a.value, b.value) }
    }
    
    Ⲫ or(Ⲁ a: Trit, Ⲁ b: Trit) → Trit {
        Ⲣ Trit { value: max(a.value, b.value) }
    }
    
    Ⲫ not(Ⲁ a: Trit) → Trit {
        Ⲣ a.neg()
    }
    
    // Łukasiewicz implication: a → b = min(1, 1 - a + b)
    Ⲫ implies(Ⲁ a: Trit, Ⲁ b: Trit) → Trit {
        Ⲃ val = min(1, 1 - a.value + b.value)
        Ⲣ Trit { value: val }
    }
    
    // Consensus: returns value if both agree, else unknown
    Ⲫ consensus(Ⲁ a: Trit, Ⲁ b: Trit) → Trit {
        Ⲉ a.value == b.value { Ⲣ a }
        Ⲣ Trit.O()  // unknown/neutral
    }
}

// ═══════════════════════════════════════════════════════════════
// BALANCED TERNARY DIVISION
// ═══════════════════════════════════════════════════════════════

Ⲏ BTDivision {
    // Division with remainder
    Ⲫ divmod(Ⲁ dividend: BTNumber, Ⲁ divisor: BTNumber) → (BTNumber, BTNumber) {
        Ⲉ divisor.to_int() == 0 { ⊘ }  // division by zero
        
        Ⲃ quotient = BTNumber.zero()
        Ⲃ remainder = dividend
        Ⲃ d_abs = Ⲉ divisor.to_int() < 0 { divisor.neg() } Ⲁ { divisor }
        
        // Long division algorithm
        Ⲃ shift = dividend.trits.len() - divisor.trits.len()
        
        Ⲝ shift >= 0 {
            Ⲃ shifted = d_abs.shift_left(shift)
            
            // Try +1, 0, -1 for this position
            Ⲃ test_pos = remainder.sub(shifted)
            Ⲃ test_neg = remainder.add(shifted)
            
            Ⲉ abs(test_pos.to_int()) <= abs(remainder.to_int()) {
                remainder = test_pos
                quotient = quotient.add(BTNumber.one().shift_left(shift))
            } Ⲁ Ⲉ abs(test_neg.to_int()) < abs(remainder.to_int()) {
                remainder = test_neg
                quotient = quotient.sub(BTNumber.one().shift_left(shift))
            }
            
            shift = shift - 1
        }
        
        // Adjust sign
        Ⲉ divisor.to_int() < 0 { quotient = quotient.neg() }
        
        Ⲣ (quotient.normalize(), remainder.normalize())
    }
}

// ═══════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════

Ⲫ test_balanced_ternary() {
    // Test conversion
    Ⲃ n5 = BTNumber.from_int(5)   // 5 = 1*9 - 1*3 - 1*1 = 1TT
    assert(n5.to_int() == 5)
    assert(n5.to_string() == "1TT")
    
    Ⲃ n7 = BTNumber.from_int(7)   // 7 = 1*9 - 1*3 + 1*1 = 1T1
    assert(n7.to_int() == 7)
    
    Ⲃ nm5 = BTNumber.from_int(-5) // -5 = T11
    assert(nm5.to_int() == -5)
    
    // Test addition
    Ⲃ sum = n5.add(n7)            // 5 + 7 = 12
    assert(sum.to_int() == 12)
    
    // Test subtraction
    Ⲃ diff = n7.sub(n5)           // 7 - 5 = 2
    assert(diff.to_int() == 2)
    
    // Test multiplication
    Ⲃ prod = n5.mul(n7)           // 5 * 7 = 35
    assert(prod.to_int() == 35)
    
    // Test negation
    Ⲃ neg5 = n5.neg()
    assert(neg5.to_int() == -5)
    
    // Test division
    Ⲃ (q, r) = BTDivision.divmod(BTNumber.from_int(17), BTNumber.from_int(5))
    assert(q.to_int() == 3)
    assert(r.to_int() == 2)
    
    // Test ternary logic
    Ⲃ t = Trit.I()   // true
    Ⲃ f = Trit.T()   // false
    Ⲃ u = Trit.O()   // unknown
    
    assert(TernaryLogic.and(t, t).value == 1)
    assert(TernaryLogic.and(t, u).value == 0)
    assert(TernaryLogic.and(t, f).value == -1)
    assert(TernaryLogic.or(f, u).value == 0)
    assert(TernaryLogic.not(t).value == -1)
}

// ═══════════════════════════════════════════════════════════════
// BALANCED TERNARY CONVERSION TABLE
// ═══════════════════════════════════════════════════════════════
//
// Decimal | Balanced Ternary | Representation
// --------|------------------|---------------
//    -13  |       TTT        | -9-3-1
//    -12  |       TT0        | -9-3
//    -11  |       TT1        | -9-3+1
//    -10  |       T0T        | -9-1
//     -9  |       T00        | -9
//     -8  |       T01        | -9+1
//     -7  |       T1T        | -9+3-1
//     -6  |       T10        | -9+3
//     -5  |       T11        | -9+3+1
//     -4  |       0TT        | -3-1
//     -3  |       0T0        | -3
//     -2  |       0T1        | -3+1
//     -1  |       00T        | -1
//      0  |       000        | 0
//      1  |       001        | 1
//      2  |       01T        | 3-1
//      3  |       010        | 3
//      4  |       011        | 3+1
//      5  |       1TT        | 9-3-1
//      6  |       1T0        | 9-3
//      7  |       1T1        | 9-3+1
//      8  |       10T        | 9-1
//      9  |       100        | 9
//     10  |       101        | 9+1
//     11  |       11T        | 9+3-1
//     12  |       110        | 9+3
//     13  |       111        | 9+3+1
// ═══════════════════════════════════════════════════════════════
