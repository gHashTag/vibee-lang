// ═══════════════════════════════════════════════════════════════════════════════
// BIOLOGICAL EMERGENCE — Биологическая Эмерджентность
// ═══════════════════════════════════════════════════════════════════════════════
//
// E = Σᵢ fitness(gᵢ) × adaptation(eᵢ)
//
// Layers: 27 | Papers: 52 | Behaviors: 81 | V_biological ≈ 10^27
//
// Generated from: specs/biological_emergence.vibee
// ═══════════════════════════════════════════════════════════════════════════════

ⵣ.module biological_emergence {
    ⵣ.version = "3.0.0"
    
    // ═══════════════════════════════════════════════════════════════════════════
    // КОНСТАНТЫ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.const LAYERS = 27
    ⵣ.const PAPERS = 52
    ⵣ.const BEHAVIORS = 81
    ⵣ.const V_BIOLOGICAL_EXPONENT = 27
    
    // Эволюционные параметры по умолчанию
    ⵣ.const DEFAULT_POPULATION_SIZE = 100
    ⵣ.const DEFAULT_CROSSOVER_RATE = 0.8
    ⵣ.const DEFAULT_MUTATION_RATE = 0.01
    ⵣ.const DEFAULT_GENERATIONS = 1000
    ⵣ.const DEFAULT_ELITISM = 2
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ТИПЫ ДАННЫХ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type Gene = struct {
        value: f64,
        min: f64,
        max: f64,
        
        ⵣ.fn mutate(self: *Gene, sigma: f64) -> void {
            var delta = ⵣ.random_gaussian(0.0, sigma)
            self.value = @max(self.min, @min(self.max, self.value + delta))
        }
    }
    
    ⵣ.type Genome = struct {
        genes: []Gene,
        fitness: f64,
        age: u32,
        
        ⵣ.fn length(self: Genome) -> usize {
            return self.genes.len
        }
        
        ⵣ.fn clone(self: Genome) -> Genome {
            var new_genes = ⵣ.alloc(Gene, self.genes.len)
            @memcpy(new_genes, self.genes)
            return Genome{
                .genes = new_genes,
                .fitness = self.fitness,
                .age = 0
            }
        }
    }
    
    ⵣ.type Population = struct {
        individuals: []Genome,
        generation: u32,
        best_fitness: f64,
        average_fitness: f64
    }
    
    ⵣ.type SelectionMethod = enum {
        Tournament,
        Roulette,
        Rank,
        Elitism
    }
    
    ⵣ.type CrossoverMethod = enum {
        SinglePoint,
        TwoPoint,
        Uniform,
        Arithmetic
    }
    
    ⵣ.type EvolutionConfig = struct {
        population_size: usize,
        crossover_rate: f64,
        mutation_rate: f64,
        max_generations: u32,
        elitism_count: usize,
        selection: SelectionMethod,
        crossover: CrossoverMethod
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // SWARM TYPES
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type Particle = struct {
        position: []f64,
        velocity: []f64,
        best_position: []f64,
        best_fitness: f64
    }
    
    ⵣ.type Swarm = struct {
        particles: []Particle,
        global_best_position: []f64,
        global_best_fitness: f64,
        inertia: f64,
        cognitive: f64,
        social: f64
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // EMERGENCE TYPES
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.type EmergenceLevel = enum {
        Molecular,    // Level 1
        Cellular,     // Level 2
        Tissue,       // Level 3
        Organ,        // Level 4
        Organism,     // Level 5
        Population,   // Level 6
        Ecosystem     // Level 7
    }
    
    ⵣ.type EmergentProperty = struct {
        level: EmergenceLevel,
        name: []const u8,
        complexity: f64
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ГЕНЕТИЧЕСКИЙ АЛГОРИТМ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn init_population(size: usize, genome_length: usize) -> Population {
        var individuals = ⵣ.alloc(Genome, size)
        
        for (individuals) |*ind| {
            ind.genes = ⵣ.alloc(Gene, genome_length)
            for (ind.genes) |*gene| {
                gene.value = ⵣ.random_f64()
                gene.min = 0.0
                gene.max = 1.0
            }
            ind.fitness = 0.0
            ind.age = 0
        }
        
        return Population{
            .individuals = individuals,
            .generation = 0,
            .best_fitness = 0.0,
            .average_fitness = 0.0
        }
    }
    
    ⵣ.fn evaluate_population(pop: *Population, fitness_fn: fn(Genome) -> f64) -> void {
        var total_fitness: f64 = 0.0
        var best: f64 = 0.0
        
        for (pop.individuals) |*ind| {
            ind.fitness = fitness_fn(ind.*)
            total_fitness += ind.fitness
            if (ind.fitness > best) {
                best = ind.fitness
            }
        }
        
        pop.best_fitness = best
        pop.average_fitness = total_fitness / @intToFloat(f64, pop.individuals.len)
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // SELECTION
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn tournament_select(pop: Population, k: usize) -> *Genome {
        var best: ?*Genome = null
        var best_fitness: f64 = -1e10
        
        for (0..k) |_| {
            var idx = ⵣ.random_int(0, pop.individuals.len)
            if (pop.individuals[idx].fitness > best_fitness) {
                best_fitness = pop.individuals[idx].fitness
                best = &pop.individuals[idx]
            }
        }
        
        return best.?
    }
    
    ⵣ.fn roulette_select(pop: Population) -> *Genome {
        var total: f64 = 0.0
        for (pop.individuals) |ind| {
            total += ind.fitness
        }
        
        var spin = ⵣ.random_f64() * total
        var cumulative: f64 = 0.0
        
        for (pop.individuals) |*ind| {
            cumulative += ind.fitness
            if (cumulative >= spin) {
                return ind
            }
        }
        
        return &pop.individuals[pop.individuals.len - 1]
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // CROSSOVER
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn single_point_crossover(parent1: Genome, parent2: Genome) -> [2]Genome {
        var point = ⵣ.random_int(1, parent1.genes.len - 1)
        
        var child1 = parent1.clone()
        var child2 = parent2.clone()
        
        for (point..parent1.genes.len) |i| {
            child1.genes[i] = parent2.genes[i]
            child2.genes[i] = parent1.genes[i]
        }
        
        return [2]Genome{ child1, child2 }
    }
    
    ⵣ.fn uniform_crossover(parent1: Genome, parent2: Genome) -> [2]Genome {
        var child1 = parent1.clone()
        var child2 = parent2.clone()
        
        for (0..parent1.genes.len) |i| {
            if (ⵣ.random_f64() < 0.5) {
                child1.genes[i] = parent2.genes[i]
                child2.genes[i] = parent1.genes[i]
            }
        }
        
        return [2]Genome{ child1, child2 }
    }
    
    ⵣ.fn arithmetic_crossover(parent1: Genome, parent2: Genome, alpha: f64) -> [2]Genome {
        var child1 = parent1.clone()
        var child2 = parent2.clone()
        
        for (0..parent1.genes.len) |i| {
            child1.genes[i].value = alpha * parent1.genes[i].value + (1 - alpha) * parent2.genes[i].value
            child2.genes[i].value = (1 - alpha) * parent1.genes[i].value + alpha * parent2.genes[i].value
        }
        
        return [2]Genome{ child1, child2 }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // MUTATION
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn mutate(genome: *Genome, rate: f64, sigma: f64) -> void {
        for (genome.genes) |*gene| {
            if (ⵣ.random_f64() < rate) {
                gene.mutate(sigma)
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // EVOLUTION LOOP
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn evolve(pop: *Population, config: EvolutionConfig, fitness_fn: fn(Genome) -> f64) -> void {
        // Evaluate initial population
        evaluate_population(pop, fitness_fn)
        
        for (0..config.max_generations) |gen| {
            var new_individuals = ⵣ.alloc(Genome, config.population_size)
            
            // Elitism: copy best individuals
            sort_by_fitness(pop)
            for (0..config.elitism_count) |i| {
                new_individuals[i] = pop.individuals[i].clone()
            }
            
            // Generate rest through selection, crossover, mutation
            var idx = config.elitism_count
            while (idx < config.population_size) {
                var parent1 = tournament_select(pop.*, 3)
                var parent2 = tournament_select(pop.*, 3)
                
                if (ⵣ.random_f64() < config.crossover_rate) {
                    var children = single_point_crossover(parent1.*, parent2.*)
                    mutate(&children[0], config.mutation_rate, 0.1)
                    mutate(&children[1], config.mutation_rate, 0.1)
                    new_individuals[idx] = children[0]
                    if (idx + 1 < config.population_size) {
                        new_individuals[idx + 1] = children[1]
                    }
                    idx += 2
                } else {
                    new_individuals[idx] = parent1.clone()
                    idx += 1
                }
            }
            
            pop.individuals = new_individuals
            pop.generation = @intCast(u32, gen + 1)
            evaluate_population(pop, fitness_fn)
        }
    }
    
    ⵣ.fn sort_by_fitness(pop: *Population) -> void {
        // Simple bubble sort for clarity
        for (0..pop.individuals.len) |i| {
            for (i + 1..pop.individuals.len) |j| {
                if (pop.individuals[j].fitness > pop.individuals[i].fitness) {
                    var temp = pop.individuals[i]
                    pop.individuals[i] = pop.individuals[j]
                    pop.individuals[j] = temp
                }
            }
        }
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // PARTICLE SWARM OPTIMIZATION
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn init_swarm(size: usize, dimensions: usize) -> Swarm {
        var particles = ⵣ.alloc(Particle, size)
        
        for (particles) |*p| {
            p.position = ⵣ.alloc(f64, dimensions)
            p.velocity = ⵣ.alloc(f64, dimensions)
            p.best_position = ⵣ.alloc(f64, dimensions)
            
            for (0..dimensions) |d| {
                p.position[d] = ⵣ.random_f64() * 10.0 - 5.0
                p.velocity[d] = ⵣ.random_f64() * 2.0 - 1.0
                p.best_position[d] = p.position[d]
            }
            p.best_fitness = -1e10
        }
        
        return Swarm{
            .particles = particles,
            .global_best_position = ⵣ.alloc(f64, dimensions),
            .global_best_fitness = -1e10,
            .inertia = 0.7,
            .cognitive = 1.5,
            .social = 1.5
        }
    }
    
    ⵣ.fn pso_optimize(swarm: *Swarm, iterations: usize, fitness_fn: fn([]f64) -> f64) -> []f64 {
        for (0..iterations) |_| {
            for (swarm.particles) |*p| {
                // Evaluate fitness
                var fitness = fitness_fn(p.position)
                
                // Update personal best
                if (fitness > p.best_fitness) {
                    p.best_fitness = fitness
                    @memcpy(p.best_position, p.position)
                }
                
                // Update global best
                if (fitness > swarm.global_best_fitness) {
                    swarm.global_best_fitness = fitness
                    @memcpy(swarm.global_best_position, p.position)
                }
            }
            
            // Update velocities and positions
            for (swarm.particles) |*p| {
                for (0..p.position.len) |d| {
                    var r1 = ⵣ.random_f64()
                    var r2 = ⵣ.random_f64()
                    
                    p.velocity[d] = swarm.inertia * p.velocity[d] +
                        swarm.cognitive * r1 * (p.best_position[d] - p.position[d]) +
                        swarm.social * r2 * (swarm.global_best_position[d] - p.position[d])
                    
                    p.position[d] += p.velocity[d]
                }
            }
        }
        
        return swarm.global_best_position
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // EMERGENCE DETECTION
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.fn detect_emergence(pop: Population) -> []EmergentProperty {
        var properties = ⵣ.alloc(EmergentProperty, 0)
        
        // Check for collective behavior
        if (pop.average_fitness > 0.8 * pop.best_fitness) {
            properties = ⵣ.append(properties, EmergentProperty{
                .level = .Population,
                .name = "collective_optimization",
                .complexity = pop.average_fitness
            })
        }
        
        // Check for diversity maintenance
        var diversity = compute_diversity(pop)
        if (diversity > 0.3) {
            properties = ⵣ.append(properties, EmergentProperty{
                .level = .Ecosystem,
                .name = "diversity_maintenance",
                .complexity = diversity
            })
        }
        
        return properties
    }
    
    ⵣ.fn compute_diversity(pop: Population) -> f64 {
        var total_variance: f64 = 0.0
        var n = pop.individuals.len
        var g = pop.individuals[0].genes.len
        
        for (0..g) |gene_idx| {
            var mean: f64 = 0.0
            for (pop.individuals) |ind| {
                mean += ind.genes[gene_idx].value
            }
            mean /= @intToFloat(f64, n)
            
            var variance: f64 = 0.0
            for (pop.individuals) |ind| {
                var diff = ind.genes[gene_idx].value - mean
                variance += diff * diff
            }
            variance /= @intToFloat(f64, n)
            total_variance += variance
        }
        
        return total_variance / @intToFloat(f64, g)
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ТЕСТЫ
    // ═══════════════════════════════════════════════════════════════════════════
    
    ⵣ.test "population_initialized" {
        var pop = init_population(50, 10)
        ⵣ.expect_eq(pop.individuals.len, 50)
        ⵣ.expect_eq(pop.individuals[0].genes.len, 10)
    }
    
    ⵣ.test "fitness_improves" {
        var pop = init_population(100, 10)
        var config = EvolutionConfig{
            .population_size = 100,
            .crossover_rate = 0.8,
            .mutation_rate = 0.01,
            .max_generations = 50,
            .elitism_count = 2,
            .selection = .Tournament,
            .crossover = .SinglePoint
        }
        
        var initial_best = pop.best_fitness
        evolve(&pop, config, sphere_fitness)
        ⵣ.expect(pop.best_fitness > initial_best)
    }
    
    ⵣ.test "pso_converges" {
        var swarm = init_swarm(30, 5)
        var result = pso_optimize(&swarm, 100, sphere_fitness_array)
        ⵣ.expect(swarm.global_best_fitness > -1.0)
    }
    
    // Test fitness functions
    ⵣ.fn sphere_fitness(genome: Genome) -> f64 {
        var sum: f64 = 0.0
        for (genome.genes) |gene| {
            sum += gene.value * gene.value
        }
        return -sum  // Minimize sphere function
    }
    
    ⵣ.fn sphere_fitness_array(x: []f64) -> f64 {
        var sum: f64 = 0.0
        for (x) |xi| {
            sum += xi * xi
        }
        return -sum
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ЭКСПОРТ
// ═══════════════════════════════════════════════════════════════════════════════

ⵣ.export {
    biological_emergence.init_population,
    biological_emergence.evolve,
    biological_emergence.init_swarm,
    biological_emergence.pso_optimize,
    biological_emergence.detect_emergence,
    biological_emergence.tournament_select,
    biological_emergence.single_point_crossover,
    biological_emergence.mutate
}
