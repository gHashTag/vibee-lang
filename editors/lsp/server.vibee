/// Vibee Language Server Protocol Implementation
/// Provides IDE features: completion, diagnostics, hover, etc.

use std::io
use std::json
use std::net

use crate::lexer::{tokenize, Token, TokenKind}
use crate::parser::{parse, Module, Item}
use crate::typechecker::{check, TypeError, TypeInfo}

// LSP Message Types
pub struct Message {
    pub jsonrpc: String,
    pub id: Option<Int>,
    pub method: Option<String>,
    pub params: Option<json::Value>,
    pub result: Option<json::Value>,
    pub error: Option<ResponseError>,
}

pub struct ResponseError {
    pub code: Int,
    pub message: String,
    pub data: Option<json::Value>,
}

// LSP Server
pub struct LanguageServer {
    documents: HashMap<String, Document>,
    capabilities: ServerCapabilities,
    initialized: Bool,
}

pub struct Document {
    pub uri: String,
    pub version: Int,
    pub content: String,
    pub tokens: Vec<Token>,
    pub module: Option<Module>,
    pub diagnostics: Vec<Diagnostic>,
}

pub struct ServerCapabilities {
    pub text_document_sync: Int,
    pub completion_provider: Bool,
    pub hover_provider: Bool,
    pub definition_provider: Bool,
    pub references_provider: Bool,
    pub document_formatting_provider: Bool,
    pub document_symbol_provider: Bool,
    pub code_action_provider: Bool,
    pub rename_provider: Bool,
}

pub struct Diagnostic {
    pub range: Range,
    pub severity: Int,
    pub message: String,
    pub source: String,
}

pub struct Range {
    pub start: Position,
    pub end: Position,
}

pub struct Position {
    pub line: Int,
    pub character: Int,
}

pub struct CompletionItem {
    pub label: String,
    pub kind: Int,
    pub detail: Option<String>,
    pub documentation: Option<String>,
    pub insert_text: Option<String>,
}

pub struct Hover {
    pub contents: String,
    pub range: Option<Range>,
}

pub struct Location {
    pub uri: String,
    pub range: Range,
}

impl LanguageServer {
    pub fn new() -> LanguageServer {
        LanguageServer {
            documents: HashMap::new(),
            capabilities: ServerCapabilities {
                text_document_sync: 2, // Incremental
                completion_provider: true,
                hover_provider: true,
                definition_provider: true,
                references_provider: true,
                document_formatting_provider: true,
                document_symbol_provider: true,
                code_action_provider: true,
                rename_provider: true,
            },
            initialized: false,
        }
    }
    
    pub fn run(mut self) {
        loop {
            let msg = self.read_message()
            if let Some(response) = self.handle_message(msg) {
                self.write_message(response)
            }
        }
    }
    
    fn read_message(self) -> Message {
        // Read Content-Length header
        let header = io::read_line()
        let length: Int = header
            .strip_prefix("Content-Length: ")
            .unwrap()
            .trim()
            .parse()
            .unwrap()
        
        // Skip empty line
        io::read_line()
        
        // Read content
        let content = io::read_exact(length)
        json::parse(content)
    }
    
    fn write_message(self, msg: Message) {
        let content = json::stringify(msg)
        let header = format!("Content-Length: {}\r\n\r\n", content.len())
        io::write(header)
        io::write(content)
        io::flush()
    }
    
    fn handle_message(mut self, msg: Message) -> Option<Message> {
        if let Some(method) = msg.method.clone() {
            match method.as_str() {
                "initialize" => Some(self.handle_initialize(msg)),
                "initialized" => { self.initialized = true; None },
                "shutdown" => Some(self.handle_shutdown(msg)),
                "exit" => std::process::exit(0),
                "textDocument/didOpen" => { self.handle_did_open(msg); None },
                "textDocument/didChange" => { self.handle_did_change(msg); None },
                "textDocument/didClose" => { self.handle_did_close(msg); None },
                "textDocument/completion" => Some(self.handle_completion(msg)),
                "textDocument/hover" => Some(self.handle_hover(msg)),
                "textDocument/definition" => Some(self.handle_definition(msg)),
                "textDocument/references" => Some(self.handle_references(msg)),
                "textDocument/formatting" => Some(self.handle_formatting(msg)),
                "textDocument/documentSymbol" => Some(self.handle_document_symbol(msg)),
                "textDocument/codeAction" => Some(self.handle_code_action(msg)),
                "textDocument/rename" => Some(self.handle_rename(msg)),
                _ => None,
            }
        } else {
            None
        }
    }
    
    fn handle_initialize(self, msg: Message) -> Message {
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::object!{
                "capabilities": {
                    "textDocumentSync": self.capabilities.text_document_sync,
                    "completionProvider": {
                        "triggerCharacters": [".", ":", "<"]
                    },
                    "hoverProvider": self.capabilities.hover_provider,
                    "definitionProvider": self.capabilities.definition_provider,
                    "referencesProvider": self.capabilities.references_provider,
                    "documentFormattingProvider": self.capabilities.document_formatting_provider,
                    "documentSymbolProvider": self.capabilities.document_symbol_provider,
                    "codeActionProvider": self.capabilities.code_action_provider,
                    "renameProvider": self.capabilities.rename_provider
                },
                "serverInfo": {
                    "name": "vibee-lsp",
                    "version": "0.1.0"
                }
            }),
            error: None,
        }
    }
    
    fn handle_shutdown(self, msg: Message) -> Message {
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::Value::Null),
            error: None,
        }
    }
    
    fn handle_did_open(mut self, msg: Message) {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let content = params["textDocument"]["text"].as_str().unwrap()
        let version = params["textDocument"]["version"].as_int().unwrap()
        
        let doc = self.analyze_document(uri.to_string(), content.to_string(), version)
        self.documents.insert(uri.to_string(), doc)
        
        self.publish_diagnostics(uri.to_string())
    }
    
    fn handle_did_change(mut self, msg: Message) {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let version = params["textDocument"]["version"].as_int().unwrap()
        let changes = &params["contentChanges"]
        
        if let Some(doc) = self.documents.get_mut(&uri.to_string()) {
            for change in changes.as_array().unwrap() {
                if let Some(text) = change["text"].as_str() {
                    doc.content = text.to_string()
                    doc.version = version
                }
            }
            
            // Re-analyze
            let new_doc = self.analyze_document(uri.to_string(), doc.content.clone(), version)
            *doc = new_doc
        }
        
        self.publish_diagnostics(uri.to_string())
    }
    
    fn handle_did_close(mut self, msg: Message) {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        self.documents.remove(&uri.to_string())
    }
    
    fn handle_completion(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let position = &params["position"]
        let line = position["line"].as_int().unwrap()
        let character = position["character"].as_int().unwrap()
        
        let items = self.get_completions(uri.to_string(), line, character)
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::to_value(items)),
            error: None,
        }
    }
    
    fn handle_hover(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let position = &params["position"]
        let line = position["line"].as_int().unwrap()
        let character = position["character"].as_int().unwrap()
        
        let hover = self.get_hover(uri.to_string(), line, character)
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: hover.map(|h| json::to_value(h)),
            error: None,
        }
    }
    
    fn handle_definition(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let position = &params["position"]
        let line = position["line"].as_int().unwrap()
        let character = position["character"].as_int().unwrap()
        
        let location = self.get_definition(uri.to_string(), line, character)
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: location.map(|l| json::to_value(l)),
            error: None,
        }
    }
    
    fn handle_references(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let position = &params["position"]
        let line = position["line"].as_int().unwrap()
        let character = position["character"].as_int().unwrap()
        
        let locations = self.get_references(uri.to_string(), line, character)
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::to_value(locations)),
            error: None,
        }
    }
    
    fn handle_formatting(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        
        let edits = self.format_document(uri.to_string())
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::to_value(edits)),
            error: None,
        }
    }
    
    fn handle_document_symbol(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        
        let symbols = self.get_document_symbols(uri.to_string())
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::to_value(symbols)),
            error: None,
        }
    }
    
    fn handle_code_action(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let range = &params["range"]
        
        let actions = self.get_code_actions(uri.to_string(), range)
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::to_value(actions)),
            error: None,
        }
    }
    
    fn handle_rename(self, msg: Message) -> Message {
        let params = msg.params.unwrap()
        let uri = params["textDocument"]["uri"].as_str().unwrap()
        let position = &params["position"]
        let new_name = params["newName"].as_str().unwrap()
        
        let edits = self.rename_symbol(uri.to_string(), position, new_name.to_string())
        
        Message {
            jsonrpc: "2.0",
            id: msg.id,
            method: None,
            params: None,
            result: Some(json::to_value(edits)),
            error: None,
        }
    }
    
    // Analysis
    fn analyze_document(self, uri: String, content: String, version: Int) -> Document {
        let tokens = tokenize(content.clone())
        let module = parse(tokens.clone())
        let errors = check(module.clone())
        
        let diagnostics: Vec<Diagnostic> = errors.iter()
            .map(|e| Diagnostic {
                range: Range {
                    start: Position { line: e.span.line - 1, character: e.span.column - 1 },
                    end: Position { line: e.span.line - 1, character: e.span.column + 10 },
                },
                severity: 1, // Error
                message: e.message.clone(),
                source: "vibee".to_string(),
            })
            .collect()
        
        Document {
            uri,
            version,
            content,
            tokens,
            module: Some(module),
            diagnostics,
        }
    }
    
    fn publish_diagnostics(self, uri: String) {
        if let Some(doc) = self.documents.get(&uri) {
            let notification = Message {
                jsonrpc: "2.0",
                id: None,
                method: Some("textDocument/publishDiagnostics".to_string()),
                params: Some(json::object!{
                    "uri": uri,
                    "diagnostics": doc.diagnostics.clone()
                }),
                result: None,
                error: None,
            }
            self.write_message(notification)
        }
    }
    
    // Completion
    fn get_completions(self, uri: String, line: Int, character: Int) -> Vec<CompletionItem> {
        let mut items = Vec::new()
        
        // Keywords
        let keywords = ["fn", "struct", "enum", "trait", "impl", "actor",
                       "let", "var", "const", "mut", "pub",
                       "if", "else", "match", "for", "while", "loop",
                       "return", "break", "continue",
                       "async", "await", "spawn",
                       "true", "false", "nil"];
        
        for kw in keywords.iter() {
            items.push(CompletionItem {
                label: kw.to_string(),
                kind: 14, // Keyword
                detail: Some("keyword".to_string()),
                documentation: None,
                insert_text: None,
            })
        }
        
        // Types
        let types = ["Int", "Float", "Bool", "Char", "String", "Vec", "HashMap", "Option", "Result"];
        for ty in types.iter() {
            items.push(CompletionItem {
                label: ty.to_string(),
                kind: 7, // Class
                detail: Some("type".to_string()),
                documentation: None,
                insert_text: None,
            })
        }
        
        // Document symbols
        if let Some(doc) = self.documents.get(&uri) {
            if let Some(ref module) = doc.module {
                for item in module.items.iter() {
                    match item {
                        Item::Function(def) => {
                            items.push(CompletionItem {
                                label: def.name.clone(),
                                kind: 3, // Function
                                detail: Some("function".to_string()),
                                documentation: None,
                                insert_text: Some(format!("{}($0)", def.name)),
                            })
                        },
                        Item::Struct(def) => {
                            items.push(CompletionItem {
                                label: def.name.clone(),
                                kind: 7, // Class
                                detail: Some("struct".to_string()),
                                documentation: None,
                                insert_text: None,
                            })
                        },
                        _ => {},
                    }
                }
            }
        }
        
        items
    }
    
    // Hover
    fn get_hover(self, uri: String, line: Int, character: Int) -> Option<Hover> {
        if let Some(doc) = self.documents.get(&uri) {
            // Find token at position
            for token in doc.tokens.iter() {
                if token.span.line == line + 1 && 
                   character >= token.span.column - 1 &&
                   character < token.span.column - 1 + token.lexeme.len() as Int {
                    
                    let contents = match token.kind {
                        TokenKind::Fn => "**fn** - Function declaration",
                        TokenKind::Struct => "**struct** - Structure type",
                        TokenKind::Enum => "**enum** - Enumeration type",
                        TokenKind::Trait => "**trait** - Trait definition",
                        TokenKind::Impl => "**impl** - Implementation block",
                        TokenKind::Actor => "**actor** - Actor definition",
                        TokenKind::Identifier => {
                            // Look up type info
                            &format!("Identifier: {}", token.lexeme)
                        },
                        _ => &token.lexeme,
                    };
                    
                    return Some(Hover {
                        contents: contents.to_string(),
                        range: Some(Range {
                            start: Position { line, character: token.span.column - 1 },
                            end: Position { line, character: token.span.column - 1 + token.lexeme.len() as Int },
                        }),
                    })
                }
            }
        }
        None
    }
    
    // Definition
    fn get_definition(self, uri: String, line: Int, character: Int) -> Option<Location> {
        // Find definition of symbol at position
        // This is a simplified implementation
        None
    }
    
    // References
    fn get_references(self, uri: String, line: Int, character: Int) -> Vec<Location> {
        Vec::new()
    }
    
    // Formatting
    fn format_document(self, uri: String) -> Vec<TextEdit> {
        if let Some(doc) = self.documents.get(&uri) {
            let formatted = crate::format(doc.content.clone())
            vec![TextEdit {
                range: Range {
                    start: Position { line: 0, character: 0 },
                    end: Position { line: doc.content.lines().count() as Int, character: 0 },
                },
                new_text: formatted,
            }]
        } else {
            Vec::new()
        }
    }
    
    // Document symbols
    fn get_document_symbols(self, uri: String) -> Vec<DocumentSymbol> {
        let mut symbols = Vec::new()
        
        if let Some(doc) = self.documents.get(&uri) {
            if let Some(ref module) = doc.module {
                for item in module.items.iter() {
                    match item {
                        Item::Function(def) => {
                            symbols.push(DocumentSymbol {
                                name: def.name.clone(),
                                kind: 12, // Function
                                range: Range {
                                    start: Position { line: 0, character: 0 },
                                    end: Position { line: 0, character: 0 },
                                },
                                selection_range: Range {
                                    start: Position { line: 0, character: 0 },
                                    end: Position { line: 0, character: 0 },
                                },
                                children: Vec::new(),
                            })
                        },
                        Item::Struct(def) => {
                            symbols.push(DocumentSymbol {
                                name: def.name.clone(),
                                kind: 5, // Class
                                range: Range {
                                    start: Position { line: 0, character: 0 },
                                    end: Position { line: 0, character: 0 },
                                },
                                selection_range: Range {
                                    start: Position { line: 0, character: 0 },
                                    end: Position { line: 0, character: 0 },
                                },
                                children: Vec::new(),
                            })
                        },
                        _ => {},
                    }
                }
            }
        }
        
        symbols
    }
    
    // Code actions
    fn get_code_actions(self, uri: String, range: &json::Value) -> Vec<CodeAction> {
        Vec::new()
    }
    
    // Rename
    fn rename_symbol(self, uri: String, position: &json::Value, new_name: String) -> WorkspaceEdit {
        WorkspaceEdit { changes: HashMap::new() }
    }
}

pub struct TextEdit {
    pub range: Range,
    pub new_text: String,
}

pub struct DocumentSymbol {
    pub name: String,
    pub kind: Int,
    pub range: Range,
    pub selection_range: Range,
    pub children: Vec<DocumentSymbol>,
}

pub struct CodeAction {
    pub title: String,
    pub kind: String,
    pub edit: Option<WorkspaceEdit>,
}

pub struct WorkspaceEdit {
    pub changes: HashMap<String, Vec<TextEdit>>,
}

// Entry point
pub fn main() {
    let server = LanguageServer::new()
    server.run()
}
