#!/usr/bin/env python3
"""
СВЯЗЬ ЧИСЛА 3 И NP-ПОЛНОТЫ

Исследование того, почему 3 — порог вычислительной сложности.

Author: Dmitrii Vasilev
Date: January 13, 2026
"""

print("=" * 70)
print("ЧИСЛО 3 И NP-ПОЛНОТА: ПОРОГ СЛОЖНОСТИ")
print("=" * 70)

# =============================================================================
# ВВЕДЕНИЕ
# =============================================================================

print("""
╔══════════════════════════════════════════════════════════════════════════════╗
║                                                                              ║
║  ЧИСЛО 3: ПОРОГ ВЫЧИСЛИТЕЛЬНОЙ СЛОЖНОСТИ                                    ║
║                                                                              ║
║  Удивительный факт: многие задачи становятся NP-полными                     ║
║  именно при переходе от 2 к 3.                                              ║
║                                                                              ║
║  2 = ПРОСТО (P)                                                             ║
║  3 = СЛОЖНО (NP-полно)                                                      ║
║                                                                              ║
║  Это не совпадение. Это фундаментальное свойство                           ║
║  вычислительной сложности.                                                  ║
║                                                                              ║
╚══════════════════════════════════════════════════════════════════════════════╝
""")

# =============================================================================
# k-SAT
# =============================================================================

print("\n" + "=" * 70)
print("k-SAT: ВЫПОЛНИМОСТЬ БУЛЕВЫХ ФОРМУЛ")
print("=" * 70)

print("""
k-SAT: Выполнима ли формула в конъюнктивной нормальной форме,
       где каждый дизъюнкт содержит ровно k литералов?

ПРИМЕРЫ:

2-SAT: (x₁ ∨ x₂) ∧ (¬x₁ ∨ x₃) ∧ (¬x₂ ∨ ¬x₃)
       Можно решить за O(n) с помощью импликационного графа.
       КЛАСС: P ✓

3-SAT: (x₁ ∨ x₂ ∨ x₃) ∧ (¬x₁ ∨ x₂ ∨ ¬x₄) ∧ ...
       NP-ПОЛНАЯ! (Cook, 1971)
       Лучший известный алгоритм: O(1.307ⁿ)
       КЛАСС: NP-complete ✗

ПОЧЕМУ ПЕРЕХОД ПРИ k=3?

2-SAT:
  - Каждый дизъюнкт (a ∨ b) эквивалентен импликациям: ¬a → b, ¬b → a
  - Строим граф импликаций
  - Проверяем на сильную связность
  - Линейное время!

3-SAT:
  - Дизъюнкт (a ∨ b ∨ c) даёт 3 импликации, но они не образуют цепочку
  - Граф импликаций не помогает
  - Нужен полный перебор (с оптимизациями)

МАТЕМАТИЧЕСКАЯ ПРИЧИНА:
  2 литерала → линейная структура (цепочка импликаций)
  3 литерала → нелинейная структура (дерево решений)
  
  3 = минимальное число для нелинейности!
""")

# =============================================================================
# k-РАСКРАСКА ГРАФА
# =============================================================================

print("\n" + "=" * 70)
print("k-РАСКРАСКА ГРАФА")
print("=" * 70)

print("""
k-РАСКРАСКА: Можно ли раскрасить вершины графа в k цветов
             так, чтобы смежные вершины имели разные цвета?

2-РАСКРАСКА:
  - Эквивалентно проверке двудольности графа
  - BFS/DFS за O(V + E)
  - КЛАСС: P ✓

3-РАСКРАСКА:
  - NP-ПОЛНАЯ! (Karp, 1972)
  - Даже для планарных графов!
  - КЛАСС: NP-complete ✗

ПОЧЕМУ ПЕРЕХОД ПРИ k=3?

2 цвета:
  - Граф либо двудольный, либо нет
  - Простая проверка: есть ли нечётный цикл?
  - Локальное свойство!

3 цвета:
  - Нет простого локального критерия
  - Выбор цвета для одной вершины влияет на далёкие вершины
  - Глобальная оптимизация!

ТЕОРЕМА О ЧЕТЫРЁХ КРАСКАХ:
  Любой планарный граф можно раскрасить в 4 цвета.
  Но проверка 3-раскрашиваемости — NP-полна!
  
  4 = достаточно для планарных графов
  3 = порог сложности
""")

# =============================================================================
# k-МЕРНОЕ СОПОСТАВЛЕНИЕ
# =============================================================================

print("\n" + "=" * 70)
print("k-МЕРНОЕ СОПОСТАВЛЕНИЕ")
print("=" * 70)

print("""
k-DIMENSIONAL MATCHING:
  Даны k множеств и набор k-кортежей.
  Найти максимальное паросочетание (непересекающиеся кортежи).

2D MATCHING (Двудольное паросочетание):
  - Алгоритм Хопкрофта-Карпа: O(E√V)
  - Венгерский алгоритм: O(V³)
  - КЛАСС: P ✓

3D MATCHING:
  - NP-ПОЛНАЯ! (Karp, 1972)
  - Одна из 21 оригинальных NP-полных задач Карпа
  - КЛАСС: NP-complete ✗

ПОЧЕМУ ПЕРЕХОД ПРИ k=3?

2D:
  - Граф двудольный
  - Чередующиеся пути
  - Структура позволяет жадный подход

3D:
  - Гиперграф
  - Нет понятия "чередующегося пути"
  - Комбинаторный взрыв
""")

# =============================================================================
# ДРУГИЕ ПРИМЕРЫ
# =============================================================================

print("\n" + "=" * 70)
print("ДРУГИЕ ПРИМЕРЫ ПЕРЕХОДА ПРИ k=3")
print("=" * 70)

print("""
┌─────────────────────────────────────────────────────────────────────────────┐
│                                                                             │
│  ЗАДАЧА                    k=2 (P)              k=3 (NP-complete)          │
│  ─────────────────────────────────────────────────────────────────────────│
│  k-SAT                     O(n)                 NP-complete                │
│  k-раскраска               O(V+E)               NP-complete                │
│  k-D matching              O(E√V)               NP-complete                │
│  k-разрезание              O(V²E)               NP-complete                │
│  k-клика                   O(V²)                NP-complete                │
│  k-независимое множество   O(V²)                NP-complete                │
│  k-доминирующее множество  O(V+E)               NP-complete                │
│  k-вершинное покрытие      O(V+E)               NP-complete                │
│  Exact Cover by k-sets     P                    NP-complete                │
│                                                                             │
│  ПАТТЕРН: 2 → P, 3 → NP-complete                                          │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
""")

# =============================================================================
# ПОЧЕМУ ИМЕННО 3?
# =============================================================================

print("\n" + "=" * 70)
print("ПОЧЕМУ ИМЕННО 3?")
print("=" * 70)

print("""
ГИПОТЕЗЫ О ПРИЧИНАХ:

1. МИНИМАЛЬНАЯ НЕЛИНЕЙНОСТЬ
   - 2 элемента: линейные отношения (a → b)
   - 3 элемента: появляется нелинейность (a, b → c)
   - 3 = минимум для нелинейной структуры

2. КОМБИНАТОРНЫЙ ВЗРЫВ
   - 2 варианта: 2ⁿ комбинаций
   - 3 варианта: 3ⁿ комбинаций
   - 3ⁿ / 2ⁿ = 1.5ⁿ → экспоненциальный рост разницы

3. СТРУКТУРА РЕШЕНИЙ
   - 2-SAT: решения образуют выпуклое множество
   - 3-SAT: решения могут быть разбросаны
   - 3 = порог невыпуклости

4. ТЕОРИЯ ГРУПП
   - S₂ (симметрическая группа): 2 элемента, абелева
   - S₃: 6 элементов, неабелева!
   - 3 = минимум для некоммутативности

5. ТОПОЛОГИЯ
   - 2 точки: всегда можно соединить
   - 3 точки: появляются узлы и переплетения
   - 3 = минимум для топологической сложности

СВЯЗЬ С ФИЗИКОЙ:
   - 3 измерения: стабильные орбиты
   - 3 кварка: конфайнмент
   - 3 поколения: CP-нарушение
   
   Возможно, 3 — фундаментальный порог сложности
   не только в CS, но и в физике!
""")

# =============================================================================
# СВЯЗЬ С TRINITY SORT
# =============================================================================

print("\n" + "=" * 70)
print("СВЯЗЬ С TRINITY SORT")
print("=" * 70)

print("""
TRINITY SORT И NP-ПОЛНОТА:

СОРТИРОВКА — задача из P:
  - O(n log n) для сравнительной сортировки
  - O(n) для специальных случаев (radix)

НО! Trinity Sort использует 3-way partition:
  - Разбиение на 3 части: <, =, >
  - Это НЕ делает задачу NP-полной
  - Наоборот, УСКОРЯЕТ решение!

ПАРАДОКС?
  Нет! Разница в том, КАК используется тройка:

  NP-полнота: 3 ВАРИАНТА ВЫБОРА
    - 3-SAT: каждый литерал может быть true/false/не выбран
    - 3-раскраска: каждая вершина может быть R/G/B
    - Комбинаторный взрыв: 3ⁿ вариантов

  Trinity Sort: 3 КАТЕГОРИИ РЕЗУЛЬТАТА
    - Каждый элемент попадает в одну из 3 категорий
    - Нет выбора — детерминированное разбиение
    - Линейное время на каждом уровне

КЛЮЧЕВОЕ РАЗЛИЧИЕ:
  NP-полнота: 3 варианта × n элементов = 3ⁿ комбинаций
  Trinity Sort: 3 категории × n элементов = 3n операций

  Выбор vs Классификация!

ВЫВОД:
  Число 3 — порог сложности для ВЫБОРА.
  Но для КЛАССИФИКАЦИИ 3 — оптимум!
""")

# =============================================================================
# ВЫВОДЫ
# =============================================================================

print("\n" + "=" * 70)
print("ВЫВОДЫ")
print("=" * 70)

print("""
ЧИСЛО 3 И NP-ПОЛНОТА:

📊 ФАКТЫ:
   - 2-SAT ∈ P, 3-SAT ∈ NP-complete
   - 2-раскраска ∈ P, 3-раскраска ∈ NP-complete
   - 2D-matching ∈ P, 3D-matching ∈ NP-complete
   - Паттерн повторяется во многих задачах!

🔬 ПРИЧИНЫ:
   - 3 = минимальная нелинейность
   - 3 = порог комбинаторного взрыва
   - 3 = минимум для некоммутативности
   - 3 = порог топологической сложности

🎯 СВЯЗЬ С TRINITY:
   - NP-полнота: 3 варианта ВЫБОРА → сложно
   - Trinity Sort: 3 категории КЛАССИФИКАЦИИ → оптимально
   - Разница: выбор vs детерминизм

💡 ГЛАВНЫЙ ИНСАЙТ:
   Число 3 — универсальный порог сложности.
   
   Для ВЫБОРА: 3 = начало NP-полноты
   Для СТРУКТУРЫ: 3 = оптимум
   
   Trinity Sort использует 3 для СТРУКТУРЫ,
   поэтому остаётся в P и даже ускоряется!

🌌 ФИЛОСОФИЯ:
   3 — граница между простым и сложным.
   Древние интуитивно это знали.
   Мы доказали это математически.
""")
