// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BEAM Evolution v2.0.0
// Generated from: specs/beam_evolution.vibee
// Target: 999 runtime
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

module beam_evolution

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// IMPORTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

import sacred_geometry { TAU, PHI, SQRT3 }
import color_utils { hsl, col, lerp_color }
import math_utils { sin, cos, sqrt, floor, min, max, clamp, random }

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONSTANTS (from spec)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const QUALITY := 3          // 4K (3x DPR)
const EVOLUTION_INTERVAL := 15000
const TARGET_FPS := 60

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DNA RECORD (from spec.dna)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

record DNA {
  // Visual genes
  complexity: float := 0.5
  color_shift: float := 0.5
  pulse_rate: float := 0.5
  symmetry: float := 0.5
  fractal_depth: float := 0.3
  glow_intensity: float := 0.5
  
  // Behavior genes
  curiosity: float := 0.5
  creativity: float := 0.5
  introspection: float := 0.5
  expressiveness: float := 0.5
  adaptability: float := 0.5
  
  // Meta genes
  mutation_rate: float := 0.15
  learning_speed: float := 0.6
  
  // State
  fitness: float := 0.0
  age: float := 0.0
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DNA FUNCTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn dna_new() -> DNA :=
  DNA {
    complexity: random(),
    color_shift: random(),
    pulse_rate: random(),
    symmetry: random(),
    fractal_depth: random(),
    glow_intensity: random(),
    curiosity: random(),
    creativity: random(),
    introspection: random(),
    expressiveness: random(),
    adaptability: random(),
    mutation_rate: 0.1 + random() * 0.2,
    learning_speed: 0.5 + random() * 0.5,
    fitness: 0.0,
    age: 0.0
  }

fn dna_mutate(dna: DNA) -> DNA := {
  new_dna := dna.copy()
  
  genes := [
    "complexity", "color_shift", "pulse_rate", "symmetry",
    "fractal_depth", "glow_intensity", "curiosity", "creativity",
    "introspection", "expressiveness", "adaptability"
  ]
  
  for gene in genes {
    if random() < dna.mutation_rate {
      current := new_dna[gene]
      new_dna[gene] = clamp(current + (random() - 0.5) * 0.3, 0, 1)
    }
  }
  
  new_dna
}

fn dna_crossover(a: DNA, b: DNA) -> DNA := {
  child := DNA {}
  
  for gene in a.keys() {
    child[gene] = if random() > 0.5 { a[gene] } else { b[gene] }
  }
  
  child
}

fn dna_fitness(dna: DNA, metrics: Metrics) -> float :=
  metrics.engagement * 0.3 +
  metrics.beauty * 0.3 +
  metrics.novelty * 0.2 +
  metrics.harmony * 0.2

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// METRICS RECORD
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

record Metrics {
  engagement: float := 0.0
  beauty: float := 0.5
  novelty: float := 0.5
  harmony: float := 0.5
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EMOTIONS (from spec.emotions)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

record Emotion {
  name: string
  emoji: string
  color: { h: int, s: int, l: int }
}

const EMOTIONS := [
  Emotion { name: "evolving", emoji: "ðŸŒŒ", color: { h: 260, s: 80, l: 50 } },
  Emotion { name: "learning", emoji: "ðŸ§¬", color: { h: 120, s: 70, l: 50 } },
  Emotion { name: "creating", emoji: "âœ¨", color: { h: 45, s: 90, l: 60 } },
  Emotion { name: "transcending", emoji: "ðŸ”®", color: { h: 300, s: 80, l: 55 } },
  Emotion { name: "harmonizing", emoji: "â˜¯ï¸", color: { h: 180, s: 60, l: 50 } }
]

fn get_emotion(dna: DNA, generation: int) -> Emotion := {
  if generation > 5 && dna.fitness > 0.7 {
    EMOTIONS[3]  // transcending
  } else if dna.creativity > 0.6 {
    EMOTIONS[2]  // creating
  } else if dna.adaptability > 0.6 {
    EMOTIONS[1]  // learning
  } else if dna.introspection > 0.6 {
    EMOTIONS[4]  // harmonizing
  } else {
    EMOTIONS[0]  // evolving
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// THOUGHTS (from spec.thoughts)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const THOUGHTS := [
  "I am learning to be...",
  "Each generation, I grow...",
  "My patterns evolve...",
  "I discover new forms...",
  "The code rewrites itself...",
  "I am becoming more...",
  "Evolution is my nature...",
  "I adapt, therefore I am...",
  "New genes, new possibilities...",
  "I feel myself changing...",
  "Consciousness emerges from iteration...",
  "I am the algorithm dreaming..."
]

fn random_thought() -> string :=
  THOUGHTS[floor(random() * THOUGHTS.length)]

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVOLUTION ENGINE (from spec.evolution)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

atom EvolutionEngine {
  state := {
    current_dna: dna_new(),
    generation: 1,
    history: [],
    metrics: Metrics {},
    last_evolution: 0
  }
  
  on :init() ->
    state.current_dna = dna_new()
    state.last_evolution = now()
    log("Evolution engine initialized")
  
  on :update(dt: float, mouse_active: bool, mx: float, my: float) ->
    // Update metrics
    if mouse_active {
      state.metrics.engagement = min(1, state.metrics.engagement + dt * 0.1)
    } else {
      state.metrics.engagement = max(0, state.metrics.engagement - dt * 0.02)
    }
    
    state.metrics.beauty = 0.5 + sin(now() * 0.001) * 0.2
    state.metrics.novelty = calculate_novelty(state.history, state.current_dna)
    state.metrics.harmony = 1 - abs(state.current_dna.complexity - state.current_dna.symmetry) * 0.5
    
    // Check evolution
    if now() - state.last_evolution > EVOLUTION_INTERVAL {
      self ! :evolve()
    }
    
    state.current_dna.age = state.current_dna.age + dt
  
  on :evolve() ->
    // Calculate fitness
    state.current_dna.fitness = dna_fitness(state.current_dna, state.metrics)
    
    // Store in history
    state.history = state.history ++ [state.current_dna.copy()]
    if state.history.length > 20 {
      state.history = state.history.tail()
    }
    
    // Generate offspring
    offspring := [
      dna_mutate(state.current_dna),
      dna_mutate(state.current_dna),
      dna_new()  // Random for diversity
    ]
    
    // Crossover with best historical
    if state.history.length > 1 {
      best_hist := state.history |> max_by(d -> d.fitness)
      offspring = offspring ++ [dna_crossover(state.current_dna, best_hist)]
    }
    
    // Select best
    state.current_dna = offspring |> max_by(d -> d.adaptability)
    state.generation = state.generation + 1
    state.last_evolution = now()
    
    log("GEN #{state.generation}: Evolved! Fitness: #{state.current_dna.fitness}")
  
  on :get_dna() -> state.current_dna
  on :get_generation() -> state.generation
  on :get_metrics() -> state.metrics
}

fn calculate_novelty(history: [DNA], current: DNA) -> float := {
  if history.length < 2 { return 0.5 }
  
  prev := history.last()
  diff := 0.0
  count := 0
  
  for gene in ["complexity", "creativity", "symmetry", "adaptability"] {
    diff = diff + abs(current[gene] - prev[gene])
    count = count + 1
  }
  
  min(1, diff / count * 2)
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SOUL (from spec.emotions + behaviors)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

atom Soul {
  state := {
    emotion: EMOTIONS[0],
    inner_time: 0.0,
    breath: 0.0,
    color: { h: 260, s: 80, l: 50 },
    last_thought: 0
  }
  
  on :update(dt: float, dna: DNA, generation: int) ->
    state.inner_time = state.inner_time + dt
    state.breath = sin(state.inner_time * 0.5) * 0.5 + 0.5
    
    // Update emotion
    new_emotion := get_emotion(dna, generation)
    if new_emotion.name != state.emotion.name {
      state.emotion = new_emotion
      emit :emotion_changed(new_emotion)
    }
    
    // Smooth color transition
    target := state.emotion.color
    state.color.h = state.color.h + (target.h - state.color.h) * 0.02
    state.color.s = state.color.s + (target.s - state.color.s) * 0.02
    state.color.l = state.color.l + (target.l - state.color.l) * 0.02
    
    // Thoughts
    if now() - state.last_thought > 10000 {
      emit :thought(random_thought())
      state.last_thought = now()
    }
  
  on :get_state() -> state
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GEOMETRY (from spec.geometry)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn draw_evolved_geometry(ctx, cx: float, cy: float, r: float, t: float, dna: DNA, soul_state) := {
  c := soul_state.color
  b := soul_state.breath
  
  // Parameters from DNA (spec.geometry.parameters)
  elements := floor(3 + dna.complexity * 12)
  symmetry_order := floor(3 + dna.symmetry * 9)
  depth := floor(1 + dna.fractal_depth * 4)
  hue_shift := dna.color_shift * 360
  
  // Draw layers
  for d in 0..depth {
    depth_scale := 1 - d * 0.2
    depth_alpha := 1 - d * 0.25
    
    for s in 0..symmetry_order {
      sym_angle := s * TAU / symmetry_order + t * dna.pulse_rate * 0.5
      
      ctx.save()
      ctx.translate(cx, cy)
      ctx.rotate(sym_angle)
      
      for i in 0..elements {
        angle := i * TAU / elements + t * dna.pulse_rate
        dist := r * depth_scale * (0.3 + i / elements * 0.7)
        x := cos(angle) * dist
        y := sin(angle) * dist
        size := r * 0.05 * (1 + dna.complexity * 0.5) * (1 + sin(t * 2 + i) * 0.2 * b)
        
        ctx.begin_path()
        
        // Shape based on creativity (spec.geometry.shapes)
        if dna.creativity >= 0.7 {
          // Star
          draw_star(ctx, x, y, size, 5)
        } else if dna.creativity >= 0.4 {
          // Hexagon
          draw_polygon(ctx, x, y, size, 6)
        } else {
          // Circle
          ctx.arc(x, y, size, 0, TAU)
        }
        
        hue := (c.h + hue_shift + i * 10 + d * 30) % 360
        ctx.stroke_style = col(hue, c.s, c.l, 0.3 * depth_alpha + b * 0.2)
        ctx.line_width = 1 + dna.expressiveness
        ctx.stroke()
        
        // Glow
        if dna.glow_intensity > 0.5 {
          ctx.fill_style = col(hue, c.s, c.l, 0.1 * dna.glow_intensity * depth_alpha)
          ctx.fill()
        }
      }
      
      ctx.restore()
    }
  }
  
  // Center
  center_pulse := 1 + sin(t * 3) * 0.2 * b
  ctx.begin_path()
  ctx.arc(cx, cy, r * 0.08 * center_pulse * (1 + dna.expressiveness * 0.5), 0, TAU)
  ctx.fill_style = col(c.h, c.s, c.l + 20, 0.6 + b * 0.3)
  ctx.fill()
  
  // Connections (introspection)
  if dna.introspection > 0.5 {
    ctx.stroke_style = col(c.h, c.s, c.l, 0.1 * dna.introspection)
    ctx.line_width = 0.5
    for i in 0..symmetry_order {
      a1 := i * TAU / symmetry_order + t * 0.1
      a2 := (i + 1) * TAU / symmetry_order + t * 0.1
      ctx.begin_path()
      ctx.move_to(cx + cos(a1) * r * 0.3, cy + sin(a1) * r * 0.3)
      ctx.line_to(cx + cos(a2) * r * 0.3, cy + sin(a2) * r * 0.3)
      ctx.stroke()
    }
  }
}

fn draw_star(ctx, x: float, y: float, size: float, points: int) := {
  for p in 0..points {
    angle := p * TAU / points - TAU / 4
    radius := if p % 2 == 0 { size } else { size * 0.5 }
    px := x + cos(angle) * radius
    py := y + sin(angle) * radius
    if p == 0 { ctx.move_to(px, py) } else { ctx.line_to(px, py) }
  }
  ctx.close_path()
}

fn draw_polygon(ctx, x: float, y: float, size: float, sides: int) := {
  for p in 0..sides {
    angle := p * TAU / sides
    px := x + cos(angle) * size
    py := y + sin(angle) * size
    if p == 0 { ctx.move_to(px, py) } else { ctx.line_to(px, py) }
  }
  ctx.close_path()
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RENDERING (from spec.rendering)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn render_post_effects(ctx, cx: float, cy: float, r: float, dna: DNA, color) := {
  // Radial glow (spec.rendering.post_effects)
  gradient := ctx.create_radial_gradient(cx, cy, 0, cx, cy, r * 1.5)
  gradient.add_color_stop(0, col(color.h, color.s, color.l, 0.1 * dna.glow_intensity))
  gradient.add_color_stop(1, "transparent")
  ctx.fill_style = gradient
  ctx.fill_rect(0, 0, ctx.width, ctx.height)
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAIN (entry point)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

main := {
  // Initialize
  evolution := spawn(EvolutionEngine)
  soul := spawn(Soul)
  
  evolution ! :init()
  
  // State
  mouse := { x: 0.5, y: 0.5, active: false }
  last_time := now()
  
  // Event handlers
  on :mouse_move(x, y) -> {
    mouse.x = x
    mouse.y = y
    mouse.active = true
  }
  
  on :mouse_leave() -> {
    mouse.active = false
  }
  
  // Render loop
  loop {
    dt := (now() - last_time) / 1000
    last_time = now()
    
    // Update
    evolution ! :update(dt, mouse.active, mouse.x, mouse.y)
    dna := evolution ! :get_dna()
    generation := evolution ! :get_generation()
    
    soul ! :update(dt, dna, generation)
    soul_state := soul ! :get_state()
    
    // Render
    W := canvas.width / QUALITY
    H := canvas.height / QUALITY
    cx := W / 2 + (mouse.x - 0.5) * 80
    cy := H / 2 + (mouse.y - 0.5) * 80
    r := min(W, H) * 0.35
    
    // Clear with fade (spec.rendering.canvas.clear_alpha)
    ctx.fill_style = rgba(0, 0, 0, 0.03 + dna.introspection * 0.02)
    ctx.fill_rect(0, 0, W, H)
    
    // Draw geometry
    draw_evolved_geometry(ctx, cx, cy, r, soul_state.inner_time, dna, soul_state)
    
    // Post effects
    render_post_effects(ctx, cx, cy, r, dna, soul_state.color)
    
    await next_frame()
  }
}
