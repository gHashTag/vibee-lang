<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>BEAM Sacred Geometry</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
    canvas{display:block;width:100vw;height:100vh;position:fixed;top:0;left:0}
    #ui{position:fixed;top:10px;left:10px;z-index:100;font:11px monospace;color:#fff;opacity:0.8}
    #ui.hidden{opacity:0}
    .btn{display:inline-block;padding:8px 12px;margin:3px;background:rgba(0,100,200,0.3);border:1px solid rgba(100,150,255,0.5);color:#fff;cursor:pointer;border-radius:20px;backdrop-filter:blur(5px)}
    .btn:hover{background:rgba(0,150,255,0.5)}
    .btn.on{background:rgba(0,200,100,0.4);border-color:rgba(100,255,150,0.7)}
    #info{position:fixed;bottom:10px;left:10px;font:10px monospace;color:rgba(255,255,255,0.4)}
    #fps{position:fixed;top:10px;right:10px;font:10px monospace;color:rgba(255,255,255,0.5)}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div style="margin-bottom:10px;font-size:14px;color:#0af">◉ Sacred Geometry</div>
  <button class="btn on" data-g="flower">Flower of Life</button>
  <button class="btn" data-g="metatron">Metatron's Cube</button>
  <button class="btn" data-g="sri">Sri Yantra</button>
  <button class="btn" data-g="torus">Torus</button>
  <button class="btn" data-g="fibonacci">Fibonacci</button>
  <button class="btn" data-g="merkaba">Merkaba</button>
  <br><br>
  <button class="btn" data-fx="glow">Glow</button>
  <button class="btn on" data-fx="pulse">Pulse</button>
  <button class="btn" data-fx="rainbow">Rainbow</button>
  <br><br>
  <button class="btn" id="hide">Hide UI [H]</button>
</div>
<div id="fps">-- FPS</div>
<div id="info">Touch/Mouse to interact | φ = 1.618033988749895</div>

<script>
// ═══════════════════════════════════════════════════════════════
// BEAM Sacred Geometry - Fullscreen Interactive
// Flower of Life, Metatron's Cube, Sri Yantra, Fibonacci Spiral
// ═══════════════════════════════════════════════════════════════

const PHI = 1.618033988749895; // Golden Ratio φ
const TAU = Math.PI * 2;
const SQRT3 = Math.sqrt(3);

// Canvas setup - FULLSCREEN
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth * devicePixelRatio;
  canvas.height = window.innerHeight * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
}
resize();
window.addEventListener('resize', resize);

// State
let geometry = 'flower';
let fx = { glow: false, pulse: true, rainbow: false };
let mx = 0.5, my = 0.5, time = 0;
let touches = [];

// ─────────────────────────────────────────────────────────────────
// SACRED GEOMETRY PATTERNS
// ─────────────────────────────────────────────────────────────────

// Flower of Life - 19 circles in hexagonal pattern
function drawFlowerOfLife(cx, cy, r, t) {
  const circles = [];
  
  // Center circle
  circles.push([cx, cy]);
  
  // First ring - 6 circles
  for (let i = 0; i < 6; i++) {
    const a = i * TAU / 6 + t * 0.1;
    circles.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
  }
  
  // Second ring - 12 circles
  for (let i = 0; i < 6; i++) {
    const a = i * TAU / 6 + t * 0.1;
    circles.push([cx + r * 2 * Math.cos(a), cy + r * 2 * Math.sin(a)]);
    const a2 = (i + 0.5) * TAU / 6 + t * 0.1;
    circles.push([cx + r * SQRT3 * Math.cos(a2), cy + r * SQRT3 * Math.sin(a2)]);
  }
  
  // Draw circles
  circles.forEach(([x, y], i) => {
    const phase = t * 2 + i * 0.3;
    const pulse = fx.pulse ? 1 + Math.sin(phase) * 0.1 : 1;
    const alpha = 0.3 + Math.sin(phase) * 0.2;
    
    ctx.beginPath();
    ctx.arc(x, y, r * pulse, 0, TAU);
    ctx.strokeStyle = getColor(i / circles.length, alpha, t);
    ctx.lineWidth = 2;
    ctx.stroke();
  });
  
  // Vesica Piscis highlights
  ctx.globalCompositeOperation = 'lighter';
  for (let i = 0; i < 6; i++) {
    const a = i * TAU / 6 + t * 0.1;
    const x = cx + r * Math.cos(a);
    const y = cy + r * Math.sin(a);
    
    ctx.beginPath();
    ctx.arc(x, y, r * 0.3, 0, TAU);
    ctx.fillStyle = `rgba(100, 200, 255, ${0.1 + Math.sin(t * 3 + i) * 0.05})`;
    ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';
}

// Metatron's Cube - 13 circles with connecting lines
function drawMetatronsCube(cx, cy, r, t) {
  const points = [[cx, cy]];
  
  // Inner hexagon
  for (let i = 0; i < 6; i++) {
    const a = i * TAU / 6 - Math.PI / 2 + t * 0.05;
    points.push([cx + r * Math.cos(a), cy + r * Math.sin(a)]);
  }
  
  // Outer hexagon
  for (let i = 0; i < 6; i++) {
    const a = i * TAU / 6 + t * 0.05;
    points.push([cx + r * 2 * Math.cos(a), cy + r * 2 * Math.sin(a)]);
  }
  
  // Connect all points
  ctx.strokeStyle = getColor(0.5, 0.15, t);
  ctx.lineWidth = 1;
  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      ctx.beginPath();
      ctx.moveTo(points[i][0], points[i][1]);
      ctx.lineTo(points[j][0], points[j][1]);
      ctx.stroke();
    }
  }
  
  // Draw circles at points
  points.forEach(([x, y], i) => {
    const phase = t * 2 + i * 0.5;
    const pulse = fx.pulse ? 1 + Math.sin(phase) * 0.15 : 1;
    
    ctx.beginPath();
    ctx.arc(x, y, r * 0.3 * pulse, 0, TAU);
    ctx.strokeStyle = getColor(i / points.length, 0.8, t);
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Glow
    if (fx.glow) {
      ctx.beginPath();
      ctx.arc(x, y, r * 0.5 * pulse, 0, TAU);
      ctx.fillStyle = getColor(i / points.length, 0.1, t);
      ctx.fill();
    }
  });
}

// Sri Yantra - 9 interlocking triangles
function drawSriYantra(cx, cy, r, t) {
  // Outer circle
  ctx.beginPath();
  ctx.arc(cx, cy, r * 1.2, 0, TAU);
  ctx.strokeStyle = getColor(0, 0.5, t);
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Lotus petals (16)
  for (let i = 0; i < 16; i++) {
    const a = i * TAU / 16 + t * 0.02;
    const x1 = cx + r * 1.1 * Math.cos(a);
    const y1 = cy + r * 1.1 * Math.sin(a);
    const x2 = cx + r * 1.3 * Math.cos(a - 0.1);
    const y2 = cy + r * 1.3 * Math.sin(a - 0.1);
    const x3 = cx + r * 1.3 * Math.cos(a + 0.1);
    const y3 = cy + r * 1.3 * Math.sin(a + 0.1);
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    ctx.strokeStyle = getColor(i / 16, 0.4, t);
    ctx.stroke();
  }
  
  // 9 interlocking triangles (4 up, 5 down)
  const triangles = [
    // Upward triangles (Shiva - masculine)
    { dir: 1, scale: 1.0, offset: 0 },
    { dir: 1, scale: 0.7, offset: 0.05 },
    { dir: 1, scale: 0.45, offset: 0.08 },
    { dir: 1, scale: 0.25, offset: 0.1 },
    // Downward triangles (Shakti - feminine)
    { dir: -1, scale: 0.9, offset: 0.02 },
    { dir: -1, scale: 0.65, offset: 0.06 },
    { dir: -1, scale: 0.4, offset: 0.09 },
    { dir: -1, scale: 0.2, offset: 0.11 },
    { dir: -1, scale: 0.08, offset: 0.12 }
  ];
  
  triangles.forEach((tri, i) => {
    const phase = t + i * 0.2;
    const pulse = fx.pulse ? 1 + Math.sin(phase) * 0.05 : 1;
    const s = r * tri.scale * pulse;
    const rot = t * 0.01 * tri.dir;
    
    ctx.beginPath();
    for (let j = 0; j < 3; j++) {
      const a = j * TAU / 3 + (tri.dir > 0 ? -Math.PI / 2 : Math.PI / 2) + rot;
      const x = cx + s * Math.cos(a);
      const y = cy + s * Math.sin(a) * tri.dir + tri.offset * r * tri.dir;
      if (j === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.strokeStyle = getColor(tri.dir > 0 ? 0.1 : 0.6, 0.6, t);
    ctx.lineWidth = 1.5;
    ctx.stroke();
  });
  
  // Bindu (center point)
  const binduPulse = fx.pulse ? 1 + Math.sin(t * 3) * 0.3 : 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r * 0.03 * binduPulse, 0, TAU);
  ctx.fillStyle = getColor(0.5, 1, t);
  ctx.fill();
}

// Torus / Donut field
function drawTorus(cx, cy, r, t) {
  const rings = 12;
  const points = 36;
  
  for (let i = 0; i < rings; i++) {
    const ringPhase = i / rings * TAU + t * 0.5;
    const ringR = r * (0.3 + Math.sin(ringPhase) * 0.7);
    const ringY = r * Math.cos(ringPhase) * 0.3;
    
    ctx.beginPath();
    for (let j = 0; j <= points; j++) {
      const a = j / points * TAU;
      const x = cx + ringR * Math.cos(a);
      const y = cy + ringY + ringR * Math.sin(a) * 0.3;
      
      if (j === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = getColor(i / rings, 0.4 + Math.sin(ringPhase) * 0.2, t);
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  
  // Vertical flow lines
  for (let i = 0; i < 24; i++) {
    const a = i / 24 * TAU + t * 0.2;
    ctx.beginPath();
    for (let j = 0; j <= 20; j++) {
      const p = j / 20 * TAU;
      const flowR = r * (0.3 + Math.sin(p) * 0.7);
      const x = cx + flowR * Math.cos(a);
      const y = cy + r * Math.cos(p) * 0.3 + flowR * Math.sin(a) * 0.3;
      
      if (j === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.strokeStyle = getColor(i / 24, 0.2, t);
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

// Fibonacci / Golden Spiral
function drawFibonacci(cx, cy, r, t) {
  // Golden rectangles
  let x = cx, y = cy;
  let w = r * 0.1, h = w * PHI;
  
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(t * 0.1);
  ctx.translate(-cx, -cy);
  
  for (let i = 0; i < 12; i++) {
    const phase = t + i * 0.3;
    const alpha = 0.3 + Math.sin(phase) * 0.2;
    
    ctx.strokeStyle = getColor(i / 12, alpha, t);
    ctx.lineWidth = 1;
    ctx.strokeRect(x - w/2, y - h/2, w, h);
    
    // Spiral arc
    ctx.beginPath();
    const startAngle = -Math.PI / 2 + i * Math.PI / 2;
    ctx.arc(x + (i % 2 === 0 ? w/2 : -w/2), 
            y + (i % 4 < 2 ? h/2 : -h/2), 
            Math.min(w, h), 
            startAngle, 
            startAngle + Math.PI / 2);
    ctx.strokeStyle = getColor(i / 12, 0.8, t);
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Next rectangle
    const temp = w;
    w = h;
    h = temp + h;
    
    // Position adjustment
    if (i % 4 === 0) x += temp / 2;
    else if (i % 4 === 1) y += temp / 2;
    else if (i % 4 === 2) x -= temp / 2;
    else y -= temp / 2;
  }
  
  ctx.restore();
  
  // Phi symbol
  ctx.font = '20px serif';
  ctx.fillStyle = getColor(0.5, 0.5, t);
  ctx.fillText('φ = ' + PHI.toFixed(10), 20, window.innerHeight - 40);
}

// Merkaba - Star Tetrahedron
function drawMerkaba(cx, cy, r, t) {
  const rot = t * 0.3;
  
  // Two interlocking tetrahedra
  for (let tet = 0; tet < 2; tet++) {
    const dir = tet === 0 ? 1 : -1;
    const tetRot = rot * dir;
    
    // 3D projection of tetrahedron
    const vertices = [];
    for (let i = 0; i < 3; i++) {
      const a = i * TAU / 3 + tetRot + (tet === 0 ? 0 : Math.PI / 3);
      vertices.push([
        cx + r * Math.cos(a),
        cy + r * Math.sin(a) * 0.5 + r * 0.3 * dir
      ]);
    }
    // Apex
    vertices.push([cx, cy - r * 0.6 * dir]);
    
    // Draw edges
    const edges = [[0,1], [1,2], [2,0], [0,3], [1,3], [2,3]];
    edges.forEach(([a, b], i) => {
      const phase = t * 2 + i * 0.5 + tet * Math.PI;
      ctx.beginPath();
      ctx.moveTo(vertices[a][0], vertices[a][1]);
      ctx.lineTo(vertices[b][0], vertices[b][1]);
      ctx.strokeStyle = getColor(tet === 0 ? 0.6 : 0.1, 0.6 + Math.sin(phase) * 0.2, t);
      ctx.lineWidth = 2;
      ctx.stroke();
    });
    
    // Vertices glow
    if (fx.glow) {
      vertices.forEach(([x, y], i) => {
        const phase = t * 3 + i;
        ctx.beginPath();
        ctx.arc(x, y, r * 0.08 * (1 + Math.sin(phase) * 0.3), 0, TAU);
        ctx.fillStyle = getColor(tet === 0 ? 0.6 : 0.1, 0.3, t);
        ctx.fill();
      });
    }
  }
  
  // Central sphere
  const spherePulse = fx.pulse ? 1 + Math.sin(t * 2) * 0.2 : 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r * 0.15 * spherePulse, 0, TAU);
  ctx.fillStyle = getColor(0.5, 0.4, t);
  ctx.fill();
}

// ─────────────────────────────────────────────────────────────────
// COLOR FUNCTIONS
// ─────────────────────────────────────────────────────────────────

function getColor(hue, alpha, t) {
  if (fx.rainbow) {
    hue = (hue + t * 0.1) % 1;
  }
  const h = hue * 360;
  const s = 70;
  const l = 60;
  return `hsla(${h}, ${s}%, ${l}%, ${alpha})`;
}

// ─────────────────────────────────────────────────────────────────
// INTERACTION
// ─────────────────────────────────────────────────────────────────

function handleMove(x, y) {
  mx = x / window.innerWidth;
  my = y / window.innerHeight;
}

canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  handleMove(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

canvas.addEventListener('click', () => {
  const geos = ['flower', 'metatron', 'sri', 'torus', 'fibonacci', 'merkaba'];
  const idx = (geos.indexOf(geometry) + 1) % geos.length;
  geometry = geos[idx];
  updateButtons();
});

// UI
document.querySelectorAll('[data-g]').forEach(btn => {
  btn.addEventListener('click', e => {
    e.stopPropagation();
    geometry = btn.dataset.g;
    updateButtons();
  });
});

document.querySelectorAll('[data-fx]').forEach(btn => {
  btn.addEventListener('click', e => {
    e.stopPropagation();
    fx[btn.dataset.fx] = !fx[btn.dataset.fx];
    btn.classList.toggle('on');
  });
});

document.getElementById('hide').addEventListener('click', e => {
  e.stopPropagation();
  document.getElementById('ui').classList.toggle('hidden');
});

document.addEventListener('keydown', e => {
  if (e.key === 'h' || e.key === 'H') {
    document.getElementById('ui').classList.toggle('hidden');
  }
  if (e.key === ' ') {
    e.preventDefault();
    const geos = ['flower', 'metatron', 'sri', 'torus', 'fibonacci', 'merkaba'];
    const idx = (geos.indexOf(geometry) + 1) % geos.length;
    geometry = geos[idx];
    updateButtons();
  }
});

function updateButtons() {
  document.querySelectorAll('[data-g]').forEach(btn => {
    btn.classList.toggle('on', btn.dataset.g === geometry);
  });
}

// ─────────────────────────────────────────────────────────────────
// RENDER LOOP
// ─────────────────────────────────────────────────────────────────

let lastTime = performance.now();
let frameCount = 0, fpsTime = 0;

function render() {
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;
  time += dt;
  
  // FPS
  frameCount++;
  fpsTime += dt;
  if (fpsTime >= 1) {
    document.getElementById('fps').textContent = frameCount + ' FPS';
    frameCount = 0;
    fpsTime = 0;
  }
  
  const W = window.innerWidth;
  const H = window.innerHeight;
  const cx = W / 2 + (mx - 0.5) * 100;
  const cy = H / 2 + (my - 0.5) * 100;
  const r = Math.min(W, H) * 0.35;
  
  // Clear with fade
  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
  ctx.fillRect(0, 0, W, H);
  
  // Draw geometry
  switch (geometry) {
    case 'flower': drawFlowerOfLife(cx, cy, r * 0.2, time); break;
    case 'metatron': drawMetatronsCube(cx, cy, r * 0.4, time); break;
    case 'sri': drawSriYantra(cx, cy, r * 0.8, time); break;
    case 'torus': drawTorus(cx, cy, r, time); break;
    case 'fibonacci': drawFibonacci(cx, cy, r, time); break;
    case 'merkaba': drawMerkaba(cx, cy, r * 0.8, time); break;
  }
  
  // Glow effect
  if (fx.glow) {
    ctx.globalCompositeOperation = 'lighter';
    ctx.filter = 'blur(10px)';
    ctx.globalAlpha = 0.3;
    switch (geometry) {
      case 'flower': drawFlowerOfLife(cx, cy, r * 0.2, time); break;
      case 'metatron': drawMetatronsCube(cx, cy, r * 0.4, time); break;
      case 'sri': drawSriYantra(cx, cy, r * 0.8, time); break;
      case 'torus': drawTorus(cx, cy, r, time); break;
      case 'fibonacci': drawFibonacci(cx, cy, r, time); break;
      case 'merkaba': drawMerkaba(cx, cy, r * 0.8, time); break;
    }
    ctx.globalAlpha = 1;
    ctx.filter = 'none';
    ctx.globalCompositeOperation = 'source-over';
  }
  
  requestAnimationFrame(render);
}

render();
console.log('BEAM Sacred Geometry');
console.log('φ (Golden Ratio) =', PHI);
</script>
</body>
</html>
