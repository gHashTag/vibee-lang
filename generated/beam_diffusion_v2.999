// ═══════════════════════════════════════════════════════════════
// BEAM Pixel Diffusion v2 - Flow Matching + Rectified Flow
// Based on: FLUX (Black Forest Labs), SD3 (Stability AI)
// ═══════════════════════════════════════════════════════════════
// Key innovations:
// 1. Rectified Flow - straight paths from noise to data
// 2. Optimal Transport - efficient interpolation
// 3. SDF-based shapes (Inigo Quilez techniques)
// 4. Multi-scale wave interference
// ═══════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────
// CONSTANTS
// ─────────────────────────────────────────────────────────────────

const PI := 3.14159265359
const TAU := 6.28318530718
const SQRT2 := 1.41421356237
const PHI := 1.61803398875  // Golden ratio

// ─────────────────────────────────────────────────────────────────
// EMOTIONAL LATENT SPACE (Extended)
// ─────────────────────────────────────────────────────────────────

emotion joy := { 
  color: [1.0, 0.8, 0.2],
  frequency: 1.2,
  amplitude: 1.0,
  turbulence: 0.3
}

emotion calm := { 
  color: [0.2, 0.5, 0.9],
  frequency: 0.6,
  amplitude: 0.7,
  turbulence: 0.1
}

emotion energy := { 
  color: [1.0, 0.3, 0.1],
  frequency: 2.0,
  amplitude: 1.5,
  turbulence: 0.8
}

emotion mystery := { 
  color: [0.5, 0.2, 0.8],
  frequency: 0.8,
  amplitude: 0.9,
  turbulence: 0.5
}

emotion nature := { 
  color: [0.2, 0.8, 0.3],
  frequency: 1.0,
  amplitude: 0.8,
  turbulence: 0.4
}

emotion cosmic := {
  color: [0.1, 0.1, 0.3],
  frequency: 0.4,
  amplitude: 1.2,
  turbulence: 0.6
}

emotion fire := {
  color: [1.0, 0.4, 0.0],
  frequency: 3.0,
  amplitude: 2.0,
  turbulence: 1.0
}

// ─────────────────────────────────────────────────────────────────
// SDF PRIMITIVES (Inigo Quilez)
// https://iquilezles.org/articles/distfunctions2d/
// ─────────────────────────────────────────────────────────────────

fn sdCircle(px, py, r) := 
  sqrt(px*px + py*py) - r

fn sdBox(px, py, bx, by) := {
  dx := abs(px) - bx
  dy := abs(py) - by
  sqrt(max(dx,0)^2 + max(dy,0)^2) + min(max(dx,dy), 0)
}

fn sdRoundedBox(px, py, bx, by, r) :=
  sdBox(px, py, bx-r, by-r) - r

fn sdHexagon(px, py, r) := {
  kx := -0.866025404  // cos(60°)
  ky := 0.5           // sin(60°)
  kz := 0.577350269   // tan(30°)
  
  px = abs(px)
  py = abs(py)
  
  // Reflect across hexagon edges
  dot1 := 2 * min(kx*px + ky*py, 0)
  px = px - dot1 * kx
  py = py - dot1 * ky
  
  px = px - clamp(px, -kz*r, kz*r)
  py = py - r
  
  sqrt(px*px + py*py) * sign(py)
}

fn sdStar(px, py, r, n, m) := {
  // n = number of points, m = inner radius ratio
  an := PI / n
  en := PI / m
  
  acs := [cos(an), sin(an)]
  ecs := [cos(en), sin(en)]
  
  bn := mod(atan2(px, py), 2*an) - an
  len := sqrt(px*px + py*py)
  px = len * cos(bn)
  py = abs(len * sin(bn))
  
  px = px - r * acs[0]
  py = py - r * acs[1]
  
  k := clamp(-dot([px,py], ecs), 0, r * acs[1] / ecs[1])
  px = px + ecs[0] * k
  py = py + ecs[1] * k
  
  sqrt(px*px + py*py) * sign(px)
}

fn sdHeart(px, py) := {
  px = abs(px)
  
  if px + py > 1.0 {
    sqrt((px-0.25)^2 + (py-0.75)^2) - SQRT2/4
  } else {
    d1 := px*px + (py-1)^2
    k := max(px + py, 0) * 0.5
    d2 := (px-k)^2 + (py-k)^2
    sqrt(min(d1, d2)) * sign(px - py)
  }
}

// Smooth operations
fn opSmoothUnion(d1, d2, k) := {
  h := clamp(0.5 + 0.5*(d2-d1)/k, 0, 1)
  mix(d2, d1, h) - k*h*(1-h)
}

fn opSmoothSubtraction(d1, d2, k) := {
  h := clamp(0.5 - 0.5*(d2+d1)/k, 0, 1)
  mix(d2, -d1, h) + k*h*(1-h)
}

// ─────────────────────────────────────────────────────────────────
// FLOW MATCHING (Meta AI Research)
// https://arxiv.org/abs/2210.02747
// ─────────────────────────────────────────────────────────────────

// Rectified Flow: straight line from noise to data
// x_t = (1-t)*x_0 + t*x_1 where x_0=noise, x_1=target
fn rectifiedFlow(noise, target, t) := {
  // Linear interpolation (OT displacement)
  (1 - t) * noise + t * target
}

// Velocity field for rectified flow
// v(x,t) = (x_1 - x_0) = target - noise
fn flowVelocity(noise, target) :=
  target - noise

// Optimal Transport path (more efficient than diffusion)
fn optimalTransportPath(x0, x1, t) := {
  // Straight line in latent space
  x0 + t * (x1 - x0)
}

// ─────────────────────────────────────────────────────────────────
// NOISE FUNCTIONS (Improved)
// ─────────────────────────────────────────────────────────────────

// Hash function for noise
fn hash(x, y) := {
  p := fract(x * 0.3183099 + y * 0.1)
  p = p * 17.0
  fract(p * (p + 33.33))
}

// Value noise
fn valueNoise(x, y) := {
  i := floor(x)
  j := floor(y)
  f := fract(x)
  g := fract(y)
  
  // Smoothstep
  u := f * f * (3 - 2*f)
  v := g * g * (3 - 2*g)
  
  // Four corners
  a := hash(i, j)
  b := hash(i+1, j)
  c := hash(i, j+1)
  d := hash(i+1, j+1)
  
  // Bilinear interpolation
  mix(mix(a, b, u), mix(c, d, u), v)
}

// Fractal Brownian Motion (FBM)
fn fbm(x, y, octaves) := {
  value := 0
  amplitude := 0.5
  frequency := 1.0
  
  for i in 0..octaves {
    value = value + amplitude * valueNoise(x*frequency, y*frequency)
    amplitude = amplitude * 0.5
    frequency = frequency * 2.0
  }
  
  value
}

// Curl noise for fluid-like motion
fn curlNoise(x, y, t) := {
  eps := 0.01
  
  // Partial derivatives
  dx := (fbm(x+eps, y, 4) - fbm(x-eps, y, 4)) / (2*eps)
  dy := (fbm(x, y+eps, 4) - fbm(x, y-eps, 4)) / (2*eps)
  
  // Curl: perpendicular to gradient
  [-dy, dx]
}

// ─────────────────────────────────────────────────────────────────
// PIXEL PROCESS v2 (Enhanced OTP Actor)
// ─────────────────────────────────────────────────────────────────

atom PixelProcessV2 {
  state := {
    x: 0,
    y: 0,
    // RGB in [0,1]
    r: 0.5, g: 0.5, b: 0.5,
    // Flow state
    noise_r: 0, noise_g: 0, noise_b: 0,
    target_r: 0, target_g: 0, target_b: 0,
    flow_t: 0,  // Flow time [0,1]
    // Wave state
    phase: 0,
    frequency: 0.1,
    // SDF state
    sdf_value: 0,
    // Alive for fault tolerance
    alive: true
  }
  
  on :init(pos_x, pos_y, width, height) ->
    state.x = pos_x
    state.y = pos_y
    // Normalized coordinates [-1, 1]
    state.nx = (pos_x / width) * 2 - 1
    state.ny = (pos_y / height) * 2 - 1
    // Initialize with noise
    state.noise_r = random()
    state.noise_g = random()
    state.noise_b = random()
    state.phase = random() * TAU
    state.frequency = 0.05 + random() * 0.1
    
  on :tick(dt, time, emotion, cursor, sdf_mode) ->
    // 1. Calculate SDF for current shape
    sdf := match sdf_mode {
      "circle" -> sdCircle(state.nx - cursor.nx, state.ny - cursor.ny, 0.3)
      "box" -> sdBox(state.nx, state.ny, 0.4, 0.3)
      "hexagon" -> sdHexagon(state.nx, state.ny, 0.4)
      "star" -> sdStar(state.nx, state.ny, 0.4, 5, 2.5)
      "heart" -> sdHeart(state.nx, state.ny * 1.2 + 0.3)
      _ -> sdCircle(state.nx, state.ny, 0.5)
    }
    state.sdf_value = sdf
    
    // 2. Cursor influence (Classifier-Free Guidance)
    dx := state.nx - cursor.nx
    dy := state.ny - cursor.ny
    dist := sqrt(dx*dx + dy*dy)
    guidance := exp(-dist*dist * 4) * cursor.strength
    
    // 3. Calculate target color from emotion + SDF
    // Inside shape: emotion color
    // Outside: complementary/dark
    inside := sdf < 0
    edge := abs(sdf) < 0.05
    
    if inside {
      state.target_r = emotion.color[0]
      state.target_g = emotion.color[1]
      state.target_b = emotion.color[2]
    } else {
      // Gradient falloff
      falloff := exp(-sdf * 3)
      state.target_r = emotion.color[0] * falloff * 0.3
      state.target_g = emotion.color[1] * falloff * 0.3
      state.target_b = emotion.color[2] * falloff * 0.3
    }
    
    // Edge glow
    if edge {
      glow := 1 - abs(sdf) / 0.05
      state.target_r = state.target_r + glow * 0.5
      state.target_g = state.target_g + glow * 0.5
      state.target_b = state.target_b + glow * 0.5
    }
    
    // 4. Wave modulation
    wave := sin(
      state.frequency * sqrt(state.x*state.x + state.y*state.y) * 0.1 +
      time * emotion.frequency +
      state.phase
    )
    
    // Add harmonics
    wave2 := 0.5 * sin(state.frequency * 2 * dist * 10 + time * 1.7)
    wave3 := 0.3 * sin(state.frequency * 3 * dist * 10 + time * 2.3)
    total_wave := (wave + wave2 + wave3) * emotion.amplitude
    
    // 5. Apply turbulence via curl noise
    curl := curlNoise(state.nx * 3, state.ny * 3, time * 0.1)
    turb := emotion.turbulence * 0.1
    state.target_r = state.target_r + curl[0] * turb
    state.target_g = state.target_g + curl[1] * turb
    state.target_b = state.target_b + (curl[0] + curl[1]) * turb * 0.5
    
    // 6. Flow Matching: interpolate from noise to target
    // Rectified flow with guidance boost
    flow_speed := 0.02 * (1 + guidance * 2)
    state.flow_t = min(1, state.flow_t + flow_speed)
    
    // Optimal transport interpolation
    state.r = rectifiedFlow(state.noise_r, state.target_r, state.flow_t)
    state.g = rectifiedFlow(state.noise_g, state.target_g, state.flow_t)
    state.b = rectifiedFlow(state.noise_b, state.target_b, state.flow_t)
    
    // 7. Add wave interference to final color
    wave_influence := 0.15 * (1 - state.flow_t)  // Decreases as flow completes
    state.r = state.r + total_wave * wave_influence
    state.g = state.g + total_wave * wave_influence * 0.8
    state.b = state.b + total_wave * wave_influence * 0.6
    
    // 8. Phase evolution
    state.phase = state.phase + dt * state.frequency * (1 + guidance)
    
  on :reset_flow() ->
    // Reset to noise state (like adding noise in diffusion)
    state.noise_r = random()
    state.noise_g = random()
    state.noise_b = random()
    state.flow_t = 0
    
  on :get_color() ->
    [
      clamp(state.r, 0, 1),
      clamp(state.g, 0, 1),
      clamp(state.b, 0, 1),
      1.0
    ]
    
  on :get_sdf() ->
    state.sdf_value
}

// ─────────────────────────────────────────────────────────────────
// DIFFUSION SUPERVISOR v2
// ─────────────────────────────────────────────────────────────────

atom DiffusionSupervisorV2 {
  state := {
    width: 0,
    height: 0,
    pixels: [],
    time: 0,
    emotion: joy,
    cursor: { nx: 0, ny: 0, strength: 0.5 },
    sdf_mode: "circle",
    running: true
  }
  
  on :start(width, height) ->
    state.width = width
    state.height = height
    
    // Spawn pixel grid
    for y in 0..height {
      row := []
      for x in 0..width {
        pixel := spawn(PixelProcessV2)
        pixel ! :init(x, y, width, height)
        row = row ++ [pixel]
      }
      state.pixels = state.pixels ++ [row]
    }
    
    log("BEAM Diffusion v2: #{width}x#{height} = #{width*height} processes")
    log("Using: Flow Matching + Rectified Flow + SDF")
    
  on :tick(dt) ->
    state.time = state.time + dt
    
    // Update all pixels
    for y in 0..state.height {
      for x in 0..state.width {
        state.pixels[y][x] ! :tick(
          dt,
          state.time,
          state.emotion,
          state.cursor,
          state.sdf_mode
        )
      }
    }
    
  on :set_emotion(name) ->
    state.emotion = match name {
      "joy" -> joy
      "calm" -> calm
      "energy" -> energy
      "mystery" -> mystery
      "nature" -> nature
      "cosmic" -> cosmic
      "fire" -> fire
      _ -> joy
    }
    // Reset flow for new emotion
    for row in state.pixels {
      for pixel in row {
        pixel ! :reset_flow()
      }
    }
    
  on :set_shape(shape) ->
    state.sdf_mode = shape
    // Reset flow for new shape
    for row in state.pixels {
      for pixel in row {
        pixel ! :reset_flow()
      }
    }
    
  on :cursor_move(nx, ny) ->
    state.cursor.nx = nx * 2 - 1  // Convert to [-1, 1]
    state.cursor.ny = ny * 2 - 1
    
  on :cursor_strength(s) ->
    state.cursor.strength = s
    
  on :get_image(image_data) ->
    for y in 0..state.height {
      for x in 0..state.width {
        color := state.pixels[y][x] ! :get_color()
        idx := (y * state.width + x) * 4
        
        // ACES tone mapping
        color = aces_tonemap(color)
        
        image_data[idx + 0] = floor(color[0] * 255)
        image_data[idx + 1] = floor(color[1] * 255)
        image_data[idx + 2] = floor(color[2] * 255)
        image_data[idx + 3] = 255
      }
    }
    image_data
}

// ─────────────────────────────────────────────────────────────────
// HELPER FUNCTIONS
// ─────────────────────────────────────────────────────────────────

fn clamp(x, min_val, max_val) := max(min_val, min(max_val, x))
fn mix(a, b, t) := a + (b - a) * t
fn fract(x) := x - floor(x)
fn mod(x, y) := x - y * floor(x / y)
fn sign(x) := if x > 0 { 1 } else if x < 0 { -1 } else { 0 }
fn dot(a, b) := a[0]*b[0] + a[1]*b[1]

fn aces_tonemap(color) := {
  a := 2.51
  b := 0.03
  c := 2.43
  d := 0.59
  e := 0.14
  
  [
    clamp((color[0]*(a*color[0]+b))/(color[0]*(c*color[0]+d)+e), 0, 1),
    clamp((color[1]*(a*color[1]+b))/(color[1]*(c*color[1]+d)+e), 0, 1),
    clamp((color[2]*(a*color[2]+b))/(color[2]*(c*color[2]+d)+e), 0, 1)
  ]
}

// ─────────────────────────────────────────────────────────────────
// ENTRY POINT
// ─────────────────────────────────────────────────────────────────

main := {
  supervisor := spawn(DiffusionSupervisorV2)
  supervisor ! :start(128, 128)
  
  loop {
    supervisor ! :tick(1/60)
    image := supervisor ! :get_image(canvas_data)
    render(image)
    await next_frame()
  }
}
