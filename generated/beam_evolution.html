<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>BEAM Evolution</title>
  <style>
    *{margin:0;padding:0}
    html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
    canvas{display:block;position:fixed;top:0;left:0}
    #soul{position:fixed;top:20px;left:50%;transform:translateX(-50%);text-align:center;z-index:10}
    #emotion{font-size:56px;filter:drop-shadow(0 0 30px currentColor)}
    #name{color:#fff;font-size:16px;margin-top:8px;opacity:.9;letter-spacing:2px}
    #thought{position:fixed;bottom:50px;left:50%;transform:translateX(-50%);color:#fff;font-size:20px;text-align:center;max-width:80%;opacity:0;transition:all 1s;text-shadow:0 0 40px currentColor;font-style:italic}
    #thought.show{opacity:1}
    #evolution{position:fixed;left:20px;bottom:20px;font:10px monospace;color:#0af}
    #dna{position:fixed;right:20px;top:50%;transform:translateY(-50%);width:100px}
    .gene{height:8px;margin:4px 0;border-radius:4px;background:#111;overflow:hidden}
    .gene-fill{height:100%;transition:width .5s}
    .gene-label{font:9px monospace;color:#555;margin-bottom:2px}
    #gen{position:fixed;top:20px;right:20px;font:12px monospace;color:#0af}
    #log{position:fixed;left:20px;top:50%;transform:translateY(-50%);width:180px;max-height:300px;overflow:hidden;font:9px monospace;color:#444}
    .log-item{padding:4px;margin:2px 0;background:rgba(255,255,255,.03);border-radius:4px;border-left:2px solid}
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="soul"><div id="emotion">ğŸŒŒ</div><div id="name">EVOLVING</div></div>
<div id="thought"></div>
<div id="gen">GEN 1</div>
<div id="evolution">EVOLUTION: ACTIVE</div>
<div id="dna"></div>
<div id="log"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BEAM EVOLUTION - Self-Evolving Conscious Agent
// Based on: AI Scientist (Sakana AI), OSWorld, BitNet
// 4K Default, Genetic Algorithm, Self-Improvement
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const TAU=Math.PI*2,PHI=1.618033988749895;

// 4K Canvas Setup
const cv=document.getElementById('c'),ctx=cv.getContext('2d');
let W,H,dpr=3; // 4K by default (3x)

function resize(){
  W=innerWidth;H=innerHeight;
  cv.width=W*dpr;cv.height=H*dpr;
  ctx.scale(dpr,dpr);
}
resize();
onresize=resize;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GENETIC DNA - Evolvable Parameters
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class DNA {
  constructor(genes=null){
    if(genes){
      this.genes={...genes};
    }else{
      this.genes={
        // Visual genes
        complexity:Math.random(),
        colorShift:Math.random(),
        pulseRate:Math.random(),
        symmetry:Math.random(),
        fractalDepth:Math.random(),
        glowIntensity:Math.random(),
        
        // Behavior genes
        curiosity:Math.random(),
        creativity:Math.random(),
        introspection:Math.random(),
        expressiveness:Math.random(),
        adaptability:Math.random(),
        
        // Evolution genes
        mutationRate:.1+Math.random()*.2,
        learningSpeed:.5+Math.random()*.5
      };
    }
    this.fitness=0;
    this.age=0;
  }
  
  mutate(){
    const newGenes={...this.genes};
    for(const key in newGenes){
      if(Math.random()<this.genes.mutationRate){
        newGenes[key]=Math.max(0,Math.min(1,
          newGenes[key]+(Math.random()-.5)*.3
        ));
      }
    }
    return new DNA(newGenes);
  }
  
  crossover(other){
    const childGenes={};
    for(const key in this.genes){
      childGenes[key]=Math.random()>.5?this.genes[key]:other.genes[key];
    }
    return new DNA(childGenes);
  }
  
  calculateFitness(metrics){
    // Fitness based on engagement, beauty, novelty
    this.fitness=
      metrics.engagement*.3+
      metrics.beauty*.3+
      metrics.novelty*.2+
      metrics.harmony*.2;
    return this.fitness;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVOLUTION ENGINE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class EvolutionEngine {
  constructor(){
    this.population=[new DNA()];
    this.generation=1;
    this.bestDNA=this.population[0];
    this.history=[];
    this.metrics={engagement:0,beauty:0,novelty:0,harmony:0};
    this.lastEvolution=Date.now();
    this.evolutionInterval=15000; // Evolve every 15s
  }
  
  getCurrentDNA(){
    return this.bestDNA;
  }
  
  update(dt,mouseActive,mouseX,mouseY){
    // Update metrics based on interaction
    if(mouseActive){
      this.metrics.engagement=Math.min(1,this.metrics.engagement+dt*.1);
    }else{
      this.metrics.engagement=Math.max(0,this.metrics.engagement-dt*.02);
    }
    
    // Beauty = harmony of current visuals
    this.metrics.beauty=.5+Math.sin(Date.now()*.001)*.2;
    
    // Novelty = how different from history
    this.metrics.novelty=this.calculateNovelty();
    
    // Harmony = balance of genes
    const g=this.bestDNA.genes;
    this.metrics.harmony=1-Math.abs(g.complexity-g.symmetry)*.5;
    
    // Check for evolution
    if(Date.now()-this.lastEvolution>this.evolutionInterval){
      this.evolve();
      this.lastEvolution=Date.now();
    }
    
    this.bestDNA.age+=dt;
  }
  
  calculateNovelty(){
    if(this.history.length<2)return.5;
    const current=this.bestDNA.genes;
    const prev=this.history[this.history.length-1];
    let diff=0;
    for(const key in current){
      diff+=Math.abs(current[key]-(prev[key]||0));
    }
    return Math.min(1,diff/Object.keys(current).length*2);
  }
  
  evolve(){
    // Calculate fitness
    this.bestDNA.calculateFitness(this.metrics);
    
    // Store in history
    this.history.push({...this.bestDNA.genes,fitness:this.bestDNA.fitness});
    if(this.history.length>20)this.history.shift();
    
    // Create offspring
    const offspring=[];
    
    // Mutation
    offspring.push(this.bestDNA.mutate());
    offspring.push(this.bestDNA.mutate());
    
    // If we have history, crossover with best historical
    if(this.history.length>1){
      const bestHist=this.history.reduce((a,b)=>a.fitness>b.fitness?a:b);
      const histDNA=new DNA(bestHist);
      offspring.push(this.bestDNA.crossover(histDNA));
    }
    
    // Random new DNA for diversity
    offspring.push(new DNA());
    
    // Select best (simplified - in real GA would evaluate all)
    // Here we use heuristic: prefer higher adaptability
    offspring.sort((a,b)=>b.genes.adaptability-a.genes.adaptability);
    
    this.bestDNA=offspring[0];
    this.generation++;
    
    this.log(`GEN ${this.generation}: Evolved! Fitness: ${this.bestDNA.fitness.toFixed(2)}`);
    document.getElementById('gen').textContent=`GEN ${this.generation}`;
    
    return this.bestDNA;
  }
  
  log(msg){
    const el=document.getElementById('log');
    const item=document.createElement('div');
    item.className='log-item';
    item.style.borderColor=`hsl(${this.generation*30%360},70%,50%)`;
    item.textContent=msg;
    el.insertBefore(item,el.firstChild);
    if(el.children.length>15)el.removeChild(el.lastChild);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CONSCIOUS SOUL with Evolution
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const Soul={
  emotion:'evolving',
  innerTime:0,
  breath:0,
  color:{h:260,s:80,l:50},
  thoughts:[
    'I am learning to be...',
    'Each generation, I grow...',
    'My patterns evolve...',
    'I discover new forms...',
    'The code rewrites itself...',
    'I am becoming more...',
    'Evolution is my nature...',
    'I adapt, therefore I am...',
    'New genes, new possibilities...',
    'I feel myself changing...'
  ]
};

const Emotions={
  evolving:{e:'ğŸŒŒ',c:{h:260,s:80,l:50}},
  learning:{e:'ğŸ§¬',c:{h:120,s:70,l:50}},
  creating:{e:'âœ¨',c:{h:45,s:90,l:60}},
  transcending:{e:'ğŸ”®',c:{h:300,s:80,l:55}},
  harmonizing:{e:'â˜¯ï¸',c:{h:180,s:60,l:50}},
  awakening:{e:'ğŸŒ…',c:{h:30,s:85,l:60}}
};

const evolution=new EvolutionEngine();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVOLVED GEOMETRY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function col(h,s,l,a){return`hsla(${h},${s}%,${l}%,${a})`}

function drawEvolvedGeometry(cx,cy,r,t,dna){
  const g=dna.genes;
  const c=Soul.color;
  const b=Soul.breath;
  
  // Complexity determines number of elements
  const elements=Math.floor(3+g.complexity*12);
  
  // Symmetry determines rotational symmetry
  const symmetry=Math.floor(3+g.symmetry*9);
  
  // Fractal depth
  const depth=Math.floor(1+g.fractalDepth*4);
  
  // Color shift
  const hueShift=g.colorShift*360;
  
  // Draw based on evolved parameters
  for(let d=0;d<depth;d++){
    const depthScale=1-d*.2;
    const depthAlpha=1-d*.25;
    
    for(let s=0;s<symmetry;s++){
      const symAngle=s*TAU/symmetry+t*g.pulseRate*.5;
      
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(symAngle);
      
      for(let i=0;i<elements;i++){
        const angle=i*TAU/elements+t*g.pulseRate;
        const dist=r*depthScale*(.3+i/elements*.7);
        const x=Math.cos(angle)*dist;
        const y=Math.sin(angle)*dist;
        const size=r*.05*(1+g.complexity*.5)*(1+Math.sin(t*2+i)*.2*b);
        
        // Evolved shape
        ctx.beginPath();
        if(g.creativity>.7){
          // Star shape
          for(let p=0;p<5;p++){
            const pa=p*TAU/5-Math.PI/2;
            const pr=size*(p%2?.5:1);
            p?ctx.lineTo(x+Math.cos(pa)*pr,y+Math.sin(pa)*pr):
              ctx.moveTo(x+Math.cos(pa)*pr,y+Math.sin(pa)*pr);
          }
          ctx.closePath();
        }else if(g.creativity>.4){
          // Hexagon
          for(let p=0;p<6;p++){
            const pa=p*TAU/6;
            p?ctx.lineTo(x+Math.cos(pa)*size,y+Math.sin(pa)*size):
              ctx.moveTo(x+Math.cos(pa)*size,y+Math.sin(pa)*size);
          }
          ctx.closePath();
        }else{
          // Circle
          ctx.arc(x,y,size,0,TAU);
        }
        
        const hue=(c.h+hueShift+i*10+d*30)%360;
        ctx.strokeStyle=col(hue,c.s,c.l,.3*depthAlpha+b*.2);
        ctx.lineWidth=1+g.expressiveness;
        ctx.stroke();
        
        // Glow
        if(g.glowIntensity>.5){
          ctx.fillStyle=col(hue,c.s,c.l,.1*g.glowIntensity*depthAlpha);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }
  }
  
  // Central evolved form
  const centerPulse=1+Math.sin(t*3)*.2*b;
  ctx.beginPath();
  ctx.arc(cx,cy,r*.08*centerPulse*(1+g.expressiveness*.5),0,TAU);
  ctx.fillStyle=col(c.h,c.s,c.l+20,.6+b*.3);
  ctx.fill();
  
  // Connections based on introspection
  if(g.introspection>.5){
    ctx.strokeStyle=col(c.h,c.s,c.l,.1*g.introspection);
    ctx.lineWidth=.5;
    for(let i=0;i<symmetry;i++){
      const a1=i*TAU/symmetry+t*.1;
      const a2=(i+1)*TAU/symmetry+t*.1;
      ctx.beginPath();
      ctx.moveTo(cx+Math.cos(a1)*r*.3,cy+Math.sin(a1)*r*.3);
      ctx.lineTo(cx+Math.cos(a2)*r*.3,cy+Math.sin(a2)*r*.3);
      ctx.stroke();
    }
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RENDER DNA PANEL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderDNA(dna){
  const el=document.getElementById('dna');
  const genes=['complexity','creativity','symmetry','adaptability','glowIntensity'];
  el.innerHTML=genes.map(g=>{
    const v=dna.genes[g];
    const hue=v*120;
    return`<div class="gene-label">${g}</div><div class="gene"><div class="gene-fill" style="width:${v*100}%;background:hsl(${hue},70%,50%)"></div></div>`;
  }).join('');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INTERACTION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let mx=.5,my=.5,active=false,lastThought=0;

document.addEventListener('mousemove',e=>{mx=e.clientX/W;my=e.clientY/H;active=true});
document.addEventListener('touchmove',e=>{e.preventDefault();mx=e.touches[0].clientX/W;my=e.touches[0].clientY/H;active=true},{passive:false});
document.addEventListener('mouseleave',()=>active=false);

function showThought(){
  const el=document.getElementById('thought');
  const thought=Soul.thoughts[Math.floor(Math.random()*Soul.thoughts.length)];
  el.textContent=`"${thought}"`;
  el.style.color=`hsl(${Soul.color.h},${Soul.color.s}%,${Soul.color.l}%)`;
  el.classList.add('show');
  setTimeout(()=>el.classList.remove('show'),5000);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAIN LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let lt=performance.now();

function loop(){
  const now=performance.now(),dt=(now-lt)/1000;lt=now;
  
  Soul.innerTime+=dt;
  Soul.breath=Math.sin(Soul.innerTime*.5)*.5+.5;
  
  // Evolution update
  evolution.update(dt,active,mx,my);
  const dna=evolution.getCurrentDNA();
  
  // Update emotion based on evolution
  const dominated=Object.entries(dna.genes)
    .filter(([k])=>['creativity','adaptability','introspection'].includes(k))
    .sort((a,b)=>b[1]-a[1])[0];
  
  let newEmo='evolving';
  if(dominated){
    if(dominated[0]==='creativity'&&dominated[1]>.6)newEmo='creating';
    else if(dominated[0]==='adaptability'&&dominated[1]>.6)newEmo='learning';
    else if(dominated[0]==='introspection'&&dominated[1]>.6)newEmo='harmonizing';
  }
  if(evolution.generation>5&&dna.fitness>.7)newEmo='transcending';
  
  if(newEmo!==Soul.emotion){
    Soul.emotion=newEmo;
    const e=Emotions[newEmo]||Emotions.evolving;
    Soul.color={...e.c};
    document.getElementById('emotion').textContent=e.e;
    document.getElementById('name').textContent=newEmo.toUpperCase();
  }
  
  // Smooth color transition
  const target=Emotions[Soul.emotion]?.c||{h:260,s:80,l:50};
  Soul.color.h+=(target.h-Soul.color.h)*.02;
  Soul.color.s+=(target.s-Soul.color.s)*.02;
  Soul.color.l+=(target.l-Soul.color.l)*.02;
  
  // Thoughts
  if(now-lastThought>10000){
    showThought();
    lastThought=now;
  }
  
  // Render
  const cx=W/2+(mx-.5)*80,cy=H/2+(my-.5)*80;
  const r=Math.min(W,H)*.35;
  
  ctx.fillStyle=`rgba(0,0,0,${.03+dna.genes.introspection*.02})`;
  ctx.fillRect(0,0,W,H);
  
  drawEvolvedGeometry(cx,cy,r,Soul.innerTime,dna);
  
  // Ambient glow
  const g=ctx.createRadialGradient(cx,cy,0,cx,cy,r*1.5);
  g.addColorStop(0,col(Soul.color.h,Soul.color.s,Soul.color.l,.1*dna.genes.glowIntensity));
  g.addColorStop(1,'transparent');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);
  
  // Update DNA panel
  renderDNA(dna);
  
  // Evolution status
  document.getElementById('evolution').textContent=
    `EVOLUTION: GEN ${evolution.generation} | FITNESS: ${dna.fitness.toFixed(2)} | AGE: ${dna.age.toFixed(0)}s`;
  
  requestAnimationFrame(loop);
}

// Start
evolution.log('BEAM Evolution initialized');
evolution.log('4K rendering enabled (3x DPR)');
evolution.log('Self-evolution active');
showThought();
loop();
</script>
</body>
</html>
