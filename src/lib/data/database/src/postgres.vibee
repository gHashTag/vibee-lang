// PostgreSQL Database Module for Telegram RAG
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Connection pool and CRUD operations for telegram_dialogs, telegram_messages, telegram_media
// Converted from infra/db/postgres.gleam → dsl/infra/db/postgres.vibee

// =============================================================================
// Types - Connection and Pool
// =============================================================================

type DbPool {
  DbPool(connection: Connection)
}

type DbError {
  DbConnection❌message: str)
  DbQuery❌message: str)
  DbNotFound
}
fn new() · Self {
    connection: connection
  
}

  # Auto-generated getters
fn connection(self) · self.connection


  # Auto-generated getters
fn message(self) · self.message

fn message(self) · self.message


// =============================================================================
// Types - Dialog (auto-generates to_string/from_string)
// =============================================================================

@enum DialogType {
  "type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}" => Dialogtype type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  "group" => DialogGroup
  "channel" => DialogChannel
  "bot" => DialogBot
}

derive(Json)
@enum ParseStatus {
  "pending" => ParsePending
  "in_progress" => ParseInProgress
  "completed" => ParseCompleted
  "failed" => ParseFailed
}

type TelegramDialog {
  TelegramDialog(
    id: int,
    dialog_type: DialogType,
    title: str?,
    type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name: str?,
    first_name: str?,
    last_name: str?,
    phone: str?,
    participants_count: int?,
    is_verified: bool,
    is_restricted: bool,
    last_message_id: int?,
    last_parsed_at: str?,
    parse_status: ParseStatus,
    total_messages: int,
    parsed_messages: int
  )
}

  # Auto-generated getters
fn id(self) · self.id

fn dialog_type(self) · self.dialog_type

fn title(self) · self.title

fn type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name(self) → str {
  self.type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name
}
fn first_name(self) · self.first_name

fn last_name(self) · self.last_name

fn phone(self) · self.phone

fn participants_count(self) · self.participants_count

fn is_verified(self) · self.is_verified

fn is_restricted(self) · self.is_restricted

fn last_message_id(self) · self.last_message_id

fn last_parsed_at(self) · self.last_parsed_at

fn parse_status(self) · self.parse_status

fn total_messages(self) · self.total_messages


  # Auto-generated getters
fn id(self) · self.id

fn message_id(self) · self.message_id

fn dialog_id(self) · self.dialog_id

fn sender_id(self) · self.sender_id

fn sender_name(self) · self.sender_name

fn content_type(self) · self.content_type

fn text_content(self) · self.text_content

fn media_id(self) · self.media_id

fn reply_to_id(self) · self.reply_to_id

fn forward_from_id(self) · self.forward_from_id

fn forward_from_name(self) · self.forward_from_name

fn timestamp(self) · self.timestamp

fn has_embedding(self) · self.has_embedding

fn parsed_messages(self) · self.parsed_messages


  # Auto-generated getters
fn id(self) · self.id

fn message_id(self) · self.message_id

fn dialog_id(self) · self.dialog_id

fn media_type(self) · self.media_type

fn file_id(self) · self.file_id

fn file_path(self) · self.file_path

fn file_size(self) · self.file_size

fn mime_type(self) · self.mime_type


  # Auto-generated getters
fn id(self) · self.id

fn job_type(self) · self.job_type

fn dialog_id(self) · self.dialog_id

fn status(self) · self.status

fn progress_current(self) · self.progress_current


  # Auto-generated getters
fn total_dialogs(self) · self.total_dialogs

fn parsed_dialogs(self) · self.parsed_dialogs

fn total_messages(self) · self.total_messages

fn messages_with_embedding(self) · self.messages_with_embedding

fn total_media(self) · self.total_media

fn processed_media(self) · self.processed_media


  # Auto-generated getters
fn message_id(self) · self.message_id

fn dialog_id(self) · self.dialog_id

fn text_content(self) · self.text_content

fn timestamp(self) · self.timestamp


  # Auto-generated getters
fn dialog_id(self) · self.dialog_id

fn dialog_title(self) · self.dialog_title

fn dialog_type(self) · self.dialog_type


  # Auto-generated getters
fn message_id(self) · self.message_id

fn sender_name(self) · self.sender_name

fn text_content(self) · self.text_content

fn timestamp(self) · self.timestamp

fn is_outgoing(self) · self.is_outgoing

fn total_messages(self) · self.total_messages

fn messages_with_embedding(self) · self.messages_with_embedding

fn first_message_date(self) · self.first_message_date

fn last_message_date(self) · self.last_message_date

fn sender_name(self) · self.sender_name

fn vector_rank(self) · self.vector_rank

fn keyword_rank(self) · self.keyword_rank

fn rrf_score(self) · self.rrf_score

fn pending_jobs(self) · self.pending_jobs

fn running_jobs(self) · self.running_jobs

fn progress_total(self) · self.progress_total

fn started_at(self) · self.started_at

fn completed_at(self) · self.completed_at

fn error_message(self) · self.error_message

fn duration_seconds(self) · self.duration_seconds

fn transcription(self) · self.transcription

fn image_description(self) · self.image_description

fn process_status(self) · self.process_status


// =============================================================================
// Types - Message
// =============================================================================

@enum ContentType {
  "text" => ContentText
  "photo" => ContentPhoto
  "voice" => ContentVoice
  "video" => ContentVideo
  "document" => ContentDocument
  "sticker" => ContentSticker
  "animation" => ContentAnimation
  "video_note" => ContentVideoNote
  "audio" => ContentAudio
  "contact" => ContentContact
  "location" => ContentLocation
  "poll" => ContentPoll
  "other" => ContentOther
}

type TelegramMessage {
  TelegramMessage(
    id: int,
    message_id: int,
    dialog_id: int,
    sender_id: int?,
    sender_name: str?,
    content_type: ContentType,
    text_content: str?,
    media_id: int?,
    reply_to_id: int?,
    forward_from_id: int?,
    forward_from_name: str?,
    timestamp: str,
    has_embedding: bool
  )
}

// =============================================================================
// Types - Media (auto-generates to_string/from_string)
// =============================================================================

@enum ProcessStatus {
  "pending" => ProcessPending
  "processing" => ProcessProcessing
  "completed" => ProcessCompleted
  "failed" => ProcessFailed
  "skipped" => ProcessSkipped
}

type TelegramMedia {
  TelegramMedia(
    id: int,
    message_id: int,
    dialog_id: int,
    media_type: str,
    file_id: str?,
    file_path: str?,
    file_size: int?,
    mime_type: str?,
    duration_seconds: int?,
    transcription: str?,
    image_description: str?,
    process_status: ProcessStatus
  )
}

// =============================================================================
// Types - Parse Job
// =============================================================================

type ParseJob {
  ParseJob(
    id: int,
    job_type: str,
    dialog_id: int?,
    status: str,
    progress_current: int,
    progress_total: int,
    started_at: str?,
    completed_at: str?,
    error_message: str?
  )
}

type ParseStats {
  ParseStats(
    total_dialogs: int,
    parsed_dialogs: int,
    total_messages: int,
    messages_with_embedding: int,
    total_media: int,
    processed_media: int,
    pending_jobs: int,
    running_jobs: int
  )
}

// =============================================================================
// Types - Search
// =============================================================================

type SearchResult {
  SearchResult(
    message_id: int,
    dialog_id: int,
    text_content: str,
    timestamp: str,
    sender_name: str?,
    vector_rank: int,
    keyword_rank: int,
    rrf_score: float
  )
}

type DialogMetadata {
  DialogMetadata(
    dialog_id: int,
    dialog_title: str?,
    dialog_type: str,
    total_messages: int,
    messages_with_embedding: int,
    first_message_date: str?,
    last_message_date: str?
  )
}

type RecentMessage {
  RecentMessage(
    message_id: int,
    sender_name: str?,
    text_content: str,
    timestamp: str,
    is_outgoing: bool
  )
}

// =============================================================================
// Connection Pool
// =============================================================================

trace("db.postgres.connect")
@spec connect(database_url: str) → DbError · Result {
  /// Create database connection pool
  given: Database URL (PostgreSQL)
  when: Initializing database
  then: Returns connection pool or error
}

@impl {
  pog_connect(database_url)
}

@spec disconnect(pool: DbPool) → Nil {
  /// Disconnect from database
  given: Pool
  when: Shutting down
  then: Closes connections
}

@impl {
  // Nil is implicit
}

@spec set_global_pool(pool: DbPool) → Nil {
  /// Store pool in global ETS table
  given: Pool
  when: Making pool available globally
  then: Stores in ETS
}

@impl {
  ets_set_global_pool(pool)
}

@spec get_global_pool() → DbPool? {
  /// Get pool from global ETS table
  given: Nothing
  when: Getting global pool
  then: Returns pool if exists
}

@impl {
  ets_get_global_pool()
}

// =============================================================================
// Dialog CRUD
// =============================================================================

metrics("db.postgres")
@spec upsert_dialog(pool: DbPool, dialog: TelegramDialog) → DbError · Result {
  /// Insert or update dialog
  given: Pool and dialog
  when: Saving dialog
  then: Upserts to database
}

@impl {
  dialog · sql_upsert_dialog
}

metrics("db.postgres")
@spec get_dialog(pool: DbPool, dialog_id: int) → DbError · Result {
  /// Get dialog by ID
  given: Pool and dialog ID
  when: Fetching dialog
  then: Returns dialog or error
}

@impl {
  dialog_id · sql_get_dialog
}

metrics("db.postgres")
@spec list_dialogs(pool: DbPool, status_filter: ParseStatus?, limit: int, offset: int) → Result([TelegramDialog], DbError) {
  /// list dialogs with optional filter
  given: Pool and pagination params
  when: Listing dialogs
  then: Returns dialog list
}

@impl {
  status_filter, limit, offset · sql_list_dialogs
}

metrics("db.postgres")
@spec update_dialog_status(pool: DbPool, dialog_id: int, status: ParseStatus, parsed_messages: int) → DbError · Result {
  /// Update dialog parse status
  given: Pool, dialog ID, status, count
  when: Updating parse progress
  then: Updates status in database
}

@impl {
  dialog_id, status, parsed_messages · sql_update_dialog_status
}

// =============================================================================
// Message CRUD
// =============================================================================

metrics("db.postgres")
trace("db.postgres.insert_messages_batch")
@spec insert_messages_batch(pool: DbPool, messages: [TelegramMessage]) → DbError · Result {
  /// Insert batch of messages
  given: Pool and message list
  when: Bulk inserting messages
  then: Returns inserted count
}

@impl {
  messages · sql_insert_messages_batch
}

metrics("db.postgres")
@spec get_messages(pool: DbPool, dialog_id: int, limit: int, offset_message_id: int?) → Result([TelegramMessage], DbError) {
  /// Get messages for dialog with pagination
  given: Pool, dialog ID, limit, offset
  when: Fetching messages
  then: Returns message list
}

@impl {
  dialog_id, limit, offset_message_id · sql_get_messages
}

metrics("db.postgres")
@spec get_messages_without_embedding(pool: DbPool, limit: int) → Result([TelegramMessage], DbError) {
  /// Get messages without embeddings
  given: Pool and limit
  when: Batch embedding generation
  then: Returns unembedded messages
}

@impl {
  limit · sql_get_messages_without_embedding
}

metrics("db.postgres")
@spec update_message_embedding(pool: DbPool, message_id: int, embedding: [float], model: str) → DbError · Result {
  /// Update message embedding
  given: Pool, message ID, embedding vector, model
  when: Storing embedding
  then: Updates embedding in database
}

@impl {
  message_id, embedding, model · sql_update_message_embedding
}

// =============================================================================
// Media CRUD
// =============================================================================

metrics("db.postgres")
@spec insert_media(pool: DbPool, media: TelegramMedia) → DbError · Result {
  /// Insert media record
  given: Pool and media
  when: Saving media
  then: Returns inserted ID
}

@impl {
  media · sql_insert_media
}

metrics("db.postgres")
@spec get_pending_media(pool: DbPool, media_type: str?, limit: int) → Result([TelegramMedia], DbError) {
  /// Get pending media for processing
  given: Pool, optional type filter, limit
  when: Finding media to process
  then: Returns pending media list
}

@impl {
  media_type, limit · sql_get_pending_media
}

metrics("db.postgres")
@spec update_media_transcription(pool: DbPool, media_id: int, transcription: str, model: str, language: str) → DbError · Result {
  /// Update media transcription (voice)
  given: Pool, media ID, transcription, model, language
  when: Storing transcription
  then: Updates transcription in database
}

@impl {
  media_id, transcription, model, language · sql_update_media_transcription
}

metrics("db.postgres")
@spec update_media_vision(pool: DbPool, media_id: int, description: str, ocr_text: str?, model: str) → DbError · Result {
  /// Update media image description (photo)
  given: Pool, media ID, description, OCR, model
  when: Storing vision analysis
  then: Updates vision in database
}

@impl {
  media_id, description, ocr_text, model · sql_update_media_vision
}

metrics("db.postgres")
@spec update_media_status(pool: DbPool, media_id: int, status: ProcessStatus, error: str?) → DbError · Result {
  /// Update media process status
  given: Pool, media ID, status, optional error
  when: Updating processing state
  then: Updates status in database
}

@impl {
  media_id, status, error · sql_update_media_status
}

// =============================================================================
// Parse Job Operations
// =============================================================================

metrics("db.postgres")
@spec create_parse_job(pool: DbPool, job_type: str, dialog_id: int?) → DbError · Result {
  /// Create new parse job
  given: Pool, job type, optional dialog ID
  when: Starting parse job
  then: Returns job ID
}

@impl {
  job_type, dialog_id · sql_create_parse_job
}

metrics("db.postgres")
@spec create_parse_job_with_config(pool: DbPool, job_type: str, dialog_id: int?, config_json: str) → DbError · Result {
  /// Create parse job with config
  given: Pool, job type, dialog ID, config JSON
  when: Starting configured job
  then: Returns job ID
}

@impl {
  job_type, dialog_id, config_json · sql_create_parse_job_with_config
}

metrics("db.postgres")
@spec update_job_progress(pool: DbPool, job_id: int, current: int, total: int) → DbError · Result {
  /// Update job progress
  given: Pool, job ID, current/total counts
  when: Updating progress
  then: Updates progress in database
}

@impl {
  job_id, current, total · sql_update_job_progress
}

metrics("db.postgres")
@spec complete_job(pool: DbPool, job_id: int, result_json: str) → DbError · Result {
  /// Complete parse job
  given: Pool, job ID, result JSON
  when: Job finished successfully
  then: Marks job complete
}

@impl {
  job_id, result_json · sql_complete_job
}

metrics("db.postgres")
@spec fail_job(pool: DbPool, job_id: int, error: str) → DbError · Result {
  /// Fail parse job
  given: Pool, job ID, error message
  when: Job failed
  then: Marks job failed
}

@impl {
  job_id, error · sql_fail_job
}

metrics("db.postgres")
@spec get_parse_stats(pool: DbPool) → ParseStats {
  /// Get parse statistics
  given: Pool
  when: Getting stats
  then: Returns statistics
}

@impl {
  sql_get_parse_stats(pool)
}

// =============================================================================
// Search Operations
// =============================================================================

metrics("db.postgres")
trace("db.postgres.hybrid_search")
@spec hybrid_search(pool: DbPool, query_embedding: [float], query_text: str, limit: int) → Result([SearchResult], DbError) {
  /// Hybrid search (vector + keyword with RRF)
  given: Pool, query embedding, text, limit
  when: Semantic + keyword search
  then: Returns ranked results
}

@impl {
  query_embedding, query_text, limit · sql_hybrid_search
}

metrics("db.postgres")
trace("db.postgres.semantic_search")
@spec semantic_search(pool: DbPool, query_embedding: [float], limit: int, threshold: float) → Result([SearchResult], DbError) {
  /// Vector-only semantic search
  given: Pool, query embedding, limit, threshold
  when: Pure semantic search
  then: Returns similar results
}

@impl {
  query_embedding, limit, threshold · sql_semantic_search
}

metrics("db.postgres")
trace("db.postgres.keyword_search")
@spec keyword_search(pool: DbPool, query_text: str, limit: int) → Result([SearchResult], DbError) {
  /// Full-text keyword search
  given: Pool, query text, limit
  when: Text search
  then: Returns matching results
}

@impl {
  query_text, limit · sql_keyword_search
}

// =============================================================================
// Conversation Context (AI Digital Clone)
// =============================================================================

metrics("db.postgres")
@spec get_recent_messages(pool: DbPool, dialog_id: int, limit: int, owner_id: int) → Result([RecentMessage], DbError) {
  /// Get recent messages for dialog
  given: Pool, dialog ID, limit, owner ID
  when: Building conversation context
  then: Returns recent messages
}

@impl {
  dialog_id, limit, owner_id · sql_get_recent_messages
}

metrics("db.postgres")
@spec get_dialog_metadata(pool: DbPool, dialog_id: int) → DbError · Result {
  /// Get dialog metadata for context
  given: Pool and dialog ID
  when: Getting dialog info
  then: Returns metadata
}

@impl {
  dialog_id · sql_get_dialog_metadata
}

metrics("db.postgres")
@spec semantic_search_in_dialog(pool: DbPool, dialog_id: int, query_embedding: [float], limit: int) → Result([SearchResult], DbError) {
  /// Semantic search filtered by dialog
  given: Pool, dialog ID, embedding, limit
  when: Searching in specific dialog
  then: Returns filtered results
}

@impl {
  dialog_id, query_embedding, limit · sql_semantic_search_in_dialog
}

// =============================================================================
// FFI Imports (PostgreSQL via pog)
// =============================================================================

// @ffi pog_connect(url: str) → DbError · Result
// @ffi ets_set_global_pool(pool: DbPool) → Nil
// @ffi ets_get_global_pool() → DbPool?
// @ffi sql_upsert_dialog(...) → DbError · Result
// @ffi sql_get_dialog(...) → DbError · Result
// @ffi sql_list_dialogs(...) → Result([TelegramDialog], DbError)
// ... other SQL FFI functions

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
