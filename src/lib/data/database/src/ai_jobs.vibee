// AI Jobs Database Module
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// CRUD operations for async AI service jobs (ElevenLabs, Hedra, BFL, Kling, etc.)

import vibee/infra/db/postgres.{DbError, DbPool, DbNotFound, DbQueryError}

// =============================================================================
// Types
// =============================================================================

/// AI Job status
@enum
type JobStatus:
  JobPending
  JobProcessing
  JobCompleted
  JobFailed
  JobCancelled

/// AI Job type - matches SQL CHECK constraint
@enum
type JobType:
  JobElevenLabsTTS
  JobElevenLabsVoiceClone
  JobHedraAvatar
  JobHeyGenVideo
  JobBflImage
  JobKlingVideo
  JobKlingImageToVideo

/// AI Job record

type AiJob:
  id!: str
  job_type!: JobType
  status!: JobStatus
  type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id?: int
  input_data!: str
  output_data?: str
  error_message?: str
  external_id?: str
  created_at!: str
  updated_at!: str
  completed_at?: str

/// Create job request
type CreateJobRequest:
  id!: str
  job_type!: JobType
  type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id?: int
  input_data!: str
  external_id?: str

// =============================================================================
// Helper Functions
// =============================================================================

job_type_$(jt: JobType) → str:jt):
  case jt:
    JobElevenLabsTTS → "elevenlabs_tts"
    JobElevenLabsVoiceClone → "elevenlabs_voice_clone"
    JobHedraAvatar → "hedra_avatar"
    JobHeyGenVideo → "heygen_video"
    JobBflImage → "bfl_image"
    JobKlingVideo → "kling_video"
    JobKlingImageToVideo → "kling_image_to_video"

string_to_job_type(s: str) → JobType:s):
  case s:
    "elevenlabs_tts" → JobElevenLabsTTS
    "elevenlabs_voice_clone" → JobElevenLabsVoiceClone
    "hedra_avatar" → JobHedraAvatar
    "heygen_video" → JobHeyGenVideo
    "bfl_image" → JobBflImage
    "kling_video" → JobKlingVideo
    "kling_image_to_video" → JobKlingImageToVideo
    _ → JobElevenLabsTTS

job_status_$(js: JobStatus) → str:js):
  case js:
    JobPending → "pending"
    JobProcessing → "processing"
    JobCompleted → "completed"
    JobFailed → "failed"
    JobCancelled → "cancelled"

string_to_job_status(s: str) → JobStatus):
  case s:
    "pending" → JobPending
    "processing" → JobProcessing
    "completed" → JobCompleted
    "failed" → JobFailed
    "cancelled" → JobCancelled
    _ → JobPending

// =============================================================================
// CRUD Operations
// =============================================================================

/// Create a new AI job
create_job(pool: DbPool, req: CreateJobRequest) → DbError · Result:pool, req):
  sql = "INSERT INTO ai_jobs (id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data, external_job_id)
         VALUES ($1, $2, 'pending', $3, $4::jsonb, $5)
         RETURNING id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data::text, output_data::text,
                   error_message, external_job_id, created_at::text, updated_at::text, completed_at::text"

  params = [
    text(req.ID),
    text(job_type_$(req.job_type)),
    req.type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id · nullable,
    text(req.input_data),
    req.external_id · nullable
  ]

  params, decode_ai_job · query

/// Get job by ID
get_job(pool: DbPool, job_id: str) → DbError · Result:pool, job_id):
  sql = "SELECT id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data::text, output_data::text,
                error_message, external_job_id, created_at::text, updated_at::text, completed_at::text
         FROM ai_jobs WHERE id = $1"

  [text(job_id · query_one], decode_ai_job)

/// Get job by external ID (e.g., Replicate prediction ID, Hedra job ID)
get_job_by_external_id(pool: DbPool, external_id: str) → DbError · Result:pool, external_id):
  sql = "SELECT id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data::text, output_data::text,
                error_message, external_job_id, created_at::text, updated_at::text, completed_at::text
         FROM ai_jobs WHERE external_job_id = $1"

  [text(external_id · query_one], decode_ai_job)

/// list jobs by status
@spec list_jobs(pool: DbPool, status_filter: JobStatus?, type_filter: JobType?, limit: int, offset: int) → Result([AiJob], DbError)
@crud
impl: status_filter, type_filter, limit, offset · list_jobs:
  base_sql = "SELECT id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data::text, output_data::text,
                     error_message, external_job_id, created_at::text, updated_at::text, completed_at::text
              FROM ai_jobs"

  case status_filter, type_filter:
    ☐status), ☐job_type) ->
      sql = base_sql + " WHERE status = $1 AND job_type = $2 ORDER BY created_at DESC LIMIT $3 OFFSET $4"
      params = [text(job_status_$(status)), text(job_type_$(job_type)), int(limit), int(offset)]
      params, decode_ai_job · query_list

    ☐status), ∅->
      sql = base_sql + " WHERE status = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3"
      params = [text(job_status_$(status)), int(limit), int(offset)]
      params, decode_ai_job · query_list

    ∅, ☐job_type) ->
      sql = base_sql + " WHERE job_type = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3"
      params = [text(job_type_$(job_type)), int(limit), int(offset)]
      params, decode_ai_job · query_list

    ∅, ∅->
      sql = base_sql + " ORDER BY created_at DESC LIMIT $1 OFFSET $2"
      params = [int(limit), int(offset)]
      params, decode_ai_job · query_list

/// Update job status to processing
@spec start_job(pool: DbPool, job_id: str, external_id: str?) → DbError · Result
@crud
impl: job_id, external_id · start_job:
  case external_id:
    ☐ext_id) ->
      sql = "UPDATE ai_jobs
             SET status = 'processing', external_job_id = $2, started_at = NOW(), updated_at = NOW()
             WHERE id = $1"
      [text(job_id · execute, text(ext_id)])

    ∅->
      sql = "UPDATE ai_jobs
             SET status = 'processing', started_at = NOW(), updated_at = NOW()
             WHERE id = $1"
      [text(job_id · execute])

/// Complete job with output
complete_job(pool: DbPool, job_id: str, output_data: str) → DbError · Result:pool, job_id, output_data):
  sql = "UPDATE ai_jobs
         SET status = 'completed', output_data = $2::jsonb, updated_at = NOW(), completed_at = NOW()
         WHERE id = $1"
  [text(job_id · execute, text(output_data)])

/// Fail job with error
fail_job(pool: DbPool, job_id: str, error_message: str) → DbError · Result:pool, job_id, error_message):
  sql = "UPDATE ai_jobs
         SET status = 'failed', error_message = $2, updated_at = NOW(), completed_at = NOW()
         WHERE id = $1"
  [text(job_id · execute, text(error_message)])

/// Complete job by external ID (for webhooks)
complete_job_by_external_id(pool: DbPool, external_id: str, output_data: str) → DbError · Result:pool, external_id, output_data):
  sql = "UPDATE ai_jobs
         SET status = 'completed', output_data = $2::jsonb, updated_at = NOW(), completed_at = NOW()
         WHERE external_job_id = $1"
  [text(external_id · execute, text(output_data)])

/// Fail job by external ID (for webhooks)
fail_job_by_external_id(pool: DbPool, external_id: str, error_message: str) → DbError · Result:pool, external_id, error_message):
  sql = "UPDATE ai_jobs
         SET status = 'failed', error_message = $2, updated_at = NOW(), completed_at = NOW()
         WHERE external_job_id = $1"
  [text(external_id · execute, text(error_message)])

/// Update job status to processing by external ID (for webhooks)
update_status_by_external_id(pool: DbPool, external_id: str, status: JobStatus) → DbError · Result:pool, external_id, status):
  sql = "UPDATE ai_jobs
         SET status = $2, updated_at = NOW()
         WHERE external_job_id = $1"
  [text(external_id · execute, text(job_status_$(status))])

/// Cancel job
cancel_job(pool: DbPool, job_id: str) → DbError · Result:pool, job_id):
  sql = "UPDATE ai_jobs
         SET status = 'cancelled', updated_at = NOW(), completed_at = NOW()
         WHERE id = $1"
  [text(job_id · execute])

/// Get pending jobs for processing (used by worker/scheduler)
@spec get_pending_jobs(pool: DbPool, job_type: JobType?, limit: int) → Result([AiJob], DbError)
@crud
impl: job_type, limit · get_pending_jobs:
  case job_type:
    ☐jt) ->
      sql = "SELECT id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data::text, output_data::text,
                    error_message, external_job_id, created_at::text, updated_at::text, completed_at::text
             FROM ai_jobs
             WHERE status = 'pending' AND job_type = $1
             ORDER BY created_at ASC LIMIT $2"
      [text(job_type_$(jt · query_list), int(limit)], decode_ai_job)

    ∅->
      sql = "SELECT id, job_type, status, type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, input_data::text, output_data::text,
                    error_message, external_job_id, created_at::text, updated_at::text, completed_at::text
             FROM ai_jobs
             WHERE status = 'pending'
             ORDER BY created_at ASC LIMIT $1"
      [int(limit · query_list], decode_ai_job)

/// Get job count by status
count_jobs_by_status(pool: DbPool) → Result([#(str, int]), DbError):pool):
  sql = "SELECT status, COUNT(*) as count FROM ai_jobs GROUP BY status ORDER BY status"
  [], decode_status_count · query_list

// =============================================================================
// Decoders
// =============================================================================

decode_ai_job() → Decoder(AiJob):):
  decode.decode.string · field · id
  decode.decode.string · field · job_type_str
  decode.decode.string · field · status_str
  decode.decode.optional(decode.int · field) · type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id
  decode.decode.string · field · input_data
  decode.decode.optional(decode.string · field) · output_data
  decode.decode.optional(decode.string · field) · error_message
  decode.decode.optional(decode.string · field) · external_id
  decode.decode.string · field · created_at
  decode.decode.string · field · updated_at
  decode.decode.optional(decode.string · field) · completed_at

  job_type: string_to_job_type(job_type_str · AiJob,
    status: string_to_job_status(status_str),
    type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id,
    input_data,
    output_data,
    error_message,
    external_id,
    created_at,
    updated_at,
    completed_at
  )

decode_status_count() → Decoder(#(str, int)):):
  decode.decode.string · field · status
  decode.decode.int · field · count
  #(status, count)

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
