/// Vibee Lang Parser - AST Builder
/// Converts tokens into Abstract Syntax Tree

use crate::lexer::{Token, TokenKind, Span}

// AST Node Types
pub enum Expr {
    Literal(LiteralExpr),
    Identifier(String),
    Binary(Box<Expr>, BinOp, Box<Expr>),
    Unary(UnaryOp, Box<Expr>),
    Call(Box<Expr>, Vec<Expr>),
    Index(Box<Expr>, Box<Expr>),
    Field(Box<Expr>, String),
    If(Box<Expr>, Box<Block>, Option<Box<Block>>),
    Match(Box<Expr>, Vec<MatchArm>),
    Block(Block),
    Lambda(Vec<Param>, Box<Expr>),
    Array(Vec<Expr>),
    Tuple(Vec<Expr>),
    Struct(String, Vec<(String, Expr)>),
}

pub enum LiteralExpr {
    Int(Int),
    Float(Float),
    String(String),
    Char(Char),
    Bool(Bool),
    Nil,
}

pub enum BinOp {
    Add, Sub, Mul, Div, Mod,
    Eq, NotEq, Lt, Gt, LtEq, GtEq,
    And, Or, BitAnd, BitOr, BitXor,
    Shl, Shr,
}

pub enum UnaryOp {
    Neg, Not, BitNot, Ref, Deref,
}

pub struct MatchArm {
    pub pattern: Pattern,
    pub guard: Option<Expr>,
    pub body: Expr,
}

pub enum Pattern {
    Wildcard,
    Literal(LiteralExpr),
    Identifier(String),
    Tuple(Vec<Pattern>),
    Struct(String, Vec<(String, Pattern)>),
    Enum(String, Option<Box<Pattern>>),
}

pub struct Block {
    pub stmts: Vec<Stmt>,
    pub expr: Option<Box<Expr>>,
}

pub enum Stmt {
    Let(String, Option<Type>, Option<Expr>),
    Expr(Expr),
    Return(Option<Expr>),
    Break(Option<Expr>),
    Continue,
    While(Expr, Block),
    For(String, Expr, Block),
    Loop(Block),
}

pub struct Param {
    pub name: String,
    pub ty: Type,
    pub default: Option<Expr>,
}

pub enum Type {
    Named(String),
    Generic(String, Vec<Type>),
    Tuple(Vec<Type>),
    Array(Box<Type>, Option<Int>),
    Function(Vec<Type>, Box<Type>),
    Reference(Box<Type>, Bool),
    Optional(Box<Type>),
}

// Top-level items
pub enum Item {
    Function(FnDef),
    Struct(StructDef),
    Enum(EnumDef),
    Trait(TraitDef),
    Impl(ImplDef),
    Actor(ActorDef),
    Const(ConstDef),
    Use(UseDef),
    Mod(ModDef),
}

pub struct FnDef {
    pub name: String,
    pub generics: Vec<GenericParam>,
    pub params: Vec<Param>,
    pub ret_type: Option<Type>,
    pub body: Option<Block>,
    pub is_pub: Bool,
    pub is_async: Bool,
}

pub struct StructDef {
    pub name: String,
    pub generics: Vec<GenericParam>,
    pub fields: Vec<FieldDef>,
    pub is_pub: Bool,
}

pub struct FieldDef {
    pub name: String,
    pub ty: Type,
    pub is_pub: Bool,
}

pub struct EnumDef {
    pub name: String,
    pub generics: Vec<GenericParam>,
    pub variants: Vec<VariantDef>,
    pub is_pub: Bool,
}

pub struct VariantDef {
    pub name: String,
    pub fields: Option<Vec<Type>>,
}

pub struct TraitDef {
    pub name: String,
    pub generics: Vec<GenericParam>,
    pub methods: Vec<FnDef>,
    pub is_pub: Bool,
}

pub struct ImplDef {
    pub trait_name: Option<String>,
    pub target_type: Type,
    pub generics: Vec<GenericParam>,
    pub methods: Vec<FnDef>,
}

pub struct ActorDef {
    pub name: String,
    pub generics: Vec<GenericParam>,
    pub fields: Vec<FieldDef>,
    pub handlers: Vec<FnDef>,
    pub is_pub: Bool,
}

pub struct ConstDef {
    pub name: String,
    pub ty: Type,
    pub value: Expr,
    pub is_pub: Bool,
}

pub struct UseDef {
    pub path: Vec<String>,
    pub alias: Option<String>,
}

pub struct ModDef {
    pub name: String,
    pub items: Vec<Item>,
    pub is_pub: Bool,
}

pub struct GenericParam {
    pub name: String,
    pub bounds: Vec<String>,
}

pub struct Module {
    pub name: String,
    pub items: Vec<Item>,
}

// Parser
pub struct Parser {
    tokens: Vec<Token>,
    current: Int,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Parser {
        Parser { tokens, current: 0 }
    }
    
    pub fn parse(mut self) -> Module {
        let mut items = Vec::new()
        while !self.is_at_end() {
            if let Some(item) = self.parse_item() {
                items.push(item)
            }
        }
        Module { name: "main", items }
    }
    
    fn parse_item(mut self) -> Option<Item> {
        let is_pub = self.match_token(TokenKind::Pub)
        
        match self.peek().kind {
            TokenKind::Fn => Some(Item::Function(self.parse_fn(is_pub))),
            TokenKind::Struct => Some(Item::Struct(self.parse_struct(is_pub))),
            TokenKind::Enum => Some(Item::Enum(self.parse_enum(is_pub))),
            TokenKind::Trait => Some(Item::Trait(self.parse_trait(is_pub))),
            TokenKind::Impl => Some(Item::Impl(self.parse_impl())),
            TokenKind::Actor => Some(Item::Actor(self.parse_actor(is_pub))),
            TokenKind::Const => Some(Item::Const(self.parse_const(is_pub))),
            TokenKind::Use => Some(Item::Use(self.parse_use())),
            TokenKind::Mod => Some(Item::Mod(self.parse_mod(is_pub))),
            _ => {
                self.advance()
                None
            },
        }
    }
    
    fn parse_fn(mut self, is_pub: Bool) -> FnDef {
        self.expect(TokenKind::Fn)
        let is_async = self.match_token(TokenKind::Async)
        let name = self.expect_identifier()
        let generics = self.parse_generics()
        
        self.expect(TokenKind::LParen)
        let params = self.parse_params()
        self.expect(TokenKind::RParen)
        
        let ret_type = if self.match_token(TokenKind::Arrow) {
            Some(self.parse_type())
        } else { None }
        
        let body = if self.check(TokenKind::LBrace) {
            Some(self.parse_block())
        } else { None }
        
        FnDef { name, generics, params, ret_type, body, is_pub, is_async }
    }
    
    fn parse_struct(mut self, is_pub: Bool) -> StructDef {
        self.expect(TokenKind::Struct)
        let name = self.expect_identifier()
        let generics = self.parse_generics()
        
        self.expect(TokenKind::LBrace)
        let mut fields = Vec::new()
        while !self.check(TokenKind::RBrace) {
            let field_pub = self.match_token(TokenKind::Pub)
            let field_name = self.expect_identifier()
            self.expect(TokenKind::Colon)
            let ty = self.parse_type()
            fields.push(FieldDef { name: field_name, ty, is_pub: field_pub })
            self.match_token(TokenKind::Comma)
        }
        self.expect(TokenKind::RBrace)
        
        StructDef { name, generics, fields, is_pub }
    }
    
    fn parse_enum(mut self, is_pub: Bool) -> EnumDef {
        self.expect(TokenKind::Enum)
        let name = self.expect_identifier()
        let generics = self.parse_generics()
        
        self.expect(TokenKind::LBrace)
        let mut variants = Vec::new()
        while !self.check(TokenKind::RBrace) {
            let var_name = self.expect_identifier()
            let fields = if self.match_token(TokenKind::LParen) {
                let mut types = Vec::new()
                while !self.check(TokenKind::RParen) {
                    types.push(self.parse_type())
                    self.match_token(TokenKind::Comma)
                }
                self.expect(TokenKind::RParen)
                Some(types)
            } else { None }
            variants.push(VariantDef { name: var_name, fields })
            self.match_token(TokenKind::Comma)
        }
        self.expect(TokenKind::RBrace)
        
        EnumDef { name, generics, variants, is_pub }
    }
    
    fn parse_trait(mut self, is_pub: Bool) -> TraitDef {
        self.expect(TokenKind::Trait)
        let name = self.expect_identifier()
        let generics = self.parse_generics()
        
        self.expect(TokenKind::LBrace)
        let mut methods = Vec::new()
        while !self.check(TokenKind::RBrace) {
            methods.push(self.parse_fn(false))
        }
        self.expect(TokenKind::RBrace)
        
        TraitDef { name, generics, methods, is_pub }
    }
    
    fn parse_impl(mut self) -> ImplDef {
        self.expect(TokenKind::Impl)
        let generics = self.parse_generics()
        
        let first_type = self.parse_type()
        let (trait_name, target_type) = if self.match_token(TokenKind::For) {
            (Some(first_type.to_string()), self.parse_type())
        } else {
            (None, first_type)
        }
        
        self.expect(TokenKind::LBrace)
        let mut methods = Vec::new()
        while !self.check(TokenKind::RBrace) {
            let is_pub = self.match_token(TokenKind::Pub)
            methods.push(self.parse_fn(is_pub))
        }
        self.expect(TokenKind::RBrace)
        
        ImplDef { trait_name, target_type, generics, methods }
    }
    
    fn parse_actor(mut self, is_pub: Bool) -> ActorDef {
        self.expect(TokenKind::Actor)
        let name = self.expect_identifier()
        let generics = self.parse_generics()
        
        self.expect(TokenKind::LBrace)
        let mut fields = Vec::new()
        let mut handlers = Vec::new()
        
        while !self.check(TokenKind::RBrace) {
            if self.check(TokenKind::Fn) || self.check(TokenKind::Pub) {
                let h_pub = self.match_token(TokenKind::Pub)
                handlers.push(self.parse_fn(h_pub))
            } else {
                let f_pub = self.match_token(TokenKind::Pub)
                let f_name = self.expect_identifier()
                self.expect(TokenKind::Colon)
                let ty = self.parse_type()
                fields.push(FieldDef { name: f_name, ty, is_pub: f_pub })
                self.match_token(TokenKind::Comma)
            }
        }
        self.expect(TokenKind::RBrace)
        
        ActorDef { name, generics, fields, handlers, is_pub }
    }
    
    fn parse_const(mut self, is_pub: Bool) -> ConstDef {
        self.expect(TokenKind::Const)
        let name = self.expect_identifier()
        self.expect(TokenKind::Colon)
        let ty = self.parse_type()
        self.expect(TokenKind::Eq)
        let value = self.parse_expr()
        
        ConstDef { name, ty, value, is_pub }
    }
    
    fn parse_use(mut self) -> UseDef {
        self.expect(TokenKind::Use)
        let mut path = Vec::new()
        path.push(self.expect_identifier())
        while self.match_token(TokenKind::ColonColon) {
            path.push(self.expect_identifier())
        }
        let alias = if self.match_token(TokenKind::As) {
            Some(self.expect_identifier())
        } else { None }
        
        UseDef { path, alias }
    }
    
    fn parse_mod(mut self, is_pub: Bool) -> ModDef {
        self.expect(TokenKind::Mod)
        let name = self.expect_identifier()
        
        self.expect(TokenKind::LBrace)
        let mut items = Vec::new()
        while !self.check(TokenKind::RBrace) {
            if let Some(item) = self.parse_item() {
                items.push(item)
            }
        }
        self.expect(TokenKind::RBrace)
        
        ModDef { name, items, is_pub }
    }
    
    fn parse_generics(mut self) -> Vec<GenericParam> {
        if !self.match_token(TokenKind::Lt) { return Vec::new() }
        
        let mut params = Vec::new()
        while !self.check(TokenKind::Gt) {
            let name = self.expect_identifier()
            let mut bounds = Vec::new()
            if self.match_token(TokenKind::Colon) {
                bounds.push(self.expect_identifier())
                while self.match_token(TokenKind::Plus) {
                    bounds.push(self.expect_identifier())
                }
            }
            params.push(GenericParam { name, bounds })
            self.match_token(TokenKind::Comma)
        }
        self.expect(TokenKind::Gt)
        params
    }
    
    fn parse_params(mut self) -> Vec<Param> {
        let mut params = Vec::new()
        while !self.check(TokenKind::RParen) {
            let name = self.expect_identifier()
            self.expect(TokenKind::Colon)
            let ty = self.parse_type()
            let default = if self.match_token(TokenKind::Eq) {
                Some(self.parse_expr())
            } else { None }
            params.push(Param { name, ty, default })
            self.match_token(TokenKind::Comma)
        }
        params
    }
    
    fn parse_type(mut self) -> Type {
        let name = self.expect_identifier()
        
        if self.match_token(TokenKind::Lt) {
            let mut args = Vec::new()
            while !self.check(TokenKind::Gt) {
                args.push(self.parse_type())
                self.match_token(TokenKind::Comma)
            }
            self.expect(TokenKind::Gt)
            Type::Generic(name, args)
        } else {
            Type::Named(name)
        }
    }
    
    fn parse_block(mut self) -> Block {
        self.expect(TokenKind::LBrace)
        let mut stmts = Vec::new()
        let mut expr = None
        
        while !self.check(TokenKind::RBrace) {
            let stmt = self.parse_stmt()
            stmts.push(stmt)
        }
        self.expect(TokenKind::RBrace)
        
        Block { stmts, expr }
    }
    
    fn parse_stmt(mut self) -> Stmt {
        match self.peek().kind {
            TokenKind::Let => self.parse_let(),
            TokenKind::Return => self.parse_return(),
            TokenKind::Break => self.parse_break(),
            TokenKind::Continue => { self.advance(); Stmt::Continue },
            TokenKind::While => self.parse_while(),
            TokenKind::For => self.parse_for(),
            TokenKind::Loop => self.parse_loop(),
            _ => Stmt::Expr(self.parse_expr()),
        }
    }
    
    fn parse_let(mut self) -> Stmt {
        self.expect(TokenKind::Let)
        let name = self.expect_identifier()
        let ty = if self.match_token(TokenKind::Colon) {
            Some(self.parse_type())
        } else { None }
        let value = if self.match_token(TokenKind::Eq) {
            Some(self.parse_expr())
        } else { None }
        Stmt::Let(name, ty, value)
    }
    
    fn parse_return(mut self) -> Stmt {
        self.expect(TokenKind::Return)
        let value = if !self.check(TokenKind::RBrace) && !self.check(TokenKind::Semicolon) {
            Some(self.parse_expr())
        } else { None }
        Stmt::Return(value)
    }
    
    fn parse_break(mut self) -> Stmt {
        self.expect(TokenKind::Break)
        let value = if !self.check(TokenKind::RBrace) && !self.check(TokenKind::Semicolon) {
            Some(self.parse_expr())
        } else { None }
        Stmt::Break(value)
    }
    
    fn parse_while(mut self) -> Stmt {
        self.expect(TokenKind::While)
        let cond = self.parse_expr()
        let body = self.parse_block()
        Stmt::While(cond, body)
    }
    
    fn parse_for(mut self) -> Stmt {
        self.expect(TokenKind::For)
        let var = self.expect_identifier()
        self.expect(TokenKind::In)
        let iter = self.parse_expr()
        let body = self.parse_block()
        Stmt::For(var, iter, body)
    }
    
    fn parse_loop(mut self) -> Stmt {
        self.expect(TokenKind::Loop)
        let body = self.parse_block()
        Stmt::Loop(body)
    }
    
    fn parse_expr(mut self) -> Expr {
        self.parse_or()
    }
    
    fn parse_or(mut self) -> Expr {
        let mut left = self.parse_and()
        while self.match_token(TokenKind::Or2) {
            let right = self.parse_and()
            left = Expr::Binary(Box::new(left), BinOp::Or, Box::new(right))
        }
        left
    }
    
    fn parse_and(mut self) -> Expr {
        let mut left = self.parse_equality()
        while self.match_token(TokenKind::And2) {
            let right = self.parse_equality()
            left = Expr::Binary(Box::new(left), BinOp::And, Box::new(right))
        }
        left
    }
    
    fn parse_equality(mut self) -> Expr {
        let mut left = self.parse_comparison()
        while self.check(TokenKind::EqEq) || self.check(TokenKind::NotEq) {
            let op = if self.match_token(TokenKind::EqEq) { BinOp::Eq } else { self.advance(); BinOp::NotEq }
            let right = self.parse_comparison()
            left = Expr::Binary(Box::new(left), op, Box::new(right))
        }
        left
    }
    
    fn parse_comparison(mut self) -> Expr {
        let mut left = self.parse_term()
        while self.check(TokenKind::Lt) || self.check(TokenKind::Gt) || 
              self.check(TokenKind::LtEq) || self.check(TokenKind::GtEq) {
            let op = match self.advance().kind {
                TokenKind::Lt => BinOp::Lt,
                TokenKind::Gt => BinOp::Gt,
                TokenKind::LtEq => BinOp::LtEq,
                _ => BinOp::GtEq,
            }
            let right = self.parse_term()
            left = Expr::Binary(Box::new(left), op, Box::new(right))
        }
        left
    }
    
    fn parse_term(mut self) -> Expr {
        let mut left = self.parse_factor()
        while self.check(TokenKind::Plus) || self.check(TokenKind::Minus) {
            let op = if self.match_token(TokenKind::Plus) { BinOp::Add } else { self.advance(); BinOp::Sub }
            let right = self.parse_factor()
            left = Expr::Binary(Box::new(left), op, Box::new(right))
        }
        left
    }
    
    fn parse_factor(mut self) -> Expr {
        let mut left = self.parse_unary()
        while self.check(TokenKind::Star) || self.check(TokenKind::Slash) || self.check(TokenKind::Percent) {
            let op = match self.advance().kind {
                TokenKind::Star => BinOp::Mul,
                TokenKind::Slash => BinOp::Div,
                _ => BinOp::Mod,
            }
            let right = self.parse_unary()
            left = Expr::Binary(Box::new(left), op, Box::new(right))
        }
        left
    }
    
    fn parse_unary(mut self) -> Expr {
        if self.check(TokenKind::Minus) || self.check(TokenKind::Not2) {
            let op = if self.match_token(TokenKind::Minus) { UnaryOp::Neg } else { self.advance(); UnaryOp::Not }
            let right = self.parse_unary()
            Expr::Unary(op, Box::new(right))
        } else {
            self.parse_call()
        }
    }
    
    fn parse_call(mut self) -> Expr {
        let mut expr = self.parse_primary()
        
        loop {
            if self.match_token(TokenKind::LParen) {
                let mut args = Vec::new()
                while !self.check(TokenKind::RParen) {
                    args.push(self.parse_expr())
                    self.match_token(TokenKind::Comma)
                }
                self.expect(TokenKind::RParen)
                expr = Expr::Call(Box::new(expr), args)
            } else if self.match_token(TokenKind::Dot) {
                let field = self.expect_identifier()
                expr = Expr::Field(Box::new(expr), field)
            } else if self.match_token(TokenKind::LBracket) {
                let index = self.parse_expr()
                self.expect(TokenKind::RBracket)
                expr = Expr::Index(Box::new(expr), Box::new(index))
            } else {
                break
            }
        }
        expr
    }
    
    fn parse_primary(mut self) -> Expr {
        match self.peek().kind {
            TokenKind::IntLiteral => {
                let token = self.advance()
                Expr::Literal(LiteralExpr::Int(token.lexeme.parse_int()))
            },
            TokenKind::FloatLiteral => {
                let token = self.advance()
                Expr::Literal(LiteralExpr::Float(token.lexeme.parse_float()))
            },
            TokenKind::StringLiteral => {
                let token = self.advance()
                Expr::Literal(LiteralExpr::String(token.lexeme))
            },
            TokenKind::True => { self.advance(); Expr::Literal(LiteralExpr::Bool(true)) },
            TokenKind::False => { self.advance(); Expr::Literal(LiteralExpr::Bool(false)) },
            TokenKind::Nil => { self.advance(); Expr::Literal(LiteralExpr::Nil) },
            TokenKind::Identifier => {
                let name = self.advance().lexeme
                Expr::Identifier(name)
            },
            TokenKind::LParen => {
                self.advance()
                let expr = self.parse_expr()
                self.expect(TokenKind::RParen)
                expr
            },
            TokenKind::LBracket => {
                self.advance()
                let mut elements = Vec::new()
                while !self.check(TokenKind::RBracket) {
                    elements.push(self.parse_expr())
                    self.match_token(TokenKind::Comma)
                }
                self.expect(TokenKind::RBracket)
                Expr::Array(elements)
            },
            TokenKind::If => self.parse_if_expr(),
            TokenKind::Match => self.parse_match_expr(),
            TokenKind::LBrace => Expr::Block(self.parse_block()),
            _ => {
                self.advance()
                Expr::Literal(LiteralExpr::Nil)
            },
        }
    }
    
    fn parse_if_expr(mut self) -> Expr {
        self.expect(TokenKind::If)
        let cond = self.parse_expr()
        let then_block = self.parse_block()
        let else_block = if self.match_token(TokenKind::Else) {
            Some(Box::new(self.parse_block()))
        } else { None }
        Expr::If(Box::new(cond), Box::new(then_block), else_block)
    }
    
    fn parse_match_expr(mut self) -> Expr {
        self.expect(TokenKind::Match)
        let scrutinee = self.parse_expr()
        self.expect(TokenKind::LBrace)
        let mut arms = Vec::new()
        while !self.check(TokenKind::RBrace) {
            let pattern = self.parse_pattern()
            let guard = if self.match_token(TokenKind::If) {
                Some(self.parse_expr())
            } else { None }
            self.expect(TokenKind::FatArrow)
            let body = self.parse_expr()
            arms.push(MatchArm { pattern, guard, body })
            self.match_token(TokenKind::Comma)
        }
        self.expect(TokenKind::RBrace)
        Expr::Match(Box::new(scrutinee), arms)
    }
    
    fn parse_pattern(mut self) -> Pattern {
        match self.peek().kind {
            TokenKind::Identifier => {
                let name = self.advance().lexeme
                if name == "_" { Pattern::Wildcard }
                else { Pattern::Identifier(name) }
            },
            TokenKind::IntLiteral => {
                let token = self.advance()
                Pattern::Literal(LiteralExpr::Int(token.lexeme.parse_int()))
            },
            TokenKind::StringLiteral => {
                let token = self.advance()
                Pattern::Literal(LiteralExpr::String(token.lexeme))
            },
            TokenKind::True => { self.advance(); Pattern::Literal(LiteralExpr::Bool(true)) },
            TokenKind::False => { self.advance(); Pattern::Literal(LiteralExpr::Bool(false)) },
            _ => { self.advance(); Pattern::Wildcard },
        }
    }
    
    // Helper methods
    fn is_at_end(self) -> Bool {
        self.peek().kind == TokenKind::Eof
    }
    
    fn peek(self) -> Token {
        self.tokens[self.current]
    }
    
    fn advance(mut self) -> Token {
        if !self.is_at_end() { self.current += 1 }
        self.tokens[self.current - 1]
    }
    
    fn check(self, kind: TokenKind) -> Bool {
        !self.is_at_end() && self.peek().kind == kind
    }
    
    fn match_token(mut self, kind: TokenKind) -> Bool {
        if self.check(kind) { self.advance(); true }
        else { false }
    }
    
    fn expect(mut self, kind: TokenKind) {
        if !self.match_token(kind) {
            panic("Expected token: " + kind.to_string())
        }
    }
    
    fn expect_identifier(mut self) -> String {
        if self.check(TokenKind::Identifier) {
            self.advance().lexeme
        } else {
            panic("Expected identifier")
            ""
        }
    }
}

// Public API
pub fn parse(tokens: Vec<Token>) -> Module {
    Parser::new(tokens).parse()
}

test "parse simple function" {
    let tokens = tokenize("fn main() { }")
    let module = parse(tokens)
    assert(module.items.len() == 1)
}
