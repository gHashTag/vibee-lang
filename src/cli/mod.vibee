/// Vibee Lang CLI
/// Command-line interface for the Vibee compiler

use std::fs
use std::env
use std::process

use crate::lexer::tokenize
use crate::parser::parse
use crate::typechecker::check
use crate::ir::lower
use crate::codegen::{generate, Target}

const VERSION: String = "0.1.0"

pub struct CLI {
    args: Vec<String>,
}

impl CLI {
    pub fn new() -> CLI {
        CLI { args: env::args() }
    }
    
    pub fn run(mut self) -> Int {
        if self.args.len() < 2 {
            self.print_help()
            return 0
        }
        
        let command = self.args[1].clone()
        
        match command.as_str() {
            "build" => self.cmd_build(),
            "run" => self.cmd_run(),
            "check" => self.cmd_check(),
            "fmt" => self.cmd_fmt(),
            "test" => self.cmd_test(),
            "repl" => self.cmd_repl(),
            "new" => self.cmd_new(),
            "init" => self.cmd_init(),
            "doc" => self.cmd_doc(),
            "version" | "-v" | "--version" => self.cmd_version(),
            "help" | "-h" | "--help" => { self.print_help(); 0 },
            _ => {
                println("Unknown command: {}", command)
                self.print_help()
                1
            },
        }
    }
    
    fn cmd_build(self) -> Int {
        let file = self.get_file_arg()
        if file.is_empty() {
            println("Usage: vibee build <file.vibee>")
            return 1
        }
        
        let target = self.get_target()
        
        println("Compiling {}...", file)
        
        match self.compile(file.clone(), target) {
            Ok(output) => {
                let out_file = file.replace(".vibee", self.target_extension(target))
                fs::write(out_file.clone(), output)
                println("✅ Built: {}", out_file)
                0
            },
            Err(errors) => {
                for err in errors.iter() {
                    println("❌ Error: {}", err)
                }
                1
            },
        }
    }
    
    fn cmd_run(self) -> Int {
        let file = self.get_file_arg()
        if file.is_empty() {
            println("Usage: vibee run <file.vibee>")
            return 1
        }
        
        println("Running {}...", file)
        
        // Compile to JS and run with Node
        match self.compile(file.clone(), Target::JavaScript) {
            Ok(output) => {
                let temp_file = "/tmp/vibee_run.js"
                fs::write(temp_file, output)
                process::run("node", [temp_file])
            },
            Err(errors) => {
                for err in errors.iter() {
                    println("❌ Error: {}", err)
                }
                1
            },
        }
    }
    
    fn cmd_check(self) -> Int {
        let file = self.get_file_arg()
        if file.is_empty() {
            println("Usage: vibee check <file.vibee>")
            return 1
        }
        
        println("Checking {}...", file)
        
        let source = fs::read_to_string(file.clone())
        let tokens = tokenize(source)
        let module = parse(tokens)
        let errors = check(module)
        
        if errors.is_empty() {
            println("✅ No errors found")
            0
        } else {
            for err in errors.iter() {
                println("❌ {}", err.message)
            }
            1
        }
    }
    
    fn cmd_fmt(self) -> Int {
        let file = self.get_file_arg()
        if file.is_empty() {
            println("Usage: vibee fmt <file.vibee>")
            return 1
        }
        
        println("Formatting {}...", file)
        
        let source = fs::read_to_string(file.clone())
        let formatted = self.format_source(source)
        fs::write(file.clone(), formatted)
        
        println("✅ Formatted: {}", file)
        0
    }
    
    fn cmd_test(self) -> Int {
        let file = self.get_file_arg()
        
        println("Running tests...")
        
        let files = if file.is_empty() {
            fs::glob("**/*.vibee")
        } else {
            vec![file]
        }
        
        let mut passed = 0
        let mut failed = 0
        
        for f in files.iter() {
            let source = fs::read_to_string(f.clone())
            let tokens = tokenize(source)
            let module = parse(tokens)
            
            // Find and run test functions
            for item in module.items.iter() {
                if let Item::Function(def) = item {
                    if def.name.starts_with("test_") || def.has_attr("test") {
                        print("  {} ... ", def.name)
                        match self.run_test(def.clone()) {
                            Ok(_) => {
                                println("✅")
                                passed += 1
                            },
                            Err(msg) => {
                                println("❌ {}", msg)
                                failed += 1
                            },
                        }
                    }
                }
            }
        }
        
        println("")
        println("Results: {} passed, {} failed", passed, failed)
        
        if failed > 0 { 1 } else { 0 }
    }
    
    fn cmd_repl(self) -> Int {
        println("Vibee REPL v{}", VERSION)
        println("Type :help for help, :quit to exit")
        println("")
        
        let mut repl = REPL::new()
        repl.run()
        0
    }
    
    fn cmd_new(self) -> Int {
        let name = if self.args.len() > 2 {
            self.args[2].clone()
        } else {
            println("Usage: vibee new <project-name>")
            return 1
        }
        
        println("Creating new project: {}", name)
        
        // Create directory structure
        fs::create_dir(name.clone())
        fs::create_dir(format!("{}/src", name))
        fs::create_dir(format!("{}/tests", name))
        
        // Create main.vibee
        let main_content = r#"/// Main entry point

fn main() {
    println("Hello, Vibee!")
}
"#
        fs::write(format!("{}/src/main.vibee", name), main_content)
        
        // Create vibee.toml
        let toml_content = format!(r#"[package]
name = "{}"
version = "0.1.0"
edition = "2024"

[dependencies]
"#, name)
        fs::write(format!("{}/vibee.toml", name), toml_content)
        
        // Create .gitignore
        let gitignore = r#"target/
*.ll
*.wasm
*.js.map
"#
        fs::write(format!("{}/.gitignore", name), gitignore)
        
        println("✅ Created project: {}", name)
        println("")
        println("To get started:")
        println("  cd {}", name)
        println("  vibee run src/main.vibee")
        
        0
    }
    
    fn cmd_init(self) -> Int {
        println("Initializing Vibee project in current directory...")
        
        if !fs::exists("src") {
            fs::create_dir("src")
        }
        
        if !fs::exists("src/main.vibee") {
            let main_content = r#"/// Main entry point

fn main() {
    println("Hello, Vibee!")
}
"#
            fs::write("src/main.vibee", main_content)
        }
        
        if !fs::exists("vibee.toml") {
            let name = fs::current_dir().file_name()
            let toml_content = format!(r#"[package]
name = "{}"
version = "0.1.0"
edition = "2024"

[dependencies]
"#, name)
            fs::write("vibee.toml", toml_content)
        }
        
        println("✅ Initialized Vibee project")
        0
    }
    
    fn cmd_doc(self) -> Int {
        let file = self.get_file_arg()
        
        println("Generating documentation...")
        
        let files = if file.is_empty() {
            fs::glob("**/*.vibee")
        } else {
            vec![file]
        }
        
        fs::create_dir("docs")
        
        for f in files.iter() {
            let source = fs::read_to_string(f.clone())
            let tokens = tokenize(source)
            let module = parse(tokens)
            
            let doc = self.generate_doc(module)
            let doc_file = format!("docs/{}.md", f.replace(".vibee", "").replace("/", "_"))
            fs::write(doc_file, doc)
        }
        
        println("✅ Documentation generated in docs/")
        0
    }
    
    fn cmd_version(self) -> Int {
        println("Vibee Lang Compiler v{}", VERSION)
        println("Target: {}", env::target())
        0
    }
    
    fn print_help(self) {
        println("Vibee Lang Compiler v{}", VERSION)
        println("")
        println("USAGE:")
        println("    vibee <COMMAND> [OPTIONS]")
        println("")
        println("COMMANDS:")
        println("    build <file>     Compile a Vibee source file")
        println("    run <file>       Compile and run a Vibee program")
        println("    check <file>     Type-check without compiling")
        println("    fmt <file>       Format source code")
        println("    test [file]      Run tests")
        println("    repl             Start interactive REPL")
        println("    new <name>       Create a new project")
        println("    init             Initialize project in current directory")
        println("    doc [file]       Generate documentation")
        println("    version          Show version information")
        println("    help             Show this help message")
        println("")
        println("OPTIONS:")
        println("    --target <target>    Output target (llvm, wasm, js)")
        println("    --output <file>      Output file name")
        println("    --optimize           Enable optimizations")
        println("    --debug              Include debug information")
    }
    
    fn get_file_arg(self) -> String {
        if self.args.len() > 2 {
            self.args[2].clone()
        } else {
            String::new()
        }
    }
    
    fn get_target(self) -> Target {
        for i in 0..self.args.len() {
            if self.args[i] == "--target" && i + 1 < self.args.len() {
                return match self.args[i + 1].as_str() {
                    "llvm" => Target::LLVM,
                    "wasm" => Target::WASM,
                    "js" | "javascript" => Target::JavaScript,
                    _ => Target::LLVM,
                }
            }
        }
        Target::LLVM
    }
    
    fn target_extension(self, target: Target) -> String {
        match target {
            Target::LLVM => ".ll",
            Target::WASM => ".wasm",
            Target::JavaScript => ".js",
            Target::Native => "",
        }.to_string()
    }
    
    fn compile(self, file: String, target: Target) -> Result<String, Vec<String>> {
        let source = fs::read_to_string(file)
        
        // Lexing
        let tokens = tokenize(source)
        
        // Parsing
        let module = parse(tokens)
        
        // Type checking
        let errors = check(module.clone())
        if !errors.is_empty() {
            return Err(errors.iter().map(|e| e.message.clone()).collect())
        }
        
        // IR generation
        let ir = lower(module)
        
        // Code generation
        let output = generate(ir, target)
        
        Ok(output)
    }
    
    fn format_source(self, source: String) -> String {
        // Simple formatter - proper implementation would use AST
        let mut output = String::new()
        let mut indent = 0
        
        for line in source.lines() {
            let trimmed = line.trim()
            
            if trimmed.ends_with("}") && !trimmed.contains("{") {
                indent = (indent - 1).max(0)
            }
            
            for _ in 0..indent {
                output += "    "
            }
            output += trimmed
            output += "\n"
            
            if trimmed.ends_with("{") {
                indent += 1
            }
        }
        
        output
    }
    
    fn run_test(self, def: FnDef) -> Result<(), String> {
        // Compile and run test function
        // Returns Ok if test passes, Err with message if fails
        Ok(())
    }
    
    fn generate_doc(self, module: Module) -> String {
        let mut doc = String::new()
        doc += format!("# Module: {}\n\n", module.name)
        
        for item in module.items.iter() {
            match item {
                Item::Function(def) => {
                    if def.is_pub {
                        doc += format!("## fn {}\n\n", def.name)
                        doc += "```vibee\n"
                        doc += format!("fn {}(", def.name)
                        for (i, p) in def.params.iter().enumerate() {
                            if i > 0 { doc += ", " }
                            doc += format!("{}: {:?}", p.name, p.ty)
                        }
                        doc += ")"
                        if let Some(ret) = def.ret_type.clone() {
                            doc += format!(" -> {:?}", ret)
                        }
                        doc += "\n```\n\n"
                    }
                },
                Item::Struct(def) => {
                    if def.is_pub {
                        doc += format!("## struct {}\n\n", def.name)
                        doc += "```vibee\n"
                        doc += format!("struct {} {{\n", def.name)
                        for f in def.fields.iter() {
                            doc += format!("    {}: {:?},\n", f.name, f.ty)
                        }
                        doc += "}\n```\n\n"
                    }
                },
                _ => {},
            }
        }
        
        doc
    }
}

// REPL
pub struct REPL {
    history: Vec<String>,
    context: HashMap<String, TypeInfo>,
}

impl REPL {
    pub fn new() -> REPL {
        REPL {
            history: Vec::new(),
            context: HashMap::new(),
        }
    }
    
    pub fn run(mut self) -> Int {
        loop {
            print(">>> ")
            let input = io::read_line()
            
            if input.starts_with(":") {
                match self.handle_command(input) {
                    Some(0) => continue,
                    Some(code) => return code,
                    None => {},
                }
            } else {
                self.eval(input)
            }
        }
    }
    
    fn handle_command(mut self, cmd: String) -> Option<Int> {
        let parts: Vec<String> = cmd.split_whitespace().collect()
        let command = parts[0].as_str()
        
        match command {
            ":quit" | ":q" | ":exit" => Some(0),
            ":help" | ":h" | ":?" => {
                self.print_help()
                Some(0)
            },
            ":clear" => {
                self.context.clear()
                println("Context cleared")
                Some(0)
            },
            ":type" => {
                if parts.len() > 1 {
                    let expr = parts[1..].join(" ")
                    self.show_type(expr)
                }
                Some(0)
            },
            ":history" => {
                for (i, h) in self.history.iter().enumerate() {
                    println("{}: {}", i, h)
                }
                Some(0)
            },
            ":load" => {
                if parts.len() > 1 {
                    self.load_file(parts[1].clone())
                }
                Some(0)
            },
            _ => {
                println("Unknown command: {}", command)
                None
            },
        }
    }
    
    fn eval(mut self, input: String) {
        self.history.push(input.clone())
        
        // Wrap in function for evaluation
        let wrapped = format!("fn __repl__() {{ {} }}", input)
        
        let tokens = tokenize(wrapped)
        let module = parse(tokens)
        let errors = check(module.clone())
        
        if !errors.is_empty() {
            for err in errors.iter() {
                println("Error: {}", err.message)
            }
            return
        }
        
        // Compile to JS and evaluate
        let ir = lower(module)
        let js = generate(ir, Target::JavaScript)
        
        // Execute and print result
        let result = self.execute_js(js)
        if !result.is_empty() {
            println("{}", result)
        }
    }
    
    fn show_type(self, expr: String) {
        let wrapped = format!("fn __type__() {{ {} }}", expr)
        let tokens = tokenize(wrapped)
        let module = parse(tokens)
        
        // Get type of expression
        // This is simplified - real implementation would track types
        println("Type inference not yet implemented")
    }
    
    fn load_file(mut self, file: String) {
        let source = fs::read_to_string(file.clone())
        println("Loaded: {}", file)
        self.eval(source)
    }
    
    fn execute_js(self, js: String) -> String {
        // Execute JS and capture output
        // This is a placeholder - real implementation would use a JS runtime
        String::new()
    }
    
    fn print_help(self) {
        println("REPL Commands:")
        println("  :quit, :q      Exit the REPL")
        println("  :help, :h      Show this help")
        println("  :clear         Clear the context")
        println("  :type <expr>   Show type of expression")
        println("  :history       Show command history")
        println("  :load <file>   Load and evaluate a file")
    }
}

// Entry point
pub fn main() {
    let cli = CLI::new()
    let code = cli.run()
    process::exit(code)
}
