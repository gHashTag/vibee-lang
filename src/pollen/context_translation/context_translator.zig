// Generated by vibeec from context_aware_translation.vibee
// Module: context_translation
// Version: 2.0.0
// Description: Multi-layer context-aware translation with idiom support

const std = @import("std");

// Types

pub const IdiomDetection = struct {
    is_idiom: bool,
    idiom_id: []const u8,
    confidence: f32,
};

pub const IdiomMapping = struct {
    source_idiom: []const u8,
    target_idiom: []const u8,
    confidence: f32,
    meaning: []const u8,
    domain: []const u8,
};

// Idiom database
const IdiomDatabase = std.StringHashMap(IdiomMapping);

fn initIdiomDatabase(allocator: std.mem.Allocator) !IdiomDatabase {
    var db = IdiomDatabase.init(allocator);
    
    try db.put("break_a_leg", IdiomMapping{
        .source_idiom = "Break a leg",
        .target_idiom = "Ни пуха ни пера",
        .confidence = 0.95,
        .meaning = "Good luck",
        .domain = "Theater",
    });
    
    try db.put("raining_cats_and_dogs", IdiomMapping{
        .source_idiom = "It's raining cats and dogs",
        .target_idiom = "Льёт как из ведра",
        .confidence = 0.90,
        .meaning = "Heavy rain",
        .domain = "Weather",
    });
    
    try db.put("piece_of_cake", IdiomMapping{
        .source_idiom = "Piece of cake",
        .target_idiom = "Проще простого",
        .confidence = 0.85,
        .meaning = "Very easy",
        .domain = "General",
    });
    
    try db.put("hit_the_nail_on_the_head", IdiomMapping{
        .source_idiom = "Hit the nail on the head",
        .target_idiom = "Попасть в точку",
        .confidence = 0.90,
        .meaning = "Exactly right",
        .domain = "General",
    });
    
    try db.put("spill_the_beans", IdiomMapping{
        .source_idiom = "Spill the beans",
        .target_idiom = "Раскрыть секрет",
        .confidence = 0.80,
        .meaning = "Reveal a secret",
        .domain = "General",
    });
    
    return db;
}

// Functions

pub fn detectIdiom(allocator: std.mem.Allocator, phrase: []const u8) !IdiomDetection {
    var db = try initIdiomDatabase(allocator);
    defer db.deinit();
    
    // Normalize phrase (lowercase, remove punctuation)
    var normalized = try allocator.alloc(u8, phrase.len);
    defer allocator.free(normalized);
    
    var j: usize = 0;
    for (phrase) |c| {
        if (std.ascii.isAlphabetic(c) or c == ' ') {
            normalized[j] = std.ascii.toLower(c);
            j += 1;
        }
    }
    const clean_phrase = normalized[0..j];
    
    // Check if phrase matches any idiom
    var it = db.iterator();
    while (it.next()) |entry| {
        const idiom_id = entry.key_ptr.*;
        
        // Replace underscores with spaces for matching
        var idiom_with_spaces = try allocator.alloc(u8, idiom_id.len);
        defer allocator.free(idiom_with_spaces);
        
        for (idiom_id, 0..) |c, i| {
            idiom_with_spaces[i] = if (c == '_') ' ' else c;
        }
        
        // Simple substring match
        if (std.mem.indexOf(u8, clean_phrase, idiom_with_spaces) != null) {
            return IdiomDetection{
                .is_idiom = true,
                .idiom_id = idiom_id,
                .confidence = 0.95,
            };
        }
    }
    
    return IdiomDetection{
        .is_idiom = false,
        .idiom_id = "",
        .confidence = 0.0,
    };
}

pub fn translateIdiom(allocator: std.mem.Allocator, idiom_id: []const u8, target_lang: []const u8) !IdiomMapping {
    _ = target_lang; // Currently only supports Russian
    
    var db = try initIdiomDatabase(allocator);
    defer db.deinit();
    
    if (db.get(idiom_id)) |mapping| {
        return mapping;
    }
    
    return error.IdiomNotFound;
}

pub fn translateWithContext(allocator: std.mem.Allocator, text: []const u8) ![]const u8 {
    // Detect if text contains idiom
    const detection = try detectIdiom(allocator, text);
    
    if (detection.is_idiom) {
        // Translate idiom
        const mapping = try translateIdiom(allocator, detection.idiom_id, "russian");
        
        // Return target idiom (with punctuation if present)
        if (std.mem.endsWith(u8, text, "!")) {
            return try std.fmt.allocPrint(allocator, "{s}!", .{mapping.target_idiom});
        } else if (std.mem.endsWith(u8, text, ".")) {
            return try std.fmt.allocPrint(allocator, "{s}.", .{mapping.target_idiom});
        } else {
            return try allocator.dupe(u8, mapping.target_idiom);
        }
    }
    
    // Fall back to word-by-word translation
    return try allocator.dupe(u8, text);
}

// Test cases (from spec)

test "detect_idiom - break_a_leg_idiom" {
    const allocator = std.testing.allocator;
    
    const result = try detectIdiom(allocator, "Break a leg");
    
    try std.testing.expect(result.is_idiom);
    try std.testing.expectEqualStrings("break_a_leg", result.idiom_id);
}

test "detect_idiom - literal_break" {
    const allocator = std.testing.allocator;
    
    const result = try detectIdiom(allocator, "I broke my leg");
    
    try std.testing.expect(!result.is_idiom);
}

test "translate_idiom - break_a_leg_to_russian" {
    const allocator = std.testing.allocator;
    
    const result = try translateIdiom(allocator, "break_a_leg", "russian");
    
    try std.testing.expectEqualStrings("Ни пуха ни пера", result.target_idiom);
    try std.testing.expectApproxEqAbs(@as(f32, 0.95), result.confidence, 0.05);
}

test "translate_idiom - raining_cats_and_dogs" {
    const allocator = std.testing.allocator;
    
    const result = try translateIdiom(allocator, "raining_cats_and_dogs", "russian");
    
    try std.testing.expectEqualStrings("Льёт как из ведра", result.target_idiom);
    try std.testing.expectApproxEqAbs(@as(f32, 0.90), result.confidence, 0.05);
}

test "translate_with_context - theater_context" {
    const allocator = std.testing.allocator;
    
    const result = try translateWithContext(allocator, "Break a leg!");
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("Ни пуха ни пера!", result);
}

test "translate_with_context - all_idioms" {
    const allocator = std.testing.allocator;
    
    // Test all idioms
    const tests = [_]struct { input: []const u8, expected: []const u8 }{
        .{ .input = "Break a leg!", .expected = "Ни пуха ни пера!" },
        .{ .input = "It's raining cats and dogs", .expected = "Льёт как из ведра" },
        .{ .input = "Piece of cake", .expected = "Проще простого" },
        .{ .input = "Hit the nail on the head", .expected = "Попасть в точку" },
        .{ .input = "Spill the beans", .expected = "Раскрыть секрет" },
    };
    
    for (tests) |t| {
        const result = try translateWithContext(allocator, t.input);
        defer allocator.free(result);
        
        try std.testing.expectEqualStrings(t.expected, result);
    }
}
