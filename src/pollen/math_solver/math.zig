// Generated by vibeec from math_solver.vibee
// Module: math_solver
// Version: 1.0.0
// Description: Mathematical equation solver using VIBEE's universal transformation pattern

const std = @import("std");

// Types

pub const QuadraticSolution = struct {
    x1: f64,
    x2: f64,
    discriminant: f64,
    has_real_solutions: bool,
};

// Functions

pub fn solveQuadratic(a: f64, b: f64, c: f64) !QuadraticSolution {
    if (a == 0) {
        return error.NotQuadratic;
    }
    
    // Calculate discriminant: b² - 4ac
    const discriminant = b * b - 4 * a * c;
    
    if (discriminant < 0) {
        // No real solutions (complex solutions exist)
        return QuadraticSolution{
            .x1 = 0,
            .x2 = 0,
            .discriminant = discriminant,
            .has_real_solutions = false,
        };
    }
    
    // Calculate solutions using quadratic formula
    // x = (-b ± √discriminant) / 2a
    const sqrt_discriminant = @sqrt(discriminant);
    const x1 = (-b + sqrt_discriminant) / (2 * a);
    const x2 = (-b - sqrt_discriminant) / (2 * a);
    
    return QuadraticSolution{
        .x1 = x1,
        .x2 = x2,
        .discriminant = discriminant,
        .has_real_solutions = true,
    };
}

pub fn solveLinear(a: f64, b: f64) !f64 {
    if (a == 0) {
        return error.NotLinear;
    }
    
    // x = -b / a
    return -b / a;
}

pub fn calculateDiscriminant(a: f64, b: f64, c: f64) f64 {
    return b * b - 4 * a * c;
}

pub fn evaluatePolynomial(coefficients: []const f64, x: f64) f64 {
    var result: f64 = 0;
    var power: f64 = 1;
    
    for (coefficients) |coef| {
        result += coef * power;
        power *= x;
    }
    
    return result;
}

// Test cases (from spec)

test "solve_quadratic - simple_quadratic" {
    // x² - 5x + 6 = 0
    // Solutions: x = 3, x = 2
    const result = try solveQuadratic(1, -5, 6);
    
    try std.testing.expect(result.has_real_solutions);
    try std.testing.expectApproxEqAbs(@as(f64, 3.0), result.x1, 0.0001);
    try std.testing.expectApproxEqAbs(@as(f64, 2.0), result.x2, 0.0001);
}

test "solve_quadratic - perfect_square" {
    // x² - 2x + 1 = 0
    // (x - 1)² = 0
    // Solution: x = 1 (double root)
    const result = try solveQuadratic(1, -2, 1);
    
    try std.testing.expect(result.has_real_solutions);
    try std.testing.expectApproxEqAbs(@as(f64, 1.0), result.x1, 0.0001);
    try std.testing.expectApproxEqAbs(@as(f64, 1.0), result.x2, 0.0001);
    try std.testing.expectApproxEqAbs(@as(f64, 0.0), result.discriminant, 0.0001);
}

test "solve_quadratic - no_real_solutions" {
    // x² + 1 = 0
    // No real solutions (x = ±i)
    const result = try solveQuadratic(1, 0, 1);
    
    try std.testing.expect(!result.has_real_solutions);
    try std.testing.expect(result.discriminant < 0);
}

test "solve_linear - simple_linear" {
    // 2x - 6 = 0
    // x = 3
    const result = try solveLinear(2, -6);
    
    try std.testing.expectApproxEqAbs(@as(f64, 3.0), result, 0.0001);
}

test "solve_linear - negative_solution" {
    // 3x + 9 = 0
    // x = -3
    const result = try solveLinear(3, 9);
    
    try std.testing.expectApproxEqAbs(@as(f64, -3.0), result, 0.0001);
}

test "calculate_discriminant" {
    // x² - 5x + 6 = 0
    // Discriminant = 25 - 24 = 1
    const disc = calculateDiscriminant(1, -5, 6);
    
    try std.testing.expectApproxEqAbs(@as(f64, 1.0), disc, 0.0001);
}

test "evaluate_polynomial" {
    // x² + 2x + 1 at x = 2
    // 4 + 4 + 1 = 9
    const coefficients = [_]f64{ 1, 2, 1 }; // c + bx + ax²
    const result = evaluatePolynomial(&coefficients, 2);
    
    try std.testing.expectApproxEqAbs(@as(f64, 9.0), result, 0.0001);
}
