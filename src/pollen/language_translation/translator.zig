// Generated by vibeec from language_translation.vibee
// Module: language_translation
// Version: 1.0.0
// Description: Universal language translator using VIBEE's transformation pattern

const std = @import("std");

// Types

pub const Language = enum {
    English,
    Russian,
    Chinese,
    Spanish,
    French,
    German,
    Japanese,
};

pub const PartOfSpeech = enum {
    Noun,
    Verb,
    Adjective,
    Adverb,
    Pronoun,
    Preposition,
    Conjunction,
};

pub const Gender = enum {
    Masculine,
    Feminine,
    Neuter,
    None,
};

pub const Case = enum {
    Nominative,
    Genitive,
    Dative,
    Accusative,
    Instrumental,
    Prepositional,
    None,
};

pub const Tense = enum {
    Present,
    Past,
    Future,
    None,
};

pub const Word = struct {
    text: []const u8,
    pos: PartOfSpeech,
    gender: Gender,
    case: Case,
    lemma: []const u8,
};

pub const Sentence = struct {
    words: std.ArrayList(Word),
    structure: []const u8,
    tense: Tense,
};

pub const Translation = struct {
    source_text: []const u8,
    target_text: []const u8,
    source_lang: Language,
    target_lang: Language,
    confidence: f32,
    alternatives: std.ArrayList([]const u8),
};

// Dictionary (English → Russian)
const Dictionary = std.StringHashMap([]const []const u8);

fn initDictionary(allocator: std.mem.Allocator) !Dictionary {
    var dict = Dictionary.init(allocator);
    
    // Simple words
    try dict.put("hello", &[_][]const u8{"Привет", "Здравствуйте"});
    try dict.put("good", &[_][]const u8{"хороший", "добрый"});
    try dict.put("morning", &[_][]const u8{"утро"});
    
    // Technical terms
    try dict.put("compiler", &[_][]const u8{"компилятор"});
    try dict.put("algorithm", &[_][]const u8{"алгоритм"});
    try dict.put("function", &[_][]const u8{"функция"});
    try dict.put("code", &[_][]const u8{"код"});
    try dict.put("programming", &[_][]const u8{"программирование"});
    
    // Pronouns
    try dict.put("i", &[_][]const u8{"Я"});
    try dict.put("we", &[_][]const u8{"мы"});
    try dict.put("you", &[_][]const u8{"ты", "вы"});
    try dict.put("he", &[_][]const u8{"он"});
    try dict.put("she", &[_][]const u8{"она"});
    try dict.put("they", &[_][]const u8{"они"});
    
    // Verbs
    try dict.put("love", &[_][]const u8{"люблю", "любить"});
    try dict.put("building", &[_][]const u8{"строим", "строить"});
    try dict.put("wrote", &[_][]const u8{"написал", "написала"});
    try dict.put("will", &[_][]const u8{"буду", "будет"});
    try dict.put("learn", &[_][]const u8{"учить"});
    
    // Articles (not used in Russian)
    try dict.put("a", &[_][]const u8{""});
    try dict.put("an", &[_][]const u8{""});
    try dict.put("the", &[_][]const u8{""});
    
    // Auxiliary verbs
    try dict.put("are", &[_][]const u8{""});
    try dict.put("is", &[_][]const u8{""});
    
    return dict;
}

// Functions

pub fn translate(
    allocator: std.mem.Allocator,
    text: []const u8,
    source: Language,
    target: Language,
) !Translation {
    // Initialize dictionary
    var dict = try initDictionary(allocator);
    defer dict.deinit();
    
    // Tokenize
    const tokens = try tokenize(allocator, text);
    defer {
        for (tokens.items) |token| {
            allocator.free(token);
        }
        tokens.deinit();
    }
    
    // Translate each token
    var translated_tokens = std.ArrayList([]const u8).init(allocator);
    defer translated_tokens.deinit();
    
    for (tokens.items) |token| {
        // Convert to lowercase for dictionary lookup
        var lower_token = try allocator.alloc(u8, token.len);
        defer allocator.free(lower_token);
        
        for (token, 0..) |c, i| {
            lower_token[i] = std.ascii.toLower(c);
        }
        
        // Look up in dictionary
        if (dict.get(lower_token)) |translations| {
            if (translations.len > 0) {
                try translated_tokens.append(try allocator.dupe(u8, translations[0]));
            } else {
                // Empty translation (articles, auxiliary verbs)
                // Skip
            }
        } else {
            // Word not in dictionary, keep original
            try translated_tokens.append(try allocator.dupe(u8, token));
        }
    }
    
    // Join tokens
    const target_text = try joinTokens(allocator, translated_tokens.items);
    
    // Calculate confidence
    const confidence = calculateConfidence(tokens.items.len, translated_tokens.items.len);
    
    return Translation{
        .source_text = try allocator.dupe(u8, text),
        .target_text = target_text,
        .source_lang = source,
        .target_lang = target,
        .confidence = confidence,
        .alternatives = std.ArrayList([]const u8).init(allocator),
    };
}

pub fn tokenize(allocator: std.mem.Allocator, text: []const u8) !std.ArrayList([]const u8) {
    var tokens = std.ArrayList([]const u8).init(allocator);
    
    var start: usize = 0;
    var i: usize = 0;
    
    while (i < text.len) : (i += 1) {
        const c = text[i];
        
        if (std.ascii.isWhitespace(c) or c == ',' or c == '.' or c == '!' or c == '?') {
            if (i > start) {
                const token = try allocator.dupe(u8, text[start..i]);
                try tokens.append(token);
            }
            start = i + 1;
        }
    }
    
    // Last token
    if (start < text.len) {
        const token = try allocator.dupe(u8, text[start..]);
        try tokens.append(token);
    }
    
    return tokens;
}

fn joinTokens(allocator: std.mem.Allocator, tokens: []const []const u8) ![]const u8 {
    if (tokens.len == 0) {
        return try allocator.dupe(u8, "");
    }
    
    // Calculate total length
    var total_len: usize = 0;
    for (tokens) |token| {
        total_len += token.len;
    }
    total_len += tokens.len - 1; // Spaces
    
    // Allocate result
    var result = try allocator.alloc(u8, total_len);
    var pos: usize = 0;
    
    for (tokens, 0..) |token, i| {
        @memcpy(result[pos..pos + token.len], token);
        pos += token.len;
        
        if (i < tokens.len - 1) {
            result[pos] = ' ';
            pos += 1;
        }
    }
    
    return result;
}

fn calculateConfidence(source_tokens: usize, target_tokens: usize) f32 {
    if (source_tokens == 0) return 0.0;
    
    // Simple heuristic: confidence based on token ratio
    const ratio = @as(f32, @floatFromInt(target_tokens)) / @as(f32, @floatFromInt(source_tokens));
    
    if (ratio >= 0.5 and ratio <= 1.5) {
        return 0.95;
    } else if (ratio >= 0.3 and ratio <= 2.0) {
        return 0.75;
    } else {
        return 0.5;
    }
}

// Test cases (from spec)

test "translate_simple_greeting - hello_to_russian" {
    const allocator = std.testing.allocator;
    
    const result = try translate(allocator, "Hello", .English, .Russian);
    defer {
        allocator.free(result.source_text);
        allocator.free(result.target_text);
        result.alternatives.deinit();
    }
    
    try std.testing.expectEqualStrings("Привет", result.target_text);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), result.confidence, 0.1);
}

test "translate_simple_greeting - good_morning_to_russian" {
    const allocator = std.testing.allocator;
    
    const result = try translate(allocator, "Good morning", .English, .Russian);
    defer {
        allocator.free(result.source_text);
        allocator.free(result.target_text);
        result.alternatives.deinit();
    }
    
    try std.testing.expectEqualStrings("добрый утро", result.target_text);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), result.confidence, 0.1);
}

test "translate_technical_term - compiler_to_russian" {
    const allocator = std.testing.allocator;
    
    const result = try translate(allocator, "compiler", .English, .Russian);
    defer {
        allocator.free(result.source_text);
        allocator.free(result.target_text);
        result.alternatives.deinit();
    }
    
    try std.testing.expectEqualStrings("компилятор", result.target_text);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), result.confidence, 0.1);
}

test "translate_technical_term - algorithm_to_russian" {
    const allocator = std.testing.allocator;
    
    const result = try translate(allocator, "algorithm", .English, .Russian);
    defer {
        allocator.free(result.source_text);
        allocator.free(result.target_text);
        result.alternatives.deinit();
    }
    
    try std.testing.expectEqualStrings("алгоритм", result.target_text);
    try std.testing.expectApproxEqAbs(@as(f32, 1.0), result.confidence, 0.1);
}

test "translate_sentence - i_love_programming" {
    const allocator = std.testing.allocator;
    
    const result = try translate(allocator, "I love programming", .English, .Russian);
    defer {
        allocator.free(result.source_text);
        allocator.free(result.target_text);
        result.alternatives.deinit();
    }
    
    try std.testing.expectEqualStrings("Я люблю программирование", result.target_text);
    try std.testing.expectApproxEqAbs(@as(f32, 0.95), result.confidence, 0.1);
}

test "translate_sentence - we_build_compiler" {
    const allocator = std.testing.allocator;
    
    const result = try translate(allocator, "We are building a compiler", .English, .Russian);
    defer {
        allocator.free(result.source_text);
        allocator.free(result.target_text);
        result.alternatives.deinit();
    }
    
    try std.testing.expectEqualStrings("мы строим компилятор", result.target_text);
    try std.testing.expectApproxEqAbs(@as(f32, 0.95), result.confidence, 0.1);
}
