// Generated by vibeec from spec.vibee
// Module: auto_fixer
// Version: 1.0.0
// Description: Automatic violation fixer - converts manual code to specs

const std = @import("std");

// Types

pub const FixAction = enum {
    CreateSpec,
    RegenerateCode,
    ArchiveManual,
    ManualReview,
};

pub const FixConfig = struct {
    auto: bool,
    dry_run: bool,
    interactive: bool,
    backup: bool,
};

pub const Fix = struct {
    violation: Violation,
    action: FixAction,
    success: bool,
    spec_path: []const u8,
    archive_path: []const u8,
};

pub const FixResult = struct {
    fixed: usize,
    manual_review: usize,
    errors: usize,
    fixes: std.ArrayList(Fix),
};

pub const Violation = struct {
    file: []const u8,
    type: []const u8,
    severity: []const u8,
    message: []const u8,
};

pub const CodeAnalysis = struct {
    functions: std.ArrayList(FunctionInfo),
    types: std.ArrayList(TypeInfo),
    imports: std.ArrayList([]const u8),
};

pub const FunctionInfo = struct {
    name: []const u8,
    params: std.ArrayList(Param),
    return_type: []const u8,
};

pub const TypeInfo = struct {
    name: []const u8,
    fields: std.ArrayList(Field),
};

pub const Param = struct {
    name: []const u8,
    type: []const u8,
};

pub const Field = struct {
    name: []const u8,
    type: []const u8,
};

// Functions

pub fn fixViolations(allocator: std.mem.Allocator, violations: []const Violation, config: FixConfig) !FixResult {
    var fixes = std.ArrayList(Fix).init(allocator);
    var fixed: usize = 0;
    var manual_review: usize = 0;
    var errors: usize = 0;
    
    for (violations) |violation| {
        const fix_result = fixViolation(allocator, violation, config) catch |err| {
            std.debug.print("Error fixing {s}: {}\n", .{ violation.file, err });
            errors += 1;
            continue;
        };
        
        try fixes.append(fix_result);
        
        if (fix_result.success) {
            fixed += 1;
        } else {
            manual_review += 1;
        }
    }
    
    return FixResult{
        .fixed = fixed,
        .manual_review = manual_review,
        .errors = errors,
        .fixes = fixes,
    };
}

pub fn fixViolation(allocator: std.mem.Allocator, violation: Violation, _: FixConfig) !Fix {
    // Determine fix action
    const action = determineAction(violation);
    
    var spec_path: []const u8 = "";
    var archive_path: []const u8 = "";
    var success = false;
    
    switch (action) {
        .CreateSpec => {
            spec_path = try createSpecFromCode(allocator, violation.file);
            success = true;
        },
        .RegenerateCode => {
            const spec = try findSpecForFile(allocator, violation.file);
            _ = try regenerateCode(allocator, spec);
            success = true;
        },
        .ArchiveManual => {
            archive_path = try archiveFile(allocator, violation.file);
            success = true;
        },
        .ManualReview => {
            success = false;
        },
    }
    
    return Fix{
        .violation = violation,
        .action = action,
        .success = success,
        .spec_path = spec_path,
        .archive_path = archive_path,
    };
}

fn determineAction(violation: Violation) FixAction {
    // Simple heuristic: if file is in src/modules/, create spec
    if (std.mem.indexOf(u8, violation.file, "src/modules/") != null) {
        return .CreateSpec;
    }
    
    return .ManualReview;
}

pub fn createSpecFromCode(allocator: std.mem.Allocator, code_file: []const u8) ![]const u8 {
    // Analyze code
    const analysis = try analyzeCode(allocator, code_file);
    defer {
        analysis.functions.deinit();
        analysis.types.deinit();
        analysis.imports.deinit();
    }
    
    // Extract module name from path
    const module_name = extractModuleName(code_file);
    
    // Generate spec
    const spec_content = try generateSpec(allocator, analysis, module_name);
    
    // Determine spec path
    const spec_path = try std.fmt.allocPrint(allocator, "src/pollen/{s}/spec.vibee", .{module_name});
    
    // Write spec file
    const file = try std.fs.cwd().createFile(spec_path, .{});
    defer file.close();
    
    try file.writeAll(spec_content);
    
    return spec_path;
}

pub fn analyzeCode(allocator: std.mem.Allocator, code_file: []const u8) !CodeAnalysis {
    // Read file
    const file = try std.fs.cwd().openFile(code_file, .{});
    defer file.close();
    
    const content = try file.readToEndAlloc(allocator, 1024 * 1024); // 1MB max
    defer allocator.free(content);
    
    // Parse code (simplified)
    const functions = std.ArrayList(FunctionInfo).init(allocator);
    const types = std.ArrayList(TypeInfo).init(allocator);
    const imports = std.ArrayList([]const u8).init(allocator);
    
    // TODO: Implement proper parsing
    // For now, return empty analysis
    
    return CodeAnalysis{
        .functions = functions,
        .types = types,
        .imports = imports,
    };
}

pub fn generateSpec(allocator: std.mem.Allocator, analysis: CodeAnalysis, module_name: []const u8) ![]const u8 {
    var spec = std.ArrayList(u8).init(allocator);
    var writer = spec.writer();
    
    try writer.print("name: {s}\n", .{module_name});
    try writer.print("version: \"1.0.0\"\n", .{});
    try writer.print("language: zig\n", .{});
    try writer.print("module: {s}\n", .{module_name});
    try writer.print("target: {s}.zig\n", .{module_name});
    try writer.print("description: Auto-generated spec\n\n", .{});
    
    try writer.print("behaviors:\n", .{});
    for (analysis.functions.items) |func| {
        try writer.print("  - name: {s}\n", .{func.name});
        try writer.print("    given: Input provided\n", .{});
        try writer.print("    when: Function called\n", .{});
        try writer.print("    then: Result returned\n", .{});
        try writer.print("    test_cases: []\n\n", .{});
    }
    
    try writer.print("types: {{}}\n\n", .{});
    try writer.print("functions: []\n\n", .{});
    try writer.print("imports:\n", .{});
    try writer.print("  - std\n", .{});
    
    return spec.toOwnedSlice();
}

pub fn archiveFile(allocator: std.mem.Allocator, file: []const u8) ![]const u8 {
    // Create archive directory if needed
    std.fs.cwd().makeDir("src/archive") catch |err| {
        if (err != error.PathAlreadyExists) return err;
    };
    
    // Generate archive path
    const basename = std.fs.path.basename(file);
    const archive_path = try std.fmt.allocPrint(allocator, "src/archive/{s}.bak", .{basename});
    
    // Copy file to archive
    try std.fs.cwd().copyFile(file, std.fs.cwd(), archive_path, .{});
    
    // Delete original
    try std.fs.cwd().deleteFile(file);
    
    return archive_path;
}

pub fn regenerateCode(allocator: std.mem.Allocator, spec_path: []const u8) ![]const u8 {
    // Execute vibeec gen
    const result = try std.ChildProcess.exec(.{
        .allocator = allocator,
        .argv = &[_][]const u8{ "vibeec", "gen", spec_path },
    });
    
    defer allocator.free(result.stdout);
    defer allocator.free(result.stderr);
    
    if (result.term.Exited != 0) {
        return error.RegenerationFailed;
    }
    
    return try allocator.dupe(u8, result.stdout);
}

pub fn promptUser(allocator: std.mem.Allocator, message: []const u8, options: []const []const u8) ![]const u8 {
    const stdout = std.io.getStdOut().writer();
    const stdin = std.io.getStdIn().reader();
    
    try stdout.print("{s}\n", .{message});
    for (options, 0..) |option, i| {
        try stdout.print("  {d}. {s}\n", .{ i + 1, option });
    }
    try stdout.print("Choice: ", .{});
    
    var buf: [256]u8 = undefined;
    const input = try stdin.readUntilDelimiterOrEof(&buf, '\n');
    
    if (input) |choice| {
        return try allocator.dupe(u8, std.mem.trim(u8, choice, &std.ascii.whitespace));
    }
    
    return error.NoInput;
}

fn extractModuleName(path: []const u8) []const u8 {
    const basename = std.fs.path.basename(path);
    const stem = std.fs.path.stem(basename);
    return stem;
}

fn findSpecForFile(allocator: std.mem.Allocator, file: []const u8) ![]const u8 {
    const module_name = extractModuleName(file);
    return try std.fmt.allocPrint(allocator, "src/pollen/{s}/spec.vibee", .{module_name});
}

// Test cases (from spec)

test "fix_violation - fix_manual_code" {
    _ = std.testing.allocator;
    
    // This test would verify the fix
    // const fix = try fixViolation(allocator, violation, config);
    // try std.testing.expect(fix.success);
}

test "create_spec_from_code - generate_spec" {
    _ = std.testing.allocator;
    
    // This test would verify spec generation
    // const spec_path = try createSpecFromCode(allocator, "test.zig");
    // defer allocator.free(spec_path);
    // try std.testing.expect(spec_path.len > 0);
}

test "archive_file - archive_file" {
    _ = std.testing.allocator;
    
    // This test would verify file archiving
    // const archive_path = try archiveFile(allocator, "src/modules/test.zig");
    // defer allocator.free(archive_path);
    // try std.testing.expect(std.mem.indexOf(u8, archive_path, "src/archive/") != null);
}
