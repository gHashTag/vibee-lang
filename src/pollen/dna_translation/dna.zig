// Generated by vibeec from dna_translation.vibee
// Module: dna_translation
// Version: 1.0.0
// Description: DNA to protein translation using VIBEE's universal transformation pattern

const std = @import("std");

// Types

pub const AminoAcid = struct {
    name: []const u8,
    symbol: []const u8,
};

pub const Protein = struct {
    sequence: []const u8,
    length: usize,
};

// Genetic Code (Standard Codon Table)
const GeneticCode = std.StringHashMap(AminoAcid);

fn initGeneticCode(allocator: std.mem.Allocator) !GeneticCode {
    var code = GeneticCode.init(allocator);
    
    // Start codon
    try code.put("ATG", AminoAcid{ .name = "Methionine", .symbol = "M" });
    
    // Stop codons
    try code.put("TAA", AminoAcid{ .name = "Stop", .symbol = "*" });
    try code.put("TAG", AminoAcid{ .name = "Stop", .symbol = "*" });
    try code.put("TGA", AminoAcid{ .name = "Stop", .symbol = "*" });
    
    // Glycine (GGx)
    try code.put("GGG", AminoAcid{ .name = "Glycine", .symbol = "G" });
    try code.put("GGA", AminoAcid{ .name = "Glycine", .symbol = "G" });
    try code.put("GGT", AminoAcid{ .name = "Glycine", .symbol = "G" });
    try code.put("GGC", AminoAcid{ .name = "Glycine", .symbol = "G" });
    
    // Alanine (GCx)
    try code.put("GCG", AminoAcid{ .name = "Alanine", .symbol = "A" });
    try code.put("GCA", AminoAcid{ .name = "Alanine", .symbol = "A" });
    try code.put("GCT", AminoAcid{ .name = "Alanine", .symbol = "A" });
    try code.put("GCC", AminoAcid{ .name = "Alanine", .symbol = "A" });
    
    // Valine (GTx)
    try code.put("GTG", AminoAcid{ .name = "Valine", .symbol = "V" });
    try code.put("GTA", AminoAcid{ .name = "Valine", .symbol = "V" });
    try code.put("GTT", AminoAcid{ .name = "Valine", .symbol = "V" });
    try code.put("GTC", AminoAcid{ .name = "Valine", .symbol = "V" });
    
    // Leucine (TTx, CTx)
    try code.put("TTG", AminoAcid{ .name = "Leucine", .symbol = "L" });
    try code.put("TTA", AminoAcid{ .name = "Leucine", .symbol = "L" });
    try code.put("CTG", AminoAcid{ .name = "Leucine", .symbol = "L" });
    try code.put("CTA", AminoAcid{ .name = "Leucine", .symbol = "L" });
    try code.put("CTT", AminoAcid{ .name = "Leucine", .symbol = "L" });
    try code.put("CTC", AminoAcid{ .name = "Leucine", .symbol = "L" });
    
    return code;
}

// Functions

pub fn translateCodon(allocator: std.mem.Allocator, codon: []const u8) !AminoAcid {
    if (codon.len != 3) {
        return error.InvalidCodon;
    }
    
    var code = try initGeneticCode(allocator);
    defer code.deinit();
    
    if (code.get(codon)) |amino_acid| {
        return amino_acid;
    }
    
    return error.UnknownCodon;
}

pub fn translateSequence(allocator: std.mem.Allocator, dna: []const u8) !Protein {
    if (dna.len % 3 != 0) {
        return error.InvalidSequenceLength;
    }
    
    var code = try initGeneticCode(allocator);
    defer code.deinit();
    
    var protein_seq = std.ArrayList(u8).init(allocator);
    defer protein_seq.deinit();
    
    var i: usize = 0;
    while (i < dna.len) : (i += 3) {
        const codon = dna[i..i + 3];
        
        if (code.get(codon)) |amino_acid| {
            try protein_seq.appendSlice(amino_acid.symbol);
        } else {
            return error.UnknownCodon;
        }
    }
    
    const seq = try protein_seq.toOwnedSlice();
    return Protein{
        .sequence = seq,
        .length = seq.len,
    };
}

pub fn transcribeDnaToRna(allocator: std.mem.Allocator, dna: []const u8) ![]const u8 {
    var rna = try allocator.alloc(u8, dna.len);
    
    for (dna, 0..) |nucleotide, i| {
        rna[i] = switch (nucleotide) {
            'T' => 'U',
            'A' => 'A',
            'G' => 'G',
            'C' => 'C',
            else => return error.InvalidNucleotide,
        };
    }
    
    return rna;
}

pub fn reverseComplement(allocator: std.mem.Allocator, dna: []const u8) ![]const u8 {
    var complement = try allocator.alloc(u8, dna.len);
    
    var i: usize = 0;
    while (i < dna.len) : (i += 1) {
        const j = dna.len - 1 - i;
        complement[i] = switch (dna[j]) {
            'A' => 'T',
            'T' => 'A',
            'G' => 'C',
            'C' => 'G',
            else => return error.InvalidNucleotide,
        };
    }
    
    return complement;
}

// Test cases (from spec)

test "translate_codon - atg_to_methionine" {
    const allocator = std.testing.allocator;
    
    const result = try translateCodon(allocator, "ATG");
    
    try std.testing.expectEqualStrings("Methionine", result.name);
    try std.testing.expectEqualStrings("M", result.symbol);
}

test "translate_codon - taa_to_stop" {
    const allocator = std.testing.allocator;
    
    const result = try translateCodon(allocator, "TAA");
    
    try std.testing.expectEqualStrings("Stop", result.name);
    try std.testing.expectEqualStrings("*", result.symbol);
}

test "translate_codon - ggg_to_glycine" {
    const allocator = std.testing.allocator;
    
    const result = try translateCodon(allocator, "GGG");
    
    try std.testing.expectEqualStrings("Glycine", result.name);
    try std.testing.expectEqualStrings("G", result.symbol);
}

test "translate_sequence - simple_sequence" {
    const allocator = std.testing.allocator;
    
    const result = try translateSequence(allocator, "ATGGGG");
    defer allocator.free(result.sequence);
    
    try std.testing.expectEqualStrings("MG", result.sequence);
    try std.testing.expectEqual(@as(usize, 2), result.length);
}

test "translate_sequence - with_stop_codon" {
    const allocator = std.testing.allocator;
    
    const result = try translateSequence(allocator, "ATGGGGTAA");
    defer allocator.free(result.sequence);
    
    try std.testing.expectEqualStrings("MG*", result.sequence);
    try std.testing.expectEqual(@as(usize, 3), result.length);
}

test "transcribe_dna_to_rna - simple_transcription" {
    const allocator = std.testing.allocator;
    
    const result = try transcribeDnaToRna(allocator, "ATGC");
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("AUGC", result);
}

test "reverse_complement" {
    const allocator = std.testing.allocator;
    
    const result = try reverseComplement(allocator, "ATGC");
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("GCAT", result);
}
