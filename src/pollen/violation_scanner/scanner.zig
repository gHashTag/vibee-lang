// Generated by vibeec from spec.vibee
// Module: violation_scanner
// Version: 1.0.0
// Description: Repository scanner for manual code violations

const std = @import("std");

// Types

pub const Severity = enum {
    Critical,
    High,
    Medium,
    Low,
    Info,
};

pub const ViolationType = enum {
    ManualCode,
    WrongLocation,
    MissingSpec,
    EditedGenerated,
    EmptyDirectory,
};

pub const FileClassification = enum {
    Specification,
    Generated,
    Documentation,
    Configuration,
    Archive,
    Forbidden,
};

pub const Violation = struct {
    file: []const u8,
    type: ViolationType,
    severity: Severity,
    message: []const u8,
    fixable: bool,
    suggestion: []const u8,
};

pub const ScanConfig = struct {
    path: []const u8,
    recursive: bool,
    strict: bool,
    verbose: bool,
};

pub const ScanResult = struct {
    total_files: usize,
    scanned_files: usize,
    violations: std.ArrayList(Violation),
    clean: bool,
    duration_ms: i64,
};

pub const ScanStatistics = struct {
    total_files: usize,
    specs: usize,
    generated: usize,
    docs: usize,
    violations: usize,
    by_severity: std.AutoHashMap(Severity, usize),
};

// Functions

pub fn scanRepository(allocator: std.mem.Allocator, config: ScanConfig) !ScanResult {
    const start_time = std.time.milliTimestamp();
    
    var violations = std.ArrayList(Violation).init(allocator);
    var total_files: usize = 0;
    var scanned_files: usize = 0;
    
    // Scan directory recursively
    const files = try scanDirectory(allocator, config.path, config.recursive);
    defer allocator.free(files);
    
    total_files = files.len;
    
    for (files) |file| {
        const classification = classifyFile(file);
        
        if (try detectViolation(allocator, file, classification)) |violation| {
            try violations.append(violation);
        }
        
        scanned_files += 1;
    }
    
    const duration_ms = std.time.milliTimestamp() - start_time;
    
    return ScanResult{
        .total_files = total_files,
        .scanned_files = scanned_files,
        .violations = violations,
        .clean = violations.items.len == 0,
        .duration_ms = duration_ms,
    };
}

pub fn scanDirectory(allocator: std.mem.Allocator, path: []const u8, recursive: bool) ![][]const u8 {
    var files = std.ArrayList([]const u8).init(allocator);
    
    var dir = try std.fs.cwd().openDir(path, .{ .iterate = true });
    defer dir.close();
    
    var iterator = dir.iterate();
    
    while (try iterator.next()) |entry| {
        const full_path = try std.fs.path.join(allocator, &[_][]const u8{ path, entry.name });
        
        switch (entry.kind) {
            .file => {
                try files.append(full_path);
            },
            .directory => {
                if (recursive and !std.mem.eql(u8, entry.name, ".git") and !std.mem.eql(u8, entry.name, "node_modules")) {
                    const subfiles = try scanDirectory(allocator, full_path, recursive);
                    for (subfiles) |subfile| {
                        try files.append(subfile);
                    }
                }
            },
            else => {},
        }
    }
    
    return files.toOwnedSlice();
}

pub fn classifyFile(path: []const u8) FileClassification {
    // Check file extension and location
    if (std.mem.endsWith(u8, path, ".vibee")) {
        return .Specification;
    }
    
    if (std.mem.indexOf(u8, path, "src/pollen/") != null) {
        if (std.mem.endsWith(u8, path, ".zig")) {
            return .Specification; // Specs in pollen are allowed
        }
    }
    
    if (std.mem.indexOf(u8, path, "src/storage/") != null) {
        return .Generated;
    }
    
    if (std.mem.indexOf(u8, path, "docs/") != null or std.mem.endsWith(u8, path, ".md")) {
        return .Documentation;
    }
    
    if (std.mem.endsWith(u8, path, ".toml") or std.mem.endsWith(u8, path, ".json") or std.mem.endsWith(u8, path, ".yaml")) {
        return .Configuration;
    }
    
    if (std.mem.indexOf(u8, path, "src/archive/") != null) {
        return .Archive;
    }
    
    // Manual code in src/modules/ is forbidden
    if (std.mem.indexOf(u8, path, "src/modules/") != null) {
        return .Forbidden;
    }
    
    return .Forbidden;
}

pub fn detectViolation(allocator: std.mem.Allocator, path: []const u8, classification: FileClassification) !?Violation {
    switch (classification) {
        .Forbidden => {
            return Violation{
                .file = try allocator.dupe(u8, path),
                .type = .ManualCode,
                .severity = .Critical,
                .message = try std.fmt.allocPrint(allocator, "Manual code detected: {s}", .{path}),
                .fixable = true,
                .suggestion = try std.fmt.allocPrint(allocator, "Create spec in src/pollen/ and regenerate", .{}),
            };
        },
        else => return null,
    }
}

pub fn isAllowedFile(path: []const u8) bool {
    const classification = classifyFile(path);
    return classification != .Forbidden;
}

pub fn isManualCode(path: []const u8) bool {
    const classification = classifyFile(path);
    return classification == .Forbidden;
}

pub fn generateReport(allocator: std.mem.Allocator, result: ScanResult) ![]const u8 {
    var report = std.ArrayList(u8).init(allocator);
    var writer = report.writer();
    
    try writer.print("Scan Report\n", .{});
    try writer.print("===========\n\n", .{});
    try writer.print("Total files: {d}\n", .{result.total_files});
    try writer.print("Scanned files: {d}\n", .{result.scanned_files});
    try writer.print("Violations: {d}\n", .{result.violations.items.len});
    try writer.print("Clean: {}\n", .{result.clean});
    try writer.print("Duration: {d}ms\n\n", .{result.duration_ms});
    
    if (result.violations.items.len > 0) {
        try writer.print("Violations:\n", .{});
        for (result.violations.items) |violation| {
            try writer.print("  [{s}] {s}: {s}\n", .{ @tagName(violation.severity), violation.file, violation.message });
            if (violation.fixable) {
                try writer.print("    Suggestion: {s}\n", .{violation.suggestion});
            }
        }
    }
    
    return report.toOwnedSlice();
}

pub fn calculateStatistics(allocator: std.mem.Allocator, result: ScanResult) !ScanStatistics {
    var by_severity = std.AutoHashMap(Severity, usize).init(allocator);
    
    for (result.violations.items) |violation| {
        const count = by_severity.get(violation.severity) orelse 0;
        try by_severity.put(violation.severity, count + 1);
    }
    
    return ScanStatistics{
        .total_files = result.total_files,
        .specs = 0, // TODO: Count specs
        .generated = 0, // TODO: Count generated
        .docs = 0, // TODO: Count docs
        .violations = result.violations.items.len,
        .by_severity = by_severity,
    };
}

// Test cases (from spec)
test "scan_repository - clean_repository" {
    _ = std.testing.allocator;
    
    // This test would pass if src/pollen is clean
    // const result = try scanRepository(allocator, config);
    // defer result.violations.deinit();
    // try std.testing.expect(result.clean);
}

test "classify_file - classify_spec" {
    const path = "src/pollen/test/spec.vibee";
    const classification = classifyFile(path);
    try std.testing.expectEqual(FileClassification.Specification, classification);
}

test "classify_file - classify_manual_code" {
    const path = "src/modules/test.zig";
    const classification = classifyFile(path);
    try std.testing.expectEqual(FileClassification.Forbidden, classification);
}
