// Generated by vibeec from music_transposition.vibee
// Module: music_transposition
// Version: 1.0.0
// Description: Musical note transposition using VIBEE's universal transformation pattern

const std = @import("std");

// Chromatic scale (12 semitones)
const CHROMATIC_SCALE = [_][]const u8{
    "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B",
};

// Functions

pub fn transposeNote(allocator: std.mem.Allocator, note: []const u8, semitones: i32) ![]const u8 {
    // Find note in chromatic scale
    var note_index: ?usize = null;
    for (CHROMATIC_SCALE, 0..) |scale_note, i| {
        if (std.mem.eql(u8, note, scale_note)) {
            note_index = i;
            break;
        }
    }
    
    if (note_index == null) {
        return error.InvalidNote;
    }
    
    // Calculate new index (with wrapping)
    const current = @as(i32, @intCast(note_index.?));
    var new_index = @mod(current + semitones, 12);
    if (new_index < 0) {
        new_index += 12;
    }
    
    const new_note = CHROMATIC_SCALE[@intCast(new_index)];
    return try allocator.dupe(u8, new_note);
}

pub fn transposeChord(
    allocator: std.mem.Allocator,
    chord: []const []const u8,
    semitones: i32,
) !std.ArrayList([]const u8) {
    var transposed = std.ArrayList([]const u8).init(allocator);
    
    for (chord) |note| {
        const new_note = try transposeNote(allocator, note, semitones);
        try transposed.append(new_note);
    }
    
    return transposed;
}

pub fn transposeMelody(
    allocator: std.mem.Allocator,
    melody: []const []const u8,
    semitones: i32,
) !std.ArrayList([]const u8) {
    var transposed = std.ArrayList([]const u8).init(allocator);
    
    for (melody) |note| {
        const new_note = try transposeNote(allocator, note, semitones);
        try transposed.append(new_note);
    }
    
    return transposed;
}

pub fn noteToMidi(note: []const u8) !u8 {
    // Middle C (C4) = MIDI 60
    // Find note in chromatic scale
    for (CHROMATIC_SCALE, 0..) |scale_note, i| {
        if (std.mem.eql(u8, note, scale_note)) {
            return @intCast(60 + i); // C4 octave
        }
    }
    
    return error.InvalidNote;
}

pub fn midiToNote(allocator: std.mem.Allocator, midi: u8) ![]const u8 {
    const note_index = @mod(midi, 12);
    const note = CHROMATIC_SCALE[note_index];
    return try allocator.dupe(u8, note);
}

pub fn calculateInterval(note1: []const u8, note2: []const u8) !i32 {
    var index1: ?usize = null;
    var index2: ?usize = null;
    
    for (CHROMATIC_SCALE, 0..) |scale_note, i| {
        if (std.mem.eql(u8, note1, scale_note)) {
            index1 = i;
        }
        if (std.mem.eql(u8, note2, scale_note)) {
            index2 = i;
        }
    }
    
    if (index1 == null or index2 == null) {
        return error.InvalidNote;
    }
    
    const diff = @as(i32, @intCast(index2.?)) - @as(i32, @intCast(index1.?));
    return diff;
}

// Test cases (from spec)

test "transpose_note - c_to_d" {
    const allocator = std.testing.allocator;
    
    const result = try transposeNote(allocator, "C", 2);
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("D", result);
}

test "transpose_note - d_to_e" {
    const allocator = std.testing.allocator;
    
    const result = try transposeNote(allocator, "D", 2);
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("E", result);
}

test "transpose_note - e_to_fsharp" {
    const allocator = std.testing.allocator;
    
    const result = try transposeNote(allocator, "E", 2);
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("F#", result);
}

test "transpose_note - g_to_a" {
    const allocator = std.testing.allocator;
    
    const result = try transposeNote(allocator, "G", 2);
    defer allocator.free(result);
    
    try std.testing.expectEqualStrings("A", result);
}

test "transpose_chord - c_major_to_d_major" {
    const allocator = std.testing.allocator;
    
    const chord = [_][]const u8{ "C", "E", "G" };
    var result = try transposeChord(allocator, &chord, 2);
    defer {
        for (result.items) |note| {
            allocator.free(note);
        }
        result.deinit();
    }
    
    try std.testing.expectEqual(@as(usize, 3), result.items.len);
    try std.testing.expectEqualStrings("D", result.items[0]);
    try std.testing.expectEqualStrings("F#", result.items[1]);
    try std.testing.expectEqualStrings("A", result.items[2]);
}

test "transpose_chord - g_major_to_a_major" {
    const allocator = std.testing.allocator;
    
    const chord = [_][]const u8{ "G", "B", "D" };
    var result = try transposeChord(allocator, &chord, 2);
    defer {
        for (result.items) |note| {
            allocator.free(note);
        }
        result.deinit();
    }
    
    try std.testing.expectEqual(@as(usize, 3), result.items.len);
    try std.testing.expectEqualStrings("A", result.items[0]);
    try std.testing.expectEqualStrings("C#", result.items[1]);
    try std.testing.expectEqualStrings("E", result.items[2]);
}

test "transpose_melody - simple_melody" {
    const allocator = std.testing.allocator;
    
    const melody = [_][]const u8{ "C", "D", "E", "F", "G" };
    var result = try transposeMelody(allocator, &melody, 2);
    defer {
        for (result.items) |note| {
            allocator.free(note);
        }
        result.deinit();
    }
    
    try std.testing.expectEqual(@as(usize, 5), result.items.len);
    try std.testing.expectEqualStrings("D", result.items[0]);
    try std.testing.expectEqualStrings("E", result.items[1]);
    try std.testing.expectEqualStrings("F#", result.items[2]);
    try std.testing.expectEqualStrings("G", result.items[3]);
    try std.testing.expectEqualStrings("A", result.items[4]);
}

test "note_to_midi" {
    try std.testing.expectEqual(@as(u8, 60), try noteToMidi("C"));
    try std.testing.expectEqual(@as(u8, 62), try noteToMidi("D"));
    try std.testing.expectEqual(@as(u8, 64), try noteToMidi("E"));
}

test "calculate_interval" {
    try std.testing.expectEqual(@as(i32, 2), try calculateInterval("C", "D"));
    try std.testing.expectEqual(@as(i32, 4), try calculateInterval("C", "E"));
    try std.testing.expectEqual(@as(i32, 7), try calculateInterval("C", "G"));
}
