/// Vibee Lang Type Checker
/// Performs type inference and validation

use crate::parser::{Module, Item, Expr, Stmt, Type, FnDef, StructDef, EnumDef}

// Type representation
pub enum TypeInfo {
    Unit,
    Bool,
    Int,
    Float,
    Char,
    String,
    Array(Box<TypeInfo>),
    Tuple(Vec<TypeInfo>),
    Function(Vec<TypeInfo>, Box<TypeInfo>),
    Struct(String, Vec<(String, TypeInfo)>),
    Enum(String, Vec<(String, Option<TypeInfo>)>),
    Generic(String),
    Reference(Box<TypeInfo>, Bool),
    Optional(Box<TypeInfo>),
    Never,
    Unknown,
    Error(String),
}

impl TypeInfo {
    pub fn is_numeric(self) -> Bool {
        match self {
            TypeInfo::Int | TypeInfo::Float => true,
            _ => false,
        }
    }
    
    pub fn is_comparable(self) -> Bool {
        match self {
            TypeInfo::Int | TypeInfo::Float | TypeInfo::Char | TypeInfo::String | TypeInfo::Bool => true,
            _ => false,
        }
    }
    
    pub fn equals(self, other: TypeInfo) -> Bool {
        match (self, other) {
            (TypeInfo::Unit, TypeInfo::Unit) => true,
            (TypeInfo::Bool, TypeInfo::Bool) => true,
            (TypeInfo::Int, TypeInfo::Int) => true,
            (TypeInfo::Float, TypeInfo::Float) => true,
            (TypeInfo::Char, TypeInfo::Char) => true,
            (TypeInfo::String, TypeInfo::String) => true,
            (TypeInfo::Array(a), TypeInfo::Array(b)) => a.equals(*b),
            (TypeInfo::Optional(a), TypeInfo::Optional(b)) => a.equals(*b),
            (TypeInfo::Struct(n1, _), TypeInfo::Struct(n2, _)) => n1 == n2,
            (TypeInfo::Enum(n1, _), TypeInfo::Enum(n2, _)) => n1 == n2,
            (TypeInfo::Generic(a), TypeInfo::Generic(b)) => a == b,
            _ => false,
        }
    }
}

// Symbol table
pub struct Symbol {
    pub name: String,
    pub ty: TypeInfo,
    pub mutable: Bool,
    pub scope: Int,
}

pub struct SymbolTable {
    symbols: Vec<Symbol>,
    scope_depth: Int,
}

impl SymbolTable {
    pub fn new() -> SymbolTable {
        SymbolTable { symbols: Vec::new(), scope_depth: 0 }
    }
    
    pub fn enter_scope(mut self) {
        self.scope_depth += 1
    }
    
    pub fn exit_scope(mut self) {
        self.symbols.retain(|s| s.scope < self.scope_depth)
        self.scope_depth -= 1
    }
    
    pub fn define(mut self, name: String, ty: TypeInfo, mutable: Bool) {
        self.symbols.push(Symbol { name, ty, mutable, scope: self.scope_depth })
    }
    
    pub fn lookup(self, name: String) -> Option<Symbol> {
        for i in (0..self.symbols.len()).rev() {
            if self.symbols[i].name == name {
                return Some(self.symbols[i].clone())
            }
        }
        None
    }
}

// Type environment
pub struct TypeEnv {
    structs: HashMap<String, StructDef>,
    enums: HashMap<String, EnumDef>,
    functions: HashMap<String, FnDef>,
    traits: HashMap<String, TraitDef>,
}

impl TypeEnv {
    pub fn new() -> TypeEnv {
        TypeEnv {
            structs: HashMap::new(),
            enums: HashMap::new(),
            functions: HashMap::new(),
            traits: HashMap::new(),
        }
    }
    
    pub fn register_struct(mut self, def: StructDef) {
        self.structs.insert(def.name.clone(), def)
    }
    
    pub fn register_enum(mut self, def: EnumDef) {
        self.enums.insert(def.name.clone(), def)
    }
    
    pub fn register_function(mut self, def: FnDef) {
        self.functions.insert(def.name.clone(), def)
    }
    
    pub fn get_struct(self, name: String) -> Option<StructDef> {
        self.structs.get(name)
    }
    
    pub fn get_enum(self, name: String) -> Option<EnumDef> {
        self.enums.get(name)
    }
    
    pub fn get_function(self, name: String) -> Option<FnDef> {
        self.functions.get(name)
    }
}

// Type checker
pub struct TypeChecker {
    env: TypeEnv,
    symbols: SymbolTable,
    errors: Vec<TypeError>,
    current_fn_ret: Option<TypeInfo>,
}

pub struct TypeError {
    pub message: String,
    pub span: Span,
}

impl TypeChecker {
    pub fn new() -> TypeChecker {
        TypeChecker {
            env: TypeEnv::new(),
            symbols: SymbolTable::new(),
            errors: Vec::new(),
            current_fn_ret: None,
        }
    }
    
    pub fn check(mut self, module: Module) -> Vec<TypeError> {
        // First pass: collect type definitions
        for item in module.items.iter() {
            match item {
                Item::Struct(def) => self.env.register_struct(def.clone()),
                Item::Enum(def) => self.env.register_enum(def.clone()),
                Item::Function(def) => self.env.register_function(def.clone()),
                _ => {},
            }
        }
        
        // Second pass: type check
        for item in module.items.iter() {
            self.check_item(item)
        }
        
        self.errors
    }
    
    fn check_item(mut self, item: Item) {
        match item {
            Item::Function(def) => self.check_function(def),
            Item::Struct(def) => self.check_struct(def),
            Item::Enum(def) => self.check_enum(def),
            Item::Impl(def) => self.check_impl(def),
            _ => {},
        }
    }
    
    fn check_function(mut self, def: FnDef) {
        self.symbols.enter_scope()
        
        // Add parameters to scope
        for param in def.params.iter() {
            let ty = self.resolve_type(param.ty.clone())
            self.symbols.define(param.name.clone(), ty, false)
        }
        
        // Set return type for checking return statements
        self.current_fn_ret = def.ret_type.map(|t| self.resolve_type(t))
        
        // Check body
        if let Some(body) = def.body {
            let body_type = self.check_block(body)
            
            // Verify return type
            if let Some(expected) = self.current_fn_ret.clone() {
                if !body_type.equals(expected.clone()) && !body_type.equals(TypeInfo::Never) {
                    self.error(format!("Function '{}' expected return type {:?}, got {:?}", 
                        def.name, expected, body_type))
                }
            }
        }
        
        self.current_fn_ret = None
        self.symbols.exit_scope()
    }
    
    fn check_struct(mut self, def: StructDef) {
        for field in def.fields.iter() {
            let ty = self.resolve_type(field.ty.clone())
            if ty.equals(TypeInfo::Error("".to_string())) {
                self.error(format!("Unknown type in struct field '{}'", field.name))
            }
        }
    }
    
    fn check_enum(mut self, def: EnumDef) {
        for variant in def.variants.iter() {
            if let Some(fields) = variant.fields.clone() {
                for field_ty in fields.iter() {
                    let ty = self.resolve_type(field_ty.clone())
                    if ty.equals(TypeInfo::Error("".to_string())) {
                        self.error(format!("Unknown type in enum variant '{}'", variant.name))
                    }
                }
            }
        }
    }
    
    fn check_impl(mut self, def: ImplDef) {
        for method in def.methods.iter() {
            self.check_function(method.clone())
        }
    }
    
    fn check_block(mut self, block: Block) -> TypeInfo {
        self.symbols.enter_scope()
        
        let mut last_type = TypeInfo::Unit
        for stmt in block.stmts.iter() {
            last_type = self.check_stmt(stmt.clone())
        }
        
        if let Some(expr) = block.expr {
            last_type = self.check_expr(*expr)
        }
        
        self.symbols.exit_scope()
        last_type
    }
    
    fn check_stmt(mut self, stmt: Stmt) -> TypeInfo {
        match stmt {
            Stmt::Let(name, ty_ann, value) => {
                let ty = if let Some(init) = value {
                    let init_ty = self.check_expr(init)
                    if let Some(ann) = ty_ann {
                        let expected = self.resolve_type(ann)
                        if !init_ty.equals(expected.clone()) {
                            self.error(format!("Type mismatch: expected {:?}, got {:?}", expected, init_ty))
                        }
                        expected
                    } else {
                        init_ty
                    }
                } else if let Some(ann) = ty_ann {
                    self.resolve_type(ann)
                } else {
                    self.error("Cannot infer type without initializer")
                    TypeInfo::Unknown
                };
                self.symbols.define(name, ty, false)
                TypeInfo::Unit
            },
            Stmt::Expr(expr) => self.check_expr(expr),
            Stmt::Return(value) => {
                if let Some(expr) = value {
                    let ty = self.check_expr(expr)
                    if let Some(expected) = self.current_fn_ret.clone() {
                        if !ty.equals(expected.clone()) {
                            self.error(format!("Return type mismatch: expected {:?}, got {:?}", expected, ty))
                        }
                    }
                }
                TypeInfo::Never
            },
            Stmt::While(cond, body) => {
                let cond_ty = self.check_expr(cond)
                if !cond_ty.equals(TypeInfo::Bool) {
                    self.error("While condition must be Bool")
                }
                self.check_block(body);
                TypeInfo::Unit
            },
            Stmt::For(var, iter, body) => {
                let iter_ty = self.check_expr(iter)
                let elem_ty = match iter_ty {
                    TypeInfo::Array(inner) => *inner,
                    _ => {
                        self.error("For loop requires iterable")
                        TypeInfo::Unknown
                    },
                };
                self.symbols.enter_scope()
                self.symbols.define(var, elem_ty, false)
                self.check_block(body);
                self.symbols.exit_scope()
                TypeInfo::Unit
            },
            Stmt::Loop(body) => {
                self.check_block(body);
                TypeInfo::Never
            },
            _ => TypeInfo::Unit,
        }
    }
    
    fn check_expr(mut self, expr: Expr) -> TypeInfo {
        match expr {
            Expr::Literal(lit) => self.check_literal(lit),
            Expr::Identifier(name) => {
                if let Some(sym) = self.symbols.lookup(name.clone()) {
                    sym.ty
                } else {
                    self.error(format!("Undefined variable: {}", name))
                    TypeInfo::Unknown
                }
            },
            Expr::Binary(left, op, right) => {
                let left_ty = self.check_expr(*left)
                let right_ty = self.check_expr(*right)
                self.check_binary_op(op, left_ty, right_ty)
            },
            Expr::Unary(op, expr) => {
                let ty = self.check_expr(*expr)
                self.check_unary_op(op, ty)
            },
            Expr::Call(callee, args) => {
                let callee_ty = self.check_expr(*callee)
                match callee_ty {
                    TypeInfo::Function(params, ret) => {
                        if args.len() != params.len() {
                            self.error(format!("Expected {} arguments, got {}", params.len(), args.len()))
                        }
                        for (arg, param_ty) in args.iter().zip(params.iter()) {
                            let arg_ty = self.check_expr(arg.clone())
                            if !arg_ty.equals(param_ty.clone()) {
                                self.error(format!("Argument type mismatch: expected {:?}, got {:?}", param_ty, arg_ty))
                            }
                        }
                        *ret
                    },
                    _ => {
                        self.error("Cannot call non-function")
                        TypeInfo::Unknown
                    },
                }
            },
            Expr::Index(array, index) => {
                let array_ty = self.check_expr(*array)
                let index_ty = self.check_expr(*index)
                if !index_ty.equals(TypeInfo::Int) {
                    self.error("Array index must be Int")
                }
                match array_ty {
                    TypeInfo::Array(inner) => *inner,
                    TypeInfo::String => TypeInfo::Char,
                    _ => {
                        self.error("Cannot index non-array")
                        TypeInfo::Unknown
                    },
                }
            },
            Expr::Field(obj, field) => {
                let obj_ty = self.check_expr(*obj)
                match obj_ty {
                    TypeInfo::Struct(name, fields) => {
                        for (f_name, f_ty) in fields.iter() {
                            if *f_name == field {
                                return f_ty.clone()
                            }
                        }
                        self.error(format!("Unknown field '{}' on struct '{}'", field, name))
                        TypeInfo::Unknown
                    },
                    _ => {
                        self.error("Cannot access field on non-struct")
                        TypeInfo::Unknown
                    },
                }
            },
            Expr::If(cond, then_block, else_block) => {
                let cond_ty = self.check_expr(*cond)
                if !cond_ty.equals(TypeInfo::Bool) {
                    self.error("If condition must be Bool")
                }
                let then_ty = self.check_block(*then_block)
                if let Some(else_b) = else_block {
                    let else_ty = self.check_block(*else_b)
                    if !then_ty.equals(else_ty.clone()) {
                        self.error("If branches must have same type")
                    }
                    then_ty
                } else {
                    TypeInfo::Unit
                }
            },
            Expr::Match(scrutinee, arms) => {
                let scrutinee_ty = self.check_expr(*scrutinee)
                let mut result_ty: Option<TypeInfo> = None
                for arm in arms.iter() {
                    self.check_pattern(arm.pattern.clone(), scrutinee_ty.clone())
                    let arm_ty = self.check_expr(arm.body.clone())
                    if let Some(expected) = result_ty.clone() {
                        if !arm_ty.equals(expected.clone()) {
                            self.error("Match arms must have same type")
                        }
                    } else {
                        result_ty = Some(arm_ty)
                    }
                }
                result_ty.unwrap_or(TypeInfo::Unit)
            },
            Expr::Array(elements) => {
                if elements.is_empty() {
                    TypeInfo::Array(Box::new(TypeInfo::Unknown))
                } else {
                    let first_ty = self.check_expr(elements[0].clone())
                    for elem in elements.iter().skip(1) {
                        let elem_ty = self.check_expr(elem.clone())
                        if !elem_ty.equals(first_ty.clone()) {
                            self.error("Array elements must have same type")
                        }
                    }
                    TypeInfo::Array(Box::new(first_ty))
                }
            },
            Expr::Tuple(elements) => {
                let types: Vec<TypeInfo> = elements.iter()
                    .map(|e| self.check_expr(e.clone()))
                    .collect()
                TypeInfo::Tuple(types)
            },
            Expr::Block(block) => self.check_block(block),
            Expr::Lambda(params, body) => {
                self.symbols.enter_scope()
                let param_types: Vec<TypeInfo> = params.iter()
                    .map(|p| {
                        let ty = self.resolve_type(p.ty.clone())
                        self.symbols.define(p.name.clone(), ty.clone(), false)
                        ty
                    })
                    .collect()
                let ret_ty = self.check_expr(*body)
                self.symbols.exit_scope()
                TypeInfo::Function(param_types, Box::new(ret_ty))
            },
            _ => TypeInfo::Unknown,
        }
    }
    
    fn check_literal(self, lit: LiteralExpr) -> TypeInfo {
        match lit {
            LiteralExpr::Int(_) => TypeInfo::Int,
            LiteralExpr::Float(_) => TypeInfo::Float,
            LiteralExpr::String(_) => TypeInfo::String,
            LiteralExpr::Char(_) => TypeInfo::Char,
            LiteralExpr::Bool(_) => TypeInfo::Bool,
            LiteralExpr::Nil => TypeInfo::Unit,
        }
    }
    
    fn check_binary_op(mut self, op: BinOp, left: TypeInfo, right: TypeInfo) -> TypeInfo {
        match op {
            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Mod => {
                if left.is_numeric() && right.is_numeric() {
                    if left.equals(TypeInfo::Float) || right.equals(TypeInfo::Float) {
                        TypeInfo::Float
                    } else {
                        TypeInfo::Int
                    }
                } else if op == BinOp::Add && left.equals(TypeInfo::String) {
                    TypeInfo::String
                } else {
                    self.error("Invalid operands for arithmetic")
                    TypeInfo::Unknown
                }
            },
            BinOp::Eq | BinOp::NotEq => {
                if !left.equals(right.clone()) {
                    self.error("Cannot compare different types")
                }
                TypeInfo::Bool
            },
            BinOp::Lt | BinOp::Gt | BinOp::LtEq | BinOp::GtEq => {
                if !left.is_comparable() || !right.is_comparable() {
                    self.error("Invalid operands for comparison")
                }
                TypeInfo::Bool
            },
            BinOp::And | BinOp::Or => {
                if !left.equals(TypeInfo::Bool) || !right.equals(TypeInfo::Bool) {
                    self.error("Logical operators require Bool")
                }
                TypeInfo::Bool
            },
            BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor | BinOp::Shl | BinOp::Shr => {
                if !left.equals(TypeInfo::Int) || !right.equals(TypeInfo::Int) {
                    self.error("Bitwise operators require Int")
                }
                TypeInfo::Int
            },
        }
    }
    
    fn check_unary_op(mut self, op: UnaryOp, ty: TypeInfo) -> TypeInfo {
        match op {
            UnaryOp::Neg => {
                if !ty.is_numeric() {
                    self.error("Negation requires numeric type")
                }
                ty
            },
            UnaryOp::Not => {
                if !ty.equals(TypeInfo::Bool) {
                    self.error("Logical not requires Bool")
                }
                TypeInfo::Bool
            },
            UnaryOp::BitNot => {
                if !ty.equals(TypeInfo::Int) {
                    self.error("Bitwise not requires Int")
                }
                TypeInfo::Int
            },
            UnaryOp::Ref => TypeInfo::Reference(Box::new(ty), false),
            UnaryOp::Deref => {
                match ty {
                    TypeInfo::Reference(inner, _) => *inner,
                    _ => {
                        self.error("Cannot dereference non-reference")
                        TypeInfo::Unknown
                    },
                }
            },
        }
    }
    
    fn check_pattern(mut self, pattern: Pattern, expected: TypeInfo) {
        match pattern {
            Pattern::Wildcard => {},
            Pattern::Identifier(name) => {
                self.symbols.define(name, expected, false)
            },
            Pattern::Literal(lit) => {
                let lit_ty = self.check_literal(lit)
                if !lit_ty.equals(expected) {
                    self.error("Pattern type mismatch")
                }
            },
            _ => {},
        }
    }
    
    fn resolve_type(self, ty: Type) -> TypeInfo {
        match ty {
            Type::Named(name) => {
                match name.as_str() {
                    "Int" => TypeInfo::Int,
                    "Float" => TypeInfo::Float,
                    "Bool" => TypeInfo::Bool,
                    "Char" => TypeInfo::Char,
                    "String" => TypeInfo::String,
                    "()" => TypeInfo::Unit,
                    _ => {
                        if self.env.get_struct(name.clone()).is_some() {
                            TypeInfo::Struct(name, Vec::new())
                        } else if self.env.get_enum(name.clone()).is_some() {
                            TypeInfo::Enum(name, Vec::new())
                        } else {
                            TypeInfo::Generic(name)
                        }
                    },
                }
            },
            Type::Generic(name, args) => {
                let resolved_args: Vec<TypeInfo> = args.iter()
                    .map(|a| self.resolve_type(a.clone()))
                    .collect()
                match name.as_str() {
                    "Vec" | "Array" => TypeInfo::Array(Box::new(resolved_args[0].clone())),
                    "Option" => TypeInfo::Optional(Box::new(resolved_args[0].clone())),
                    _ => TypeInfo::Struct(name, Vec::new()),
                }
            },
            Type::Tuple(types) => {
                let resolved: Vec<TypeInfo> = types.iter()
                    .map(|t| self.resolve_type(t.clone()))
                    .collect()
                TypeInfo::Tuple(resolved)
            },
            Type::Array(inner, _) => {
                TypeInfo::Array(Box::new(self.resolve_type(*inner)))
            },
            Type::Function(params, ret) => {
                let param_types: Vec<TypeInfo> = params.iter()
                    .map(|p| self.resolve_type(p.clone()))
                    .collect()
                TypeInfo::Function(param_types, Box::new(self.resolve_type(*ret)))
            },
            Type::Reference(inner, mutable) => {
                TypeInfo::Reference(Box::new(self.resolve_type(*inner)), mutable)
            },
            Type::Optional(inner) => {
                TypeInfo::Optional(Box::new(self.resolve_type(*inner)))
            },
        }
    }
    
    fn error(mut self, message: String) {
        self.errors.push(TypeError { message, span: Span::default() })
    }
}

// Public API
pub fn check(module: Module) -> Vec<TypeError> {
    TypeChecker::new().check(module)
}

test "type check simple function" {
    let source = "fn add(a: Int, b: Int) -> Int { a + b }"
    let tokens = tokenize(source)
    let module = parse(tokens)
    let errors = check(module)
    assert(errors.is_empty())
}

test "type check error" {
    let source = "fn bad() -> Int { \"hello\" }"
    let tokens = tokenize(source)
    let module = parse(tokens)
    let errors = check(module)
    assert(!errors.is_empty())
}
