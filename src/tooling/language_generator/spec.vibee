name: language_generator
version: 1.0.0
description: Generate new programming language from VIBEE specification

metadata:
  author: VIBEE Team
  category: meta_programming
  tags: [codegen, language-design, compiler, bootstrap]

types:
  LanguageSpec:
    name: string
    version: string
    syntax: SyntaxSpec
    semantics: SemanticsSpec
    type_system: TypeSystemSpec
    
  GeneratedLanguage:
    name: string
    lexer: string
    parser: string
    type_checker: string
    code_generator: string
    runtime: string
    standard_library: string
    
  CodeGenConfig:
    target_language: string  # gleam, rust, typescript, python
    optimization_level: number
    include_runtime: boolean
    include_stdlib: boolean
    
  GenerationResult:
    success: boolean
    files_generated: list<GeneratedFile>
    errors: list<string>
    metrics: GenerationMetrics
    
  GeneratedFile:
    path: string
    content: string
    size_bytes: number
    
  GenerationMetrics:
    total_files: number
    total_lines: number
    generation_time_ms: number
    
constants:
  TEMPLATES:
    lexer_template: |
      // Generated Lexer for {language_name}
      
      type Token = {token_types}
      
      pub lex(source: String): Result<List<Token>, String> = {{
        source
          |> tokenize
          |> validate_tokens
      }}
      
      fn tokenize(source: String): List<Token> = {{
        // Tokenization logic
        {tokenization_rules}
      }}
      
    parser_template: |
      // Generated Parser for {language_name}
      
      type AST = {ast_types}
      
      pub parse(tokens: List<Token>): Result<AST, String> = {{
        tokens
          |> build_ast
          |> validate_ast
      }}
      
      fn build_ast(tokens: List<Token>): AST = {{
        // Parsing logic
        {parsing_rules}
      }}
      
    type_checker_template: |
      // Generated Type Checker for {language_name}
      
      type TypeEnv = Map<String, Type>
      
      pub type_check(ast: AST, env: TypeEnv): Result<TypedAST, String> = {{
        ast match {{
          {type_checking_rules}
        }}
      }}
      
    code_generator_template: |
      // Generated Code Generator for {language_name}
      
      pub generate(ast: TypedAST, target: String): Result<String, String> = {{
        ast match {{
          {code_generation_rules}
        }}
      }}
      
    runtime_template: |
      // Generated Runtime for {language_name}
      
      pub type Runtime = {{
        memory: MemoryManager,
        scheduler: Scheduler,
        gc: GarbageCollector
      }}
      
      pub init_runtime(): Runtime = {{
        Runtime(
          memory: init_memory(),
          scheduler: init_scheduler(),
          gc: init_gc()
        )
      }}
      
    stdlib_template: |
      // Generated Standard Library for {language_name}
      
      // Core functions
      {core_functions}
      
      // Collections
      {collection_functions}
      
      // IO
      {io_functions}

behaviors:
  generate_language:
    input:
      spec: LanguageSpec
      config: CodeGenConfig
    output: GeneratedLanguage
    description: Generate complete language from specification
    steps:
      - Parse language specification
      - Generate lexer from syntax rules
      - Generate parser from grammar
      - Generate type checker from type system
      - Generate code generator for target
      - Generate runtime if needed
      - Generate standard library
      - Return generated language
      
  generate_lexer:
    input:
      syntax: SyntaxSpec
      target: string
    output:
      lexer_code: string
    description: Generate lexer from syntax specification
    steps:
      - Extract keywords and operators
      - Generate token types
      - Generate tokenization rules
      - Apply lexer template
      - Return lexer code
      
  generate_parser:
    input:
      grammar: Grammar
      target: string
    output:
      parser_code: string
    description: Generate parser from grammar
    steps:
      - Extract grammar rules
      - Generate AST types
      - Generate parsing functions
      - Apply parser template
      - Return parser code
      
  generate_type_checker:
    input:
      type_system: TypeSystemSpec
      target: string
    output:
      type_checker_code: string
    description: Generate type checker
    steps:
      - Extract type rules
      - Generate type checking functions
      - Generate type inference logic
      - Apply type checker template
      - Return type checker code
      
  generate_code_gen:
    input:
      semantics: SemanticsSpec
      target: string
    output:
      codegen_code: string
    description: Generate code generator
    steps:
      - Extract semantic rules
      - Generate code generation functions
      - Generate optimization passes
      - Apply code generator template
      - Return code generator code
      
  generate_runtime:
    input:
      runtime_spec: RuntimeSpec
      target: string
    output:
      runtime_code: string
    description: Generate runtime system
    steps:
      - Generate memory manager
      - Generate scheduler
      - Generate garbage collector
      - Apply runtime template
      - Return runtime code
      
  generate_stdlib:
    input:
      stdlib_spec: StdLibSpec
      target: string
    output:
      stdlib_code: string
    description: Generate standard library
    steps:
      - Generate core functions
      - Generate collection functions
      - Generate IO functions
      - Apply stdlib template
      - Return stdlib code
      
  bootstrap_compiler:
    input:
      spec: LanguageSpec
    output:
      compiler: GeneratedLanguage
    description: Bootstrap self-hosting compiler
    steps:
      - Generate initial compiler in host language
      - Compile language spec with initial compiler
      - Generate self-hosting compiler
      - Verify equivalence
      - Return self-hosting compiler
      
  validate_generated_code:
    input:
      generated: GeneratedLanguage
    output:
      valid: boolean
      errors: list<string>
    description: Validate generated code
    steps:
      - Compile generated code
      - Run test suite
      - Check for errors
      - Return validation result

functions:
  - name: apply_template
    params:
      template: string
      context: map<string, any>
    returns: string
    description: Apply template with context
    
  - name: generate_token_types
    params:
      keywords: list<string>
      operators: list<string>
    returns: string
    description: Generate token type definitions
    
  - name: generate_ast_types
    params:
      grammar: Grammar
    returns: string
    description: Generate AST type definitions
    
  - name: optimize_generated_code
    params:
      code: string
      level: number
    returns: string
    description: Optimize generated code

tests:
  - name: generate_simple_language
    behavior: generate_language
    input:
      spec:
        name: "SimpleLang"
        syntax:
          keywords: ["let", "if", "else"]
          operators: ["+", "-"]
      config:
        target_language: "gleam"
        optimization_level: 2
    expected:
      name: "SimpleLang"
      lexer: contains("Token")
      parser: contains("AST")
      
  - name: generate_lexer_from_syntax
    behavior: generate_lexer
    input:
      syntax:
        keywords: ["let", "fn", "type"]
        operators: ["+", "-", "*", "/"]
      target: "gleam"
    expected:
      lexer_code: contains("pub lex")
      lexer_code: contains("Token")
      
  - name: generate_parser_from_grammar
    behavior: generate_parser
    input:
      grammar:
        rules:
          - non_terminal: "Expr"
            productions: ["Term", "Expr + Term"]
      target: "gleam"
    expected:
      parser_code: contains("pub parse")
      parser_code: contains("AST")
      
  - name: bootstrap_self_hosting_compiler
    behavior: bootstrap_compiler
    input:
      spec:
        name: "VIBEE"
        version: "2.0.0"
    expected:
      compiler.lexer: not_empty
      compiler.parser: not_empty
      compiler.type_checker: not_empty
      
  - name: validate_generated_compiler
    behavior: validate_generated_code
    input:
      generated:
        name: "TestLang"
        lexer: "pub lex() = ..."
        parser: "pub parse() = ..."
    expected:
      valid: true
      errors: []

examples:
  - name: "Generate Calculator Language"
    description: "Generate a simple calculator language"
    code: |
      let calc_spec = LanguageSpec(
        name: "CalcLang",
        syntax: SyntaxSpec(
          keywords: [],
          operators: ["+", "-", "*", "/", "(", ")"],
          literals: ["number"]
        ),
        semantics: SemanticsSpec(
          evaluation: "eager"
        ),
        type_system: TypeSystemSpec(
          types: ["Number"]
        )
      )
      
      let calc_lang = generate_language(
        spec: calc_spec,
        config: CodeGenConfig(
          target_language: "gleam",
          optimization_level: 2,
          include_runtime: false,
          include_stdlib: false
        )
      )
      
      // Generated files:
      // - calc_lang_lexer.gleam
      // - calc_lang_parser.gleam
      // - calc_lang_eval.gleam
      
  - name: "Generate VIBEE V2 Compiler"
    description: "Generate VIBEE V2 compiler from meta-spec"
    code: |
      // Load VIBEE V2 specification
      let vibee_v2_spec = load_spec("language_spec.yml")
      
      // Generate compiler
      let vibee_v2_compiler = generate_language(
        spec: vibee_v2_spec,
        config: CodeGenConfig(
          target_language: "gleam",
          optimization_level: 3,
          include_runtime: true,
          include_stdlib: true
        )
      )
      
      // Bootstrap: compile VIBEE with VIBEE
      let self_hosting = bootstrap_compiler(vibee_v2_spec)
      
      // Verify equivalence
      assert validate_generated_code(self_hosting).valid
      
  - name: "Generate Multi-Target Compiler"
    description: "Generate compiler for multiple backends"
    code: |
      let targets = ["gleam", "javascript", "wasm", "native"]
      
      let compilers = targets.map(target => {
        generate_language(
          spec: vibee_v2_spec,
          config: CodeGenConfig(
            target_language: target,
            optimization_level: 3,
            include_runtime: true,
            include_stdlib: true
          )
        )
      })
      
      // Now we have VIBEE compilers for all targets!

cli_commands:
  generate:
    description: "Generate language from specification"
    usage: "vibee generate [options] <spec.yml>"
    options:
      - "--target": "Target language (gleam, rust, typescript, python)"
      - "--output": "Output directory"
      - "--optimize": "Optimization level (0-3)"
      - "--runtime": "Include runtime system"
      - "--stdlib": "Include standard library"
    examples:
      - "vibee generate language_spec.yml"
      - "vibee generate --target rust --optimize 3 spec.yml"
      - "vibee generate --output ./generated spec.yml"
      
  bootstrap:
    description: "Bootstrap self-hosting compiler"
    usage: "vibee bootstrap <spec.yml>"
    examples:
      - "vibee bootstrap language_spec.yml"
      
  validate:
    description: "Validate generated language"
    usage: "vibee validate <generated_dir>"
    examples:
      - "vibee validate ./generated"

generation_pipeline:
  steps:
    - name: "Parse Specification"
      input: "spec.yml"
      output: "LanguageSpec"
      
    - name: "Generate Lexer"
      input: "LanguageSpec.syntax"
      output: "lexer.gleam"
      
    - name: "Generate Parser"
      input: "LanguageSpec.grammar"
      output: "parser.gleam"
      
    - name: "Generate Type Checker"
      input: "LanguageSpec.type_system"
      output: "type_checker.gleam"
      
    - name: "Generate Code Generator"
      input: "LanguageSpec.semantics"
      output: "codegen.gleam"
      
    - name: "Generate Runtime"
      input: "LanguageSpec.runtime"
      output: "runtime.gleam"
      
    - name: "Generate Standard Library"
      input: "LanguageSpec.stdlib"
      output: "stdlib.gleam"
      
    - name: "Compile Generated Code"
      input: "*.gleam"
      output: "compiler binary"
      
    - name: "Validate"
      input: "compiler binary"
      output: "validation report"

metrics:
  generation_speed:
    simple_language: "< 1 second"
    medium_language: "< 5 seconds"
    complex_language: "< 30 seconds"
    
  code_quality:
    type_safety: "100%"
    test_coverage: "> 90%"
    optimization: "comparable to hand-written"
    
  bootstrap_time:
    initial_compiler: "< 1 minute"
    self_hosting_compiler: "< 5 minutes"
    verification: "< 2 minutes"
