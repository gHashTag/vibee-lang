// Remotion Tools - MCP Tools for video rendering and templates
  // Performance Warning:   // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider extracting hardcoded strings to constants// Compositions, templates, variants, batch rendering, AI analysis
// Converted from mcp/remotion_tools.gleam → remotion_tools.vibee

// =============================================================================
// Core Render Tools
// =============================================================================

tool remotion_render_video {
  /// Render a video using Remotion
  description: "Render a video using Remotion. Available compositions: TextOverlay (animated text), VideoIntro (brand intro), DynamicVideo (type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} message with data items), LipSyncMain (talking head)."

  @param composition_id: str {
    description: "Composition to render"
    enum: ["TextOverlay", "VideoIntro", "DynamicVideo", "LipSyncMain"]
    required: true
  }

  @param title: str? {
    description: "Title text (for TextOverlay)"
  }

  @param subtitle: str? {
    description: "Subtitle text (for TextOverlay)"
  }

  @param brand_name: str? {
    description: "Brand name (for VideoIntro)"
  }

  @param tagline: str? {
    description: "Tagline (for VideoIntro)"
  }

  @param type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_name: str? {
    description: "type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} name (for DynamicVideo)"
  }

  @param message: str? {
    description: "Message text (for DynamicVideo)"
  }

  @param theme: str? {
    enum: ["dark", "light"]
    description: "Theme: dark or light (default: dark)"
    default: "dark"
  }

  @param codec: str? {
    enum: ["h264", "h265", "vp8", "vp9", "prores"]
    description: "Video codec (default: h264)"
    default: "h264"
  }
}

tool remotion_render_still {
  /// Render a single frame (still image) from composition
  description: "Render a single frame (still image) from a Remotion composition."

  @param composition_id: str {
    description: "Composition to render"
    enum: ["TextOverlay", "VideoIntro", "DynamicVideo", "LipSyncMain"]
    required: true
  }

  @param frame: int? {
    description: "Frame number to render, 0-indexed (default: 0)"
    default: 0
  }

  @param title: str? {
    description: "Title (for TextOverlay)"
  }

  @param subtitle: str? {
    description: "Subtitle (for TextOverlay)"
  }
}

tool remotion_get_render_status {
  /// Check render progress
  description: "Get the status and progress of a Remotion render job."

  @param render_id: str {
    description: "Render ID returned from render_video"
    required: true
  }
}

tool remotion_list_compositions {
  /// list available compositions
  description: "list all available Remotion video compositions with descriptions."
}

// =============================================================================
// Template Management Tools (for AI Agent)
// =============================================================================

tool template_list {
  /// list available Remotion templates
  description: "list all available Remotion templates in the project. Returns template names, descriptions, and file paths."

  @param category: str? {
    enum: ["all", "lipsync", "text", "intro", "outro"]
    description: "Filter templates by category (default: all)"
    default: "all"
  }
}

tool template_read {
  /// Read template source code
  description: "Read the TypeScript/TSX source code of a Remotion template. Use this to understand how a template works before modifying it."

  @param template_name: str {
    description: "Name of the template (e.g., 'LipSyncMain', 'TextOverlay')"
    required: true
  }
}

tool template_create {
  /// Create a new Remotion template
  description: "Create a new Remotion template. Generates a new .tsx file in the compositions directory with the provided code."

  @param name: str {
    description: "Template name (PascalCase, e.g., 'MyCustomTemplate')"
    required: true
  }

  @param code: str {
    description: "Full TypeScript/TSX code for the template"
    required: true
  }

  @param description: str? {
    description: "Brief description of what the template does"
  }

  @param props_schema: Json? {
    description: "JSON schema for template props (optional)"
  }
}

tool template_modify {
  /// Modify existing template
  description: "Modify an existing Remotion template. Apply changes to the template code."

  @param template_name: str {
    description: "Name of the template to modify"
    required: true
  }

  @param new_code: str? {
    description: "New full code to replace the template"
  }

  @param patch: Json? {
    description: "Partial changes: {old_string, new_string} for find-replace"
  }
}

tool template_preview {
  /// Get preview URL for template
  description: "Get a preview URL to see the template in the Remotion Player with custom props."

  @param template_name: str {
    description: "Template name to preview"
    required: true
  }

  @param props: Json? {
    description: "Props to pass to the template"
  }
}

tool props_update {
  /// Update template props in editor
  description: "Update one or more template properties in the editor. Changes are applied immediately to the preview."

  @param updates: Json {
    description: "Object with prop keys and new values to set"
    required: true
  }
}

// =============================================================================
// Factory Tools (Template Variation System)
// =============================================================================

tool factory_list_variants {
  /// list all template variants
  description: "list all generated template variants with their preview URLs. Returns variant IDs, priorities, and axis configurations."

  @param template_id: str? {
    description: "Template ID (default: talking-head)"
    default: "talking-head"
  }

  @param limit: int? {
    description: "Max variants to (default: 50)"
    default: 50
  }

  @param min_priority: int? {
    description: "Minimum priority score 0-100 (default: 0)"
    default: 0
  }

  @param filter_axis: str? {
    description: "Filter by axis value (e.g., 'circle-bottom-left', 'karaoke')"
  }
}

tool factory_generate_variants {
  /// Generate new template variants
  description: "Generate template variants from a base template. Returns type {name} {
  items: List[Item],
  count: Int} variants with IDs, priorities, and estimated render cost."

  @param template_id: str? {
    description: "Template ID to generate variants from (default: talking-head)"
    default: "talking-head"
  }

  @param limit: int? {
    description: "Maximum variants to generate (default: 100)"
    default: 100
  }

  @param axes: [str]? {
    description: "Axes to vary: avatarPosition, hookStyle, captionStyle, bRollPattern"
  }

  @param min_priority: int? {
    description: "Minimum priority threshold (default: 0)"
    default: 0
  }
}

tool factory_render_preview {
  /// Render preview thumbnail for a variant
  description: "Render a single frame preview (thumbnail) for a template variant. Returns image URL."

  @param variant_id: str {
    description: "Variant ID (e.g., 'TH_cbl_zi_k_hcc')"
    required: true
  }

  @param frame: int? {
    description: "Frame number to render (default: 90 = 3 seconds)"
    default: 90
  }

  @param width: int? {
    description: "Output width (default: 540)"
    default: 540
  }

  @param height: int? {
    description: "Output height (default: 960)"
    default: 960
  }
}

tool factory_batch_render {
  /// Start batch rendering of variants
  description: "Start batch rendering of multiple template variants. Returns batch ID for tracking progress."

  @param variant_ids: [str]? {
    description: "type {name} {
  items: List[Item],
  count: Int} variant IDs to render"
  }

  @param template_id: str? {
    description: "Or specify template_id + limit to auto-generate variants"
  }

  @param limit: int? {
    description: "Number of top-priority variants to render"
  }

  @param concurrency: int? {
    description: "Parallel renders (default: 5)"
    default: 5
  }

  @param duration: int? {
    description: "Video duration in seconds (default: 30)"
    default: 30
  }

  @param dry_run: bool? {
    description: "If true, only estimate cost without rendering"
    default: false
  }

  @param test_mode: bool? {
    description: "Use placeholder test assets"
    default: false
  }
}

tool factory_batch_status {
  /// Get batch render status
  description: "Get the status of a batch render job. Returns progress, completed/failed counts, and output URLs."

  @param batch_id: str {
    description: "Batch ID returned from factory_batch_render"
    required: true
  }
}

tool factory_get_gallery_url {
  /// Get gallery preview URL
  description: "Get URL to the variant gallery page showing all previews. Returns HTML gallery URL."

  @param template_id: str? {
    description: "Template ID (default: talking-head)"
  }

  @param batch_id: str? {
    description: "Specific batch ID to show (optional)"
  }
}

// =============================================================================
// Video Analysis Tools (AI Vision for Quality Review)
// =============================================================================

tool analyze_rendered_video {
  /// Analyze rendered video with AI vision
  description: "Analyze a rendered video for quality, composition, and visual elements using Gemini 3 Pro vision. Extracts frames at key timestamps and provides detailed feedback with scores."

  @param video_path: str {
    description: "Absolute path to the rendered video file (e.g., /path/to/video.mp4)"
    required: true
  }

  @param analysis_type: str? {
    enum: ["quick", "detailed", "design_review"]
    description: "Type of analysis: quick (2 frames), detailed (4 frames), design_review (6 frames with scoring)"
    default: "detailed"
  }

  @param timestamps: [int]? {
    description: "Custom timestamps in seconds to extract frames (overrides analysis_type)"
  }

  @param custom_prompt: str? {
    description: "Custom prompt for analysis (adds to default)"
  }
}

tool analyze_video_frames {
  /// Analyze specific video frames
  description: "Analyze specific frames from a video or image files. Send multiple images for comparison or sequence analysis."

  @param frame_paths: [str] {
    description: "type {name} {
  items: List[Item],
  count: Int} image file paths (PNG/JPG) to analyze"
    required: true
  }

  @param prompt: str {
    description: "Analysis prompt describing what to evaluate"
    required: true
  }

  @param model: str? {
    enum: ["gemini-3-pro-image-preview", "gpt-4o", "claude-3.5-sonnet"]
    description: "Vision model to use (default: gemini-3-pro-image-preview)"
    default: "gemini-3-pro-image-preview"
  }
}

tool batch_analyze_renders {
  /// Analyze multiple rendered videos
  description: "Analyze multiple rendered videos and generate a comparative report. Useful for evaluating batch renders."

  @param video_directory: str {
    description: "Directory containing rendered videos"
    required: true
  }

  @param limit: int? {
    description: "Maximum videos to analyze (default: 10)"
    default: 10
  }

  @param output_format: str? {
    enum: ["summary", "detailed", "json"]
    description: "Output format (default: summary)"
    default: "summary"
  }
}

// =============================================================================
// Types
// =============================================================================

derive(Json)
@enum RenderCodec {
  "h264" => H264
  "h265" => H265
  "vp8" => VP8
  "vp9" => VP9
  "prores" => ProRes
}

derive(Json)
@enum TemplateCategory {
  "all" => All
  "lipsync" => Lipsync
  "text" => Text
  "intro" => Intro
  "outro" => Outro
}

derive(Json)
@enum AnalysisType {
  "quick" => Quick
  "detailed" => Detailed
  "design_review" => DesignReview
}

derive(Json)
@enum VisionModel {
  "gemini-3-pro-image-preview" => Gemini3Pro
  "gpt-4o" => GPT4o
  "claude-3.5-sonnet" => Claude35Sonnet
}

type RenderRequest {
  RenderRequest(
    composition_id: str,
    input_props: Json,
    output_bucket: str,
    codec: RenderCodec
  )
}

type StillRequest {
  StillRequest(
    composition_id: str,
    input_props: Json,
    frame: int,
    output_bucket: str
  )
}
fn new() · Self {
    composition_id: composition_id,
    input_props: input_props,
    output_bucket: output_bucket,
    codec: codec
  
}

  # Auto-generated getters
fn composition_id(self) · self.composition_id


  # Auto-generated getters
fn composition_id(self) · self.composition_id


  # Auto-generated getters
fn region(self) · self.region


  # Auto-generated getters
fn name(self) · self.name

fn category(self) · self.category

fn description(self) · self.description

fn file_path(self) · self.file_path


  # Auto-generated getters
fn id(self) · self.id

fn template_id(self) · self.template_id

fn priority(self) · self.priority


  # Auto-generated getters
fn batch_id(self) · self.batch_id

fn total(self) · self.total

fn completed(self) · self.completed

fn failed(self) · self.failed

fn in_progress(self) · self.in_progress

fn avatar_position(self) · self.avatar_position


  # Auto-generated getters
fn overall_score(self) · self.overall_score

fn composition_score(self) · self.composition_score

fn color_harmony_score(self) · self.color_harmony_score

fn text_readability_score(self) · self.text_readability_score

fn visual_quality_score(self) · self.visual_quality_score

fn professional_feel_score(self) · self.professional_feel_score

fn summary(self) · self.summary

fn hook_style(self) · self.hook_style

fn caption_style(self) · self.caption_style

fn b_roll_pattern(self) · self.b_roll_pattern

fn function_name(self) · self.function_name

fn serve_url(self) · self.serve_url

fn input_props(self) · self.input_props

fn frame(self) · self.frame

fn output_bucket(self) · self.output_bucket

fn input_props(self) · self.input_props

fn output_bucket(self) · self.output_bucket

fn codec(self) · self.codec


type RenderConfig {
  RenderConfig(
    region: str,
    function_name: str,
    serve_url: str
  )
}

type TemplateInfo {
  TemplateInfo(
    name: str,
    category: TemplateCategory,
    description: str,
    file_path: str
  )
}

type VariantConfig {
  VariantConfig(
    id: str,
    template_id: str,
    priority: int,
    avatar_position: str,
    hook_style: str,
    caption_style: str,
    b_roll_pattern: str
  )
}

type BatchRenderStatus {
  BatchRenderStatus(
    batch_id: str,
    total: int,
    completed: int,
    failed: int,
    in_progress: int,
    output_urls: [str]
  )
}

type VideoAnalysisResult {
  VideoAnalysisResult(
    overall_score: float,
    composition_score: int,
    color_harmony_score: int,
    text_readability_score: int,
    visual_quality_score: int,
    professional_feel_score: int,
    issues: [str],
    suggestions: [str],
    summary: str
  )
}

// =============================================================================
// Helper Functions
// =============================================================================

@spec codec_from_string(s: str) → RenderCodec {
  /// Parse codec from string
  given: Codec string
  when: Parsing render options
  then: Returns RenderCodec enum
}

@impl {
  match s {
    "h264" → H264
    "h265" → H265
    "vp8" → VP8
    "vp9" → VP9
    "prores" → ProRes
    _ → H264
  }
}

@spec codec_$(codec: RenderCodec) → str {
  /// Convert codec to string
  given: RenderCodec enum
  when: Building render request
  then: Returns codec string
}

@impl {
  match codec {
    H264 → "h264"
    H265 → "h265"
    VP8 → "vp8"
    VP9 → "vp9"
    ProRes → "prores"
  }
}

@spec category_from_string(s: str) → TemplateCategory {
  /// Parse template category from string
  given: Category string
  when: Filtering templates
  then: Returns TemplateCategory enum
}

@impl {
  match s {
    "lipsync" → Lipsync
    "text" → Text
    "intro" → Intro
    "outro" → Outro
    _ → All
  }
}

@spec category_$(cat: TemplateCategory) → str {
  /// Convert category to string
  given: TemplateCategory enum
  when: Displaying template info
  then: Returns category string
}

@impl {
  match cat {
    All → "all"
    Lipsync → "lipsync"
    Text → "text"
    Intro → "intro"
    Outro → "outro"
  }
}

@spec analysis_type_from_string(s: str) → AnalysisType {
  /// Parse analysis type from string
  given: Analysis type string
  when: Configuring video analysis
  then: Returns AnalysisType enum
}

@impl {
  match s {
    "quick" → Quick
    "detailed" → Detailed
    "design_review" → DesignReview
    _ → Detailed
  }
}

@spec get_timestamps_for_analysis(t: AnalysisType) → [int] {
  /// Get timestamps based on analysis type
  given: AnalysisType enum
  when: Extracting frames for analysis
  then: Returns type {name} {
  items: List[Item],
  count: Int} second timestamps
}

@impl {
  match t {
    Quick → [1, 8]
    Detailed → [1, 3, 8, 12]
    DesignReview → [1, 3, 5, 8, 10, 12]
  }
}

@spec model_from_string(s: str) → VisionModel {
  /// Parse vision model from string
  given: Model string
  when: Selecting AI model for analysis
  then: Returns VisionModel enum
}

@impl {
  match s {
    "gemini-3-pro-image-preview" → Gemini3Pro
    "gpt-4o" → GPT4o
    "claude-3.5-sonnet" → Claude35Sonnet
    _ → Gemini3Pro
  }
}

@spec model_to_openrouter_id(m: VisionModel) → str {
  /// Convert model to OpenRouter model ID
  given: VisionModel enum
  when: Making API request
  then: Returns OpenRouter model string
}

@impl {
  match m {
    Gemini3Pro → "google/gemini-3-pro-image-preview"
    GPT4o → "openai/gpt-4o"
    Claude35Sonnet → "anthropic/claude-3.5-sonnet"
  }
}

@spec video_analysis_prompt() → str {
  /// Default prompt for video quality analysis
  given: Nothing
  when: Analyzing rendered video
  then: Returns detailed analysis prompt
}

@impl {
  "Analyze this video frame from a rendered Instagram Reel. Evaluate:

1. **Composition** (1-10): Avatar placement, text positioning, visual balance
2. **Color Harmony** (1-10): Color scheme, contrast, brand consistency
3. **Text Readability** (1-10): Font size, contrast with background, safe zones
4. **Visual Quality** (1-10): Resolution, artifacts, blur, compression
5. **Professional Feel** (1-10): Overall polish, attention to detail

For each category, provide:
- Score (1-10)
- Specific issues found
- Improvement suggestions

Return as JSON with overall_score, per-category scores, and summary."
}

// =============================================================================
// FFI Imports - handlers in infra/mcp/remotion_tools.gleam
// =============================================================================

// @ffi handle_remotion_render_video(args: Json) → ToolResult
// @ffi handle_remotion_render_still(args: Json) → ToolResult
// @ffi handle_remotion_get_render_status(args: Json) → ToolResult
// @ffi handle_remotion_list_compositions(args: Json) → ToolResult
// @ffi handle_template_list(args: Json) → ToolResult
// @ffi handle_template_read(args: Json) → ToolResult
// @ffi handle_template_create(args: Json) → ToolResult
// @ffi handle_template_modify(args: Json) → ToolResult
// @ffi handle_template_preview(args: Json) → ToolResult
// @ffi handle_props_update(args: Json) → ToolResult
// @ffi handle_factory_list_variants(args: Json) → ToolResult
// @ffi handle_factory_generate_variants(args: Json) → ToolResult
// @ffi handle_factory_render_preview(args: Json) → ToolResult
// @ffi handle_factory_batch_render(args: Json) → ToolResult
// @ffi handle_factory_batch_status(args: Json) → ToolResult
// @ffi handle_factory_get_gallery_url(args: Json) → ToolResult
// @ffi handle_analyze_rendered_video(args: Json) → ToolResult
// @ffi handle_analyze_video_frames(args: Json) → ToolResult
// @ffi handle_batch_analyze_renders(args: Json) → ToolResult

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
