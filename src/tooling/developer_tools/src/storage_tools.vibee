// Storage Tools - MCP Tools for S3/Tigris file storage
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Upload, list, config via render-server proxy
// Converted from mcp/storage_tools.gleam → storage_tools.vibee

// =============================================================================
// Tool Definitions
// =============================================================================

tool storage_upload {
  /// Upload file to S3/Tigris
  description: "Upload a file to S3/Tigris cloud storage. Accepts base64-encoded file data. Returns public URL of uploaded file."

  @param data: str {
    description: "Base64-encoded file content"
    required: true
  }

  @param filename: str {
    description: "Filename with extension (e.g., 'video.mp4', 'image.png')"
    required: true
  }

  @param content_type: str? {
    description: "MIME type (e.g., 'video/mp4', 'image/png', 'audio/mpeg')"
  }
}

tool storage_list {
  /// list files in S3/Tigris
  description: "list all uploaded files in S3/Tigris storage. Returns array of files with URLs and metadata."
}

tool storage_config {
  /// Get storage configuration
  description: "Get current storage configuration (S3 endpoint, bucket, public URL)."
}

// =============================================================================
// Types
// =============================================================================

derive(Json)
@enum StorageProvider {
  "s3" => S3
  "tigris" => Tigris
  "r2" => R2
  "minio" => Minio
}

derive(Json)
@enum ContentType {
  "video/mp4" => VideoMp4
  "video/webm" => VideoWebm
  "video/quicktime" => VideoMov
  "audio/mpeg" => AudioMpeg
  "audio/wav" => AudioWav
  "image/png" => ImagePng
  "image/jpeg" => ImageJpeg
  "image/gif" => ImageGif
  "image/webp" => ImageWebp
  "application/octet-stream" => OctetStream
}

type StorageConfig {
  StorageConfig(
    provider: StorageProvider,
    render_server_url: str,
    s3_endpoint: str,
    s3_bucket: str,
    s3_public_url: str
  )
}

type UploadResult {
  UploadResult(
    url: str,
    key: str,
    size: int,
    content_type: str
  )
}
fn new() · Self {
    provider: provider,
    render_server_url: render_server_url,
    s3_endpoint: s3_endpoint,
    s3_bucket: s3_bucket,
    s3_public_url: s3_public_url
  
}

  # Auto-generated getters
fn provider(self) · self.provider


  # Auto-generated getters
fn url(self) · self.url


  # Auto-generated getters
fn key(self) · self.key

fn url(self) · self.url

fn size(self) · self.size

fn content_type(self) · self.content_type


  # Auto-generated getters
fn message(self) · self.message

fn message(self) · self.message

fn key(self) · self.key

fn last_modified(self) · self.last_modified

fn key(self) · self.key

fn size(self) · self.size

fn content_type(self) · self.content_type

fn render_server_url(self) · self.render_server_url

fn s3_endpoint(self) · self.s3_endpoint

fn s3_bucket(self) · self.s3_bucket

fn s3_public_url(self) · self.s3_public_url


type StorageAsset {
  StorageAsset(
    key: str,
    url: str,
    size: int,
    content_type: str,
    last_modified: str
  )
}

type StorageError {
  StorageConnection❌message: str)
  StorageUpload❌message: str)
  StorageNotFound(key: str)
  StoragePermissionDenied
  StorageQuotaExceeded
}

// =============================================================================
// Helper Functions
// =============================================================================

@spec provider_from_string(s: str) → StorageProvider {
  /// Parse storage provider from string
  given: Provider string
  when: Parsing config
  then: Returns StorageProvider enum
}

@impl {
  match s {
    "tigris" → Tigris
    "r2" → R2
    "minio" → Minio
    _ → S3
  }
}

@spec provider_$(p: StorageProvider) → str {
  /// Convert storage provider to string
  given: StorageProvider enum
  when: Serializing config
  then: Returns provider string
}

@impl {
  match p {
    S3 → "s3"
    Tigris → "tigris"
    R2 → "r2"
    Minio → "minio"
  }
}

@spec content_type_from_string(s: str) → ContentType {
  /// Parse content type from MIME string
  given: MIME type string
  when: Validating upload
  then: Returns ContentType enum
}

@impl {
  match s {
    "video/mp4" → VideoMp4
    "video/webm" → VideoWebm
    "video/quicktime" → VideoMov
    "audio/mpeg" → AudioMpeg
    "audio/wav" → AudioWav
    "image/png" → ImagePng
    "image/jpeg" → ImageJpeg
    "image/gif" → ImageGif
    "image/webp" → ImageWebp
    _ → OctetStream
  }
}

@spec content_type_$(ct: ContentType) → str {
  /// Convert content type to MIME string
  given: ContentType enum
  when: Setting HTTP headers
  then: Returns MIME type string
}

@impl {
  match ct {
    VideoMp4 → "video/mp4"
    VideoWebm → "video/webm"
    VideoMov → "video/quicktime"
    AudioMpeg → "audio/mpeg"
    AudioWav → "audio/wav"
    ImagePng → "image/png"
    ImageJpeg → "image/jpeg"
    ImageGif → "image/gif"
    ImageWebp → "image/webp"
    OctetStream → "application/octet-stream"
  }
}

@spec guess_content_type(filename: str) → ContentType {
  /// Guess content type from filename extension
  given: Filename with extension
  when: No content_type provided
  then: Returns ContentType based on extension
}

@impl {
  let ext = get_extension(filename)
  match ext {
    ".mp4" → VideoMp4
    ".webm" → VideoWebm
    ".mov" → VideoMov
    ".mp3" → AudioMpeg
    ".wav" → AudioWav
    ".png" → ImagePng
    ".jpg" → ImageJpeg
    ".jpeg" → ImageJpeg
    ".gif" → ImageGif
    ".webp" → ImageWebp
    _ → OctetStream
  }
}

@spec get_extension(filename: str) → str {
  /// Extract file extension from filename
  given: Filename string
  when: Guessing content type
  then: Returns lowercase extension with dot
}

@impl {
  let parts = string."." · split
  case list.last(parts) {
    ☐ext) → ".{string.lowercase(ext)}"
    ∅-> ""
  }
}

@spec storage_error_$(err: StorageError) → str {
  /// Convert storage error to string
  given: StorageError
  when: Formatting error response
  then: Returns error message
}

@impl {
  match err {
    StorageConnection❌msg) → "Connection error: {msg}"
    StorageUpload❌msg) → "Upload error: {msg}"
    StorageNotFound(key) → "Not found: {key}"
    StoragePermissionDenied → "Permission denied"
    StorageQuotaExceeded → "Storage quota exceeded"
  }
}

@spec is_video(ct: ContentType) → bool {
  /// Check if content type is video
  given: ContentType
  when: Filtering assets
  then: Returns true if video
}

@impl {
  match ct {
    VideoMp4 → true
    VideoWebm → true
    VideoMov → true
    _ → false
  }
}

@spec is_audio(ct: ContentType) → bool {
  /// Check if content type is audio
  given: ContentType
  when: Filtering assets
  then: Returns true if audio
}

@impl {
  match ct {
    AudioMpeg → true
    AudioWav → true
    _ → false
  }
}

@spec is_image(ct: ContentType) → bool {
  /// Check if content type is image
  given: ContentType
  when: Filtering assets
  then: Returns true if image
}

@impl {
  match ct {
    ImagePng → true
    ImageJpeg → true
    ImageGif → true
    ImageWebp → true
    _ → false
  }
}

@spec default_render_server_url() → str {
  /// Get default render server URL
  given: Nothing
  when: No config provided
  then: Returns default URL
}

@impl {
  "https://vibee-remotion.fly.dev"
}

// =============================================================================
// FFI Imports - handlers in infra/mcp/storage_tools.gleam
// =============================================================================

// @ffi handle_upload(data: str, filename: str, content_type: str) → ToolResult
// @ffi handle_list() → ToolResult
// @ffi handle_config() → ToolResult

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
