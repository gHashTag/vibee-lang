//! VIBEE ⲦⲢⲒⲚⲒⲦⲨ Code Generator - AST to Zig
//! Generates Zig code from parsed AST
//! φ² + 1/φ² = 3

const std = @import("std");
const coptic_parser = @import("coptic_parser_real.zig");
const coptic_lexer = @import("coptic_lexer.zig");

const AstNode = coptic_parser.AstNode;
const NodeKind = coptic_parser.NodeKind;
const TokenKind = coptic_lexer.TokenKind;

pub const PHI: f64 = 1.6180339887498948482;

pub const CodeGen = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayList(u8),
    indent: u32,
    source: []const u8,
    
    pub fn init(allocator: std.mem.Allocator, source: []const u8) CodeGen {
        return .{
            .allocator = allocator,
            .output = std.ArrayList(u8).init(allocator),
            .indent = 0,
            .source = source,
        };
    }
    
    pub fn deinit(self: *CodeGen) void {
        self.output.deinit();
    }
    
    pub fn generate(self: *CodeGen, ast: *const AstNode) ![]const u8 {
        try self.writeHeader();
        try self.visitNode(ast);
        return self.output.items;
    }
    
    fn writeHeader(self: *CodeGen) !void {
        try self.write("// Generated by VIBEE ⲦⲢⲒⲚⲒⲦⲨ Compiler\n");
        try self.write("// φ² + 1/φ² = 3\n\n");
        try self.write("const std = @import(\"std\");\n\n");
        try self.write("pub const PHI: f64 = 1.6180339887498948482;\n");
        try self.write("pub const TRINITY: u32 = 27;\n\n");
    }
    
    fn visitNode(self: *CodeGen, node: *const AstNode) error{OutOfMemory}!void {
        switch (node.kind) {
            .program => try self.visitProgram(node),
            .const_decl => try self.visitConstDecl(node),
            .var_decl => try self.visitVarDecl(node),
            .let_decl => try self.visitVarDecl(node), // treat let like var
            .let_destructure_array, .let_destructure_object => {}, // TODO: codegen for destructuring
            .rest_pattern => {},
            .func_decl => try self.visitFuncDecl(node),
            .func_expr => try self.visitFuncExpr(node),
            .lambda_expr => try self.visitLambda(node),
            .block => try self.visitBlock(node),
            .return_stmt => try self.visitReturn(node),
            .if_expr => try self.visitIf(node),
            .match_expr => try self.visitMatch(node),
            .match_arm => {},
            .or_pattern => {},  // handled in match
            .range_pattern => {},  // handled in match
            .while_stmt => try self.visitWhile(node),
            .for_stmt => try self.visitFor(node),
            .break_stmt => try self.write("break"),
            .continue_stmt => try self.write("continue"),
            .binary_expr => try self.visitBinary(node),
            .is_expr => try self.visitIsExpr(node),
            .unary_expr => try self.visitUnary(node),
            .call_expr => try self.visitCall(node),
            .index_expr => try self.visitIndex(node),
            .member_expr => try self.visitMember(node),
            .optional_member => try self.visitOptionalMember(node),
            .array_literal => try self.visitArray(node),
            .spread_element => try self.visitSpread(node),
            .list_comprehension => try self.visitListComprehension(node),
            .object_literal => try self.visitObject(node),
            .object_field => {},
            .literal_int, .literal_float => try self.visitLiteral(node),
            .literal_string => try self.visitStringLiteral(node),
            .literal_trit => try self.visitTritLiteral(node),
            .literal_tryte => try self.visitTryteLiteral(node),
            .literal_bool => try self.visitBoolLiteral(node),
            .literal_nil => try self.write("null"),
            .literal_none => try self.write("null"),
            .literal_some, .literal_ok, .literal_err => {
                if (node.children.items.len > 0) {
                    try self.visitNode(&node.children.items[0]);
                }
            },
            .identifier, .coptic_id => try self.visitIdentifier(node),
            .placeholder => try self.write("_"),
        }
    }
    
    fn visitFuncExpr(self: *CodeGen, node: *const AstNode) !void {
        try self.write("fn(");
        // params
        var first = true;
        for (node.children.items[0..node.children.items.len -| 1]) |*child| {
            if (!first) try self.write(", ");
            try self.visitNode(child);
            first = false;
        }
        try self.write(") ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[node.children.items.len - 1]);
        }
    }
    
    fn visitLambda(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len < 1) return;
        const body_idx = node.children.items.len - 1;
        
        // Single param: |x| expr
        // Multiple params: |x, y| expr
        try self.write("|");
        var first = true;
        for (node.children.items[0..body_idx]) |*child| {
            if (!first) try self.write(", ");
            try self.visitNode(child);
            first = false;
        }
        try self.write("| ");
        try self.visitNode(&node.children.items[body_idx]);
    }
    
    fn visitListComprehension(self: *CodeGen, node: *const AstNode) !void {
        // Generate as: for loop with filter
        try self.write("// list comprehension\n");
        _ = node;
    }
    
    fn visitIsExpr(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len < 2) return;
        try self.write("@TypeOf(");
        try self.visitNode(&node.children.items[0]);
        try self.write(") == ");
        try self.visitNode(&node.children.items[1]);
    }
    
    fn visitSpread(self: *CodeGen, node: *const AstNode) !void {
        try self.write("...");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
    }
    
    fn visitMatch(self: *CodeGen, node: *const AstNode) !void {
        _ = node;
        try self.write("// match expression");
    }
    
    fn visitMember(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(".");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
    }
    
    fn visitOptionalMember(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write("?.");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
    }
    
    fn visitObject(self: *CodeGen, node: *const AstNode) !void {
        try self.write(".{");
        var first = true;
        for (node.children.items) |*child| {
            if (!first) try self.write(", ");
            try self.visitNode(child);
            first = false;
        }
        try self.write("}");
    }
    
    fn visitProgram(self: *CodeGen, node: *const AstNode) !void {
        for (node.children.items) |*child| {
            try self.visitNode(child);
            try self.write("\n");
        }
    }
    
    fn visitConstDecl(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("pub const ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // name
        }
        try self.write(" = ");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]); // value
        }
        try self.write(";\n");
    }
    
    fn visitVarDecl(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("var ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // name
        }
        try self.write(" = ");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]); // value
        }
        try self.write(";\n");
    }
    
    fn visitFuncDecl(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("pub fn ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // name
        }
        try self.write("(");
        // params
        var i: usize = 1;
        while (i < node.children.items.len - 1) : (i += 1) {
            if (i > 1) try self.write(", ");
            try self.visitNode(&node.children.items[i]);
            try self.write(": anytype");
        }
        try self.write(") anytype {\n");
        self.indent += 1;
        // body
        if (node.children.items.len > 1) {
            const body = &node.children.items[node.children.items.len - 1];
            for (body.children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }
    
    fn visitBlock(self: *CodeGen, node: *const AstNode) !void {
        for (node.children.items) |*child| {
            try self.visitNode(child);
        }
    }
    
    fn visitReturn(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("return ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(";\n");
    }
    
    fn visitIf(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("if (");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // condition
        }
        try self.write(") {\n");
        self.indent += 1;
        if (node.children.items.len > 1) {
            for (node.children.items[1].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}");
        if (node.children.items.len > 2) {
            try self.write(" else {\n");
            self.indent += 1;
            for (node.children.items[2].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
            self.indent -= 1;
            try self.writeIndent();
            try self.write("}");
        }
        try self.write("\n");
    }
    
    fn visitWhile(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("while (");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(") {\n");
        self.indent += 1;
        if (node.children.items.len > 1) {
            for (node.children.items[1].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }
    
    fn visitFor(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("for (");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]); // iterable
        }
        try self.write(") |");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // var
        }
        try self.write("| {\n");
        self.indent += 1;
        if (node.children.items.len > 2) {
            for (node.children.items[2].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }
    
    fn visitIndex(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write("[");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
        try self.write("]");
    }
    
    fn visitArray(self: *CodeGen, node: *const AstNode) !void {
        try self.write(".{");
        for (node.children.items, 0..) |*child, i| {
            if (i > 0) try self.write(", ");
            try self.visitNode(child);
        }
        try self.write("}");
    }
    
    fn visitStringLiteral(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        try self.write(lexeme);
    }
    
    fn visitBoolLiteral(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        try self.write(lexeme);
    }
    
    fn visitBinary(self: *CodeGen, node: *const AstNode) !void {
        try self.write("(");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(" ");
        try self.write(switch (node.token.kind) {
            .op_plus => "+",
            .op_minus => "-",
            .op_star => "*",
            .op_slash => "/",
            .op_eqeq => "==",
            else => "?",
        });
        try self.write(" ");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
        try self.write(")");
    }
    
    fn visitUnary(self: *CodeGen, node: *const AstNode) !void {
        try self.write(switch (node.token.kind) {
            .op_minus => "-",
            else => "!",
        });
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
    }
    
    fn visitCall(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // callee
        }
        try self.write("(");
        var i: usize = 1;
        while (i < node.children.items.len) : (i += 1) {
            if (i > 1) try self.write(", ");
            try self.visitNode(&node.children.items[i]);
        }
        try self.write(")");
    }
    
    fn visitLiteral(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        try self.output.appendSlice(lexeme);
    }
    
    fn visitTritLiteral(self: *CodeGen, node: *const AstNode) !void {
        const value = switch (node.token.kind) {
            .trit_true => "1",   // △
            .trit_unknown => "0", // ○
            .trit_false => "-1", // ▽
            else => "0",
        };
        try self.write(value);
    }

    fn visitTryteLiteral(self: *CodeGen, node: *const AstNode) !void {
        // Tryte literal: 0t012 -> convert to decimal
        // Balanced ternary: 0=0, 1=1, 2=-1 (or T=-1)
        const lexeme = node.token.lexeme(self.source);
        if (lexeme.len >= 2 and lexeme[0] == '0' and lexeme[1] == 't') {
            const trits = lexeme[2..];
            var val: i16 = 0;
            var power: i16 = 1;
            var i: usize = trits.len;
            while (i > 0) {
                i -= 1;
                const c = trits[i];
                var trit: i16 = 0;
                if (c == '2' or c == 'T' or c == 't') {
                    trit = -1; // balanced ternary: 2 = -1
                } else if (c == '1') {
                    trit = 1;
                }
                // c == '0' -> trit stays 0
                val += trit * power;
                power *= 3;
            }
            var buf: [16]u8 = undefined;
            const len = std.fmt.formatIntBuf(&buf, val, 10, .lower, .{});
            try self.output.appendSlice(buf[0..len]);
        } else {
            try self.write("0");
        }
    }
    
    fn visitIdentifier(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        // Convert coptic to ascii for Zig compatibility
        if (node.kind == .coptic_id) {
            try self.write("coptic_");
            // Use codepoint as suffix
            try self.output.appendSlice(lexeme);
        } else {
            try self.output.appendSlice(lexeme);
        }
    }
    
    fn write(self: *CodeGen, s: []const u8) !void {
        try self.output.appendSlice(s);
    }
    
    fn writeIndent(self: *CodeGen) !void {
        var i: u32 = 0;
        while (i < self.indent) : (i += 1) {
            try self.write("    ");
        }
    }
};

/// Compile source to Zig code
pub fn compile(source: []const u8, allocator: std.mem.Allocator) ![]const u8 {
    var parser = coptic_parser.Parser.init(source, allocator);
    var ast = try parser.parseProgram();
    defer ast.deinit();
    
    var codegen = CodeGen.init(allocator, source);
    defer codegen.deinit();
    
    const code = try codegen.generate(&ast);
    return try allocator.dupe(u8, code);
}

// Tests
test "codegen const" {
    const source = "const x = 42";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "pub const x = 42") != null);
}

test "codegen func" {
    const source = "func add(a, b) { return a + b }";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn add") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "return") != null);
}

test "codegen binary" {
    const source = "1 + 2";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "(1 + 2)") != null);
}

test "codegen trit" {
    const source = "△";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "1") != null);
}

test "phi constant" {
    try std.testing.expect(PHI > 1.618 and PHI < 1.619);
}
