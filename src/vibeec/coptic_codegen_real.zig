//! VIBEE ⲦⲢⲒⲚⲒⲦⲨ Code Generator - AST to Zig
//! Generates Zig code from parsed AST
//! φ² + 1/φ² = 3

const std = @import("std");
const coptic_parser = @import("coptic_parser_real.zig");
const coptic_lexer = @import("coptic_lexer.zig");

const AstNode = coptic_parser.AstNode;
const NodeKind = coptic_parser.NodeKind;
const TokenKind = coptic_lexer.TokenKind;

pub const PHI: f64 = 1.6180339887498948482;

pub const CodeGen = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayListUnmanaged(u8),
    indent: u32,
    source: []const u8,

    pub fn init(allocator: std.mem.Allocator, source: []const u8) CodeGen {
        return .{
            .allocator = allocator,
            .output = .{},
            .indent = 0,
            .source = source,
        };
    }

    pub fn deinit(self: *CodeGen) void {
        self.output.deinit(self.allocator);
    }

    pub fn generate(self: *CodeGen, ast: *const AstNode) ![]const u8 {
        try self.writeHeader();
        try self.visitNode(ast);
        return self.output.items;
    }

    fn writeHeader(self: *CodeGen) !void {
        try self.write("// Generated by VIBEE ⲦⲢⲒⲚⲒⲦⲨ Compiler\n");
        try self.write("// φ² + 1/φ² = 3\n\n");
        try self.write("const std = @import(\"std\");\n\n");
        try self.write("pub const PHI: f64 = 1.6180339887498948482;\n");
        try self.write("pub const TRINITY: u32 = 27;\n\n");
    }

    fn visitNode(self: *CodeGen, node: *const AstNode) error{OutOfMemory}!void {
        switch (node.kind) {
            .program => try self.visitProgram(node),
            .module_decl => try self.visitModule(node),
            .const_decl => try self.visitConstDecl(node),
            .var_decl => try self.visitVarDecl(node),
            .let_decl => try self.visitVarDecl(node), // treat let like var
            .let_destructure_array, .let_destructure_object => {}, // TODO: codegen for destructuring
            .rest_pattern => {},
            .func_decl => try self.visitFuncDecl(node),
            .func_expr => try self.visitFuncExpr(node),
            .lambda_expr => try self.visitLambda(node),
            .block => try self.visitBlock(node),
            .return_stmt => try self.visitReturn(node),
            .if_expr => try self.visitIf(node),
            .match_expr => try self.visitMatch(node),
            .match_arm => {},
            .or_pattern => {}, // handled in match
            .range_pattern => {}, // handled in match
            .while_stmt => try self.visitWhile(node),
            .for_stmt => try self.visitFor(node),
            .break_stmt => try self.write("break"),
            .continue_stmt => try self.write("continue"),
            .binary_expr => try self.visitBinary(node),
            .is_expr => try self.visitIsExpr(node),
            .unary_expr => try self.visitUnary(node),
            .call_expr => try self.visitCall(node),
            .index_expr => try self.visitIndex(node),
            .member_expr => try self.visitMember(node),
            .optional_member => try self.visitOptionalMember(node),
            .array_literal => try self.visitArray(node),
            .spread_element => try self.visitSpread(node),
            .list_comprehension => try self.visitListComprehension(node),
            .object_literal => try self.visitObject(node),
            .object_field => {},
            .literal_int, .literal_float => try self.visitLiteral(node),
            .literal_string => try self.visitStringLiteral(node),
            .literal_trit => try self.visitTritLiteral(node),
            .literal_tryte => try self.visitTryteLiteral(node),
            .literal_bool => try self.visitBoolLiteral(node),
            .literal_nil => try self.write("null"),
            .literal_none => try self.write("null"),
            .literal_some, .literal_ok, .literal_err => {
                if (node.children.items.len > 0) {
                    try self.visitNode(&node.children.items[0]);
                }
            },
            .identifier, .coptic_id => try self.visitIdentifier(node),
            .placeholder => try self.write("_"),
        }
    }

    fn visitFuncExpr(self: *CodeGen, node: *const AstNode) !void {
        try self.write("fn(");
        // params
        var first = true;
        for (node.children.items[0..node.children.items.len -| 1]) |*child| {
            if (!first) try self.write(", ");
            try self.visitNode(child);
            first = false;
        }
        try self.write(") ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[node.children.items.len - 1]);
        }
    }

    fn visitLambda(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len < 1) return;
        const body_idx = node.children.items.len - 1;

        // Single param: |x| expr
        // Multiple params: |x, y| expr
        try self.write("|");
        var first = true;
        for (node.children.items[0..body_idx]) |*child| {
            if (!first) try self.write(", ");
            try self.visitNode(child);
            first = false;
        }
        try self.write("| ");
        try self.visitNode(&node.children.items[body_idx]);
    }

    fn visitListComprehension(self: *CodeGen, node: *const AstNode) !void {
        // Generate as: for loop with filter
        try self.write("// list comprehension\n");
        _ = node;
    }

    fn visitIsExpr(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len < 2) return;
        try self.write("@TypeOf(");
        try self.visitNode(&node.children.items[0]);
        try self.write(") == ");
        try self.visitNode(&node.children.items[1]);
    }

    fn visitSpread(self: *CodeGen, node: *const AstNode) !void {
        try self.write("...");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
    }

    fn visitMatch(self: *CodeGen, node: *const AstNode) !void {
        _ = node;
        try self.write("// match expression");
    }

    fn visitMember(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(".");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
    }

    fn visitOptionalMember(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write("?.");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
    }

    fn visitObject(self: *CodeGen, node: *const AstNode) !void {
        try self.write(".{");
        var first = true;
        for (node.children.items) |*child| {
            if (!first) try self.write(", ");
            try self.visitNode(child);
            first = false;
        }
        try self.write("}");
    }

    fn visitProgram(self: *CodeGen, node: *const AstNode) !void {
        for (node.children.items) |*child| {
            try self.visitNode(child);
            try self.write("\n");
        }
    }

    fn visitModule(self: *CodeGen, node: *const AstNode) !void {
        try self.write("// Module: ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write("\n");
    }

    fn visitConstDecl(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("pub const ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // name
        }
        try self.write(" = ");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]); // value
        }
        try self.write(";\n");
    }

    fn visitVarDecl(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("var ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // name
        }
        try self.write(" = ");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]); // value
        }
        try self.write(";\n");
    }

    fn visitFuncDecl(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("pub fn ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // name
        }
        try self.write("(");
        // params
        var i: usize = 1;
        while (i < node.children.items.len - 1) : (i += 1) {
            if (i > 1) try self.write(", ");
            try self.visitNode(&node.children.items[i]);
            try self.write(": anytype");
        }
        try self.write(") anytype {\n");
        self.indent += 1;
        // body
        if (node.children.items.len > 1) {
            const body = &node.children.items[node.children.items.len - 1];
            for (body.children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    fn visitBlock(self: *CodeGen, node: *const AstNode) !void {
        for (node.children.items) |*child| {
            try self.visitNode(child);
        }
    }

    fn visitReturn(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("return ");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(";\n");
    }

    fn visitIf(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("if (");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // condition
        }
        try self.write(") {\n");
        self.indent += 1;
        if (node.children.items.len > 1) {
            for (node.children.items[1].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}");
        if (node.children.items.len > 2) {
            try self.write(" else {\n");
            self.indent += 1;
            for (node.children.items[2].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
            self.indent -= 1;
            try self.writeIndent();
            try self.write("}");
        }
        try self.write("\n");
    }

    fn visitWhile(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("while (");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(") {\n");
        self.indent += 1;
        if (node.children.items.len > 1) {
            for (node.children.items[1].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    fn visitFor(self: *CodeGen, node: *const AstNode) !void {
        try self.writeIndent();
        try self.write("for (");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]); // iterable
        }
        try self.write(") |");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // var
        }
        try self.write("| {\n");
        self.indent += 1;
        if (node.children.items.len > 2) {
            for (node.children.items[2].children.items) |*stmt| {
                try self.visitNode(stmt);
            }
        }
        self.indent -= 1;
        try self.writeIndent();
        try self.write("}\n");
    }

    fn visitIndex(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write("[");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
        try self.write("]");
    }

    fn visitArray(self: *CodeGen, node: *const AstNode) !void {
        try self.write(".{");
        for (node.children.items, 0..) |*child, i| {
            if (i > 0) try self.write(", ");
            try self.visitNode(child);
        }
        try self.write("}");
    }

    fn visitStringLiteral(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        try self.write(lexeme);
    }

    fn visitBoolLiteral(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        try self.write(lexeme);
    }

    fn visitBinary(self: *CodeGen, node: *const AstNode) !void {
        try self.write("(");
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
        try self.write(" ");
        try self.write(switch (node.token.kind) {
            .op_plus => "+",
            .op_minus => "-",
            .op_star => "*",
            .op_slash => "/",
            .op_eqeq => "==",
            else => "?",
        });
        try self.write(" ");
        if (node.children.items.len > 1) {
            try self.visitNode(&node.children.items[1]);
        }
        try self.write(")");
    }

    fn visitUnary(self: *CodeGen, node: *const AstNode) !void {
        try self.write(switch (node.token.kind) {
            .op_minus => "-",
            else => "!",
        });
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]);
        }
    }

    fn visitCall(self: *CodeGen, node: *const AstNode) !void {
        if (node.children.items.len > 0) {
            try self.visitNode(&node.children.items[0]); // callee
        }
        try self.write("(");
        var i: usize = 1;
        while (i < node.children.items.len) : (i += 1) {
            if (i > 1) try self.write(", ");
            try self.visitNode(&node.children.items[i]);
        }
        try self.write(")");
    }

    fn visitLiteral(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        try self.output.appendSlice(self.allocator, lexeme);
    }

    fn visitTritLiteral(self: *CodeGen, node: *const AstNode) !void {
        const value = switch (node.token.kind) {
            .trit_true => "1", // △
            .trit_unknown => "0", // ○
            .trit_false => "-1", // ▽
            else => "0",
        };
        try self.write(value);
    }

    fn visitTryteLiteral(self: *CodeGen, node: *const AstNode) !void {
        // Tryte literal: 0t012 -> convert to decimal
        // Balanced ternary: 0=0, 1=1, 2=-1 (or T=-1)
        const lexeme = node.token.lexeme(self.source);
        if (lexeme.len >= 2 and lexeme[0] == '0' and lexeme[1] == 't') {
            const trits = lexeme[2..];
            var val: i16 = 0;
            var power: i16 = 1;
            var i: usize = trits.len;
            while (i > 0) {
                i -= 1;
                const c = trits[i];
                var trit: i16 = 0;
                if (c == '2' or c == 'T' or c == 't') {
                    trit = -1; // balanced ternary: 2 = -1
                } else if (c == '1') {
                    trit = 1;
                }
                // c == '0' -> trit stays 0
                val += trit * power;
                power *= 3;
            }
            var buf: [16]u8 = undefined;
            const formatted = std.fmt.bufPrint(&buf, "{d}", .{val}) catch "0";
            try self.output.appendSlice(self.allocator, formatted);
        } else {
            try self.write("0");
        }
    }

    fn visitIdentifier(self: *CodeGen, node: *const AstNode) !void {
        const lexeme = node.token.lexeme(self.source);
        // Convert coptic to ascii for Zig compatibility
        if (node.kind == .coptic_id) {
            try self.write("coptic_");
            // Use codepoint as suffix
            try self.output.appendSlice(self.allocator, lexeme);
        } else {
            try self.output.appendSlice(self.allocator, lexeme);
        }
    }

    fn write(self: *CodeGen, s: []const u8) !void {
        try self.output.appendSlice(self.allocator, s);
    }

    fn writeIndent(self: *CodeGen) !void {
        var i: u32 = 0;
        while (i < self.indent) : (i += 1) {
            try self.write("    ");
        }
    }
};

/// Compile source to Zig code
pub fn compile(source: []const u8, allocator: std.mem.Allocator) ![]const u8 {
    var parser = coptic_parser.Parser.init(source, allocator);
    var ast = try parser.parseProgram();
    defer ast.deinit();

    var codegen = CodeGen.init(allocator, source);
    defer codegen.deinit();

    const code = try codegen.generate(&ast);
    return try allocator.dupe(u8, code);
}

// Tests
test "codegen const" {
    const source = "const x = 42";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "pub const x = 42") != null);
}

test "codegen func" {
    const source = "func add(a, b) { return a + b }";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn add") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "return") != null);
}

test "codegen binary" {
    const source = "1 + 2";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "(1 + 2)") != null);
}

test "codegen trit" {
    const source = "△";
    const code = try compile(source, std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "1") != null);
}

test "phi constant" {
    try std.testing.expect(PHI > 1.618 and PHI < 1.619);
}

// ═══════════════════════════════════════════════════════════════════════════════
// VERILOG BACKEND (FPGA Target)
// ═══════════════════════════════════════════════════════════════════════════════
// Генерация Verilog кода для синтеза на FPGA
// Приоритет: BitNet операции (Ternary MAC без умножений)
// φ² + 1/φ² = 3

pub const VerilogGen = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayListUnmanaged(u8),
    source: []const u8,
    module_name: []const u8,

    pub fn init(allocator: std.mem.Allocator, source: []const u8, module_name: []const u8) VerilogGen {
        return .{
            .allocator = allocator,
            .output = .{},
            .source = source,
            .module_name = module_name,
        };
    }

    pub fn deinit(self: *VerilogGen) void {
        self.output.deinit(self.allocator);
    }

    pub fn generate(self: *VerilogGen, ast: *const AstNode) ![]const u8 {
        try self.writeVerilogHeader();
        try self.visitNodeVerilog(ast);
        try self.writeVerilogFooter();
        return self.output.items;
    }

    fn writeVerilogHeader(self: *VerilogGen) !void {
        try self.write("// ═══════════════════════════════════════════════════════════════════════════════\n");
        try self.write("// Generated by VIBEE ⲦⲢⲒⲚⲒⲦⲨ Compiler - VERILOG BACKEND\n");
        try self.write("// φ² + 1/φ² = 3 | TRINITY FPGA\n");
        try self.write("// ═══════════════════════════════════════════════════════════════════════════════\n\n");
        try self.write("`timescale 1ns / 1ps\n\n");
        try self.write("typedef logic [1:0] trit_t; // 00=-1, 01=0, 10=+1\n\n");
        try self.write("module ");
        try self.write(self.module_name);
        try self.write(" (\n    input clk,\n    input reset,\n    input [7:0] activation_in,\n    input [1:0] weight_in,\n    output reg [31:0] result,\n    output reg done\n);\n\n");
    }

    fn writeVerilogFooter(self: *VerilogGen) !void {
        try self.write("\n    // Ternary MAC integration from trinity_fpga_mvp.v\n");
        try self.write("    // Instantiate: ternary_mac tmac (.clk(clk), .reset(reset), ...);\n\n");
        try self.write("endmodule\n\n");
        try self.write("// Golden Verification: φ² + 1/φ² = 3.0 ✓\n");
    }

    fn visitModuleVerilog(self: *VerilogGen, node: *const AstNode) !void {
        try self.write("    // Module: ");
        if (node.children.items.len > 0) {
            const name = node.children.items[0].token.lexeme(self.source);
            try self.write(name);
        }
        try self.write("\n");
    }

    fn visitNodeVerilog(self: *VerilogGen, node: *const AstNode) error{OutOfMemory}!void {
        switch (node.kind) {
            .program => {
                for (node.children.items) |*child| {
                    try self.visitNodeVerilog(child);
                }
            },
            .module_decl => try self.visitModuleVerilog(node),
            .func_decl => try self.visitFuncDeclVerilog(node),
            .binary_expr => try self.visitBinaryVerilog(node),
            .return_stmt => try self.visitReturnVerilog(node),
            else => {}, // Not all Coptic constructs map to Verilog
        }
    }

    fn visitFuncDeclVerilog(self: *VerilogGen, node: *const AstNode) !void {
        // В Verilog функции становятся модулями или always блоками
        try self.write("    // Function: ");
        if (node.children.items.len > 0) {
            const name = node.children.items[0].token.lexeme(self.source);
            try self.write(name);
        }
        try self.write("\n    always_ff @(posedge clk) begin\n");
        try self.write("        if (reset) begin\n");
        try self.write("            result <= 32'd0;\n");
        try self.write("            done <= 1'b0;\n");
        try self.write("        end else begin\n");

        // Body
        if (node.children.items.len > 1) {
            const body = &node.children.items[node.children.items.len - 1];
            for (body.children.items) |*stmt| {
                try self.visitNodeVerilog(stmt);
            }
        }

        try self.write("            done <= 1'b1;\n");
        try self.write("        end\n");
        try self.write("    end\n");
    }

    fn visitBinaryVerilog(self: *VerilogGen, node: *const AstNode) !void {
        // Троичные операции без умножения!
        try self.write("            // Ternary binary op (BitNet optimized)\n");
        try self.write("            case (weight_in)\n");
        try self.write("                2'b00: result <= result - activation_in; // -1\n");
        try self.write("                2'b10: result <= result + activation_in; // +1\n");
        try self.write("                default: result <= result;               // 0\n");
        try self.write("            endcase\n");
        _ = node;
    }

    fn visitReturnVerilog(self: *VerilogGen, node: *const AstNode) !void {
        try self.write("            // Return value assigned to result register\n");
        _ = node;
    }

    fn write(self: *VerilogGen, s: []const u8) !void {
        try self.output.appendSlice(self.allocator, s);
    }
};

/// Compile source to Verilog code (FPGA target)
pub fn compileToVerilog(source: []const u8, module_name: []const u8, allocator: std.mem.Allocator) ![]const u8 {
    var parser = coptic_parser.Parser.init(allocator, source);
    var ast = try parser.parseProgram();
    defer ast.deinit();

    var vgen = VerilogGen.init(allocator, source, module_name);
    defer vgen.deinit();

    const code = try vgen.generate(&ast);
    return try allocator.dupe(u8, code);
}

test "verilog backend" {
    const source = "func mul(a, b) { return a * b }";
    const code = try compileToVerilog(source, "coptic_mul", std.testing.allocator);
    defer std.testing.allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "module coptic_mul") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "always_ff") != null);
}
// ═══════════════════════════════════════════════════════════════════════════════
// COPTIC NATIVE (CIS) BACKEND
// ═══════════════════════════════════════════════════════════════════════════════
// Direct mapping of AST to 27 Coptic Instructions (1 Triad per Op)
// φ² + 1/φ² = 3 | TRINITY NATIVE
// ═══════════════════════════════════════════════════════════════════════════════

pub const CopticNativeGen = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayListUnmanaged(u21), // Stream of Coptic Codepoints
    source: []const u8,

    pub fn init(allocator: std.mem.Allocator, source: []const u8) CopticNativeGen {
        return .{
            .allocator = allocator,
            .output = .{},
            .source = source,
        };
    }

    pub fn deinit(self: *CopticNativeGen) void {
        self.output.deinit(self.allocator);
    }

    pub fn generate(self: *CopticNativeGen, ast: *const AstNode) ![]u21 {
        try self.visitNodeCIS(ast);
        return self.output.toOwnedSlice(self.allocator);
    }

    fn visitNodeCIS(self: *CopticNativeGen, node: *const AstNode) error{OutOfMemory}!void {
        switch (node.kind) {
            .program => {
                for (node.children.items) |*child| {
                    try self.visitNodeCIS(child);
                }
            },
            .binary_expr => {
                // Compile children first (stack-based approach for CIS)
                if (node.children.items.len > 0) try self.visitNodeCIS(&node.children.items[0]);
                if (node.children.items.len > 1) try self.visitNodeCIS(&node.children.items[1]);

                // Emit OP
                const op: u21 = switch (node.token.kind) {
                    .op_plus, .op_plus_t => coptic_lexer.COPTIC_START + 0, // ⲁ (ADD)
                    .op_minus, .op_minus_t => coptic_lexer.COPTIC_START + 1, // ⲃ (SUB)
                    .op_star, .op_star_t => coptic_lexer.COPTIC_START + 13, // ⲛ (TMAC)
                    else => coptic_lexer.COPTIC_START + 23, // ⲱ (SINK/ERR)
                };
                try self.output.append(self.allocator, op);
            },
            .literal_int, .literal_float, .literal_trit, .literal_tryte => {
                // In CIS literals are pushed to stack (LOAD logic)
                try self.output.append(self.allocator, coptic_lexer.COPTIC_START + 3); // ⲇ (LOAD)
            },
            .identifier, .coptic_id => {
                try self.output.append(self.allocator, coptic_lexer.COPTIC_START + 3); // ⲇ (LOAD from reg)
            },
            .func_decl => {
                // Visit body
                const body = &node.children.items[node.children.items.len - 1];
                try self.visitNodeCIS(body);
            },
            .block => {
                for (node.children.items) |*child| {
                    try self.visitNodeCIS(child);
                }
            },
            .return_stmt => {
                if (node.children.items.len > 0) try self.visitNodeCIS(&node.children.items[0]);
                try self.output.append(self.allocator, coptic_lexer.COPTIC_START + 21); // ⲫ (PHIT/RET)
            },
            .call_expr => {
                for (node.children.items[1..]) |*arg| {
                    try self.visitNodeCIS(arg);
                }
                try self.output.append(self.allocator, coptic_lexer.COPTIC_START + 25); // ϣ (TINT/CALL)
            },
            else => {},
        }
    }
};

/// Compile source directly to Coptic Instruction Set (Ternary Opcodes)
pub fn compileToCIS(source: []const u8, allocator: std.mem.Allocator) ![]u21 {
    var parser = coptic_parser.Parser.init(allocator, source);
    var ast = try parser.parseProgram();
    defer ast.deinit();

    var cgen = CopticNativeGen.init(allocator, source);
    defer cgen.deinit();

    return try cgen.generate(&ast);
}

test "coptic native backend" {
    const source = "1 + 2";
    const ops = try compileToCIS(source, std.testing.allocator);
    defer std.testing.allocator.free(ops);

    // Expect: LOAD (1), LOAD (2), ADD (ⲁ)
    try std.testing.expect(ops.len >= 3);
    try std.testing.expectEqual(@as(u21, 0x2C80 + 3), ops[0]); // ⲇ
    try std.testing.expectEqual(@as(u21, 0x2C80 + 3), ops[1]); // ⲇ
    try std.testing.expectEqual(@as(u21, 0x2C80 + 0), ops[2]); // ⲁ
}
