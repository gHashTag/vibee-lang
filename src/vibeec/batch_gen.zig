const std = @import("std");

/// BATCH GENERATOR - Массовая генерация VIBEE модулей
/// Ускорение: 10-50x по сравнению с последовательной генерацией

pub const ModuleDef = struct {
    name: []const u8,
    desc: []const u8,
};

pub const DomainConfig = struct {
    name: []const u8,
    version_start: u32,
    modules: []const ModuleDef,
};

/// Генерирует .vibee спецификацию
pub fn generateSpec(allocator: std.mem.Allocator, domain: []const u8, module: ModuleDef, version: u32) ![]const u8 {
    const v1 = version / 100;
    const v2 = (version / 10) % 10;
    const v3 = version % 10;

    return try std.fmt.allocPrint(allocator,
        \\name: {s}_v{d}
        \\version: "{d}.{d}.{d}"
        \\language: zig
        \\module: {s}
        \\description: "{s}"
        \\
        \\types:
        \\  {s}Config:
        \\    fields:
        \\      id: String
        \\      enabled: Bool
        \\      params: Object
        \\
        \\  {s}State:
        \\    fields:
        \\      status: String
        \\      data: Object
        \\      timestamp: Timestamp
        \\
        \\  {s}Result:
        \\    fields:
        \\      success: Bool
        \\      output: Object
        \\      error: Option<String>
        \\
        \\behaviors:
        \\  - name: init_{s}
        \\    given: "Config provided"
        \\    when: "Initialize {s}"
        \\    then: "State created"
        \\
        \\  - name: process_{s}
        \\    given: "Valid state"
        \\    when: "Process request"
        \\    then: "Result returned"
        \\
    , .{ module.name, version, v1, v2, v3, module.name, module.desc, module.name, module.name, module.name, module.name, module.name, module.name });
}

/// Генерирует .zig код напрямую (без промежуточного .vibee)
pub fn generateZig(allocator: std.mem.Allocator, module: ModuleDef, version: u32) ![]const u8 {
    const v1 = version / 100;
    const v2 = (version / 10) % 10;
    const v3 = version % 10;

    return try std.fmt.allocPrint(allocator,
        \\//! {s}_v{d} - {s}
        \\//! Version: {d}.{d}.{d}
        \\//! Auto-generated by VIBEE Batch Generator
        \\
        \\const std = @import("std");
        \\
        \\pub const {s}Config = struct {{
        \\    id: []const u8,
        \\    enabled: bool,
        \\    params: []const u8,
        \\}};
        \\
        \\pub const {s}State = struct {{
        \\    status: []const u8,
        \\    data: []const u8,
        \\    timestamp: i64,
        \\}};
        \\
        \\pub const {s}Result = struct {{
        \\    success: bool,
        \\    output: []const u8,
        \\    @"error": ?[]const u8,
        \\}};
        \\
        \\pub fn init_{s}(config: {s}Config) {s}State {{
        \\    _ = config;
        \\    return .{{
        \\        .status = "initialized",
        \\        .data = "{{}}",
        \\        .timestamp = std.time.timestamp(),
        \\    }};
        \\}}
        \\
        \\pub fn process_{s}(state: *{s}State) {s}Result {{
        \\    state.status = "processed";
        \\    return .{{
        \\        .success = true,
        \\        .output = "{{}}",
        \\        .@"error" = null,
        \\    }};
        \\}}
        \\
        \\test "init_{s}" {{
        \\    const config = {s}Config{{
        \\        .id = "test",
        \\        .enabled = true,
        \\        .params = "{{}}",
        \\    }};
        \\    const state = init_{s}(config);
        \\    try std.testing.expectEqualStrings("initialized", state.status);
        \\}}
        \\
        \\test "process_{s}" {{
        \\    var state = {s}State{{
        \\        .status = "initialized",
        \\        .data = "{{}}",
        \\        .timestamp = 0,
        \\    }};
        \\    const result = process_{s}(&state);
        \\    try std.testing.expect(result.success);
        \\}}
        \\
    , .{
        module.name, version, module.desc, v1, v2, v3,
        module.name, module.name, module.name,
        module.name, module.name, module.name,
        module.name, module.name, module.name,
        module.name, module.name, module.name,
        module.name, module.name, module.name,
    });
}

/// Batch генерация всего домена
pub fn generateDomain(allocator: std.mem.Allocator, config: DomainConfig) !void {
    const spec_dir = try std.fmt.allocPrint(allocator, "specs/tri/{s}", .{config.name});
    const output_dir = "trinity/output";

    // Создаем директории
    std.fs.cwd().makePath(spec_dir) catch {};
    std.fs.cwd().makePath(output_dir) catch {};

    var version = config.version_start;
    for (config.modules) |module| {
        // Генерируем .vibee
        const spec_content = try generateSpec(allocator, config.name, module, version);
        const spec_path = try std.fmt.allocPrint(allocator, "{s}/{s}_v{d}.vibee", .{ spec_dir, module.name, version });
        
        const spec_file = try std.fs.cwd().createFile(spec_path, .{});
        defer spec_file.close();
        try spec_file.writeAll(spec_content);

        // Генерируем .zig напрямую
        const zig_content = try generateZig(allocator, module, version);
        const zig_path = try std.fmt.allocPrint(allocator, "{s}/{s}_v{d}.zig", .{ output_dir, module.name, version });
        
        const zig_file = try std.fs.cwd().createFile(zig_path, .{});
        defer zig_file.close();
        try zig_file.writeAll(zig_content);

        version += 1;
    }
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len < 2) {
        std.debug.print("Usage: batch_gen <config.json>\n", .{});
        return;
    }

    std.debug.print("VIBEE Batch Generator v1.0\n", .{});
}

test "generateSpec" {
    const allocator = std.testing.allocator;
    const module = ModuleDef{ .name = "test", .desc = "Test module" };
    const spec = try generateSpec(allocator, "domain", module, 100);
    defer allocator.free(spec);
    try std.testing.expect(std.mem.indexOf(u8, spec, "name: test_v100") != null);
}

test "generateZig" {
    const allocator = std.testing.allocator;
    const module = ModuleDef{ .name = "test", .desc = "Test module" };
    const zig = try generateZig(allocator, module, 100);
    defer allocator.free(zig);
    try std.testing.expect(std.mem.indexOf(u8, zig, "pub const testConfig") != null);
}
