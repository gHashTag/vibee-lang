// ═══════════════════════════════════════════════════════════════════════════════
// AUTO CODEGEN - Автоматическая генерация Zig кода из .vibee спецификаций
// ═══════════════════════════════════════════════════════════════════════════════
//
// Генерирует полный Zig код БЕЗ ручного ⲍⲓⲅ_ⲟⲩⲧⲡⲩⲧ
// Автор: Dmitrii Vasilev
// φ² + 1/φ² = 3
//
// Creation Pattern:
//   Source: VibeeSpec
//   Transformer: AutoCodeGenerator
//   Result: GeneratedZigCode
//
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const vibee_parser = @import("vibee_parser.zig");

const VibeeSpec = vibee_parser.VibeeSpec;
const TypeDef = vibee_parser.TypeDef;
const Field = vibee_parser.Field;
const Behavior = vibee_parser.Behavior;
const TestCase = vibee_parser.TestCase;
const Constant = vibee_parser.Constant;
const CreationPattern = vibee_parser.CreationPattern;

// ═══════════════════════════════════════════════════════════════════════════════
// СВЯЩЕННЫЕ КОНСТАНТЫ
// ═══════════════════════════════════════════════════════════════════════════════

pub const PHI: f64 = 1.618033988749895;
pub const TRINITY: f64 = 3.0;
pub const PHOENIX: i64 = 999;

// ═══════════════════════════════════════════════════════════════════════════════
// AUTO CODE GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub const AutoCodeGenerator = struct {
    allocator: Allocator,
    buffer: ArrayList(u8),
    indent: u32,

    const Self = @This();

    pub fn init(allocator: Allocator) Self {
        return Self{
            .allocator = allocator,
            .buffer = ArrayList(u8).init(allocator),
            .indent = 0,
        };
    }

    pub fn deinit(self: *Self) void {
        self.buffer.deinit();
    }

    /// Генерация полного Zig файла из спецификации
    pub fn generate(self: *Self, spec: *const VibeeSpec) ![]const u8 {
        try self.writeHeader(spec);
        try self.writeImports();
        try self.writeSacredConstants();
        try self.writeUserConstants(spec.constants.items);
        try self.writeTypes(spec.types.items);
        try self.writeFunctions(spec.behaviors.items);
        try self.writeTests(spec.behaviors.items);
        try self.writeGoldenIdentityTest();

        return self.buffer.items;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HEADER
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeHeader(self: *Self, spec: *const VibeeSpec) !void {
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeFmt("// {s} v{s} - AUTO-GENERATED from .vibee specification\n", .{ spec.name, spec.version });
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("//");
        try self.writeLine("// DO NOT EDIT MANUALLY - This file is auto-generated by vibeec");
        try self.writeLine("//");
        try self.writeLine("// Sacred Formula: V = n × 3^k × π^m × φ^p × e^q");
        try self.writeLine("// Golden Identity: φ² + 1/φ² = 3");
        try self.writeLine("//");
        try self.writeFmt("// Author: {s}\n", .{spec.author});
        try self.writeLine("//");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // IMPORTS
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeImports(self: *Self) !void {
        try self.writeLine("const std = @import(\"std\");");
        try self.writeLine("const math = std.math;");
        try self.writeLine("const testing = std.testing;");
        try self.newline();
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // SACRED CONSTANTS
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeSacredConstants(self: *Self) !void {
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("// SACRED CONSTANTS");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();
        try self.writeLine("/// Golden ratio φ = (1 + √5) / 2");
        try self.writeLine("pub const PHI: f64 = 1.618033988749895;");
        try self.newline();
        try self.writeLine("/// Inverse golden ratio 1/φ = φ - 1");
        try self.writeLine("pub const PHI_INV: f64 = 0.618033988749895;");
        try self.newline();
        try self.writeLine("/// φ² = φ + 1");
        try self.writeLine("pub const PHI_SQ: f64 = 2.618033988749895;");
        try self.newline();
        try self.writeLine("/// Trinity constant (φ² + 1/φ² = 3)");
        try self.writeLine("pub const TRINITY: f64 = 3.0;");
        try self.newline();
        try self.writeLine("/// Phoenix number");
        try self.writeLine("pub const PHOENIX: i64 = 999;");
        try self.newline();
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // USER CONSTANTS
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeUserConstants(self: *Self, constants: []const Constant) !void {
        if (constants.len == 0) return;

        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("// USER CONSTANTS");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();

        for (constants) |c| {
            if (c.description.len > 0) {
                try self.writeFmt("/// {s}\n", .{c.description});
            }
            try self.writeFmt("pub const {s}: f64 = {d};\n", .{ c.name, c.value });
        }
        try self.newline();
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // TYPES
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeTypes(self: *Self, types: []const TypeDef) !void {
        if (types.len == 0) return;

        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("// TYPES");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();

        for (types) |t| {
            try self.generateStruct(&t);
            try self.newline();
        }
    }

    fn generateStruct(self: *Self, t: *const TypeDef) !void {
        if (t.description.len > 0) {
            try self.writeFmt("/// {s}\n", .{t.description});
        }

        // Если есть базовый тип - это алиас
        if (t.base) |base| {
            try self.writeFmt("pub const {s} = {s};\n", .{ t.name, mapType(base) });
            return;
        }

        // Генерируем структуру
        try self.writeFmt("pub const {s} = struct {{\n", .{t.name});
        self.indent += 1;

        for (t.fields.items) |field| {
            try self.writeIndent();
            const zig_type = mapType(field.type_name);
            const safe_name = escapeReservedWord(field.name);
            try self.writeFmt("{s}: {s},\n", .{ safe_name, zig_type });
        }

        self.indent -= 1;
        try self.writeLine("};");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // FUNCTIONS (from behaviors)
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeFunctions(self: *Self, behaviors: []const Behavior) !void {
        if (behaviors.len == 0) return;

        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("// FUNCTIONS");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();

        for (behaviors) |b| {
            try self.generateFunction(&b);
            try self.newline();
        }
    }

    fn generateFunction(self: *Self, b: *const Behavior) !void {
        // Документация из given/when/then
        try self.writeFmt("/// Given: {s}\n", .{b.given});
        try self.writeFmt("/// When: {s}\n", .{b.when});
        try self.writeFmt("/// Then: {s}\n", .{b.then});

        // Генерируем сигнатуру функции
        try self.writeFmt("pub fn {s}() void {{\n", .{b.name});
        self.indent += 1;

        try self.writeIndent();
        try self.writeLine("// TODO: Implement based on specification");

        self.indent -= 1;
        try self.writeLine("}");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // TESTS
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeTests(self: *Self, behaviors: []const Behavior) !void {
        var has_tests = false;
        for (behaviors) |b| {
            if (b.test_cases.items.len > 0) {
                has_tests = true;
                break;
            }
        }

        if (!has_tests) return;

        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("// TESTS");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();

        for (behaviors) |b| {
            for (b.test_cases.items) |tc| {
                try self.generateTest(&tc);
                try self.newline();
            }
        }
    }

    fn generateTest(self: *Self, tc: *const TestCase) !void {
        try self.writeFmt("test \"{s}\" {{\n", .{tc.name});
        self.indent += 1;

        try self.writeIndent();
        try self.writeFmt("// Input: {s}\n", .{tc.input});
        try self.writeIndent();
        try self.writeFmt("// Expected: {s}\n", .{tc.expected});
        try self.writeIndent();
        try self.writeLine("// TODO: Implement test");

        self.indent -= 1;
        try self.writeLine("}");
    }

    fn writeGoldenIdentityTest(self: *Self) !void {
        try self.newline();
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.writeLine("// GOLDEN IDENTITY VERIFICATION");
        try self.writeLine("// ═══════════════════════════════════════════════════════════════════════════════");
        try self.newline();

        try self.writeLine("test \"golden identity: φ² + 1/φ² = 3\" {");
        self.indent += 1;

        try self.writeIndent();
        try self.writeLine("const phi_sq = PHI * PHI;");
        try self.writeIndent();
        try self.writeLine("const phi_inv_sq = 1.0 / (PHI * PHI);");
        try self.writeIndent();
        try self.writeLine("const result = phi_sq + phi_inv_sq;");
        try self.writeIndent();
        try self.writeLine("try testing.expectApproxEqAbs(TRINITY, result, 0.0001);");

        self.indent -= 1;
        try self.writeLine("}");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HELPERS
    // ═══════════════════════════════════════════════════════════════════════════

    fn writeLine(self: *Self, str: []const u8) !void {
        try self.writeIndent();
        try self.buffer.appendSlice(str);
        try self.buffer.append('\n');
    }

    fn writeFmt(self: *Self, comptime fmt: []const u8, args: anytype) !void {
        const writer = self.buffer.writer();
        try writer.print(fmt, args);
    }

    fn writeIndent(self: *Self) !void {
        var i: u32 = 0;
        while (i < self.indent) : (i += 1) {
            try self.buffer.appendSlice("    ");
        }
    }

    fn newline(self: *Self) !void {
        try self.buffer.append('\n');
    }

    pub fn getOutput(self: *Self) []const u8 {
        return self.buffer.items;
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// TYPE MAPPING
// ═══════════════════════════════════════════════════════════════════════════════

/// Маппинг VIBEE типов в Zig типы
pub fn mapType(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "[]const u8";
    if (std.mem.eql(u8, vibee_type, "Int")) return "i64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "f64";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.eql(u8, vibee_type, "Void")) return "void";

    // List<T> -> []T
    if (std.mem.startsWith(u8, vibee_type, "List<")) {
        // Упрощённая обработка - возвращаем slice
        return "[]const u8"; // TODO: proper generic handling
    }

    // Option<T> -> ?T
    if (std.mem.startsWith(u8, vibee_type, "Option<")) {
        return "?[]const u8"; // TODO: proper generic handling
    }

    // Неизвестный тип - возвращаем как есть
    return vibee_type;
}

/// Экранирование зарезервированных слов Zig
pub fn escapeReservedWord(name: []const u8) []const u8 {
    const reserved = [_][]const u8{
        "type",  "error", "align", "test",
        "break", "catch", "else",  "enum",
        "for",   "if",    "or",    "and",
    };

    for (reserved) |r| {
        if (std.mem.eql(u8, name, r)) {
            return "@\"type\""; // TODO: proper escaping
        }
    }

    return name;
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "mapType: String -> []const u8" {
    const result = mapType("String");
    try std.testing.expectEqualStrings("[]const u8", result);
}

test "mapType: Int -> i64" {
    const result = mapType("Int");
    try std.testing.expectEqualStrings("i64", result);
}

test "mapType: Float -> f64" {
    const result = mapType("Float");
    try std.testing.expectEqualStrings("f64", result);
}

test "mapType: Bool -> bool" {
    const result = mapType("Bool");
    try std.testing.expectEqualStrings("bool", result);
}

test "golden identity constant" {
    const phi_sq = PHI * PHI;
    const phi_inv_sq = 1.0 / (PHI * PHI);
    const result = phi_sq + phi_inv_sq;
    try std.testing.expectApproxEqAbs(TRINITY, result, 0.0001);
}

test "AutoCodeGenerator init/deinit" {
    var gen = AutoCodeGenerator.init(std.testing.allocator);
    defer gen.deinit();

    try std.testing.expect(gen.buffer.items.len == 0);
    try std.testing.expect(gen.indent == 0);
}
