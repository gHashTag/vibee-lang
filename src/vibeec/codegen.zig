// VIBEEC Code Generator - Generates Zig code from parsed specs

const std = @import("std");
const parser = @import("parser.zig");

pub fn generate(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    // Header
    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\//
        \\// Module: {s}
        \\// Version: {s}
        \\// Language: {s}
        \\
        \\const std = @import("std");
        \\
        \\
    , .{ spec.name, spec.module, spec.version, spec.language });

    // Generate behaviors as functions
    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() !void {{
            \\    // TODO: Implement
            \\    return error.NotImplemented;
            \\}}
            \\
            \\
        , .{
            behavior.name,
            behavior.given,
            behavior.when,
            behavior.then,
            behavior.name,
        });
    }

    // Generate tests
    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\test "{s}" {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    
            \\    const result = {s}();
            \\    _ = result catch |err| {{
            \\        if (err == error.NotImplemented) {{
            \\            // Expected for stub
            \\            return;
            \\        }}
            \\        return err;
            \\    }};
            \\}}
            \\
            \\
        , .{
            behavior.name,
            behavior.given,
            behavior.when,
            behavior.then,
            behavior.name,
        });
    }

    return output.toOwnedSlice();
}

test "generate simple code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "zig",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "test \"test_behavior\"") != null);
}
