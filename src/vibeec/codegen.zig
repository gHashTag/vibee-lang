// VIBEEC Code Generator - Multi-target code generation
// Supports: Zig, Python, Rust, Go, Gleam, TypeScript, WASM

const std = @import("std");
const parser = @import("parser.zig");

pub const Target = enum {
    zig,
    python,
    rust,
    go,
    gleam,
    typescript,
    wasm,

    pub fn fromString(s: []const u8) ?Target {
        if (std.mem.eql(u8, s, "zig")) return .zig;
        if (std.mem.eql(u8, s, "python") or std.mem.eql(u8, s, "py")) return .python;
        if (std.mem.eql(u8, s, "rust") or std.mem.eql(u8, s, "rs")) return .rust;
        if (std.mem.eql(u8, s, "go") or std.mem.eql(u8, s, "golang")) return .go;
        if (std.mem.eql(u8, s, "gleam")) return .gleam;
        if (std.mem.eql(u8, s, "typescript") or std.mem.eql(u8, s, "ts")) return .typescript;
        if (std.mem.eql(u8, s, "wasm") or std.mem.eql(u8, s, "webassembly")) return .wasm;
        return null;
    }

    pub fn extension(self: Target) []const u8 {
        return switch (self) {
            .zig => ".zig",
            .python => ".py",
            .rust => ".rs",
            .go => ".go",
            .gleam => ".gleam",
            .typescript => ".ts",
            .wasm => ".wat",
        };
    }
};

pub fn generate(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    const target = Target.fromString(spec.language) orelse .zig;
    return generateForTarget(allocator, spec, target);
}

pub fn generateForTarget(allocator: std.mem.Allocator, spec: parser.Spec, target: Target) ![]const u8 {
    return switch (target) {
        .zig => generateZig(allocator, spec),
        .python => generatePython(allocator, spec),
        .rust => generateRust(allocator, spec),
        .go => generateGo(allocator, spec),
        .gleam => generateGleam(allocator, spec),
        .typescript => generateTypeScript(allocator, spec),
        .wasm => generateWasm(allocator, spec),
    };
}

// ============================================================================
// ZIG CODE GENERATOR
// ============================================================================

fn generateZig(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Zig
        \\
        \\const std = @import("std");
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() !void {{
            \\    // TODO: Implement
            \\    return error.NotImplemented;
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\test "{s}" {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    _ = {s}() catch |err| {{
            \\        if (err == error.NotImplemented) return;
            \\        return err;
            \\    }};
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// PYTHON CODE GENERATOR
// ============================================================================

fn generatePython(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\# Generated by VIBEEC from {s}.vibee
        \\# DO NOT EDIT - This file is auto-generated
        \\# Module: {s} | Version: {s} | Target: Python
        \\
        \\from typing import Any, Optional
        \\import pytest
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\def {s}() -> Any:
            \\    """
            \\    {s}
            \\    
            \\    Given: {s}
            \\    When: {s}
            \\    Then: {s}
            \\    """
            \\    raise NotImplementedError("TODO: Implement")
            \\
            \\
        , .{ behavior.name, behavior.name, behavior.given, behavior.when, behavior.then });
    }

    try writer.print(
        \\# ============================================================================
        \\# Tests
        \\# ============================================================================
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\def test_{s}():
            \\    """
            \\    Given: {s}
            \\    When: {s}
            \\    Then: {s}
            \\    """
            \\    try:
            \\        result = {s}()
            \\        assert result is not None
            \\    except NotImplementedError:
            \\        pytest.skip("Not implemented yet")
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\
        \\if __name__ == "__main__":
        \\    pytest.main([__file__, "-v"])
        \\
    , .{});

    return output.toOwnedSlice();
}

// ============================================================================
// RUST CODE GENERATOR
// ============================================================================

fn generateRust(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Rust
        \\
        \\use std::error::Error;
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\///
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() -> Result<(), Box<dyn Error>> {{
            \\    // TODO: Implement
            \\    Err("Not implemented".into())
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\#[cfg(test)]
        \\mod tests {{
        \\    use super::*;
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\    #[test]
            \\    fn test_{s}() {{
            \\        // Given: {s}
            \\        // When: {s}
            \\        // Then: {s}
            \\        match {s}() {{
            \\            Ok(_) => {{}},
            \\            Err(e) if e.to_string() == "Not implemented" => {{}},
            \\            Err(e) => panic!("Unexpected error: {{}}", e),
            \\        }}
            \\    }}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\}}
        \\
    , .{});

    return output.toOwnedSlice();
}

// ============================================================================
// GO CODE GENERATOR
// ============================================================================

fn generateGo(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Go
        \\
        \\package {s}
        \\
        \\import (
        \\    "errors"
        \\    "testing"
        \\)
        \\
        \\var ErrNotImplemented = errors.New("not implemented")
        \\
        \\
    , .{ spec.name, spec.module, spec.version, spec.name });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\// {s}
            \\// Given: {s}
            \\// When: {s}
            \\// Then: {s}
            \\func {s}() error {{
            \\    // TODO: Implement
            \\    return ErrNotImplemented
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, toPascalCase(behavior.name) });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\func Test{s}(t *testing.T) {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    err := {s}()
            \\    if err != nil && err != ErrNotImplemented {{
            \\        t.Errorf("Unexpected error: %v", err)
            \\    }}
            \\}}
            \\
            \\
        , .{ toPascalCase(behavior.name), behavior.given, behavior.when, behavior.then, toPascalCase(behavior.name) });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// GLEAM CODE GENERATOR
// ============================================================================

fn generateGleam(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Gleam
        \\
        \\import gleam/result
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\///
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() -> Result(Nil, String) {{
            \\  // TODO: Implement
            \\  Error("Not implemented")
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// TYPESCRIPT CODE GENERATOR
// ============================================================================

fn generateTypeScript(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: TypeScript
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/**
            \\ * {s}
            \\ *
            \\ * Given: {s}
            \\ * When: {s}
            \\ * Then: {s}
            \\ */
            \\export function {s}(): void {{
            \\  // TODO: Implement
            \\  throw new Error("Not implemented");
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, toCamelCase(behavior.name) });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\import {{ describe, it, expect }} from "vitest";
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\describe("{s}", () => {{
            \\  it("should work", () => {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    try {{
            \\      {s}();
            \\    }} catch (e) {{
            \\      if ((e as Error).message !== "Not implemented") {{
            \\        throw e;
            \\      }}
            \\    }}
            \\  }});
            \\}});
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, toCamelCase(behavior.name) });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// WASM CODE GENERATOR (WebAssembly Text Format)
// ============================================================================

fn generateWasm(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\;; Generated by VIBEEC from {s}.vibee
        \\;; DO NOT EDIT - This file is auto-generated
        \\;; Module: {s} | Version: {s} | Target: WebAssembly
        \\
        \\(module
        \\  ;; Memory export
        \\  (memory (export "memory") 1)
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\  ;; {s}
            \\  ;; Given: {s}
            \\  ;; When: {s}
            \\  ;; Then: {s}
            \\  (func (export "{s}") (result i32)
            \\    ;; TODO: Implement
            \\    i32.const -1  ;; Return -1 for not implemented
            \\  )
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\)
        \\
    , .{});

    return output.toOwnedSlice();
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn toPascalCase(name: []const u8) []const u8 {
    // Simple implementation - just return as-is for now
    // In production, would convert snake_case to PascalCase
    return name;
}

fn toCamelCase(name: []const u8) []const u8 {
    // Simple implementation - just return as-is for now
    // In production, would convert snake_case to camelCase
    return name;
}

// ============================================================================
// TESTS
// ============================================================================

test "generate zig code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "zig",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Zig") != null);
}

test "generate python code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "python",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "def test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Python") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "import pytest") != null);
}

test "generate rust code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "rust",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Rust") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "#[cfg(test)]") != null);
}

test "generate go code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "go",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "func") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Go") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "package") != null);
}

test "generate typescript code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "typescript",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "export function") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: TypeScript") != null);
}

test "generate wasm code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "wasm",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "(module") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: WebAssembly") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "(func (export") != null);
}

test "target from string" {
    try std.testing.expect(Target.fromString("zig") == .zig);
    try std.testing.expect(Target.fromString("python") == .python);
    try std.testing.expect(Target.fromString("py") == .python);
    try std.testing.expect(Target.fromString("rust") == .rust);
    try std.testing.expect(Target.fromString("rs") == .rust);
    try std.testing.expect(Target.fromString("go") == .go);
    try std.testing.expect(Target.fromString("golang") == .go);
    try std.testing.expect(Target.fromString("gleam") == .gleam);
    try std.testing.expect(Target.fromString("typescript") == .typescript);
    try std.testing.expect(Target.fromString("ts") == .typescript);
    try std.testing.expect(Target.fromString("wasm") == .wasm);
    try std.testing.expect(Target.fromString("unknown") == null);
}
