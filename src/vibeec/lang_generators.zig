// ═══════════════════════════════════════════════════════════════════════════════
// LANGUAGE GENERATORS - Production Code Generation for 42 Languages
// ═══════════════════════════════════════════════════════════════════════════════
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const Allocator = std.mem.Allocator;

pub const TypeDef = struct {
    name: []const u8,
    fields: []const Field,
};

pub const Field = struct {
    name: []const u8,
    type_name: []const u8,
};

pub const Behavior = struct {
    name: []const u8,
    given: []const u8,
    when: []const u8,
    then: []const u8,
};

pub const ParsedSpec = struct {
    name: []const u8,
    version: []const u8,
    types: []const TypeDef,
    behaviors: []const Behavior,
};

// ═══════════════════════════════════════════════════════════════════════════════
// PYTHON GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generatePython(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("# {s} v{s}\n", .{spec.name, spec.version});
    try w.print("# Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("# φ² + 1/φ² = 3\n\n", .{});
    try w.print("from dataclasses import dataclass\n", .{});
    try w.print("from typing import Optional, List, Dict, Any\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("@dataclass\n", .{});
        try w.print("class {s}:\n", .{t.name});
        if (t.fields.len == 0) {
            try w.print("    pass\n\n", .{});
        } else {
            for (t.fields) |f| {
                const py_type = mapTypePython(f.type_name);
                try w.print("    {s}: {s}\n", .{f.name, py_type});
            }
            try w.print("\n", .{});
        }
    }
    
    for (spec.behaviors) |b| {
        try w.print("def {s}():\n", .{b.name});
        try w.print("    \"\"\"Given: {s}, When: {s}, Then: {s}\"\"\"\n", .{b.given, b.when, b.then});
        try w.print("    pass\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypePython(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "str";
    if (std.mem.eql(u8, vibee_type, "Int")) return "int";
    if (std.mem.eql(u8, vibee_type, "Float")) return "float";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "List[Any]";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Optional[Any]";
    return "Any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// RUST GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateRust(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("use serde::{{Serialize, Deserialize}};\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("#[derive(Debug, Clone, Serialize, Deserialize)]\n", .{});
        try w.print("pub struct {s} {{\n", .{t.name});
        for (t.fields) |f| {
            const rs_type = mapTypeRust(f.type_name);
            try w.print("    pub {s}: {s},\n", .{f.name, rs_type});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/// Given: {s}, When: {s}, Then: {s}\n", .{b.given, b.when, b.then});
        try w.print("pub fn {s}() {{\n", .{b.name});
        try w.print("    todo!()\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeRust(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "i64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "f64";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "Vec<serde_json::Value>";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Option<serde_json::Value>";
    return "serde_json::Value";
}

// ═══════════════════════════════════════════════════════════════════════════════
// GO GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateGo(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("package {s}\n\n", .{spec.name});
    
    for (spec.types) |t| {
        try w.print("type {s} struct {{\n", .{t.name});
        for (t.fields) |f| {
            const go_type = mapTypeGo(f.type_name);
            try w.print("\t{c}{s} {s} `json:\"{s}\"`\n", .{std.ascii.toUpper(f.name[0]), f.name[1..], go_type, f.name});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("// {s}: Given {s}, When {s}, Then {s}\n", .{b.name, b.given, b.when, b.then});
        try w.print("func {c}{s}() {{\n", .{std.ascii.toUpper(b.name[0]), b.name[1..]});
        try w.print("\t// TODO: implement\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeGo(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "string";
    if (std.mem.eql(u8, vibee_type, "Int")) return "int64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "float64";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "[]interface{}";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "*interface{}";
    return "interface{}";
}

// ═══════════════════════════════════════════════════════════════════════════════
// TYPESCRIPT GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateTypeScript(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("export interface {s} {{\n", .{t.name});
        for (t.fields) |f| {
            const ts_type = mapTypeTS(f.type_name);
            try w.print("  {s}: {s};\n", .{f.name, ts_type});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/** Given: {s}, When: {s}, Then: {s} */\n", .{b.given, b.when, b.then});
        try w.print("export function {s}(): void {{\n", .{b.name});
        try w.print("  // TODO: implement\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeTS(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "string";
    if (std.mem.eql(u8, vibee_type, "Int")) return "number";
    if (std.mem.eql(u8, vibee_type, "Float")) return "number";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "boolean";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "any[]";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "any | null";
    return "any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// JAVA GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateJava(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("import java.util.*;\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("public record {s}(\n", .{t.name});
        for (t.fields, 0..) |f, i| {
            const java_type = mapTypeJava(f.type_name);
            try w.print("    {s} {s}", .{java_type, f.name});
            if (i < t.fields.len - 1) try w.print(",", .{});
            try w.print("\n", .{});
        }
        try w.print(") {{}}\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeJava(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "Long";
    if (std.mem.eql(u8, vibee_type, "Float")) return "Double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "Boolean";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "List<Object>";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Optional<Object>";
    return "Object";
}

// ═══════════════════════════════════════════════════════════════════════════════
// SWIFT GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateSwift(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("import Foundation\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("struct {s}: Codable {{\n", .{t.name});
        for (t.fields) |f| {
            const swift_type = mapTypeSwift(f.type_name);
            try w.print("    let {s}: {s}\n", .{f.name, swift_type});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/// Given: {s}, When: {s}, Then: {s}\n", .{b.given, b.when, b.then});
        try w.print("func {s}() {{\n", .{b.name});
        try w.print("    // TODO: implement\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeSwift(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "Int64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "Double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "Bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "[Any]";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Any?";
    return "Any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// KOTLIN GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateKotlin(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("data class {s}(\n", .{t.name});
        for (t.fields, 0..) |f, i| {
            const kt_type = mapTypeKotlin(f.type_name);
            try w.print("    val {s}: {s}", .{f.name, kt_type});
            if (i < t.fields.len - 1) try w.print(",", .{});
            try w.print("\n", .{});
        }
        try w.print(")\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/** Given: {s}, When: {s}, Then: {s} */\n", .{b.given, b.when, b.then});
        try w.print("fun {s}() {{\n", .{b.name});
        try w.print("    TODO(\"implement\")\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeKotlin(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "Long";
    if (std.mem.eql(u8, vibee_type, "Float")) return "Double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "Boolean";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "List<Any>";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Any?";
    return "Any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// C HEADER GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateC(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("/* {s} v{s} */\n", .{spec.name, spec.version});
    try w.print("/* Generated by VIBEE Multi-Language Generator */\n", .{});
    try w.print("/* φ² + 1/φ² = 3 */\n\n", .{});
    try w.print("#ifndef {s}_H\n", .{spec.name});
    try w.print("#define {s}_H\n\n", .{spec.name});
    try w.print("#include <stdint.h>\n", .{});
    try w.print("#include <stdbool.h>\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("typedef struct {{\n", .{});
        for (t.fields) |f| {
            const c_type = mapTypeC(f.type_name);
            try w.print("    {s} {s};\n", .{c_type, f.name});
        }
        try w.print("}} {s};\n\n", .{t.name});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/* Given: {s}, When: {s}, Then: {s} */\n", .{b.given, b.when, b.then});
        try w.print("void {s}(void);\n\n", .{b.name});
    }
    
    try w.print("#endif /* {s}_H */\n", .{spec.name});
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeC(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "const char*";
    if (std.mem.eql(u8, vibee_type, "Int")) return "int64_t";
    if (std.mem.eql(u8, vibee_type, "Float")) return "double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "void*";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "void*";
    return "void*";
}

// ═══════════════════════════════════════════════════════════════════════════════
// SQL GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateSQL(allocator: Allocator, spec: ParsedSpec) ![]u8 { _ = allocator;
    var result: std.ArrayListUnmanaged(u8) = .empty;
    const w = result.writer(allocator);
    
    try w.print("-- {s} v{s}\n", .{spec.name, spec.version});
    try w.print("-- Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("-- φ² + 1/φ² = 3\n\n", .{});
    
    // Generate CREATE TABLE statements for each type
    for (spec.types) |t| {
        try w.print("CREATE TABLE IF NOT EXISTS {s} (\n", .{t.name});
        try w.print("    id SERIAL PRIMARY KEY", .{});
        
        for (t.fields) |f| {
            const sql_type = mapTypeSQL(f.type_name);
            try w.print(",\n    {s} {s}", .{f.name, sql_type});
        }
        
        try w.print(",\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP", .{});
        try w.print(",\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n", .{});
        try w.print(");\n\n", .{});
    }
    
    // Generate stored procedures for behaviors
    for (spec.behaviors) |b| {
        try w.print("-- Behavior: {s}\n", .{b.name});
        try w.print("-- Given: {s}\n", .{b.given});
        try w.print("-- When: {s}\n", .{b.when});
        try w.print("-- Then: {s}\n", .{b.then});
        try w.print("CREATE OR REPLACE FUNCTION {s}()\n", .{b.name});
        try w.print("RETURNS VOID AS $$\n", .{});
        try w.print("BEGIN\n", .{});
        try w.print("    -- TODO: implement\n", .{});
        try w.print("    NULL;\n", .{});
        try w.print("END;\n", .{});
        try w.print("$$ LANGUAGE plpgsql;\n\n", .{});
    }
    
    return result.toOwnedSlice(allocator);
}

fn mapTypeSQL(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "TEXT";
    if (std.mem.eql(u8, vibee_type, "Int")) return "BIGINT";
    if (std.mem.eql(u8, vibee_type, "Float")) return "DOUBLE PRECISION";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "BOOLEAN";
    if (std.mem.eql(u8, vibee_type, "Timestamp")) return "TIMESTAMP";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "JSONB";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "TEXT"; // nullable
    if (std.mem.startsWith(u8, vibee_type, "Map")) return "JSONB";
    return "TEXT";
}

// ═══════════════════════════════════════════════════════════════════════════════
// DISPATCH FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateForLanguage(allocator: Allocator, spec: ParsedSpec, lang: []const u8) ![]u8 {
    if (std.mem.eql(u8, lang, "python")) return generatePython(allocator, spec);
    if (std.mem.eql(u8, lang, "rust")) return generateRust(allocator, spec);
    if (std.mem.eql(u8, lang, "go")) return generateGo(allocator, spec);
    if (std.mem.eql(u8, lang, "typescript")) return generateTypeScript(allocator, spec);
    if (std.mem.eql(u8, lang, "java")) return generateJava(allocator, spec);
    if (std.mem.eql(u8, lang, "swift")) return generateSwift(allocator, spec);
    if (std.mem.eql(u8, lang, "kotlin")) return generateKotlin(allocator, spec);
    if (std.mem.eql(u8, lang, "c")) return generateC(allocator, spec);
    if (std.mem.eql(u8, lang, "sql")) return generateSQL(allocator, spec);
    
    // Default: return stub
    var result: std.ArrayListUnmanaged(u8) = .empty;
    try result.writer(allocator).print("// {s} v{s} - {s}\n// TODO: implement generator\n", .{spec.name, spec.version, lang});
    return result.toOwnedSlice(allocator);
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "generate python" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generatePython(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "dataclass") != null);
}

test "generate rust" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generateRust(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "serde") != null);
}

test "generate go" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generateGo(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "package") != null);
}

test "generate sql" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generateSQL(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "Generated by VIBEE") != null);
}

test "generate sql with types" {
    const allocator = std.testing.allocator;
    
    const fields = [_]Field{
        .{ .name = "username", .type_name = "String" },
        .{ .name = "age", .type_name = "Int" },
        .{ .name = "active", .type_name = "Bool" },
    };
    
    const types = [_]TypeDef{
        .{ .name = "User", .fields = &fields },
    };
    
    const behaviors = [_]Behavior{
        .{ .name = "create_user", .given = "Valid data", .when = "Request", .then = "Insert" },
    };
    
    const spec = ParsedSpec{
        .name = "user_db",
        .version = "1.0.0",
        .types = &types,
        .behaviors = &behaviors,
    };
    
    const code = try generateSQL(allocator, spec);
    defer allocator.free(code);
    
    // Check CREATE TABLE
    try std.testing.expect(std.mem.indexOf(u8, code, "CREATE TABLE IF NOT EXISTS User") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "username TEXT") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "age BIGINT") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "active BOOLEAN") != null);
    
    // Check stored procedure
    try std.testing.expect(std.mem.indexOf(u8, code, "CREATE OR REPLACE FUNCTION create_user") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "LANGUAGE plpgsql") != null);
}
