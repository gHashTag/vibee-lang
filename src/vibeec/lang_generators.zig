// ═══════════════════════════════════════════════════════════════════════════════
// LANGUAGE GENERATORS - Production Code Generation for 42 Languages
// ═══════════════════════════════════════════════════════════════════════════════
// φ² + 1/φ² = 3 | PHOENIX = 999
// ═══════════════════════════════════════════════════════════════════════════════

const std = @import("std");
const Allocator = std.mem.Allocator;

pub const TypeDef = struct {
    name: []const u8,
    fields: []const Field,
};

pub const Field = struct {
    name: []const u8,
    type_name: []const u8,
};

pub const Behavior = struct {
    name: []const u8,
    given: []const u8,
    when: []const u8,
    then: []const u8,
};

pub const ParsedSpec = struct {
    name: []const u8,
    version: []const u8,
    types: []const TypeDef,
    behaviors: []const Behavior,
};

// ═══════════════════════════════════════════════════════════════════════════════
// PYTHON GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generatePython(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("# {s} v{s}\n", .{spec.name, spec.version});
    try w.print("# Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("# φ² + 1/φ² = 3\n\n", .{});
    try w.print("from dataclasses import dataclass\n", .{});
    try w.print("from typing import Optional, List, Dict, Any\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("@dataclass\n", .{});
        try w.print("class {s}:\n", .{t.name});
        if (t.fields.len == 0) {
            try w.print("    pass\n\n", .{});
        } else {
            for (t.fields) |f| {
                const py_type = mapTypePython(f.type_name);
                try w.print("    {s}: {s}\n", .{f.name, py_type});
            }
            try w.print("\n", .{});
        }
    }
    
    for (spec.behaviors) |b| {
        try w.print("def {s}():\n", .{b.name});
        try w.print("    \"\"\"Given: {s}, When: {s}, Then: {s}\"\"\"\n", .{b.given, b.when, b.then});
        try w.print("    pass\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypePython(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "str";
    if (std.mem.eql(u8, vibee_type, "Int")) return "int";
    if (std.mem.eql(u8, vibee_type, "Float")) return "float";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "List[Any]";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Optional[Any]";
    return "Any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// RUST GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateRust(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("use serde::{{Serialize, Deserialize}};\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("#[derive(Debug, Clone, Serialize, Deserialize)]\n", .{});
        try w.print("pub struct {s} {{\n", .{t.name});
        for (t.fields) |f| {
            const rs_type = mapTypeRust(f.type_name);
            try w.print("    pub {s}: {s},\n", .{f.name, rs_type});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/// Given: {s}, When: {s}, Then: {s}\n", .{b.given, b.when, b.then});
        try w.print("pub fn {s}() {{\n", .{b.name});
        try w.print("    todo!()\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypeRust(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "i64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "f64";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "Vec<serde_json::Value>";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Option<serde_json::Value>";
    return "serde_json::Value";
}

// ═══════════════════════════════════════════════════════════════════════════════
// GO GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateGo(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("package {s}\n\n", .{spec.name});
    
    for (spec.types) |t| {
        try w.print("type {s} struct {{\n", .{t.name});
        for (t.fields) |f| {
            const go_type = mapTypeGo(f.type_name);
            try w.print("\t{c}{s} {s} `json:\"{s}\"`\n", .{std.ascii.toUpper(f.name[0]), f.name[1..], go_type, f.name});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("// {s}: Given {s}, When {s}, Then {s}\n", .{b.name, b.given, b.when, b.then});
        try w.print("func {c}{s}() {{\n", .{std.ascii.toUpper(b.name[0]), b.name[1..]});
        try w.print("\t// TODO: implement\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypeGo(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "string";
    if (std.mem.eql(u8, vibee_type, "Int")) return "int64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "float64";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "[]interface{}";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "*interface{}";
    return "interface{}";
}

// ═══════════════════════════════════════════════════════════════════════════════
// TYPESCRIPT GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateTypeScript(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("export interface {s} {{\n", .{t.name});
        for (t.fields) |f| {
            const ts_type = mapTypeTS(f.type_name);
            try w.print("  {s}: {s};\n", .{f.name, ts_type});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/** Given: {s}, When: {s}, Then: {s} */\n", .{b.given, b.when, b.then});
        try w.print("export function {s}(): void {{\n", .{b.name});
        try w.print("  // TODO: implement\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypeTS(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "string";
    if (std.mem.eql(u8, vibee_type, "Int")) return "number";
    if (std.mem.eql(u8, vibee_type, "Float")) return "number";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "boolean";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "any[]";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "any | null";
    return "any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// JAVA GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateJava(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("import java.util.*;\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("public record {s}(\n", .{t.name});
        for (t.fields, 0..) |f, i| {
            const java_type = mapTypeJava(f.type_name);
            try w.print("    {s} {s}", .{java_type, f.name});
            if (i < t.fields.len - 1) try w.print(",", .{});
            try w.print("\n", .{});
        }
        try w.print(") {{}}\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypeJava(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "Long";
    if (std.mem.eql(u8, vibee_type, "Float")) return "Double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "Boolean";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "List<Object>";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Optional<Object>";
    return "Object";
}

// ═══════════════════════════════════════════════════════════════════════════════
// SWIFT GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateSwift(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    try w.print("import Foundation\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("struct {s}: Codable {{\n", .{t.name});
        for (t.fields) |f| {
            const swift_type = mapTypeSwift(f.type_name);
            try w.print("    let {s}: {s}\n", .{f.name, swift_type});
        }
        try w.print("}}\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/// Given: {s}, When: {s}, Then: {s}\n", .{b.given, b.when, b.then});
        try w.print("func {s}() {{\n", .{b.name});
        try w.print("    // TODO: implement\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypeSwift(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "Int64";
    if (std.mem.eql(u8, vibee_type, "Float")) return "Double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "Bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "[Any]";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Any?";
    return "Any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// KOTLIN GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateKotlin(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("// {s} v{s}\n", .{spec.name, spec.version});
    try w.print("// Generated by VIBEE Multi-Language Generator\n", .{});
    try w.print("// φ² + 1/φ² = 3\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("data class {s}(\n", .{t.name});
        for (t.fields, 0..) |f, i| {
            const kt_type = mapTypeKotlin(f.type_name);
            try w.print("    val {s}: {s}", .{f.name, kt_type});
            if (i < t.fields.len - 1) try w.print(",", .{});
            try w.print("\n", .{});
        }
        try w.print(")\n\n", .{});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/** Given: {s}, When: {s}, Then: {s} */\n", .{b.given, b.when, b.then});
        try w.print("fun {s}() {{\n", .{b.name});
        try w.print("    TODO(\"implement\")\n", .{});
        try w.print("}}\n\n", .{});
    }
    
    return result.toOwnedSlice();
}

fn mapTypeKotlin(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "String";
    if (std.mem.eql(u8, vibee_type, "Int")) return "Long";
    if (std.mem.eql(u8, vibee_type, "Float")) return "Double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "Boolean";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "List<Any>";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "Any?";
    return "Any";
}

// ═══════════════════════════════════════════════════════════════════════════════
// C HEADER GENERATOR
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateC(allocator: Allocator, spec: ParsedSpec) ![]u8 {
    var result = std.ArrayList(u8).init(allocator);
    const w = result.writer();
    
    try w.print("/* {s} v{s} */\n", .{spec.name, spec.version});
    try w.print("/* Generated by VIBEE Multi-Language Generator */\n", .{});
    try w.print("/* φ² + 1/φ² = 3 */\n\n", .{});
    try w.print("#ifndef {s}_H\n", .{spec.name});
    try w.print("#define {s}_H\n\n", .{spec.name});
    try w.print("#include <stdint.h>\n", .{});
    try w.print("#include <stdbool.h>\n\n", .{});
    
    for (spec.types) |t| {
        try w.print("typedef struct {{\n", .{});
        for (t.fields) |f| {
            const c_type = mapTypeC(f.type_name);
            try w.print("    {s} {s};\n", .{c_type, f.name});
        }
        try w.print("}} {s};\n\n", .{t.name});
    }
    
    for (spec.behaviors) |b| {
        try w.print("/* Given: {s}, When: {s}, Then: {s} */\n", .{b.given, b.when, b.then});
        try w.print("void {s}(void);\n\n", .{b.name});
    }
    
    try w.print("#endif /* {s}_H */\n", .{spec.name});
    
    return result.toOwnedSlice();
}

fn mapTypeC(vibee_type: []const u8) []const u8 {
    if (std.mem.eql(u8, vibee_type, "String")) return "const char*";
    if (std.mem.eql(u8, vibee_type, "Int")) return "int64_t";
    if (std.mem.eql(u8, vibee_type, "Float")) return "double";
    if (std.mem.eql(u8, vibee_type, "Bool")) return "bool";
    if (std.mem.startsWith(u8, vibee_type, "List")) return "void*";
    if (std.mem.startsWith(u8, vibee_type, "Option")) return "void*";
    return "void*";
}

// ═══════════════════════════════════════════════════════════════════════════════
// DISPATCH FUNCTION
// ═══════════════════════════════════════════════════════════════════════════════

pub fn generateForLanguage(allocator: Allocator, spec: ParsedSpec, lang: []const u8) ![]u8 {
    if (std.mem.eql(u8, lang, "python")) return generatePython(allocator, spec);
    if (std.mem.eql(u8, lang, "rust")) return generateRust(allocator, spec);
    if (std.mem.eql(u8, lang, "go")) return generateGo(allocator, spec);
    if (std.mem.eql(u8, lang, "typescript")) return generateTypeScript(allocator, spec);
    if (std.mem.eql(u8, lang, "java")) return generateJava(allocator, spec);
    if (std.mem.eql(u8, lang, "swift")) return generateSwift(allocator, spec);
    if (std.mem.eql(u8, lang, "kotlin")) return generateKotlin(allocator, spec);
    if (std.mem.eql(u8, lang, "c")) return generateC(allocator, spec);
    
    // Default: return stub
    var result = std.ArrayList(u8).init(allocator);
    try result.writer().print("// {s} v{s} - {s}\n// TODO: implement generator\n", .{spec.name, spec.version, lang});
    return result.toOwnedSlice();
}

// ═══════════════════════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════════════════════

test "generate python" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generatePython(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "dataclass") != null);
}

test "generate rust" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generateRust(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "serde") != null);
}

test "generate go" {
    const allocator = std.testing.allocator;
    const spec = ParsedSpec{
        .name = "test",
        .version = "1.0.0",
        .types = &[_]TypeDef{},
        .behaviors = &[_]Behavior{},
    };
    const code = try generateGo(allocator, spec);
    defer allocator.free(code);
    try std.testing.expect(std.mem.indexOf(u8, code, "package") != null);
}
