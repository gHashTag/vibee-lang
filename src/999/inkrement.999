// ============================================
// ИНКРЕМЕНТАЛЬНАЯ КОМПИЛЯЦИЯ
// Перекомпиляция только изменённых файлов
// ============================================
//
// Основано на:
//   - Salsa (Rust-analyzer)
//   - Query-based compilation
//   - Incremental computation
//
// Ускорение: 10-100x для больших проектов
//
// ============================================

Ⲩ yadro
Ⲩ gorynych

// ============================================
// ХЭШИРОВАНИЕ
// ============================================

// Хэш содержимого файла
Ⲫ хэш_содержимого(данные: [Ⲋ]) -> Ⲋ:
  // FNV-1a хэш
  Ⲙ хэш: Ⲋ = 0xcbf29ce484222325
  Ⲯ байт данные:
    хэш = хэш ^ байт
    хэш = хэш * 0x100000001b3
  Ⲣ хэш

// Хэш AST узла
Ⲫ хэш_ast(узел: ⲨⲂ) -> Ⲋ:
  Ⲙ хэш = хэш_содержимого(узел.Ⲅ.байты())
  хэш = хэш ^ (узел.Ⲁ * 31)
  Ⲯ ребёнок узел.Ⲃ:
    хэш = хэш ^ хэш_ast(ребёнок)
  Ⲣ хэш

// ============================================
// ГРАФ ЗАВИСИМОСТЕЙ
// ============================================

// Узел графа зависимостей
Ⲏ ⲨⲌⲀ:
  путь: Ⲥ
  хэш: Ⲋ
  зависимости: [Ⲥ]      // от кого зависит
  зависимые: [Ⲥ]        // кто зависит от нас
  состояние: Ⲉ ⲨⲌⲂ

// Состояние узла
Ⲉ ⲨⲌⲂ:
  Ⲁ    // чистый (не изменился)
  Ⲃ    // грязный (нужна перекомпиляция)
  Ⲅ    // в процессе компиляции
  Ⲇ    // скомпилирован

// Граф зависимостей
Ⲏ ⲨⲌ:
  узлы: {Ⲥ: ⲨⲌⲀ}
  порядок: [Ⲥ]          // топологический порядок

// Создать граф
Ⲫ ⲨⲌ_новый() -> ⲨⲌ:
  Ⲣ ⲨⲌ { узлы: {}, порядок: [] }

// Добавить файл
Ⲫ ⲨⲌ_добавить(г: ⲨⲌ, путь: Ⲥ, зависимости: [Ⲥ]):
  Ⲙ хэш = хэш_содержимого(читать_файл(путь).байты())
  
  г.узлы[путь] = ⲨⲌⲀ {
    путь: путь,
    хэш: хэш,
    зависимости: зависимости,
    зависимые: [],
    состояние: Ⲃ  // грязный по умолчанию
  }
  
  // Обновляем обратные зависимости
  Ⲯ зав зависимости:
    Ⲝ зав ∈ г.узлы:
      Ⲁ: г.узлы[зав].зависимые += путь

// Топологическая сортировка
Ⲫ ⲨⲌ_топсорт(г: ⲨⲌ) -> [Ⲥ]:
  Ⲙ посещённые: {Ⲥ} = {}
  Ⲙ результат: [Ⲥ] = []
  
  Ⲫ посетить(путь: Ⲥ):
    Ⲝ путь ∈ посещённые:
      Ⲁ: Ⲣ
    посещённые += путь
    
    Ⲯ зав г.узлы[путь].зависимости:
      посетить(зав)
    
    результат += путь
  
  Ⲯ (путь, _) г.узлы:
    посетить(путь)
  
  г.порядок = результат
  Ⲣ результат

// Пометить грязные узлы
Ⲫ ⲨⲌ_пометить_грязные(г: ⲨⲌ):
  // Проверяем изменения файлов
  Ⲯ (путь, узел) г.узлы:
    Ⲙ текущий_хэш = хэш_содержимого(читать_файл(путь).байты())
    Ⲝ текущий_хэш != узел.хэш:
      Ⲁ:
        узел.состояние = Ⲃ
        узел.хэш = текущий_хэш
        // Помечаем зависимые как грязные
        ⲨⲌ_распространить_грязь(г, путь)

// Распространить грязь по зависимым
Ⲫ ⲨⲌ_распространить_грязь(г: ⲨⲌ, путь: Ⲥ):
  Ⲯ зависимый г.узлы[путь].зависимые:
    Ⲝ г.узлы[зависимый].состояние != Ⲃ:
      Ⲁ:
        г.узлы[зависимый].состояние = Ⲃ
        ⲨⲌ_распространить_грязь(г, зависимый)

// ============================================
// КЭШ КОМПИЛЯЦИИ
// ============================================

// Запись кэша
Ⲏ ⲨⲎⲂ:
  путь: Ⲥ
  хэш_исходника: Ⲋ
  хэш_зависимостей: Ⲋ
  токены: [ⲨⲀ]?
  ast: ⲨⲂ?
  ir: ⲨⲄ?
  код: Ⲥ?

// Кэш компиляции
Ⲏ ⲨⲎⲄ:
  записи: {Ⲥ: ⲨⲎⲂ}
  граф: ⲨⲌ
  статистика: ⲨⲎⲆ

// Статистика
Ⲏ ⲨⲎⲆ:
  попадания: Ⲋ
  промахи: Ⲋ
  время_сэкономлено: Ⲋ

// Создать кэш
Ⲫ ⲨⲎⲄ_новый() -> ⲨⲎⲄ:
  Ⲣ ⲨⲎⲄ {
    записи: {},
    граф: ⲨⲌ_новый(),
    статистика: ⲨⲎⲆ { попадания: 0, промахи: 0, время_сэкономлено: 0 }
  }

// Загрузить кэш с диска
Ⲫ ⲨⲎⲄ_загрузить(путь: Ⲥ) -> ⲨⲎⲄ?:
  Ⲝ !файл_существует(путь):
    Ⲁ: Ⲣ None
  
  Ⲙ данные = читать_файл(путь)
  Ⲣ Some(десериализовать(данные))

// Сохранить кэш на диск
Ⲫ ⲨⲎⲄ_сохранить(кэш: ⲨⲎⲄ, путь: Ⲥ):
  Ⲙ данные = сериализовать(кэш)
  записать_файл(путь, данные)

// ============================================
// ИНКРЕМЕНТАЛЬНЫЙ КОМПИЛЯТОР
// ============================================

Ⲏ ⲢⲒ:  // инкрементальный компилятор
  горыныч: Ⲣ
  кэш: ⲨⲎⲄ
  корень: Ⲥ

// Создать инкрементальный компилятор
Ⲫ ⲢⲒ_новый(корень: Ⲥ, цель: Ⲉ ⲢⲄⲀ, уровень: Ⲋ) -> ⲢⲒ:
  Ⲙ кэш_путь = корень + "/.999cache"
  Ⲙ кэш = ⲨⲎⲄ_загрузить(кэш_путь) ?? ⲨⲎⲄ_новый()
  
  Ⲣ ⲢⲒ {
    горыныч: ⲢⲀ(цель, уровень),
    кэш: кэш,
    корень: корень
  }

// Компилировать файл инкрементально
Ⲫ ⲢⲒ_компилировать_файл(комп: ⲢⲒ, путь: Ⲥ) -> Ⲥ:
  Ⲙ начало = время_сейчас()
  
  // Проверяем кэш
  Ⲝ путь ∈ комп.кэш.записи:
    Ⲁ:
      Ⲙ запись = комп.кэш.записи[путь]
      Ⲙ текущий_хэш = хэш_содержимого(читать_файл(путь).байты())
      
      Ⲝ текущий_хэш == запись.хэш_исходника:
        Ⲁ:
          // Проверяем зависимости
          Ⲙ хэш_зав = хэш_зависимостей(комп, запись)
          Ⲝ хэш_зав == запись.хэш_зависимостей && запись.код != None:
            Ⲁ:
              // Попадание в кэш!
              комп.кэш.статистика.попадания += 1
              комп.кэш.статистика.время_сэкономлено += время_сейчас() - начало
              Ⲣ запись.код
  
  // Промах — компилируем
  комп.кэш.статистика.промахи += 1
  
  Ⲙ исходник = читать_файл(путь)
  Ⲙ код = ⲢⲂ(комп.горыныч, исходник)
  
  // Сохраняем в кэш
  комп.кэш.записи[путь] = ⲨⲎⲂ {
    путь: путь,
    хэш_исходника: хэш_содержимого(исходник.байты()),
    хэш_зависимостей: хэш_зависимостей(комп, комп.кэш.записи[путь]),
    токены: None,  // можно сохранить для отладки
    ast: None,
    ir: None,
    код: Some(код)
  }
  
  Ⲣ код

// Хэш зависимостей
Ⲫ хэш_зависимостей(комп: ⲢⲒ, запись: ⲨⲎⲂ) -> Ⲋ:
  Ⲙ хэш: Ⲋ = 0
  
  Ⲝ запись.путь ∈ комп.кэш.граф.узлы:
    Ⲁ:
      Ⲯ зав комп.кэш.граф.узлы[запись.путь].зависимости:
        Ⲝ зав ∈ комп.кэш.записи:
          Ⲁ: хэш = хэш ^ комп.кэш.записи[зав].хэш_исходника
  
  Ⲣ хэш

// Компилировать проект
Ⲫ ⲢⲒ_компилировать_проект(комп: ⲢⲒ) -> {Ⲥ: Ⲥ}:
  Ⲙ результаты: {Ⲥ: Ⲥ} = {}
  
  // Находим все .999 файлы
  Ⲙ файлы = найти_файлы(комп.корень, "*.999")
  
  // Строим граф зависимостей
  Ⲯ файл файлы:
    Ⲙ зависимости = извлечь_импорты(файл)
    ⲨⲌ_добавить(комп.кэш.граф, файл, зависимости)
  
  // Топологическая сортировка
  Ⲙ порядок = ⲨⲌ_топсорт(комп.кэш.граф)
  
  // Помечаем грязные
  ⲨⲌ_пометить_грязные(комп.кэш.граф)
  
  // Компилируем в правильном порядке
  Ⲯ файл порядок:
    Ⲝ комп.кэш.граф.узлы[файл].состояние == Ⲃ:
      Ⲁ:
        результаты[файл] = ⲢⲒ_компилировать_файл(комп, файл)
        комп.кэш.граф.узлы[файл].состояние = Ⲇ
  
  // Сохраняем кэш
  ⲨⲎⲄ_сохранить(комп.кэш, комп.корень + "/.999cache")
  
  // Выводим статистику
  печать(format!(
    "Компиляция завершена: {} попаданий, {} промахов, сэкономлено {}ms",
    комп.кэш.статистика.попадания,
    комп.кэш.статистика.промахи,
    комп.кэш.статистика.время_сэкономлено
  ))
  
  Ⲣ результаты

// ============================================
// WATCH MODE
// ============================================

// Режим наблюдения за изменениями
Ⲫ ⲢⲒ_watch(комп: ⲢⲒ):
  печать("Наблюдение за изменениями в " + комп.корень)
  
  Ⲙ последние_хэши: {Ⲥ: Ⲋ} = {}
  
  // Инициализируем хэши
  Ⲙ файлы = найти_файлы(комп.корень, "*.999")
  Ⲯ файл файлы:
    последние_хэши[файл] = хэш_содержимого(читать_файл(файл).байты())
  
  // Бесконечный цикл наблюдения
  Ⲯ Ⲁ:
    спать(100)  // 100ms
    
    Ⲙ изменённые: [Ⲥ] = []
    
    Ⲯ файл файлы:
      Ⲙ текущий_хэш = хэш_содержимого(читать_файл(файл).байты())
      Ⲝ текущий_хэш != последние_хэши[файл]:
        Ⲁ:
          изменённые += файл
          последние_хэши[файл] = текущий_хэш
    
    Ⲝ длина(изменённые) > 0:
      Ⲁ:
        печать(format!("Изменены: {}", изменённые.join(", ")))
        
        // Перекомпилируем только изменённые и зависимые
        Ⲯ файл изменённые:
          ⲨⲌ_распространить_грязь(комп.кэш.граф, файл)
        
        ⲢⲒ_компилировать_проект(комп)

// ============================================
// ПАРАЛЛЕЛЬНАЯ КОМПИЛЯЦИЯ
// ============================================

// Компилировать параллельно (по уровням графа)
Ⲫ ⲢⲒ_компилировать_параллельно(комп: ⲢⲒ) -> {Ⲥ: Ⲥ}:
  Ⲙ результаты: {Ⲥ: Ⲥ} = {}
  
  // Группируем по уровням (файлы без зависимостей друг на друга)
  Ⲙ уровни = группировать_по_уровням(комп.кэш.граф)
  
  Ⲯ уровень уровни:
    // Файлы одного уровня можно компилировать параллельно
    Ⲙ задачи: [Future<Ⲥ>] = []
    
    Ⲯ файл уровень:
      Ⲝ комп.кэш.граф.узлы[файл].состояние == Ⲃ:
        Ⲁ:
          задачи += spawn(|| ⲢⲒ_компилировать_файл(комп, файл))
    
    // Ждём завершения всех задач уровня
    Ⲯ (файл, задача) zip(уровень, задачи):
      результаты[файл] = await(задача)
      комп.кэш.граф.узлы[файл].состояние = Ⲇ
  
  Ⲣ результаты

// Группировка по уровням
Ⲫ группировать_по_уровням(граф: ⲨⲌ) -> [[Ⲥ]]:
  Ⲙ уровни: [[Ⲥ]] = []
  Ⲙ обработанные: {Ⲥ} = {}
  
  Ⲯ длина(обработанные) < длина(граф.узлы):
    Ⲙ текущий_уровень: [Ⲥ] = []
    
    Ⲯ (путь, узел) граф.узлы:
      Ⲝ путь ∉ обработанные:
        Ⲁ:
          // Проверяем, что все зависимости обработаны
          Ⲙ готов = Ⲁ
          Ⲯ зав узел.зависимости:
            Ⲝ зав ∉ обработанные:
              Ⲁ: готов = Ⲃ
          
          Ⲝ готов:
            Ⲁ: текущий_уровень += путь
    
    Ⲯ путь текущий_уровень:
      обработанные += путь
    
    уровни += текущий_уровень
  
  Ⲣ уровни
