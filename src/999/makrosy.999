// ============================================
// СИСТЕМА МАКРОСОВ ЯЗЫКА 999
// ============================================

// Виды макросов
Ⲉ ⲨⲘⲀ:
  Ⲁ    // декларативный
  Ⲃ    // процедурный
  Ⲅ    // derive
  Ⲇ    // атрибутный
  Ⲉ    // гигиенический

// Макрос
Ⲏ ⲨⲘ:
  Ⲁ: Ⲥ        // имя
  Ⲃ: Ⲉ ⲨⲘⲀ    // вид
  Ⲅ: [ⲨⲘⲂ]    // правила
  Ⲇ: Ⲧ        // гигиенический?

// Правило макроса
Ⲏ ⲨⲘⲂ:
  Ⲁ: Ⲥ        // паттерн
  Ⲃ: Ⲥ        // развёртка

// Макропроцессор
Ⲏ ⲢⲘ:
  Ⲁ: {Ⲥ: ⲨⲘ}  // макросы
  Ⲃ: Ⲋ        // счётчик гигиены

// Создать процессор
Ⲫ ⲢⲘⲀ() -> ⲢⲘ:
  Ⲙ п = ⲢⲘ { Ⲁ: {}, Ⲃ: 0 }
  // Встроенные макросы
  п = зарег_derive(п)
  п = зарег_route(п)
  п = зарег_test(п)
  п = зарег_cache(п)
  п = зарег_validate(п)
  Ⲣ п

// ============================================
// @Ⲇ — DERIVE МАКРОС
// ============================================

Ⲫ зарег_derive(п: ⲢⲘ) -> ⲢⲘ:
  п.Ⲁ["Ⲇ"] = ⲨⲘ {
    Ⲁ: "Ⲇ",
    Ⲃ: Ⲅ,
    Ⲅ: [],
    Ⲇ: Ⲁ
  }
  Ⲣ п

// Развернуть derive
Ⲫ развернуть_derive(узел: ⲨⲂ, трейты: [Ⲥ]) -> ⲨⲂ:
  Ⲙ методы: [ⲨⲂ] = []
  
  Ⲯ т трейты:
    Ⲝ т:
      "Entity":
        методы += ген_entity(узел)
      "Serialize":
        методы += ген_serialize(узел)
      "Deserialize":
        методы += ген_deserialize(узел)
      "Clone":
        методы += ген_clone(узел)
      "Debug":
        методы += ген_debug(узел)
      "Eq":
        методы += ген_eq(узел)
      "Hash":
        методы += ген_hash(узел)
      "Default":
        методы += ген_default(узел)
      "Builder":
        методы += ген_builder(узел)
  
  Ⲣ ⲨⲂ { Ⲁ: Ⲁ, Ⲃ: [узел] + методы, Ⲅ: "" }

// Генерация Entity
Ⲫ ген_entity(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ имя = узел.Ⲅ
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    // table_name
    ⲨⲂ_fn("table_name", [], "Ⲥ", 
      ⲨⲂ_ret(ⲨⲂ_str(имя.lower()))),
    
    // columns
    ⲨⲂ_fn("columns", [], "[ColumnDef]",
      ⲨⲂ_ret(ⲨⲂ_list(поля.map(п -> 
        ⲨⲂ_call("ColumnDef", [п.Ⲁ, п.Ⲃ]))))),
    
    // from_row
    ⲨⲂ_fn("from_row", [("row", "Row")], "Result<Self>",
      ⲨⲂ_ret(ⲨⲂ_struct(имя, поля.map(п ->
        (п.Ⲁ, ⲨⲂ_call("row.get", [п.Ⲁ])))))),
    
    // to_row
    ⲨⲂ_fn("to_row", [], "Map<Ⲥ, Value>",
      ⲨⲂ_ret(ⲨⲂ_map(поля.map(п ->
        (п.Ⲁ, ⲨⲂ_field("self", п.Ⲁ)))))),
    
    // id
    ⲨⲂ_fn("id", [], "Option<Value>",
      ⲨⲂ_ret(ⲨⲂ_field("self", "id")))
  ]

// Генерация Serialize
Ⲫ ген_serialize(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    // to_json
    ⲨⲂ_fn("to_json", [], "Ⲥ",
      ⲨⲂ_ret(ⲨⲂ_call("json.encode", [ⲨⲂ_self()]))),
    
    // to_yaml
    ⲨⲂ_fn("to_yaml", [], "Ⲥ",
      ⲨⲂ_ret(ⲨⲂ_call("yaml.encode", [ⲨⲂ_self()]))),
    
    // to_msgpack
    ⲨⲂ_fn("to_msgpack", [], "[Ⲋ]",
      ⲨⲂ_ret(ⲨⲂ_call("msgpack.encode", [ⲨⲂ_self()])))
  ]

// Генерация Deserialize
Ⲫ ген_deserialize(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ имя = узел.Ⲅ
  
  Ⲣ [
    // from_json
    ⲨⲂ_fn("from_json", [("s", "Ⲥ")], "Result<Self>",
      ⲨⲂ_ret(ⲨⲂ_call("json.decode", [ⲨⲂ_var("s")]))),
    
    // from_yaml
    ⲨⲂ_fn("from_yaml", [("s", "Ⲥ")], "Result<Self>",
      ⲨⲂ_ret(ⲨⲂ_call("yaml.decode", [ⲨⲂ_var("s")])))
  ]

// Генерация Clone
Ⲫ ген_clone(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ имя = узел.Ⲅ
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    ⲨⲂ_fn("clone", [], "Self",
      ⲨⲂ_ret(ⲨⲂ_struct(имя, поля.map(п ->
        (п.Ⲁ, ⲨⲂ_call("clone", [ⲨⲂ_field("self", п.Ⲁ)]))))))
  ]

// Генерация Debug
Ⲫ ген_debug(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ имя = узел.Ⲅ
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    ⲨⲂ_fn("debug", [], "Ⲥ",
      ⲨⲂ_ret(ⲨⲂ_format(имя + " { " + 
        поля.map(п -> п.Ⲁ + ": {:?}").join(", ") + " }",
        поля.map(п -> ⲨⲂ_field("self", п.Ⲁ)))))
  ]

// Генерация Eq
Ⲫ ген_eq(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    ⲨⲂ_fn("eq", [("other", "Self")], "Ⲧ",
      ⲨⲂ_ret(ⲨⲂ_and(поля.map(п ->
        ⲨⲂ_eq(ⲨⲂ_field("self", п.Ⲁ), ⲨⲂ_field("other", п.Ⲁ)))))),
    
    ⲨⲂ_fn("ne", [("other", "Self")], "Ⲧ",
      ⲨⲂ_ret(ⲨⲂ_not(ⲨⲂ_call("eq", [ⲨⲂ_var("other")]))))
  ]

// Генерация Hash
Ⲫ ген_hash(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    ⲨⲂ_fn("hash", [], "Ⲋ",
      ⲨⲂ_block([
        ⲨⲂ_let("h", ⲨⲂ_num(0)),
        ...поля.map(п ->
          ⲨⲂ_assign("h", ⲨⲂ_xor(
            ⲨⲂ_mul(ⲨⲂ_var("h"), ⲨⲂ_num(31)),
            ⲨⲂ_call("hash", [ⲨⲂ_field("self", п.Ⲁ)])))),
        ⲨⲂ_ret(ⲨⲂ_var("h"))
      ]))
  ]

// Генерация Default
Ⲫ ген_default(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ имя = узел.Ⲅ
  Ⲙ поля = узел.Ⲃ
  
  Ⲣ [
    ⲨⲂ_fn("default", [], "Self",
      ⲨⲂ_ret(ⲨⲂ_struct(имя, поля.map(п ->
        (п.Ⲁ, ⲨⲂ_call("Default.default", []))))))
  ]

// Генерация Builder
Ⲫ ген_builder(узел: ⲨⲂ) -> [ⲨⲂ]:
  Ⲙ имя = узел.Ⲅ
  Ⲙ поля = узел.Ⲃ
  
  Ⲙ методы: [ⲨⲂ] = []
  
  // with_* методы
  Ⲯ п поля:
    методы += ⲨⲂ_fn("with_" + п.Ⲁ, [(п.Ⲁ, п.Ⲃ)], "Self",
      ⲨⲂ_block([
        ⲨⲂ_assign(ⲨⲂ_field("self", п.Ⲁ), ⲨⲂ_var(п.Ⲁ)),
        ⲨⲂ_ret(ⲨⲂ_self())
      ]))
  
  // build метод
  методы += ⲨⲂ_fn("build", [], "Self",
    ⲨⲂ_ret(ⲨⲂ_self()))
  
  Ⲣ методы

// ============================================
// @Ⲣ — ROUTE МАКРОС
// ============================================

Ⲫ зарег_route(п: ⲢⲘ) -> ⲢⲘ:
  п.Ⲁ["Ⲣ"] = ⲨⲘ {
    Ⲁ: "Ⲣ",
    Ⲃ: Ⲇ,
    Ⲅ: [],
    Ⲇ: Ⲁ
  }
  Ⲣ п

// Развернуть route
Ⲫ развернуть_route(fn_узел: ⲨⲂ, метод: Ⲥ, путь: Ⲥ) -> ⲨⲂ:
  Ⲙ имя_fn = fn_узел.Ⲅ
  
  // Генерируем регистрацию маршрута
  Ⲣ ⲨⲂ { 
    Ⲁ: Ⲁ,  // модуль
    Ⲃ: [
      fn_узел,
      // router.route(метод, путь, имя_fn)
      ⲨⲂ_call("__router.route", [
        ⲨⲂ_var("Method." + метод),
        ⲨⲂ_str(путь),
        ⲨⲂ_var(имя_fn)
      ])
    ],
    Ⲅ: ""
  }

// ============================================
// @Ⲧ — TEST МАКРОС
// ============================================

Ⲫ зарег_test(п: ⲢⲘ) -> ⲢⲘ:
  п.Ⲁ["Ⲧ"] = ⲨⲘ {
    Ⲁ: "Ⲧ",
    Ⲃ: Ⲇ,
    Ⲅ: [],
    Ⲇ: Ⲁ
  }
  Ⲣ п

// Развернуть test
Ⲫ развернуть_test(fn_узел: ⲨⲂ) -> ⲨⲂ:
  Ⲙ имя = fn_узел.Ⲅ
  
  Ⲣ ⲨⲂ {
    Ⲁ: Ⲁ,
    Ⲃ: [
      fn_узел,
      // __tests.register(имя, fn)
      ⲨⲂ_call("__tests.register", [
        ⲨⲂ_str(имя),
        ⲨⲂ_var(имя)
      ])
    ],
    Ⲅ: ""
  }

// ============================================
// @Ⲕ — CACHE МАКРОС
// ============================================

Ⲫ зарег_cache(п: ⲢⲘ) -> ⲢⲘ:
  п.Ⲁ["Ⲕ"] = ⲨⲘ {
    Ⲁ: "Ⲕ",
    Ⲃ: Ⲇ,
    Ⲅ: [],
    Ⲇ: Ⲁ
  }
  Ⲣ п

// Развернуть cache
Ⲫ развернуть_cache(fn_узел: ⲨⲂ, ttl: Ⲋ) -> ⲨⲂ:
  Ⲙ имя = fn_узел.Ⲅ
  Ⲙ тело = fn_узел.Ⲃ[0]  // тело функции
  Ⲙ парамы = fn_узел.Ⲃ[1]  // параметры
  
  // Генерируем обёртку с кэшем
  Ⲣ ⲨⲂ_fn(имя, парамы, fn_узел.Ⲃ[2],
    ⲨⲂ_block([
      // ключ кэша
      ⲨⲂ_let("__key", ⲨⲂ_call("cache_key", [
        ⲨⲂ_str(имя),
        ...парамы.map(п -> ⲨⲂ_var(п.Ⲁ))
      ])),
      // проверка кэша
      ⲨⲂ_if(
        ⲨⲂ_call("__cache.has", [ⲨⲂ_var("__key")]),
        ⲨⲂ_ret(ⲨⲂ_call("__cache.get", [ⲨⲂ_var("__key")])),
        ⲨⲂ_block([
          ⲨⲂ_let("__result", тело),
          ⲨⲂ_call("__cache.set", [
            ⲨⲂ_var("__key"),
            ⲨⲂ_var("__result"),
            ⲨⲂ_num(ttl)
          ]),
          ⲨⲂ_ret(ⲨⲂ_var("__result"))
        ])
      )
    ]))

// ============================================
// @Ⲃ — VALIDATE МАКРОС
// ============================================

Ⲫ зарег_validate(п: ⲢⲘ) -> ⲢⲘ:
  п.Ⲁ["Ⲃ"] = ⲨⲘ {
    Ⲁ: "Ⲃ",
    Ⲃ: Ⲇ,
    Ⲅ: [],
    Ⲇ: Ⲁ
  }
  Ⲣ п

// Развернуть validate
Ⲫ развернуть_validate(поле: Ⲥ, правила: [Ⲥ]) -> ⲨⲂ:
  Ⲙ проверки: [ⲨⲂ] = []
  
  Ⲯ правило правила:
    Ⲝ правило:
      "not_empty":
        проверки += ⲨⲂ_if(
          ⲨⲂ_call("is_empty", [ⲨⲂ_var(поле)]),
          ⲨⲂ_ret(ⲨⲂ_err(поле + " не может быть пустым")),
          ⲨⲂ_nop())
      "email":
        проверки += ⲨⲂ_if(
          ⲨⲂ_not(ⲨⲂ_call("is_email", [ⲨⲂ_var(поле)])),
          ⲨⲂ_ret(ⲨⲂ_err(поле + " должен быть email")),
          ⲨⲂ_nop())
      _:
        // min(n), max(n), regex(...)
        Ⲝ правило.starts_with("min("):
          Ⲁ:
            Ⲙ n = parse_num(правило)
            проверки += ⲨⲂ_if(
              ⲨⲂ_lt(ⲨⲂ_call("len", [ⲨⲂ_var(поле)]), ⲨⲂ_num(n)),
              ⲨⲂ_ret(ⲨⲂ_err(поле + " минимум " + n + " символов")),
              ⲨⲂ_nop())
        Ⲝ правило.starts_with("max("):
          Ⲁ:
            Ⲙ n = parse_num(правило)
            проверки += ⲨⲂ_if(
              ⲨⲂ_gt(ⲨⲂ_call("len", [ⲨⲂ_var(поле)]), ⲨⲂ_num(n)),
              ⲨⲂ_ret(ⲨⲂ_err(поле + " максимум " + n + " символов")),
              ⲨⲂ_nop())
  
  Ⲣ ⲨⲂ_block(проверки)

// ============================================
// ГЛАВНЫЙ РАЗВЁРТЫВАТЕЛЬ
// ============================================

Ⲫ развернуть(п: ⲢⲘ, ast: ⲨⲂ) -> ⲨⲂ:
  // Рекурсивно обходим AST
  Ⲝ ast.Ⲁ:
    Ⲃ:  // структура с атрибутами
      Ⲣ развернуть_структуру(п, ast)
    Ⲇ:  // функция с атрибутами
      Ⲣ развернуть_функцию(п, ast)
    _:
      // Рекурсивно для детей
      ast.Ⲃ = ast.Ⲃ.map(ребёнок -> развернуть(п, ребёнок))
      Ⲣ ast

Ⲫ развернуть_структуру(п: ⲢⲘ, ast: ⲨⲂ) -> ⲨⲂ:
  Ⲙ атрибуты = получить_атрибуты(ast)
  
  Ⲯ атр атрибуты:
    Ⲝ атр.starts_with("@Ⲇ("):
      Ⲁ:
        Ⲙ трейты = parse_traits(атр)
        Ⲣ развернуть_derive(ast, трейты)
  
  Ⲣ ast

Ⲫ развернуть_функцию(п: ⲢⲘ, ast: ⲨⲂ) -> ⲨⲂ:
  Ⲙ атрибуты = получить_атрибуты(ast)
  
  Ⲯ атр атрибуты:
    Ⲝ атр.starts_with("@Ⲣ("):
      Ⲁ:
        Ⲙ (метод, путь) = parse_route(атр)
        Ⲣ развернуть_route(ast, метод, путь)
    Ⲝ атр == "@Ⲧ":
      Ⲁ:
        Ⲣ развернуть_test(ast)
    Ⲝ атр.starts_with("@Ⲕ("):
      Ⲁ:
        Ⲙ ttl = parse_ttl(атр)
        Ⲣ развернуть_cache(ast, ttl)
  
  Ⲣ ast
