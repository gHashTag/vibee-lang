// ============================================
// ОТЛАДЧИК ДЛЯ ЯЗЫКА 999
// Debug Adapter Protocol (DAP)
// ============================================
//
// Функции:
//   - Точки останова (breakpoints)
//   - Пошаговое выполнение
//   - Просмотр переменных
//   - Стек вызовов
//   - Watch выражения
//   - Условные точки останова
//
// ============================================

Ⲩ runtime
Ⲩ gorynych

// ============================================
// ТИПЫ ОТЛАДЧИКА
// ============================================

// Точка останова
Ⲏ ⲨⲆⲂ:
  id: Ⲋ
  файл: Ⲥ
  строка: Ⲋ
  условие: Ⲥ?
  счётчик: Ⲋ?        // сработать после N попаданий
  попадания: Ⲋ
  активна: Ⲧ

// Кадр стека
Ⲏ ⲨⲆⲤ:
  id: Ⲋ
  имя: Ⲥ
  файл: Ⲥ
  строка: Ⲋ
  столбец: Ⲋ
  локальные: {Ⲥ: ⲨⲆⲂⲁ}

// Переменная
Ⲏ ⲨⲆⲂⲁ:
  имя: Ⲥ
  значение: Ⲥ
  тип: Ⲥ
  ссылка: Ⲋ?        // для составных типов

// Состояние отладки
Ⲉ ⲨⲆⲤⲧ:
  Ⲁ    // запущен
  Ⲃ    // остановлен
  Ⲅ    // пауза
  Ⲇ    // завершён

// Причина остановки
Ⲉ ⲨⲆⲤⲣ:
  Ⲁ    // точка останова
  Ⲃ    // шаг
  Ⲅ    // исключение
  Ⲇ    // пауза пользователя

// ============================================
// ОТЛАДЧИК
// ============================================

Ⲏ ⲨⲆ:
  vm: ⲨⲂⲘ
  программа: [ⲨⲂⲘ_Ⲓ]
  исходники: {Ⲥ: [Ⲥ]}     // файл -> строки
  карта: {Ⲋ: (Ⲥ, Ⲋ)}     // pc -> (файл, строка)
  точки: [ⲨⲆⲂ]
  стек: [ⲨⲆⲤ]
  состояние: Ⲉ ⲨⲆⲤⲧ
  причина: Ⲉ ⲨⲆⲤⲣ?
  watch: {Ⲥ: Ⲥ}           // выражение -> значение
  счётчик_id: Ⲋ

// Создать отладчик
Ⲫ ⲨⲆ_новый(программа: [ⲨⲂⲘ_Ⲓ], карта: {Ⲋ: (Ⲥ, Ⲋ)}) -> ⲨⲆ:
  Ⲣ ⲨⲆ {
    vm: ⲨⲂⲘ_новая(1024 * 1024),
    программа: программа,
    исходники: {},
    карта: карта,
    точки: [],
    стек: [],
    состояние: Ⲃ,
    причина: None,
    watch: {},
    счётчик_id: 0
  }

// ============================================
// ТОЧКИ ОСТАНОВА
// ============================================

// Добавить точку останова
Ⲫ ⲨⲆ_добавить_точку(отл: ⲨⲆ, файл: Ⲥ, строка: Ⲋ) -> Ⲋ:
  отл.счётчик_id += 1
  Ⲙ точка = ⲨⲆⲂ {
    id: отл.счётчик_id,
    файл: файл,
    строка: строка,
    условие: None,
    счётчик: None,
    попадания: 0,
    активна: Ⲁ
  }
  отл.точки += точка
  Ⲣ точка.id

// Добавить условную точку
Ⲫ ⲨⲆ_добавить_условную(отл: ⲨⲆ, файл: Ⲥ, строка: Ⲋ, условие: Ⲥ) -> Ⲋ:
  отл.счётчик_id += 1
  Ⲙ точка = ⲨⲆⲂ {
    id: отл.счётчик_id,
    файл: файл,
    строка: строка,
    условие: Some(условие),
    счётчик: None,
    попадания: 0,
    активна: Ⲁ
  }
  отл.точки += точка
  Ⲣ точка.id

// Удалить точку
Ⲫ ⲨⲆ_удалить_точку(отл: ⲨⲆ, id: Ⲋ):
  отл.точки = отл.точки.filter(т -> т.id != id)

// Включить/выключить точку
Ⲫ ⲨⲆ_переключить_точку(отл: ⲨⲆ, id: Ⲋ):
  Ⲯ точка отл.точки:
    Ⲝ точка.id == id:
      Ⲁ: точка.активна = Ⲧ_не(точка.активна)

// Проверить точку останова
Ⲫ ⲨⲆ_проверить_точку(отл: ⲨⲆ) -> Ⲧ:
  Ⲙ pc = отл.vm.pc
  
  Ⲝ pc ∉ отл.карта:
    Ⲁ: Ⲣ Ⲃ
  
  Ⲙ (файл, строка) = отл.карта[pc]
  
  Ⲯ точка отл.точки:
    Ⲝ точка.активна == Ⲁ && точка.файл == файл && точка.строка == строка:
      Ⲁ:
        точка.попадания += 1
        
        // Проверяем счётчик
        Ⲝ точка.счётчик != None:
          Ⲁ:
            Ⲝ точка.попадания < точка.счётчик:
              Ⲁ: Ⲣ Ⲃ
        
        // Проверяем условие
        Ⲝ точка.условие != None:
          Ⲁ:
            Ⲙ результат = вычислить_выражение(отл, точка.условие)
            Ⲝ результат != "Ⲁ":
              Ⲁ: Ⲣ Ⲃ
        
        Ⲣ Ⲁ
  
  Ⲣ Ⲃ

// ============================================
// ВЫПОЛНЕНИЕ
// ============================================

// Запустить
Ⲫ ⲨⲆ_запустить(отл: ⲨⲆ):
  отл.состояние = Ⲁ
  
  Ⲯ отл.vm.работает == Ⲁ:
    // Проверяем точки останова
    Ⲝ ⲨⲆ_проверить_точку(отл):
      Ⲁ:
        отл.состояние = Ⲃ
        отл.причина = Some(Ⲁ)
        обновить_стек(отл)
        Ⲣ
    
    // Выполняем шаг
    ⲨⲂⲘ_шаг(отл.vm, отл.программа)
  
  отл.состояние = Ⲇ

// Продолжить
Ⲫ ⲨⲆ_продолжить(отл: ⲨⲆ):
  отл.состояние = Ⲁ
  ⲨⲆ_запустить(отл)

// Пауза
Ⲫ ⲨⲆ_пауза(отл: ⲨⲆ):
  отл.состояние = Ⲃ
  отл.причина = Some(Ⲇ)
  обновить_стек(отл)

// Шаг (step over)
Ⲫ ⲨⲆ_шаг(отл: ⲨⲆ):
  Ⲙ текущая_глубина = длина(отл.стек)
  
  // Выполняем одну инструкцию
  ⲨⲂⲘ_шаг(отл.vm, отл.программа)
  обновить_стек(отл)
  
  // Если вошли в функцию — продолжаем до выхода
  Ⲯ длина(отл.стек) > текущая_глубина:
    ⲨⲂⲘ_шаг(отл.vm, отл.программа)
    обновить_стек(отл)
  
  отл.состояние = Ⲃ
  отл.причина = Some(Ⲃ)

// Шаг внутрь (step into)
Ⲫ ⲨⲆ_шаг_внутрь(отл: ⲨⲆ):
  ⲨⲂⲘ_шаг(отл.vm, отл.программа)
  обновить_стек(отл)
  отл.состояние = Ⲃ
  отл.причина = Some(Ⲃ)

// Шаг наружу (step out)
Ⲫ ⲨⲆ_шаг_наружу(отл: ⲨⲆ):
  Ⲙ текущая_глубина = длина(отл.стек)
  
  Ⲯ длина(отл.стек) >= текущая_глубина && отл.vm.работает == Ⲁ:
    ⲨⲂⲘ_шаг(отл.vm, отл.программа)
    обновить_стек(отл)
  
  отл.состояние = Ⲃ
  отл.причина = Some(Ⲃ)

// ============================================
// СТЕК ВЫЗОВОВ
// ============================================

Ⲫ обновить_стек(отл: ⲨⲆ):
  отл.стек = []
  
  // Текущий кадр
  Ⲙ pc = отл.vm.pc
  Ⲝ pc ∈ отл.карта:
    Ⲁ:
      Ⲙ (файл, строка) = отл.карта[pc]
      отл.стек += ⲨⲆⲤ {
        id: 0,
        имя: "главная",
        файл: файл,
        строка: строка,
        столбец: 1,
        локальные: собрать_локальные(отл)
      }
  
  // Кадры из стека VM
  Ⲙ fp = отл.vm.fp
  Ⲙ id = 1
  Ⲯ fp > 0:
    Ⲙ адрес_возврата = Ⲧ9_в_число(отл.vm.стек[fp - 2])
    Ⲝ адрес_возврата ∈ отл.карта:
      Ⲁ:
        Ⲙ (файл, строка) = отл.карта[адрес_возврата]
        отл.стек += ⲨⲆⲤ {
          id: id,
          имя: "функция_" + id,
          файл: файл,
          строка: строка,
          столбец: 1,
          локальные: {}
        }
        id += 1
    fp = Ⲧ9_в_число(отл.vm.стек[fp - 1])

// Собрать локальные переменные
Ⲫ собрать_локальные(отл: ⲨⲆ) -> {Ⲥ: ⲨⲆⲂⲁ}:
  Ⲙ результат: {Ⲥ: ⲨⲆⲂⲁ} = {}
  
  // Регистры
  Ⲯ ⲓ 0..27:
    Ⲙ имя = "Ⲣ" + символ_регистра(ⲓ)
    Ⲙ значение = отл.vm.регистры[ⲓ]
    результат[имя] = ⲨⲆⲂⲁ {
      имя: имя,
      значение: Ⲧ9_в_TREX(значение),
      тип: "Ⲧ9",
      ссылка: None
    }
  
  Ⲣ результат

// ============================================
// WATCH ВЫРАЖЕНИЯ
// ============================================

// Добавить watch
Ⲫ ⲨⲆ_добавить_watch(отл: ⲨⲆ, выражение: Ⲥ):
  отл.watch[выражение] = вычислить_выражение(отл, выражение)

// Удалить watch
Ⲫ ⲨⲆ_удалить_watch(отл: ⲨⲆ, выражение: Ⲥ):
  отл.watch.удалить(выражение)

// Обновить все watch
Ⲫ ⲨⲆ_обновить_watch(отл: ⲨⲆ):
  Ⲯ (выражение, _) отл.watch:
    отл.watch[выражение] = вычислить_выражение(отл, выражение)

// Вычислить выражение
Ⲫ вычислить_выражение(отл: ⲨⲆ, выражение: Ⲥ) -> Ⲥ:
  // Простые случаи
  Ⲝ выражение.starts_with("Ⲣ"):
    Ⲁ:
      Ⲙ индекс = индекс_регистра(выражение[1])
      Ⲣ Ⲧ9_в_TREX(отл.vm.регистры[индекс])
  
  // Числа
  Ⲝ is_число(выражение):
    Ⲁ: Ⲣ выражение
  
  // Сложные выражения — парсим и вычисляем
  Ⲙ ast = парсить_выражение(выражение)
  Ⲣ вычислить_ast(отл, ast)

// ============================================
// DAP ПРОТОКОЛ
// ============================================

Ⲫ ⲨⲆ_обработать_dap(отл: ⲨⲆ, запрос: Ⲥ) -> Ⲥ:
  Ⲙ json = json_parse(запрос)
  Ⲙ команда = json["command"]
  Ⲙ seq = json["seq"]
  Ⲙ args = json["arguments"]
  
  Ⲙ тело = Ⲝ команда:
    "initialize":
      json!({
        "supportsConfigurationDoneRequest": Ⲁ,
        "supportsConditionalBreakpoints": Ⲁ,
        "supportsHitConditionalBreakpoints": Ⲁ,
        "supportsEvaluateForHovers": Ⲁ,
        "supportsStepBack": Ⲃ
      })
    
    "setBreakpoints":
      Ⲙ файл = args["source"]["path"]
      Ⲙ точки_запроса = args["breakpoints"]
      Ⲙ результат: [{}] = []
      
      // Удаляем старые точки для этого файла
      отл.точки = отл.точки.filter(т -> т.файл != файл)
      
      // Добавляем новые
      Ⲯ т точки_запроса:
        Ⲙ id = Ⲝ т["condition"] != None:
          Ⲁ: ⲨⲆ_добавить_условную(отл, файл, т["line"], т["condition"])
          Ⲃ: ⲨⲆ_добавить_точку(отл, файл, т["line"])
        результат += json!({ "id": id, "verified": Ⲁ, "line": т["line"] })
      
      json!({ "breakpoints": результат })
    
    "continue":
      ⲨⲆ_продолжить(отл)
      json!({ "allThreadsContinued": Ⲁ })
    
    "pause":
      ⲨⲆ_пауза(отл)
      json!({})
    
    "next":
      ⲨⲆ_шаг(отл)
      json!({})
    
    "stepIn":
      ⲨⲆ_шаг_внутрь(отл)
      json!({})
    
    "stepOut":
      ⲨⲆ_шаг_наружу(отл)
      json!({})
    
    "stackTrace":
      Ⲙ кадры = отл.стек.map(к -> json!({
        "id": к.id,
        "name": к.имя,
        "source": { "path": к.файл },
        "line": к.строка,
        "column": к.столбец
      }))
      json!({ "stackFrames": кадры, "totalFrames": длина(кадры) })
    
    "scopes":
      Ⲙ frame_id = args["frameId"]
      json!({
        "scopes": [
          { "name": "Локальные", "variablesReference": frame_id + 1, "expensive": Ⲃ },
          { "name": "Регистры", "variablesReference": 1000, "expensive": Ⲃ }
        ]
      })
    
    "variables":
      Ⲙ ref = args["variablesReference"]
      Ⲙ переменные: [{}] = []
      
      Ⲝ ref == 1000:
        Ⲁ:
          // Регистры
          Ⲯ ⲓ 0..27:
            переменные += json!({
              "name": "Ⲣ" + символ_регистра(ⲓ),
              "value": Ⲧ9_в_TREX(отл.vm.регистры[ⲓ]),
              "type": "Ⲧ9"
            })
        Ⲃ:
          // Локальные переменные кадра
          Ⲙ кадр = отл.стек[ref - 1]
          Ⲯ (имя, перем) кадр.локальные:
            переменные += json!({
              "name": имя,
              "value": перем.значение,
              "type": перем.тип
            })
      
      json!({ "variables": переменные })
    
    "evaluate":
      Ⲙ выражение = args["expression"]
      Ⲙ значение = вычислить_выражение(отл, выражение)
      json!({ "result": значение, "variablesReference": 0 })
    
    _:
      json!({})
  
  Ⲣ json!({
    "seq": seq,
    "type": "response",
    "request_seq": seq,
    "success": Ⲁ,
    "command": команда,
    "body": тело
  }).to_string()

// ============================================
// ГЛАВНЫЙ ЦИКЛ
// ============================================

Ⲫ debugger_главная(программа: [ⲨⲂⲘ_Ⲓ], карта: {Ⲋ: (Ⲥ, Ⲋ)}):
  Ⲙ отл = ⲨⲆ_новый(программа, карта)
  
  Ⲯ Ⲁ:
    Ⲙ заголовок = читать_строку()
    Ⲝ заголовок.starts_with("Content-Length:"):
      Ⲁ:
        Ⲙ длина = parse_int(заголовок[16:])
        читать_строку()
        Ⲙ тело = читать_байты(длина)
        
        Ⲙ ответ = ⲨⲆ_обработать_dap(отл, тело)
        
        печать("Content-Length: " + длина(ответ))
        печать("")
        печать(ответ)
