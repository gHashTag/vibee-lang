name: jit_osr
version: "1.0.0"
language: zig
module: jit_osr
description: |
  JIT ON-STACK REPLACEMENT (OSR)
  
  Бесшовный переход между интерпретацией и JIT.
  Научное обоснование: V8, HotSpot, PyPy tracing JIT.
  
  Creation Pattern:
    Interpreted State → OSR Transition → JIT Execution
         Source       →   Transformer   →    Result

creation_pattern:
  source: InterpretedExecution
  transformer: OSRTransition
  result: JITExecution
  iteration: on_hotness_threshold

types:
  OSRState:
    pc: u64
    registers: [27]T9        # 27 ternary registers
    stack: [T9]
    locals: [T9]
    frame_ptr: u64

  OSREntry:
    vm_pc: u64
    jit_offset: u64
    slots: [OSRSlot]

  OSRSlot:
    slot_type: OSRSlotType
    vm_loc: u32
    jit_loc: u32

  OSRSlotType:
    enum:
      - RegToReg      # VM register → x86 register
      - RegToStack    # VM register → stack slot
      - StackToReg    # VM stack → x86 register
      - StackToStack  # VM stack → stack slot

  Guard:
    pc: u64
    condition: GuardType
    deopt_id: u32

  GuardType:
    enum:
      - TypeMismatch
      - Overflow
      - NullCheck
      - BoundsCheck

  JITWithOSR:
    jit: JIT
    osr_entries: dict(u64, OSREntry)
    deopt_entries: dict(u64, OSREntry)
    guards: [Guard]

  ProfileData:
    call_count: u64
    total_time_ns: u64
    is_hot: bool
    types_observed: [TypeInfo]

  X86State:
    regs: [16]u64
    stack: [u64]
    rsp: u64
    rbp: u64

transformers:
  - name: profile_execution
    type: iterative
    input: {profiler: Profiler, pc: u64, time_ns: u64}
    output: Profiler
    rule: |
      if pc not in profiler.counters:
        profiler.counters[pc] = ProfileData.new()
      counter = profiler.counters[pc]
      counter.call_count += 1
      counter.total_time_ns += time_ns
      if counter.call_count >= HOTNESS_THRESHOLD or 
         counter.total_time_ns >= TIME_THRESHOLD:
        counter.is_hot = true
      return profiler
    patterns: [amortization]

  - name: compile_with_osr
    type: pure
    input: {jit: JITWithOSR, program: [Instruction], start: u64}
    output: u64
    rule: |
      addr = jit.buffer.size
      emit_prologue(jit)
      
      for pc in start..len(program):
        # Register OSR entry at loop headers
        if is_loop_header(program, pc):
          jit.osr_entries[pc] = OSREntry {
            vm_pc: pc,
            jit_offset: jit.buffer.size - addr,
            slots: compute_slots(program, pc)
          }
        
        instr = program[pc]
        emit_with_guards(jit, instr)
      
      emit_epilogue(jit)
      return addr
    patterns: [precomputation]
    expected_speedup: 10.0

  - name: osr_enter
    type: pure
    input: {jit: JITWithOSR, state: OSRState}
    output: bool
    rule: |
      if state.pc not in jit.osr_entries:
        return false
      
      entry = jit.osr_entries[state.pc]
      x86_regs = prepare_registers(state, entry.slots)
      jit_addr = jit.buffer.code + entry.jit_offset
      osr_trampoline(jit_addr, x86_regs, state.stack)
      return true
    patterns: [precomputation]

  - name: deoptimize
    type: pure
    input: {jit: JITWithOSR, deopt_id: u32, x86_state: X86State}
    output: OSRState
    rule: |
      entry = jit.deopt_entries[deopt_id]
      state = OSRState.new()
      state.pc = entry.vm_pc
      
      for slot in entry.slots:
        match slot.slot_type:
          RegToReg => state.registers[slot.vm_loc] = x86_state.regs[slot.jit_loc]
          RegToStack => state.registers[slot.vm_loc] = x86_state.stack[slot.jit_loc]
      
      return state
    patterns: [amortization]

behaviors:
  - name: osr_entry_creation
    given: A loop header in bytecode
    when: JIT compiling the function
    then: OSR entry point is created at loop header
    test_cases:
      - name: simple_loop
        input:
          program: ["load", "cmp", "jump_if_false", "body", "jump_back"]
          loop_header: 0
        expected:
          osr_entry_created: true
          entry_pc: 0

  - name: osr_transition
    given: Interpreter state at OSR point
    when: Entering JIT code via OSR
    then: All live values are correctly transferred
    test_cases:
      - name: register_transfer
        input:
          vm_registers: [1, 2, 3]
          osr_slots: [{RegToReg, 0, RAX}, {RegToReg, 1, RBX}]
        expected:
          x86_rax: 1
          x86_rbx: 2

  - name: deoptimization
    given: Guard failure in JIT code
    when: Deoptimizing back to interpreter
    then: State is correctly restored
    test_cases:
      - name: overflow_guard
        input:
          guard_type: Overflow
          x86_rax: 9999
          deopt_pc: 42
        expected:
          vm_pc: 42
          vm_register_0: 9999

  - name: profiling_hotness
    given: Function call count
    when: Count exceeds threshold
    then: Function marked as hot for JIT
    test_cases:
      - name: reaches_threshold
        input:
          call_count: 1000
          threshold: 1000
        expected:
          is_hot: true
      - name: below_threshold
        input:
          call_count: 500
          threshold: 1000
        expected:
          is_hot: false

functions:
  - name: jit_osr_new
    params: {}
    returns: JITWithOSR
    
  - name: compile_with_osr
    params: {jit: JITWithOSR, program: [Instruction], start: u64}
    returns: u64
    description: Compile with OSR entry points
    
  - name: osr_enter
    params: {jit: JITWithOSR, state: OSRState}
    returns: bool
    description: Enter JIT from interpreter via OSR
    
  - name: deoptimize
    params: {jit: JITWithOSR, deopt_id: u32, x86_state: X86State}
    returns: OSRState
    description: Exit JIT back to interpreter
    
  - name: emit_guard
    params: {jit: JITWithOSR, guard_type: GuardType, reg: u8}
    returns: void
    description: Emit guard with deopt exit
    
  - name: osr_trampoline
    params: {addr: u64, regs: [16]u64, stack: [T9]}
    returns: void
    ffi: {lib: "jit_999", symbol: "osr_trampoline"}

data:
  hotness_threshold: 1000
  time_threshold_ns: 10000000  # 10ms
  
  callee_saved_regs:
    - RBX
    - R12
    - R13
    - R14
    - R15

test_generation:
  boundary: true
  property: true
  stress: [100, 1000, 10000]
  coverage: 90
