name: polyhedral_fusion
version: "1.0.0"
language: 999
module: polyhedral_fusion
description: |
  POLYHEDRAL FUSION — Агрессивное слияние циклов
  
  На базе MLIR Affine Dialect с diamond tiling для stencils.
  Научные работы: ISL, Polly, Polygeist.
  
  Creation Pattern:
    Separate Loops → Fusion Analysis → Fused Loops
        Source    →    Transformer   →    Result

creation_pattern:
  source: SeparateLoops
  transformer: GreedyFusion
  result: FusedLoops
  iteration: until_no_profitable_fusion

types:
  AffineExpr:
    coefficients: [i64]
    variables: [str]

  AffineConstraint:
    expr: AffineExpr
    type: ConstraintType

  ConstraintType:
    enum:
      - GE   # >=
      - EQ   # ==

  PolySet:
    params: [str]
    variables: [str]
    constraints: [AffineConstraint]

  PolyLoop:
    iterator: str
    lower: AffineExpr
    upper: AffineExpr
    step: i64
    body: [PolyLoop | PolyStmt]

  PolyStmt:
    name: str
    domain: PolySet
    accesses: [MemAccess]

  MemAccess:
    array: str
    indices: [AffineExpr]
    type: AccessType

  AccessType:
    enum:
      - Read
      - Write

  Dependence:
    source: PolyStmt
    target: PolyStmt
    type: DepType
    distance: [i64]

  DepType:
    enum:
      - RAW   # Read After Write
      - WAR   # Write After Read
      - WAW   # Write After Write

  FusionCandidate:
    producer: PolyLoop
    consumer: PolyLoop
    common_indices: [str]
    profit: i64

  FusionResult:
    fused: PolyLoop
    memory_saved: i64
    locality_improvement: f64

  CostModel:
    cache_misses: i64
    parallelism: i64
    vectorizability: i64

transformers:
  - name: analyze_dependencies
    type: pure
    input: [PolyStmt]
    output: [Dependence]
    rule: |
      deps = []
      for i in 0..len(stmts):
        for j in 0..len(stmts):
          s1, s2 = stmts[i], stmts[j]
          for d1 in s1.accesses:
            for d2 in s2.accesses:
              if d1.array == d2.array:
                dep_type = determine_dep_type(d1, d2)
                if dep_type:
                  distance = compute_distance(d1, d2)
                  deps.append(Dependence{s1, s2, dep_type, distance})
      return deps
    patterns: [precomputation]

  - name: can_fuse
    type: pure
    input: {prod: PolyLoop, cons: PolyLoop}
    output: bool
    rule: |
      # Check iteration bounds compatibility
      if not compatible_bounds(prod, cons):
        return false
      
      # Check dependencies
      deps = analyze_dependencies(extract_stmts(prod) + extract_stmts(cons))
      for dep in deps:
        if dep.type == RAW:
          if not positive_distance(dep.distance):
            return false  # anti-dependence blocks fusion
      
      return true
    patterns: [precomputation]

  - name: greedy_fusion
    type: iterative
    input: [PolyLoop]
    output: [PolyLoop]
    rule: |
      work_list = loops.clone()
      result = []
      
      while len(work_list) > 0:
        best_pair = None
        best_profit = 0
        
        for i in 0..len(work_list):
          for j in (i+1)..len(work_list):
            if can_fuse(work_list[i], work_list[j]):
              profit = estimate_fusion_profit(work_list[i], work_list[j])
              if profit > best_profit:
                best_profit = profit
                best_pair = (i, j)
        
        if best_pair:
          (i, j) = best_pair
          fused = perform_fusion(work_list[i], work_list[j])
          work_list.remove(j)
          work_list[i] = fused
        else:
          result.append(work_list[0])
          work_list.remove(0)
      
      return result
    patterns: [greedy_local]
    expected_speedup: 2.0

  - name: diamond_tiling
    type: pure
    input: {loop: PolyLoop, tile_size: i64}
    output: PolyLoop
    rule: |
      # For stencil computations
      if not is_stencil(loop):
        return loop
      
      # Step 1: Skew
      skewed = loop_skewing(loop, loop.body[0], 1)
      
      # Step 2: Tile
      tiled = loop_tiling(skewed, tile_size)
      
      return tiled
    patterns: [divide_and_conquer]
    expected_speedup: 3.0

behaviors:
  - name: fusion_legality
    given: Two adjacent loops
    when: Checking if fusion is legal
    then: Respects all data dependencies
    test_cases:
      - name: independent_loops
        input:
          loop1: "for i: A[i] = f(B[i])"
          loop2: "for i: C[i] = g(D[i])"
        expected: {can_fuse: true}
      - name: dependent_loops
        input:
          loop1: "for i: A[i] = f(B[i])"
          loop2: "for i: C[i] = g(A[i])"
        expected: {can_fuse: true}  # producer-consumer
      - name: anti_dependent
        input:
          loop1: "for i: A[i] = f(A[i-1])"
          loop2: "for i: B[i] = g(A[i+1])"
        expected: {can_fuse: false}

  - name: fusion_profit
    given: Two fusable loops
    when: Estimating profit
    then: Considers memory savings and locality
    test_cases:
      - name: producer_consumer
        input:
          loop1: "for i in 0..1000: tmp[i] = compute()"
          loop2: "for i in 0..1000: out[i] = use(tmp[i])"
        expected:
          memory_saved: "1000 elements"
          locality_improvement: "> 0"

  - name: diamond_tiling_stencil
    given: A stencil computation
    when: Applying diamond tiling
    then: Improves cache efficiency
    test_cases:
      - name: jacobi_stencil
        input:
          stencil: "A[i] = (A[i-1] + A[i] + A[i+1]) / 3"
          tile_size: 32
        expected:
          cache_misses_reduction: "> 50%"

functions:
  - name: analyze_dependencies
    params: {stmts: [PolyStmt]}
    returns: [Dependence]
    
  - name: can_fuse
    params: {prod: PolyLoop, cons: PolyLoop}
    returns: bool
    
  - name: greedy_fusion
    params: {loops: [PolyLoop]}
    returns: [PolyLoop]
    
  - name: perform_fusion
    params: {prod: PolyLoop, cons: PolyLoop}
    returns: PolyLoop
    
  - name: estimate_fusion_profit
    params: {prod: PolyLoop, cons: PolyLoop}
    returns: i64
    
  - name: diamond_tiling
    params: {loop: PolyLoop, tile_size: i64}
    returns: PolyLoop
    
  - name: loop_tiling
    params: {loop: PolyLoop, size: i64}
    returns: PolyLoop
    
  - name: loop_skewing
    params: {outer: PolyLoop, inner: PolyLoop, factor: i64}
    returns: PolyLoop

data:
  default_tile_sizes:
    l1_cache: 32
    l2_cache: 128
    l3_cache: 512

  fusion_heuristics:
    min_profit_threshold: 100
    max_register_pressure: 16
    max_body_size: 50

test_generation:
  boundary: true
  property: true
  stress: [100, 1000, 10000]
  coverage: 90
