name: wasm_backend
version: "1.0.0"
language: 999
module: wasm
description: |
  WASM BACKEND — Компиляция 999 → WebAssembly
  
  Универсальная переносимость троичного кода.
  Эмуляция тритов через i32 LUT.
  
  Creation Pattern:
    999 IR → WASM Lowering → WASM Module
    Source →   Transformer  →   Result

creation_pattern:
  source: TernaryIR
  transformer: WASMLowering
  result: WASMModule
  iteration: single_pass

types:
  WasmValType:
    enum:
      - I32
      - I64
      - F32
      - F64
      - V128
      - FuncRef
      - ExternRef

  WasmFuncType:
    params: [WasmValType]
    results: [WasmValType]

  WasmOp:
    enum:
      # Control
      - Unreachable
      - Nop
      - Block(u32)
      - Loop(u32)
      - If(u32)
      - Else
      - End
      - Br(u32)
      - BrIf(u32)
      - Return
      - Call(u32)
      
      # Locals
      - LocalGet(u32)
      - LocalSet(u32)
      - LocalTee(u32)
      
      # Memory
      - I32Load(u32, u32)
      - I32Store(u32, u32)
      
      # i32 ops
      - I32Const(i32)
      - I32Add
      - I32Sub
      - I32Mul
      - I32DivS
      - I32And
      - I32Or
      - I32Xor
      - I32Shl
      - I32ShrS
      - I32Eqz
      - I32Eq
      - I32LtS

  WasmFunc:
    type_idx: u32
    locals: [WasmValType]
    body: [WasmOp]

  WasmModule:
    types: [WasmFuncType]
    funcs: [WasmFunc]
    memory: {min: u32, max: u32?}
    exports: [{name: str, kind: str, idx: u32}]

transformers:
  - name: lower_999_to_wasm
    type: pure
    input: Module999
    output: WasmModule
    rule: |
      wasm = WasmModule.new()
      wasm.memory = {min: 1, max: null}
      
      for func in module.functions:
        wasm_func = lower_func(func)
        wasm.funcs.append(wasm_func)
        wasm.exports.append({name: func.name, kind: "func", idx: len(wasm.funcs)-1})
      
      return wasm
    patterns: [precomputation]

  - name: lower_trit_add
    type: pure
    input: {}
    output: [WasmOp]
    rule: |
      # trit_a + trit_b (each -1, 0, +1 as i32)
      # result = clamp(a + b, -1, 1)
      return [
        I32Add,
        I32Const(1),
        Call(MIN_FUNC),
        I32Const(-1),
        Call(MAX_FUNC)
      ]
    patterns: [precomputation]

  - name: lower_trit_neg
    type: pure
    input: {}
    output: [WasmOp]
    rule: |
      # neg(trit) = 0 - trit
      return [
        I32Const(0),
        I32Sub
      ]
    patterns: [algebraic_reorg]

  - name: encode_wasm
    type: pure
    input: WasmModule
    output: [u8]
    rule: |
      bytes = []
      # Magic number
      bytes += [0x00, 0x61, 0x73, 0x6D]
      # Version
      bytes += [0x01, 0x00, 0x00, 0x00]
      # Sections
      bytes += encode_type_section(module.types)
      bytes += encode_func_section(module.funcs)
      bytes += encode_memory_section(module.memory)
      bytes += encode_export_section(module.exports)
      bytes += encode_code_section(module.funcs)
      return bytes
    patterns: [precomputation]

behaviors:
  - name: wasm_module_validity
    given: A 999 module
    when: Compiling to WASM
    then: Produces valid WASM binary
    test_cases:
      - name: magic_number
        input: {module: "empty"}
        expected: {first_bytes: [0x00, 0x61, 0x73, 0x6D]}
      - name: version
        input: {module: "empty"}
        expected: {bytes_4_7: [0x01, 0x00, 0x00, 0x00]}

  - name: trit_emulation
    given: Ternary operations in 999
    when: Lowering to WASM
    then: Correctly emulates with i32
    test_cases:
      - name: trit_add_plus_plus
        input: {a: 1, b: 1}
        expected: {result: -1, carry: 1}
      - name: trit_neg
        input: {trit: 1}
        expected: {result: -1}

  - name: function_export
    given: A 999 function
    when: Compiling to WASM
    then: Function is exported
    test_cases:
      - name: main_export
        input: {func_name: "main"}
        expected: {exported: true}

functions:
  - name: lower_999_to_wasm
    params: {module: Module999}
    returns: WasmModule
    
  - name: lower_func
    params: {func: Func999}
    returns: WasmFunc
    
  - name: lower_op
    params: {op: Op999}
    returns: [WasmOp]
    
  - name: encode_wasm
    params: {module: WasmModule}
    returns: [u8]
    
  - name: leb128
    params: {n: i64}
    returns: [u8]
    description: LEB128 encoding

data:
  wasm_opcodes:
    unreachable: 0x00
    nop: 0x01
    block: 0x02
    loop: 0x03
    if: 0x04
    else: 0x05
    end: 0x0B
    br: 0x0C
    br_if: 0x0D
    return: 0x0F
    call: 0x10
    local_get: 0x20
    local_set: 0x21
    i32_load: 0x28
    i32_store: 0x36
    i32_const: 0x41
    i32_add: 0x6A
    i32_sub: 0x6B
    i32_mul: 0x6C

  section_ids:
    type: 0x01
    import: 0x02
    function: 0x03
    table: 0x04
    memory: 0x05
    global: 0x06
    export: 0x07
    start: 0x08
    element: 0x09
    code: 0x0A
    data: 0x0B

test_generation:
  boundary: true
  property: true
  stress: [100, 1000]
  coverage: 85
