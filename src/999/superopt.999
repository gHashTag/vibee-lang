// ============================================
// SUPEROPTIMIZER
// Перебор оптимального кода
// ============================================

Ⲩ arifmetika

// Инструкция для суперооптимизации
Ⲉ ⲤⲞⲡ:
  ADD SUB MUL DIV
  SHL SHR AND OR XOR
  NEG NOT MOV
  ADDT NEGT  // троичные

Ⲏ ⲤⲎⲛⲥⲧ:
  оп: Ⲉ ⲤⲞⲡ
  dst: Ⲋ
  src1: Ⲋ
  src2: Ⲋ?
  imm: Ⲋ?

// Программа
Ⲏ ⲤⲠⲣⲟⲅ:
  инструкции: [ⲤⲎⲛⲥⲧ]
  входы: Ⲋ
  выходы: Ⲋ

// Состояние
Ⲏ ⲤⲤⲧⲁⲧⲉ:
  регистры: [Ⲋ]

// Выполнить программу
Ⲫ выполнить(прог: ⲤⲠⲣⲟⲅ, входы: [Ⲋ]) -> [Ⲋ]:
  Ⲙ состояние = ⲤⲤⲧⲁⲧⲉ { регистры: входы + [0] * 8 }
  Ⲯ инстр прог.инструкции:
    выполнить_инструкцию(состояние, инстр)
  Ⲣ состояние.регистры[0..прог.выходы]

Ⲫ выполнить_инструкцию(с: ⲤⲤⲧⲁⲧⲉ, и: ⲤⲎⲛⲥⲧ):
  Ⲙ a = с.регистры[и.src1]
  Ⲙ b = и.src2 ? с.регистры[и.src2] : (и.imm ? и.imm : 0)
  Ⲝ и.оп:
    ADD: с.регистры[и.dst] = a + b
    SUB: с.регистры[и.dst] = a - b
    MUL: с.регистры[и.dst] = a * b
    SHL: с.регистры[и.dst] = a << b
    SHR: с.регистры[и.dst] = a >> b
    NEG: с.регистры[и.dst] = -a
    ADDT: с.регистры[и.dst] = троичное_сложение(a, b)
    NEGT: с.регистры[и.dst] = троичная_инверсия(a)

// Перебор программ
Ⲫ суперооптимизация(цель: ⲤⲠⲣⲟⲅ, тесты: [[Ⲋ]], макс_длина: Ⲋ) -> ⲤⲠⲣⲟⲅ?:
  Ⲙ ожидаемые = тесты.map(т -> выполнить(цель, т))
  
  Ⲯ длина 1..макс_длина:
    Ⲙ кандидат = перебрать_программы(длина, цель.входы, цель.выходы)
    Ⲯ прог кандидат:
      Ⲝ проверить_эквивалентность(прог, тесты, ожидаемые):
        Ⲝ стоимость(прог) < стоимость(цель):
          Ⲣ прог
  Ⲣ None

Ⲫ стоимость(прог: ⲤⲠⲣⲟⲅ) -> Ⲋ:
  Ⲙ с = 0
  Ⲯ и прог.инструкции:
    Ⲝ и.оп:
      MUL: с += 3
      DIV: с += 10
      _: с += 1
  Ⲣ с

// Пример: x * 3 → (x << 1) + x
Ⲫ пример_mul3() -> ⲤⲠⲣⲟⲅ:
  Ⲣ ⲤⲠⲣⲟⲅ {
    инструкции: [
      ⲤⲎⲛⲥⲧ { оп: SHL, dst: 1, src1: 0, imm: 1 },
      ⲤⲎⲛⲥⲧ { оп: ADD, dst: 0, src1: 1, src2: 0 }
    ],
    входы: 1, выходы: 1
  }
