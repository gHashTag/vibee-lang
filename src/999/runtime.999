// ============================================
// RUNTIME / VM ДЛЯ ЯЗЫКА 999
// Троичная виртуальная машина
// ============================================
//
// Архитектура:
//   - 27 регистров (Ⲁ-Ⲯ)
//   - Стековая память
//   - Троичная арифметика
//   - Сборщик мусора
//
// ============================================

Ⲩ yadro
Ⲩ arifmetika

// ============================================
// ПАМЯТЬ
// ============================================

// Объект в куче
Ⲏ ⲨⲞⲀ:
  тип: Ⲉ ⲨⲞⲂ
  размер: Ⲋ
  данные: [Ⲧ9]
  метка: Ⲧ          // для GC: Ⲁ=живой, Ⲃ=мёртвый, Ⲟ=неизвестно

// Типы объектов
Ⲉ ⲨⲞⲂ:
  Ⲁ    // число (Ⲧ9)
  Ⲃ    // строка
  Ⲅ    // массив
  Ⲇ    // структура
  Ⲉ    // функция
  Ⲋ    // замыкание

// Куча
Ⲏ ⲨⲞ:
  объекты: [ⲨⲞⲀ]
  свободные: [Ⲋ]    // индексы свободных слотов
  размер: Ⲋ
  использовано: Ⲋ

// Создать кучу
Ⲫ ⲨⲞ_новая(размер: Ⲋ) -> ⲨⲞ:
  Ⲣ ⲨⲞ {
    объекты: [],
    свободные: [],
    размер: размер,
    использовано: 0
  }

// Выделить память
Ⲫ ⲨⲞ_выделить(куча: ⲨⲞ, тип: Ⲉ ⲨⲞⲂ, размер: Ⲋ) -> Ⲋ:
  // Проверяем свободные слоты
  Ⲝ длина(куча.свободные) > 0:
    Ⲁ:
      Ⲙ индекс = куча.свободные.pop()
      куча.объекты[индекс] = ⲨⲞⲀ {
        тип: тип,
        размер: размер,
        данные: [число_в_Ⲧ9(0); размер],
        метка: Ⲟ
      }
      Ⲣ индекс
  
  // Проверяем лимит
  Ⲝ куча.использовано >= куча.размер:
    Ⲁ:
      // Запускаем GC
      ⲨⲞ_gc(куча)
      Ⲝ куча.использовано >= куча.размер:
        Ⲁ: ошибка("Недостаточно памяти")
  
  // Добавляем новый объект
  Ⲙ индекс = длина(куча.объекты)
  куча.объекты += ⲨⲞⲀ {
    тип: тип,
    размер: размер,
    данные: [число_в_Ⲧ9(0); размер],
    метка: Ⲟ
  }
  куча.использовано += 1
  
  Ⲣ индекс

// Освободить память
Ⲫ ⲨⲞ_освободить(куча: ⲨⲞ, индекс: Ⲋ):
  куча.объекты[индекс].метка = Ⲃ
  куча.свободные += индекс
  куча.использовано -= 1

// ============================================
// СБОРЩИК МУСОРА (Mark & Sweep)
// ============================================

Ⲫ ⲨⲞ_gc(куча: ⲨⲞ):
  // Фаза 1: Сброс меток
  Ⲯ объект куча.объекты:
    объект.метка = Ⲟ
  
  // Фаза 2: Пометка живых (от корней)
  // Корни: регистры VM, стек
  // (передаются извне)
  
  // Фаза 3: Очистка мёртвых
  Ⲯ ⲓ 0..длина(куча.объекты):
    Ⲝ куча.объекты[ⲓ].метка != Ⲁ:
      Ⲁ:
        куча.свободные += ⲓ
        куча.использовано -= 1

// Пометить объект как живой (рекурсивно)
Ⲫ ⲨⲞ_пометить(куча: ⲨⲞ, индекс: Ⲋ):
  Ⲝ индекс < 0 || индекс >= длина(куча.объекты):
    Ⲁ: Ⲣ
  
  Ⲙ объект = куча.объекты[индекс]
  Ⲝ объект.метка == Ⲁ:
    Ⲁ: Ⲣ  // уже помечен
  
  объект.метка = Ⲁ
  
  // Рекурсивно помечаем ссылки
  Ⲝ объект.тип == Ⲅ || объект.тип == Ⲇ:
    Ⲁ:
      Ⲯ значение объект.данные:
        Ⲙ ссылка = Ⲧ9_в_число(значение)
        ⲨⲞ_пометить(куча, ссылка)

// ============================================
// ВИРТУАЛЬНАЯ МАШИНА
// ============================================

// Состояние VM
Ⲏ ⲨⲂⲘ:
  регистры: [Ⲧ9; 27]      // Ⲁ-Ⲯ
  стек: [Ⲧ9]
  память: ⲨⲞ
  pc: Ⲋ                    // program counter
  sp: Ⲋ                    // stack pointer
  fp: Ⲋ                    // frame pointer
  флаги: Ⲧ3                // флаги состояния
  работает: Ⲧ

// Создать VM
Ⲫ ⲨⲂⲘ_новая(размер_памяти: Ⲋ) -> ⲨⲂⲘ:
  Ⲣ ⲨⲂⲘ {
    регистры: [число_в_Ⲧ9(0); 27],
    стек: [],
    память: ⲨⲞ_новая(размер_памяти),
    pc: 0,
    sp: 0,
    fp: 0,
    флаги: число_в_Ⲧ3(0),
    работает: Ⲁ
  }

// Опкоды VM
Ⲉ ⲨⲂⲘ_ОП:
  // Загрузка/сохранение
  LOAD_IMM      // загрузить константу в регистр
  LOAD_REG      // копировать регистр
  LOAD_MEM      // загрузить из памяти
  STORE_MEM     // сохранить в память
  
  // Стек
  PUSH          // положить на стек
  POP           // снять со стека
  
  // Арифметика (троичная)
  ADD           // сложение
  SUB           // вычитание
  MUL           // умножение
  DIV           // деление
  MOD           // остаток
  NEG           // инверсия (смена знака)
  
  // Троичная логика
  AND           // троичное И
  OR            // троичное ИЛИ
  NOT           // троичное НЕ
  
  // Сравнение
  CMP           // сравнить (устанавливает флаги)
  
  // Переходы
  JMP           // безусловный переход
  JZ            // переход если 0
  JP            // переход если +
  JN            // переход если -
  
  // Вызовы
  CALL          // вызов функции
  RET           // возврат
  
  // Память
  ALLOC         // выделить память
  FREE          // освободить память
  
  // Система
  SYSCALL       // системный вызов
  HALT          // остановка
  NOP           // ничего

// Инструкция
Ⲏ ⲨⲂⲘ_Ⲓ:
  оп: Ⲉ ⲨⲂⲘ_ОП
  арг1: Ⲋ
  арг2: Ⲋ
  арг3: Ⲋ

// Выполнить инструкцию
Ⲫ ⲨⲂⲘ_шаг(vm: ⲨⲂⲘ, программа: [ⲨⲂⲘ_Ⲓ]) -> Ⲧ:
  Ⲝ vm.pc >= длина(программа) || vm.работает == Ⲃ:
    Ⲁ: Ⲣ Ⲃ
  
  Ⲙ инстр = программа[vm.pc]
  vm.pc += 1
  
  Ⲝ инстр.оп:
    LOAD_IMM:
      vm.регистры[инстр.арг1] = число_в_Ⲧ9(инстр.арг2)
    
    LOAD_REG:
      vm.регистры[инстр.арг1] = vm.регистры[инстр.арг2]
    
    LOAD_MEM:
      Ⲙ адрес = Ⲧ9_в_число(vm.регистры[инстр.арг2])
      vm.регистры[инстр.арг1] = vm.память.объекты[адрес].данные[инстр.арг3]
    
    STORE_MEM:
      Ⲙ адрес = Ⲧ9_в_число(vm.регистры[инстр.арг1])
      vm.память.объекты[адрес].данные[инстр.арг3] = vm.регистры[инстр.арг2]
    
    PUSH:
      vm.стек += vm.регистры[инстр.арг1]
      vm.sp += 1
    
    POP:
      vm.sp -= 1
      vm.регистры[инстр.арг1] = vm.стек[vm.sp]
    
    ADD:
      vm.регистры[инстр.арг1] = Ⲧ9_сложить(
        vm.регистры[инстр.арг2],
        vm.регистры[инстр.арг3]
      )
    
    SUB:
      vm.регистры[инстр.арг1] = Ⲧ9_вычесть(
        vm.регистры[инстр.арг2],
        vm.регистры[инстр.арг3]
      )
    
    MUL:
      vm.регистры[инстр.арг1] = Ⲧ9_умножить(
        vm.регистры[инстр.арг2],
        vm.регистры[инстр.арг3]
      )
    
    DIV:
      Ⲙ (частное, _) = Ⲧ9_делить(
        vm.регистры[инстр.арг2],
        vm.регистры[инстр.арг3]
      )
      vm.регистры[инстр.арг1] = частное
    
    NEG:
      vm.регистры[инстр.арг1] = Ⲧ9_инв(vm.регистры[инстр.арг2])
    
    AND:
      // Троичное И по тритам
      Ⲙ а = vm.регистры[инстр.арг2]
      Ⲙ б = vm.регистры[инстр.арг3]
      vm.регистры[инстр.арг1] = Ⲧ9_и(а, б)
    
    OR:
      Ⲙ а = vm.регистры[инстр.арг2]
      Ⲙ б = vm.регистры[инстр.арг3]
      vm.регистры[инстр.арг1] = Ⲧ9_или(а, б)
    
    NOT:
      vm.регистры[инстр.арг1] = Ⲧ9_не(vm.регистры[инстр.арг2])
    
    CMP:
      vm.флаги = Ⲧ9_сравнить(
        vm.регистры[инстр.арг1],
        vm.регистры[инстр.арг2]
      )
    
    JMP:
      vm.pc = инстр.арг1
    
    JZ:
      Ⲝ Ⲧ3_в_число(vm.флаги) == 0:
        Ⲁ: vm.pc = инстр.арг1
    
    JP:
      Ⲝ Ⲧ3_в_число(vm.флаги) > 0:
        Ⲁ: vm.pc = инстр.арг1
    
    JN:
      Ⲝ Ⲧ3_в_число(vm.флаги) < 0:
        Ⲁ: vm.pc = инстр.арг1
    
    CALL:
      // Сохраняем адрес возврата
      vm.стек += число_в_Ⲧ9(vm.pc)
      vm.стек += число_в_Ⲧ9(vm.fp)
      vm.sp += 2
      vm.fp = vm.sp
      vm.pc = инстр.арг1
    
    RET:
      vm.sp = vm.fp
      vm.fp = Ⲧ9_в_число(vm.стек[vm.sp - 1])
      vm.pc = Ⲧ9_в_число(vm.стек[vm.sp - 2])
      vm.sp -= 2
    
    ALLOC:
      Ⲙ размер = Ⲧ9_в_число(vm.регистры[инстр.арг2])
      Ⲙ адрес = ⲨⲞ_выделить(vm.память, Ⲅ, размер)
      vm.регистры[инстр.арг1] = число_в_Ⲧ9(адрес)
    
    FREE:
      Ⲙ адрес = Ⲧ9_в_число(vm.регистры[инстр.арг1])
      ⲨⲞ_освободить(vm.память, адрес)
    
    SYSCALL:
      ⲨⲂⲘ_syscall(vm, инстр.арг1)
    
    HALT:
      vm.работает = Ⲃ
      Ⲣ Ⲃ
    
    NOP:
      ()
  
  Ⲣ Ⲁ

// Системные вызовы
Ⲫ ⲨⲂⲘ_syscall(vm: ⲨⲂⲘ, номер: Ⲋ):
  Ⲝ номер:
    0:  // print
      Ⲙ значение = Ⲧ9_в_число(vm.регистры[0])
      печать(значение)
    
    1:  // print_trex
      Ⲙ trex = Ⲧ9_в_TREX(vm.регистры[0])
      печать(trex)
    
    2:  // read
      Ⲙ ввод = читать_строку()
      vm.регистры[0] = число_в_Ⲧ9(parse_int(ввод))
    
    3:  // time
      vm.регистры[0] = число_в_Ⲧ9(время_сейчас())
    
    4:  // gc
      ⲨⲞ_gc(vm.память)
    
    _:
      ошибка("Неизвестный syscall: " + номер)

// Запустить программу
Ⲫ ⲨⲂⲘ_запустить(vm: ⲨⲂⲘ, программа: [ⲨⲂⲘ_Ⲓ]):
  Ⲯ ⲨⲂⲘ_шаг(vm, программа):
    ()

// ============================================
// КОМПИЛЯЦИЯ IR В БАЙТКОД VM
// ============================================

Ⲫ ir_в_байткод(ir: ⲨⲄ) -> [ⲨⲂⲘ_Ⲓ]:
  Ⲙ программа: [ⲨⲂⲘ_Ⲓ] = []
  
  Ⲯ функция ir.Ⲁ:
    Ⲯ блок функция.Ⲃ:
      Ⲯ инстр блок.Ⲃ:
        Ⲝ инстр.Ⲁ:
          Ⲁ:  // LOAD
            программа += ⲨⲂⲘ_Ⲓ {
              оп: LOAD_IMM,
              арг1: инстр.Ⲅ,
              арг2: инстр.Ⲃ[0],
              арг3: 0
            }
          
          Ⲅ:  // ADD
            программа += ⲨⲂⲘ_Ⲓ {
              оп: ADD,
              арг1: инстр.Ⲅ,
              арг2: инстр.Ⲃ[0],
              арг3: инстр.Ⲃ[1]
            }
          
          Ⲇ:  // SUB
            программа += ⲨⲂⲘ_Ⲓ {
              оп: SUB,
              арг1: инстр.Ⲅ,
              арг2: инстр.Ⲃ[0],
              арг3: инстр.Ⲃ[1]
            }
          
          Ⲉ:  // MUL
            программа += ⲨⲂⲘ_Ⲓ {
              оп: MUL,
              арг1: инстр.Ⲅ,
              арг2: инстр.Ⲃ[0],
              арг3: инстр.Ⲃ[1]
            }
          
          Ⲗ:  // CALL
            программа += ⲨⲂⲘ_Ⲓ {
              оп: CALL,
              арг1: инстр.Ⲃ[0],
              арг2: 0,
              арг3: 0
            }
          
          Ⲙ:  // RET
            программа += ⲨⲂⲘ_Ⲓ {
              оп: RET,
              арг1: инстр.Ⲃ[0],
              арг2: 0,
              арг3: 0
            }
          
          _:
            программа += ⲨⲂⲘ_Ⲓ { оп: NOP, арг1: 0, арг2: 0, арг3: 0 }
  
  // Добавляем HALT в конец
  программа += ⲨⲂⲘ_Ⲓ { оп: HALT, арг1: 0, арг2: 0, арг3: 0 }
  
  Ⲣ программа

// ============================================
// ПРИМЕР ПРОГРАММЫ
// ============================================

// Факториал на байткоде VM
Ⲫ пример_факториал() -> [ⲨⲂⲘ_Ⲓ]:
  Ⲣ [
    // n = 5
    ⲨⲂⲘ_Ⲓ { оп: LOAD_IMM, арг1: 0, арг2: 5, арг3: 0 },
    // result = 1
    ⲨⲂⲘ_Ⲓ { оп: LOAD_IMM, арг1: 1, арг2: 1, арг3: 0 },
    // loop:
    // if n == 0 goto end
    ⲨⲂⲘ_Ⲓ { оп: LOAD_IMM, арг1: 2, арг2: 0, арг3: 0 },
    ⲨⲂⲘ_Ⲓ { оп: CMP, арг1: 0, арг2: 2, арг3: 0 },
    ⲨⲂⲘ_Ⲓ { оп: JZ, арг1: 11, арг2: 0, арг3: 0 },
    // result = result * n
    ⲨⲂⲘ_Ⲓ { оп: MUL, арг1: 1, арг2: 1, арг3: 0 },
    // n = n - 1
    ⲨⲂⲘ_Ⲓ { оп: LOAD_IMM, арг1: 2, арг2: 1, арг3: 0 },
    ⲨⲂⲘ_Ⲓ { оп: SUB, арг1: 0, арг2: 0, арг3: 2 },
    // goto loop
    ⲨⲂⲘ_Ⲓ { оп: JMP, арг1: 2, арг2: 0, арг3: 0 },
    // end:
    // print result
    ⲨⲂⲘ_Ⲓ { оп: LOAD_REG, арг1: 0, арг2: 1, арг3: 0 },
    ⲨⲂⲘ_Ⲓ { оп: SYSCALL, арг1: 0, арг2: 0, арг3: 0 },
    ⲨⲂⲘ_Ⲓ { оп: HALT, арг1: 0, арг2: 0, арг3: 0 }
  ]
