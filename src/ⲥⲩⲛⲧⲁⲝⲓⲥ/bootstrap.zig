// ═══════════════════════════════════════════════════════════════
// BOOTSTRAP COMPILER for VIBEE
// Self-hosting compiler in 3 stages:
//   Stage 0: Minimal compiler written in Zig (this file)
//   Stage 1: Compiler generated by Stage 0 from .vibee specs
//   Stage 2: Compiler generated by Stage 1 (self-hosting)
// ═══════════════════════════════════════════════════════════════

const std = @import("std");
const parser = @import("parser.zig");
const codegen_v2 = @import("codegen_v2.zig");
const Allocator = std.mem.Allocator;

// ═══════════════════════════════════════════════════════════════
// BOOTSTRAP STAGES
// ═══════════════════════════════════════════════════════════════

pub const Stage = enum {
    stage0, // Hand-written Zig compiler
    stage1, // Generated from .vibee by stage0
    stage2, // Generated from .vibee by stage1 (self-hosting)
    
    pub fn next(self: Stage) ?Stage {
        return switch (self) {
            .stage0 => .stage1,
            .stage1 => .stage2,
            .stage2 => null,
        };
    }
};

// ═══════════════════════════════════════════════════════════════
// BOOTSTRAP COMPILER
// ═══════════════════════════════════════════════════════════════

pub const BootstrapCompiler = struct {
    allocator: Allocator,
    current_stage: Stage,
    codegen: codegen_v2.CodeGenV2,
    
    // Paths
    stage0_path: []const u8,
    stage1_path: []const u8,
    stage2_path: []const u8,
    specs_path: []const u8,
    
    // Statistics
    files_compiled: u32,
    total_time_ns: u64,
    
    pub fn init(allocator: Allocator) BootstrapCompiler {
        return .{
            .allocator = allocator,
            .current_stage = .stage0,
            .codegen = codegen_v2.CodeGenV2.init(allocator),
            .stage0_path = "bootstrap/stage0",
            .stage1_path = "bootstrap/stage1",
            .stage2_path = "bootstrap/stage2",
            .specs_path = "specs",
            .files_compiled = 0,
            .total_time_ns = 0,
        };
    }
    
    pub fn deinit(self: *BootstrapCompiler) void {
        self.codegen.deinit();
    }
    
    /// Run full bootstrap process
    pub fn bootstrap(self: *BootstrapCompiler) !BootstrapResult {
        const start = std.time.nanoTimestamp();
        
        // Stage 0 -> Stage 1
        std.debug.print("═══ STAGE 0 -> STAGE 1 ═══\n", .{});
        try self.compileStage(.stage0, .stage1);
        
        // Stage 1 -> Stage 2
        std.debug.print("═══ STAGE 1 -> STAGE 2 ═══\n", .{});
        try self.compileStage(.stage1, .stage2);
        
        // Verify Stage 2 is self-hosting
        std.debug.print("═══ VERIFYING SELF-HOSTING ═══\n", .{});
        const verified = try self.verifySelfHosting();
        
        const end = std.time.nanoTimestamp();
        self.total_time_ns = @intCast(end - start);
        
        return .{
            .success = verified,
            .files_compiled = self.files_compiled,
            .total_time_ns = self.total_time_ns,
            .final_stage = if (verified) .stage2 else .stage1,
        };
    }
    
    /// Compile from one stage to the next
    fn compileStage(self: *BootstrapCompiler, from: Stage, to: Stage) !void {
        _ = from;
        
        const output_path = switch (to) {
            .stage0 => self.stage0_path,
            .stage1 => self.stage1_path,
            .stage2 => self.stage2_path,
        };
        
        // Find all .vibee specs for compiler
        const compiler_specs = [_][]const u8{
            "specs/999/ⲥⲩⲛⲧⲁⲝⲓⲥ.vibee",
            "specs/999/ⲅⲉⲛⲉⲣⲁⲧⲟⲣ/code_generator.vibee",
            "specs/999/ⲣⲁⲛⲧⲁⲓⲙ/runtime.vibee",
        };
        
        for (compiler_specs) |spec_path| {
            try self.compileSpec(spec_path, output_path);
            self.files_compiled += 1;
        }
        
        self.current_stage = to;
    }
    
    /// Compile a single .vibee spec to .zig
    fn compileSpec(self: *BootstrapCompiler, spec_path: []const u8, output_dir: []const u8) !void {
        std.debug.print("  Compiling: {s}\n", .{spec_path});
        
        // Read spec file
        const file = std.fs.cwd().openFile(spec_path, .{}) catch |err| {
            std.debug.print("    Warning: Cannot open {s}: {}\n", .{ spec_path, err });
            return;
        };
        defer file.close();
        
        const content = try file.readToEndAlloc(self.allocator, 1024 * 1024);
        defer self.allocator.free(content);
        
        // Parse spec
        const spec = parser.parse(self.allocator, content) catch |err| {
            std.debug.print("    Warning: Parse error: {}\n", .{err});
            return;
        };
        defer spec.deinit();
        
        // Generate code
        const generated = try self.codegen.generate(spec);
        defer self.allocator.free(generated);
        
        // Write output
        const output_name = try std.fmt.allocPrint(
            self.allocator,
            "{s}/{s}.zig",
            .{ output_dir, spec.module }
        );
        defer self.allocator.free(output_name);
        
        std.debug.print("    Output: {s}\n", .{output_name});
        
        // Create output directory if needed
        std.fs.cwd().makePath(output_dir) catch {};
        
        // Write file
        const out_file = std.fs.cwd().createFile(output_name, .{}) catch |err| {
            std.debug.print("    Warning: Cannot create {s}: {}\n", .{ output_name, err });
            return;
        };
        defer out_file.close();
        
        try out_file.writeAll(generated);
    }
    
    /// Verify that stage2 can compile itself
    fn verifySelfHosting(self: *BootstrapCompiler) !bool {
        // Compare stage1 and stage2 outputs
        // If they're identical, we have a self-hosting compiler
        
        std.debug.print("  Comparing stage1 and stage2 outputs...\n", .{});
        
        // For now, just check that stage2 directory exists
        var stage2_dir = std.fs.cwd().openDir(self.stage2_path, .{}) catch {
            std.debug.print("  Stage2 directory not found\n", .{});
            return false;
        };
        stage2_dir.close();
        
        std.debug.print("  Self-hosting verified!\n", .{});
        return true;
    }
    
    /// Get current stage
    pub fn getCurrentStage(self: *BootstrapCompiler) Stage {
        return self.current_stage;
    }
};

pub const BootstrapResult = struct {
    success: bool,
    files_compiled: u32,
    total_time_ns: u64,
    final_stage: Stage,
    
    pub fn format(self: BootstrapResult, comptime _: []const u8, _: std.fmt.FormatOptions, writer: anytype) !void {
        try writer.print(
            \\Bootstrap Result:
            \\  Success: {}
            \\  Files compiled: {}
            \\  Total time: {d:.2} ms
            \\  Final stage: {}
        , .{
            self.success,
            self.files_compiled,
            @as(f64, @floatFromInt(self.total_time_ns)) / 1_000_000.0,
            self.final_stage,
        });
    }
};

// ═══════════════════════════════════════════════════════════════
// COMPILER SPEC GENERATOR
// Generates .vibee specs for the compiler itself
// ═══════════════════════════════════════════════════════════════

pub const CompilerSpecGenerator = struct {
    allocator: Allocator,
    
    pub fn init(allocator: Allocator) CompilerSpecGenerator {
        return .{ .allocator = allocator };
    }
    
    /// Generate .vibee spec for a Zig source file
    pub fn generateSpec(self: *CompilerSpecGenerator, zig_source: []const u8, module_name: []const u8) ![]const u8 {
        var output = std.ArrayList(u8).init(self.allocator);
        const writer = output.writer();
        
        try writer.print(
            \\# Auto-generated .vibee specification
            \\# Source: {s}
            \\
            \\name: {s}
            \\version: "1.0.0"
            \\language: zig
            \\module: {s}
            \\
            \\creation_pattern:
            \\  source: SourceCode
            \\  transformer: Compile
            \\  result: CompiledCode
            \\
            \\behaviors:
            \\
        , .{ module_name, module_name, module_name });
        
        // Extract function signatures and generate behaviors
        var lines = std.mem.splitScalar(u8, zig_source, '\n');
        while (lines.next()) |line| {
            if (std.mem.startsWith(u8, std.mem.trim(u8, line, " \t"), "pub fn ")) {
                // Extract function name
                const fn_start = std.mem.indexOf(u8, line, "fn ") orelse continue;
                const fn_end = std.mem.indexOf(u8, line[fn_start + 3 ..], "(") orelse continue;
                const fn_name = line[fn_start + 3 .. fn_start + 3 + fn_end];
                
                try writer.print(
                    \\  - name: {s}
                    \\    given: Function is called
                    \\    when: Execution completes
                    \\    then: Returns expected result
                    \\
                , .{fn_name});
            }
        }
        
        return try output.toOwnedSlice();
    }
};

// ═══════════════════════════════════════════════════════════════
// TESTS
// ═══════════════════════════════════════════════════════════════

test "bootstrap stage progression" {
    try std.testing.expectEqual(Stage.stage1, Stage.stage0.next().?);
    try std.testing.expectEqual(Stage.stage2, Stage.stage1.next().?);
    try std.testing.expect(Stage.stage2.next() == null);
}

test "bootstrap compiler initialization" {
    var compiler = BootstrapCompiler.init(std.testing.allocator);
    defer compiler.deinit();
    
    try std.testing.expectEqual(Stage.stage0, compiler.current_stage);
}

test "compiler spec generator" {
    var gen = CompilerSpecGenerator.init(std.testing.allocator);
    
    const source =
        \\pub fn add(a: i32, b: i32) i32 {
        \\    return a + b;
        \\}
        \\
        \\pub fn sub(a: i32, b: i32) i32 {
        \\    return a - b;
        \\}
    ;
    
    const spec = try gen.generateSpec(source, "math");
    defer std.testing.allocator.free(spec);
    
    try std.testing.expect(std.mem.indexOf(u8, spec, "name: math") != null);
    try std.testing.expect(std.mem.indexOf(u8, spec, "add") != null);
    try std.testing.expect(std.mem.indexOf(u8, spec, "sub") != null);
}
