// VIBEEC Code Generator - Multi-target code generation
// Supports: Zig, Python, Rust, Go, Gleam, TypeScript, WASM
// Enhanced with Creation Pattern code generation from mathematical experiments

const std = @import("std");
const parser = @import("parser.zig");

pub const Target = enum {
    zig,
    python,
    rust,
    go,
    gleam,
    typescript,
    wasm,
    @"999", // Священный язык 999 с коптским алфавитом

    pub fn fromString(s: []const u8) ?Target {
        if (std.mem.eql(u8, s, "zig")) return .zig;
        if (std.mem.eql(u8, s, "python") or std.mem.eql(u8, s, "py")) return .python;
        if (std.mem.eql(u8, s, "rust") or std.mem.eql(u8, s, "rs")) return .rust;
        if (std.mem.eql(u8, s, "go") or std.mem.eql(u8, s, "golang")) return .go;
        if (std.mem.eql(u8, s, "gleam")) return .gleam;
        if (std.mem.eql(u8, s, "typescript") or std.mem.eql(u8, s, "ts")) return .typescript;
        if (std.mem.eql(u8, s, "wasm") or std.mem.eql(u8, s, "webassembly")) return .wasm;
        if (std.mem.eql(u8, s, "999") or std.mem.eql(u8, s, "coptic")) return .@"999";
        return null;
    }

    pub fn extension(self: Target) []const u8 {
        return switch (self) {
            .zig => ".zig",
            .python => ".py",
            .rust => ".rs",
            .go => ".go",
            .gleam => ".gleam",
            .typescript => ".ts",
            .wasm => ".wat",
            .@"999" => ".999",
        };
    }
};

pub fn generate(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    const target = Target.fromString(spec.language) orelse .zig;
    return generateForTarget(allocator, spec, target);
}

pub fn generateForTarget(allocator: std.mem.Allocator, spec: parser.Spec, target: Target) ![]const u8 {
    return switch (target) {
        .zig => generateZig(allocator, spec),
        .python => generatePython(allocator, spec),
        .rust => generateRust(allocator, spec),
        .@"999" => generate999(allocator, spec),
        .go => generateGo(allocator, spec),
        .gleam => generateGleam(allocator, spec),
        .typescript => generateTypeScript(allocator, spec),
        .wasm => generateWasm(allocator, spec),
    };
}

// ============================================================================
// ZIG CODE GENERATOR
// ============================================================================

fn generateZig(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Zig
        \\
        \\const std = @import("std");
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    // Generate Creation Pattern infrastructure if present
    if (spec.hasCreationPattern()) {
        try generateCreationPatternZig(writer, spec);
    }

    // Generate transformer functions
    for (spec.transformers) |transformer| {
        try generateTransformerZig(writer, transformer);
    }

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() !void {{
            \\    // TODO: Implement
            \\    return error.NotImplemented;
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\
    , .{});

    // Generate automatic tests based on test_generation config
    if (spec.test_generation) |tg| {
        try generateAutoTestsZig(writer, spec, tg);
    }

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\test "{s}" {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    _ = {s}() catch |err| {{
            \\        if (err == error.NotImplemented) return;
            \\        return err;
            \\    }};
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// PYTHON CODE GENERATOR
// ============================================================================

fn generatePython(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\# Generated by VIBEEC from {s}.vibee
        \\# DO NOT EDIT - This file is auto-generated
        \\# Module: {s} | Version: {s} | Target: Python
        \\
        \\from typing import Any, Optional
        \\import pytest
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\def {s}() -> Any:
            \\    """
            \\    {s}
            \\    
            \\    Given: {s}
            \\    When: {s}
            \\    Then: {s}
            \\    """
            \\    raise NotImplementedError("TODO: Implement")
            \\
            \\
        , .{ behavior.name, behavior.name, behavior.given, behavior.when, behavior.then });
    }

    try writer.print(
        \\# ============================================================================
        \\# Tests
        \\# ============================================================================
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\def test_{s}():
            \\    """
            \\    Given: {s}
            \\    When: {s}
            \\    Then: {s}
            \\    """
            \\    try:
            \\        result = {s}()
            \\        assert result is not None
            \\    except NotImplementedError:
            \\        pytest.skip("Not implemented yet")
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\
        \\if __name__ == "__main__":
        \\    pytest.main([__file__, "-v"])
        \\
    , .{});

    return output.toOwnedSlice();
}

// ============================================================================
// RUST CODE GENERATOR
// ============================================================================

fn generateRust(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Rust
        \\
        \\use std::error::Error;
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\///
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() -> Result<(), Box<dyn Error>> {{
            \\    // TODO: Implement
            \\    Err("Not implemented".into())
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\#[cfg(test)]
        \\mod tests {{
        \\    use super::*;
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\    #[test]
            \\    fn test_{s}() {{
            \\        // Given: {s}
            \\        // When: {s}
            \\        // Then: {s}
            \\        match {s}() {{
            \\            Ok(_) => {{}},
            \\            Err(e) if e.to_string() == "Not implemented" => {{}},
            \\            Err(e) => panic!("Unexpected error: {{}}", e),
            \\        }}
            \\    }}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\}}
        \\
    , .{});

    return output.toOwnedSlice();
}

// ============================================================================
// GO CODE GENERATOR
// ============================================================================

fn generateGo(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Go
        \\
        \\package {s}
        \\
        \\import (
        \\    "errors"
        \\    "testing"
        \\)
        \\
        \\var ErrNotImplemented = errors.New("not implemented")
        \\
        \\
    , .{ spec.name, spec.module, spec.version, spec.name });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\// {s}
            \\// Given: {s}
            \\// When: {s}
            \\// Then: {s}
            \\func {s}() error {{
            \\    // TODO: Implement
            \\    return ErrNotImplemented
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, toPascalCase(behavior.name) });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\func Test{s}(t *testing.T) {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    err := {s}()
            \\    if err != nil && err != ErrNotImplemented {{
            \\        t.Errorf("Unexpected error: %v", err)
            \\    }}
            \\}}
            \\
            \\
        , .{ toPascalCase(behavior.name), behavior.given, behavior.when, behavior.then, toPascalCase(behavior.name) });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// GLEAM CODE GENERATOR
// ============================================================================

fn generateGleam(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: Gleam
        \\
        \\import gleam/result
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/// {s}
            \\///
            \\/// Given: {s}
            \\/// When: {s}
            \\/// Then: {s}
            \\pub fn {s}() -> Result(Nil, String) {{
            \\  // TODO: Implement
            \\  Error("Not implemented")
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// TYPESCRIPT CODE GENERATOR
// ============================================================================

fn generateTypeScript(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\// Generated by VIBEEC from {s}.vibee
        \\// DO NOT EDIT - This file is auto-generated
        \\// Module: {s} | Version: {s} | Target: TypeScript
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\/**
            \\ * {s}
            \\ *
            \\ * Given: {s}
            \\ * When: {s}
            \\ * Then: {s}
            \\ */
            \\export function {s}(): void {{
            \\  // TODO: Implement
            \\  throw new Error("Not implemented");
            \\}}
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, toCamelCase(behavior.name) });
    }

    try writer.print(
        \\// ============================================================================
        \\// Tests
        \\// ============================================================================
        \\
        \\import {{ describe, it, expect }} from "vitest";
        \\
        \\
    , .{});

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\describe("{s}", () => {{
            \\  it("should work", () => {{
            \\    // Given: {s}
            \\    // When: {s}
            \\    // Then: {s}
            \\    try {{
            \\      {s}();
            \\    }} catch (e) {{
            \\      if ((e as Error).message !== "Not implemented") {{
            \\        throw e;
            \\      }}
            \\    }}
            \\  }});
            \\}});
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, toCamelCase(behavior.name) });
    }

    return output.toOwnedSlice();
}

// ============================================================================
// WASM CODE GENERATOR (WebAssembly Text Format)
// ============================================================================

fn generateWasm(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    try writer.print(
        \\;; Generated by VIBEEC from {s}.vibee
        \\;; DO NOT EDIT - This file is auto-generated
        \\;; Module: {s} | Version: {s} | Target: WebAssembly
        \\
        \\(module
        \\  ;; Memory export
        \\  (memory (export "memory") 1)
        \\
        \\
    , .{ spec.name, spec.module, spec.version });

    for (spec.behaviors) |behavior| {
        try writer.print(
            \\  ;; {s}
            \\  ;; Given: {s}
            \\  ;; When: {s}
            \\  ;; Then: {s}
            \\  (func (export "{s}") (result i32)
            \\    ;; TODO: Implement
            \\    i32.const -1  ;; Return -1 for not implemented
            \\  )
            \\
            \\
        , .{ behavior.name, behavior.given, behavior.when, behavior.then, behavior.name });
    }

    try writer.print(
        \\)
        \\
    , .{});

    return output.toOwnedSlice();
}

// ============================================================================
// CREATION PATTERN CODE GENERATION (from mathematical experiments)
// ============================================================================

/// Generate Creation Pattern infrastructure for Zig
fn generateCreationPatternZig(writer: anytype, spec: parser.Spec) !void {
    const cp = spec.creation_pattern orelse return;

    try writer.print(
        \\// ============================================================================
        \\// Creation Pattern: {s} → {s} → {s}
        \\// ============================================================================
        \\
        \\
    , .{ cp.source, cp.transformer, cp.result });

    // Generate iteration result type
    try writer.print(
        \\/// Result of iterative transformation
        \\pub const IterationResult = struct {{
        \\    value: u64,
        \\    steps: usize,
        \\    max_reached: u64,
        \\    converged: bool,
        \\}};
        \\
        \\
    , .{});

    // Generate iteration function based on iteration type
    switch (cp.iteration) {
        .until_condition, .until_fixed_point => {
            try writer.print(
                \\/// Apply transformer iteratively until condition is met
                \\/// Pattern: Source → Transformer^n → Result
                \\pub fn iterate_until(
                \\    initial: u64,
                \\    transformer: *const fn(u64) u64,
                \\    condition: *const fn(u64) bool,
                \\    max_steps: usize,
                \\) IterationResult {{
                \\    var current = initial;
                \\    var steps: usize = 0;
                \\    var max_reached: u64 = initial;
                \\
                \\    while (!condition(current) and steps < max_steps) {{
                \\        current = transformer(current);
                \\        steps += 1;
                \\        if (current > max_reached) {{
                \\            max_reached = current;
                \\        }}
                \\    }}
                \\
                \\    return .{{
                \\        .value = current,
                \\        .steps = steps,
                \\        .max_reached = max_reached,
                \\        .converged = condition(current),
                \\    }};
                \\}}
                \\
                \\
            , .{});
        },
        .bounded => {
            try writer.print(
                \\/// Apply transformer a fixed number of times
                \\pub fn iterate_bounded(
                \\    initial: u64,
                \\    transformer: *const fn(u64) u64,
                \\    steps: usize,
                \\) u64 {{
                \\    var current = initial;
                \\    var i: usize = 0;
                \\    while (i < steps) : (i += 1) {{
                \\        current = transformer(current);
                \\    }}
                \\    return current;
                \\}}
                \\
                \\
            , .{});
        },
        .single => {
            // No special iteration needed
        },
        .infinite => {
            try writer.print(
                \\/// Generator for infinite sequence
                \\pub const InfiniteIterator = struct {{
                \\    current: u64,
                \\    transformer: *const fn(u64) u64,
                \\
                \\    pub fn next(self: *InfiniteIterator) u64 {{
                \\        const result = self.current;
                \\        self.current = self.transformer(self.current);
                \\        return result;
                \\    }}
                \\}};
                \\
                \\pub fn infinite_sequence(initial: u64, transformer: *const fn(u64) u64) InfiniteIterator {{
                \\    return .{{ .current = initial, .transformer = transformer }};
                \\}}
                \\
                \\
            , .{});
        },
    }

    // Generate statistical analysis if needed
    try writer.print(
        \\/// Statistical analysis of transformation over a range
        \\pub const Statistics = struct {{
        \\    count: usize,
        \\    sum: f64,
        \\    mean: f64,
        \\    min: f64,
        \\    max: f64,
        \\    all_converged: bool,
        \\}};
        \\
        \\pub fn analyze_range(
        \\    start: u64,
        \\    end: u64,
        \\    transformer: *const fn(u64) u64,
        \\    condition: *const fn(u64) bool,
        \\    max_steps: usize,
        \\) Statistics {{
        \\    var sum: f64 = 0;
        \\    var count: usize = 0;
        \\    var min: f64 = std.math.inf(f64);
        \\    var max: f64 = -std.math.inf(f64);
        \\    var all_converged = true;
        \\
        \\    var n = start;
        \\    while (n <= end) : (n += 1) {{
        \\        const result = iterate_until(n, transformer, condition, max_steps);
        \\        const steps_f = @as(f64, @floatFromInt(result.steps));
        \\        sum += steps_f;
        \\        count += 1;
        \\        if (steps_f < min) min = steps_f;
        \\        if (steps_f > max) max = steps_f;
        \\        if (!result.converged) all_converged = false;
        \\    }}
        \\
        \\    return .{{
        \\        .count = count,
        \\        .sum = sum,
        \\        .mean = sum / @as(f64, @floatFromInt(count)),
        \\        .min = min,
        \\        .max = max,
        \\        .all_converged = all_converged,
        \\    }};
        \\}}
        \\
        \\
    , .{});
}

/// Generate transformer function for Zig
fn generateTransformerZig(writer: anytype, transformer: parser.Transformer) !void {
    try writer.print(
        \\/// Transformer: {s}
        \\/// Type: {s}
        \\/// Input: {s} → Output: {s}
        \\
    , .{
        transformer.name,
        @tagName(transformer.transformer_type),
        transformer.input,
        transformer.output,
    });

    switch (transformer.transformer_type) {
        .pure => {
            try writer.print(
                \\pub fn {s}(input: u64) u64 {{
                \\    // TODO: Implement transformation rule
                \\    // Rule: {s}
                \\    _ = input;
                \\    return 0;
                \\}}
                \\
                \\
            , .{ transformer.name, transformer.rule });
        },
        .filter => {
            try writer.print(
                \\pub fn {s}(input: u64) bool {{
                \\    // TODO: Implement filter predicate
                \\    // Rule: {s}
                \\    _ = input;
                \\    return false;
                \\}}
                \\
                \\/// Filter a range using {s}
                \\pub fn filter_range_{s}(allocator: std.mem.Allocator, start: u64, end: u64) ![]u64 {{
                \\    var results = std.ArrayList(u64).init(allocator);
                \\    var n = start;
                \\    while (n <= end) : (n += 1) {{
                \\        if ({s}(n)) {{
                \\            try results.append(n);
                \\        }}
                \\    }}
                \\    return results.toOwnedSlice();
                \\}}
                \\
                \\
            , .{ transformer.name, transformer.rule, transformer.name, transformer.name, transformer.name });
        },
        .mapping => {
            try writer.print(
                \\pub fn {s}(a: u64, b: u64) u64 {{
                \\    // TODO: Implement mapping function
                \\    // Rule: {s}
                \\    _ = a;
                \\    _ = b;
                \\    return 0;
                \\}}
                \\
                \\/// Find pairs that map to target using {s}
                \\pub const Pair = struct {{ a: u64, b: u64 }};
                \\
                \\pub fn find_pairs_{s}(allocator: std.mem.Allocator, target: u64, limit: u64) ![]Pair {{
                \\    var results = std.ArrayList(Pair).init(allocator);
                \\    var a: u64 = 1;
                \\    while (a <= limit) : (a += 1) {{
                \\        var b: u64 = a;
                \\        while (b <= limit) : (b += 1) {{
                \\            if ({s}(a, b) == target) {{
                \\                try results.append(.{{ .a = a, .b = b }});
                \\            }}
                \\        }}
                \\    }}
                \\    return results.toOwnedSlice();
                \\}}
                \\
                \\
            , .{ transformer.name, transformer.rule, transformer.name, transformer.name, transformer.name });
        },
        .generator => {
            try writer.print(
                \\pub const {s}Iterator = struct {{
                \\    state: u64,
                \\
                \\    pub fn next(self: *{s}Iterator) ?u64 {{
                \\        // TODO: Implement generator
                \\        // Rule: {s}
                \\        const result = self.state;
                \\        self.state += 1;
                \\        return result;
                \\    }}
                \\}};
                \\
                \\pub fn {s}() {s}Iterator {{
                \\    return .{{ .state = 0 }};
                \\}}
                \\
                \\
            , .{ transformer.name, transformer.name, transformer.rule, transformer.name, transformer.name });
        },
        .iterative => {
            try writer.print(
                \\pub fn {s}(input: u64) u64 {{
                \\    // TODO: Implement iterative transformation
                \\    // Rule: {s}
                \\    _ = input;
                \\    return 0;
                \\}}
                \\
                \\
            , .{ transformer.name, transformer.rule });
        },
    }
}

/// Generate automatic tests based on test_generation config
fn generateAutoTestsZig(writer: anytype, spec: parser.Spec, tg: parser.TestGeneration) !void {
    _ = spec;

    try writer.print(
        \\// ============================================================================
        \\// Auto-generated Tests (from test_generation config)
        \\// ============================================================================
        \\
        \\
    , .{});

    if (tg.boundary) {
        try writer.print(
            \\test "boundary: zero" {{
            \\    // Auto-generated boundary test for value 0
            \\    // TODO: Add assertions based on spec
            \\}}
            \\
            \\test "boundary: one" {{
            \\    // Auto-generated boundary test for value 1
            \\    // TODO: Add assertions based on spec
            \\}}
            \\
            \\test "boundary: max_u32" {{
            \\    // Auto-generated boundary test for max u32
            \\    const max_val: u64 = std.math.maxInt(u32);
            \\    _ = max_val;
            \\    // TODO: Add assertions based on spec
            \\}}
            \\
            \\
        , .{});
    }

    if (tg.stress) {
        for (tg.stress_limits) |limit| {
            try writer.print(
                \\test "stress: range_1_to_{d}" {{
                \\    // Auto-generated stress test for range 1 to {d}
                \\    // TODO: Add range verification based on spec
                \\}}
                \\
                \\
            , .{ limit, limit });
        }

        // Default stress tests if no limits specified
        if (tg.stress_limits.len == 0) {
            try writer.print(
                \\test "stress: range_1_to_1000" {{
                \\    // Auto-generated stress test for range 1 to 1000
                \\}}
                \\
                \\test "stress: range_1_to_10000" {{
                \\    // Auto-generated stress test for range 1 to 10000
                \\}}
                \\
                \\
            , .{});
        }
    }

    if (tg.property) {
        try writer.print(
            \\test "property: idempotence" {{
            \\    // Auto-generated property test: f(f(x)) behavior
            \\    // TODO: Add property assertions based on spec
            \\}}
            \\
            \\test "property: monotonicity" {{
            \\    // Auto-generated property test: ordering preservation
            \\    // TODO: Add property assertions based on spec
            \\}}
            \\
            \\
        , .{});
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn toPascalCase(name: []const u8) []const u8 {
    // Simple implementation - just return as-is for now
    // In production, would convert snake_case to PascalCase
    return name;
}

fn toCamelCase(name: []const u8) []const u8 {
    // Simple implementation - just return as-is for now
    // In production, would convert snake_case to camelCase
    return name;
}

// ============================================================================
// TESTS
// ============================================================================

test "generate zig code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "zig",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Zig") != null);
}

test "generate python code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "python",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "def test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Python") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "import pytest") != null);
}

test "generate rust code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "rust",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn test_behavior") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Rust") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "#[cfg(test)]") != null);
}

test "generate go code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "go",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "func") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: Go") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "package") != null);
}

test "generate typescript code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "typescript",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "export function") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: TypeScript") != null);
}

test "generate wasm code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "Input provided",
            .when = "Function called",
            .then = "Result returned",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test",
        .version = "1.0.0",
        .language = "wasm",
        .module = "test_module",
        .description = "Test module",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    try std.testing.expect(std.mem.indexOf(u8, code, "(module") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "Target: WebAssembly") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "(func (export") != null);
}

test "target from string" {
    try std.testing.expect(Target.fromString("zig") == .zig);
    try std.testing.expect(Target.fromString("python") == .python);
    try std.testing.expect(Target.fromString("py") == .python);
    try std.testing.expect(Target.fromString("rust") == .rust);
    try std.testing.expect(Target.fromString("rs") == .rust);
    try std.testing.expect(Target.fromString("go") == .go);
    try std.testing.expect(Target.fromString("golang") == .go);
    try std.testing.expect(Target.fromString("gleam") == .gleam);
    try std.testing.expect(Target.fromString("typescript") == .typescript);
    try std.testing.expect(Target.fromString("ts") == .typescript);
    try std.testing.expect(Target.fromString("wasm") == .wasm);
    try std.testing.expect(Target.fromString("unknown") == null);
}

// ============================================================================
// Creation Pattern Code Generation Tests
// ============================================================================

test "generate creation pattern infrastructure" {
    var behaviors = [_]parser.Behavior{};

    const cp = parser.CreationPattern{
        .source = "PositiveInteger",
        .transformer = "collatz_step",
        .result = "One",
        .iteration = .until_condition,
        .condition = "equals(1)",
        .max_steps = 10000,
    };

    const spec = parser.Spec{
        .name = "collatz",
        .version = "1.0.0",
        .language = "zig",
        .module = "collatz",
        .description = "Collatz conjecture",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = cp,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    // Should generate Creation Pattern header
    try std.testing.expect(std.mem.indexOf(u8, code, "Creation Pattern:") != null);
    // Should generate IterationResult type
    try std.testing.expect(std.mem.indexOf(u8, code, "IterationResult") != null);
    // Should generate iterate_until function
    try std.testing.expect(std.mem.indexOf(u8, code, "iterate_until") != null);
    // Should generate Statistics type
    try std.testing.expect(std.mem.indexOf(u8, code, "Statistics") != null);
    // Should generate analyze_range function
    try std.testing.expect(std.mem.indexOf(u8, code, "analyze_range") != null);
}

test "generate transformer functions" {
    var behaviors = [_]parser.Behavior{};

    var transformers = [_]parser.Transformer{
        .{
            .name = "collatz_step",
            .transformer_type = .pure,
            .input = "u64",
            .output = "u64",
            .rule = "n/2 if even, 3n+1 if odd",
        },
        .{
            .name = "is_twin_prime",
            .transformer_type = .filter,
            .input = "u64",
            .output = "bool",
            .rule = "p and p+2 both prime",
        },
    };

    const spec = parser.Spec{
        .name = "transformers",
        .version = "1.0.0",
        .language = "zig",
        .module = "transformers",
        .description = "Transformer tests",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &transformers,
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    // Should generate pure transformer
    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn collatz_step") != null);
    // Should generate filter transformer
    try std.testing.expect(std.mem.indexOf(u8, code, "pub fn is_twin_prime") != null);
    // Should generate filter_range helper for filter type
    try std.testing.expect(std.mem.indexOf(u8, code, "filter_range_is_twin_prime") != null);
}

test "generate auto tests" {
    var behaviors = [_]parser.Behavior{};

    const tg = parser.TestGeneration{
        .boundary = true,
        .stress = true,
        .property = true,
        .stress_limits = &[_]usize{},
        .coverage_target = 80,
    };

    const spec = parser.Spec{
        .name = "autotests",
        .version = "1.0.0",
        .language = "zig",
        .module = "autotests",
        .description = "Auto test generation",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = tg,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    // Should generate boundary tests
    try std.testing.expect(std.mem.indexOf(u8, code, "boundary: zero") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "boundary: one") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "boundary: max_u32") != null);
    // Should generate stress tests
    try std.testing.expect(std.mem.indexOf(u8, code, "stress: range") != null);
    // Should generate property tests
    try std.testing.expect(std.mem.indexOf(u8, code, "property: idempotence") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "property: monotonicity") != null);
}

// ============================================================================
// 999 CODE GENERATOR - СВЯЩЕННЫЙ КОПТСКИЙ АЛФАВИТ
// ============================================================================
// АЛФАВИТ ЦАРСТВА (27 символов):
// МЕДНОЕ (1-9):     Ⲁ Ⲃ Ⲅ Ⲇ Ⲉ Ⲋ Ⲍ Ⲏ Ⲑ
// СЕРЕБРЯНОЕ (10-18): Ⲓ Ⲕ Ⲗ Ⲙ Ⲛ Ⲝ Ⲟ Ⲡ Ⲣ
// ЗОЛОТОЕ (19-27):   Ⲥ Ⲧ Ⲩ Ⲫ Ⲭ Ⲯ Ⲱ Ⳁ Ⳃ

const COPTIC_ALPHABET = [27][]const u8{
    "Ⲁ", "Ⲃ", "Ⲅ", "Ⲇ", "Ⲉ", "Ⲋ", "Ⲍ", "Ⲏ", "Ⲑ", // Медное 1-9
    "Ⲓ", "Ⲕ", "Ⲗ", "Ⲙ", "Ⲛ", "Ⲝ", "Ⲟ", "Ⲡ", "Ⲣ", // Серебряное 10-18
    "Ⲥ", "Ⲧ", "Ⲩ", "Ⲫ", "Ⲭ", "Ⲯ", "Ⲱ", "Ⳁ", "Ⳃ", // Золотое 19-27
};

// Латиница → Коптский (консистентный маппинг)
const LATIN_TO_COPTIC = [26][]const u8{
    "Ⲁ", // a
    "Ⲃ", // b
    "Ⲕ", // c → k
    "Ⲇ", // d
    "Ⲉ", // e
    "Ⲫ", // f
    "Ⲅ", // g
    "Ⲏ", // h
    "Ⲓ", // i
    "Ⲓ", // j → i
    "Ⲕ", // k
    "Ⲗ", // l
    "Ⲙ", // m
    "Ⲛ", // n
    "Ⲟ", // o
    "Ⲡ", // p
    "Ⲕ", // q → k
    "Ⲣ", // r
    "Ⲥ", // s
    "Ⲧ", // t
    "Ⲩ", // u
    "Ⲃ", // v → b
    "Ⲱ", // w
    "Ⲭ", // x
    "Ⲩ", // y → u
    "Ⲍ", // z
};

// Ключевые слова языка 999 (КОНСИСТЕНТНЫЕ)
const KW_MODULE = "Ⲙ";
const KW_FUNCTION = "Ⲫ";
const KW_STRUCT = "Ⲥ";
const KW_CONST = "Ⲕ";
const KW_VAR = "Ⲝ";
const KW_EXPORT = "Ⲉ";
const KW_IMPORT = "Ⲓ";
const KW_IF = "ⲈⲤ";
const KW_ELSE = "ⲈⲖ";
const KW_FOR = "ⲆⲖ";
const KW_WHILE = "ⲠⲔ";
const KW_RETURN = "ⲂⲌ";
const KW_BREAK = "ⲂⲢ";
const KW_CONTINUE = "ⲠⲢ";
const KW_IN = "Ⲃ";
const KW_RANGE = "ⲆⲀ";
const KW_TRUE = "Ⲑ";
const KW_FALSE = "Ⲁ";
const KW_NULL = "Ⲱ";

// Типы данных (КОНСИСТЕНТНЫЕ)
const TYPE_INT = "Ⲓ";
const TYPE_FLOAT = "Ⲫ";
const TYPE_STRING = "Ⲥ";
const TYPE_BOOL = "Ⲃ";
const TYPE_LIST = "Ⲗ";
const TYPE_MAP = "Ⲙ";
const TYPE_VOID = "Ⲱ";

// ============================================================================
// КОНСИСТЕНТНАЯ ТАБЛИЦА ИДЕНТИФИКАТОРОВ
// ============================================================================
// Гарантирует: один идентификатор → всегда один коптский код

const ConsistentMapping = struct {
    latin: []const u8,
    coptic: []const u8,
};

const CONSISTENT_IDENTIFIERS = [_]ConsistentMapping{
    // UI компоненты
    .{ .latin = "layout", .coptic = "ⲖⲀⲨⲞ" },
    .{ .latin = "button", .coptic = "ⲂⲦⲚⲔ" },
    .{ .latin = "input", .coptic = "ⲒⲚⲠⲦ" },
    .{ .latin = "text", .coptic = "ⲦⲈⲜⲦ" },
    .{ .latin = "image", .coptic = "ⲒⲘⲀⲄ" },
    .{ .latin = "container", .coptic = "ⲔⲞⲚⲦ" },
    .{ .latin = "card", .coptic = "ⲔⲀⲢⲆ" },
    .{ .latin = "modal", .coptic = "ⲘⲞⲆⲖ" },
    .{ .latin = "navbar", .coptic = "ⲚⲀⲂⲢ" },
    .{ .latin = "sidebar", .coptic = "ⲤⲒⲆⲂ" },
    // Действия
    .{ .latin = "click", .coptic = "ⲔⲖⲒⲔ" },
    .{ .latin = "submit", .coptic = "ⲤⲂⲘⲦ" },
    .{ .latin = "change", .coptic = "ⲬⲚⲄⲈ" },
    .{ .latin = "load", .coptic = "ⲖⲞⲀⲆ" },
    .{ .latin = "save", .coptic = "ⲤⲀⲂⲈ" },
    .{ .latin = "delete", .coptic = "ⲆⲈⲖⲦ" },
    .{ .latin = "update", .coptic = "ⲨⲠⲆⲦ" },
    .{ .latin = "create", .coptic = "ⲔⲢⲈⲦ" },
    // Данные
    .{ .latin = "data", .coptic = "ⲆⲀⲦⲀ" },
    .{ .latin = "value", .coptic = "ⲂⲀⲖⲨ" },
    .{ .latin = "result", .coptic = "ⲢⲈⲤⲖ" },
    .{ .latin = "error", .coptic = "ⲈⲢⲢⲢ" },
    .{ .latin = "state", .coptic = "ⲤⲦⲀⲦ" },
    .{ .latin = "props", .coptic = "ⲠⲢⲞⲠ" },
    .{ .latin = "config", .coptic = "ⲔⲞⲚⲪ" },
    .{ .latin = "options", .coptic = "ⲞⲠⲦⲤ" },
    // Генерация
    .{ .latin = "generate", .coptic = "ⲄⲈⲚⲢ" },
    .{ .latin = "render", .coptic = "ⲢⲚⲆⲢ" },
    .{ .latin = "transform", .coptic = "ⲦⲢⲚⲤ" },
    .{ .latin = "encode", .coptic = "ⲈⲚⲔⲆ" },
    .{ .latin = "decode", .coptic = "ⲆⲈⲔⲆ" },
    .{ .latin = "parse", .coptic = "ⲠⲀⲢⲤ" },
    .{ .latin = "compile", .coptic = "ⲔⲘⲠⲖ" },
    // 3D/WorldGen
    .{ .latin = "world", .coptic = "ⲰⲢⲖⲆ" },
    .{ .latin = "terrain", .coptic = "ⲦⲢⲢⲚ" },
    .{ .latin = "object", .coptic = "ⲞⲂⲒⲔ" },
    .{ .latin = "scene", .coptic = "ⲤⲤⲈⲚ" },
    .{ .latin = "camera", .coptic = "ⲔⲀⲘⲢ" },
    .{ .latin = "light", .coptic = "ⲖⲒⲄⲦ" },
    .{ .latin = "mesh", .coptic = "ⲘⲈⲰⲤ" },
    .{ .latin = "texture", .coptic = "ⲦⲈⲜⲢ" },
    // GNN/ML
    .{ .latin = "graph", .coptic = "ⲄⲢⲀⲪ" },
    .{ .latin = "node", .coptic = "ⲚⲞⲆⲈ" },
    .{ .latin = "edge", .coptic = "ⲈⲆⲄⲈ" },
    .{ .latin = "layer", .coptic = "ⲖⲀⲨⲢ" },
    .{ .latin = "model", .coptic = "ⲘⲞⲆⲖ" },
    .{ .latin = "train", .coptic = "ⲦⲢⲀⲚ" },
    .{ .latin = "predict", .coptic = "ⲠⲢⲈⲆ" },
    .{ .latin = "loss", .coptic = "ⲖⲞⲤⲤ" },
    // Diffusion
    .{ .latin = "diffusion", .coptic = "ⲆⲒⲪⲤ" },
    .{ .latin = "noise", .coptic = "ⲚⲞⲒⲤ" },
    .{ .latin = "denoise", .coptic = "ⲆⲚⲞⲤ" },
    .{ .latin = "step", .coptic = "ⲤⲦⲈⲠ" },
    .{ .latin = "sample", .coptic = "ⲤⲘⲠⲖ" },
    // Gradient
    .{ .latin = "gradient", .coptic = "ⲄⲢⲀⲆ" },
    .{ .latin = "optimize", .coptic = "ⲞⲠⲦⲘ" },
    .{ .latin = "minimize", .coptic = "ⲘⲒⲚⲘ" },
    .{ .latin = "maximize", .coptic = "ⲘⲀⲜⲘ" },
    .{ .latin = "constraint", .coptic = "ⲔⲚⲤⲦ" },
    // Общие
    .{ .latin = "test", .coptic = "ⲦⲈⲤⲦ" },
    .{ .latin = "spec", .coptic = "ⲤⲠⲈⲔ" },
    .{ .latin = "behavior", .coptic = "ⲂⲈⲎⲂ" },
    .{ .latin = "module", .coptic = "ⲘⲞⲆⲨ" },
    .{ .latin = "source", .coptic = "ⲤⲞⲨⲢ" },
    .{ .latin = "target", .coptic = "ⲦⲀⲢⲄ" },
};

/// Кодирование числа в base-27 коптский алфавит
fn encodeNumber(allocator: std.mem.Allocator, n: u64) ![]const u8 {
    if (n == 0) {
        return try allocator.dupe(u8, COPTIC_ALPHABET[0]);
    }
    
    var result = std.ArrayList(u8).init(allocator);
    var num = n;
    
    // Собираем цифры в обратном порядке
    var digits = std.ArrayList(usize).init(allocator);
    defer digits.deinit();
    
    while (num > 0) {
        try digits.append(num % 27);
        num /= 27;
    }
    
    // Записываем в правильном порядке
    var i: usize = digits.items.len;
    while (i > 0) {
        i -= 1;
        try result.appendSlice(COPTIC_ALPHABET[digits.items[i]]);
    }
    
    return result.toOwnedSlice();
}

/// Поиск в консистентной таблице
fn findConsistentMapping(name: []const u8) ?[]const u8 {
    // Приводим к нижнему регистру для поиска
    var lower_buf: [64]u8 = undefined;
    const len = @min(name.len, 64);
    for (name[0..len], 0..) |c, i| {
        lower_buf[i] = if (c >= 'A' and c <= 'Z') c + 32 else c;
    }
    const lower = lower_buf[0..len];
    
    for (CONSISTENT_IDENTIFIERS) |mapping| {
        if (std.mem.eql(u8, mapping.latin, lower)) {
            return mapping.coptic;
        }
    }
    return null;
}

/// Кодирование одной латинской буквы в коптскую
fn latinToCoptic(c: u8) []const u8 {
    const lower = if (c >= 'A' and c <= 'Z') c + 32 else c;
    if (lower >= 'a' and lower <= 'z') {
        return LATIN_TO_COPTIC[lower - 'a'];
    }
    return "Ⲁ"; // default
}

/// КОНСИСТЕНТНОЕ кодирование идентификатора в коптский алфавит
/// Гарантирует: один идентификатор → всегда один коптский код
fn encodeIdentifier(allocator: std.mem.Allocator, name: []const u8) ![]const u8 {
    // 1. Сначала ищем в консистентной таблице
    if (findConsistentMapping(name)) |coptic| {
        return try allocator.dupe(u8, coptic);
    }
    
    // 2. Если не найдено - кодируем первые 4 буквы детерминированно
    var result = std.ArrayList(u8).init(allocator);
    
    var count: usize = 0;
    for (name) |c| {
        if (count >= 4) break;
        if ((c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z')) {
            try result.appendSlice(latinToCoptic(c));
            count += 1;
        }
    }
    
    // Если меньше 4 символов - дополняем Ⲁ
    while (count < 4) {
        try result.appendSlice("Ⲁ");
        count += 1;
    }
    
    return result.toOwnedSlice();
}

/// Генерация кода на языке 999
fn generate999(allocator: std.mem.Allocator, spec: parser.Spec) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    const writer = output.writer();

    // Заголовок модуля
    const module_name = try encodeIdentifier(allocator, spec.module);
    defer allocator.free(module_name);
    
    try writer.print(
        \\// ⳃⳃⳃ - Ⲅⲉⲛⲉⲣⲁⲧⲉⲇ ⲃⲩ ⲂⲒⲂⲈⲈⲤ
        \\// Ⲥⲟⲩⲣⲥⲉ: {s}.vibee
        \\// Ⲃⲉⲣⲥⲓⲟⲛ: {s}
        \\
        \\{s} {s}
        \\
        \\
    , .{ spec.name, spec.version, KW_MODULE, module_name });

    // Генерация констант из Creation Pattern
    if (spec.creation_pattern) |cp| {
        const source_enc = try encodeIdentifier(allocator, cp.source);
        defer allocator.free(source_enc);
        const transformer_enc = try encodeIdentifier(allocator, cp.transformer);
        defer allocator.free(transformer_enc);
        const result_enc = try encodeIdentifier(allocator, cp.result);
        defer allocator.free(result_enc);
        
        try writer.print(
            \\// Ⲥⲣⲉⲁⲧⲓⲟⲛ Ⲡⲁⲧⲧⲉⲣⲛ
            \\{s} {s}: {s} = "{s}"
            \\{s} {s}: {s} = "{s}"
            \\{s} {s}: {s} = "{s}"
            \\
            \\
        , .{
            KW_CONST, source_enc, TYPE_STRING, cp.source,
            KW_CONST, transformer_enc, TYPE_STRING, cp.transformer,
            KW_CONST, result_enc, TYPE_STRING, cp.result,
        });
    }

    // Генерация функций из behaviors
    for (spec.behaviors) |behavior| {
        const func_name = try encodeIdentifier(allocator, behavior.name);
        defer allocator.free(func_name);
        
        try writer.print(
            \\// {s}
            \\// Ⲅⲓⲃⲉⲛ: {s}
            \\// Ⲱⲏⲉⲛ: {s}
            \\// Ⲧⲏⲉⲛ: {s}
            \\{s} {s}() -> {s} {{
            \\  {s} {s}
            \\}}
            \\
            \\
        , .{
            behavior.name,
            behavior.given,
            behavior.when,
            behavior.then,
            KW_FUNCTION, func_name, TYPE_VOID,
            KW_RETURN, KW_NULL,
        });
    }

    // Генерация трансформеров
    for (spec.transformers) |transformer| {
        const trans_name = try encodeIdentifier(allocator, transformer.name);
        defer allocator.free(trans_name);
        const input_enc = try encodeIdentifier(allocator, transformer.input);
        defer allocator.free(input_enc);
        const output_enc = try encodeIdentifier(allocator, transformer.output);
        defer allocator.free(output_enc);
        
        try writer.print(
            \\// Ⲧⲣⲁⲛⲥⲫⲟⲣⲙⲉⲣ: {s}
            \\{s} {s}({s}: {s}) -> {s} {{
            \\  {s} {s}
            \\}}
            \\
            \\
        , .{
            transformer.name,
            KW_FUNCTION, trans_name, input_enc, TYPE_INT, output_enc,
            KW_RETURN, KW_NULL,
        });
    }

    // Экспорты
    try writer.print(
        \\{s} {{
    , .{KW_EXPORT});
    
    for (spec.behaviors, 0..) |behavior, i| {
        const func_name = try encodeIdentifier(allocator, behavior.name);
        defer allocator.free(func_name);
        
        if (i > 0) try writer.writeAll(", ");
        try writer.writeAll(func_name);
    }
    
    try writer.writeAll(" }\n");

    return output.toOwnedSlice();
}

test "generate 999 code" {
    var behaviors = [_]parser.Behavior{
        .{
            .name = "test_behavior",
            .given = "input",
            .when = "process",
            .then = "output",
            .test_cases = &[_]parser.TestCase{},
        },
    };

    const spec = parser.Spec{
        .name = "test999",
        .version = "1.0.0",
        .language = "999",
        .module = "test_module",
        .description = "Test 999 generation",
        .behaviors = &behaviors,
        .types = &[_]parser.Type{},
        .functions = &[_]parser.Function{},
        .imports = &[_][]const u8{},
        .creation_pattern = null,
        .transformers = &[_]parser.Transformer{},
        .test_generation = null,
        .allocator = std.testing.allocator,
    };

    const code = try generate(std.testing.allocator, spec);
    defer std.testing.allocator.free(code);

    // Должен содержать коптские символы
    try std.testing.expect(std.mem.indexOf(u8, code, "Ⲙ") != null); // MODULE
    try std.testing.expect(std.mem.indexOf(u8, code, "Ⲫ") != null); // FUNCTION
    try std.testing.expect(std.mem.indexOf(u8, code, "Ⲉ") != null); // EXPORT
    
    // Не должен содержать латинские ключевые слова
    try std.testing.expect(std.mem.indexOf(u8, code, "module ") == null);
    try std.testing.expect(std.mem.indexOf(u8, code, "function ") == null);
    try std.testing.expect(std.mem.indexOf(u8, code, "export ") == null);
}

test "encode number to coptic" {
    // 0 = Ⲁ
    const zero = try encodeNumber(std.testing.allocator, 0);
    defer std.testing.allocator.free(zero);
    try std.testing.expectEqualStrings("Ⲁ", zero);
    
    // 1 = Ⲃ
    const one = try encodeNumber(std.testing.allocator, 1);
    defer std.testing.allocator.free(one);
    try std.testing.expectEqualStrings("Ⲃ", one);
    
    // 26 = Ⳃ
    const twentysix = try encodeNumber(std.testing.allocator, 26);
    defer std.testing.allocator.free(twentysix);
    try std.testing.expectEqualStrings("Ⳃ", twentysix);
    
    // 27 = ⲂⲀ (1*27 + 0)
    const twentyseven = try encodeNumber(std.testing.allocator, 27);
    defer std.testing.allocator.free(twentyseven);
    try std.testing.expectEqualStrings("ⲂⲀ", twentyseven);
}

test "consistent identifier encoding" {
    // Тест консистентности: один идентификатор → всегда один код
    
    // layout → ⲖⲀⲨⲞ (из таблицы)
    const layout1 = try encodeIdentifier(std.testing.allocator, "layout");
    defer std.testing.allocator.free(layout1);
    const layout2 = try encodeIdentifier(std.testing.allocator, "layout");
    defer std.testing.allocator.free(layout2);
    try std.testing.expectEqualStrings("ⲖⲀⲨⲞ", layout1);
    try std.testing.expectEqualStrings(layout1, layout2); // КОНСИСТЕНТНОСТЬ!
    
    // button → ⲂⲦⲚⲔ (из таблицы)
    const button = try encodeIdentifier(std.testing.allocator, "button");
    defer std.testing.allocator.free(button);
    try std.testing.expectEqualStrings("ⲂⲦⲚⲔ", button);
    
    // graph → ⲄⲢⲀⲪ (из таблицы)
    const graph = try encodeIdentifier(std.testing.allocator, "graph");
    defer std.testing.allocator.free(graph);
    try std.testing.expectEqualStrings("ⲄⲢⲀⲪ", graph);
    
    // Новый идентификатор (не в таблице) - детерминированное кодирование
    const custom1 = try encodeIdentifier(std.testing.allocator, "myVar");
    defer std.testing.allocator.free(custom1);
    const custom2 = try encodeIdentifier(std.testing.allocator, "myVar");
    defer std.testing.allocator.free(custom2);
    try std.testing.expectEqualStrings(custom1, custom2); // КОНСИСТЕНТНОСТЬ!
    try std.testing.expectEqualStrings("ⲘⲨⲂⲀ", custom1); // m=Ⲙ, y=Ⲩ, v=Ⲃ, a=Ⲁ
}

test "deterministic new identifier encoding" {
    // Новые идентификаторы кодируются детерминированно через латиницу
    
    // "test" → ⲦⲈⲤⲦ (из таблицы)
    const test_id = try encodeIdentifier(std.testing.allocator, "test");
    defer std.testing.allocator.free(test_id);
    try std.testing.expectEqualStrings("ⲦⲈⲤⲦ", test_id);
    
    // "xyz" → ⲬⲨⲌⲀ (x=Ⲭ, y=Ⲩ, z=Ⲍ, дополнение Ⲁ)
    const xyz = try encodeIdentifier(std.testing.allocator, "xyz");
    defer std.testing.allocator.free(xyz);
    try std.testing.expectEqualStrings("ⲬⲨⲌⲀ", xyz);
}

// ============================================================================
// ВАЛИДАТОР КОПТСКОГО КОДА
// ============================================================================

/// Проверяет что строка содержит только коптские символы (Ⲁ-Ⳃ)
/// и допустимые символы (пробелы, переносы, пунктуация, цифры)
pub fn validateCopticCode(code: []const u8) bool {
    var i: usize = 0;
    while (i < code.len) {
        const c = code[i];
        
        // ASCII допустимые: пробелы, переносы, пунктуация, цифры, комментарии
        if (c <= 127) {
            // Запрещены латинские буквы!
            if ((c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z')) {
                return false;
            }
            i += 1;
            continue;
        }
        
        // UTF-8 многобайтовые символы
        // Коптский диапазон: U+2C80 - U+2CFF (Ⲁ-Ⳃ)
        if (c >= 0xE2) {
            // 3-байтовый UTF-8
            if (i + 2 < code.len) {
                i += 3;
                continue;
            }
        } else if (c >= 0xC0) {
            // 2-байтовый UTF-8
            if (i + 1 < code.len) {
                i += 2;
                continue;
            }
        }
        
        i += 1;
    }
    return true;
}

/// Проверяет что код НЕ содержит латинских букв
pub fn hasNoLatinLetters(code: []const u8) bool {
    for (code) |c| {
        if ((c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z')) {
            return false;
        }
    }
    return true;
}

test "validate coptic code - no latin" {
    // Правильный код (только коптский)
    const valid = "Ⲙ ⲦⲈⲤⲦ\nⲂⲌ Ⲱ";
    try std.testing.expect(hasNoLatinLetters(valid));
    
    // Неправильный код (есть латиница)
    const invalid = "func test() { return 0; }";
    try std.testing.expect(!hasNoLatinLetters(invalid));
    
    // Смешанный (недопустимо)
    const mixed = "Ⲙ test";
    try std.testing.expect(!hasNoLatinLetters(mixed));
}
