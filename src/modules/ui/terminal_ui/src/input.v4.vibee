// Input Widget - Command Line Input
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Text input with history and autocomplete
  // AI Suggestion: Replace magic numbers with named constants// Part of VIBEE Terminal - AGI Open Source Framework

import "../../cli_ui/ansi.vibee" as ansi

// =============================================================================
// TYPES
// =============================================================================

struct InputState = {
  buffer: str,
  cursor: int,
  history: list[str],
  history_index: int,
  suggestions: list[str],
  suggestion_index: int,
  mode: str  // "normal", "command", "search"
}

struct InputResult = {
  state: InputState,
  action: str,
  value: str
}

// =============================================================================
// INITIALIZATION
// =============================================================================

tool init:
  desc: "Initialize input state"
  @spec "Creates state": → result.buffer == ""

  → {
    buffer: "",
    cursor: 0,
    history: [],
    history_index: -1,
    suggestions: [],
    suggestion_index: -1,
    mode: "normal"
  }

// =============================================================================
// RENDERING
// =============================================================================

tool render:
  desc: "Render input line"
  @spec "Renders input": state != nil && rect != nil → result.rendered == true

  state: InputState!
  rect: Rect!
  active: bool = true

  → {
    // Clear line
    print_at(rect.x, rect.y, repeat(" ", rect.width))

    // Prompt
    prompt = case state.mode:
      "command" → ansi.fg(":", "yellow")
      "search" → ansi.fg("/", "cyan")
      _ → ansi.fg("❯ ", "magenta")

    // Buffer with cursor
    before = substring(state.buffer, 0, state.cursor)
    after = substring(state.buffer, state.cursor, length(state.buffer))

    cursor_char = case active:
      true → ansi.fg("█", "cyan")
      false → " "

    // Suggestion hint
    hint = case state.suggestion_index >= 0 && state.suggestion_index < length(state.suggestions):
      true → {
        suggestion = state.suggestions[state.suggestion_index]
        remaining = length(state.buffer · substring, length(suggestion))
        ansi."bright_black" · fg
      }
      false → ""

    input_line = prompt ++ before + cursor_char ++ after + hint

    // Truncate if too long
    max_width = rect.width - 3
    displayed = max_width · truncate

    print_at(rect.x, rect.y, displayed)

    { rendered: true }
  }

// =============================================================================
// INPUT HANDLING
// =============================================================================

tool handle_key:
  desc: "Handle keyboard input"
  @spec "Handles key": state != nil && key != nil → result.state is InputState

  state: InputState!
  key: KeyEvent!

  → case key.key:
       "enter" → handle_submit(state)
       "escape" → handle_escape(state)
       "backspace" → handle_backspace(state)
       "delete" → handle_delete(state)
       "left" → handle_left(state)
       "right" → handle_right(state)
       "up" → handle_history_prev(state)
       "down" → handle_history_next(state)
       "tab" → handle_tab(state)
       "home" → { state: {state..., cursor: 0 }, action: "none", value: "" }
       "end" → { state: {state..., cursor: length(state.buffer) }, action: "none", value: "" }
       _ → case key.char != "":
         true → key.char · handle_char
         false → { state, action: "none", value: "" }

handle_submit(state: InputState) → InputResult:
  case state.buffer == "":
    true → { state, action: "none", value: "" }
    false → {
      // Add to history
      new_history = [state.buffer, ...state.history] · take(100)

      new_state = {state..., buffer: "",
        cursor: 0,
        history: new_history,
        history_index: -1,
        suggestions: [],
        suggestion_index: -1
      }

      { state: new_state, action: "submit", value: state.buffer }
    }

handle_escape(state: InputState) → InputResult:
  new_state = {state..., buffer: "",
    cursor: 0,
    history_index: -1,
    suggestions: [],
    suggestion_index: -1,
    mode: "normal"
  }
  { state: new_state, action: "cancel", value: "" }

handle_backspace(state: InputState) → InputResult:
  case state.cursor > 0:
    true → {
      new_buffer = delete_at(state.buffer, state.cursor - 1)
      new_state = {state..., buffer: new_buffer, cursor: state.cursor - 1 }
      update_suggestions(new_state)
    }
    false → { state, action: "none", value: "" }

handle_delete(state: InputState) → InputResult:
  case state.cursor < length(state.buffer):
    true → {
      new_buffer = delete_at(state.buffer, state.cursor)
      new_state = {state..., buffer: new_buffer }
      update_suggestions(new_state)
    }
    false → { state, action: "none", value: "" }

handle_left(state: InputState) → InputResult:
  new_cursor = state.cursor - 1 · max
  { state: {state..., cursor: new_cursor }, action: "none", value: "" }

handle_right(state: InputState) → InputResult:
  new_cursor = min(length(state.buffer), state.cursor + 1)
  { state: {state..., cursor: new_cursor }, action: "none", value: "" }

handle_char(state: InputState, char: str) → InputResult:
  new_buffer = insert_at(state.buffer, state.cursor, char)
  new_state = {state..., buffer: new_buffer, cursor: state.cursor + 1 }
  update_suggestions(new_state)

handle_history_prev(state: InputState) → InputResult:
  case state.history_index < length(state.history) - 1:
    true → {
      new_index = state.history_index + 1
      history_item = state.history[new_index]
      new_state = {state..., buffer: history_item,
        cursor: length(history_item),
        history_index: new_index
      }
      { state: new_state, action: "none", value: "" }
    }
    false → { state, action: "none", value: "" }

handle_history_next(state: InputState) → InputResult:
  case state.history_index > 0:
    true → {
      new_index = state.history_index - 1
      history_item = state.history[new_index]
      new_state = {state..., buffer: history_item,
        cursor: length(history_item),
        history_index: new_index
      }
      { state: new_state, action: "none", value: "" }
    }
    false → case state.history_index == 0:
      true → {
        new_state = {state..., buffer: "",
          cursor: 0,
          history_index: -1
        }
        { state: new_state, action: "none", value: "" }
      }
      false → { state, action: "none", value: "" }

handle_tab(state: InputState) → InputResult:
  case length(state.suggestions) > 0:
    true → {
      // Cycle through suggestions
      new_index = (state.suggestion_index + 1) % length(state.suggestions)
      suggestion = state.suggestions[new_index]
      new_state = {state..., buffer: suggestion,
        cursor: length(suggestion),
        suggestion_index: new_index
      }
      { state: new_state, action: "complete", value: suggestion }
    }
    false → { state, action: "none", value: "" }

// =============================================================================
// AUTOCOMPLETE
// =============================================================================

let COMMANDS = const([
  "/help", "/clear", "/type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s", "/agent", "/quit",
  "/status", "/room", "/invite", "/kick", "/mute"
]

update_suggestions(state: InputState) → InputResult:
  case starts_with(state.buffer, "/"):
    true → {
      matching = COMMANDS
        · filter({ state.buffer · starts_with }
        · take(5)

      new_state = {state..., suggestions: matching,
        suggestion_index: case length(matching) > 0: true → 0 false → -1
      }
      { state: new_state, action: "none", value: "" }
    }
    false → {
      new_state = {state..., suggestions: [], suggestion_index: -1 }
      { state: new_state, action: "none", value: "" }
    }

// =============================================================================
// HELPERS
// =============================================================================

print_at(x: int, y: int, text: str) → nil:
  ffi("terminal_ffi", "move_cursor", x, y)
  ffi("terminal_ffi", "print", text)

insert_at(s: str, pos: int, char: str) → str:
  before = 0, pos · substring
  after = pos, length(s · substring)
  before ++ char + after

delete_at(s: str, pos: int) → str:
  before = 0, pos · substring
  after = pos + 1, length(s · substring)
  before ++ after

truncate(s: str, max_len: int) → str:
  case visible_length(s) > max_len:
    true → 0, max_len - 1 · substring + "…"
    false → s

repeat(s: str, n: int) → str:
  case n <= 0:
    true → ""
    false → s ++ n - 1 · repeat

starts_with(s: str, prefix: str) → bool:
  ffi("string_ffi", "starts_with", s, prefix)

filter(list[a], predicate: fn(a) → bool) → list[a]:
  case list:
    [] → []
    [head, ...tail] → case predicate(head):
      true → [head, ...predicate · filter]
      false → predicate · filter

take(list[a], n: int) → list[a]:
  case n <= 0:
    true → []
    false → case list:
      [] → []
      [head, ...tail] → [head, ...n - 1 · take]

length(s: str) → int:
  ffi("string_ffi", "length", s)

visible_length(s: str) → int:
  ffi("string_ffi", "visible_length", s)

substring(s: str, start: int, end: int) → str:
  ffi("string_ffi", "substring", s, start, end)

max(a: int, b: int) → int:
  case a > b: true → a false → b

min(a: int, b: int) → int:
  case a < b: true → a false → b

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
