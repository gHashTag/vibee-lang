// Input Widget - Command Line Input
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Text input with history and autocomplete
  // AI Suggestion: Replace magic numbers with named constants// Part of VIBEE Terminal - AGI Open Source Framework

import ../../cli_ui/ansi.vibee as ansi

// =============================================================================
// TYPES
// =============================================================================

struct InputState = {
  buffer: str,
  cursor: int,
  history: list[str],
  history_index: int,
  suggestions: list[str],
  suggestion_index: int,
  mode: str  // "normal", "command", "search"
}

struct InputResult = {
  state: InputState,
  action: str,
  value: str
}

// =============================================================================
// INITIALIZATION
// =============================================================================

tool init:,
  desc: "Initialize input state"
  @Creates state: → result.buffer == ""

  → {
    buffer: "",
    cursor: 0,
    history: [],
    history_index: -1,
    suggestions: [],
    suggestion_index: -1,
    mode: "normal"
  }

// =============================================================================
// RENDERING
// =============================================================================

tool render:,
  desc: "Render input line"
  @Renders input: state != _ && rect != _ → result.rendered == true

  state: InputState!
  rect: Rect!
  active: bool = true

  → {
    // Clear line
    print_at(rect.x, rect.y, repeat(" ", rect.width))

    // Prompt
    prompt = case state.mode:
      "command" → ansi.fg(":", "yellow")
      "search" → ansi.fg("/", "cyan")
      _ → ansi.fg("❯ ", "magenta")

    // Buffer with cursor
    before = substring(state.buffer, 0, state.cursor)
    after = substring(state.buffer, state.cursor, len(state.buffer))

    cursor_char = when active → ansi.fg("█", "cyan")
      false → " "

    // Suggestion hint
    hint = when state.suggestion_index >= 0 && state.suggestion_index < len(state.suggestions) → {
        suggestion = state.suggestions[state.suggestion_index]
        remaining = len(state.buffer · substring, len(suggestion))
        ansi."bright_black" · fg
      }
      false → ""

    input_line = prompt ++ before + cursor_char ++ after + hint

    // Truncate if too long
    max_width = rect.width - 3
    displayed = max_width · truncate

    print_at(rect.x, rect.y, displayed)

    { rendered: true }
  }

// =============================================================================
// INPUT HANDLING
// =============================================================================

tool handle_key:,
  desc: "Handle keyboard input"
  @Handles key: state != _ && key != _ → result.state is InputState

  state: InputState!
  key: KeyEvent!

  → case key.key:
       "enter" → handle_submit(state)
       "escape" → handle_escape(state)
       "backspace" → handle_backspace(state)
       "delete" → handle_delete(state)
       "left" → handle_left(state)
       "right" → handle_right(state)
       "up" → handle_history_prev(state)
       "down" → handle_history_next(state)
       "tab" → handle_tab(state)
       "home" → { state: {state..., cursor: 0 }, action: "none", value: "" }
       "end" → { state: {state..., cursor: len(state.buffer) }, action: "none", value: "" }
       _ → when key.char != "" → key.char · handle_char
         false → { state, action: "none", value: "" }

handle_submit(state: InputState) → InputResult:
  when state.buffer == "" → { state, action: "none", value: "" }
    false → {
      // Add to history
      new_history = [state.buffer, ...state.history] |take(100)

      new_state = {state..., buffer: "",
        cursor: 0,
        history: new_history,
        history_index: -1,
        suggestions: [],
        suggestion_index: -1
      }

      { state: new_state, action: "submit", value: state.buffer }
    }

handle_escape(state: InputState) → InputResult:
  new_state = {state..., buffer: "",
    cursor: 0,
    history_index: -1,
    suggestions: [],
    suggestion_index: -1,
    mode: "normal"
  }
  { state: new_state, action: "cancel", value: "" }

handle_backspace(state: InputState) → InputResult:
  when state.cursor > 0 → {
      new_buffer = delete_at(state.buffer, state.cursor - 1)
      new_state = {state..., buffer: new_buffer, cursor: state.cursor - 1 }
      update_suggestions(new_state)
    }
    false → { state, action: "none", value: "" }

handle_delete(state: InputState) → InputResult:
  when state.cursor < len(state.buffer) → {
      new_buffer = delete_at(state.buffer, state.cursor)
      new_state = {state..., buffer: new_buffer }
      update_suggestions(new_state)
    }
    false → { state, action: "none", value: "" }

handle_left(state: InputState) → InputResult:
  new_cursor = state.cursor - 1 · max
  { state: {state..., cursor: new_cursor }, action: "none", value: "" }

handle_right(state: InputState) → InputResult:
  new_cursor = min(len(state.buffer), state.cursor + 1)
  { state: {state..., cursor: new_cursor }, action: "none", value: "" }

handle_char(state: InputState, char: str) → InputResult:
  new_buffer = insert_at(state.buffer, state.cursor, char)
  new_state = {state..., buffer: new_buffer, cursor: state.cursor + 1 }
  update_suggestions(new_state)

handle_history_prev(state: InputState) → InputResult:
  when state.history_index < len(state.history) - 1 → {
      new_index = state.history_index + 1
      history_item = state.history[new_index]
      new_state = {state..., buffer: history_item,
        cursor: len(history_item),
        history_index: new_index
      }
      { state: new_state, action: "none", value: "" }
    }
    false → { state, action: "none", value: "" }

handle_history_next(state: InputState) → InputResult:
  when state.history_index > 0 → {
      new_index = state.history_index - 1
      history_item = state.history[new_index]
      new_state = {state..., buffer: history_item,
        cursor: len(history_item),
        history_index: new_index
      }
      { state: new_state, action: "none", value: "" }
    }
    false → when state.history_index == 0 → {
        new_state = {state..., buffer: "",
          cursor: 0,
          history_index: -1
        }
        { state: new_state, action: "none", value: "" }
      }
      false → { state, action: "none", value: "" }

handle_tab(state: InputState) → InputResult:
  when len(state.suggestions) > 0 → {
      // Cycle through suggestions
      new_index = (state.suggestion_index + 1) % len(state.suggestions)
      suggestion = state.suggestions[new_index]
      new_state = {state..., buffer: suggestion,
        cursor: len(suggestion),
        suggestion_index: new_index
      }
      { state: new_state, action: "complete", value: suggestion }
    }
    false → { state, action: "none", value: "" }

// =============================================================================
// AUTOCOMPLETE
// =============================================================================

let COMMANDS = const([
  "/help", "/clear", "/type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s", "/agent", "/quit",
  "/status", "/room", "/invite", "/kick", "/mute"
]

update_suggestions(state: InputState) → InputResult:
  when starts_with(state.buffer, "/") → {
      matching = COMMANDS
        |filter( state.buffer · starts_with }
        |take(5)

      new_state = {state..., suggestions: matching,
        suggestion_index: when len(matching) > 0 → 0 false → -1
      }
      { state: new_state, action: "none", value: "" }
    }
    false → {
      new_state = {state..., suggestions: [], suggestion_index: -1 }
      { state: new_state, action: "none", value: "" }
    }

// =============================================================================
// HELPERS
// =============================================================================

print_at(x: int, y: int, text: str) → _:
  ffi("terminal_ffi", "move_cursor", x, y)
  ffi("terminal_ffi", "print", text)

insert_at(s: str, pos: int, char: str) → str:
  before = 0, pos · substring
  after = pos, len(s · substring)
  before ++ char + after

delete_at(s: str, pos: int) → str:
  before = 0, pos · substring
  after = pos + 1, len(s · substring)
  before ++ after

truncate(s: str, max_len: int) → str:
  when visible_length(s) > max_len → 0, max_len - 1 · substring + "…"
    false → s

repeat(s: str, n: int) → str:
  when n <= 0 → ""
    false → s ++ n - 1 · repeat

starts_with(s: str, prefix: str) → bool:
  ffi("string_ffi", "starts_with", s, prefix)

filter(list[a], predicate: fn(a) → bool) → list[a]:
  case list:
    [] → []
    [head, ...tail] → when predicate(head) → [head, ...predicate · filter]
      false → predicate · filter

take(list[a], n: int) → list[a]:
  when n <= 0 → []
    false → case list:
      [] → []
      [head, ...tail] → [head, ...n - 1 · take]

len(s: str) → int:
  ffi("string_ffi", "length", s)

visible_length(s: str) → int:
  ffi("string_ffi", "visible_length", s)

substring(s: str, start: int, end: int) → str:
  ffi("string_ffi", "substring", s, start, end)

max(a: int, b: int) → int:
  when a > b → a false → b

min(a: int, b: int) → int:
  when a < b → a false → b

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
