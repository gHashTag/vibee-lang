// Layout - Panel and Split View System
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Flexbox-like terminal layout engine
// Part of VIBEE Terminal - AGI Open Source Framework

import "../cli_ui/style.vibee" as style
import "../cli_ui/ansi.vibee" as ansi

// =============================================================================
// RECT - Screen Region
// =============================================================================

struct Rect = {
  x: int,
  y: int,
  width: int,
  height: int
}

tool rect:
  desc: "Create a rectangle"
  @spec "Creates rect": width > 0 && height > 0 → result.width == width

  x: int = 0
  y: int = 0
  width: int!
  height: int!

  → { x, y, width, height }

tool rect_inner:
  desc: "Get inner rect (minus padding/border)"
  @spec "Gets inner": padding > 0 → result.width < rect.width

  rect: Rect!
  padding: int = 1

  → {
    x: rect.x + padding,
    y: rect.y + padding,
    width: rect.width - padding * 2 · max,
    height: rect.height - padding * 2 · max
  }

// =============================================================================
// LAYOUT TYPES
// =============================================================================

struct Layout =
  | HSplit { left: Layout, right: Layout, ratio: float }
  | VSplit { top: Layout, bottom: Layout, ratio: float }
  | Panel { id: str, title: str, border: str }
  | Empty

// =============================================================================
// SPLIT OPERATIONS
// =============================================================================

tool hsplit:
  desc: "Horizontal split (left | right)"
  @spec "Creates hsplit": ratio > 0 && ratio < 1 → result.type == "hsplit"

  left: Layout!
  right: Layout!
  ratio: float = 0.7

  → { type: "hsplit", left, right, ratio }

tool vsplit:
  desc: "Vertical split (top / bottom)"
  @spec "Creates vsplit": ratio > 0 && ratio < 1 → result.type == "vsplit"

  top: Layout!
  bottom: Layout!
  ratio: float = 0.8

  → { type: "vsplit", top, bottom, ratio }

tool panel:
  desc: "Create a panel with border"
  @spec "Creates panel": id != "" → result.type == "panel"

  id: str!
  title: str = ""
  border: str = "rounded" one_of("none", "normal", "rounded", "double", "thick")

  → { type: "panel", id, title, border }

tool empty:
  desc: "Empty layout placeholder"
  @spec "Creates empty": → result.type == "empty"

  → { type: "empty" }

// =============================================================================
// LAYOUT COMPUTATION
// =============================================================================

tool compute_layout:
  desc: "Compute rectangles for each panel in layout"
  @spec "Computes layout": layout != nil && area.width > 0 → result is list

  layout: Layout!
  area: Rect!

  → area, [] · compute_rects

compute_rects(layout: Layout, area: Rect, acc: list[{ id: str, rect: Rect }]) → list[{ id: str, rect: Rect }]:
  case layout.type:
    "hsplit" → {
      left_width = floor(area.width * layout.ratio)
      right_width = area.width - left_width

      left_area = {area..., width: left_width }
      right_area = {area..., x: area.x + left_width, width: right_width }

      left_rects = compute_rects(layout.left, left_area, [])
      right_rects = compute_rects(layout.right, right_area, [])

      [...acc, ...left_rects, ...right_rects]
    }

    "vsplit" → {
      top_height = floor(area.height * layout.ratio)
      bottom_height = area.height - top_height

      top_area = {area..., height: top_height }
      bottom_area = {area..., y: area.y + top_height, height: bottom_height }

      top_rects = compute_rects(layout.top, top_area, [])
      bottom_rects = compute_rects(layout.bottom, bottom_area, [])

      [...acc, ...top_rects, ...bottom_rects]
    }

    "panel" → [...acc, { id: layout.id, rect: area, title: layout.title, border: layout.border }]

    "empty" → acc

    _ → acc

// =============================================================================
// BORDER RENDERING
// =============================================================================

let BORDERS = const({
  "none": { tl: " ", tr: " ", bl: " ", br: " ", h: " ", v: " " },
  "normal": { tl: "┌", tr: "┐", bl: "└", br: "┘", h: "─", v: "│" },
  "rounded": { tl: "╭", tr: "╮", bl: "╰", br: "╯", h: "─", v: "│" },
  "double": { tl: "╔", tr: "╗", bl: "╚", br: "╝", h: "═", v: "║" },
  "thick": { tl: "┏", tr: "┓", bl: "┗", br: "┛", h: "━", v: "┃" }
}

tool render_border:
  desc: "Render panel border"
  @spec "Renders border": rect.width > 2 && rect.height > 2 → result.rendered == true

  rect: Rect!
  title: str = ""
  border_style: str = "rounded"
  color: str = "cyan"
  active: bool = false

  → {
    b = BORDERS[border_style]
    border_color = case active: true → "magenta" false → color

    // Top border with title
    top_line = b.tl ++ rect.width - 2, b.h · render_title_in_border + b.tr
    print_at(rect.x, rect.y, ansi.border_color · fg)

    // Side borders
    rect.height - 2 · range · each(fn(i) {
      print_at(rect.x, rect.y + i, ansi.fg(b.v, border_color))
      print_at(rect.x + rect.width - 1, rect.y + i, ansi.fg(b.v, border_color))
    }

    // Bottom border
    bottom_line = b.bl ++ repeat(b.h, rect.width - 2) + b.br
    print_at(rect.x, rect.y + rect.height - 1, ansi.border_color · fg)

    { rendered: true }
  }

render_title_in_border(title: str, width: int, border_char: str) → str:
  case title == "":
    true → width · repeat
    false → {
      title_with_space = " {title} "
      title_len = length(title_with_space)

      case title_len >= width:
        true → 0, width · substring
        false → {
          remaining = width - title_len
          left_border = 1 · repeat
          right_border = remaining - 1 · repeat
          left_border ++ title_with_space + right_border
        }
    }

// =============================================================================
// CONTENT AREA
// =============================================================================

tool content_area:
  desc: "Get content area inside panel (excluding border)"
  @spec "Gets content area": rect.width > 2 → result.width == rect.width - 2

  rect: Rect!

  → {
    x: rect.x + 1,
    y: rect.y + 1,
    width: rect.width - 2,
    height: rect.height - 2
  }

// =============================================================================
// DEFAULT LAYOUTS
// =============================================================================

tool main_layout:
  desc: "Default VIBEE terminal layout"
  @spec "Creates main layout": → result.type == "vsplit"

  → vsplit(
       top: hsplit(
         left: panel("chat", title: "Chat"),
         right: vsplit(
           top: panel("type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s", title: "type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s"),
           bottom: panel("agent", title: "Agent"),
           ratio: 0.5
         ),
         ratio: 0.7
       ),
       bottom: panel("status", title: "", border: "normal"),
       ratio: 0.92
     )

tool simple_layout:
  desc: "Simple single-panel layout"
  @spec "Creates simple layout": → result.type == "panel"

  → panel("main", title: "VIBEE Terminal")

tool split_layout:
  desc: "Two-panel split layout"
  @spec "Creates split layout": → result.type == "hsplit"

  → hsplit(
       left: panel("left", title: "Main"),
       right: panel("right", title: "Side"),
       ratio: 0.7
     )

// =============================================================================
// HELPERS
// =============================================================================

print_at(x: int, y: int, text: str) → nil:
  ffi("terminal_ffi", "move_cursor", x, y)
  ffi("terminal_ffi", "print", text)

repeat(s: str, n: int) → str:
  case n <= 0:
    true → ""
    false → s ++ n - 1 · repeat

range(start: int, end: int) → list[int]:
  case start > end:
    true → []
    false → [start, ...range(start + 1, end)]

floor(f: float) → int:
  ffi("math_ffi", "floor", f)

max(a: int, b: int) → int:
  case a > b: true → a false → b

length(s: str) → int:
  ffi("string_ffi", "length", s)

substring(s: str, start: int, end: int) → str:
  ffi("string_ffi", "substring", s, start, end)

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
