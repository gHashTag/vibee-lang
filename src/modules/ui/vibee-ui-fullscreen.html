<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VIBEE UI - Multiplatform UI Kit</title>
  <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">
  <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>
  <link href=\"https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700;800;900&display=swap\" rel=\"stylesheet\">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, sans-serif; }
    body, html { width: 100%; height: 100%; background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height, scale;
    let components = [];
    let particles = [];
    let hoveredId = null;
    let clickedId = null;
    let mouseX = 0, mouseY = 0;
    let time = 0;
    let fps = 0;
    let frameCount = 0;
    let lastFpsTime = Date.now();
    let renderTime = 0;
    let particleCount = 100;
    let showStats = true;
    // Use native browser scroll
    let scrollY = 0;
    let maxScrollY = 0;
    let carouselScrolls = {}; // {carouselId: scrollX}
    let responsiveScale = 1;
    let baseWidth = 1920; // Design width

    function resize() {
      scale = window.devicePixelRatio || 1;
      width = window.innerWidth;
      height = window.innerHeight;
      
      // Calculate responsive scale based on viewport width
      responsiveScale = width / baseWidth;
      
      console.log('Resize:', {width, height, baseWidth, responsiveScale, 
                              canvasWidth: baseWidth * scale, 
                              canvasHeight: height * scale});
      
      // Update Agent API with real viewport size
      fetch('/api/viewport', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({width, height})
      }).catch(() => {});
      
      // Adjust particle count based on screen size (reduced for performance)
      if (width < 768) {
        particleCount = 10; // Mobile
      } else if (width < 1024) {
        particleCount = 20; // Tablet
      } else {
        particleCount = 30; // Desktop
      }
      
      // Canvas internal size: viewport size × devicePixelRatio
      canvas.width = width * scale;
      canvas.height = height * scale;
      
      // Canvas CSS size: actual viewport size
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      
      // Scale context: device pixel ratio only
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(scale, scale);
      
      updateMaxScroll();
      initParticles();
    }

    async function loadUI() {
      const res = await fetch('/components');
      components = await res.json();
      updateMaxScroll();
      createHTMLInputs();
      initParticles();
      animate();
    }
    
    function createHTMLInputs() {
      // Remove Canvas rendering for inputs, create real HTML inputs instead
      const inputComponents = components.filter(c => c.type === 'input');
      
      // We'll hide Canvas inputs and show HTML overlays
      // For now, just mark them as non-interactive on Canvas
      inputComponents.forEach(input => {
        input.isHTML = true;
      });
    }

    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1,
          opacity: Math.random() * 0.5 + 0.2
        });
      }
    }

    function animate() {
      const frameStart = performance.now();
      
      time += 0.016;
      ctx.clearRect(0, 0, width, height);
      
      // FPS calculation
      frameCount++;
      const now = Date.now();
      if (now - lastFpsTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastFpsTime = now;
      }
      
      // Dark background like Aceternity
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, width, height);
      
      // Subtle gradient overlay
      const gradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height));
      gradient.addColorStop(0, 'rgba(99, 102, 241, 0.03)');
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      // Animated particles
      drawParticles();
      
      // Grid overlay
      drawGrid();
      
      // Debug info
      ctx.save();
      ctx.fillStyle = '#00ff00';
      ctx.font = '16px monospace';
      ctx.fillText(`Viewport: ${width}x${height}`, 10, 30);
      ctx.fillText(`Scale: ${responsiveScale.toFixed(2)}`, 10, 50);
      ctx.fillText(`Canvas: ${canvas.width}x${canvas.height}`, 10, 70);
      ctx.fillText(`Design: ${baseWidth}x${height}`, 10, 90);
      ctx.restore();
      
      // Save context for scaling and scrolling
      ctx.save();
      
      // Scale content FIRST to fit viewport width
      ctx.scale(responsiveScale, responsiveScale);
      
      // Then translate for scroll (in scaled space)
      ctx.translate(0, -scrollY);
      
      // Calculate viewport in design space (after scale)
      const viewportHeight = height / responsiveScale;
      
      // UI Components
      components.forEach(comp => {
        const isHovered = comp.id === hoveredId;
        const isClicked = comp.id === clickedId;
        
        // Skip rendering if outside viewport (in design space)
        const compY = comp.y || 0;
        const compHeight = comp.height || 100;
        if (compY + compHeight < scrollY || compY > scrollY + viewportHeight) {
          return;
        }
        
        // No horizontal scroll - render components as-is
        const offsetComp = comp;
        
        // Render based on component type
        switch(offsetComp.type) {
          case 'hero': drawHero(offsetComp); break;
          case 'text': drawText(offsetComp); break;
          case 'desc': drawDesc(offsetComp); break;
          case 'section': drawSection(offsetComp); break;
          case 'card3d': draw3DCard(offsetComp, isHovered, isClicked); break;
          case 'glass': drawGlassCard(offsetComp, isHovered, isClicked); break;
          case 'button': drawButton(offsetComp, isHovered, isClicked); break;
          case 'input': drawInput(offsetComp, isHovered, isClicked); break;
          case 'spotlight': drawSpotlight(offsetComp, isHovered); break;
          case 'textfx': drawTextEffect(offsetComp); break;
          case 'hover': drawHoverCard(offsetComp, isHovered); break;
          case 'bgfx': drawBackgroundEffect(offsetComp); break;
          case 'loader': drawLoader(offsetComp); break;
          case 'badge': drawBadge(offsetComp); break;
          case 'progress': drawProgress(offsetComp); break;
          case 'tooltip': drawTooltip(offsetComp, isHovered); break;
          case 'comparison': drawComparisonCard(offsetComp, isHovered); break;
          case 'footer': drawFooter(offsetComp); break;
        }
      });
      
      ctx.restore();
      
      // Cursor glow
      drawCursorGlow();
      
      // Horizontal scroll indicators
      drawScrollIndicators();
      
      // Performance stats
      if (showStats) {
        drawStats();
      }
      
      renderTime = performance.now() - frameStart;
      requestAnimationFrame(animate);
    }
    
    function drawScrollIndicators() {
      const pageMouseY = mouseY + scrollY;
      const zoneId = checkHorizontalZone(pageMouseY);
      
      if (zoneId) {
        // Show horizontal scroll indicator
        const scrollAmount = carouselScrolls[zoneId] || 0;
        const maxScroll = 1200;
        const progress = scrollAmount / maxScroll;
        
        ctx.save();
        
        // Background bar
        const barWidth = 300;
        const barHeight = 6;
        const barX = width - barWidth - 40;
        const barY = height - 40;
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Progress bar
        const progressGrad = ctx.createLinearGradient(barX, 0, barX + barWidth * progress, 0);
        progressGrad.addColorStop(0, '#6366f1');
        progressGrad.addColorStop(1, '#8b5cf6');
        ctx.fillStyle = progressGrad;
        ctx.fillRect(barX, barY, barWidth * progress, barHeight);
        
        // Label
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '12px Montserrat';
        ctx.textAlign = 'right';
        ctx.fillText('← Shift+Scroll →', barX + barWidth, barY - 8);
        
        ctx.restore();
      }
    }

    function drawStats() {
      ctx.save();
      
      // Stats panel
      const panelX = width - 220;
      const panelY = 20;
      const panelW = 200;
      const panelH = 180;
      
      // Background
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      roundRect(ctx, panelX, panelY, panelW, panelH, 10);
      ctx.fill();
      
      ctx.strokeStyle = 'rgba(100, 150, 255, 0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Text
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'left';
      
      const stats = [
        `FPS: ${fps}`,
        `Render: ${renderTime.toFixed(2)}ms`,
        `Particles: ${particleCount}`,
        `Components: ${components.length}`,
        `Resolution: ${width}x${height}`,
        `Scale: ${scale.toFixed(1)}x`,
        `Memory: ${(performance.memory?.usedJSHeapSize / 1048576 || 0).toFixed(1)}MB`
      ];
      
      stats.forEach((stat, i) => {
        ctx.fillText(stat, panelX + 15, panelY + 30 + i * 22);
      });
      
      // FPS indicator
      const fpsColor = fps >= 55 ? '#4ade80' : fps >= 30 ? '#fbbf24' : '#ef4444';
      ctx.fillStyle = fpsColor;
      ctx.beginPath();
      ctx.arc(panelX + panelW - 20, panelY + 25, 6, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    function drawParticles() {
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        
        if (p.x < 0 || p.x > width) p.vx *= -1;
        if (p.y < 0 || p.y > height) p.vy *= -1;
        
        // Connect nearby particles
        particles.forEach(p2 => {
          const dx = p.x - p2.x;
          const dy = p.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 100) {
            ctx.strokeStyle = `rgba(100, 150, 255, ${(1 - dist / 100) * 0.1})`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        });
        
        ctx.fillStyle = `rgba(150, 200, 255, ${p.opacity})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawGrid() {
      ctx.strokeStyle = 'rgba(100, 150, 255, 0.05)';
      ctx.lineWidth = 1;
      
      for (let x = 0; x < width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      for (let y = 0; y < height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }

    // ============================================================================
    // DRAWING FUNCTIONS - Aceternity UI Kit
    // ============================================================================
    
    function drawHero(hero) {
      const x = hero.x, y = hero.y, w = hero.width, h = hero.height;
      
      ctx.save();
      
      // Hero content centered
      const centerX = w / 2;
      const centerY = h / 2;
      
      // Main title with gradient
      const titleGrad = ctx.createLinearGradient(centerX - 300, centerY - 100, centerX + 300, centerY - 100);
      titleGrad.addColorStop(0, '#fff');
      titleGrad.addColorStop(0.5, '#a78bfa');
      titleGrad.addColorStop(1, '#fff');
      ctx.fillStyle = titleGrad;
      ctx.font = 'bold 96px Montserrat';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('VIBEE UI', centerX, centerY - 60);
      
      // Subtitle
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.font = '32px Montserrat';
      ctx.fillText('Beautiful components built with Canvas & BEAM', centerX, centerY + 40);
      
      // Hint
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.font = '18px Montserrat';
      ctx.fillText('Scroll to explore • Shift+Scroll for horizontal • Right-click to copy text', centerX, centerY + 100);
      
      ctx.restore();
    }
    
    function drawDesc(desc) {
      ctx.save();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.font = `${desc.size}px Montserrat`;
      ctx.textAlign = 'left';
      ctx.fillText(desc.content, desc.x, desc.y);
      ctx.restore();
    }
    
    function drawComparisonCard(card, isHovered) {
      const x = card.x, y = card.y, w = card.width, h = card.height;
      
      ctx.save();
      
      // Background with glassmorphism
      if (card.highlight) {
        const grad = ctx.createLinearGradient(x, y, x, y + h);
        grad.addColorStop(0, 'rgba(245, 158, 11, 0.15)');
        grad.addColorStop(1, 'rgba(20, 20, 30, 0.8)');
        ctx.fillStyle = grad;
      } else {
        ctx.fillStyle = 'rgba(20, 20, 30, 0.8)';
      }
      
      roundRect(ctx, x, y, w, h, 16);
      ctx.fill();
      
      // Border
      ctx.strokeStyle = card.highlight ? '#f59e0b' : 'rgba(100, 150, 255, 0.2)';
      ctx.lineWidth = 1;
      
      // Hover effect
      if (isHovered) {
        ctx.shadowColor = card.highlight ? '#fbbf24' : '#6366f1';
        ctx.shadowBlur = 20;
      }
      ctx.stroke();
      
      // Title
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px Montserrat';
      ctx.textAlign = 'left';
      ctx.fillText(card.title, x + 24, y + 50);
      
      // Badge
      if (card.badge) {
        const badgeX = x + 24 + ctx.measureText(card.title).width + 12;
        ctx.fillStyle = card.highlight ? 'rgba(245, 158, 11, 0.3)' : 'rgba(100, 150, 255, 0.2)';
        roundRect(ctx, badgeX, y + 32, 80, 24, 12);
        ctx.fill();
        
        ctx.fillStyle = card.highlight ? '#fbbf24' : '#6366f1';
        ctx.font = '11px Montserrat';
        ctx.textAlign = 'center';
        ctx.fillText(card.badge, badgeX + 40, y + 48);
      }
      
      // Description
      if (card.description) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '14px Montserrat';
        ctx.textAlign = 'left';
        ctx.fillText(card.description, x + 24, y + 80);
      }
      
      // Features list
      if (card.features) {
        card.features.forEach((feature, i) => {
          const featureY = y + 120 + (i * 40);
          
          // Icon
          const iconColor = feature.status === 'check' ? '#4ade80' :
                            feature.status === 'cross' ? '#ef4444' :
                            '#fbbf24';
          ctx.fillStyle = iconColor;
          ctx.font = '18px monospace';
          const icon = feature.status === 'check' ? '✓' :
                       feature.status === 'cross' ? '✗' : '⚠';
          ctx.fillText(icon, x + 24, featureY);
          
          // Text
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.font = '14px Montserrat';
          ctx.textAlign = 'left';
          ctx.fillText(feature.text, x + 52, featureY);
        });
      }
      
      ctx.restore();
    }
    
    function drawFooter(footer) {
      const x = footer.x, y = footer.y, w = footer.width, h = footer.height;
      
      ctx.save();
      
      // Footer background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.fillRect(x, y, w, h);
      
      // Border top
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + w, y);
      ctx.stroke();
      
      // Footer text
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.font = '16px Montserrat';
      ctx.textAlign = 'center';
      ctx.fillText('Built with Gleam & BEAM • Agent API Ready', w/2, y + h/2 - 20);
      ctx.fillText('60+ Components • 100% Canvas • No HTML/CSS', w/2, y + h/2 + 10);
      
      ctx.restore();
    }
    
    function drawText(txt) {
      ctx.save();
      
      if (txt.glow) {
        ctx.shadowColor = 'rgba(100, 150, 255, 0.8)';
        ctx.shadowBlur = 30;
      }
      
      ctx.fillStyle = '#fff';
      ctx.font = `${txt.size}px Montserrat, sans-serif`;
      ctx.textAlign = txt.align || 'left';
      ctx.fillText(txt.content, txt.x, txt.y);
      
      ctx.restore();
    }
    
    function draw3DCard(card, hovered, clicked) {
      const x = card.x, y = card.y, w = card.width, h = card.height;
      
      // Different color schemes based on card id
      const colorSchemes = {
        'card1': {bg: '#1a1a2e', accent: '#6366f1', shadow: 'rgba(99, 102, 241, 0.4)'},
        'card2': {bg: '#1e1a2e', accent: '#8b5cf6', shadow: 'rgba(139, 92, 246, 0.4)'},
        'card1b': {bg: '#1a2e2e', accent: '#10b981', shadow: 'rgba(16, 185, 129, 0.4)'},
        'card2b': {bg: '#2e1a1a', accent: '#ef4444', shadow: 'rgba(239, 68, 68, 0.4)'},
        'grid1': {bg: '#1a1a2e', accent: '#6366f1', shadow: 'rgba(99, 102, 241, 0.4)'},
        'grid2': {bg: '#2e1a1e', accent: '#ec4899', shadow: 'rgba(236, 72, 153, 0.4)'},
        'grid3': {bg: '#1a2e1e', accent: '#10b981', shadow: 'rgba(16, 185, 129, 0.4)'},
        'grid4': {bg: '#2e2a1a', accent: '#f59e0b', shadow: 'rgba(245, 158, 11, 0.4)'}
      };
      
      const scheme = colorSchemes[card.id] || {bg: '#18181b', accent: '#6366f1', shadow: 'rgba(99, 102, 241, 0.4)'};
      
      // Calculate tilt based on mouse position when hovered
      let tiltX = 0, tiltY = 0;
      if (hovered) {
        const centerX = x + w/2;
        const centerY = y + h/2;
        tiltX = ((mouseX - centerX) / w) * 10;
        tiltY = ((mouseY + scrollY - centerY) / h) * 10;
      }
      
      const lift = hovered ? -15 : 0;
      
      ctx.save();
      ctx.translate(x + w/2, y + h/2 + lift);
      ctx.rotate((tiltX * Math.PI) / 180);
      ctx.translate(-w/2, -h/2);
      
      // Shadow
      if (hovered) {
        ctx.shadowColor = scheme.shadow;
        ctx.shadowBlur = 60;
        ctx.shadowOffsetY = 30;
      }
      
      // Card background with gradient
      const gradient = ctx.createLinearGradient(0, 0, w, h);
      gradient.addColorStop(0, scheme.bg);
      gradient.addColorStop(1, scheme.bg + 'dd');
      ctx.fillStyle = gradient;
      roundRect(ctx, 0, 0, w, h, 24);
      ctx.fill();
      
      // Accent border
      ctx.strokeStyle = scheme.accent + '40';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Top accent line
      const accentGrad = ctx.createLinearGradient(0, 0, w, 0);
      accentGrad.addColorStop(0, 'transparent');
      accentGrad.addColorStop(0.5, scheme.accent);
      accentGrad.addColorStop(1, 'transparent');
      ctx.strokeStyle = accentGrad;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(20, 0);
      ctx.lineTo(w - 20, 0);
      ctx.stroke();
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      // Content with proper spacing
      if (card.title) {
        // Title with gradient
        const titleGrad = ctx.createLinearGradient(40, 60, 40 + 200, 60);
        titleGrad.addColorStop(0, '#fff');
        titleGrad.addColorStop(1, scheme.accent);
        ctx.fillStyle = titleGrad;
        ctx.font = 'bold 28px Montserrat';
        ctx.textAlign = 'left';
        
        // Wrap text if needed
        const words = card.title.split(' ');
        let line = '';
        let yPos = 60;
        words.forEach(word => {
          const testLine = line + word + ' ';
          const metrics = ctx.measureText(testLine);
          if (metrics.width > w - 80 && line !== '') {
            ctx.fillText(line, 40, yPos);
            line = word + ' ';
            yPos += 40;
          } else {
            line = testLine;
          }
        });
        ctx.fillText(line, 40, yPos);
      }
      
      if (card.content) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '16px Montserrat';
        ctx.fillText(card.content, 40, h - 60);
      }
      
      // Hover glow
      if (hovered) {
        ctx.fillStyle = scheme.accent + '15';
        roundRect(ctx, 0, 0, w, h, 24);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    function drawGlassCard(card, hovered, clicked) {
      const x = card.x, y = card.y, w = card.width, h = card.height;
      const offset = clicked ? 4 : hovered ? -4 : 0;
      
      // Different glass styles based on card id
      const glassStyles = {
        'glass1': {
          bg: 'rgba(99, 102, 241, 0.1)',
          border: ['rgba(99, 102, 241, 0.6)', 'rgba(139, 92, 246, 0.6)'],
          glow: 'rgba(99, 102, 241, 0.5)'
        },
        'glass2': {
          bg: 'rgba(236, 72, 153, 0.1)',
          border: ['rgba(236, 72, 153, 0.6)', 'rgba(249, 115, 22, 0.6)'],
          glow: 'rgba(236, 72, 153, 0.5)'
        },
        'glass3': {
          bg: 'rgba(16, 185, 129, 0.1)',
          border: ['rgba(16, 185, 129, 0.6)', 'rgba(59, 130, 246, 0.6)'],
          glow: 'rgba(16, 185, 129, 0.5)'
        },
        'grid5': {
          bg: 'rgba(139, 92, 246, 0.1)',
          border: ['rgba(139, 92, 246, 0.6)', 'rgba(236, 72, 153, 0.6)'],
          glow: 'rgba(139, 92, 246, 0.5)'
        },
        'grid6': {
          bg: 'rgba(245, 158, 11, 0.1)',
          border: ['rgba(245, 158, 11, 0.6)', 'rgba(239, 68, 68, 0.6)'],
          glow: 'rgba(245, 158, 11, 0.5)'
        },
        'grid7': {
          bg: 'rgba(59, 130, 246, 0.1)',
          border: ['rgba(59, 130, 246, 0.6)', 'rgba(99, 102, 241, 0.6)'],
          glow: 'rgba(59, 130, 246, 0.5)'
        },
        'grid8': {
          bg: 'rgba(239, 68, 68, 0.1)',
          border: ['rgba(239, 68, 68, 0.6)', 'rgba(236, 72, 153, 0.6)'],
          glow: 'rgba(239, 68, 68, 0.5)'
        }
      };
      
      const style = glassStyles[card.id] || {
        bg: 'rgba(255, 255, 255, 0.1)',
        border: ['rgba(100, 150, 255, 0.5)', 'rgba(150, 100, 255, 0.5)'],
        glow: 'rgba(100, 150, 255, 0.5)'
      };
      
      ctx.save();
      ctx.translate(0, offset);
      
      // Glow effect
      if (hovered) {
        ctx.shadowColor = style.glow;
        ctx.shadowBlur = 40;
      }
      
      // Glassmorphism background with color
      ctx.fillStyle = style.bg;
      roundRect(ctx, x, y, w, h, 20);
      ctx.fill();
      
      // Inner glow layer
      ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      roundRect(ctx, x + 2, y + 2, w - 4, h - 4, 18);
      ctx.fill();
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      // Animated border gradient
      const borderGradient = ctx.createLinearGradient(x, y, x + w, y + h);
      const hue = (time * 30) % 360;
      borderGradient.addColorStop(0, style.border[0]);
      borderGradient.addColorStop(0.5, style.border[1]);
      borderGradient.addColorStop(1, style.border[0]);
      ctx.strokeStyle = borderGradient;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Shine effect on top
      const shineGradient = ctx.createLinearGradient(x, y, x, y + h/3);
      shineGradient.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
      shineGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = shineGradient;
      roundRect(ctx, x, y, w, h/3, 20);
      ctx.fill();
      
      // Title and content
      if (card.title) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Montserrat';
        ctx.textAlign = 'left';
        ctx.fillText(card.title, x + 30, y + 60);
      }
      
      if (card.content) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '16px Montserrat';
        ctx.textAlign = 'left';
        
        // Wrap text
        const maxWidth = w - 60;
        const words = card.content.split(' ');
        let line = '';
        let yPos = y + 100;
        words.forEach(word => {
          const testLine = line + word + ' ';
          const metrics = ctx.measureText(testLine);
          if (metrics.width > maxWidth && line !== '') {
            ctx.fillText(line, x + 30, yPos);
            line = word + ' ';
            yPos += 24;
          } else {
            line = testLine;
          }
        });
        ctx.fillText(line, x + 30, yPos);
      }
      
      ctx.restore();
    }

    function drawButton(btn, hovered, clicked) {
      const x = btn.x, y = btn.y, w = btn.width, h = btn.height;
      const variant = btn.variant || 'gradient';
      const scale = clicked ? 0.95 : hovered ? 1.05 : 1;
      
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.scale(scale, scale);
      ctx.translate(-w/2, -h/2);
      
      switch(variant) {
        case 'gradient':
          const grad1 = ctx.createLinearGradient(0, 0, w, h);
          grad1.addColorStop(0, '#6366f1');
          grad1.addColorStop(1, '#8b5cf6');
          ctx.fillStyle = grad1;
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.fill();
          break;
          
        case 'glow':
          ctx.shadowColor = '#3b82f6';
          ctx.shadowBlur = hovered ? 30 : 15;
          ctx.fillStyle = '#3b82f6';
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.fill();
          ctx.shadowBlur = 0;
          break;
          
        case 'border':
          ctx.strokeStyle = `hsl(${(time * 50) % 360}, 70%, 60%)`;
          ctx.lineWidth = 2;
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.stroke();
          ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
          ctx.fill();
          break;
          
        case 'shimmer':
          const shimmer = ctx.createLinearGradient(
            -w + (time * 100) % (w * 2), 0,
            (time * 100) % (w * 2), 0
          );
          shimmer.addColorStop(0, '#ec4899');
          shimmer.addColorStop(0.5, '#f97316');
          shimmer.addColorStop(1, '#ec4899');
          ctx.fillStyle = shimmer;
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.fill();
          break;
          
        case 'ripple':
          const ripple = Math.sin(time * 3) * 0.5 + 0.5;
          ctx.shadowColor = '#10b981';
          ctx.shadowBlur = 20 + ripple * 20;
          ctx.fillStyle = '#10b981';
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.fill();
          ctx.shadowBlur = 0;
          break;
          
        case 'pulse':
          const pulse = Math.sin(time * 4) * 0.3 + 0.7;
          ctx.globalAlpha = pulse;
          ctx.fillStyle = '#f59e0b';
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.fill();
          ctx.globalAlpha = 1;
          break;
          
        case 'neon':
          ctx.shadowColor = '#ef4444';
          ctx.shadowBlur = 25;
          ctx.strokeStyle = '#ef4444';
          ctx.lineWidth = 3;
          roundRect(ctx, 0, 0, w, h, 12);
          ctx.stroke();
          ctx.shadowBlur = 0;
          break;
      }
      
      // Text
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Montserrat';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(btn.text, w/2, h/2);
      
      ctx.restore();
    }

    function drawSection(section) {
      ctx.save();
      
      // Section title - large and bold
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${section.size}px Montserrat`;
      ctx.textAlign = 'left';
      ctx.fillText(section.content, section.x, section.y);
      
      ctx.restore();
    }

    function drawInput(input, hovered, clicked) {
      const x = input.x, y = input.y, w = input.width, h = input.height;
      
      ctx.save();
      
      // Background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      roundRect(ctx, x, y, w, h, 12);
      ctx.fill();
      
      // Border with glow on hover
      if (hovered) {
        ctx.shadowColor = 'rgba(99, 102, 241, 0.6)';
        ctx.shadowBlur = 20;
      }
      
      const borderGradient = ctx.createLinearGradient(x, y, x + w, y);
      borderGradient.addColorStop(0, `rgba(99, 102, 241, ${hovered ? 0.8 : 0.3})`);
      borderGradient.addColorStop(1, `rgba(139, 92, 246, ${hovered ? 0.8 : 0.3})`);
      ctx.strokeStyle = borderGradient;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      // Placeholder text
      ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.font = '16px Montserrat';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(input.placeholder, x + 20, y + h/2);
      
      // Note about interactivity
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.font = '12px Montserrat';
      ctx.fillText('(Canvas demo - not interactive)', x + 20, y + h/2 + 25);
      
      ctx.restore();
    }

    function drawSpotlight(card, hovered) {
      const x = card.x, y = card.y, w = card.width, h = card.height;
      
      // Different spotlight colors
      const spotlightColors = {
        'spot1': {bg: 'rgba(20, 20, 40, 0.8)', spot: 'rgba(99, 102, 241, 0.4)', border: 'rgba(99, 102, 241, 0.4)'},
        'spot2': {bg: 'rgba(40, 20, 40, 0.8)', spot: 'rgba(236, 72, 153, 0.4)', border: 'rgba(236, 72, 153, 0.4)'},
        'spot3': {bg: 'rgba(20, 40, 40, 0.8)', spot: 'rgba(16, 185, 129, 0.4)', border: 'rgba(16, 185, 129, 0.4)'},
        'spot4': {bg: 'rgba(40, 30, 20, 0.8)', spot: 'rgba(245, 158, 11, 0.4)', border: 'rgba(245, 158, 11, 0.4)'},
        'spot5': {bg: 'rgba(30, 20, 40, 0.8)', spot: 'rgba(139, 92, 246, 0.4)', border: 'rgba(139, 92, 246, 0.4)'}
      };
      
      const colors = spotlightColors[card.id] || {
        bg: 'rgba(20, 20, 40, 0.8)',
        spot: 'rgba(100, 150, 255, 0.3)',
        border: 'rgba(100, 150, 255, 0.3)'
      };
      
      ctx.save();
      
      // Card background
      ctx.fillStyle = colors.bg;
      roundRect(ctx, x, y, w, h, 20);
      ctx.fill();
      
      // Spotlight effect following mouse
      if (hovered) {
        // Calculate spotlight position relative to card
        const spotX = x + (mouseX - x);
        const spotY = y + (mouseY - y);
        
        // Clamp spotlight to card bounds
        const clampedX = Math.max(x, Math.min(spotX, x + w));
        const clampedY = Math.max(y, Math.min(spotY, y + h));
        
        const gradient = ctx.createRadialGradient(clampedX, clampedY, 0, clampedX, clampedY, 200);
        gradient.addColorStop(0, colors.spot);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        roundRect(ctx, x, y, w, h, 20);
        ctx.fill();
      }
      
      // Border with glow
      ctx.strokeStyle = colors.border;
      ctx.lineWidth = 2;
      if (hovered) {
        ctx.shadowColor = colors.border;
        ctx.shadowBlur = 20;
      }
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Content
      if (card.title) {
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 22px Montserrat';
        ctx.textAlign = 'left';
        ctx.fillText(card.title, x + 30, y + 50);
      }
      
      if (card.content) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '16px Montserrat';
        const lines = card.content.split(' | ');
        lines.forEach((line, i) => {
          ctx.fillText(line, x + 30, y + 85 + i * 24);
        });
      }
      
      ctx.restore();
    }
    
    function drawTextEffect(txt) {
      const x = txt.x, y = txt.y;
      const effect = txt.effect || 'gradient';
      
      ctx.save();
      ctx.font = `bold ${txt.size}px Montserrat`;
      ctx.textAlign = 'left';
      
      switch(effect) {
        case 'gradient':
          const grad = ctx.createLinearGradient(x, y - txt.size, x + 300, y);
          grad.addColorStop(0, '#6366f1');
          grad.addColorStop(0.5, '#8b5cf6');
          grad.addColorStop(1, '#ec4899');
          ctx.fillStyle = grad;
          break;
          
        case 'glow':
          ctx.shadowColor = '#3b82f6';
          ctx.shadowBlur = 20;
          ctx.fillStyle = '#3b82f6';
          break;
          
        case 'wave':
          const offset = Math.sin(time * 2) * 5;
          ctx.translate(0, offset);
          ctx.fillStyle = '#10b981';
          break;
          
        case 'flip':
          if (Math.floor(time) % 2 === 0) {
            ctx.scale(-1, 1);
            ctx.translate(-x * 2 - 200, 0);
          }
          ctx.fillStyle = '#f59e0b';
          break;
      }
      
      ctx.fillText(txt.content, x, y);
      ctx.restore();
    }
    
    function drawHoverCard(card, hovered) {
      const x = card.x, y = card.y, w = card.width, h = card.height;
      const effect = card.effect || 'scale';
      
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      
      switch(effect) {
        case 'scale':
          const scale = hovered ? 1.1 : 1;
          ctx.scale(scale, scale);
          break;
        case 'rotate':
          const rotate = hovered ? 5 : 0;
          ctx.rotate((rotate * Math.PI) / 180);
          break;
        case 'lift':
          ctx.translate(0, hovered ? -10 : 0);
          break;
      }
      
      ctx.translate(-w/2, -h/2);
      
      // Card
      ctx.fillStyle = 'rgba(30, 30, 60, 0.8)';
      roundRect(ctx, 0, 0, w, h, 12);
      ctx.fill();
      
      if (effect === 'glow' && hovered) {
        ctx.shadowColor = '#6366f1';
        ctx.shadowBlur = 30;
        ctx.fill();
        ctx.shadowBlur = 0;
      }
      
      if (effect === 'border' && hovered) {
        ctx.strokeStyle = '#8b5cf6';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Title
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px Montserrat';
      ctx.textAlign = 'center';
      ctx.fillText(card.title, w/2, h/2);
      
      ctx.restore();
    }
    
    function drawBackgroundEffect(bg) {
      const x = bg.x, y = bg.y, w = bg.width, h = bg.height;
      const effect = bg.effect || 'gradient';
      
      ctx.save();
      
      switch(effect) {
        case 'gradient':
          const grad1 = ctx.createLinearGradient(x, y, x + w, y + h);
          const hue1 = (time * 30) % 360;
          grad1.addColorStop(0, `hsl(${hue1}, 70%, 50%)`);
          grad1.addColorStop(1, `hsl(${hue1 + 60}, 70%, 50%)`);
          ctx.fillStyle = grad1;
          break;
          
        case 'mesh':
          const grad2 = ctx.createRadialGradient(
            x + w/2 + Math.sin(time) * 50,
            y + h/2 + Math.cos(time) * 50,
            0,
            x + w/2,
            y + h/2,
            Math.max(w, h)
          );
          grad2.addColorStop(0, '#6366f1');
          grad2.addColorStop(0.5, '#8b5cf6');
          grad2.addColorStop(1, '#ec4899');
          ctx.fillStyle = grad2;
          break;
          
        case 'aurora':
          const grad3 = ctx.createLinearGradient(
            x,
            y + Math.sin(time * 0.5) * h * 0.3,
            x + w,
            y + h + Math.cos(time * 0.5) * h * 0.3
          );
          grad3.addColorStop(0, 'rgba(99, 102, 241, 0.3)');
          grad3.addColorStop(0.5, 'rgba(139, 92, 246, 0.3)');
          grad3.addColorStop(1, 'rgba(236, 72, 153, 0.3)');
          ctx.fillStyle = grad3;
          break;
      }
      
      roundRect(ctx, x, y, w, h, 16);
      ctx.fill();
      
      // Title
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px Montserrat';
      ctx.textAlign = 'center';
      ctx.fillText(bg.title, x + w/2, y + h/2);
      
      ctx.restore();
    }
    
    function drawLoader(loader) {
      const x = loader.x, y = loader.y, size = loader.size;
      const variant = loader.variant || 'spinner';
      
      ctx.save();
      ctx.translate(x, y);
      
      switch(variant) {
        case 'spinner':
          ctx.rotate(time * 3);
          ctx.strokeStyle = '#6366f1';
          ctx.lineWidth = 4;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.arc(0, 0, size/2, 0, Math.PI * 1.5);
          ctx.stroke();
          break;
          
        case 'dots':
          for (let i = 0; i < 3; i++) {
            const offset = Math.sin(time * 3 + i * 0.5) * 10;
            ctx.fillStyle = '#8b5cf6';
            ctx.beginPath();
            ctx.arc(i * 20 - 20, offset, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
          
        case 'pulse':
          const pulse = Math.sin(time * 4) * 0.3 + 0.7;
          ctx.globalAlpha = pulse;
          ctx.fillStyle = '#ec4899';
          ctx.beginPath();
          ctx.arc(0, 0, size/2, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          break;
          
        case 'bars':
          for (let i = 0; i < 4; i++) {
            const height = Math.abs(Math.sin(time * 3 + i * 0.3)) * size;
            ctx.fillStyle = '#10b981';
            ctx.fillRect(i * 12 - 18, -height/2, 8, height);
          }
          break;
          
        case 'ring':
          ctx.strokeStyle = '#f59e0b';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(0, 0, size/2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.rotate(time * 2);
          ctx.strokeStyle = '#fbbf24';
          ctx.beginPath();
          ctx.arc(0, 0, size/2, 0, Math.PI * 0.5);
          ctx.stroke();
          break;
          
        case 'orbit':
          ctx.rotate(time * 2);
          ctx.fillStyle = '#ef4444';
          ctx.beginPath();
          ctx.arc(size/2, 0, 8, 0, Math.PI * 2);
          ctx.fill();
          break;
      }
      
      ctx.restore();
    }
    
    function drawBadge(badge) {
      const x = badge.x, y = badge.y, w = badge.width, h = badge.height;
      const variant = badge.variant || 'gradient';
      
      ctx.save();
      
      switch(variant) {
        case 'gradient':
          const grad = ctx.createLinearGradient(x, y, x + w, y);
          grad.addColorStop(0, '#6366f1');
          grad.addColorStop(1, '#8b5cf6');
          ctx.fillStyle = grad;
          break;
          
        case 'glow':
          ctx.shadowColor = '#3b82f6';
          ctx.shadowBlur = 15;
          ctx.fillStyle = '#3b82f6';
          break;
          
        case 'outline':
          ctx.strokeStyle = '#8b5cf6';
          ctx.lineWidth = 2;
          ctx.fillStyle = 'rgba(139, 92, 246, 0.1)';
          break;
          
        case 'shimmer':
          const shimmer = ctx.createLinearGradient(
            x - w + (time * 50) % (w * 2), y,
            x + (time * 50) % (w * 2), y
          );
          shimmer.addColorStop(0, '#ec4899');
          shimmer.addColorStop(0.5, '#f97316');
          shimmer.addColorStop(1, '#ec4899');
          ctx.fillStyle = shimmer;
          break;
          
        case 'pulse':
          const pulse = Math.sin(time * 4) * 0.3 + 0.7;
          ctx.globalAlpha = pulse;
          ctx.fillStyle = '#f59e0b';
          break;
      }
      
      roundRect(ctx, x, y, w, h, h/2);
      ctx.fill();
      if (variant === 'outline') ctx.stroke();
      
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      
      // Text
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 12px Montserrat';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(badge.text, x + w/2, y + h/2);
      
      ctx.restore();
    }
    
    function drawProgress(prog) {
      const x = prog.x, y = prog.y, w = prog.width, h = prog.height;
      const value = prog.value || 0;
      const variant = prog.variant || 'gradient';
      
      ctx.save();
      
      // Background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      roundRect(ctx, x, y, w, h, h/2);
      ctx.fill();
      
      // Progress bar
      const progressW = (w * value) / 100;
      
      switch(variant) {
        case 'gradient':
          const grad = ctx.createLinearGradient(x, y, x + progressW, y);
          grad.addColorStop(0, '#6366f1');
          grad.addColorStop(1, '#8b5cf6');
          ctx.fillStyle = grad;
          break;
          
        case 'glow':
          ctx.shadowColor = '#3b82f6';
          ctx.shadowBlur = 10;
          ctx.fillStyle = '#3b82f6';
          break;
          
        case 'animated':
          const animGrad = ctx.createLinearGradient(
            x + (time * 50) % w, y,
            x + progressW + (time * 50) % w, y
          );
          animGrad.addColorStop(0, '#10b981');
          animGrad.addColorStop(0.5, '#34d399');
          animGrad.addColorStop(1, '#10b981');
          ctx.fillStyle = animGrad;
          break;
      }
      
      if (progressW > 0) {
        roundRect(ctx, x, y, progressW, h, h/2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    function drawTooltip(tip, hovered) {
      const x = tip.x, y = tip.y, w = tip.width, h = tip.height;
      
      ctx.save();
      
      // Button
      ctx.fillStyle = hovered ? '#6366f1' : 'rgba(99, 102, 241, 0.8)';
      roundRect(ctx, x, y, w, h, 8);
      ctx.fill();
      
      ctx.fillStyle = '#fff';
      ctx.font = '14px Montserrat';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(tip.text, x + w/2, y + h/2);
      
      // Tooltip on hover
      if (hovered && tip.tooltip) {
        const tooltipW = ctx.measureText(tip.tooltip).width + 20;
        const tooltipH = 30;
        const tooltipX = x + w/2 - tooltipW/2;
        const tooltipY = y - tooltipH - 10;
        
        // Tooltip background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        roundRect(ctx, tooltipX, tooltipY, tooltipW, tooltipH, 6);
        ctx.fill();
        
        // Tooltip text
        ctx.fillStyle = '#fff';
        ctx.font = '12px Montserrat';
        ctx.fillText(tip.tooltip, tooltipX + tooltipW/2, tooltipY + tooltipH/2);
        
        // Arrow
        ctx.beginPath();
        ctx.moveTo(x + w/2, tooltipY + tooltipH);
        ctx.lineTo(x + w/2 - 5, tooltipY + tooltipH + 5);
        ctx.lineTo(x + w/2 + 5, tooltipY + tooltipH + 5);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
    }

    function drawCursorGlow() {
      const gradient = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, 100);
      gradient.addColorStop(0, 'rgba(100, 150, 255, 0.1)');
      gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    canvas.addEventListener('mousemove', (e) => {
      // Get mouse position in design coordinates (1920px space)
      const rect = canvas.getBoundingClientRect();
      const canvasX = (e.clientX - rect.left) / responsiveScale;
      const canvasY = (e.clientY - rect.top) / responsiveScale;
      mouseX = canvasX;
      mouseY = canvasY;
      
      // Mouse position in page coordinates (accounting for scroll)
      const pageMouseY = mouseY + scrollY;
      
      let found = null;
      for (let comp of components) {
        // Check if mouse is over component (accounting for horizontal scroll)
        let compX = comp.x;
        const compY = comp.y || 0;
        
        // Apply horizontal scroll offset
        if (comp.type === 'card3d' && compY >= 960 && compY <= 1360) {
          compX += -(carouselScrolls['zone1'] || 0);
        } else if (comp.type === 'spotlight' && compY >= 1620 && compY <= 1920) {
          compX += -(carouselScrolls['zone2'] || 0);
        } else if (comp.type === 'glass' && compY >= 2540 && compY <= 2840) {
          compX += -(carouselScrolls['zone3'] || 0);
        } else if ((comp.type === 'card3d' || comp.type === 'glass') && compY >= 6240 && compY <= 6800) {
          compX += -(carouselScrolls['zone4'] || 0);
        }
        
        if (mouseX >= compX && mouseX <= compX + (comp.width || 0) &&
            pageMouseY >= compY && pageMouseY <= compY + (comp.height || 0)) {
          found = comp.id;
          break;
        }
      }
      
      if (found !== hoveredId) {
        hoveredId = found;
        canvas.style.cursor = found ? 'pointer' : 'default';
        
        // Send hover event to Agent API
        if (found) {
          fetch('/api/hover', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({element_id: found})
          }).catch(() => {});
        }
      }
    });

    canvas.addEventListener('mousedown', () => {
      clickedId = hoveredId;
    });

    canvas.addEventListener('mouseup', () => {
      if (clickedId) {
        // Send click event to Agent API
        fetch('/api/click', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            element_id: clickedId,
            position: {x: mouseX, y: mouseY}
          })
        }).catch(() => {});
      }
      clickedId = null;
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 's' || e.key === 'S') {
        showStats = !showStats;
      }
      if (e.key === 'p' || e.key === 'P') {
        particleCount = particleCount === 100 ? 200 : particleCount === 200 ? 50 : 100;
        initParticles();
      }
      
      // Copy text on Ctrl+C / Cmd+C
      if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
        if (hoveredId) {
          const comp = components.find(c => c.id === hoveredId);
          if (comp) {
            let textToCopy = '';
            if (comp.title) textToCopy += comp.title + '\n';
            if (comp.content) textToCopy += comp.content;
            if (comp.text) textToCopy = comp.text;
            
            if (textToCopy) {
              navigator.clipboard.writeText(textToCopy).then(() => {
                console.log('Copied:', textToCopy);
              });
            }
          }
        }
      }
      
      // Send key event to Agent API
      fetch('/api/key', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({key: e.key})
      }).catch(() => {});
    });
    
    // Right-click context menu for copying
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      
      if (hoveredId) {
        const comp = components.find(c => c.id === hoveredId);
        if (comp) {
          let textToCopy = '';
          if (comp.title) textToCopy += comp.title + '\n';
          if (comp.content) textToCopy += comp.content;
          if (comp.text) textToCopy = comp.text;
          
          if (textToCopy) {
            navigator.clipboard.writeText(textToCopy).then(() => {
              // Show copy notification
              const notification = document.createElement('div');
              notification.textContent = 'Copied!';
              notification.style.cssText = 'position:fixed;top:20px;right:20px;background:rgba(99,102,241,0.9);color:#fff;padding:12px 24px;border-radius:8px;font-size:14px;z-index:9999;';
              document.body.appendChild(notification);
              setTimeout(() => notification.remove(), 2000);
            });
          }
        }
      }
    });

    // Scroll handler with horizontal scroll support
    let scrollTimeout = null;
    let isHorizontalScrollZone = false;
    let currentCarouselId = null;
    
    // Define horizontal scroll zones (y ranges where horizontal scroll is active)
    const horizontalZones = [
      {start: 960, end: 1360, id: 'zone1'},  // 3D cards
      {start: 1620, end: 1920, id: 'zone2'}, // Spotlight cards
      {start: 2540, end: 2840, id: 'zone3'}, // Glass cards
      {start: 6240, end: 6800, id: 'zone4'}  // Card grid
    ];
    
    function checkHorizontalZone(y) {
      for (let zone of horizontalZones) {
        if (y >= zone.start && y <= zone.end) {
          return zone.id;
        }
      }
      return null;
    }
    
    // Vertical and horizontal scroll with carousel zones
    window.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      const pageMouseY = mouseY + scrollY;
      const zoneId = checkHorizontalZone(pageMouseY);
      
      // Check if we're in a horizontal scroll zone and user is scrolling horizontally
      if (zoneId && Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
        // Horizontal scroll in carousel zone
        const currentScroll = carouselScrolls[zoneId] || 0;
        const maxScroll = 1200;
        carouselScrolls[zoneId] = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaX * 0.8));
      } else {
        // Vertical scroll
        scrollY += e.deltaY * 0.8;
        scrollY = Math.max(0, Math.min(scrollY, maxScrollY));
      }
    }, { passive: false });

    // Calculate max scroll on load
    function updateMaxScroll() {
      if (components.length === 0) return;
      let maxY = 0;
      components.forEach(comp => {
        const compBottom = (comp.y || 0) + (comp.height || 100);
        if (compBottom > maxY) maxY = compBottom;
      });
      maxScrollY = Math.max(0, maxY - height + 100);
    }

    window.addEventListener('resize', resize);
    resize();
    loadUI();
  </script>
</body>
</html>