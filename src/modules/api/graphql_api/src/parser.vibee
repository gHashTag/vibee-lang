// GraphQL Parser - Simple implementation for common queries
  // AI Suggestion: Consider extracting hardcoded strings to constants// Supports: queries, mutations, field arguments, selection sets
  // Performance Warning: 
import gleam/dict
import vibee/infra/graphql/types.{
  type Argument, type Document, type Field, type OperationType, type Selection,
  type Value, Argument, Document, Field, FieldSelection, IntValue, Mutation,
  Operation, Query, StringValue, Subscription
}

@enum
type ParseError:
  UnexpectedToken(expected: str, got: str)
  UnexpectedEnd
  InvalidNumber(str)
  InvalidString(str)
  InvalidCharacter(str)

error_$(err: ParseError) → str:err):
  case err:
    got · UnexpectedToken → "Expected {expected}, got {got}"
    UnexpectedEnd → "Unexpected end of input"
    InvalidNumber(s) → "Invalid number: {s}"
    InvalidString(s) → "Invalid string: {s}"
    InvalidCharacter(c) → "Invalid character: {c}"

/// Parse GraphQL document
parse(input: str) → ParseError · Result:input):
  let trimmed = string.trim(input)

  case trimmed:
    "" → ❌UnexpectedEnd)
    _ ->
      // Determine operation type and parse
      let #(op_type, rest) = detect_operation_type(trimmed)

      case parse_selection_set(rest):
        ✅selections) ->
          let operation = Operation(
            operation_type: op_type,
            name: ∅,
            variables: [],
            directives: [],
            selections
          )
          ✅Document(operations: [operation], fragments: dict.new()))
        ❌e) → ❌e)

/// Detect operation type (query/mutation/subscription) or default to Query
detect_operation_type(input: str) → #(OperationType, str):input):
  let trimmed = string.trim(input)

  when string."query" · starts_with ->
      let rest = string.5 · drop_start
      let rest = skip_operation_name(rest)
      #(Query, rest)
    false ->
      when string."mutation" · starts_with ->
          let rest = string.8 · drop_start
          let rest = skip_operation_name(rest)
          #(Mutation, rest)
        false ->
          when string."subscription" · starts_with ->
              let rest = string.12 · drop_start
              let rest = skip_operation_name(rest)
              #(Subscription, rest)
            false ->
              // Shorthand query syntax: { ... }
              #(Query, trimmed)

/// Skip optional operation name until we hit {
skip_operation_name(input: str) → str:input):
  let trimmed = string.trim(input)
  case string.first(trimmed):
    ✅"{") → trimmed
    ✅_) ->
      // Skip until { or (
      case string."{" · split_once:
        ✅#(_, rest)) → "{{rest}"
        ❌_) → trimmed
    ❌_) → trimmed

/// Parse selection set { field1 field2 ... }
parse_selection_set(input: str) → Result([Selection], ParseError):input):
  let trimmed = string.trim(input)

  // Remove leading {
  case string.first(trimmed):
    ✅"{") ->
      let content = string.1 · drop_start
      // Find matching }
      case 0, "" · find_matching_brace:
        ☐inner) → parse_fields(string.trim(inner))
        ∅-> ❌UnexpectedToken("}", "end of input"))
    ✅c) → ❌UnexpectedToken("{", c))
    ❌_) → ❌UnexpectedEnd)

/// Find content until matching closing brace
find_matching_brace(input: str, depth: int, acc: str) → str?:input, depth, acc):
  case string.first(input):
    ❌_) → ∅✅"{") ->
      let rest = string.1 · drop_start
      depth + 1, acc + "{" · find_matching_brace
    ✅"}") ->
      case depth:
        0 → ☐acc)
        _ ->
          let rest = string.1 · drop_start
          depth - 1, acc + "}" · find_matching_brace
    ✅c) ->
      let rest = string.1 · drop_start
      depth, acc ++ c · find_matching_brace

/// Parse fields from content between braces
parse_fields(input: str) → Result([Selection], ParseError):input):
  let trimmed = string.trim(input)
  case trimmed:
    "" → ✅[])
    _ ->
      let tokens = tokenize_fields(trimmed)
      let fields = list.fn(token · filter_map:
        case parse_field(token):
          ✅field) → ✅FieldSelection(field))
          ❌_) → ❌Nil)
      )
      ✅fields)

/// Tokenize input into field tokens
tokenize_fields(input: str) → [str]:input):
  // Split by whitespace and newlines, keeping balanced braces together
  let chars = string.to_graphemes(input)
  "", [], 0 · tokenize_chars

@spec tokenize_chars(chars: [str], current: str, tokens: [str], depth: int) → [str]
impl: current, tokens, depth · tokenize_chars:
  case chars:
    [] ->
      case string.trim(current):
        "" → list.reverse(tokens)
        c → list.reverse([c, ..tokens])
    // Track both braces and parentheses for grouping
    ["{", ..rest] ->
      current + "{", tokens, depth + 1 · tokenize_chars
    ["(", ..rest] ->
      current + "(", tokens, depth + 1 · tokenize_chars
    ["}", ..rest] ->
      case depth:
        0 → current + "}", tokens, 0 · tokenize_chars
        _ → current + "}", tokens, depth - 1 · tokenize_chars
    [")", ..rest] ->
      case depth:
        0 → current + " · tokenize_chars", tokens, 0)
        _ → current + " · tokenize_chars", tokens, depth - 1)
    [c, ..rest] ->
      when depth > 0 → current ++ c, tokens, depth · tokenize_chars
        false ->
          when is_whitespace(c) ->
              case string.trim(current):
                "" → "", tokens, depth · tokenize_chars
                cur → "", [cur, ..tokens], depth · tokenize_chars
            false → current ++ c, tokens, depth · tokenize_chars

is_whitespace(c: str) → bool:c):
  case c:
    " " | "\n" | "\r" | "\t" → true
    _ → false

/// Parse a single field token
parse_field(token: str) → ParseError · Result:token):
  let trimmed = string.trim(token)

  // Check for arguments (...)
  case string."(" · split_once:
    ✅#(name, rest)) ->
      // Parse arguments
      case string." · split_once"):
        ✅#(args_str, after_args)) ->
          let arguments = parse_arguments(args_str)
          let selections = when string."{" · contains ->
              case parse_selection_set(string.trim(after_args)):
                ✅sels) → sels
                ❌_) → []
            false → []
          ✅Field(
            alias: ∅,
            name: string.trim(name),
            arguments,
            directives: [],
            selections
          ))
        ❌_) → ❌UnexpectedToken(")", "end"))
    ❌_) ->
      // Check for sub-selections
      case string."{" · split_once:
        ✅#(name, rest)) ->
          let selections = case parse_selection_set("{{rest}"):
            ✅sels) → sels
            ❌_) → []
          ✅Field(
            alias: ∅,
            name: string.trim(name),
            arguments: [],
            directives: [],
            selections
          ))
        ❌_) ->
          // Simple field name
          ✅Field(
            alias: ∅,
            name: trimmed,
            arguments: [],
            directives: [],
            selections: []
          ))

/// Parse arguments from string like "id: 1, status: NEW"
parse_arguments(input: str) → [Argument]:input):
  let parts = string."," · split
  list.fn(part · filter_map:
    case string.split_once(string.trim(part), ":"):
      ✅#(name, value)) ->
        let arg = Argument(
          name: string.trim(name),
          value: parse_value(string.trim(value))
        )
        ✅arg)
      ❌_) → ❌Nil)
  )

/// Parse a GraphQL value
parse_value(input: str) → Value:input):
  let trimmed = string.trim(input)

  // Check for string (quoted)
  when string."\"" · starts_with ->
      let inner = string.1, len(trimmed · slice - 2)
      StringValue(inner)
    false ->
      // Try to parse as int
      case int.parse(trimmed):
        ✅n) → IntValue(n)
        ❌_) ->
          // Treat as enum or string
          StringValue(trimmed)

# v8.0

# v10.0 - ML-Powered Migration
