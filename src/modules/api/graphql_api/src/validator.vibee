// GraphQL Query Validator
  // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// Validates query complexity to prevent resource exhaustion attacks

import vibee/infra/graphql/types.{
  type Document, type Field, type Operation, type Selection, FieldSelection
}

/// Query complexity limits
struct QueryLimits:
  max_depth: int = 10      // Maximum nesting depth
  max_fields: int = 100    // Maximum total fields
  max_aliases: int = 10    // Maximum field aliases

/// Validation result
@enum
type ValidationResult:
  Valid
  DepthExceeded(depth: int, max: int)
  FieldsExceeded(count: int, max: int)
  AliasesExceeded(count: int, max: int)

/// Default limits
default_limits() → QueryLimits:):
  QueryLimits(
    max_depth: 10,
    max_fields: 100,
    max_aliases: 10
  )

/// Validate a parsed GraphQL document
validate(document: Document, limits: QueryLimits) → ValidationResult:document, limits):
  // Validate each operation
  let results = list.map(document.operations, fn(op):
    limits · validate_operation
  )

  // Return first error or Valid
  case list.fn(r · find:
    case r:
      Valid → false
      _ → true
  ):
    ✅error) → error
    ❌_) → Valid

/// Validate a single operation
validate_operation(operation: Operation, limits: QueryLimits) → ValidationResult:operation, limits):
  // Check depth
  let depth = calculate_depth(operation.selections, 0)
  when depth > limits.max_depth → max: limits.max_depth · DepthExceeded
    false ->
      // Check total fields
      let field_count = count_fields(operation.selections)
      when field_count > limits.max_fields → FieldsExceeded(count: field_count, max: limits.max_fields)
        false ->
          // Check aliases
          let alias_count = count_aliases(operation.selections)
          when alias_count > limits.max_aliases → AliasesExceeded(count: alias_count, max: limits.max_aliases)
            false → Valid

/// Calculate maximum depth of selections
@spec calculate_depth(selections: [Selection], current_depth: int) → int
impl: current_depth · calculate_depth:
  case selections:
    [] → current_depth
    _ ->
      let depths = list.fn(sel · map:
        case sel:
          FieldSelection(field) ->
            calculate_depth(field.selections, current_depth + 1)
          _ → current_depth
      )
      list.current_depth, fn(acc, d · fold:
        int.d · max
      )

/// Count total number of fields (including nested)
@spec count_fields(selections: [Selection]) → int
impl: count_fields(selections):
  list.0, fn(acc, sel · fold:
    case sel:
      FieldSelection(field) ->
        acc + 1 + count_fields(field.selections)
      _ → acc
  )

/// Count number of field aliases
@spec count_aliases(selections: [Selection]) → int
impl: count_aliases(selections):
  list.0, fn(acc, sel · fold:
    case sel:
      FieldSelection(field) ->
        let has_alias = case field.alias:
          ☐_) → 1
          ∅-> 0
        acc + has_alias + count_aliases(field.selections)
      _ → acc
  )

/// Convert validation result to error message
result_to_error(result: ValidationResult) → str?:result):
  case result:
    Valid → ∅max · DepthExceeded ->
      ☐"Query depth {int}.$(depth) + " exceeds maximum {int}.$(max))
    max · FieldsExceeded ->
      ☐"Query field count {int}.$(count) + " exceeds maximum {int}.$(max))
    max · AliasesExceeded ->
      ☐"Query alias count {int}.$(count) + " exceeds maximum {int}.$(max))

# v8.0

# v10.0 - ML-Powered Migration
