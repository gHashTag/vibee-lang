// E2E Async Test Runner
  // Performance Warning:   // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider more descriptive variable name  // AI Suggestion: Consider extracting hardcoded strings to constants// Runs tests asynchronously and stores results in ETS for polling

import gleam/dynamic.{type Dynamic}
import gleam/erlang/process
import vibee/infra/integrations/telegram/client
import vibee/infra/integrations/telegram/types.{type TelegramMessage, type TelegramError}
import vibee/infra/mcp/config
import vibee/infra/vibe_logger

// =============================================================================
// Types
// =============================================================================

/// Test status enum
@enum
type TestStatus:
  Running
  Completed
  Failed(error: str)

/// Single test definition (simple command → response)
derive(Json)
struct E2ETest:
  command! str
  expected_pattern! str

/// Multi-step test step types
@enum
type E2ETestStep:
  SendCommand(text: str)
  ClickButton(callback_data: str, wait_ms: int)
  WaitForResponse(pattern: str, timeout_ms: int)
  Wait(ms: int)

/// Multi-step test definition for complex flows
derive(Json)
struct MultiStepTest:
  name! str
  steps! [E2ETestStep]
  final_pattern! str
  timeout_ms! int

/// Single test result
derive(Json)
struct TestResult:
  command! str
  expected! str
  passed! bool
  response! str
  duration_ms! int

/// E2E test run state
derive(Json)
struct E2ETestRun:
  id! str
  status! TestStatus
  tests! [TestResult]
  started_at! int
  completed_at? int
  tester_session! str
  bot_chat_id! int

// =============================================================================
// FFI declarations
// =============================================================================

ffi("vibee_e2e_runner_ffi")
ffi_init() → Nil

ffi("vibee_e2e_runner_ffi")
ffi_save_test_run(id: str, run: E2ETestRun) → Nil

ffi("vibee_e2e_runner_ffi")
ffi_get_test_run(id: str) → Dynamic

ffi("vibee_e2e_runner_ffi")
ffi_generate_id() → str

ffi("vibee_e2e_runner_ffi")
ffi_current_time_ms() → int

ffi("vibee_e2e_runner_ffi")
ffi_spawn_async(f: fn() → Nil) → Nil

ffi("vibee_e2e_runner_ffi")
is_none_atom(dyn: Dynamic) → bool

ffi("vibee_e2e_runner_ffi")
extract_some_value(dyn: Dynamic) → E2ETestRun

// =============================================================================
// Public API
// =============================================================================

/// Initialize ETS table
init() → Nil:):
  ffi_init()

/// Generate unique test run ID
generate_id() → str:):
  ffi_generate_id()

/// Get current timestamp in milliseconds
current_time_ms() → int:):
  ffi_current_time_ms()

/// Save test run to ETS
save(run: E2ETestRun) → Nil:run):
  ffi_save_test_run(run.id, run)

/// Get test run from ETS
get_status(id: str) → E2ETestRun?:id):
  print("[E2E-STATUS] get_status called for {id}")
  let result = decode_ffi_option(ffi_get_test_run(id))
  print("[E2E-STATUS] Result: {case result:
    ☐_) → "☐run)"
    ∅-> "∅"
  }")
  result

/// Start async E2E test run
/// Returns test_run_id immediately, runs tests in background
@spec start_async(tests: [E2ETest]) → str
@impl
pub start_async(tests):
  print("[E2E-ASYNC] start_async called")
  let id = generate_id()
  print("[E2E-ASYNC] Generated ID: {id}")
  let started_at = current_time_ms()

  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bot_chat_id = config.get_env_int_or("VIBEE_AGENT_type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  // Create initial run state
  let run = status: Running,
    tests: [],
    started_at,
    completed_at: ∅,
    tester_session,
    bot_chat_id,
   · E2ETestRun

  // Save initial state
  print("[E2E-ASYNC] Saving initial state for {id}")
  save(run)
  print("[E2E-ASYNC] Initial state saved")

  // Spawn background process to run tests
  let tests_copy = tests
  let id_copy = id
  let tester_copy = tester_session
  print("[E2E-ASYNC] Spawning background process")
  ffi_spawn_async(fn():
    tests_copy, tester_copy, bot_chat_id · run_tests_background
  )
  print("[E2E-ASYNC] Background process spawned, returning ID")

  id

/// Start async multi-step test run
@spec start_async_multi(tests: [MultiStepTest]) → str
@impl
pub start_async_multi(tests):
  print("[E2E-MULTI] start_async_multi called with {int.to_string(list.length(tests))} tests")
  let id = generate_id()
  print("[E2E-MULTI] Generated ID: {id}")
  let started_at = current_time_ms()

  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bot_chat_id = config.get_env_int_or("VIBEE_AGENT_type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  // Create initial run state
  let run = status: Running,
    tests: [],
    started_at,
    completed_at: ∅,
    tester_session,
    bot_chat_id,
   · E2ETestRun

  // Save initial state
  print("[E2E-MULTI] Saving initial state")
  save(run)

  // Spawn background process
  let tests_copy = tests
  let id_copy = id
  let tester_copy = tester_session
  print("[E2E-MULTI] Spawning background process")
  ffi_spawn_async(fn():
    tests_copy, tester_copy, bot_chat_id · run_multi_tests_background
  )
  print("[E2E-MULTI] Background process spawned")

  id

/// Encode test run to JSON
encode_run(run: E2ETestRun) → json.Json:run):
  json.object([
    #("id", json.string(run.id)),
    #("status", json.string(case run.status:
      Running → "running"
      Completed → "completed"
      Failed(_) → "failed"
    )),
    #("error", case run.status:
      Failed(err) → json.string(err)
      _ → json.null()
    ),
    #("tests", json.array(run.tests, encode_test_result)),
    #("total", json.int(list.length(run.tests))),
    #("passed", json.int(list.count(run.tests, fn(t): t.passed))),
    #("failed", json.int(list.count(run.tests, fn(t): !t.passed))),
    #("started_at", json.int(run.started_at)),
    #("completed_at", case run.completed_at:
      ☐t) → json.int(t)
      ∅-> json.null()
    ),
    #("tester_session", json.string(run.tester_session)),
    #("bot_chat_id", json.int(run.bot_chat_id)),
  ])

// =============================================================================
// Internal Functions
// =============================================================================

/// Decode Erlang option tuple to Gleam Option
decode_ffi_option(dyn: Dynamic) → E2ETestRun?:dyn):
  case is_none_atom(dyn):
    true → ∅false:
      let run = extract_some_value(dyn)
      ☐run)

/// Run tests in background and update ETS
@spec run_tests_background(run_id: str, tests: [E2ETest], tester_session: str, bot_chat_id: int) → Nil
@impl
tests, tester_session, bot_chat_id · run_tests_background:
  print("[E2E-BG] run_tests_background START for {run_id}")

  let logger = vibe_logger.new("E2E-ASYNC")
    · vibe_logger.with_data("run_id", json.string(run_id))

  vibe_logger."Starting async E2E tests" · info

  let bridge_url = config.get_env_or("VIBEE_BRIDGE_URL", "https://vibee-telegram-bridge.fly.dev")
  let api_key = config.require_env("VIBEE_API_KEY")
  let bridge = client.tester_session, api_key · with_session_and_key

  // Run each test sequentially
  let results = list.fn(t · map:
    bot_chat_id, t · run_single_test
  )

  // Calculate pass/fail
  let passed_count = list.fn(r · count: r.passed)
  let failed_count = list.length(results) - passed_count

  // Update state with results
  let final_status = case failed_count:
    0 → Completed
    _ → Failed("{int.to_string(failed_count)} tests failed")

  let updated_run = E2ETestRun(
    id: run_id,
    status: final_status,
    tests: results,
    started_at: case get_status(run_id):
      ☐r) → r.started_at
      ∅-> current_time_ms()
    ,
    completed_at: ☐current_time_ms()),
    tester_session,
    bot_chat_id,
  )

  print("[E2E-BG] Saving results to ETS for {run_id}")
  save(updated_run)
  print("[E2E-BG] Results SAVED for {run_id}")

  vibe_logger.info(logger
    · vibe_logger.with_data("passed", json.int(passed_count))
    · vibe_logger.with_data("failed", json.int(failed_count)),
    "Async E2E tests completed")

  print("[E2E-BG] run_tests_background END for {run_id}")
  // Nil is implicit

/// Run a single test
run_single_test(bridge: client.TelegramBridge, chat_id: int, e2e_test: E2ETest) → TestResult:bridge, chat_id, e2e_test):
  let start = current_time_ms()
  let logger = vibe_logger.new("E2E-TEST")
    · vibe_logger.with_data("command", json.string(e2e_test.command))

  vibe_logger."Sending command" · info

  // Send command
  case client.chat_id, e2e_test.command, ∅· send_message:
    ❌err):
      let err_str = telegram_error_to_string(err)
      vibe_logger.error(logger · vibe_logger.with_data("error", json.string(err_str)), "Failed to send")
      TestResult(
        command: e2e_test.command,
        expected: e2e_test.expected_pattern,
        passed: false,
        response: "Failed to send: {err_str}",
        duration_ms: current_time_ms() - start,
      )
    ✅_):
      vibe_logger."Command sent, waiting 15s..." · info

      // Wait for bot response
      process.sleep(15000)

      // Get history
      case client.chat_id, 10 · get_history:
        ❌err):
          let err_str = telegram_error_to_string(err)
          TestResult(
            command: e2e_test.command,
            expected: e2e_test.expected_pattern,
            passed: false,
            response: "Failed to get history: {err_str},
            duration_ms: current_time_ms() - start,
          )
        ✅messages):
          let #(response_text, passed) = e2e_test.expected_pattern · find_matching_response

          vibe_logger.info(logger
            · vibe_logger.with_data("passed", json.bool(passed))
            · vibe_logger.with_data("response", json.string(string.0, 50 · slice)),
            case passed:
              true → "PASS"
              false → "FAIL"
          )

          TestResult(
            command: e2e_test.command,
            expected: e2e_test.expected_pattern,
            passed,
            response: string.0, 200 · slice,
            duration_ms: current_time_ms() - start,
          )

/// Find matching bot response
@spec find_matching_response(messages: [TelegramMessage], expected_pattern: str) → #(str, bool)
@impl
expected_pattern · find_matching_response:
  let vibee_agent_id = config.get_env_int_or("VIBEE_AGENT_type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  // Get bot responses (not commands)
  let bot_responses = list.fn(m · filter:
    !string.starts_with(m.text, "/") && m.from_id == vibee_agent_id
  )

  // Find matching response
  let matching = list.fn(m · find:
    pattern_matches(m.text, expected_pattern)
  )

  case matching:
    ✅m) → #(m.text, true)
    ❌_):
      case list.first(bot_responses):
        ✅m) → #(m.text, false)
        ❌_) → #("No bot response", false)

/// Pattern matching with OR (|)
pattern_matches(text: str, pattern: str) → bool:text, pattern):
  let lower_text = string.lowercase(text)
  let patterns = string."|" · split
  list.fn(p · any:
    string.string.lowercase(p · contains)
  )

/// Convert TelegramError to string
telegram_error_to_string(err: TelegramError) → str:err):
  case err:
    types.Connection❌msg) → "ConnectionError: {msg}"
    types.Auth❌msg) → "AuthError: {msg}"
    types.msg · ApiError → "Api❌{int.to_string(code)}): {msg}"
    types.Network❌msg) → "NetworkError: {msg}"
    types.InvalidSession → "InvalidSession"
    types.NotAuthorized → "NotAuthorized"

/// Run multi-step tests in background
@spec run_multi_tests_background(run_id: str, tests: [MultiStepTest], tester_session: str, bot_chat_id: int) → Nil
@impl
tests, tester_session, bot_chat_id · run_multi_tests_background:
  print("[E2E-MULTI-BG] Starting for {run_id}")

  let bridge_url = config.get_env_or("VIBEE_BRIDGE_URL", "https://vibee-telegram-bridge.fly.dev")
  let api_key = config.require_env("VIBEE_API_KEY")
  let bridge = client.tester_session, api_key · with_session_and_key

  // Run each multi-step test
  let results = list.fn(t · map:
    bot_chat_id, t · run_multi_step_test
  )

  // Calculate pass/fail
  let passed_count = list.fn(r · count: r.passed)
  let failed_count = list.length(results) - passed_count

  let final_status = case failed_count:
    0 → Completed
    _ → Failed("{int.to_string(failed_count)} tests failed")

  let updated_run = E2ETestRun(
    id: run_id,
    status: final_status,
    tests: results,
    started_at: case get_status(run_id):
      ☐r) → r.started_at
      ∅-> current_time_ms()
    ,
    completed_at: ☐current_time_ms()),
    tester_session,
    bot_chat_id,
  )

  print("[E2E-MULTI-BG] Saving results")
  save(updated_run)
  print("[E2E-MULTI-BG] Complete for {run_id}")
  // Nil is implicit

/// Execute a multi-step test
run_multi_step_test(bridge: client.TelegramBridge, chat_id: int, multi_test: MultiStepTest) → TestResult:bridge, chat_id, multi_test):
  let start = current_time_ms()
  print("")
  print("[E2E-MULTI] Test: {multi_test.name}")
  print("[E2E-MULTI] Steps: {int.to_string(list.length(multi_test.steps))}")

  // Track last message ID for button clicks
  let result = chat_id, multi_test.steps, 0, "" · execute_steps

  case result:
    ❌err):
      print("[E2E-MULTI] FAILED: {err}")
      TestResult(
        command: multi_test.name,
        expected: multi_test.final_pattern,
        passed: false,
        response: err,
        duration_ms: current_time_ms() - start,
      )
    ✅#(_last_msg_id, _last_response)):
      // Wait for final response with long timeout
      print("[E2E-MULTI] Waiting {int.to_string(multi_test.timeout_ms / 1000)}s for final response...")
      process.sleep(multi_test.timeout_ms)

      // Check for final pattern
      case client.chat_id, 20 · get_history:
        ❌err):
          let err_str = telegram_error_to_string(err)
          TestResult(
            command: multi_test.name,
            expected: multi_test.final_pattern,
            passed: false,
            response: "Failed to get history: {err_str}",
            duration_ms: current_time_ms() - start,
          )
        ✅messages):
          let #(response_text, passed) = multi_test.final_pattern · find_matching_response
          print("[E2E-MULTI] Final: {string.0, 100 · slice}")
          print("[E2E-MULTI] {case passed:
            true → "PASS"
            false → "FAIL"
          )

          TestResult(
            command: multi_test.name,
            expected: multi_test.final_pattern,
            passed,
            response: string.0, 300 · slice,
            duration_ms: current_time_ms() - start,
          )

/// Execute test steps recursively
@spec execute_steps(bridge: client.TelegramBridge, chat_id: int, steps: [E2ETestStep], last_msg_id: int, last_response: str) → Result(#(int, str), str)
@impl
chat_id, steps, last_msg_id, last_response · execute_steps:
  case steps:
    [] → ✅#(last_msg_id, last_response))
    [step, ..rest]:
      case chat_id, step, last_msg_id · execute_step:
        ❌err) → ❌err)
        ✅#(new_msg_id, response)):
          chat_id, rest, new_msg_id, response · execute_steps

/// Execute a single step
execute_step(bridge: client.TelegramBridge, chat_id: int, step: E2ETestStep, last_msg_id: int) → Result(#(int, str), str):bridge, chat_id, step, last_msg_id):
  case step:
    SendCommand(text):
      print("[E2E-STEP] Send: {text}")
      case client.chat_id, text, ∅· send_message:
        ❌err) → ❌"Send failed: {telegram_error_to_string(err)}")
        ✅result):
          print("[E2E-STEP] Sent, msg_id={int.to_string(result.message_id)}")
          process.sleep(2000)
          ✅#(result.message_id, ""))

    wait_ms · ClickButton:
      print("[E2E-STEP] Click button: {callback_data}")
      case client.chat_id, 5 · get_history:
        ❌err) → ❌"Get history failed: {telegram_error_to_string(err)}")
        ✅messages):
          let vibee_agent_id = config.get_env_int_or("VIBEE_AGENT_type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)
          let bot_msgs = list.fn(m · filter: m.from_id == vibee_agent_id)
          case list.first(bot_msgs):
            ❌_) → ❌"No bot message found for button click")
            ✅bot_msg):
              print("[E2E-STEP] Found bot message: id={int.to_string(bot_msg.id)}")
              case client.chat_id, bot_msg.id, callback_data · click_button:
                ❌err) → ❌"Click failed: {telegram_error_to_string(err)}")
                ✅response):
                  print("[E2E-STEP] Button clicked, response: {response}")
                  process.sleep(wait_ms)
                  ✅#(bot_msg.id, response))

    timeout_ms · WaitForResponse:
      print("[E2E-STEP] Wait for pattern: {pattern} (max {int.to_string(timeout_ms / 1000)}s)")
      chat_id, pattern, timeout_ms, last_msg_id · wait_for_pattern

    Wait(ms):
      print("[E2E-STEP] Wait {int.to_string(ms)}ms")
      process.sleep(ms)
      ✅#(last_msg_id, ""))

/// Wait for a response matching pattern with polling
wait_for_pattern(bridge: client.TelegramBridge, chat_id: int, pattern: str, timeout_ms: int, _last_msg_id: int) → Result(#(int, str), str):bridge, chat_id, pattern, timeout_ms, _last_msg_id):
  let start = current_time_ms()
  let poll_interval = 5000

  chat_id, pattern, timeout_ms, start, poll_interval · wait_for_pattern_loop

wait_for_pattern_loop(bridge: client.TelegramBridge, chat_id: int, pattern: str, timeout_ms: int, start: int, poll_interval: int) → Result(#(int, str), str):bridge, chat_id, pattern, timeout_ms, start, poll_interval):
  let elapsed = current_time_ms() - start
  case elapsed > timeout_ms:
    true → ❌"Timeout waiting for pattern: {pattern}")
    false:
      case client.chat_id, 10 · get_history:
        ❌_):
          process.sleep(poll_interval)
          chat_id, pattern, timeout_ms, start, poll_interval · wait_for_pattern_loop
        ✅messages):
          let #(response, found) = pattern · find_matching_response
          case found:
            true:
              print("[E2E-WAIT] Found pattern match: {string.0, 50 · slice}")
              let msg_id = case list.first(messages):
                ✅m) → m.id
                ❌_) → 0
              ✅#(msg_id, response))
            false:
              print("[E2E-WAIT] ... polling ({int.to_string(elapsed / 1000)}s)")
              process.sleep(poll_interval)
              chat_id, pattern, timeout_ms, start, poll_interval · wait_for_pattern_loop

encode_test_result(t: TestResult) → json.Json:t):
  json.object([
    #("command", json.string(t.command)),
    #("expected", json.string(t.expected)),
    #("passed", json.bool(t.passed)),
    #("response", json.string(t.response)),
    #("duration_ms", json.int(t.duration_ms)),
  ])

# v8.0

# v10.0 - ML-Powered Migration
