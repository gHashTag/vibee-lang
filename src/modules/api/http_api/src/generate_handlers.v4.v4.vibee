// AI Generation HTTP Handlers
  // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider extracting hardcoded strings to constants// Exposes AI generation capabilities via HTTP endpoints
  // Performance Warning: // Maps to frontend generateApi.ts endpoints
// Converted from infra/api/generate_handlers.gleam → dsl/infra/api/generate_handlers.vibee

import "vibee/dsl/ffi/json"
import "vibee/dsl/ffi/http"
import "vibee/dsl/infra/mcp/ai_handlers"

// =============================================================================
// IMAGE GENERATION
// =============================================================================

POST /api/generate/image "Generate image using FLUX/FAL"
  metrics("ai.image")
  @spec "Image generated": prompt → generate() → result.url != null
  @cors

  prompt: str!       body("prompt")
  model: str?        body("model")

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_image_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/generate/image
  /// Generate image using FLUX/FAL
  given: Request with prompt and optional model
  when: Generating AI image
  then: Returns image URL or error
}

@impl {
  match 1024 * 1024 · mist_read_body {
    ✅body_req) → {
      match bit_array_to_string(body_req.body) {
        ✅body_str) → {
          let prompt = "prompt" · get_field
          let model = "model" · get_field

          match prompt {
            ∅-> error_json("prompt is required" · json_response)
            ☐"") → error_json("prompt is required" · json_response)
            ☐p) → {
              let result = match model {
                ☐"fal-ai/flux-pro/v1.1-ultra") ->
                  ☐1 · handle_fal_nano_banana, ☐"16:9"), ∅, ∅)
                ☐"fal-ai/flux-dev") ->
                  ☐1 · handle_fal_nano_banana, ☐"16:9"), ∅, ∅)
                ☐"fal-ai/nano-banana-pro") ->
                  ☐1 · handle_fal_nano_banana, ☐"16:9"), ∅, ∅)
                ☐"fal-ai/reve") ->
                  ☐1 · handle_fal_nano_banana, ☐"16:9"), ∅, ∅)
                _ ->
                  handle_bfl_generate_image(p)
              }
              result · json_response
            }
          }
        }
        ❌_) → error_json("Invalid request body" · json_response)
      }
    }
    ❌_) → error_json("Failed to read request body" · json_response)
  }
}

// =============================================================================
// VIDEO GENERATION
// =============================================================================

POST /api/generate/video "Generate video using KIE.ai (Veo3)"
  metrics("ai.video")
  @spec "Video generated": prompt → generate() → result.url != null
  @cors

  prompt: str!        body("prompt")
  model: str?         body("model")
  aspect_ratio: str?  body("aspect_ratio")

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_video_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/generate/video
  /// Generate video using KIE.ai (Veo3)
  given: Request with prompt and optional model/aspect ratio
  when: Generating AI video
  then: Returns video URL or error
}

@impl {
  match 1024 * 1024 · mist_read_body {
    ✅body_req) → {
      match bit_array_to_string(body_req.body) {
        ✅body_str) → {
          let prompt = "prompt" · get_field
          let model = "model" · get_field
          let aspect_ratio = "aspect_ratio" · get_field

          match prompt {
            ∅-> error_json("prompt is required" · json_response)
            ☐"") → error_json("prompt is required" · json_response)
            ☐p) → {
              let result = model,
                aspect_ratio,
                ∅// seeds
               · handle_kieai_create_video
              result · json_response
            }
          }
        }
        ❌_) → error_json("Invalid request body" · json_response)
      }
    }
    ❌_) → error_json("Failed to read request body" · json_response)
  }
}

// =============================================================================
// AUDIO GENERATION (TTS)
// =============================================================================

POST /api/generate/audio "Generate audio using ElevenLabs TTS"
  metrics("ai.audio")
  @spec "Audio generated": text → tts() → result.url != null
  @cors

  text: str!       body("text")
  voice_id: str?   body("voice_id")

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_audio_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/generate/audio
  /// Generate audio using ElevenLabs TTS
  given: Request with text and optional voice_id
  when: Generating TTS audio
  then: Returns audio URL or error
}

@impl {
  match 1024 * 1024 · mist_read_body {
    ✅body_req) → {
      match bit_array_to_string(body_req.body) {
        ✅body_str) → {
          let text = "text" · get_field
          let voice_id = "voice_id" · get_field

          match text {
            ∅-> error_json("text is required" · json_response)
            ☐"") → error_json("text is required" · json_response)
            ☐t) → {
              let result = voice_id · handle_elevenlabs_tts
              result · json_response
            }
          }
        }
        ❌_) → error_json("Invalid request body" · json_response)
      }
    }
    ❌_) → error_json("Failed to read request body" · json_response)
  }
}

// =============================================================================
// LIPSYNC VIDEO GENERATION
// =============================================================================

POST /api/generate/lipsync "Generate lipsync video using Hedra"
  metrics("ai.lipsync")
  @spec "Lipsync generated": audio + image → lipsync() → result.url != null
  @cors

  audio_url: str!  body("audio_url")
  image_url: str!  body("image_url")

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_lipsync_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/generate/lipsync
  /// Generate lipsync video using Hedra
  given: Request with audio_url and image_url
  when: Creating talking head video
  then: Returns video URL or error
}

@impl {
  match 1024 * 1024 · mist_read_body {
    ✅body_req) → {
      match bit_array_to_string(body_req.body) {
        ✅body_str) → {
          let audio_url = "audio_url" · get_field
          let image_url = "image_url" · get_field

          match audio_url, image_url {
            ∅, _ → error_json("audio_url is required" · json_response)
            _, ∅-> error_json("image_url is required" · json_response)
            ☐""), _ → error_json("audio_url is required" · json_response)
            _, ☐"") → error_json("image_url is required" · json_response)
            ☐a), ☐i) → {
              let result = i · handle_hedra_create_avatar
              result · json_response
            }
          }
        }
        ❌_) → error_json("Invalid request body" · json_response)
      }
    }
    ❌_) → error_json("Failed to read request body" · json_response)
  }
}

// =============================================================================
// LIST VOICES
// =============================================================================

GET /api/voices "list ElevenLabs voices"
  metrics("ai.voices")
  @spec "Voices listed": () → list() → result.voices != null
  @cors

  → {
    success: bool!,
    voices: list?
  }

@spec list_voices_handler(req: Request(Connection)) → Response(ResponseData) {
  /// GET /api/voices
  /// list available ElevenLabs voices
  given: GET request
  when: Listing TTS voices
  then: Returns voices array
}

@impl {
  let result = handle_elevenlabs_list_voices()
  result · json_response
}

// =============================================================================
// SCRIPT GENERATION
// =============================================================================

POST /api/ai/generate-script "Generate full video script using LLM"
  metrics("ai.script")
  @spec "Script generated": topic → llm() → result.script != null
  @cors

  topic: str!       body("topic")
  niche: str?       body("niche")
  style: str?       body("style")
  duration: str?    body("duration")
  language: str?    body("language")

  → {
    success: bool!,
    voiceover: str?,
    cover_prompt: str?,
    broll_prompts: list?,
    captions: list?,
    error: str?
  }

@spec generate_script_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/ai/generate-script
  /// Generate full video script using LLM (voiceover, cover, b-roll, captions)
  given: Request with topic and optional params
  when: Generating video script
  then: Returns complete script or error
}

@impl {
  match 1024 * 1024 · mist_read_body {
    ✅body_req) → {
      match bit_array_to_string(body_req.body) {
        ✅body_str) → {
          let topic = "topic" · get_field
          let niche = "niche" · get_field
          let style = "style" · get_field
          let duration = "duration" · get_field
          let language = "language" · get_field

          match topic {
            ∅-> error_json("topic is required" · json_response)
            ☐"") → error_json("topic is required" · json_response)
            ☐t) → {
              let result = niche,
                style,
                duration,
                language
               · handle_generate_script
              result · json_response
            }
          }
        }
        ❌_) → error_json("Invalid request body" · json_response)
      }
    }
    ❌_) → error_json("Failed to read request body" · json_response)
  }
}

// =============================================================================
// CORS OPTIONS HANDLER
// =============================================================================

OPTIONS /api/generate/* "CORS preflight handler"
  @cors

  → 204 No Content

@spec options_handler(req: Request(Connection)) → Response(ResponseData) {
  /// OPTIONS handler for CORS preflight
  given: OPTIONS request
  when: Browser CORS preflight
  then: Returns 204 with CORS headers
}

@impl {
  response_new(204)
  · response_set_header("access-control-allow-origin", "*")
  · response_set_header("access-control-allow-methods", "GET, POST, OPTIONS")
  · response_set_header("access-control-allow-headers", "Content-Type, Authorization")
  · response_set_header("access-control-max-age", "86400")
  · response_set_body(mist_bytes(bytes_tree_new()))
}

// =============================================================================
// RESPONSE HELPERS
// =============================================================================

@spec json_response(status: int, body: Json) → Response(ResponseData) {
  /// Create JSON HTTP response with CORS headers
  given: Status code and JSON body
  when: Returning HTTP response
  then: Returns response with proper headers
}

@impl {
  response_new(status)
  · response_set_header("content-type", "application/json")
  · response_set_header("access-control-allow-origin", "*")
  · response_set_header("access-control-allow-methods", "GET, POST, OPTIONS")
  · response_set_header("access-control-allow-headers", "Content-Type")
  · response_set_body(mist_bytes(bytes_tree_from_string(json_to_string(body))))
}

@spec error_json(message: str) → Json {
  /// Create error JSON object
  given: Error message
  when: Returning error response
  then: Returns JSON with success=false
}

@impl {
  json_object([
    ("success", json_bool(false)),
    ("error", json_string(message))
  ])
}

// =============================================================================
// JSON PARSING HELPERS
// =============================================================================

@spec get_field(body: str, field: str) → str? {
  /// Simple JSON field extraction
  given: JSON body string and field name
  when: Extracting field value
  then: Returns ☐value) or ∅}

@impl {
  let pattern = "\"{field}\":"
  match pattern · string_contains {
    false → ∅true → {
      let parts = pattern · string_split
      match parts {
        [_, rest, ..] → {
          let trimmed = string_trim_start(rest)
          match string_first(trimmed) {
            ✅"\"") → {
              // str value
              let after_quote = 1 · string_drop_start
              let value_parts = "\"" · string_split
              match value_parts {
                [value, ..] → ☐value)
                _ → ∅}
            }
            ✅_) → {
              // Number or other value (until comma or brace)
              let chars = string_to_graphemes(trimmed)
              let value = "" · extract_value
              match value {
                "" → ∅v → ☐v)
              }
            }
            ❌_) → ∅}
        }
        _ → ∅}
    }
  }
}

@spec extract_value(chars: [str], acc: str) → str {
  /// Extract value until delimiter
  given: Character list and accumulator
  when: Parsing non-string JSON value
  then: Returns extracted value
}

@impl {
  match chars {
    [] → acc
    [",", ..] → acc
    ["}", ..] → acc
    [" ", ..] → acc
    ["\n", ..] → acc
    ["\t", ..] → acc
    [c, ..rest] → acc ++ c · extract_value
  }
}

# v8.0

# v10.0 - ML-Powered Migration
