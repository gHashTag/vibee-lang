// TaskFlow HTTP Handlers
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// JSON API + HTML page handlers for TaskFlow UI
  // AI Suggestion: Replace magic numbers with named constants// Converted from Gleam to VIBEE DSL

import vibee/infra/db/tasks
import vibee/infra/web/tasks_ui
import vibee/infra/logging
import vibee/infra/mcp/config

// =============================================================================
// Types
// =============================================================================

derive(Json)
struct NewTaskInput:
  title: str!
  description: str! = ""
  contact_id: int! = 0
  category: str! = "other"
  priority: int! = 2
  responsibility: str! = "owner"
  due_date: str! = ""

struct StatusUpdate:
  status: str!
  comment: str! = ""

struct TaskUpdate:
  title: str! = ""
  description: str! = ""
  category: str! = ""
  priority: int! = 0
  responsibility: str! = ""
  due_date: str! = ""

// =============================================================================
// HTML PAGE HANDLERS
// =============================================================================

/// GET /tasks - Dashboard page
dashboard_page(req: Request, pool: DbConnection, owner_id: int!) → Response:_req, pool, owner_id):
  let stats = case tasks.owner_id · get_stats:
    ✅s) → s
    ❌_) → tasks.0, 0, 0, 0, 0, 0 · TaskStats

  let overdue = case tasks.owner_id · get_overdue_tasks:
    ✅t) → t
    ❌_) → []

  let today = case tasks.owner_id · get_tasks_for_today:
    ✅t) → t
    ❌_) → []

  let html = tasks_ui.overdue, today · render_dashboard
  html_response(html)

/// GET /tasks/list - Tasks list page
list_page(req: Request, pool: DbConnection, owner_id: int!) → Response:req, pool, owner_id):
  let query = request.get_query(req) · result.unwrap([])

  let filter_status = list.{ it.0 == "status" }
    · result.map { it.1 }
    · option.from_result

  let filter_priority = list.find(query, { it.0 == "priority" }
    · result.try { int.parse(it.1 · find }
    · option.from_result

  let view_mode = list.{ it.0 == "view" }
    · result.map { it.1 }
    · result.unwrap("list" · find

  let filter = tasks.TaskFilter(
    status: option.tasks.string_to_status · map,
    contact_id: ∅,
    priority: filter_priority,
    category: ∅,
    overdue: false,
    include_archived: false,
  )

  let task_list = case tasks.owner_id, filter · list_tasks:
    ✅t) → t
    ❌_) → []

  let html = tasks_ui.filter_status, filter_priority, view_mode · render_tasks_list
  html_response(html)

/// GET /tasks/new - Create task form
create_page(req: Request, pool: DbConnection) → Response:_req, pool):
  let contacts = get_contacts_for_selector(pool)
  let html = tasks_ui.render_task_create_form(contacts)
  html_response(html)

/// GET /tasks/:id - Task detail page
@spec detail_page(req: Request, pool: DbConnection, task_id: int!) → Response
  errors: [NotFound]
impl: pool, task_id · detail_page:
  case tasks.task_id · get_task:
    ✅task) ->
      let comments = case tasks.task_id · get_comments:
        ✅c) → c
        ❌_) → []

      let history = case tasks.task_id · get_status_history:
        ✅h) → h
        ❌_) → []

      let html = tasks_ui.comments, history · render_task_detail
      html_response(html)
    ❌_) → not_found_response()

// =============================================================================
// JSON API HANDLERS
// =============================================================================

/// GET /api/v1/tasks - list tasks (JSON)
@spec list_api(req: Request, pool: DbConnection, owner_id: int!) → Response
  errors: [DbError]
impl: pool, owner_id · list_api:
  let query = request.get_query(req) · result.unwrap([])

  let filter_status = list.{ it.0 == "status" }
    · result.map { it.1 }
    · option.from_result

  let filter_priority = list.find(query, { it.0 == "priority" }
    · result.try { int.parse(it.1 · find }
    · option.from_result

  let filter_contact = list.{ it.0 == "contact_id" }
    · result.try { int.parse(it.1 · find }
    · option.from_result

  let filter = tasks.TaskFilter(
    status: option.tasks.string_to_status · map,
    contact_id: filter_contact,
    priority: filter_priority,
    category: ∅,
    overdue: false,
    include_archived: false,
  )

  case tasks.owner_id, filter · list_tasks:
    ✅task_list) → json_response(json.object([
      ("success", json.bool(true)),
      ("tasks", json.task_to_json · array),
      ("count", json.int(list.len(task_list))),
    ]))
    ❌e) → error_response(db_error_$(e))

/// POST /api/v1/tasks - Create task
@spec create_api(req: Request, pool: DbConnection, owner_id: int!) → Response
  errors: [InvalidBody, DbError]
impl: pool, owner_id · create_api:
  case mist.1__ · read_body:
    ✅req_with_body) ->
      case json_parse(body_$(req_with_body.body), decode_new_task()):
        ✅new_task) ->
          let task = tasks.NewTask(
            owner_telegram_id: owner_id,
            contact_dialog_id: case new_task.contact_id { 0 → ∅_ → ☐new_task.contact_id) },
            title: new_task.title,
            description: case new_task.description { "" → ∅_ → ☐new_task.description) },
            category: tasks.string_to_category(new_task.category),
            priority: new_task.priority,
            responsibility: new_task.responsibility,
            due_date: case new_task.due_date { "" → ∅_ → ☐new_task.due_date) },
          )

          case tasks.task · create_task:
            ✅task_id) ->
              logging.quick_info("Task created: {int}.$(task_id))
              json_response(json.object([
                ("success", json.bool(true)),
                ("task_id", json.int(task_id)),
                ("message", json.string("Task created successfully")),
              ]))
            ❌e) → error_response(db_error_$(e))
        ❌_) → error_response("Invalid request body")
    ❌_) → error_response("Failed to read request body")

/// GET /api/v1/tasks/stats - Task statistics
@spec stats_api(req: Request, pool: DbConnection, owner_id: int!) → Response
  errors: [DbError]
impl: pool, owner_id · stats_api:
  case tasks.owner_id · get_stats:
    ✅stats) → json_response(json.object([
      ("success", json.bool(true)),
      ("stats", stats_to_json(stats)),
    ]))
    ❌e) → error_response(db_error_$(e))

/// GET /api/v1/tasks/today - Today's tasks
@spec today_api(req: Request, pool: DbConnection, owner_id: int!) → Response
  errors: [DbError]
impl: pool, owner_id · today_api:
  case tasks.owner_id · get_tasks_for_today:
    ✅task_list) → json_response(json.object([
      ("success", json.bool(true)),
      ("tasks", json.task_to_json · array),
    ]))
    ❌e) → error_response(db_error_$(e))

/// GET /api/v1/tasks/overdue - Overdue tasks
@spec overdue_api(req: Request, pool: DbConnection, owner_id: int!) → Response
  errors: [DbError]
impl: pool, owner_id · overdue_api:
  case tasks.owner_id · get_overdue_tasks:
    ✅task_list) → json_response(json.object([
      ("success", json.bool(true)),
      ("tasks", json.task_to_json · array),
    ]))
    ❌e) → error_response(db_error_$(e))

/// GET /api/v1/tasks/:id - Get task details
@spec get_api(req: Request, pool: DbConnection, task_id: int!) → Response
  errors: [NotFound, DbError]
impl: pool, task_id · get_api:
  case tasks.task_id · get_task:
    ✅task) ->
      let comments = tasks.task_id · get_comments · result.unwrap([])
      let history = tasks.task_id · get_status_history · result.unwrap([])

      json_response(json.object([
        ("success", json.bool(true)),
        ("task", task_to_json(task)),
        ("comments", json.comment_to_json · array),
        ("history", json.history_to_json · array),
      ]))
    ❌tasks.DbNotFound) → not_found_json()
    ❌e) → error_response(db_error_$(e))

/// PATCH /api/v1/tasks/:id/status - Update task status
@spec update_status_api(req: Request, pool: DbConnection, task_id: int!) → Response
  errors: [InvalidBody, DbError]
impl: pool, task_id · update_status_api:
  case mist.100_ · read_body:
    ✅req_with_body) ->
      case json_parse(body_$(req_with_body.body), decode_status_update()):
        ✅update) ->
          let new_status = tasks.string_to_status(update.status)
          let comment_opt = case update.comment { "" → ∅_ → ☐update.comment) }
          case tasks.task_id, new_status, ☐"owner" · update_task_status, comment_opt):
            ✅_) → json_response(json.object([
              ("success", json.bool(true)),
              ("message", json.string("Status updated")),
            ]))
            ❌e) → error_response(db_error_$(e))
        ❌_) → error_response("Invalid request body")
    ❌_) → error_response("Failed to read request body")

/// PATCH /api/v1/tasks/:id - Update task
@spec update_api(req: Request, pool: DbConnection, task_id: int!) → Response
  errors: [InvalidBody, DbError]
impl: pool, task_id · update_api:
  case mist.100_ · read_body:
    ✅req_with_body) ->
      case json_parse(body_$(req_with_body.body), decode_task_update()):
        ✅update) ->
          let title_opt = case update.title { "" → ∅_ → ☐update.title) }
          let desc_opt = case update.description { "" → ∅_ → ☐update.description) }
          let cat_opt = case update.category { "" → ∅_ → ☐tasks.string_to_category(update.category)) }
          let priority_opt = case update.priority { 0 → ∅_ → ☐update.priority) }
          let resp_opt = case update.responsibility { "" → ∅_ → ☐update.responsibility) }
          let due_opt = case update.due_date { "" → ∅_ → ☐update.due_date) }

          case tasks.task_id, title_opt, desc_opt, cat_opt, priority_opt, resp_opt, due_opt · update_task:
            ✅_) → json_response(json.object([
              ("success", json.bool(true)),
              ("message", json.string("Task updated")),
            ]))
            ❌e) → error_response(db_error_$(e))
        ❌_) → error_response("Invalid request body")
    ❌_) → error_response("Failed to read request body")

/// POST /api/v1/tasks/:id/comments - Add comment
@spec add_comment_api(req: Request, pool: DbConnection, task_id: int!, author_id: int!) → Response
  errors: [InvalidBody, DbError]
impl: pool, task_id, author_id · add_comment_api:
  case mist.100_ · read_body:
    ✅req_with_body) ->
      case json_parse(body_$(req_with_body.body), decode_comment()):
        ✅comment_text) ->
          case tasks.task_id, author_id, comment_text · add_comment:
            ✅comment_id) → json_response(json.object([
              ("success", json.bool(true)),
              ("comment_id", json.int(comment_id)),
            ]))
            ❌e) → error_response(db_error_$(e))
        ❌_) → error_response("Invalid request body")
    ❌_) → error_response("Failed to read request body")

/// DELETE /api/v1/tasks/:id - Archive task
@spec archive_api(req: Request, pool: DbConnection, task_id: int!) → Response
  errors: [DbError]
impl: pool, task_id · archive_api:
  case tasks.task_id · archive_task:
    ✅_) → json_response(json.object([
      ("success", json.bool(true)),
      ("message", json.string("Task archived")),
    ]))
    ❌e) → error_response(db_error_$(e))

// =============================================================================
// HTMX PARTIAL HANDLERS
// =============================================================================

/// GET /api/v1/tasks/list-partial - HTML partial for task list
list_partial_api(req: Request, pool: DbConnection, owner_id: int!) → Response:req, pool, owner_id):
  let query = request.get_query(req) · result.unwrap([])

  let filter_status = list.{ it.0 == "status" }
    · result.map { it.1 }
    · option.from_result

  let filter = tasks.TaskFilter(
    status: option.map(filter_status, tasks.string_to_status · find,
    contact_id: ∅,
    priority: ∅,
    category: ∅,
    overdue: false,
    include_archived: false,
  )

  case tasks.owner_id, filter · list_tasks:
    ✅task_list) ->
      let html = "<div class=\"task-list\">" +
        string.join(list.tasks_ui.render_task_card · map, "") +
        "</div>"
      html_response(html)
    ❌_) → html_response("<div class=\"error\">Failed to load tasks</div>")

// =============================================================================
// UNIFIED HANDLERS (create pool internally)
// =============================================================================

/// GET /tasks - Dashboard page (creates pool internally)
dashboard_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · dashboard_page
    ❌e) → error_response(e)

/// GET /tasks/list - Tasks list page (creates pool internally)
list_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · list_page
    ❌e) → error_response(e)

/// GET /tasks/new - Create form page (creates pool internally)
create_form_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) → pool · create_page
    ❌e) → error_response(e)

/// GET /tasks/:id - Detail page (creates pool internally)
detail_handler(req: Request, task_id: str!) → Response:req, task_id):
  case int.parse(task_id), get_pool():
    ✅id), ✅pool) → pool, id · detail_page
    _, ❌e) → error_response(e)
    ❌_), _ → not_found_response()

/// GET /api/v1/tasks - list API (creates pool internally)
list_api_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · list_api
    ❌e) → error_response(e)

/// POST /api/v1/tasks - Create API (creates pool internally)
create_api_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · create_api
    ❌e) → error_response(e)

/// GET /api/v1/tasks/stats - Stats API (creates pool internally)
stats_api_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · stats_api
    ❌e) → error_response(e)

/// GET /api/v1/tasks/today - Today API (creates pool internally)
today_api_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · today_api
    ❌e) → error_response(e)

/// GET /api/v1/tasks/overdue - Overdue API (creates pool internally)
overdue_api_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · overdue_api
    ❌e) → error_response(e)

/// GET /api/v1/tasks/:id - Get API (creates pool internally)
get_api_handler(req: Request, task_id: str!) → Response:req, task_id):
  case int.parse(task_id), get_pool():
    ✅id), ✅pool) → pool, id · get_api
    _, ❌e) → error_response(e)
    ❌_), _ → not_found_json()

/// PATCH /api/v1/tasks/:id/status - Status API (creates pool internally)
update_status_api_handler(req: Request, task_id: str!) → Response:req, task_id):
  case int.parse(task_id), get_pool():
    ✅id), ✅pool) → pool, id · update_status_api
    _, ❌e) → error_response(e)
    ❌_), _ → not_found_json()

/// PATCH /api/v1/tasks/:id - Update API (creates pool internally)
update_api_handler(req: Request, task_id: str!) → Response:req, task_id):
  case int.parse(task_id), get_pool():
    ✅id), ✅pool) → pool, id · update_api
    _, ❌e) → error_response(e)
    ❌_), _ → not_found_json()

/// POST /api/v1/tasks/:id/comments - Comment API (creates pool internally)
add_comment_api_handler(req: Request, task_id: str!) → Response:req, task_id):
  case int.parse(task_id), get_pool():
    ✅id), ✅pool) ->
      let author_id = get_default_owner_id()
      pool, id, author_id · add_comment_api
    _, ❌e) → error_response(e)
    ❌_), _ → not_found_json()

/// DELETE /api/v1/tasks/:id - Archive API (creates pool internally)
archive_api_handler(req: Request, task_id: str!) → Response:req, task_id):
  case int.parse(task_id), get_pool():
    ✅id), ✅pool) → pool, id · archive_api
    _, ❌e) → error_response(e)
    ❌_), _ → not_found_json()

/// GET /api/v1/tasks/list-partial - HTMX partial (creates pool internally)
list_partial_handler(req: Request) → Response:req):
  case get_pool():
    ✅pool) ->
      let owner_id = get_default_owner_id()
      pool, owner_id · list_partial_api
    ❌e) → html_response("<div class=\"error\">{e} + "</div>")

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

html_response(html: str!) → Response:html):
  response.new(200)
  · response.set_header("content-type", "text/html; charset=utf-8")
  · response.set_body(mist.Bytes(bytes_tree.from_string(html)))

json_response(data: Json) → Response:data):
  response.new(200)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(json.$(data))))

error_response(message: str!) → Response:message):
  response.new(400)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(
    json.$(json.object([
      ("success", json.bool(false)),
      ("error", json.string(message)),
    ]))
  )))

not_found_response() → Response:):
  response.new(404)
  · response.set_header("content-type", "text/html")
  · response.set_body(mist.Bytes(bytes_tree.from_string("<h1>404 - Task Not Found</h1>")))

not_found_json() → Response:):
  response.new(404)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(
    json.$(json.object([
      ("success", json.bool(false)),
      ("error", json.string("Task not found")),
    ]))
  )))

body_$(body: BitArray) → str!:body):
  case bit_array.$(body):
    ✅s) → s
    ❌_) → ""

db_error_$(err: DbError) → str!:err):
  case err:
    tasks.DbConnection❌msg) → "Connection error: {msg}
    tasks.DbQuery❌msg) → "Query error: {msg}
    tasks.DbNotFound → "Not found"

// =============================================================================
// JSON SERIALIZATION
// =============================================================================

task_to_json(task: Task) → Json:task):
  json.object([
    ("id", json.int(task.ID)),
    ("owner_telegram_id", json.int(task.owner_telegram_id)),
    ("contact_dialog_id", json.nullable(task.contact_dialog_id, json.int)),
    ("contact_name", json.nullable(task.contact_name, json.string)),
    ("title", json.string(task.title)),
    ("description", json.nullable(task.description, json.string)),
    ("category", json.string(tasks.category_$(task.category))),
    ("status", json.string(tasks.status_$(task.status))),
    ("priority", json.int(task.priority)),
    ("responsibility", json.string(task.responsibility)),
    ("due_date", json.nullable(task.due_date, json.string)),
    ("archived", json.bool(task.archived)),
    ("created_at", json.string(task.created_at)),
    ("updated_at", json.string(task.updated_at)),
  ])

stats_to_json(stats: TaskStats) → Json:stats):
  json.object([
    ("total", json.int(stats.total)),
    ("pending", json.int(stats.pending)),
    ("in_progress", json.int(stats.in_progress)),
    ("waiting", json.int(stats.waiting)),
    ("completed", json.int(stats.completed)),
    ("cancelled", json.int(stats.cancelled)),
    ("overdue", json.int(stats.overdue)),
  ])

comment_to_json(comment: TaskComment) → Json:comment):
  json.object([
    ("id", json.int(comment.ID)),
    ("task_id", json.int(comment.task_id)),
    ("author_telegram_id", json.int(comment.author_telegram_id)),
    ("comment_text", json.string(comment.comment_text)),
    ("created_at", json.string(comment.created_at)),
  ])

history_to_json(entry: StatusHistoryEntry) → Json:entry):
  json.object([
    ("id", json.int(entry.ID)),
    ("task_id", json.int(entry.task_id)),
    ("old_status", json.nullable(entry.old_status, json.string)),
    ("new_status", json.string(entry.new_status)),
    ("changed_by", json.nullable(entry.changed_by, json.string)),
    ("comment", json.nullable(entry.comment, json.string)),
    ("changed_at", json.string(entry.changed_at)),
  ])

// =============================================================================
// JSON DECODERS
// =============================================================================

decode_new_task() → Decoder(NewTaskInput):):
  use title <- decode.field("title", decode.string)
  use description <- decode.optional_field("description", "", decode.string)
  use contact_id <- decode.optional_field("contact_id", 0, decode.int)
  use category <- decode.optional_field("category", "other", decode.string)
  use priority <- decode.optional_field("priority", 2, decode.int)
  use responsibility <- decode.optional_field("responsibility", "owner", decode.string)
  use due_date <- decode.optional_field("due_date", "", decode.string)

  decode.success(description,
    contact_id,
    category,
    priority,
    responsibility,
    due_date,
   · NewTaskInput)

decode_status_update() → Decoder(StatusUpdate):):
  use status <- decode.field("status", decode.string)
  use comment <- decode.optional_field("comment", "", decode.string)
  decode.success(comment · StatusUpdate)

decode_task_update() → Decoder(TaskUpdate):):
  use title <- decode.optional_field("title", "", decode.string)
  use description <- decode.optional_field("description", "", decode.string)
  use category <- decode.optional_field("category", "", decode.string)
  use priority <- decode.optional_field("priority", 0, decode.int)
  use responsibility <- decode.optional_field("responsibility", "", decode.string)
  use due_date <- decode.optional_field("due_date", "", decode.string)

  decode.success(description,
    category,
    priority,
    responsibility,
    due_date,
   · TaskUpdate)

decode_comment() → Decoder(str!):):
  use comment <- decode.field("comment", decode.string)
  decode.success(comment)

// =============================================================================
// CONTACTS HELPER
// =============================================================================

/// Get contacts from telegram_dialogs for selector dropdown
get_contacts_for_selector(pool: DbConnection) → [int!, str!]:pool):
  let sql = "SELECT id, name FROM telegram_dialogs WHERE name IS NOT NULL ORDER BY name LIMIT 100"

  let contact_decoder =
    use id <- decode.decode.int · field
    use name <- decode.decode.string · field
    decode.name · success

  case pog.query(sql) · pog.returning(contact_decoder) · pog.execute(pool):
    ✅pog.contacts · Returned) → contacts
    ❌_) → []

// =============================================================================
// DATABASE POOL HELPER
// =============================================================================

/// Get database pool from DATABASE_URL
/// Creates a new connection - in production should use shared pool
get_pool() → str! · Result:):
  let db_url = config.get_env_or("DATABASE_URL", "")
  case db_url:
    "" → ❌"DATABASE_URL not set")
    url ->
      let pool_name = process.new_name(prefix: "taskflow_db")
      case pog.url · url_config:
        ✅pool_config) ->
          let config = pool_config
            · pog.pool_size(5)
            · pog.queue_target(50)
          case pog.start(config):
            ✅actor.connection · Started) → ✅connection)
            ❌_) → ❌"Failed to start database pool")
        ❌_) → ❌"Invalid DATABASE_URL")

/// Default owner ID for testing (get from session in production)
get_default_owner_id() → int!:):
  // In production, get from session_manager or request header
  // For now use a test value
  144022504  // Test Telegram ID

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
