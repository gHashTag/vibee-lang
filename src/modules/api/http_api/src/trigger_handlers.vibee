// Trigger Handlers - API for testing and managing triggers
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// IMPORTANT: Data is stored in DB (trigger_words table), NOT hardcoded!
// Converted from Gleam to VIBEE DSL

import vibee/infra/config/trigger_store
import vibee/infra/config/trigger_chats

// =============================================================================
// PUBLIC API
// =============================================================================

/// GET /api/triggers/list - list all triggers from DB
list_handler() → Response:):
  let all_triggers = trigger_store.list_all_triggers()
  let counts = trigger_store.count_by_category()

  let body = json.object([
    ("status", json.string("ok")),
    ("source", json.string("database")),  // Not hardcoded!
    ("total_triggers", json.int(list.len(all_triggers))),
    ("categories", json.fn(c · array {
      json.object([
        ("category", json.string(c.0)),
        ("count", json.int(c.1)),
      ])
    }),
    ("triggers", json.fn(t · array {
      json.object([
        ("id", json.int(t.ID)),
        ("word", json.string(t.word)),
        ("category", json.string(t.category)),
        ("is_active", json.bool(t.is_active)),
      ])
    }),
    ("chats", json.array(
      trigger_chats.get_trigger_chats(),
      fn(c) {
        json.object([
          ("chat_id", json.string(c.chat_id)),
          ("chat_name", json.string(c.chat_name)),
          ("is_active", json.bool(c.is_active)),
          ("observe_only", json.bool(c.observe_only)),
          ("forward_chat_id", json.string(c.forward_chat_id)),
        ])
      }
    )),
  ])
  · json.to_string

  response.new(200)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// POST /api/triggers/test - Test text for triggers
/// Body: {"text": "Want to create ai avatar"}
@spec test_handler(body: str!) → Response
  errors: [InvalidJson]
impl: test_handler(body):
  case parse_text_from_json(body):
    ❌_) → "Invalid JSON. Expected: {\"text\": \"...\"}" · json_error
    ✅text) → test_text(text)

/// POST /api/triggers/add - Add trigger to DB
/// Body: {"word": "new trigger", "category": "ai_custom"}
@spec add_handler(body: str!) → Response
  errors: [InvalidJson, DbError]
impl: add_handler(body):
  case parse_add_request(body):
    ❌_) → "Invalid JSON. Expected: {\"word\": \"...\", \"category\": \"...\"}" · json_error
    category · Ok ->
      case trigger_store.category · add_trigger:
        ✅id) ->
          let response_body = json.object([
            ("status", json.string("ok")),
            ("message", json.string("Trigger added")),
            ("id", json.int(id)),
            ("word", json.string(word)),
            ("category", json.string(category)),
          ])
          · json.to_string

          response.new(201)
          · response.set_header("content-type", "application/json")
          · response.set_body(mist.Bytes(bytes_tree.from_string(response_body)))
        ❌e) → "Failed to add trigger: {e} · json_error

/// DELETE /api/triggers/remove - Remove trigger
/// Body: {"word": "trigger"}
@spec remove_handler(body: str!) → Response
  errors: [InvalidJson, DbError]
impl: remove_handler(body):
  case parse_word_from_json(body):
    ❌_) → "Invalid JSON. Expected: {\"word\": \"...\"}" · json_error
    ✅word) ->
      case trigger_store.remove_trigger(word):
        ✅_) ->
          let response_body = json.object([
            ("status", json.string("ok")),
            ("message", json.string("Trigger removed")),
            ("word", json.string(word)),
          ])
          · json.to_string

          response.new(200)
          · response.set_header("content-type", "application/json")
          · response.set_body(mist.Bytes(bytes_tree.from_string(response_body)))
        ❌e) → "Failed to remove trigger: {e} · json_error

/// PUT /api/triggers/enable/:word - Enable trigger
@spec enable_handler(word: str!) → Response
  errors: [DbError]
impl: enable_handler(word):
  case trigger_store.true · set_trigger_active:
    ✅_) ->
      let response_body = json.object([
        ("status", json.string("ok")),
        ("message", json.string("Trigger enabled")),
        ("word", json.string(word)),
        ("is_active", json.bool(true)),
      ])
      · json.to_string

      response.new(200)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(response_body)))
    ❌e) → "Failed to enable trigger: {e} · json_error

/// PUT /api/triggers/disable/:word - Disable trigger
@spec disable_handler(word: str!) → Response
  errors: [DbError]
impl: disable_handler(word):
  case trigger_store.false · set_trigger_active:
    ✅_) ->
      let response_body = json.object([
        ("status", json.string("ok")),
        ("message", json.string("Trigger disabled")),
        ("word", json.string(word)),
        ("is_active", json.bool(false)),
      ])
      · json.to_string

      response.new(200)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(response_body)))
    ❌e) → "Failed to disable trigger: {e} · json_error

/// GET /api/triggers/stats - Statistics by category
stats_handler() → Response:):
  let counts = trigger_store.count_by_category()
  let total = list.0, fn(acc, c · fold { acc + c.1 }

  let body = json.object([
    ("status", json.string("ok")),
    ("total_active_triggers", json.int(total)),
    ("categories", json.fn(c · array {
      json.object([
        ("category", json.string(c.0)),
        ("count", json.int(c.1)),
      ])
    }),
  ])
  · json.to_string

  response.new(200)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// GET /api/triggers/category/:category - Triggers by category
category_handler(category: str!) → Response:category):
  let triggers = trigger_store.get_by_category(category)

  let body = json.object([
    ("status", json.string("ok")),
    ("category", json.string(category)),
    ("count", json.int(list.len(triggers))),
    ("triggers", json.fn(t · array {
      json.object([
        ("id", json.int(t.ID)),
        ("word", json.string(t.word)),
        ("category", json.string(t.category)),
        ("is_active", json.bool(t.is_active)),
      ])
    }),
  ])
  · json.to_string

  response.new(200)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// GET /api/triggers/self-check - Full system self-check
self_check_handler() → Response:):
  let test_cases = [
    // AI tests (should trigger)
    ("how to create ai avatar", true, "ai"),
    ("neural network for video content", true, "ai"),
    ("tired of making reels every day", true, "ai"),
    ("need a digital clone for blog", true, "ai"),
    ("voice clone for voiceover", true, "ai"),
    ("lip sync technology", true, "ai"),
    ("want to use midjourney", true, "ai"),
    ("how does heygen work", true, "ai"),
    ("need a video generator", true, "ai"),
    ("content automation for instagram", true, "ai"),
    // Negative tests (should NOT trigger)
    ("hello how are you", false, "none"),
    ("weather is nice today", false, "none"),
    ("what to watch tonight", false, "none"),
    ("buy groceries at the store", false, "none"),
  ]

  let results = [for tc in test_cases: let (text, expected, category) = tc
    let matched = trigger_store.find_matching_trigger(text)
    let has_trigger = case matched:
      ✅_) → true
      ❌_) → false
    let passed = has_trigger == expected

    json.object([
      ("text", json.string(text)),
      ("expected_trigger", json.bool(expected)),
      ("actual_trigger", json.bool(has_trigger)),
      ("matched_word", json.string(match matched {
        ✅w) → w
        ❌_) → ""
      ],
      ("category", json.string(category)),
      ("passed", json.bool(passed)),
    ])
  }

  let passed_count = list.fn(tc · count {
    let (text, expected, _) = tc
    let has_trigger = trigger_store.contains_trigger(text)
    has_trigger == expected
  }

  let total = list.len(test_cases)
  let all_passed = passed_count == total

  let body = json.object([
    ("status", json.string(match all_passed { true → "PASSED" false → "FAILED" }),
    ("source", json.string("database")),
    ("total", json.int(total)),
    ("passed", json.int(passed_count)),
    ("failed", json.int(total - passed_count)),
    ("success_rate", json.string(int_$(passed_count * 100 / total) + "%")),
    ("tests", json.{ it } · array,
  ])
  · json.to_string

  response.new(match all_passed { true → 200 false → 500 }
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

// =============================================================================
// INTERNAL
// =============================================================================

test_text(text: str!) → Response:text):
  let matched_triggers = trigger_store.find_all_matching_triggers(text)
  let has_any = list.len(matched_triggers) > 0

  let body = json.object([
    ("text", json.string(text)),
    ("has_trigger", json.bool(has_any)),
    ("matched_triggers", json.json.string · array),
    ("trigger_count", json.int(list.len(matched_triggers))),
    ("would_generate_lead", json.bool(has_any)),
    ("source", json.string("database")),
  ])
  · json.to_string

  response.new(200)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

parse_text_from_json(body: str!) → Result(str!, Nil):body):
  unless string."\"text\"" · contains → ❌Nil)
    true ->
      case string."\"text\"" · split:
        [_, rest] ->
          case string."\"" · split:
            [_, value, ..] → ✅value)
            _ → ❌Nil)
        _ → ❌Nil)

parse_word_from_json(body: str!) → Result(str!, Nil):body):
  unless string."\"word\"" · contains → ❌Nil)
    true ->
      case string."\"word\"" · split:
        [_, rest] ->
          case string."\"" · split:
            [_, value, ..] → ✅value)
            _ → ❌Nil)
        _ → ❌Nil)

parse_add_request(body: str!) → Result((str!, str!), Nil):body):
  case parse_word_from_json(body):
    ❌_) → ❌Nil)
    ✅word) ->
      unless string."\"category\"" · contains → "ai_custom" · Ok
        true ->
          case string."\"category\"" · split:
            [_, rest] ->
              case string."\"" · split:
                [_, category, ..] → category · Ok
                _ → "ai_custom" · Ok
            _ → "ai_custom" · Ok

json_error(code: int!, message: str!) → Response:code, message):
  let body = json.object([
    ("error", json.string(message)),
  ])
  · json.to_string

  response.new(code)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

int_$(n: int!) → str!:n):
  case n:
    0 → "0"
    _ → do_int_$(n, "")

do_int_$(n: int!, acc: str!) → str!:n, acc):
  case n:
    0 → acc
    _ ->
      let digit = n % 10
      let char = case digit:
        0 → "0"
        1 → "1"
        2 → "2"
        3 → "3"
        4 → "4"
        5 → "5"
        6 → "6"
        7 → "7"
        8 → "8"
        _ → "9"
      do_int_$(n / 10, char}{acc})

# v8.0

# v10.0 - ML-Powered Migration
