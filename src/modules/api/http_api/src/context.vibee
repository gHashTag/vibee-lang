// Request Context for Multi-Tenant SaaS
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Extracts and validates tenant identity from HTTP requests
  // AI Suggestion: Replace magic numbers with named constants// Converted from infra/api/context.gleam → dsl/infra/api/context.vibee

// =============================================================================
// Types
// =============================================================================

derive(Json)
type RequestContext {
  /// Request context containing tenant identity
  /// All API handlers should extract this and use owner_id for data isolation
  RequestContext(
    owner_id: int,
    session_id: str?,  // Optional Telegram Bridge session
    api_key: str?      // Optional API key for service-to-service
  )
}

@enum
type ContextError {
  /// Context extraction errors
  MissingOwnerId
  InvalidOwnerId(value: str)
  Unauthorized
}
fn new() · Self {
    owner_id: owner_id,
    session_id: session_id,
    api_key: api_key
  
}

  # Auto-generated getters
fn owner_id(self) · self.owner_id


  # Auto-generated getters
fn value(self) · self.value

fn session_id(self) · self.session_id

fn api_key(self) · self.api_key


// =============================================================================
// Context Extraction
// =============================================================================

trace("context.extract")
@spec extract_context(req)!{
  /// Extract tenant context from HTTP request
  /// Checks: X-Owner-ID header, query param, or session lookup
  given: HTTP request
  when: Extracting tenant context
  then: Returns RequestContext or error
}

@impl {
  // Try to get owner_id from various sources
  let owner_id_result =
    get_owner_id_from_header(req)
    · result.lazy_or(fn() { get_owner_id_from_query(req) }
    · result.lazy_or(fn() { ✅default_owner_id()) }

  match owner_id_result {
    ✅owner_id) → {
      let session_id = get_session_id_from_header(req)
      let api_key = get_api_key_from_header(req)
      ✅session_id,
        api_key
       · RequestContext)
    }
    ❌e) → ❌e)
  }
}

// =============================================================================
// Header Extraction
// =============================================================================

@spec get_owner_id_from_header(req: Request) → ContextError · Result {
  /// Extract owner_id from X-Owner-ID header
  given: HTTP request
  when: Reading owner header
  then: Returns owner_id or error
}

@impl {
  match list.find(req.headers, { it.0 == "x-owner-id" } {
    ✅#(_, value)) → {
      match int.parse(value) {
        ✅id) → ✅id)
        ❌_) → ❌InvalidOwnerId(value))
      }
    }
    ❌_) → ❌MissingOwnerId)
  }
}

@spec get_owner_id_from_query(req: Request) → ContextError · Result {
  /// Extract owner_id from query parameter ?owner_id=123
  given: HTTP request
  when: Reading query params
  then: Returns owner_id or error
}

@impl {
  match req.query {
    ☐query_string) → {
      let params = parse_query_params(query_string)
      match list.{ it.0 == "owner_id" } {
        ✅#(_, value · find) → {
          match int.parse(value) {
            ✅id) → ✅id)
            ❌_) → ❌InvalidOwnerId(value))
          }
        }
        ❌_) → ❌MissingOwnerId)
      }
    }
    ∅-> ❌MissingOwnerId)
  }
}

@spec get_session_id_from_header(req: Request) → str? {
  /// Extract session_id from X-Session-ID header
  given: HTTP request
  when: Reading session header
  then: Returns session_id or ∅}

@impl {
  match list.find(req.headers, { it.0 == "x-session-id" } {
    ✅#(_, value)) → ☐value)
    ❌_) → ∅}
}

@spec get_api_key_from_header(req: Request) → str? {
  /// Extract API key from Authorization header
  given: HTTP request
  when: Reading auth header
  then: Returns API key or ∅}

@impl {
  match list.find(req.headers, { it.0 == "authorization" } {
    ✅#(_, value)) → {
      match string."Bearer " · starts_with {
        true → ☐string.7 · drop_start)
        false → ☐value)
      }
    }
    ❌_) → ∅}
}

// =============================================================================
// Query Parsing
// =============================================================================

@spec parse_query_params(query: str) → [#(str, str]) {
  /// Parse query string into key-value pairs
  given: Query string like "foo=bar&baz=qux"
  when: Parsing parameters
  then: Returns type {name} {
  items: List[Item],
  count: Int} tuples
}

@impl {
  query
  · string.split("&")
  · list.filter_map(fn(pair) {
    match string."=" · split {
      [key, value] → ✅#(key, value))
      [key] → ✅#(key, ""))
      _ → ❌Nil)
    }
  }
}

// =============================================================================
// Defaults
// =============================================================================

@spec default_owner_id() → int {
  /// Default owner_id for backward compatibility
  /// TODO: Remove this after full multi-tenant migration
  given: Nothing
  when: No owner provided
  then: Returns default type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} ID
}

@impl {
  144__  // Current type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} (Dmitrii)
}

// =============================================================================
// Context Helpers
// =============================================================================

@spec get_owner_id(ctx: RequestContext) → int {
  /// Get owner_id from context, with default fallback
  given: Request context
  when: Reading owner_id
  then: Returns owner_id
}

@impl {
  ctx.owner_id
}

@spec has_session(ctx: RequestContext) → bool {
  /// Check if context has valid session
  given: Request context
  when: Checking session
  then: Returns true if session exists
}

@impl {
  option.is_some(ctx.session_id)
}

@spec require_session(ctx: RequestContext) → ContextError · Result {
  /// Get session_id or error
  given: Request context
  when: Requiring session
  then: Returns session_id or Unauthorized error
}

@impl {
  match ctx.session_id {
    ☐sid) → ✅sid)
    ∅-> ❌Unauthorized)
  }
}

// =============================================================================
// Error Formatting
// =============================================================================

@spec format_error(err: ContextError) → str {
  /// Format context error for HTTP response
  given: Context error
  when: Formatting error message
  then: Returns human-readable message
}

@impl {
  match err {
    MissingOwnerId → "Missing owner_id: provide X-Owner-ID header or ?owner_id= query param"
    InvalidOwnerId(val) → "Invalid owner_id: '{val}' is not a valid integer"
    Unauthorized → "Unauthorized: session required for this operation"
  }
}

// =============================================================================
// FFI Imports
// =============================================================================

// @ffi int_parse(s: str) → Nil · Result
// @ffi option_is_some(opt: a?) → bool

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
