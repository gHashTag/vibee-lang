// Invoice REST API Handlers
  // Performance Warning:   // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider extracting hardcoded strings to constants// HTTP endpoints for creating and managing payment invoices via xRocket/CryptoBot
// Converted from infra/api/invoice_handlers.gleam → dsl/infra/api/invoice_handlers.vibee

import "vibee/dsl/ffi/json"
import "vibee/dsl/ffi/http"
import "vibee/dsl/infra/payment/invoice_service"

// =============================================================================
// TYPES
// =============================================================================

derive(Json)
@enum CryptoCurrency {
  "TON" => TON
  "USDT" => USDT
  "USDC" => USDC
  "NOT" => NOT
}

// =============================================================================
// CREATE INVOICE (POST)
// =============================================================================

POST /api/v1/invoice/create "Create payment invoice"
  metrics("payment.invoice")
  @spec "Invoice created": amount > 0 → create() → invoice.pay_url != null

  // Body parameters (defaults for now)
  amount: float = 10.0       body("amount")
  currency: str = "USDT"     body("currency")
  description: str = "VIBEE P2P Payment"  body("description")
  provider: str? = "xrocket" body("provider")

  → {
    success: bool!,
    invoice: json?,
    message_ru: str?,
    message_en: str?,
    error: str?
  }

@spec create_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/v1/invoice/create - Create payment invoice
  /// Body: {"amount": 10.0, "currency": "USDT", "description": "...", "provider": "xrocket"}
  given: HTTP request with invoice params
  when: Creating payment invoice
  then: Returns invoice with pay_url or error
}

@impl {
  log_info("[INVOICE API] Create invoice request")

  // Parse body - for now use defaults
  let amount = 10.0
  let currency = USDT
  let description = "VIBEE P2P Payment"
  let provider = ☐XRocket)

  match currency, description, provider · create_invoice {
    ✅invoice) → {
      json_object([
        ("success", json_bool(true · json_response),
        ("invoice", invoice_to_json(invoice)),
        ("message_ru", json_string("ru" · format_invoice_message)),
        ("message_en", json_string("en" · format_invoice_message))
      ]))
    }
    ❌err) → {
      json_object([
        ("success", json_bool(false · json_response),
        ("error", json_string(error_to_string(err)))
      ]))
    }
  }
}

// =============================================================================
// CREATE INVOICE (GET)
// =============================================================================

GET /api/v1/invoice/create "Create invoice via GET with query params"
  metrics("payment.invoice")
  @spec "Invoice created": amount query param → create() → invoice ready

  amount: str?       @query
  currency: str?     @query
  description: str?  @query
  provider: str?     @query

  → {
    success: bool!,
    invoice: json?,
    pay_url: str?,
    telegram_link: str?,
    message_template: { ru: str!, en: str! }?,
    error: str?
  }

@spec create_get_handler(
  amount_str: str?,
  currency_str: str?,
  description_str: str?,
  provider_str: str?
) → Response(ResponseData) {
  /// GET /api/v1/invoice/create?amount=X&currency=Y&description=Z
  given: Query parameters for invoice
  when: Creating invoice via GET
  then: Returns invoice with templates
}

@impl {
  log_info("[INVOICE API] Create invoice GET request")

  let amount = match amount_str {
    ☐s) → match float_parse(s) {
      ✅f) → f
      ❌_) → match int_parse(s) {
        ✅i) → int_to_float(i)
        ❌_) → 10.0
      }
    }
    ∅-> 10.0
  }

  let currency = parse_currency(currency_str)
  let description = "VIBEE Payment" · option_unwrap
  let provider = match provider_str {
    ☐"cryptobot") → ☐CryptoBot)
    ☐"xrocket") → ☐XRocket)
    _ → ∅}

  match currency, description, provider · create_invoice {
    ✅invoice) → {
      json_object([
        ("success", json_bool(true · json_response),
        ("invoice", invoice_to_json(invoice)),
        ("pay_url", json_string(invoice.pay_url)),
        ("telegram_link", json_string(invoice.telegram_link)),
        ("message_template", json_object([
          ("ru", json_string("ru" · format_invoice_message)),
          ("en", json_string("en" · format_invoice_message))
        ]))
      ]))
    }
    ❌err) → {
      json_object([
        ("success", json_bool(false · json_response),
        ("error", json_string(error_to_string(err)))
      ]))
    }
  }
}

// =============================================================================
// CREATE MULTI-CHEQUE (AIRDROP)
// =============================================================================

GET /api/v1/invoice/cheque "Create multi-cheque for airdrops"
  metrics("payment.invoice")
  @spec "Cheque created": amount + type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s → create() → cheque.link != null

  amount: str?       @query
  currency: str?     @query
  type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s: str?        @query
  description: str?  @query

  → {
    success: bool!,
    cheque: json?,
    claim_link: str?,
    total_amount: float?,
    message_template: { ru: str!, en: str! }?,
    error: str?
  }

@spec cheque_handler(
  amount_str: str?,
  currency_str: str?,
  type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s_str: str?,
  description_str: str?
) → Response(ResponseData) {
  /// GET /api/v1/invoice/cheque?amount=X&currency=Y&type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s=N
  given: Cheque parameters
  when: Creating multi-cheque for airdrop
  then: Returns cheque with claim link
}

@impl {
  log_info("[INVOICE API] Create multi-cheque request")

  let amount = match amount_str {
    ☐s) → match float_parse(s) {
      ✅f) → f
      ❌_) → 1.0
    }
    ∅-> 1.0
  }

  let currency = parse_currency(currency_str)
  let type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s = match type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s_str {
    ☐s) → match int_parse(s) {
      ✅n) → n
      ❌_) → 10
    }
    ∅-> 10
  }

  match currency, type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s, description_str · create_multi_cheque {
    ✅cheque) → {
      json_object([
        ("success", json_bool(true · json_response),
        ("cheque", cheque_to_json(cheque)),
        ("claim_link", json_string(cheque.link)),
        ("total_amount", json_float(amount *. int_to_float(type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s))),
        ("message_template", json_object([
          ("ru", json_string("ru" · format_cheque_message)),
          ("en", json_string("en" · format_cheque_message))
        ]))
      ]))
    }
    ❌err) → {
      json_object([
        ("success", json_bool(false · json_response),
        ("error", json_string(error_to_string(err)))
      ]))
    }
  }
}

// =============================================================================
// SEND DIRECT TRANSFER
// =============================================================================

GET /api/v1/invoice/send "Send direct transfer to Telegram type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}"
  metrics("payment.invoice")
  @spec "Transfer sent": telegram_id + amount → send() → transfer_id != null

  telegram_id: str!  @query
  amount: str!       @query
  currency: str?     @query
  comment: str?      @query
  provider: str?     @query

  → {
    success: bool!,
    transfer_id: str?,
    telegram_id: int?,
    amount: float?,
    currency: str?,
    message: str?,
    error: str?
  }

@spec send_handler(
  telegram_id_str: str?,
  amount_str: str?,
  currency_str: str?,
  comment_str: str?,
  provider_str: str?
) → Response(ResponseData) {
  /// GET /api/v1/invoice/send?telegram_id=X&amount=Y&currency=Z
  given: Transfer parameters
  when: Sending direct transfer
  then: Returns transfer ID or error
}

@impl {
  log_info("[INVOICE API] Send direct transfer request")

  match telegram_id_str, amount_str {
    ☐tg_str), ☐amt_str) → {
      match int_parse(tg_str) {
        ✅telegram_id) → {
          let amount = match float_parse(amt_str) {
            ✅f) → f
            ❌_) → match int_parse(amt_str) {
              ✅i) → int_to_float(i)
              ❌_) → 0.0
            }
          }

          let currency = parse_currency(currency_str)
          let provider = match provider_str {
            ☐"cryptobot") → ☐CryptoBot)
            _ → ☐XRocket)
          }

          match send_to_type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}(telegram_id, amount, currency, comment_str, provider) {
            ✅transfer_id) → {
              json_object([
                ("success", json_bool(true · json_response),
                ("transfer_id", json_string(transfer_id)),
                ("telegram_id", json_int(telegram_id)),
                ("amount", json_float(amount)),
                ("currency", json_string(currency_to_string(currency))),
                ("message", json_string("Funds sent successfully"))
              ]))
            }
            ❌err) → {
              json_object([
                ("success", json_bool(false · json_response),
                ("error", json_string(error_to_string(err)))
              ]))
            }
          }
        }
        ❌_) → {
          json_object([
            ("success", json_bool(false · json_response),
            ("error", json_string("Invalid telegram_id"))
          ]))
        }
      }
    }
    _, _ → {
      json_object([
        ("success", json_bool(false · json_response),
        ("error", json_string("Missing required parameters: telegram_id, amount"))
      ]))
    }
  }
}

// =============================================================================
// HELPERS
// =============================================================================

@spec json_response(status: int, body: Json) → Response(ResponseData) {
  /// Create JSON HTTP response with CORS headers
  given: Status code and JSON body
  when: Returning HTTP response
  then: Returns response with proper headers
}

@impl {
  let body_string = json_to_string(body)
  let body_bytes = bytes_tree_from_string(body_string)

  response_new(status)
  · response_set_header("content-type", "application/json")
  · response_set_header("access-control-allow-origin", "*")
  · response_set_body(mist_bytes(body_bytes))
}

@spec parse_currency(s: str?) → CryptoCurrency {
  /// Parse currency string to enum
  given: Optional currency string
  when: Parsing type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} input
  then: Returns CryptoCurrency (default USDT)
}

@impl {
  match s {
    ☐str) → {
      match string_uppercase(str) {
        "TON" → TON
        "TONCOIN" → TON
        "USDT" → USDT
        "USDC" → USDC
        "NOT" → NOT
        _ → USDT
      }
    }
    ∅-> USDT
  }
}

@spec currency_to_string(c: CryptoCurrency) → str {
  /// Convert currency enum to string
  given: CryptoCurrency enum
  when: Formatting for output
  then: Returns currency code string
}

@impl {
  match c {
    TON → "TON"
    USDT → "USDT"
    USDC → "USDC"
    NOT → "NOT"
  }
}

# v8.0

# v10.0 - ML-Powered Migration
