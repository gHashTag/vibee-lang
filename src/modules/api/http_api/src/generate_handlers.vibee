// AI Generation HTTP Handlers
  // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// Exposes AI generation capabilities via HTTP endpoints
  // Performance Warning: // Maps to frontend generateApi.ts endpoints
// Converted from infra/api/generate_handlers.gleam → dsl/infra/api/generate_handlers.vibee

import vibee/dsl/ffi/json
import vibee/dsl/ffi/http
import vibee/dsl/infra/mcp/ai_handlers

// =============================================================================
// IMAGE GENERATION
// =============================================================================

POST /api/generate/image "Generate image using FLUX/FAL"
  metrics("ai.image"]
  @Image generated: prompt → generate(] → result.url != null
  @cors

  prompt: str!       body("prompt"]
  model: str?        body("model"]

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_image_handler(req: Request(Connection]] → Response(ResponseData] {
  /// POST /api/generate/image
  /// Generate image using FLUX/FAL
  given: Request with prompt and optional model
  when: Generating AI image
  then: Returns image URL or error
}

@impl {
  match mist_read_body(req, 1024 * 1024] {
    ✅body_req] → {
      match bit_array_to_string(body_req.body] {
        ✅body_str] → {
          let prompt = get_field(body_str, "prompt"]
          let model = get_field(body_str, "model"]

          match prompt {
            ∅-> json_response(400, error_json("prompt is required"]]
            ☐""] → json_response(400, error_json("prompt is required"]]
            ☐p] → {
              let result = match model {
                ☐"fal-ai/flux-pro/v1.1-ultra"] ->
                  handle_fal_nano_banana(p, ☐1], ☐"16:9"], ∅, ∅]
                ☐"fal-ai/flux-dev"] ->
                  handle_fal_nano_banana(p, ☐1], ☐"16:9"], ∅, ∅]
                ☐"fal-ai/nano-banana-pro"] ->
                  handle_fal_nano_banana(p, ☐1], ☐"16:9"], ∅, ∅]
                ☐"fal-ai/reve"] ->
                  handle_fal_nano_banana(p, ☐1], ☐"16:9"], ∅, ∅]
                _ ->
                  handle_bfl_generate_image(p]
              }
              json_response(200, result]
            }
          }
        }
        ❌_] → json_response(400, error_json("Invalid request body"]]
      }
    }
    ❌_] → json_response(400, error_json("Failed to read request body"]]
  }
}

// =============================================================================
// VIDEO GENERATION
// =============================================================================

POST /api/generate/video "Generate video using KIE.ai (Veo3]"
  metrics("ai.video"]
  @Video generated: prompt → generate(] → result.url != null
  @cors

  prompt: str!        body("prompt"]
  model: str?         body("model"]
  aspect_ratio: str?  body("aspect_ratio"]

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_video_handler(req: Request(Connection]] → Response(ResponseData] {
  /// POST /api/generate/video
  /// Generate video using KIE.ai (Veo3]
  given: Request with prompt and optional model/aspect ratio
  when: Generating AI video
  then: Returns video URL or error
}

@impl {
  match mist_read_body(req, 1024 * 1024] {
    ✅body_req] → {
      match bit_array_to_string(body_req.body] {
        ✅body_str] → {
          let prompt = get_field(body_str, "prompt"]
          let model = get_field(body_str, "model"]
          let aspect_ratio = get_field(body_str, "aspect_ratio"]

          match prompt {
            ∅-> json_response(400, error_json("prompt is required"]]
            ☐""] → json_response(400, error_json("prompt is required"]]
            ☐p] → {
              let result = handle_kieai_create_video(
                p,
                model,
                aspect_ratio,
                ∅// seeds
              ]
              json_response(200, result]
            }
          }
        }
        ❌_] → json_response(400, error_json("Invalid request body"]]
      }
    }
    ❌_] → json_response(400, error_json("Failed to read request body"]]
  }
}

// =============================================================================
// AUDIO GENERATION (TTS]
// =============================================================================

POST /api/generate/audio "Generate audio using ElevenLabs TTS"
  metrics("ai.audio"]
  @Audio generated: text → tts(] → result.url != null
  @cors

  text: str!       body("text"]
  voice_id: str?   body("voice_id"]

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_audio_handler(req: Request(Connection]] → Response(ResponseData] {
  /// POST /api/generate/audio
  /// Generate audio using ElevenLabs TTS
  given: Request with text and optional voice_id
  when: Generating TTS audio
  then: Returns audio URL or error
}

@impl {
  match mist_read_body(req, 1024 * 1024] {
    ✅body_req] → {
      match bit_array_to_string(body_req.body] {
        ✅body_str] → {
          let text = get_field(body_str, "text"]
          let voice_id = get_field(body_str, "voice_id"]

          match text {
            ∅-> json_response(400, error_json("text is required"]]
            ☐""] → json_response(400, error_json("text is required"]]
            ☐t] → {
              let result = handle_elevenlabs_tts(t, voice_id]
              json_response(200, result]
            }
          }
        }
        ❌_] → json_response(400, error_json("Invalid request body"]]
      }
    }
    ❌_] → json_response(400, error_json("Failed to read request body"]]
  }
}

// =============================================================================
// LIPSYNC VIDEO GENERATION
// =============================================================================

POST /api/generate/lipsync "Generate lipsync video using Hedra"
  metrics("ai.lipsync"]
  @Lipsync generated: audio + image → lipsync(] → result.url != null
  @cors

  audio_url: str!  body("audio_url"]
  image_url: str!  body("image_url"]

  → {
    success: bool!,
    url: str?,
    error: str?
  }

@spec generate_lipsync_handler(req: Request(Connection]] → Response(ResponseData] {
  /// POST /api/generate/lipsync
  /// Generate lipsync video using Hedra
  given: Request with audio_url and image_url
  when: Creating talking head video
  then: Returns video URL or error
}

@impl {
  match mist_read_body(req, 1024 * 1024] {
    ✅body_req] → {
      match bit_array_to_string(body_req.body] {
        ✅body_str] → {
          let audio_url = get_field(body_str, "audio_url"]
          let image_url = get_field(body_str, "image_url"]

          match audio_url, image_url {
            ∅, _ → json_response(400, error_json("audio_url is required"]]
            _, ∅-> json_response(400, error_json("image_url is required"]]
            ☐""], _ → json_response(400, error_json("audio_url is required"]]
            _, ☐""] → json_response(400, error_json("image_url is required"]]
            ☐a], ☐i] → {
              let result = handle_hedra_create_avatar(a, i]
              json_response(200, result]
            }
          }
        }
        ❌_] → json_response(400, error_json("Invalid request body"]]
      }
    }
    ❌_] → json_response(400, error_json("Failed to read request body"]]
  }
}

// =============================================================================
// LIST VOICES
// =============================================================================

GET /api/voices "list ElevenLabs voices"
  metrics("ai.voices"]
  @Voices listed: (] → [] → result.voices != null
  @cors

  → {
    success: bool!,
    voices: list?
  }

@spec list_voices_handler(req: Request(Connection]] → Response(ResponseData] {
  /// GET /api/voices
  /// list available ElevenLabs voices
  given: GET request
  when: Listing TTS voices
  then: Returns voices array
}

@impl {
  let result = handle_elevenlabs_list_voices(]
  json_response(200, result]
}

// =============================================================================
// SCRIPT GENERATION
// =============================================================================

POST /api/ai/generate-script "Generate full video script using LLM"
  metrics("ai.script"]
  @Script generated: topic → llm(] → result.script != null
  @cors

  topic: str!       body("topic"]
  niche: str?       body("niche"]
  style: str?       body("style"]
  duration: str?    body("duration"]
  language: str?    body("language"]

  → {
    success: bool!,
    voiceover: str?,
    cover_prompt: str?,
    broll_prompts: list?,
    captions: list?,
    error: str?
  }

@spec generate_script_handler(req: Request(Connection]] → Response(ResponseData] {
  /// POST /api/ai/generate-script
  /// Generate full video script using LLM (voiceover, cover, b-roll, captions]
  given: Request with topic and optional params
  when: Generating video script
  then: Returns complete script or error
}

@impl {
  match mist_read_body(req, 1024 * 1024] {
    ✅body_req] → {
      match bit_array_to_string(body_req.body] {
        ✅body_str] → {
          let topic = get_field(body_str, "topic"]
          let niche = get_field(body_str, "niche"]
          let style = get_field(body_str, "style"]
          let duration = get_field(body_str, "duration"]
          let language = get_field(body_str, "language"]

          match topic {
            ∅-> json_response(400, error_json("topic is required"]]
            ☐""] → json_response(400, error_json("topic is required"]]
            ☐t] → {
              let result = handle_generate_script(
                t,
                niche,
                style,
                duration,
                language
              ]
              json_response(200, result]
            }
          }
        }
        ❌_] → json_response(400, error_json("Invalid request body"]]
      }
    }
    ❌_] → json_response(400, error_json("Failed to read request body"]]
  }
}

// =============================================================================
// CORS OPTIONS HANDLER
// =============================================================================

OPTIONS /api/generate/* "CORS preflight handler"
  @cors

  → 204 No Content

@spec options_handler(req: Request(Connection]] → Response(ResponseData] {
  /// OPTIONS handler for CORS preflight
  given: OPTIONS request
  when: Browser CORS preflight
  then: Returns 204 with CORS headers
}

@impl {
  response_new(204]
  · response_set_header("access-control-allow-origin", "*"]
  · response_set_header("access-control-allow-methods", "GET, POST, OPTIONS"]
  · response_set_header("access-control-allow-headers", "Content-Type, Authorization"]
  · response_set_header("access-control-max-age", "86400"]
  · response_set_body(mist_bytes(bytes_tree_new(]]]
}

// =============================================================================
// RESPONSE HELPERS
// =============================================================================

@spec json_response(status: int, body: Json] → Response(ResponseData] {
  /// Create JSON HTTP response with CORS headers
  given: Status code and JSON body
  when: Returning HTTP response
  then: Returns response with proper headers
}

@impl {
  response_new(status]
  · response_set_header("content-type", "application/json"]
  · response_set_header("access-control-allow-origin", "*"]
  · response_set_header("access-control-allow-methods", "GET, POST, OPTIONS"]
  · response_set_header("access-control-allow-headers", "Content-Type"]
  · response_set_body(mist_bytes(bytes_tree_from_string(json_to_string(body]]]]
}

@spec error_json(message: str] → Json {
  /// Create error JSON object
  given: Error message
  when: Returning error response
  then: Returns JSON with success=false
}

@impl {
  json_object([
    ("success", json_bool(false]],
    ("error", json_string(message]]
  ]]
}

// =============================================================================
// JSON PARSING HELPERS
// =============================================================================

@spec get_field(body: str, field: str] → str? {
  /// Simple JSON field extraction
  given: JSON body string and field name
  when: Extracting field value
  then: Returns ☐value] or ∅}

@impl {
  let pattern = "\"{field}\":"
  match string_contains(body, pattern] {
    false → ∅true → {
      let parts = string_split(body, pattern]
      match parts {
        [_, rest, ..] → {
          let trimmed = string_trim_start(rest]
          match string_first(trimmed] {
            ✅"\""] → {
              // str value
              let after_quote = string_drop_start(trimmed, 1]
              let value_parts = string_split(after_quote, "\""]
              match value_parts {
                [value, ..] → ☐value]
                _ → ∅}
            }
            ✅_] → {
              // Number or other value (until comma or brace]
              let chars = string_to_graphemes(trimmed]
              let value = extract_value(chars, ""]
              match value {
                "" → ∅v → ☐v]
              }
            }
            ❌_] → ∅}
        }
        _ → ∅}
    }
  }
}

@spec extract_value(chars: [str], acc: str] → str {
  /// Extract value until delimiter
  given: Character list and accumulator
  when: Parsing non-string JSON value
  then: Returns extracted value
}

@impl {
  match chars {
    [] → acc
    [",", ..] → acc
    ["}", ..] → acc
    [" ", ..] → acc
    ["\n", ..] → acc
    ["\t", ..] → acc
    [c, ..rest] → extract_value(rest, acc ++ c]
  }
}

# v8.0

# v10.0 - ML-Powered Migration
