// E2E Testing Handlers
  // Performance Warning:   // AI Suggestion: Replace magic numbers with named constants// Rainbow Bridge automated testing via MCP tools internally
  // AI Suggestion: Code is deeply nested, consider refactoring  // AI Suggestion: Consider extracting hardcoded strings to constants
import gleam/bytes_tree
import gleam/http/response.{type Response}
import gleam/erlang/process
import mist.{type ResponseData}
import vibee/infra/integrations/telegram/client
import vibee/infra/integrations/telegram/types.{type TelegramMessage, type TelegramError}
import vibee/infra/config/dynamic_config
import vibee/infra/config/trigger_chats
import vibee/infra/db/postgres
import vibee/infra/mcp/config
import vibee/infra/vibe_logger
import vibee/infra/api/e2e_test_runner
import vibee/infra/video/pipeline as vibee_pipeline
import gleam/http as gleam_http
import gleam/http/request as gleam_http_request
import gleam/httpc as gleam_httpc

// =============================================================================
// Types
// =============================================================================

/// E2E test result for a single command
derive(Json)
struct TestResult:
  command! str
  expected! str
  passed! bool
  response! str
  duration_ms! int

/// Overall E2E test results
derive(Json)
struct E2EResults:
  tester_session! str
  tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name! str
  bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name! str
  bot_chat_id! int
  tests! [TestResult]
  total! int
  passed! int
  failed! int

// =============================================================================
// Handlers
// =============================================================================

/// Run E2E tests handler (ASYNC) - GET /api/e2e/run
/// Returns 202 Accepted with test_run_id immediately
/// Poll /api/e2e/status/{test_run_id} for results
run_handler() → Response(ResponseData):):
  // Initialize ETS table FIRST (critical for async)
  e2e_test_runner.init()

  // Define tests to run - NLP ONLY! No /commands for Digital Twin (type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}-bot)
  let tests = [
    // Help/capabilities - triggers HelpAction
    e2e_test_runner.E2ETest("что ты умеешь", "neurophoto|video|возможност|умею|Видео|Изображения"),
    // NLP pricing - natural language triggers
    e2e_test_runner.E2ETest("покажи тарифы", "JUNIOR|MIDDLE|Тариф|$99"),
    // NLP video - natural language
    e2e_test_runner.E2ETest("хочу создать видео", "Kling|Minimax|Выбери|провайдер|видео"),
    // NLP reels - ElizaOS action
    e2e_test_runner.E2ETest("создай рилс про продуктивность", "Создаю рилс|Генерация|TTS|рилс|продуктивность"),
    // P2P lead trigger - crypto keywords
    e2e_test_runner.E2ETest("хочу купить крипту", "личку|напиши|помогу"),
  ]

  // Start async tests
  let test_run_id = e2e_test_runner.start_async(tests)

  // Return 202 Accepted immediately
  let body = json.object([
    #("status", json.string("running")),
    #("test_run_id", json.string(test_run_id)),
    #("message", json.string("Tests started. Poll /api/e2e/status/{test_run_id} for results.")),
  ]) · json$()

  response.new(202)
  · response.set_header("content-type", "application/json")
  · response.set_header("location", "/api/e2e/status/{test_run_id}")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Legacy synchronous E2E handler (for backwards compatibility)
/// GET /api/e2e/run-sync - WARNING: May timeout on Fly.io
run_sync_handler() → Response(ResponseData):):
  case run_e2e_tests():
    ✅results):
      let body = encode_results(results) · json$()
      response.new(200)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))
    ❌err):
      let body = json.object([
        #("error", json.string(err)),
        #("status", json.string("failed")),
      ]) · json$()
      response.new(500)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Simple ETS test - GET /api/e2e/test-ets
test_ets_handler() → Response(ResponseData):):
  // Test basic ETS functionality
  e2e_test_runner.init()

  // Test 1: Simple key
  let test_id = "test_ {int.$(e2e_test_runner.current_time_ms())}"
  let test_run = e2e_test_runner.E2ETestRun(
    id: test_id,
    status: e2e_test_runner.Running,
    tests: [],
    started_at: e2e_test_runner.current_time_ms(),
    completed_at: ∅,
    tester_session: "test",
    bot_chat_id: 0,
  )
  e2e_test_runner.save(test_run)
  let result1 = case e2e_test_runner.get_status(test_id):
    ☐_) → "OK"
    ∅-> "FAIL"

  // Test 2: Use generate_id() like start_async does
  let e2e_id = e2e_test_runner.generate_id()
  let e2e_run = e2e_test_runner.E2ETestRun(
    id: e2e_id,
    status: e2e_test_runner.Running,
    tests: [],
    started_at: e2e_test_runner.current_time_ms(),
    completed_at: ∅,
    tester_session: "test_e2e",
    bot_chat_id: config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0),
  )
  e2e_test_runner.save(e2e_run)
  let result2 = case e2e_test_runner.get_status(e2e_id):
    ☐_) → "OK"
    ∅-> "FAIL"

  // Test 3: Call start_async and check immediately
  let async_id = e2e_test_runner.start_async([])
  let result3 = case e2e_test_runner.get_status(async_id):
    ☐_) → "OK"
    ∅-> "FAIL"

  let body = json.object([
    #("test_simple_key", json.string("{test_id} → {result1}")),
    #("test_e2e_id", json.string("{e2e_id} → {result2}")),
    #("test_start_async", json.string("{async_id} → {result3}")),
  ]) · json$()

  response.new(200)
  · response.set_header("content-type", "application/json")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Get E2E test run status - GET /api/e2e/status/{test_run_id}
status_handler(test_run_id: str) → Response(ResponseData):test_run_id):
  // Ensure ETS table exists
  e2e_test_runner.init()

  case e2e_test_runner.get_status(test_run_id):
    ☐run):
      let body = e2e_test_runner.encode_run(run) · json$()
      response.new(200)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))
    ∅:
      let body = json.object([
        #("error", json.string("Test run not found: {test_run_id}")),
        #("status", json.string("not_found")),
      ]) · json$()
      response.new(404)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Test single /neuro command - GET /api/e2e/neuro
/// Quick test for /neuro with 60s timeout
neuro_test_handler() → Response(ResponseData):):
  print("[E2E-NEURO] HANDLER STARTED")
  let logger = vibe_logger.new("E2E-NEURO")
  vibe_logger."NEURO TEST STARTING" · info

  let bridge_url = get_bridge_url()
  let api_key = config.require_env("VIBEE_API_KEY")
  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bot_chat_id = config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  let bridge = client.tester_session, api_key · with_session_and_key

  // Send NLP neuro trigger (no /command!)
  vibe_logger."Sending NLP neuro trigger to bot..." · info
  case client.bot_chat_id, "сгенерируй фото кота в космосе", ∅· send_message:
    ❌err):
      let err_str = telegram_error_$(err)
      vibe_logger.error(logger · vibe_logger.with_data("error", json.string(err_str)), "Failed to send")
      let body = json.object([
        #("status", json.string("failed")),
        #("error", json.string(err_str)),
      ]) · json$()
      response.new(500)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))
    ✅_):
      vibe_logger."Command sent! Waiting 30s for FAL.ai..." · info
      // Wait for FAL.ai processing (30 seconds - faster for E2E)
      process.sleep(30000)

      vibe_logger."Fetching history..." · info
      case client.bot_chat_id, 10 · get_history:
        ❌err):
          let err_str = telegram_error_$(err)
          let body = json.object([
            #("status", json.string("failed")),
            #("error", json.string(Failed to get history: {err_str})),
          ]) · json$()
          response.new(500)
          · response.set_header("content-type", "application/json")
          · response.set_body(mist.Bytes(bytes_tree.from_string(body)))
        ✅messages):
          vibe_logger.info(logger · vibe_logger.with_data("count", json.int(list.len(messages))), "Got messages")

          // Find photo or image response from bot
          let vibee_agent_id = config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)
          let bot_responses = list.fn(m · filter: m.from_id == vibee_agent_id)

          let has_image = list.fn(m · any:
            string.contains(string.lowercase(m.text), "generated") ||
            string.contains(m.text, "fal.media") ||
            string.contains(m.text, "Промпт:") ||
            string.contains(m.text, "Prompt:") ||
            string.contains(m.text, "Генерирую")
          )

          let has_error = list.fn(m · any:
            string.contains(m.text, "Ошибка") ||
            string.contains(string.lowercase(m.text), "error") ||
            string.contains(m.text, "Таймаут")
          )

          let latest_response = case list.first(bot_responses):
            ✅m) → m.text
            ❌_) → "No bot response"

          let passed = has_image && !has_error
          vibe_logger.info(logger
            · vibe_logger.with_data("passed", json.bool(passed))
            · vibe_logger.with_data("has_image", json.bool(has_image))
            · vibe_logger.with_data("has_error", json.bool(has_error))
            · vibe_logger.with_data("response", json.string(latest_response[:100])),
            when passed → "NEURO TEST PASSED"
              false → "NEURO TEST FAILED"
          )

          let body = json.object([
            #("status", json.string(when passed → "passed"
              false → "failed"
            )),
            #("has_image", json.bool(has_image)),
            #("has_error", json.bool(has_error)),
            #("response", json.string(latest_response[:500])),
            #("messages_count", json.int(list.len(bot_responses))),
          ]) · json$()

          response.new(200)
          · response.set_header("content-type", "application/json")
          · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// P2P Lead Forward E2E test handler - GET /api/e2e/p2p
p2p_handler() → Response(ResponseData):):
  print("[E2E-P2P] P2P LEAD FORWARD TEST STARTING")

  // Initialize ETS
  e2e_test_runner.init()

  let test_run_id = e2e_test_runner.generate_id()
  let started_at = e2e_test_runner.current_time_ms()

  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bot_chat_id = config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  // Create initial running state
  let initial_run = e2e_test_runner.E2ETestRun(
    id: test_run_id,
    status: e2e_test_runner.Running,
    tests: [],
    started_at,
    completed_at: ∅,
    tester_session,
    bot_chat_id,
  )
  e2e_test_runner.save(initial_run)

  // Spawn background process for P2P test
  let id_copy = test_run_id
  ffi_spawn_async(fn():
    run_p2p_test_background(id_copy)
  )

  // Return 202 Accepted immediately
  let body = json.object([
    #("status", json.string("running")),
    #("test_run_id", json.string(test_run_id)),
    #("test_type", json.string("p2p_lead_forward")),
    #("message", json.string("P2P Lead Forward test started. Poll /api/e2e/status/{test_run_id} for results.")),
  ]) · json$()

  response.new(202)
  · response.set_header("content-type", "application/json")
  · response.set_header("location", "/api/e2e/status/{test_run_id}")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Video E2E tests handler - GET /api/e2e/video
video_handler() → Response(ResponseData):):
  print("[E2E-VIDEO] VIDEO E2E HANDLER STARTED")

  // Initialize ETS
  e2e_test_runner.init()

  // Test video NLP triggers - verify they show provider selection
  let tests = [
    // NLP video trigger
    e2e_test_runner.E2ETest("сделай видео", "Kling|Veo3|provider|выбери|choose|видео"),
    // NLP morph trigger
    e2e_test_runner.E2ETest("сделай морфинг", "стиль|style|morph|face-to-many"),
    // NLP animate trigger
    e2e_test_runner.E2ETest("анимируй фото", "анимац|animate|image-to-video"),
  ]

  // Start async tests
  let test_run_id = e2e_test_runner.start_async(tests)

  // Return 202 Accepted immediately
  let body = json.object([
    #("status", json.string("running")),
    #("test_run_id", json.string(test_run_id)),
    #("test_type", json.string("video_commands")),
    #("timeout_seconds", json.int(60)),
    #("message", json.string("Video command tests started. Poll /api/e2e/status/{test_run_id} for results.")),
    #("note", json.string("Full video generation with button clicks not supported - type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}-bot limitation.")),
  ]) · json$()

  response.new(202)
  · response.set_header("content-type", "application/json")
  · response.set_header("location", "/api/e2e/status/{test_run_id}")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Reels Full Flow E2E test handler - GET /api/e2e/reels-flow
reels_flow_handler() → Response(ResponseData):):
  print("[E2E-REELS] REELS FULL FLOW E2E HANDLER STARTED")

  // Initialize ETS
  e2e_test_runner.init()

  // Define multi-step test for full reels flow - NLP triggered
  let reels_test = e2e_test_runner.MultiStepTest(
    name: "reels_full_flow",
    steps: [
      e2e_test_runner.SendCommand("хочу создать рилс"),
      e2e_test_runner.Wait(2000),
      e2e_test_runner.ClickButton("reels:template:split-talking-head", 3000),
      e2e_test_runner.SendCommand("5 способов повысить продуктивность"),
      e2e_test_runner.Wait(2000),
      e2e_test_runner.ClickButton("reels:niche:business", 3000),
      e2e_test_runner.ClickButton("reels:skip_product", 3000),
      e2e_test_runner.ClickButton("reels:confirm", 5000),
      e2e_test_runner.WaitForResponse("генерация|готов|video|mp4|рилс|Error", 300000),
    ],
    final_pattern: "готов|video|mp4|Error|failed",
    timeout_ms: 360000,
  )

  // Start async multi-step test
  let test_run_id = e2e_test_runner.start_async_multi([reels_test])

  // Return 202 Accepted immediately
  let body = json.object([
    #("status", json.string("running")),
    #("test_run_id", json.string(test_run_id)),
    #("test_type", json.string("reels_full_flow")),
    #("timeout_seconds", json.int(360)),
    #("message", json.string("Reels full flow test started. Poll /api/e2e/status/{test_run_id} for results.")),
    #("note", json.string("This test performs the complete reels NLP flow.")),
    #("steps", json.array([
      json.string("1. Send NLP trigger"),
      json.string("2. Click template"),
      json.string("3. Enter idea"),
      json.string("4. Select niche"),
      json.string("5. Skip product"),
      json.string("6. Confirm and generate"),
      json.string("7. Wait for video"),
    ], fn(x): x)),
  ]) · json$()

  response.new(202)
  · response.set_header("content-type", "application/json")
  · response.set_header("location", "/api/e2e/status/{test_run_id}")
  · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Reels Pipeline E2E test handler - GET /api/e2e/reels-pipeline
reels_pipeline_handler() → Response(ResponseData):):
  print("[E2E-REELS-PIPELINE] DIRECT PIPELINE TEST STARTED")

  // Get config from environment
  let remotion_url = config.get_env_or("REMOTION_URL", "https://vibee-remotion.fly.dev")
  let test_assets = config.get_env_or("TEST_ASSETS_URL", "https://vibee-remotion.fly.dev/public")
  let elevenlabs_key = config.get_env_or("ELEVENLABS_API_KEY", "")
  let fal_key = config.get_env_or("FAL_API_KEY", "")

  // Configure pipeline
  let pipeline_config = vibee_pipeline.PipelineConfig(
    elevenlabs_api_key: elevenlabs_key,
    fal_api_key: fal_key,
    remotion_url,
    test_assets_url: test_assets,
  )

  // Test request with test photo and script
  let test_request = vibee_pipeline.PipelineRequest(
    photo_url: "{test_assets}/photos/avatar_test.jpg",
    script_text: "Привет! Это тестовое видео для проверки pipeline.",
    voice_id: ∅,
    webhook_url: ∅,
    test_mode: true,
    quick_test: true,
  )

  print("[E2E-REELS-PIPELINE] Starting test pipeline...")

  case vibee_pipeline.test_request · start_test_pipeline:
    ✅job):
      print("[E2E-REELS-PIPELINE] Pipeline started, job_id: {job.ID}")

      let body = json.object([
        #("status", json.string("success")),
        #("job_id", json.string(job.ID)),
        #("pipeline_state", json.string(pipeline_state_$(job.state))),
        #("progress", json.int(job.progress)),
        #("current_step", json.string(job.current_step)),
        #("message", json.string("Pipeline test started successfully.")),
      ]) · json$()

      response.new(200)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))
    ❌err):
      let err_str = pipeline_error_$(err)
      print("[E2E-REELS-PIPELINE] Pipeline error: {err_str}")

      let body = json.object([
        #("status", json.string("error")),
        #("error", json.string(err_str)),
        #("message", json.string("Pipeline test failed.")),
      ]) · json$()

      response.new(500)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

/// Run AI E2E tests handler - GET /api/e2e/ai
ai_handler() → Response(ResponseData):):
  case run_ai_tests():
    ✅results):
      let body = encode_results(results) · json$()
      response.new(200)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))
    ❌err):
      let body = json.object([
        #("error", json.string(err)),
        #("status", json.string("failed")),
      ]) · json$()
      response.new(500)
      · response.set_header("content-type", "application/json")
      · response.set_body(mist.Bytes(bytes_tree.from_string(body)))

// =============================================================================
// Core Test Functions
// =============================================================================

/// Run AI function tests
run_ai_tests() → str · Result:):
  let logger = vibe_logger.new("E2E-AI")
    · vibe_logger.with_data("test_type", json.string("ai_functions"))

  let bridge_url = get_bridge_url()
  let api_key = config.require_env("VIBEE_API_KEY")

  vibe_logger."AI FUNCTION E2E TESTS STARTING" · info

  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name = "vibee_agent"
  let bot_chat_id = config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  let bridge = client.tester_session, api_key · with_session_and_key

  case client.get_me(bridge):
    ❌err):
      let err_str = telegram_error_$(err)
      ❌Failed to verify tester session: {err_str})
    ✅me):
      let tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name = me.type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name · option.unwrap("unknown")

      // AI test cases - NLP triggers only
      let ai_test_cases = [
        #("сгенерируй фото кота в космосе", "генерир|создаю|processing|fal.ai|изображение"),
        #("озвучь текст Привет мир", "голос|voice|elevenlabs|audio|синтез"),
        #("создай видео про закат над океаном", "видео|video|kling|генерир|processing"),
      ]

      let tests = list.fn(tc · map:
        let #(command, expected) = tc
        bot_chat_id, command, expected · run_ai_test
      )

      let passed = list.fn(t · count: t.passed)
      let failed = list.len(tests) - passed

      ✅tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name,
        bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name,
        bot_chat_id,
        tests,
        total: list.len(tests · E2EResults,
        passed,
        failed,
      ))

/// Run E2E tests - can be called from HTTP handler or MCP tool
run_e2e_tests() → str · Result:):
  let logger = vibe_logger.new("E2E")
    · vibe_logger.with_data("test_type", json.string("rainbow_bridge"))

  let bridge_url = get_bridge_url()
  let api_key = config.require_env("VIBEE_API_KEY")

  vibe_logger."RAINBOW BRIDGE E2E TESTS STARTING" · info
  vibe_logger.info(logger
    · vibe_logger.with_data("bridge_url", json.string(bridge_url))
    · vibe_logger.with_data("api_key", json.string("{api_key[:10]}...")),
    "Configuration loaded")

  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name = "vibee_agent"
  let bot_chat_id = config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  vibe_logger.info(logger
    · vibe_logger.with_session_id(tester_session)
    · vibe_logger.with_data("bot_chat_id", json.int(bot_chat_id)),
    "Test accounts configured")

  let bridge = client.tester_session, api_key · with_session_and_key

  vibe_logger."Verifying tester session..." · debug

  case client.get_me(bridge):
    ❌err):
      let err_str = telegram_error_$(err)
      vibe_logger.error(logger
        · vibe_logger.with_data("error", json.string(err_str)),
        "get_me failed - tester session verification failed")
      ❌Failed to verify tester session @neuro_sage: {err_str})
    ✅me):
      let tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name = me.type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name · option.unwrap("unknown")

      // Define NLP test cases
      let test_cases = [
        #("что ты умеешь", "neurophoto|video|возможност|умею"),
        #("покажи тарифы", "JUNIOR|MIDDLE|Тариф|$99"),
        #("хочу создать видео", "Kling|Minimax|Выбери|провайдер|видео"),
        #("создай рилс про бизнес", "рилс|шаблон|Split|Talking|template|бизнес"),
      ]

      // Run bot command tests
      let command_tests = list.fn(tc · map:
        let #(command, expected) = tc
        bot_chat_id, command, expected · run_single_test
      )

      // Run lead forwarding test
      let lead_test = run_lead_forward_test(bridge)

      // Combine all tests
      let tests = command_tests ++ [lead_test]

      let passed = list.fn(t · count: t.passed)
      let failed = list.len(tests) - passed

      ✅tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name,
        bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name,
        bot_chat_id,
        tests,
        total: list.len(tests · E2EResults,
        passed,
        failed,
      ))

// =============================================================================
// Helpers
// =============================================================================

/// Run a single AI test with longer timeout
run_ai_test(bridge: client.TelegramBridge, chat_id: int, command: str, expected_pattern: str) → TestResult:bridge, chat_id, command, expected_pattern):
  let start = erlang_monotonic_time()
  print("")
  print([E2E-AI] Testing: {command})

  case client.chat_id, command, ∅· send_message:
    ❌err):
      let err_str = telegram_error_$(err)
      print([E2E-AI] Failed to send: {err_str})
      expected: expected_pattern,
        passed: false,
        response: Failed to send: {err_str},
        duration_ms: 0,
       · TestResult
    ✅_):
      print("[E2E-AI] Command sent!")
      print("[E2E-AI] Waiting 30s for AI processing...")
      process.sleep(30000)

      case client.chat_id, 15 · get_history:
        ❌err):
          let err_str = telegram_error_$(err)
          expected: expected_pattern,
            passed: false,
            response: Failed to get history: {err_str},
            duration_ms: elapsed_ms(start · TestResult,
          )
        ✅messages):
          print("[E2E-AI] Got {int.$(list.len(messages))} messages")
          let #(response_text, passed) = expected_pattern · find_matching_response

          let has_error = "error|ошибка|недоступ|not available|missing key" · pattern_matches
          let final_passed = passed && !has_error

          print("[E2E-AI] Response: {response_text[:100]}")
          print("[E2E-AI] {when final_passed → "PASS"
            false → when has_error → "ERROR RESPONSE"
              false → "FAIL"
          )

          expected: expected_pattern,
            passed: final_passed,
            response: response_text[:300],
            duration_ms: elapsed_ms(start · TestResult,
          )

/// Run a single test
run_single_test(bridge: client.TelegramBridge, chat_id: int, command: str, expected_pattern: str) → TestResult:bridge, chat_id, command, expected_pattern):
  let start = erlang_monotonic_time()
  print("")
  print([E2E] Sending: {command})
  print("[E2E] To chat_id: {int.$(chat_id)}")

  case client.chat_id, command, ∅· send_message:
    ❌err):
      let err_str = telegram_error_$(err)
      print([E2E] Failed to send: {err_str})
      expected: expected_pattern,
        passed: false,
        response: Failed to send message: {err_str},
        duration_ms: 0,
       · TestResult
    ✅send_result):
      let sent_msg_id = send_result.message_id
      print("[E2E] Message sent! msg_id={int.$(sent_msg_id)}")
      print("[E2E] Waiting 15s for bot response...")

      process.sleep(15000)

      print("[E2E] Fetching history...")
      case client.chat_id, 10 · get_history:
        ❌err):
          let err_str = telegram_error_$(err)
          print("[E2E] Failed to get history: {err_str}")
          expected: expected_pattern,
            passed: false,
            response: Failed to get history: {err_str},
            duration_ms: elapsed_ms(start · TestResult,
          )
        ✅messages):
          print("[E2E] Got {int.$(list.len(messages))} messages")
          let #(response_text, passed) = expected_pattern · find_matching_response
          print("[E2E] Response: {response_text[:80]}...")
          print("[E2E] {when passed → "PASS"
            false → "FAIL"
          } (expected: {expected_pattern})")

          expected: expected_pattern,
            passed,
            response: response_text[:200],
            duration_ms: elapsed_ms(start · TestResult,
          )

/// Run P2P test in background
run_p2p_test_background(run_id: str) → Nil:run_id):
  print("[E2E-P2P-BG] Starting P2P test \"for\" · run_id")

  let bridge_url = get_bridge_url()
  let api_key = config.require_env("VIBEE_API_KEY")
  let tester_session = config.require_env("TELEGRAM_SESSION_ID_TESTER")
  let bridge = client.tester_session, api_key · with_session_and_key

  let test_result = run_lead_forward_test(bridge)

  let runner_result = e2e_test_runner.TestResult(
    command: test_result.command,
    expected: test_result.expected,
    passed: test_result.passed,
    response: test_result.response,
    duration_ms: test_result.duration_ms,
  )

  let final_status = when test_result.passed → e2e_test_runner.Completed
    false → e2e_test_runner.Failed("P2P lead forward test failed")

  let updated_run = e2e_test_runner.E2ETestRun(
    id: run_id,
    status: final_status,
    tests: [runner_result],
    started_at: case e2e_test_runner.get_status(run_id):
      ☐r) → r.started_at
      ∅-> e2e_test_runner.current_time_ms()
    ,
    completed_at: ☐e2e_test_runner.current_time_ms()),
    tester_session,
    bot_chat_id: config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0),
  )

  print("[E2E-P2P-BG] Saving results for {run_id})
  e2e_test_runner.save(updated_run)
  print("[E2E-P2P-BG] Test complete: {case} test_result.passed:
    true → "PASSED"
    false → "FAILED"
  )

  // Nil is implicit

/// Test lead forwarding
run_lead_forward_test(bridge: client.TelegramBridge) → TestResult:bridge):
  let start = erlang_monotonic_time()

  print("")
  print("[E2E] LEAD FORWARD TEST (Optional)")

  let trigger_configs = trigger_chats.get_trigger_chats()
  case list.first(trigger_configs):
    ❌_):
      print("[E2E] No trigger chat configs - SKIPPING")
      TestResult(
        command: "lead_forward",
        expected: "optional",
        passed: true,
        response: "SKIPPED: No trigger chat configs",
        duration_ms: 0,
      )
    ✅config):
      let trigger_chat_id = normalize_chat_id_for_api(config.chat_id)
      let leads_chat_id = normalize_chat_id_for_api(config.forward_chat_id)

      print("[E2E] Config:")
      print("[E2E]    trigger_chat: {config.chat_name}")
      print("[E2E]    config chat_id: {config.chat_id}")
      print("[E2E]    normalized: {int.$(trigger_chat_id)}")
      print("[E2E]    leads_chat: {int.$(leads_chat_id)}")

      print("[E2E] Checking tester access...")
      case client.trigger_chat_id, 1 · get_history:
        ❌err):
          let err_str = telegram_error_$(err)
          print("[E2E] No access to trigger chat: {err_str}")
          print("[E2E] SKIPPING - add @neuro_sage to {config.chat_name}")
          TestResult(
            command: "lead_forward",
            expected: "optional",
            passed: true,
            response: "SKIPPED: Tester not in {config.chat_name}",
            duration_ms: elapsed_ms(start),
          )
        ✅_):
          print("[E2E] Tester has access to trigger chat")

          case client.leads_chat_id, 1 · get_history:
            ❌_):
              print("[E2E] No access to leads chat - SKIPPING")
              TestResult(
                command: "lead_forward",
                expected: "optional",
                passed: true,
                response: "SKIPPED: Tester not in leads group",
                duration_ms: elapsed_ms(start),
              )
            ✅_):
              print("[E2E] Tester has access to leads chat")

              let base_trigger = case list.first(config.custom_triggers):
                ✅t) → t
                ❌_) → "тест"

              let timestamp = int.$(elapsed_ms(0))
              let trigger_message = "{base_trigger} [E2E:{timestamp}]"

              let expected_response = config.expected_response_pattern
              let expected_forward = config.expected_forward_pattern

              print("[E2E]    trigger: {trigger_message}")
              print("[E2E]    unique_id: {timestamp}")

              start, trigger_chat_id, leads_chat_id,
                config.chat_name, trigger_message, expected_response, expected_forward · run_lead_forward_test_impl

/// Implementation of lead forward test
run_lead_forward_test_impl(bridge: client.TelegramBridge, start: int, aimly_chat_id: int, leads_chat_id: int, chat_name: str, trigger_message: str, expected_response: str, expected_forward: str) → TestResult:bridge, start, aimly_chat_id, leads_chat_id, chat_name, trigger_message, expected_response, expected_forward):
  print("")
  print("[E2E] LEAD FORWARD TEST")

  // Step 0: Sync dialogs
  print("[E2E] Syncing dialogs for tester session...")
  case client.100 · get_dialogs:
    ❌err):
      let err_str = telegram_error_$(err)
      print("[E2E] Failed to sync dialogs: {err_str}")
    ✅dialogs):
      print("[E2E] Synced {int.$(list.len(dialogs))} dialogs")
      list.fn(d · each:
        print("[E2E] Dialog: {d.title} (id={int.$(d.ID)})")
      )

  print("[E2E] Sending trigger to {chat_name}: {trigger_message}")
  print("[E2E] aimly_chat_id={int.$(aimly_chat_id)}")
  print("[E2E] leads_chat_id={int.$(leads_chat_id)}")

  // Get last msg_id in BOTH groups BEFORE sending trigger
  let last_aimly_msg_id = case client.aimly_chat_id, 1 · get_history:
    ✅msgs) → case list.first(msgs):
      ✅m):
        print("[E2E] Last aimly msg_id before trigger: {int.$(m.ID)}")
        m.ID
      ❌_) → 0
    ❌_) → 0

  let last_leads_msg_id = case client.leads_chat_id, 1 · get_history:
    ✅msgs) → case list.first(msgs):
      ✅m):
        print("[E2E] Last leads msg_id before trigger: {int.$(m.ID)}")
        m.ID
      ❌_) → 0
    ❌_) → 0

  // Step 1: Send trigger
  case client.aimly_chat_id, trigger_message, ∅· send_message:
    ❌err):
      let err_str = telegram_error_$(err)
      print("[E2E] Failed to send trigger: {err_str}")
      TestResult(
        command: "lead_forward",
        expected: "response + forward",
        passed: false,
        response: "Failed to send trigger: {err_str}",
        duration_ms: 0,
      )
    ✅_):
      print("[E2E] Waiting 15s for agent to process and forward...")
      process.sleep(15_)

      print("[E2E] Checking {chat_name} for response...")
      case client.aimly_chat_id, 5 · get_history:
        ❌err):
          let err_str = telegram_error_$(err)
          print("[E2E] Failed to get trigger chat history: {err_str}")
          TestResult(
            command: "lead_forward",
            expected: "response + forward",
            passed: false,
            response: "Failed to get trigger chat history: {err_str}",
            duration_ms: elapsed_ms(start),
          )
        ✅aimly_msgs):
          let new_aimly_msgs = list.fn(m · filter: m.ID > last_aimly_msg_id)
          print("[E2E] Found {int.$(list.len(new_aimly_msgs))} NEW messages in aimly chat")

          list.fn(m · each:
            print("[E2E] NEW aimly msg_id={int.$(m.ID)} from={m.from_name} text={m.text[:40]}")
          )

          let #(response, resp_passed) = expected_response · find_matching_response
          print("[E2E] Trigger response: {response[:60]}")
          print("[E2E] {when resp_passed → "Response PASS"
            false → "Response FAIL"
          }")

          case resp_passed:
            false:
              print("[E2E] NO NEW agent response found!")
              print("[E2E] Possible causes:")
              print("[E2E]   1. Trigger message already in seen_ids")
              print("[E2E]   2. Agent not processing Aimly.io dev chat")
              print("[E2E]   3. Trigger word not matching")
            true → Nil

          print("[E2E] Waiting 5s for forward to complete...")
          process.sleep(5000)

          print("[E2E] Checking leads group for NEW forwarded dialog (limit=15)...")
          print("[E2E] Looking for messages with msg_id > {int.$(last_leads_msg_id)}")
          case client.leads_chat_id, 15 · get_history:
            ❌err):
              let err_str = telegram_error_$(err)
              print("[E2E] Failed to get leads history: {err_str}")
              TestResult(
                command: "lead_forward",
                expected: "response + forward",
                passed: false,
                response: "Aimly: {response[:80]} | Leads: error - {err_str}",
                duration_ms: elapsed_ms(start),
              )
            ✅leads_msgs):
              let new_msgs = list.fn(m · filter: m.ID > last_leads_msg_id)
              print("[E2E] Found {int.$(list.len(new_msgs))} NEW messages in leads group")

              list.fn(m · each:
                print("[E2E] NEW msg_id={int.$(m.ID)} text={m.text[:50]}")
              )

              let #(forward, fwd_passed) = expected_forward · find_any_matching_message

              case fwd_passed:
                false:
                  print("[E2E] NO NEW Lead Card found! Expected pattern: {expected_forward}")
                  print("[E2E] This indicates forward_dialog did not execute")
                true:
                  print("[E2E] NEW Lead Card found!")

              let passed = resp_passed && fwd_passed

              TestResult(
                command: "lead_forward",
                expected: "response + forward",
                passed,
                response: "Aimly: {response[:80]} | Leads: {forward[:80]}",
                duration_ms: elapsed_ms(start),
              )

/// Find a bot response that matches the expected pattern
@spec find_matching_response(messages: [TelegramMessage], expected_pattern: str) → #(str, bool)
impl: expected_pattern · find_matching_response:
  let vibee_agent_id = config.get_env_int_or("VIBEE_AGENT_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_ID", 0)

  list.fn(m: TelegramMessage · each:
    print("[E2E] msg_id={int.$(m.ID)} from_id={int.$(m.from_id)} from={m.from_name} text={m.text[:40]}")
  )

  let bot_responses = list.fn(m: TelegramMessage · filter:
    !string.starts_with(m.text, "/") && m.from_id == vibee_agent_id
  )

  print("[E2E] Found {int.$(list.len(bot_responses))} bot responses in history")

  let matching = list.fn(m: TelegramMessage · find:
    pattern_matches(m.text, expected_pattern)
  )

  case matching:
    ✅m):
      print("[E2E] Matching response (msg_id={int.$(m.ID)}): {m.text[:60]}")
      #(m.text, true)
    ❌_):
      case list.first(bot_responses):
        ✅m):
          print("[E2E] No matching response. Latest (msg_id={int.$(m.ID)}): {m.text[:60]}")
          #(m.text, false)
        ❌_):
          print("[E2E] No bot response found!")
          #("", false)

/// Find ANY message that matches the expected pattern
@spec find_any_matching_message(messages: [TelegramMessage], expected_pattern: str) → #(str, bool)
impl: expected_pattern · find_any_matching_message:
  let matching = list.fn(m: TelegramMessage · find:
    pattern_matches(m.text, expected_pattern)
  )

  case matching:
    ✅m) → #(m.text, true)
    ❌_):
      case list.first(messages):
        ✅m) → #(m.text, false)
        ❌_) → #("", false)

/// Check if response matches expected pattern
pattern_matches(text: str, pattern: str) → bool:text, pattern):
  let lower_text = string.lowercase(text)
  let patterns = string."|" · split
  list.fn(p · any:
    string.string.lowercase(p · contains)
  )

/// Get bridge URL from config
get_bridge_url() → str:):
  case postgres.get_global_pool():
    ∅-> config.get_env_or("VIBEE_BRIDGE_URL", "https://vibee-telegram-bridge.fly.dev")
    ☐pool) → dynamic_config.get_bridge_url(pool)

/// Encode results to JSON
encode_results(results: E2EResults) → json.Json:results):
  json.object([
    #("status", json.string(case results.failed:
      0 → "passed"
      _ → "failed"
    )),
    #("tester_session", json.string(results.tester_session)),
    #("tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name", json.string(results.tester_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name)),
    #("bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name", json.string(results.bot_type type type type type type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}name)),
    #("bot_chat_id", json.int(results.bot_chat_id)),
    #("total", json.int(results.total)),
    #("passed", json.int(results.passed)),
    #("failed", json.int(results.failed)),
    #("tests", json.array(results.tests, encode_test_result)),
  ])

encode_test_result(t: TestResult) → json.Json:t):
  json.object([
    #("command", json.string(t.command)),
    #("expected", json.string(t.expected)),
    #("passed", json.bool(t.passed)),
    #("response", json.string(t.response)),
    #("duration_ms", json.int(t.duration_ms)),
  ])

/// Parse chat_id for API calls
normalize_chat_id_for_api(chat_id: str) → int:chat_id):
  case int.parse(chat_id):
    ✅id) → id
    ❌_) → 0

/// Convert pipeline state to string
pipeline_state_$(state: vibee_pipeline.PipelineState) → str:state):
  case state:
    vibee_pipeline.Pending → "pending"
    vibee_pipeline.GeneratingTTS → "generating_tts"
    vibee_pipeline.GeneratingLipsync → "generating_lipsync"
    vibee_pipeline.GeneratingBRoll → "generating_broll"
    vibee_pipeline.BuildingSegments → "building_segments"
    vibee_pipeline.Rendering → "rendering"
    vibee_pipeline.Completed(url) → "completed:{url}"
    vibee_pipeline.Failed(err) → "failed:{err}"

/// Convert pipeline error to string
pipeline_error_$(err: vibee_pipeline.PipelineError) → str:err):
  case err:
    vibee_pipeline.TTS❌msg) → "TTS error: {msg}"
    vibee_pipeline.Lipsync❌msg) → "Lipsync error: {msg}"
    vibee_pipeline.Render❌msg) → "Render error: {msg}"
    vibee_pipeline.Config❌msg) → "Config error: {msg}"
    vibee_pipeline.Network❌msg) → "Network error: {msg}"
    vibee_pipeline.BRoll❌msg) → "B-roll error: {msg}"

/// Convert TelegramError to string
telegram_error_$(err: TelegramError) → str:err):
  case err:
    types.Connection❌msg) → "ConnectionError: {msg}"
    types.Auth❌msg) → "AuthError: {msg}"
    types.msg · ApiError → "Api❌{int.$(code)}): {msg}"
    types.Network❌msg) → "NetworkError: {msg}"
    types.InvalidSession → "InvalidSession"
    types.NotAuthorized → "NotAuthorized"

// FFI declarations
ffi("erlang")
erlang_monotonic_time() → int

ffi("vibee_e2e_runner_ffi")
ffi_spawn_async(f: fn() → Nil) → Nil

elapsed_ms(start: int) → int:start):
  let end = erlang_monotonic_time()
  { end - start } / 1__

# v8.0

# v10.0 - ML-Powered Migration
