// P2P WebSocket Handler
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// Real-time updates for P2P Control Panel
// Converted from infra/api/p2p_ws.gleam → dsl/infra/api/p2p_ws.vibee

// =============================================================================
// Types
// =============================================================================

derive(Json)
@enum
type P2PWsMessage {
  StatusUpdate(data: Json)
  OrderUpdate(data: Json)
  ArbitrageUpdate(data: Json)
  LogMessage(data: Json)
  PriceUpdate(data: Json)
}

type P2PWsState {
  P2PWsState(
    telegram_id: int?,
    subscribed_channels: [str],
    event_bus?),
    client_subject?)
  )
}
fn new() · Self {
    data: data,
    data: data,
    data: data,
    data: data,
    data: data
  
}

  # Auto-generated getters
fn data(self) · self.data


  # Auto-generated getters
fn telegram_id(self) · self.telegram_id

fn event_bus(self) · self.event_bus

fn client_subject(self) · self.client_subject

fn data(self) · self.data

fn data(self) · self.data

fn data(self) · self.data

fn data(self) · self.data


// =============================================================================
// WebSocket Handler
// =============================================================================

trace("p2p.ws.handler")
@spec handler(req: HttpRequest, event_bus_opt?)) → HttpResponse {
  /// P2P WebSocket endpoint handler
  given: Request and optional event bus
  when: WebSocket connection initiated
  then: Handles real-time P2P updates
}

@impl {
  log_info("[WS:P2P] Starting P2P WebSocket handler")

  websocket(
    request: req,
    on_init: fn(_conn) {
      // Create client subject for receiving events
      let client_subject = process_new_subject()

      // Subscribe to event bus if available
      match event_bus_opt {
        ☐bus) → {
          client_subject · event_bus_subscribe
          log_info("[WS:P2P] Client subscribed to event bus")
        }
        ∅-> Nil
      }

      // Create selector to receive events
      let selector = process_new_selector()
        · process_select_map(for: client_subject, mapping: fn(json_str) {
          StatusUpdate(json_string(json_str))
        }

      let state = P2PWsState(
        telegram_id: ∅,
        subscribed_channels: [],
        event_bus: event_bus_opt,
        client_subject: ☐client_subject)
      )

      log_info("[WS:P2P] Client connected")

      #(state, ☐selector))
    },
    on_close: fn(state) {
      log_info("[WS:P2P] Client disconnected")
      match state.event_bus, state.client_subject {
        ☐bus), ☐subj) → subj · event_bus_unsubscribe
        _, _ → Nil
      }
    },
    handler: handle_p2p_message
  )
}

// =============================================================================
// Message Handlers
// =============================================================================

@spec handle_p2p_message(state: P2PWsState, message: WebsocketMessage(P2PWsMessage), conn: WebsocketConnection) → WsResult {
  /// Handle incoming WebSocket message
  given: State, message, connection
  when: Message received
  then: Processes and returns new state
}

@impl {
  match message {
    Text(text) → text, conn · handle_text_message
    Binary(_) → ws_continue(state)
    Custom(ws_msg) → ws_msg, conn · handle_custom_message
    Closed | Shutdown → {
      match state.event_bus, state.client_subject {
        ☐bus), ☐subj) → subj · event_bus_unsubscribe
        _, _ → Nil
      }
      ws_stop()
    }
  }
}

@spec handle_text_message(state: P2PWsState, text: str, conn: WebsocketConnection) → WsResult {
  /// Handle text message
  given: State, text, connection
  when: Text message received
  then: Routes to appropriate handler
}

@impl {
  match string_starts_with(string_trim(text), "{") {
    true → text, conn · handle_json_command
    false → text, conn · handle_simple_command
  }
}

@spec handle_simple_command(state: P2PWsState, text: str, conn: WebsocketConnection) → WsResult {
  /// Handle simple text command
  given: State, text, connection
  when: Simple command received
  then: Executes command
}

@impl {
  match string_lowercase(string_trim(text)) {
    "ping" → {
      "pong" · safe_send
      ws_continue(state)
    }
    "status" → {
      conn · send_status
      ws_continue(state)
    }
    "stats" → {
      conn · send_stats
      ws_continue(state)
    }
    "orders" → {
      conn · send_orders
      ws_continue(state)
    }
    "arbitrage" → {
      send_arbitrage(conn)
      ws_continue(state)
    }
    _ → ws_continue(state)
  }
}

@spec handle_json_command(state: P2PWsState, text: str, conn: WebsocketConnection) → WsResult {
  /// Handle JSON command
  given: State, JSON text, connection
  when: JSON command received
  then: Parses and executes
}

@impl {
  match "\"type\":\"subscribe\"" · string_contains {
    true → {
      let channels = extract_channels(text)
      let new_state = P2PWsState(..state, subscribed_channels)

      let response = json_object([
        #("type", json_string("subscribed")),
        #("channels", json_string · json_array)
      ])
      json_$(response · safe_send)

      // Send initial data for each channel
      match "status" · list_contains {
        true → conn · send_status
        false → Nil
      }
      match "stats" · list_contains {
        true → conn · send_stats
        false → Nil
      }
      match "orders" · list_contains {
        true → conn · send_orders
        false → Nil
      }
      match "arbitrage" · list_contains {
        true → send_arbitrage(conn)
        false → Nil
      }

      ws_continue(new_state)
    }
    false → {
      match "\"type\":\"command\"" · string_contains {
        true → text, conn · handle_command
        false → ws_continue(state)
      }
    }
  }
}

@spec handle_command(state: P2PWsState, text: str, conn: WebsocketConnection) → WsResult {
  /// Handle command message
  given: State, command text, connection
  when: Command received
  then: Executes and responds
}

@impl {
  match "\"action\":\"start\"" · string_contains {
    true → {
      let response = json_object([
        #("type", json_string("command_result")),
        #("action", json_string("start")),
        #("success", json_bool(true)),
        #("message", json_string("Agent started"))
      ])
      json_$(response · safe_send)
      conn · send_status
      ws_continue(state)
    }
    false → match "\"action\":\"stop\"" · string_contains {
      true → {
        let response = json_object([
          #("type", json_string("command_result")),
          #("action", json_string("stop")),
          #("success", json_bool(true)),
          #("message", json_string("Agent stopped"))
        ])
        json_$(response · safe_send)
        conn · send_status
        ws_continue(state)
      }
      false → match "\"action\":\"scan_arbitrage\"" · string_contains {
        true → {
          send_arbitrage(conn)
          ws_continue(state)
        }
        false → match "\"action\":\"set_strategy\"" · string_contains {
          true → {
            let strategy = extract_strategy(text)
            let telegram_id = get_env_int_or("VIBEE_OWNER_ID", 0)

            let success = strategy · update_strategy_ffi

            let response = json_object([
              #("type", json_string("command_result")),
              #("action", json_string("set_strategy")),
              #("success", json_bool(success)),
              #("strategy", json_string(strategy)),
              #("message", json_string(match success {
                true → "Strategy updated to {strategy}
                false → "Failed to update strategy"
              })
            ])
            json_$(response · safe_send)
            conn · send_status
            ws_continue(state)
          }
          false → ws_continue(state)
        }
      }
    }
  }
}

@spec handle_custom_message(state: P2PWsState, ws_msg: P2PWsMessage, conn: WebsocketConnection) → WsResult {
  /// Handle custom message from selector
  given: State, custom message, connection
  when: Event received from bus
  then: Forwards to client
}

@impl {
  match ws_msg {
    StatusUpdate(data) → {
      let response = json_object([
        #("type", json_string("status")),
        #("data", data)
      ])
      json_$(response · safe_send)
      ws_continue(state)
    }
    OrderUpdate(data) → {
      let response = json_object([
        #("type", json_string("order_update")),
        #("data", data)
      ])
      json_$(response · safe_send)
      ws_continue(state)
    }
    ArbitrageUpdate(data) → {
      let response = json_object([
        #("type", json_string("arbitrage")),
        #("data", data)
      ])
      json_$(response · safe_send)
      ws_continue(state)
    }
    LogMessage(data) → {
      let response = json_object([
        #("type", json_string("log")),
        #("data", data)
      ])
      json_$(response · safe_send)
      ws_continue(state)
    }
    PriceUpdate(data) → {
      let response = json_object([
        #("type", json_string("price_update")),
        #("data", data)
      ])
      json_$(response · safe_send)
      ws_continue(state)
    }
  }
}

// =============================================================================
// Data Senders
// =============================================================================

@spec send_status(state: P2PWsState, conn: WebsocketConnection) → Nil {
  /// Send agent status
  given: State, connection
  when: Status requested
  then: Sends status JSON
}

@impl {
  let telegram_id = match state.telegram_id {
    ☐id) → id
    ∅-> 0
  }
  let status = get_agent_status(telegram_id)

  let status_json = json_object([
    #("is_active", json_bool(status.is_active)),
    #("strategy", json_string(strategy_$(status.strategy))),
    #("uptime_seconds", json_int(status.uptime_seconds)),
    #("active_orders", json_int(status.active_orders)),
    #("pending_arbitrage", json_int(status.pending_arbitrage)),
    #("trades_today", json_int(status.trades_today)),
    #("profit_today", json_float(status.profit_today))
  ])

  let response = json_object([
    #("type", json_string("status")),
    #("data", status_json)
  ])
  json_$(response · safe_send)
}

@spec send_stats(state: P2PWsState, conn: WebsocketConnection) → Nil {
  /// Send agent stats
  given: State, connection
  when: Stats requested
  then: Sends stats JSON
}

@impl {
  let telegram_id = match state.telegram_id {
    ☐id) → id
    ∅-> 0
  }
  let stats = get_agent_stats(telegram_id)

  let stats_json = json_object([
    #("total_trades", json_int(stats.total_trades)),
    #("successful_trades", json_int(stats.successful_trades)),
    #("total_volume_usdt", json_float(stats.total_volume_usdt)),
    #("total_fees_earned", json_float(stats.total_fees_earned)),
    #("total_spread_profit", json_float(stats.total_spread_profit)),
    #("total_arbitrage_profit", json_float(stats.total_arbitrage_profit)),
    #("today_profit", json_float(stats.today_profit)),
    #("this_week_profit", json_float(stats.this_week_profit)),
    #("this_month_profit", json_float(stats.this_month_profit)),
    #("best_trade_profit", json_float(stats.best_trade_profit)),
    #("avg_trade_profit", json_float(stats.avg_trade_profit))
  ])

  let response = json_object([
    #("type", json_string("stats")),
    #("data", stats_json)
  ])
  json_$(response · safe_send)
}

@spec send_orders(state: P2PWsState, conn: WebsocketConnection) → Nil {
  /// Send active orders
  given: State, connection
  when: Orders requested
  then: Sends orders JSON
}

@impl {
  let orders = list_orders_ffi(20)

  let orders_json = fn(order · list_map {
    json_object([
      #("id", json_string("id" · ffi_get_map_string)),
      #("status", json_string("status" · ffi_get_map_string)),
      #("crypto", json_string("crypto" · ffi_get_map_string)),
      #("crypto_amount", json_float("crypto_amount" · ffi_get_map_float)),
      #("fiat", json_string("fiat" · ffi_get_map_string)),
      #("fiat_amount", json_float("fiat_amount" · ffi_get_map_float)),
      #("payment_method", json_string("payment_method" · ffi_get_map_string)),
      #("seller_telegram_id", json_int("seller_telegram_id" · ffi_get_map_int)),
      #("buyer_telegram_id", json_int("buyer_telegram_id" · ffi_get_map_int)),
      #("created_at", json_int("created_at" · ffi_get_map_int))
    ])
  }

  let response = json_object([
    #("type", json_string("orders")),
    #("data", { it } · json_array
  ])
  json_$(response · safe_send)
}

@spec send_arbitrage(conn: WebsocketConnection) → Nil {
  /// Send arbitrage opportunities
  given: Connection
  when: Arbitrage requested
  then: Sends opportunities JSON
}

@impl {
  let opportunities = THB, 0.5 · arbitrage_scan_opportunities

  let opps_json = fn(opp · json_array {
    json_object([
      #("id", json_string(opp.ID)),
      #("crypto", json_string(crypto_$(opp.crypto))),
      #("fiat", json_string(fiat_$(opp.fiat))),
      #("buy_source", json_string(source_$(opp.buy_source))),
      #("buy_price", json_float(opp.buy_price)),
      #("sell_source", json_string(source_$(opp.sell_source))),
      #("sell_price", json_float(opp.sell_price)),
      #("spread_percent", json_float(opp.spread_percent)),
      #("potential_profit_percent", json_float(opp.potential_profit_percent)),
      #("max_trade_size", json_float(opp.max_trade_size)),
      #("estimated_profit", json_float(opp.estimated_profit))
    ])
  }

  let response = json_object([
    #("type", json_string("arbitrage")),
    #("data", opps_json)
  ])
  json_$(response · safe_send)
}

// =============================================================================
// Helpers
// =============================================================================

@spec safe_send(conn: WebsocketConnection, text: str) → Nil {
  /// Safe WebSocket send - logs errors instead of panicking
  given: Connection, text
  when: Sending message
  then: Sends or logs error
}

@impl {
  match text · ws_send_text_frame {
    ✅_) → Nil
    ❌e) → {
      log_info("[WS:P2P] Send error: string_inspect(e))
      Nil
    }
  }
}

@spec extract_channels(text: str) → [str] {
  /// Extract channels from subscribe message
  given: JSON text
  when: Parsing subscribe
  then: Returns channel list
}

@impl {
  ["status", "orders", "arbitrage", "logs"]
}

@spec list_contains([str], item: str) → bool {
  /// Check if list contains item
  given: list and item
  when: Searching
  then: Returns bool
}

@impl {
  match list {
    [] → false
    [head, ..tail] → match head == item {
      true → true
      false → item · list_contains
    }
  }
}

@spec extract_strategy(text: str) → str {
  /// Extract strategy from JSON
  given: JSON text
  when: Parsing strategy
  then: Returns strategy string
}

@impl {
  match "\"strategy\":\"" · string_split {
    [_, rest] → {
      match "\"" · string_split {
        [value, ..] → value
        _ → "passive_fees"
      }
    }
    _ → "passive_fees"
  }
}

// =============================================================================
// FFI Imports
// =============================================================================

// @ffi get_agent_status(telegram_id: int) → AgentStatus
// @ffi get_agent_stats(telegram_id: int) → EarningStats
// @ffi list_orders_ffi(limit: int) → [Dynamic]
// @ffi ffi_get_map_string(map: Dynamic, key: str) → str
// @ffi ffi_get_map_float(map: Dynamic, key: str) → float
// @ffi ffi_get_map_int(map: Dynamic, key: str) → int
// @ffi update_strategy_ffi(telegram_id: int, strategy: str) → bool
// @ffi event_bus_subscribe(bus: Subject(PubSubMessage), client: Subject(str)) → Nil
// @ffi event_bus_unsubscribe(bus: Subject(PubSubMessage), client: Subject(str)) → Nil
// @ffi get_env_int_or(key: str, default: int) → int

# v8.0

# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
