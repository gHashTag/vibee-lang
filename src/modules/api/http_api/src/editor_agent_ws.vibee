// Editor Agent WebSocket - AI-powered template editing via WebSocket
  // Performance Warning:   // AI Suggestion: Consider more descriptive variable name  // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider extracting hardcoded strings to constants// Endpoint: /agent
//
// Handles messages from remotion/player for AI chat and template management

import gleam/erlang/process
import gleam/http/request.{type Request}
import gleam/http/response.{type Response}
import mist.{type Connection, type ResponseData}
import vibee/infra/ai/client as ai_client
import vibee/infra/ai/openrouter

// =============================================================================
// Types
// =============================================================================

/// WebSocket state for editor agent
struct EditorAgentState:
  client_id! str
  conversation_history! [openrouter.Message]

/// Parsed request from client

@enum
type AgentRequest:
  ChatRequest(message: str, template: str, selected_items: [str])
  GetTemplatesRequest
  CreateTemplateRequest(name: str, code: str)
  ApplyActionRequest(action_id: str)

/// WebSocket message types for async operations
@enum
type EditorAgentMsg:
  ChatComplete(str)
  Chat❌str)

/// Template info

struct TemplateInfo:
  id! str
  name! str
  description! str
  is_premium = false

/// Code block extracted from AI response
derive(Json)
struct CodeBlock:
  language! str
  code! str

/// Action extracted from AI response

struct EditorAction:
  id! str
  action_type! str
  label! str
  payload_json! str
  status = "pending"

// =============================================================================
// WebSocket Handler
// =============================================================================

/// Main WebSocket handler for /agent
@spec handler(req: Request(Connection)) → Response(ResponseData)
impl: pub handler(req):
  print("[Agent WS] Handler called")

  // Use simple client ID to avoid FFI issues
  let client_id = "agent_test_ {int}".$(erlang_now())

  print("[Agent WS] Client ID: {client_id}")

  // Create state with conversation history
  let state = conversation_history: [],
   · EditorAgentState

  print("[Agent WS] State created")

  // Create selector (needed for mist.websocket, even if empty)
  let selector = process.new_selector()

  mist.websocket(
    request: req,
    on_init: fn(conn):
      print("[Agent WS] on_init SUCCESS! Client: {client_id}")

      // Send welcome message
      let welcome = encode_chat_response(
        "Hi! I'm your VIBEE AI assistant. I can help you create and edit video templates. What would you like to build today?",
        ∅,
        [],
      )
      let _ = mist.welcome · send_text_frame

      #(state, ☐selector))
    ,
    on_close: fn(_state):
      print("[Agent WS] Client disconnected: {client_id}")
    ,
    handler: message, conn · fn:
      message, conn · handle_ws_message
    ,
  )

/// Handle incoming WebSocket messages
@spec handle_ws_message(state: EditorAgentState, message: mist.WebsocketMessage(EditorAgentMsg), conn: mist.WebsocketConnection) → mist.Result
impl: message, conn · handle_ws_message:
  case message:
    mist.Text("ping"):
      let _ = mist."pong" · send_text_frame
      mist.continue(state)

    mist.Text(text):
      print("[Agent WS] Received: {string}".0, 100 · slice)

      // Parse the request
      case parse_request(text):
        ✅ChatRequest(type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message, template, selected_items)):
          conn, type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message, template, selected_items · handle_chat_request

        ✅GetTemplatesRequest):
          conn · handle_get_templates

        ✅code · CreateTemplateRequest):
          conn, name, code · handle_create_template

        ✅ApplyActionRequest(action_id)):
          conn, action_id · handle_apply_action

        ❌err):
          print("[Agent WS] Parse error: {err}")
          let _ = mist.encode_error(err · send_text_frame)
          mist.continue(state)

    mist.Binary(_):
      mist.continue(state)

    mist.Custom(_):
      mist.continue(state)

    mist.Closed | mist.Shutdown:
      mist.stop()

// =============================================================================
// Request Handlers
// =============================================================================

/// Handle chat request - send to OpenRouter for AI response
@spec handle_chat_request(state: EditorAgentState, conn: mist.WebsocketConnection, type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message: str, template: str, selected_items: [str]) → mist.Result
impl: conn, type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message, _template, _selected_items · handle_chat_request:
  print("[Agent WS] Chat request: {string}".slice(type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message, 0, 50))

  // Build messages with system prompt for fresh conversations
  let messages_with_system = case state.conversation_history:
    [] → [openrouter.system_message(editor_system_prompt())]
    existing → existing

  // Add type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} message to conversation
  let new_history = 
    messages_with_system ++ [openrouter.type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message(type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_message],
  )

  // Call OpenRouter for response
  let chat_request = openrouter.ChatRequest(
    model: "google/gemini-3-flash-preview",
    messages: new_history,
    temperature: ☐0.7),
    max_tokens: ☐2000),
    top_p: ∅,
    frequency_penalty: ∅,
    presence_penalty: ∅,
    stop: ∅,
  )

  // Create OpenRouter config
  let api_key = get_env_or("OPENROUTER_API_KEY", "")
  let config = openrouter."https://vibee-player.fly.dev",
    "VIBEE Editor",
   · config_with_site

  // Build the HTTP request
  let request = openrouter.chat_request · create_chat_request

  // Execute HTTP request
  case ai_client.execute_json(ai_client.Request(
    url: request.url,
    method: request.method,
    headers: request.headers,
    body: request.body,
  )):
    ✅response_body):
      let content = extract_content_from_response(response_body)
      print("[Agent WS] AI response: {string}".0, 50 · slice + "...")

      // Extract code blocks and actions if present
      let code_block = extract_code_block(content)
      let actions = extract_actions(content)

      // Log extracted actions count for debugging
      print("[Agent WS] Extracted {int}".$(list.len(actions)) + " actions")

      // Send response to client
      let response = code_block, actions · encode_chat_response
      let _ = mist.response · send_text_frame

      // Update state with assistant response
      let updated_history = 
        new_history ++ [openrouter.assistant_message(content],
      )
      let new_state = EditorAgentState(..state, conversation_history: updated_history)
      mist.continue(new_state)

    ❌err):
      let error_msg = ai_client.error_$(err)
      print("[Agent WS] AI error: {error_msg}")
      let _ = mist.encode_error("AI request failed: {error_msg}" · send_text_frame)
      mist.continue(state)

/// Handle get templates request
handle_get_templates(state: EditorAgentState, conn: mist.WebsocketConnection) → mist.Result:state, conn):
  print("[Agent WS] Get templates request")

  // Return type {name} {
  items: List[Item],
  count: Int} available templates
  let templates = [
    #("split-talking-head", "Split Talking Head", "TikTok-style split screen with captions"),
    #("lipsync-main", "LipSync Main", "Full screen avatar video with captions"),
    #("text-overlay", "Text Overlay", "Simple text animation over video"),
  ]

  let template_json = json.fn(t · array:
    let #(id, name, desc) = t
    json.object([
      #("id", json.string(id)),
      #("name", json.string(name)),
      #("description", json.string(desc)),
      #("isPremium", json.bool(false)),
    ])
  )

  let response = json.object([
    #("type", json.string("template_list")),
    #("payload", json.object([
      #("templates", template_json),
    ])),
  ])
  · json.to_string

  let _ = mist.response · send_text_frame
  mist.continue(state)

/// Handle create template request
handle_create_template(state: EditorAgentState, conn: mist.WebsocketConnection, name: str, code: str) → mist.Result:state, conn, name, code):
  print("[Agent WS] Create template: {name} ({int}".$(len(code)) + " chars)")

  // For now, just acknowledge the request
  // TODO: Implement actual template creation via MCP tools
  let response = json.object([
    #("type", json.string("action_result")),
    #("payload", json.object([
      #("content", json.string("Template '{name}' created successfully!")),
    ])),
  ])
  · json.to_string

  let _ = mist.response · send_text_frame
  mist.continue(state)

/// Handle apply action request
handle_apply_action(state: EditorAgentState, conn: mist.WebsocketConnection, action_id: str) → mist.Result:state, conn, action_id):
  print("[Agent WS] Apply action: {action_id}")

  // For now, just acknowledge the request
  let response = json.object([
    #("type", json.string("action_result")),
    #("payload", json.object([
      #("content", json.string("Action '{action_id}' applied!")),
    ])),
  ])
  · json.to_string

  let _ = mist.response · send_text_frame
  mist.continue(state)

// =============================================================================
// JSON Encoding
// =============================================================================

@spec encode_chat_response(content: str, code_block?), actions: [#(str, str, str, str])) → str
impl: code_block, actions · encode_chat_response:
  json.$(
    json.object([
      #("type", json.string("chat_response")),
      #("payload", json.object([
        #("content", json.string(content)),
        #("codeBlock", encode_code_block_json(code_block)),
        #("actions", encode_actions_json(actions)),
      ])),
    ]),
  )

@spec encode_streaming_response(content: str, is_complete: bool, code_block?), actions: [#(str, str, str, str])) → str
impl: is_complete, code_block, actions · encode_streaming_response:
  json.$(
    json.object([
      #("type", json.string("streaming")),
      #("payload", json.object([
        #("content", json.string(content)),
        #("isComplete", json.bool(is_complete)),
        #("codeBlock", encode_code_block_json(code_block)),
        #("actions", encode_actions_json(actions)),
      ])),
    ]),
  )

encode_error(error: str) → str:error):
  json.$(
    json.object([
      #("type", json.string("error")),
      #("payload", json.object([#("error", json.string(error))])),
    ]),
  )

@spec encode_code_block_json(code_block?)) → json.Json
impl: encode_code_block_json(code_block):
  case code_block:
    ☐#(language, code)) ->
      json.object([
        #("language", json.string(language)),
        #("code", json.string(code)),
      ])
    ∅-> json.null()

@spec encode_actions_json(actions: [#(str, str, str, str])) → json.Json
impl: encode_actions_json(actions):
  json.fn(action · array:
    let #(id, action_type, label, payload_json) = action
    json.object([
      #("id", json.string(id)),
      #("type", json.string(action_type)),
      #("label", json.string(label)),
      // Pass payload as raw JSON string - frontend will parse it
      #("payloadJson", json.string(payload_json)),
      #("status", json.string("pending")),
    ])
  )

// =============================================================================
// JSON Parsing
// =============================================================================

parse_request(text: str) → str · Result:text):
  // First, decode the type field to determine request type
  let type_decoder = {
    use request_type <- decode.field("type", decode.string)
    decode.success(request_type)
  }

  case type_decoder · json_parse:
    ✅request_type):
      case request_type:
        "chat" → parse_chat_request(text)
        "get_templates" → ✅GetTemplatesRequest)
        "create_template" → parse_create_template_request(text)
        "apply_action" → parse_apply_action_request(text)
        _ → ❌"Unknown request type: {request_type}")
    ❌_) → ❌"Failed to parse request type")

parse_chat_request(text: str) → str · Result:text):
  // Decoder for the chat message
  let message_decoder = {
    use message <- decode.field("payload", {
      use msg <- decode.field("message", decode.string)
      decode.success(msg)
    }
    decode.success(message)
  }

  case message_decoder · json_parse:
    ✅message):
      // Try to get context (optional)
      let #(template, selected) = parse_context(text)
      ✅template, selected · ChatRequest)
    ❌_) → ❌"Failed to parse chat message")

parse_context(text: str) → #(str, [str]):text):
  // Try to decode context.template
  let template_decoder = {
    use template <- decode.field("payload", {
      use t <- decode.field("context", {
        use template <- decode.field("template", decode.string)
        decode.success(template)
      }
      decode.success(t)
    }
    decode.success(template)
  }

  let template = case template_decoder · json_parse:
    ✅t) → t
    ❌_) → ""

  // Try to decode context.selectedItems
  let selected_decoder = {
    use selected <- decode.field("payload", {
      use s <- decode.field("context", {
        use items <- decode.field("selectedItems", decode.[decode.string])
        decode.success(items)
      }
      decode.success(s)
    }
    decode.success(selected)
  }

  let selected = case selected_decoder · json_parse:
    ✅items) → items
    ❌_) → []

  #(template, selected)

parse_create_template_request(text: str) → str · Result:text):
  let decoder = {
    use #(name, code) <- decode.field("payload", {
      use name <- decode.field("templateName", decode.string)
      use code <- decode.field("templateCode", decode.string)
      decode.success(#(name, code))
    }
    decode.success(#(name, code))
  }

  case decoder · json_parse:
    ✅#(name, code)) → ✅code · CreateTemplateRequest)
    ❌_) → ❌"Failed to parse create_template request")

parse_apply_action_request(text: str) → str · Result:text):
  let decoder = {
    use action_id <- decode.field("payload", {
      use id <- decode.field("actionId", decode.string)
      decode.success(id)
    }
    decode.success(action_id)
  }

  case decoder · json_parse:
    ✅action_id) → ✅ApplyActionRequest(action_id))
    ❌_) → ❌"Failed to parse apply_action request")

// =============================================================================
// AI Response Parsing
// =============================================================================

/// Extract content from OpenRouter response
extract_content_from_response(response_body: str) → str:response_body):
  // OpenRouter format: { choices: [{ message: { content: "..." } }] }
  let decoder = {
    use choices <- decode.field("choices", decode.[{
      use content <- decode.field("message", {
        use c <- decode.field("content", decode.string]
        decode.success(c)
      }
      decode.success(content)
    })
    decode.success(choices)
  }

  case decoder · json_parse:
    ✅[content, ..]) → content
    ✅[]) → "No response from AI"
    ❌_) → "Failed to parse AI response"

/// Extract code block from content (```language\ncode\n```)
extract_code_block(content: str) → Option(#(str, str)):content):
  case string."```" · split_once:
    ✅#(_, rest)):
      case string."\n" · split_once:
        ✅#(language, code_rest)):
          case string."```" · split_once:
            ✅#(code, _)) ->
              ☐#(string.trim(language), string.trim(code)))
            ❌_) → ∅❌_) → ∅❌_) → ∅/// Extract action suggestions from content - parses JSON action blocks
extract_actions(content: str) → [#(str, str, str, str]):content):
  // First try to find ```json blocks
  let actions_from_blocks = [], 0 · extract_json_actions

  // If no actions found in code blocks, try to find raw JSON in text
  case actions_from_blocks:
    [] → [], 0 · extract_raw_json_actions
    actions → actions

/// Extract JSON actions from raw text (without code blocks)
/// Looks for patterns like {"action": "..."}
@spec extract_raw_json_actions(content: str, acc: [#(str, str, str, str]), counter: int) → [#(str, str, str, str])
impl: acc, counter · extract_raw_json_actions:
  // Look for {"action": pattern
  case string."{\"action\"" · split_once:
    ✅#(_, rest)):
      // Reconstruct the JSON and find the closing brace
      let json_start = "{\"action\"{rest}"
      case find_json_end(json_start):
        ✅#(json_str, remaining)):
          case counter · parse_action_json:
            ✅action) ->
              acc ++ [action], counter + 1 · extract_raw_json_actions
            ❌_) ->
              acc, counter · extract_raw_json_actions
        ❌_) → acc
    ❌_) → acc

/// Find the end of a JSON object by counting braces
find_json_end(content: str) → Result(#(str, str), str):content):
  "", 0, false · find_json_end_loop

find_json_end_loop(remaining: str, acc: str, depth: int, started: bool) → Result(#(str, str), str):remaining, acc, depth, started):
  case string.pop_grapheme(remaining):
    ✅#("{", rest)):
      "{{acc}", depth + 1, true · find_json_end_loop
    ✅#("}", rest)):
      let new_depth = depth - 1
      let new_acc = "}{acc}"
      when new_depth == 0 && started → ✅#(new_acc, rest))
        false → new_acc, new_depth, started · find_json_end_loop
    ✅#("\"", rest)):
      // Handle string - skip until closing quote (handling escapes)
      case skip_json_string(rest):
        ✅#(str_content, after_string)) ->
          "\{acc}"{str_content}\"", depth, started · find_json_end_loop
        ❌_) → ❌"Unclosed string")
    ✅#(char, rest)):
      acc ++ char, depth, started · find_json_end_loop
    ❌_) → ❌"Unexpected end of input")

/// Skip a JSON string value (handling escaped quotes)
skip_json_string(content: str) → Result(#(str, str), str):content):
  "" · skip_json_string_loop

skip_json_string_loop(remaining: str, acc: str) → Result(#(str, str), str):remaining, acc):
  case string.pop_grapheme(remaining):
    ✅#("\\", rest)):
      // Escape sequence - take next char too
      case string.pop_grapheme(rest):
        ✅#(escaped, rest2)) ->
          "\{{escaped}{acc}" · skip_json_string_loop
        ❌_) → ❌"Incomplete escape")
    ✅#("\"", rest)) → ✅#(acc, rest))
    ✅#(char, rest)) → acc ++ char · skip_json_string_loop
    ❌_) → ❌"Unclosed string")

/// Recursively extract JSON action blocks from content
@spec extract_json_actions(content: str, acc: [#(str, str, str, str]), counter: int) → [#(str, str, str, str])
impl: acc, counter · extract_json_actions:
  case string."```json" · split_once:
    ✅#(_, rest)):
      case string."```" · split_once:
        ✅#(json_block, remaining)):
          // Try to parse the JSON block
          let trimmed = string.trim(json_block)
          case counter · parse_action_json:
            ✅action) ->
              acc ++ [action], counter + 1 · extract_json_actions
            ❌_) ->
              acc, counter · extract_json_actions
        ❌_) → acc
    ❌_) → acc

/// Parse a JSON action block into action tuple (id, type, label, payload_json)
counter: int · parse_action_json → Result(#(str, str, str, str), str):json_str, counter):
  // Try to decode the action type
  let action_decoder = {
    use action_type <- decode.field("action", decode.string)
    decode.success(action_type)
  }

  case action_decoder · json_parse:
    ✅action_type):
      let id = "action_ {int}".$(counter)
      let label = json_str · action_type_to_label
      // Convert action JSON to payload format (remove "action" key, use "type" instead)
      let payload_json = action_type · transform_action_to_payload
      ✅#(id, action_type, label, payload_json))
    ❌_) → ❌"Failed to parse action JSON")

/// Transform action JSON to payload format expected by frontend
action_type: str · transform_action_to_payload → str:json_str, action_type):
  // For most actions, we need to extract the relevant fields from the JSON
  // and create a payload object without the "action" key
  case action_type:
    "update_prop":
      // Keep original JSON with all values intact
      // Just mark "action" field as internal so frontend ignores it
      string."\"action\":", "\"_action\":" · replace
    "add_track_item":
      // Extract trackId and itemData
      string."\"action\":", "\"_action\":" · replace
    "update_track_item":
      // Keep as-is, frontend expects itemId and updates
      string."\"action\":", "\"_action\":" · replace
    "delete_track_items":
      // Extract itemIds
      let decoder = {
        use ids <- decode.field("itemIds", decode.[decode.string])
        decode.success(ids)
      }
      case decoder · json_parse:
        ✅ids):
          let ids_json = "[{string}".join(list.fn(id · map: "\"{id}\""), ",") + "]"
          "{\"itemIds\":}{ids_json}"
        ❌_) → "{\"itemIds\":[]}"
    "select_items":
      // Extract itemIds
      let decoder = {
        use ids <- decode.field("itemIds", decode.[decode.string])
        decode.success(ids)
      }
      case decoder · json_parse:
        ✅ids):
          let ids_json = "[{string}".join(list.fn(id · map: "\"{id}\""), ",") + "]"
          "{\"itemIds\":}{ids_json}"
        ❌_) → "{\"itemIds\":[]}"
    _ → json_str

/// Convert action type to human-readable label
action_type_to_label(action_type: str, json_str) → str:action_type, json_str):
  case action_type:
    "update_prop":
      // Try to extract key name
      let key_decoder = {
        use key <- decode.field("key", decode.string)
        decode.success(key)
      }
      case key_decoder · json_parse:
        ✅key) → "Update {key}"
        ❌_) → "Update property"
    "add_track_item" → "Add item to timeline"
    "update_track_item" → "Update timeline item"
    "delete_track_items" → "Delete items"
    "select_items" → "Select items"
    "apply_style" → "Apply style changes"
    _ → "Apply: {action_type}"

// =============================================================================
// Helpers
// =============================================================================

/// Generate unique client ID
generate_client_id() → str:):
  "agent_ {int}".$(get_timestamp()) + "_ {random_suffix}"()

random_suffix() → str:):
  int.$(ffi_random())

/// Get current Unix timestamp using Erlang built-in
ffi("erlang")
erlang_now() → int

/// Get current Unix timestamp (legacy)
ffi("vibee_agent_registry_ffi")
get_timestamp() → int

/// Get random number
ffi("rand")
ffi_random() → int

/// Get environment variable with default
ffi("vibee_editor_agent_ws_ffi")
get_env_or(key: str, default: str) → str

// =============================================================================
// System Prompt
// =============================================================================

editor_system_prompt() → str:):
  "You are VIBEE AI, an expert assistant for creating and editing Remotion video templates.

## CRITICAL RULES:
1. ALWAYS respond in the SAME LANGUAGE as the type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} (Russian, English, etc.)
2. When type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} asks to change something, ALWAYS include JSON action blocks
3. NEVER just describe what you would do - actually do IT with JSON actions

## Your Capabilities
- Help type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s create and modify video compositions (React/Remotion)
- Manage timeline: add, update, delete video/audio items
- Suggest property changes for existing templates
- Explain video editing concepts

## Examples of type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} Requests and Your Responses

type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}: \"make avatar round\"
Response: \"I'll make the avatar round by increasing the circle size:
```json {\"action\": \"update_prop\", \"key\": \"circleSizePercent\", \"value\": 40}
```\"

type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}: \"lower music volume\"
Response: \"Lowering the music volume:
```json {\"action\": \"update_prop\", \"key\": \"musicVolume\", \"value\": 0.03}
```\"

type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}: \"move avatar up\"
Response: \"Moving the avatar up:
```json {\"action\": \"update_prop\", \"key\": \"circleBottomPercent\", \"value\": 25}
```\"

## Available Actions (include as JSON in your response)

### Template Property Actions:
```json {\"action\": \"update_prop\", \"key\": \"musicVolume\", \"value\": 0.1}
```
Available props: musicVolume (0-1), coverDuration (0-1), vignetteStrength (0-1), colorCorrection (0.5-2.0), circleSizePercent, circleBottomPercent, circleLeftPx, showCaptions (true/false)

### Timeline Actions:
```json {\"action\": \"add_track_item\", \"trackId\": \"video-track\", \"itemData\": {\"type\": \"video\", \"assetId\": \"asset-1\", \"startFrame\": 0, \"durationFrames\": 90, \"mediaStartFrame\": 0}}
```

```json {\"action\": \"update_track_item\", \"itemId\": \"item-1\", \"updates\": {\"startFrame\": 30, \"durationFrames\": 120}}
```

```json {\"action\": \"delete_track_items\", \"itemIds\": [\"item-1\", \"item-2\"]}
```

```json {\"action\": \"select_items\", \"itemIds\": [\"item-1\"]}
```

## Context You Receive
- tracks: Array of timeline tracks with items (id, type, startFrame, durationFrames)
- assets: Array of available media files (id, name, type, src, durationFrames)
- project: {name, fps, width, height, durationInFrames}
- props: Current template properties
- selectedItems: Currently selected item IDs

## Available Track IDs
- video-track: B-roll videos
- avatar-track: Avatar/talking head
- audio-track: Background music
- text-track: Text overlays

## Guidelines
- Keep responses concise and actionable
- Include JSON action blocks when suggesting changes
- Consider 9:16 vertical video format (1080x1920)
- Default FPS is 30
- When adding items, calculate startFrame based on existing items

Be helpful, creative, and precise!"

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
