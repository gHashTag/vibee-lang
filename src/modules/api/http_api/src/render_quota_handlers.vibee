// Render Quota API Handlers
  // Performance Warning: // Freemium model: 3 free renders, then subscription required
  // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// Converted from infra/api/render_quota_handlers.gleam → dsl/infra/api/render_quota_handlers.vibee

import vibee/dsl/ffi/json
import vibee/dsl/ffi/http
import vibee/dsl/infra/db/postgres

// =============================================================================
// CONSTANTS
// =============================================================================

let FREE_RENDERS_LIMIT = const(3

// =============================================================================
// TYPES
// =============================================================================

derive(Json)
struct RenderQuota {
  RenderQuota(
    telegram_id: int,
    total_renders: int,
    free_remaining: int,
    subscription: SubscriptionInfo?
  )
}

struct SubscriptionInfo {
  SubscriptionInfo(
    plan: str,
    generations_limit: int?,
    generations_used: int,
    remaining: int?
  )
}
fn new() · Self {
    telegram_id: telegram_id,
    total_renders: total_renders,
    free_remaining: free_remaining,
    subscription: subscription
  
}

  # Auto-generated getters
fn telegram_id(self) · self.telegram_id


  # Auto-generated getters
fn plan(self) · self.plan

fn generations_limit(self) · self.generations_limit

fn generations_used(self) · self.generations_used

fn remaining(self) · self.remaining

fn total_renders(self) · self.total_renders

fn free_remaining(self) · self.free_remaining

fn subscription(self) · self.subscription


// =============================================================================
// GET /api/render-quota?telegram_id=123
// Check render quota for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
// =============================================================================

GET /api/render-quota "Check render quota for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}"
  metrics("render.quota")
  @Quota returned: valid_telegram_id(telegram_id) → check_quota() → result.telegram_id != null

  telegram_id: str!  @query

  → {
    telegram_id: int!,
    total_renders: int!,
    free_remaining: int!,
    is_admin: bool!,
    subscription: json?
  }

@spec check_quota_handler(req: Request(Connection)) → Response(ResponseData) {
  /// GET /api/render-quota?telegram_id=123
  /// Check render quota for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  given: HTTP request with telegram_id query param
  when: Checking type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}'s render quota
  then: Returns quota info with subscription status
}

@impl {
  // Parse telegram_id from query string
  let query = request_get_query(req)
  let telegram_id_result = match query {
    ✅params) → {
      match "telegram_id" · find_param {
        ☐id_str) → int_parse(id_str)
        ∅-> ❌Nil)
      }
    }
    ❌_) → ❌Nil)
  }

  match telegram_id_result {
    ❌_) → {
      "Missing or invalid telegram_id parameter" · json_error_response
    }
    ✅telegram_id) → {
      log_info("[QUOTA] Checking quota for telegram_id: int_$(telegram_id))

      let pool_result = get_global_pool()
      log_info("[QUOTA] Pool result: inspect(pool_result))

      match pool_result {
        ∅-> {
          log_error("[QUOTA] ERROR: Database pool is ∅!")
          "Database not connected" · json_error_response
        }
        ☐pool) → {
          // Get render count from database
          let total_renders = telegram_id · get_render_count
          let free_remaining = FREE_RENDERS_LIMIT - total_renders · max

          // Check subscription
          let subscription = telegram_id · get_subscription

          // Check if type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} is admin
          let is_admin = telegram_id · check_is_admin

          json_success_response(json_object([
            #("telegram_id", json_int(telegram_id)),
            #("total_renders", json_int(total_renders)),
            #("free_remaining", json_int(free_remaining)),
            #("is_admin", json_bool(is_admin)),
            #("subscription", match subscription {
              ☐sub) → json_object([
                #("plan", json_string(sub.plan)),
                #("generations_limit", match sub.generations_limit {
                  ☐l) → json_int(l)
                  ∅-> json_null()
                },
                #("generations_used", json_int(sub.generations_used)),
                #("remaining", match sub.remaining {
                  ☐r) → json_int(r)
                  ∅-> json_null()
                }
              ])
              ∅-> json_null()
            }
          ]))
        }
      }
    }
  }
}

// =============================================================================
// POST /api/render-log
// Log a render for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
// =============================================================================

POST /api/render-log "Log a render for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}"
  metrics("render.quota")
  @Render logged: valid_telegram_id(telegram_id) → log_render() → success == true

  telegram_id: int!  @body

  → {
    success: bool!,
    telegram_id: int!,
    renders_used: int!
  }

@spec log_render_handler(req: Request(Connection)) → Response(ResponseData) {
  /// POST /api/render-log
  /// Log a render for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  /// Body: {"telegram_id": 123}
  given: HTTP request with telegram_id in body
  when: Logging a render
  then: Returns success with updated render count
}

@impl {
  // Read body
  match 1024 * 1024 · mist_read_body {
    ✅body_req) → {
      let body_str = match bit_array_$(body_req.body) {
        ✅s) → s
        ❌_) → ""
      }

      // Parse JSON body - extract telegram_id
      match parse_telegram_id_from_json(body_str) {
        ✅telegram_id) → {
          match get_global_pool() {
            ∅-> "Database not connected" · json_error_response
            ☐pool) → {
              match telegram_id · log_render {
                ✅total_renders) → {
                  json_success_response(json_object([
                    #("success", json_bool(true)),
                    #("telegram_id", json_int(telegram_id)),
                    #("renders_used", json_int(total_renders))
                  ]))
                }
                ❌err) → {
                  log_error("Failed to log render: {err})
                  "Failed to log render: {err} · json_error_response
                }
              }
            }
          }
        }
        ❌_) → {
          "Invalid JSON body. Expected: {\"telegram_id\": 123}" · json_error_response
        }
      }
    }
    ❌_) → {
      "Failed to read request body" · json_error_response
    }
  }
}

// =============================================================================
// DATABASE FUNCTIONS
// =============================================================================

@spec get_render_count(pool: Connection, telegram_id: int) → int {
  /// Get total render count for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  given: Database connection and telegram ID
  when: Checking render count
  then: Returns total renders (0 if none/error)
}

@impl {
  // Use $1::bigint to ensure proper type matching with BIGINT column
  let sql = "SELECT COUNT(*)::int FROM render_logs WHERE telegram_id = $1::bigint"

  let result = pog_query(sql)
    · pog_parameter(pog_int(telegram_id))
    · pog_returning(count_decoder())
    · pog_execute(pool)

  match result {
    ✅rows · Returned) → {
      log_info("[QUOTA] get_render_count SUCCESS: telegram_id=int_$(telegram_id) + " row_count=int_$(row_count) + " rows=inspect(rows))
      match rows {
        [count] → count
        _ → 0
      }
    }
    ❌err) → {
      log_error("[QUOTA] get_render_count ERROR: telegram_id=int_$(telegram_id) + " error=inspect(err))
      0
    }
  }
}

@spec check_is_admin(pool: Connection, telegram_id: int) → bool {
  /// Check if type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} is admin
  given: Database connection and telegram ID
  when: Checking admin status
  then: Returns true if admin, false otherwise
}

@impl {
  let sql = "SELECT is_admin FROM type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s WHERE telegram_id = $1"

  match pog_query(sql)
    · pog_parameter(pog_text(int_$(telegram_id)))
    · pog_returning(bool_decoder())
    · pog_execute(pool)
  {
    ✅[is_admin] · Returned) → is_admin
    _ → false
  }
}

@spec get_subscription(pool: Connection, telegram_id: int) → SubscriptionInfo? {
  /// Get active subscription for type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  given: Database connection and telegram ID
  when: Checking subscription status
  then: Returns ☐subscription) or ∅}

@impl {
  let sql = "
    SELECT p.code, p.generation_limit, s.generations_used
    FROM subscriptions s
    JOIN products p ON s.product_id = p.ID
    WHERE s.telegram_id = $1 AND s.status = 'active'
    ORDER BY s.created_at DESC
    LIMIT 1
  "

  match pog_query(sql)
    · pog_parameter(pog_int(telegram_id))
    · pog_returning(subscription_decoder())
    · pog_execute(pool)
  {
    ✅[sub] · Returned) → ☐sub)
    _ → ∅}
}

@spec log_render(pool: Connection, telegram_id: int) → str · Result {
  /// Log a render for a type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  given: Database connection and telegram ID
  when: Recording a render
  then: Returns ✅total_renders) or ❌message)
}

@impl {
  let sql = "
    INSERT INTO render_logs (telegram_id, composition_id)
    VALUES ($1::bigint, 'SplitTalkingHead')
  "

  match pog_query(sql)
    · pog_parameter(pog_int(telegram_id))
    · pog_execute(pool)
  {
    ✅_) → {
      // Get updated count
      ✅telegram_id · get_render_count)
    }
    ❌e) → ❌"Insert failed: pog_error_$(e))
  }
}

@spec pog_error_$(err: QueryError) → str {
  /// Convert pog error to string
  given: QueryError from pog
  when: Formatting error message
  then: Returns human-readable string
}

@impl {
  match err {
    constraint, _ · ConstraintViolated ->
      "Constraint violated: {constraint} + " - {msg}
    name, msg · PostgresqlError ->
      "PostgreSQL error {code} + " ({name} + "): {msg}
    got · UnexpectedArgumentCount ->
      "Unexpected argument count: expected "
      + int_$(expected)
      + ", got "
      + int_$(got)
    got · UnexpectedArgumentType ->
      "Unexpected argument type: expected {expected} + ", got {got}
    UnexpectedResultType(errors) ->
      "Unexpected result type: inspect(errors)
    ConnectionUnavailable → "Connection unavailable"
    QueryTimeout → "Query timeout"
  }
}

// =============================================================================
// HELPERS
// =============================================================================

@spec find_param(params: [#(str, str]), key: str) → str? {
  /// Find parameter value by key
  given: type {name} {
  items: List[Item],
  count: Int} key-value pairs and key to find
  when: Parsing query parameters
  then: Returns ☐value) or ∅}

@impl {
  match params {
    [] → ∅[#(k, v), ..rest] → {
      match k == key {
        true → ☐v)
        false → key · find_param
      }
    }
  }
}

@spec json_success_response(data: Json) → Response(ResponseData) {
  /// Create successful JSON HTTP response with CORS headers
  given: JSON data
  when: Returning success response
  then: Returns 200 response with JSON body and CORS headers
}

@impl {
  response_new(200)
  · response_set_header("content-type", "application/json")
  · response_set_header("access-control-allow-origin", "*")
  · response_set_header("access-control-allow-methods", "GET, POST, PUT, DELETE, OPTIONS")
  · response_set_header("access-control-allow-headers", "content-type, authorization, x-telegram-id")
  · response_set_body(mist_bytes(bytes_tree_from_string(json_$(data))))
}

@spec json_error_response(status: int, message: str) → Response(ResponseData) {
  /// Create error JSON HTTP response with CORS headers
  given: Status code and error message
  when: Returning error response
  then: Returns error response with JSON body and CORS headers
}

@impl {
  let body = json_object([
    #("error", json_string(message))
  ])
  response_new(status)
  · response_set_header("content-type", "application/json")
  · response_set_header("access-control-allow-origin", "*")
  · response_set_header("access-control-allow-methods", "GET, POST, PUT, DELETE, OPTIONS")
  · response_set_header("access-control-allow-headers", "content-type, authorization, x-telegram-id")
  · response_set_body(mist_bytes(bytes_tree_from_string(json_$(body))))
}

@spec parse_telegram_id_from_json(body_str) → Nil · Result {
  /// Parse telegram_id from JSON body
  given: JSON string
  when: Parsing request body
  then: Returns ✅telegram_id) or ❌Nil)
}

@impl {
  match "telegram_id" · extract_json_int {
    ☐id) → ✅id)
    ∅-> ❌Nil)
  }
}

// =============================================================================
// DECODERS
// =============================================================================

@spec count_decoder() → Decoder(int) {
  /// Decoder for COUNT(*) result
  given: Nothing
  when: Decoding count query
  then: Returns int decoder
}

@impl {
  decode_int · decode_field
  · decode_success()
}

@spec bool_decoder() → Decoder(bool) {
  /// Decoder for boolean result
  given: Nothing
  when: Decoding boolean query
  then: Returns bool decoder
}

@impl {
  decode_bool · decode_field
  · decode_success()
}

@spec subscription_decoder() → Decoder(SubscriptionInfo) {
  /// Decoder for subscription query result
  given: Nothing
  when: Decoding subscription from DB
  then: Returns SubscriptionInfo decoder
}

@impl {
  use plan <- decode_string · decode_field
  use limit <- decode_optional(decode_int · decode_field)
  use used <- decode_int · decode_field
  decode_success(generations_limit,
    generations_used,
    remaining: match limit {
      ☐l · SubscriptionInfo → ☐l - used)
      ∅-> ∅}
  ))
}

// =============================================================================
// FFI Imports
// =============================================================================

// HTTP helpers
// @ffi request_get_query(req: Request) → Result([#(str, str]), Nil)
// @ffi response_new(status: int) → Response
// @ffi response_set_header(resp: Response, key: str, value: str) → Response
// @ffi response_set_body(resp: Response, body: ResponseData) → Response
// @ffi mist_read_body(req: Request, max: int) → Nil · Result
// @ffi mist_bytes(data: BytesTree) → ResponseData
// @ffi bytes_tree_from_string(s: str) → BytesTree
// @ffi bit_array_$(bits: BitArray) → Nil · Result

// JSON helpers
// @ffi json_object(pairs: [#(str, Json])) → Json
// @ffi json_string(s: str) → Json
// @ffi json_int(n: int) → Json
// @ffi json_bool(b: bool) → Json
// @ffi json_null() → Json
// @ffi json_$(json: Json) → str
// @ffi field: str · extract_json_int → int?

// Database helpers
// @ffi get_global_pool() → Connection?
// @ffi pog_query(sql: str) → Query
// @ffi pog_parameter(query: Query, param: Parameter) → Query
// @ffi pog_returning(query: Query, decoder: Decoder) → Query
// @ffi pog_execute(query: Query, pool: Connection) → QueryError · Result
// @ffi pog_int(n: int) → Parameter
// @ffi pog_text(s: str) → Parameter

// Decode helpers
// @ffi decode_field(index: int, decoder: Decoder) → Decoder
// @ffi decode_int() → Decoder(int)
// @ffi decode_bool() → Decoder(bool)
// @ffi decode_string() → Decoder(str)
// @ffi decode_optional(decoder: Decoder) → Decoder(Option)
// @ffi decode_success(value: a) → Decoder(a)

// Utility helpers
// @ffi int_$(n: int) → str
// @ffi int_parse(s: str) → Nil · Result
// @ffi max(a: int, b: int) → int
// @ffi inspect(value: a) → str
// @ffi log_info(message: str) → Nil
// @ffi log_error(message: str) → Nil

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
