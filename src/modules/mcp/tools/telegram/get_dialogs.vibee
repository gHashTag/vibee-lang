// Telegram Get Dialogs Tool
// Retrieves list of chats, groups, and channels

import mcp/types/mcp_types.{Tool, ToolResult, Schema, Property}

// Create telegram_get_dialogs tool
fn create_tool() â†’ Tool {
  mcp_types.tool_new(
    "telegram_get_dialogs",
    "Get list of Telegram dialogs (chats, groups, channels) for a session",
    create_schema(),
    execute
  )
}

// Define input schema
fn create_schema() â†’ Schema {
  Schema {
    type_name: "object",
    properties: dict.new()
      Â· dict.insert("session_id", Property {
        type_name: "string",
        description: "Telegram session ID for authentication",
        enum_values: âˆ…
      })
      Â· dict.insert("limit", Property {
        type_name: "integer",
        description: "Maximum number of dialogs to return (default: 100)",
        enum_values: âˆ…
      })
      Â· dict.insert("type_filter", Property {
        type_name: "string",
        description: "Filter dialogs by type",
        enum_values: Some(["all", "users", "groups", "channels", "bots"])
      })
      Â· dict.insert("archived", Property {
        type_name: "boolean",
        description: "Include archived dialogs (default: false)",
        enum_values: âˆ…
      }),
    required: ["session_id"]
  }
}

// Execute tool
fn execute(params: Json) â†’ ToolResult {
  case parse_params(params) {
    Ok(p) â†’ {
      case validate_session(p.session_id) {
        Ok(_) â†’ {
          case get_telegram_dialogs(p) {
            Ok(dialogs) â†’ {
              mcp_types.tool_result_success([
                mcp_types.text_content(format_dialogs(dialogs))
              ])
            }
            Error(e) â†’ {
              mcp_types.tool_result_error("Failed to get dialogs: " + e)
            }
          }
        }
        Error(e) â†’ {
          mcp_types.tool_result_error("Invalid session: " + e)
        }
      }
    }
    Error(e) â†’ {
      mcp_types.tool_result_error("Invalid parameters: " + e)
    }
  }
}

// Parameter types
struct GetDialogsParams {
  session_id: str
  limit: int
  type_filter: str
  archived: bool
}

struct Dialog {
  id: str
  title: str
  type_name: str
  unread_count: int
  last_message: option(str)
  last_message_date: option(int)
  is_pinned: bool
  is_archived: bool
}

struct DialogList {
  dialogs: list(Dialog)
  total_count: int
}

// Parse parameters
fn parse_params(params: Json) â†’ result(GetDialogsParams, str) {
  case json.decode(params) {
    Ok(obj) â†’ {
      let session_id = dict.get(obj, "session_id")
        Â· result.map(json.to_string)
        Â· result.unwrap("")
      
      let limit = dict.get(obj, "limit")
        Â· result.map(json.to_int)
        Â· result.unwrap(100)
      
      let type_filter = dict.get(obj, "type_filter")
        Â· result.map(json.to_string)
        Â· result.unwrap("all")
      
      let archived = dict.get(obj, "archived")
        Â· result.map(json.to_bool)
        Â· result.unwrap(false)
      
      case session_id {
        "" â†’ Error("session_id is required")
        _ â†’ Ok(GetDialogsParams {
          session_id: session_id,
          limit: limit,
          type_filter: type_filter,
          archived: archived
        })
      }
    }
    Error(_) â†’ Error("Invalid JSON")
  }
}

// Validate session
fn validate_session(session_id: str) â†’ result(Nil, str) {
  case session_id {
    "" â†’ Error("Session ID cannot be empty")
    _ â†’ Ok(Nil)
  }
}

// Get dialogs from Telegram
fn get_telegram_dialogs(params: GetDialogsParams) â†’ result(DialogList, str) {
  // TODO: Implement actual Telegram API call
  // This would use the telegram bridge
  
  // Mock data for now
  let mock_dialogs = [
    Dialog {
      id: "user_123",
      title: "John Doe",
      type_name: "user",
      unread_count: 3,
      last_message: Some("Hey, how are you?"),
      last_message_date: Some(timestamp_now()),
      is_pinned: true,
      is_archived: false
    },
    Dialog {
      id: "group_456",
      title: "Dev Team",
      type_name: "group",
      unread_count: 15,
      last_message: Some("Meeting at 3pm"),
      last_message_date: Some(timestamp_now() - 3600),
      is_pinned: false,
      is_archived: false
    },
    Dialog {
      id: "channel_789",
      title: "Tech News",
      type_name: "channel",
      unread_count: 42,
      last_message: Some("New AI breakthrough announced"),
      last_message_date: Some(timestamp_now() - 7200),
      is_pinned: false,
      is_archived: false
    }
  ]
  
  // Apply filters
  let filtered = mock_dialogs
    Â· filter_by_type(params.type_filter)
    Â· filter_by_archived(params.archived)
    Â· list.take(params.limit)
  
  Ok(DialogList {
    dialogs: filtered,
    total_count: list.length(filtered)
  })
}

// Filter dialogs by type
fn filter_by_type(dialogs: list(Dialog), type_filter: str) â†’ list(Dialog) {
  case type_filter {
    "all" â†’ dialogs
    filter â†’ list.filter(dialogs, fn(d) { d.type_name == filter })
  }
}

// Filter dialogs by archived status
fn filter_by_archived(dialogs: list(Dialog), include_archived: bool) â†’ list(Dialog) {
  case include_archived {
    true â†’ dialogs
    false â†’ list.filter(dialogs, fn(d) { !d.is_archived })
  }
}

// Format dialogs for output
fn format_dialogs(result: DialogList) â†’ str {
  let header = "Found " + int.to_string(result.total_count) + " dialogs:\n\n"
  
  let dialog_lines = result.dialogs
    Â· list.map(format_dialog)
    Â· list.intersperse("\n")
    Â· string.concat()
  
  header + dialog_lines
}

// Format single dialog
fn format_dialog(dialog: Dialog) â†’ str {
  let pinned = case dialog.is_pinned {
    true â†’ "ðŸ“Œ "
    false â†’ ""
  }
  
  let unread = case dialog.unread_count {
    0 â†’ ""
    n â†’ " (" + int.to_string(n) + " unread)"
  }
  
  let last_msg = case dialog.last_message {
    Some(msg) â†’ "\n  Last: " + msg
    âˆ… â†’ ""
  }
  
  pinned + dialog.title + " [" + dialog.type_name + "]" + unread + last_msg
}

// Get current timestamp
fn timestamp_now() â†’ int {
  // TODO: Implement actual timestamp
  1704902400
}

// Export tool
fn get_tool() â†’ Tool {
  create_tool()
}
