// Telegram Get History Tool
// Retrieves message history from a chat

import mcp/types/mcp_types.{Tool, ToolResult, Schema, Property}

// Create telegram_get_history tool
fn create_tool() â†’ Tool {
  mcp_types.tool_new(
    "telegram_get_history",
    "Get message history from a Telegram chat, group, or channel",
    create_schema(),
    execute
  )
}

// Define input schema
fn create_schema() â†’ Schema {
  Schema {
    type_name: "object",
    properties: dict.new()
      Â· dict.insert("session_id", Property {
        type_name: "string",
        description: "Telegram session ID for authentication",
        enum_values: âˆ…
      })
      Â· dict.insert("chat_id", Property {
        type_name: "string",
        description: "Target chat ID to get history from",
        enum_values: âˆ…
      })
      Â· dict.insert("limit", Property {
        type_name: "integer",
        description: "Maximum number of messages to return (default: 50)",
        enum_values: âˆ…
      })
      Â· dict.insert("offset_id", Property {
        type_name: "integer",
        description: "Message ID to start from (for pagination)",
        enum_values: âˆ…
      })
      Â· dict.insert("reverse", Property {
        type_name: "boolean",
        description: "Get messages in reverse order (oldest first)",
        enum_values: âˆ…
      }),
    required: ["session_id", "chat_id"]
  }
}

// Execute tool
fn execute(params: Json) â†’ ToolResult {
  case parse_params(params) {
    Ok(p) â†’ {
      case validate_session(p.session_id) {
        Ok(_) â†’ {
          case get_telegram_history(p) {
            Ok(history) â†’ {
              mcp_types.tool_result_success([
                mcp_types.text_content(format_history(history))
              ])
            }
            Error(e) â†’ {
              mcp_types.tool_result_error("Failed to get history: " + e)
            }
          }
        }
        Error(e) â†’ {
          mcp_types.tool_result_error("Invalid session: " + e)
        }
      }
    }
    Error(e) â†’ {
      mcp_types.tool_result_error("Invalid parameters: " + e)
    }
  }
}

// Parameter types
struct GetHistoryParams {
  session_id: str
  chat_id: str
  limit: int
  offset_id: option(int)
  reverse: bool
}

struct Message {
  id: int
  from_id: str
  from_name: str
  text: str
  date: int
  reply_to: option(int)
  media_type: option(str)
  is_outgoing: bool
}

struct MessageHistory {
  messages: list(Message)
  total_count: int
  chat_id: str
}

// Parse parameters
fn parse_params(params: Json) â†’ result(GetHistoryParams, str) {
  case json.decode(params) {
    Ok(obj) â†’ {
      let session_id = dict.get(obj, "session_id")
        Â· result.map(json.to_string)
        Â· result.unwrap("")
      
      let chat_id = dict.get(obj, "chat_id")
        Â· result.map(json.to_string)
        Â· result.unwrap("")
      
      let limit = dict.get(obj, "limit")
        Â· result.map(json.to_int)
        Â· result.unwrap(50)
      
      let offset_id = dict.get(obj, "offset_id")
        Â· result.map(json.to_int)
        Â· result.to_option()
      
      let reverse = dict.get(obj, "reverse")
        Â· result.map(json.to_bool)
        Â· result.unwrap(false)
      
      case session_id, chat_id {
        "", _ â†’ Error("session_id is required")
        _, "" â†’ Error("chat_id is required")
        _, _ â†’ Ok(GetHistoryParams {
          session_id: session_id,
          chat_id: chat_id,
          limit: limit,
          offset_id: offset_id,
          reverse: reverse
        })
      }
    }
    Error(_) â†’ Error("Invalid JSON")
  }
}

// Validate session
fn validate_session(session_id: str) â†’ result(Nil, str) {
  case session_id {
    "" â†’ Error("Session ID cannot be empty")
    _ â†’ Ok(Nil)
  }
}

// Get message history from Telegram
fn get_telegram_history(params: GetHistoryParams) â†’ result(MessageHistory, str) {
  // TODO: Implement actual Telegram API call
  // This would use the telegram bridge
  
  // Mock data for now
  let mock_messages = [
    Message {
      id: 1001,
      from_id: "user_123",
      from_name: "John Doe",
      text: "Hey, how are you?",
      date: timestamp_now() - 3600,
      reply_to: âˆ…,
      media_type: âˆ…,
      is_outgoing: false
    },
    Message {
      id: 1002,
      from_id: "me",
      from_name: "Me",
      text: "I'm good, thanks! How about you?",
      date: timestamp_now() - 3500,
      reply_to: Some(1001),
      media_type: âˆ…,
      is_outgoing: true
    },
    Message {
      id: 1003,
      from_id: "user_123",
      from_name: "John Doe",
      text: "Great! Check out this photo",
      date: timestamp_now() - 3400,
      reply_to: âˆ…,
      media_type: Some("photo"),
      is_outgoing: false
    },
    Message {
      id: 1004,
      from_id: "me",
      from_name: "Me",
      text: "Nice! ğŸ‘",
      date: timestamp_now() - 3300,
      reply_to: Some(1003),
      media_type: âˆ…,
      is_outgoing: true
    }
  ]
  
  // Apply filters
  let filtered = mock_messages
    Â· apply_offset(params.offset_id)
    Â· apply_reverse(params.reverse)
    Â· list.take(params.limit)
  
  Ok(MessageHistory {
    messages: filtered,
    total_count: list.length(filtered),
    chat_id: params.chat_id
  })
}

// Apply offset filter
fn apply_offset(messages: list(Message), offset_id: option(int)) â†’ list(Message) {
  case offset_id {
    âˆ… â†’ messages
    Some(id) â†’ list.filter(messages, fn(m) { m.id > id })
  }
}

// Apply reverse order
fn apply_reverse(messages: list(Message), reverse: bool) â†’ list(Message) {
  case reverse {
    true â†’ list.reverse(messages)
    false â†’ messages
  }
}

// Format history for output
fn format_history(history: MessageHistory) â†’ str {
  let header = "Message history for chat " + history.chat_id + 
               " (" + int.to_string(history.total_count) + " messages):\n\n"
  
  let message_lines = history.messages
    Â· list.map(format_message)
    Â· list.intersperse("\n")
    Â· string.concat()
  
  header + message_lines
}

// Format single message
fn format_message(msg: Message) â†’ str {
  let direction = case msg.is_outgoing {
    true â†’ "â†’"
    false â†’ "â†"
  }
  
  let reply = case msg.reply_to {
    Some(id) â†’ " (reply to " + int.to_string(id) + ")"
    âˆ… â†’ ""
  }
  
  let media = case msg.media_type {
    Some(t) â†’ " [" + t + "]"
    âˆ… â†’ ""
  }
  
  let timestamp = format_timestamp(msg.date)
  
  direction + " [" + int.to_string(msg.id) + "] " + 
  msg.from_name + " (" + timestamp + ")" + reply + media + ":\n  " + msg.text
}

// Format timestamp
fn format_timestamp(ts: int) â†’ str {
  // TODO: Implement proper date formatting
  int.to_string(ts)
}

// Get current timestamp
fn timestamp_now() â†’ int {
  // TODO: Implement actual timestamp
  1704902400
}

// Export tool
fn get_tool() â†’ Tool {
  create_tool()
}
