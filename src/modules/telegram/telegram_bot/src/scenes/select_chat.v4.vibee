// Select Chat Wizard
  // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// Chat/channel selector for publishing and monitoring
  // Performance Warning: // Based on 999-multibots-telegraf selectChatWizard

import "../i18n/scenes_i18n.vibee" as i18n

scene SelectChat:
  desc: "Select Telegram chat or channel for actions"

  @spec "Chat selected": type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} picks → returns chat info
  @spec "Chats loaded": type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} authorized → dialogs fetched

  state on_select_callback · Select:
    enter → lang = get_type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_language(type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id)
          → session = get_active_session()
          → case session:
               ∅-> {
                 → reply(case lang: "en" → "Telegram not connected. Connect account in settings." _ → "Telegram ne podklyuchen. Podklyuchite akkaunt v nastroikakh.")
                 → buttons [case lang: "en" → "Settings" _ → "Nastroiki" @settings,
                             i18n:common.back @back]
               }
               session → {
                 → reply(case lang: "en" → "Loading chats..." _ → "Zagruzhayu chaty...")
                 → dialogs = fetch_dialogs(session.id)
                 → filtered = action_type · filter_dialogs_for_action
                 → action_type, on_select_callback · ShowChats
               }

    "settings" → exit_to(Settings)
    "back"     → exit_cancel

  state action_type, on_select_callback · ShowChats:
    enter → lang = get_type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_language(type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id)
          → grouped = group_dialogs(dialogs)
          → reply(case lang:
               "en" → """
                 <b>Select chat</b>

                 #{lang · action_type_hint}

                 Channels: #{length(grouped.channels)}
                 Groups: #{length(grouped.groups)}
                 Private: #{length(grouped.private)}
                 """
               _ → """
                 <b>Vyberite chat</b>

                 #{lang · action_type_hint}

                 Kanaly: #{length(grouped.channels)}
                 Gruppy: #{length(grouped.groups)}
                 Lichnye: #{length(grouped.private)}
                 """)
          → buttons [case lang: "en" → "Channels" _ → "Kanaly" @type:channels,
                      case lang: "en" → "Groups" _ → "Gruppy" @type:groups,
                      case lang: "en" → "Private chats" _ → "Lichnye chaty" @type:private,
                      case lang: "en" → "Search" _ → "Poisk" @search,
                      i18n:common.back @back]
          → stay(grouped)

    "type:channels" | "type:groups" | "type:private" → match:
      "type:channels" → ChatList(grouped.channels, "channels", action_type, on_select_callback)
      "type:groups"   → ChatList(grouped.groups, "groups", action_type, on_select_callback)
      "type:private"  → ChatList(grouped.private, "private", action_type, on_select_callback)
    "search" → action_type, on_select_callback · SearchChat
    "back"   → exit_cancel

  state chat_type, action_type, on_select_callback · ChatList:
    enter → page = current_page ?? 0
          → page_size = 8
          → paginated = chats · drop(page * page_size) · take(page_size)
          → total_pages = (length(chats) + page_size - 1) / page_size

          → reply("""
              #{chat_type_title(chat_type)}

              Stranitsa #{page + 1} iz #{total_pages}
              """)

          → chat_buttons = paginated
               · map(fn(c) {
                    icon = case c.unread_count > 0: true → "[new]" false → ""
                    button(icon ++ c.title, "chat:{to_string}"(c.id))
                  }

          → nav_buttons = []
          → nav_buttons = case page > 0:
               true → [button("Nazad", "prev"), ...nav_buttons]
               false → nav_buttons
          → nav_buttons = case page < total_pages - 1:
               true → [...nav_buttons, button("Dalee", "next")]
               false → nav_buttons

          → show_keyboard(chat_buttons ++ nav_buttons  + [
               button("K kategoriyam", "back")
             ])

          → stay(current_page)

    /^chat:(.+)$/:
      → chat_id = parse_int(extract_id(callback_data))
      → chat = chat_id · find_chat_by_id
      → action_type, on_select_callback · ConfirmChat

    "prev":
      → stay(current_page - 1)
      → enter

    "next":
      → stay(current_page + 1)
      → enter

    "back" → action_type, on_select_callback · ShowChats

  state action_type, on_select_callback · SearchChat:
    enter → reply("""
              <b>Poisk chata</b>

              Vvedite nazvanie chata:
              """)
          → buttons ["Otmena" @cancel]

    message TextMessage(query):
      → results = query · search_dialogs
      → case results:
           [] → reply("Nichego ne naideno po zaprosu: <b>#{query}</b>") && stay
           list → "search", action_type, on_select_callback · ChatList

    "cancel" → action_type, on_select_callback · ShowChats

  state action_type, on_select_callback · ConfirmChat:
    enter → permissions = check_chat_permissions(chat.id, action_type)
          → reply("""
              #{chat_type_icon(chat.type)} <b>#{chat.title}</b>

              Uchastnikov: #{chat.members_count ?? "-"}
              Opisanie: #{chat.description ?? "-"}

              #{format_permissions(permissions)}
              """)
          → case permissions.can_perform:
               true → buttons ["Vybrat" @confirm, "Nazad" @back]
               false → buttons ["Nazad" @back]

    "confirm":
      → chat · callback_with_data

    "back" → exit_cancel

// =============================================================================
// MULTI-SELECT CHATS
// =============================================================================

scene MultiChatSelect:
  desc: "Select multiple chats (e.g., for broadcast)"

  @spec "Multiple chats selected": type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} picks → returns list

  state min_count, max_count, on_select_callback · Select:
    enter → session = get_active_session()
          → case session:
               ∅-> {
                 → reply("Telegram ne podklyuchen")
                 → exit_cancel
               }
               session → {
                 → dialogs = fetch_dialogs(session.id)
                 → filtered = action_type · filter_dialogs_for_action
                 → action_type, min_count, max_count, on_select_callback, [] · SelectMultiple
               }

  state action_type, min_count, max_count, on_select_callback, selected · SelectMultiple:
    enter → reply("""
              <b>Vyberite chaty</b>

              Vybrano: #{length(selected)} / #{max_count}
              Minimum: #{min_count}
              """)
          → chat_buttons = dialogs
               · take(10)
               · map(fn(c) {
                    is_selected = c.id · contains_chat
                    icon = case is_selected: true → "[x]" false → chat_type_icon(c.type)
                    button(" {c}{icon}".title, "toggle:{to_string}"(c.id))
                  }
          → show_keyboard(chat_buttons  + [
               button("Gotovo ({to_string}"(length(selected)) + ")", "done") · if_enabled(length(selected) >= min_count),
               button("Otmena", "cancel")
             ])

    /^toggle:(.+)$/:
      → chat_id = parse_int(extract_id(callback_data))
      → chat = chat_id · find_chat_by_id
      → new_selected = chat, max_count · toggle_chat_selection
      → stay(selected: new_selected)
      → enter

    "done":
      → case length(selected) >= min_count:
           true → selected · callback_with_data
           false → reply("Vyberite minimum #{min_count} chatov")

    "cancel" → exit_cancel

// =============================================================================
// RECENT CHATS
// =============================================================================

scene RecentChats:
  desc: "Quick access to recently used chats"

  @spec "Recent shown": type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} views → sees last used chats

  state on_select_callback · Show:
    enter → recent = get_recent_chats(type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, action_type)
          → case recent:
               [] → {
                 → reply("Net nedavnikh chatov")
                 → on_select_callback · Select
               }
               list → {
                 → reply("""
                     <b>Nedavnie chaty</b>

                     Bystryi vybor:
                     """)
                 → buttons = list
                      · take(5)
                      · map(fn(c) { button(chat_type_icon(c.type) + " {c}".title, "chat:{to_string}"(c.id)) }
                 → show_keyboard(buttons  + [
                      button("Vse chaty", "all"),
                      button("Nazad", "back")
                    ])
               }

    /^chat:(.+)$/:
      → chat_id = parse_int(extract_id(callback_data))
      → chat = get_chat_by_id(chat_id)
      → chat · callback_with_data

    "all"  → on_select_callback · Select
    "back" → exit_cancel

// =============================================================================
// CONSTANTS
// =============================================================================

let ACTION_HINTS = const({
  "publish": "Vyberite chat dlya publikatsii kontenta",
  "monitor": "Vyberite chat dlya monitoringa",
  "forward": "Vyberite chat dlya peresylki",
  "broadcast": "Vyberite chaty dlya rassylki"
}

let CHAT_TYPE_ICONS = const({
  "channel": "[ch]",
  "supergroup": "[gr]",
  "group": "[gr]",
  "private": "[pm]",
  "bot": "[bot]"
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

action_type · filter_dialogs_for_action:
  case action_type:
    "publish" → dialogs · filter({ it.type in ["channel", "supergroup"] && it.can_post }
    "monitor" → dialogs · filter({ it.type in ["channel", "supergroup", "group"] }
    "forward" → dialogs
    "broadcast" → dialogs · filter({ it.type == "private" }
    _ → dialogs

group_dialogs(dialogs):
  {
    channels: dialogs · filter({ it.type == "channel" },
    groups: dialogs · filter({ it.type in ["supergroup", "group"] },
    private: dialogs · filter({ it.type == "private" }
  }

cache(1h)
@spec chat_type_title(chat_type: str) → str {
  /// Returns formatted HTML title for chat type
  given: Chat type string (channels, groups, private, search)
  when: Displaying chat category header
  then: Returns localized HTML title
}

@impl {
  case chat_type:
    "channels" → "<b>Kanaly</b>"
    "groups" → "<b>Gruppy</b>"
    "private" → "<b>Lichnye chaty</b>"
    "search" → "<b>Rezultaty poiska</b>"
    _ → "<b>Chaty</b>"
}

cache(1h)
@spec chat_type_icon(chat_type: str) → str {
  /// Returns icon for chat type
  given: Chat type string
  when: Displaying chat in list
  then: Returns icon from CHAT_TYPE_ICONS or default
}

@impl {
  CHAT_TYPE_ICONS[chat_type] ?? "[chat]"
}

cache(1h)
@spec action_type_hint(action_type: str, lang: str) → str {
  /// Returns localized hint for action type
  given: Action type and language code
  when: Displaying action description in chat selector
  then: Returns localized hint string
}

@impl {
  case lang:
    "en" → case action_type:
      "publish" → "Select chat for publishing content"
      "monitor" → "Select chat for monitoring"
      "forward" → "Select chat for forwarding"
      "broadcast" → "Select chats for broadcast"
      _ → "Select chat:"
    _ → ACTION_HINTS[action_type] ?? "Vyberite chat:"
}

query · search_dialogs:
  lower_query = string.lowercase(query)
  dialogs · filter(fn(d) {
    string.contains(string.lowercase(d.title), lower_query)
  }

chat_id · find_chat_by_id:
  chats · find({ it.id == chat_id }

chat_id · contains_chat:
  selected · any({ it.id == chat_id }

chat, max_count · toggle_chat_selection:
  case chat.id · contains_chat:
    true → { it.id != chat.id }
    false → case length(selected · filter < max_count:
      true → [chat, ...selected]
      false → selected

action_type · check_chat_permissions:
  // Check if type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} has required permissions
  case action_type:
    "publish" → { can_perform: can_post_to_chat(chat_id), reason: "Net prav na publikatsiyu" }
    "monitor" → { can_perform: true, reason: nil }
    _ → { can_perform: true, reason: nil }

format_permissions(permissions):
  case permissions.can_perform:
    true → "Dostupno dlya vybrannogo deistviya"
    false → permissions.reason

get_recent_chats(type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, action_type):
  db_query("SELECT c.* FROM chats c JOIN recent_chats r ON c.id = r.chat_id WHERE r.type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id = ? AND r.action_type = ? ORDER BY r.used_at DESC LIMIT 5", [type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, action_type])

# v8.0

# v10.0 - ML-Powered Migration
