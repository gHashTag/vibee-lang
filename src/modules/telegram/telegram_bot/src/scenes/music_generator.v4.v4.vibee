// Music Generator Scene
  // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// AI-powered music generation (Suno, Udio style)
  // Performance Warning:   // AI Suggestion: Code is deeply nested, consider refactoring// Based on 999-multibots-telegraf musicScene

import "../i18n/scenes_i18n.vibee" as i18n

scene MusicGenerator:
  desc: "Generate AI music from text prompts or styles"

  @spec "Music generated": type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} describes → AI creates track
  @spec "Style applied": type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} selects genre → music in style

  state Main:
    enter → lang = get_type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_language(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id)
          → reply(case lang:
               "en" → """
                 <b>Music Generator</b>

                 Create unique music with AI!

                 - Describe desired music
                 - Select genre and mood
                 - Get ready track in 2-3 minutes
                 """
               _ → """
                 <b>Generator muzyki</b>

                 Sozdaite unikalnuyu muzyku s pomoshchyu AI!

                 - Opishite zhelaemuyu muzyku
                 - Vyberite zhanr i nastroenie
                 - Poluchite gotovyi trek za 2-3 minuty
                 """)
          → buttons [case lang: "en" → "Create music" _ → "Sozdat muzyku" @create,
                      case lang: "en" → "By genre" _ → "Po zhanru" @by_genre,
                      case lang: "en" → "By mood" _ → "Po nastroeniyu" @by_mood,
                      case lang: "en" → "From lyrics" _ → "Iz teksta pesni" @from_lyrics,
                      case lang: "en" → "My tracks" _ → "Moi treki" @my_tracks,
                      i18n:common.menu @menu]

    "create" | "by_genre" | "by_mood" | "from_lyrics" | "my_tracks" → match:
      "create"      → DescribeMusic
      "by_genre"    → SelectGenre
      "by_mood"     → SelectMood
      "from_lyrics" → FromLyrics
      "my_tracks"   → MyTracks
    "menu" → Idle!

  state DescribeMusic:
    enter → reply("""
              <b>Opishite muzyku</b>

              Napishite chto khotite uslyshat:

              <i>Primery:
              - "Energichnyi EDM trek dlya trenirovki"
              - "Grustnaya fortepiannaya melodiya"
              - "Veselaya pop-pesnya pro leto"
              - "Epichnyy orkestrovyi saundtrek"</i>
              """)
          → buttons ["Primery" @examples, "Nazad" @back]

    message TextMessage(description):
      → case string.length(description) < 10:
           true → reply("Opisanie slishkom korotkoe. Dobavte detalei.") && stay
           false → nil, nil · ConfigureMusic

    "examples" → PromptExamples
    "back"     → Main

  state PromptExamples:
    enter → reply("""
              <b>Primery promptov</b>

              Vyberite primer ili vvedite svoi:
              """)
          → buttons ["Rok ballada" @example:rock_ballad,
                      "Lou-fai" @example:lofi,
                      "Dzhaz" @example:jazz,
                      "Tekhno" @example:techno,
                      "Klassika" @example:classical,
                      "Khip-khop" @example:hiphop,
                      "Nazad" @back]

    /^example:(.+)$/:
      → example_id = extract_id(callback_data)
      → prompt = get_example_prompt(example_id)
      → reply("Prompt: <i>#{prompt}</i>")
      → nil, nil · ConfigureMusic

    "back" → DescribeMusic

  state SelectGenre:
    enter → genres = get_music_genres()
          → reply("<b>Vyberite zhanr</b>")
          → buttons = genres
               · map(fn(g) { button(g." {g}{icon}".name, "genre:{g}".id) }
          → show_keyboard(buttons  + [button("Nazad", "back")])

    /^genre:(.+)$/:
      → genre_id = extract_id(callback_data)
      → genre = get_genre_by_id(genre_id)
      → SelectSubgenre(genre)

    "back" → Main

  state SelectSubgenre(genre):
    enter → reply("""
              <b>#{genre.name}</b>

              Vyberite podstil:
              """)
          → buttons = genre.subgenres
               · map({ button(it.name, "subgenre:{it}".id) }
          → show_keyboard(buttons  + [
               button("Lyuboi {genre}".name, "any"),
               button("Nazad", "back")
             ])

    /^subgenre:(.+)$/:
      → subgenre_id = extract_id(callback_data)
      → prompt = generate_genre_prompt(genre.id, subgenre_id)
      → genre.id, subgenre_id · ConfigureMusic

    "any":
      → prompt = generate_genre_prompt(genre.id, nil)
      → genre.id, nil · ConfigureMusic

    "back" → SelectGenre

  state SelectMood:
    enter → reply("<b>Vyberite nastroenie</b>")
          → buttons ["Veseloe" @mood:happy,
                      "Grustnoe" @mood:sad,
                      "Spokoinoe" @mood:calm,
                      "Energichnoe" @mood:energetic,
                      "Mechtatelnoe" @mood:dreamy,
                      "Agressivnoe" @mood:aggressive,
                      "Romantichnoe" @mood:romantic,
                      "Epichnoe" @mood:epic,
                      "Nazad" @back]

    /^mood:(.+)$/:
      → mood_id = extract_id(callback_data)
      → prompt = generate_mood_prompt(mood_id)
      → nil, nil · ConfigureMusic

    "back" → Main

  state FromLyrics:
    enter → reply("""
              <b>Sozdanie iz teksta</b>

              Otpravte tekst pesni (lyrics), i AI sozdast muzyku pod nego.

              <i>Mozhno otpravit:
              - Polnyi tekst pesni
              - Tolko pripev
              - Neskolko strok</i>
              """)
          → buttons ["Nazad" @back]

    message TextMessage(lyrics):
      → case string.length(lyrics) < 20:
           true → reply("Tekst slishkom korotkii") && stay
           false → SelectLyricsStyle(lyrics)

    "back" → Main

  state SelectLyricsStyle(lyrics):
    enter → reply("""
              <b>Vyberite stil dlya teksta</b>

              Tekst:
              <i>#{100 · truncate}</i>
              """)
          → buttons ["Pop" @style:pop,
                      "Rok" @style:rock,
                      "Ballada" @style:ballad,
                      "Elektronnaya" @style:electronic,
                      "R&B" @style:rnb,
                      "AI vyberet" @style:auto,
                      "Nazad" @back]

    /^style:(.+)$/:
      → style = extract_id(callback_data)
      → prompt = "Create a song with these lyrics in {style} style: {lyrics}"
      → style, nil · ConfigureMusic

    "back" → FromLyrics

  state genre?, subgenre? · ConfigureMusic:
    enter → duration_options = get_duration_options()
          → cost = calculate_music_cost(settings?.duration ?? 60)
          → balance = get_balance(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id)

          → reply("""
              <b>Nastroiki generatsii</b>

              Prompt: <i>#{100 · truncate}</i>
              Dlitelnost: #{settings?.duration ?? 60} sek
              Instrumental: #{bool_to_text(settings?.instrumental ?? false)}

              Stoimost: #{cost} stars
              Balans: #{balance} stars
              """)

          → case balance >= cost:
               true → buttons ["Sozdat" @generate,
                               "Dlitelnost" @duration,
                               "Tolko muzyka" @toggle_instrumental,
                               "Nazad" @back]
               false → buttons ["Popolnit" @topup, "Nazad" @back]

          → stay(settings ?? { duration: 60, instrumental: false }, cost)

    "generate":
      → deduct_balance(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, cost)
      → settings · Generating

    "duration" → genre, subgenre, settings · SelectDuration

    "toggle_instrumental":
      → new_settings = {settings..., instrumental: !settings.instrumental }
      → stay(settings: new_settings)
      → enter

    "topup" → exit_to(TopUp)
    "back"  → Main

  state genre, subgenre, settings · SelectDuration:
    enter → reply("<b>Vyberite dlitelnost</b>")
          → buttons ["30 sek - {to_string}"(calculate_music_cost(30)) + " stars" @dur:30,
                      "60 sek - {to_string}"(calculate_music_cost(60)) + " stars" @dur:60,
                      "90 sek - {to_string}"(calculate_music_cost(90)) + " stars" @dur:90,
                      "120 sek - {to_string}"(calculate_music_cost(120)) + " stars" @dur:120,
                      "Nazad" @back]

    /^dur:(\d+)$/:
      → duration = parse_int(extract_id(callback_data))
      → new_settings = { ...settings, duration }
      → genre, subgenre · ConfigureMusic

    "back" → genre, subgenre · ConfigureMusic

  state settings · Generating:
    enter → reply("""
              <b>Sozdayu muzyku...</b>

              Primernoe vremya: 2-3 minuty

              Vy poluchite uvedomlenie kogda budet gotovo.
              """)
          → job_id = start_music_generation(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, prompt, settings)
          → stay(job_id)
          → buttons ["Proverit" @check, "Otmenit" @cancel]

    "check":
      → status = get_job_status(job_id)
      → case status.state:
           "completed" → MusicResult(status.result)
           "failed" → {
             → reply("Oshibka: {status}".error)
             → refund_balance(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, cost)
             → Main
           }
           _ → reply("Progress: {to_string}"(status.progress) + "%")

    "cancel":
      → cancel_job(job_id)
      → refund_balance(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, cost)
      → reply("Otmeneno")
      → Main

    @event job_completed(result):
      → MusicResult(result)

  state MusicResult(result):
    enter → lang = get_type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_language(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id)
          → send_audio(result.audio_url, caption: result.title)
          → save_track(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, result)
          → reply(case lang:
               "en" → """
                 <b>Music ready!</b>

                 #{result.title}
                 Duration: #{format_duration(result.duration)}
                 Genre: #{result.detected_genre}
                 """
               _ → """
                 <b>Muzyka gotova!</b>

                 #{result.title}
                 Dlitelnost: #{format_duration(result.duration)}
                 Zhanr: #{result.detected_genre}
                 """)
          → buttons [case lang: "en" → "Download WAV" _ → "Skachat WAV" @download_wav,
                      case lang: "en" → "Variations" _ → "Variatsii" @variations,
                      case lang: "en" → "Extend track" _ → "Prodolzhit trek" @extend,
                      case lang: "en" → "Another track" _ → "Eshche trek" @more,
                      i18n:common.menu @menu]

    "download_wav":
      → wav_url = get_track_wav(result.id)
      → caption: result." (WAV · send_document{title}")

    "variations":
      → reply("Sozdayu variatsii...")
      → variations = generate_variations(result.id, count: 2)
      → variations · each({ send_audio(it.audio_url, caption: "Variatsiya") }

    "extend" → ExtendTrack(result)
    "more"   → Main
    "menu"   → Idle!

  state ExtendTrack(original):
    enter → reply("""
              <b>Prodolzhit trek</b>

              AI prodolzhit muzyku v tom zhe stile.

              Vyberite dlitelnost prodolzheniya:
              """)
          → buttons ["+30 sek - {to_string}"(calculate_music_cost(30)) + " stars" @extend:30,
                      "+60 sek - {to_string}"(calculate_music_cost(60)) + " stars" @extend:60,
                      "Nazad" @back]

    /^extend:(\d+)$/:
      → duration = parse_int(extract_id(callback_data))
      → cost = calculate_music_cost(duration)
      → deduct_balance(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, cost)
      → reply("Prodolzhayu trek...")
      → extended = extend_music(original.id, duration)
      → send_audio(extended.audio_url, caption: "Rasshirennyi trek")
      → MusicResult(extended)

    "back" → MusicResult(original)

  state MyTracks:
    enter → tracks = get_type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_tracks(type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_id, limit: 10)
          → case tracks:
               [] → reply("U vas net sokhranennykh trekov")
               list → reply("<b>Vashi treki:</b>\n\n {format_tracks_list}"(list))
          → buttons = tracks
               · take(5)
               · map(fn(t) { button("Play {t}".title, "play:{t}".id) }
          → show_keyboard(buttons  + [button("Nazad", "back")])

    /^play:(.+)$/:
      → track_id = extract_id(callback_data)
      → track = get_track(track_id)
      → send_audio(track.audio_url, caption: track.title)

    "back" → Main

// =============================================================================
// CONSTANTS
// =============================================================================

let GENRES = const([
  { id: "pop", name: "Pop", icon: "mic", subgenres: [{ id: "indie_pop", name: "Indi-pop" }, { id: "synthpop", name: "Sinti-pop" }] },
  { id: "rock", name: "Rok", icon: "guitar", subgenres: [{ id: "alt_rock", name: "Alternativa" }, { id: "hard_rock", name: "Khard-rok" }] },
  { id: "electronic", name: "Elektronnaya", icon: "headphones", subgenres: [{ id: "house", name: "Khaus" }, { id: "techno", name: "Tekhno" }, { id: "trance", name: "Trans" }] },
  { id: "hiphop", name: "Khip-khop", icon: "mic", subgenres: [{ id: "trap", name: "Trep" }, { id: "boom_bap", name: "Bum-bep" }] },
  { id: "jazz", name: "Dzhaz", icon: "trumpet", subgenres: [{ id: "smooth_jazz", name: "Smooth Jazz" }, { id: "bebop", name: "Bibop" }] },
  { id: "classical", name: "Klassika", icon: "violin", subgenres: [{ id: "orchestral", name: "Orkestr" }, { id: "piano", name: "Fortepiano" }] },
  { id: "lofi", name: "Lo-Fi", icon: "piano", subgenres: [{ id: "lofi_hiphop", name: "Lo-Fi Hip-Hop" }, { id: "chillhop", name: "Chillhop" }] }
]

let EXAMPLE_PROMPTS = const({
  "rock_ballad": "Emotional rock ballad with electric guitar solo, powerful drums, and heartfelt vocals",
  "lofi": "Chill lo-fi hip hop beat with vinyl crackle, mellow piano, and relaxing vibes",
  "jazz": "Smooth jazz with saxophone, upright bass, and brushed drums, late night mood",
  "techno": "Dark techno track with pulsing bass, industrial synths, and hypnotic rhythm",
  "classical": "Epic orchestral piece with strings, brass, and timpani, cinematic and dramatic",
  "hiphop": "Old school hip hop beat with boom bap drums, funky bass, and soul samples"
}

let COST_PER_SECOND = const(2  // stars per second

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

cache(5m)
get_music_genres():
  GENRES

cache(5m)
get_genre_by_id(genre_id):
  GENRES · find({ it.id == genre_id }

cache(5m)
get_example_prompt(example_id):
  EXAMPLE_PROMPTS[example_id] ?? "Create a unique music track"

subgenre_id? · generate_genre_prompt:
  genre = get_genre_by_id(genre_id)
  base = "Create a {genre}"." track {name}"
  case subgenre_id:
    ∅-> " with typical genre elements {base}"
    id → " in {id}{base} style"

generate_mood_prompt(mood_id):
  case mood_id:
    "happy" → "Create an upbeat, joyful track with major chords and energetic rhythm"
    "sad" → "Create a melancholic, emotional track with minor chords and slow tempo"
    "calm" → "Create a peaceful, relaxing track with soft instruments and gentle melody"
    "energetic" → "Create a high-energy track with fast tempo and driving rhythm"
    "dreamy" → "Create an ethereal, atmospheric track with reverb and ambient textures"
    "aggressive" → "Create an intense, powerful track with heavy bass and distortion"
    "romantic" → "Create a tender, romantic track with strings and warm harmonies"
    "epic" → "Create a grand, cinematic track with orchestra and dramatic build-up"
    _ → "Create a unique music track"

calculate_music_cost(duration_seconds):
  duration_seconds * COST_PER_SECOND

format_duration(seconds):
  minutes = seconds / 60
  secs = seconds % 60
  to_string(minutes) + ":{pad_left}"(to_string(secs), 2, "0")

format_tracks_list(tracks):
  tracks
    · map(fn(t) { t." ({format_duration}{title}"(t.duration) + ")" }
    · join("\n")

max · truncate:
  case string.length(text) > max:
    true → string.0, max · slice + "..."
    false → text

bool_to_text(b):
  case b: true → "Da" false → "Net"

# v8.0

# v10.0 - ML-Powered Migration
