import gleam/erlang/process
import gleam/http
import gleam/http/request
import gleam/httpc
import gleam/json
import gleam/result
import gleam/string
import gleam/int
import gleam/io
import gleam/float
import gleam/option.{type Option, None, Some}
import honeycomb/agi_chatbot/chatbot

pub type TelegramUpdate {
  TelegramUpdate(
    update_id: Int,
    message: Option(TelegramMessage),
  )
}

pub type TelegramMessage {
  TelegramMessage(
    message_id: Int,
    from: TelegramUser,
    chat: TelegramChat,
    text: Option(String),
  )
}

pub type TelegramUser {
  TelegramUser(
    id: Int,
    first_name: String,
    username: Option(String),
  )
}

pub type TelegramChat {
  TelegramChat(
    id: Int,
    chat_type: String,
  )
}

pub type BotConfig {
  BotConfig(
    token: String,
    last_update_id: Int,
  )
}

pub fn start(token: String) -> Result(Nil, String) {
  io.println("ü§ñ –ó–∞–ø—É—Å–∫ AGI Telegram –±–æ—Ç–∞...")
  io.println("Token: " <> string.slice(token, 0, 20) <> "...")
  
  let config = BotConfig(token: token, last_update_id: 0)
  
  case get_me(config) {
    Ok(bot_info) -> {
      io.println("‚úÖ –ë–æ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω: " <> bot_info)
      poll_loop(config)
    }
    Error(e) -> {
      io.println("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: " <> e)
      Error(e)
    }
  }
}

pub fn get_me(config: BotConfig) -> Result(String, String) {
  let url = "https://api.telegram.org/bot" <> config.token <> "/getMe"
  
  let req = request.to(url)
  |> result.unwrap(request.new())
  |> request.set_method(http.Get)
  
  case httpc.send(req) {
    Ok(resp) -> {
      case resp.status {
        200 -> Ok("Bot connected")
        _ -> Error("HTTP " <> int.to_string(resp.status))
      }
    }
    Error(_) -> Error("Network error")
  }
}

pub fn poll_loop(config: BotConfig) -> Result(Nil, String) {
  io.println("üì° Polling updates (offset: " <> int.to_string(config.last_update_id) <> ")...")
  
  case get_updates(config) {
    Ok(updates) -> {
      let new_config = process_updates(config, updates)
      process.sleep(1000)
      poll_loop(new_config)
    }
    Error(e) -> {
      io.println("‚ö†Ô∏è –û—à–∏–±–∫–∞ polling: " <> e)
      process.sleep(5000)
      poll_loop(config)
    }
  }
}

fn get_updates(config: BotConfig) -> Result(List(TelegramUpdate), String) {
  let url = "https://api.telegram.org/bot" 
    <> config.token 
    <> "/getUpdates?offset=" 
    <> int.to_string(config.last_update_id + 1)
    <> "&timeout=30"
  
  let req = request.to(url)
  |> result.unwrap(request.new())
  |> request.set_method(http.Get)
  
  case httpc.send(req) {
    Ok(resp) -> {
      case resp.status {
        200 -> parse_updates(resp.body)
        _ -> Error("HTTP " <> int.to_string(resp.status))
      }
    }
    Error(_) -> Error("Network error")
  }
}

fn parse_updates(body: String) -> Result(List(TelegramUpdate), String) {
  case string.contains(body, "\"result\":[]") {
    True -> Ok([])
    False -> Ok([])
  }
}

fn process_updates(config: BotConfig, updates: List(TelegramUpdate)) -> BotConfig {
  case updates {
    [] -> config
    [update, ..rest] -> {
      process_update(config, update)
      process_updates(BotConfig(..config, last_update_id: update.update_id), rest)
    }
  }
}

pub fn process_update(config: BotConfig, update: TelegramUpdate) -> Nil {
  case update.message {
    Some(msg) -> {
      case msg.text {
        Some(text) -> {
          io.println("üì® –ü–æ–ª—É—á–µ–Ω–æ: " <> text)
          
          let user_id = "tg_" <> int.to_string(msg.from.id)
          
          case chatbot.process_message(text) {
            Ok(response) -> {
              io.println("ü§ñ –û—Ç–≤–µ—Ç: " <> response.text)
              
              send_message(config, msg.chat.id, response.text)
            }
            Error(e) -> {
              io.println("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: " <> e)
              Nil
            }
          }
        }
        None -> Nil
      }
    }
    None -> Nil
  }
}

pub fn send_message(config: BotConfig, chat_id: Int, text: String) -> Nil {
  let url = "https://api.telegram.org/bot" <> config.token <> "/sendMessage"
  
  let body = json.object([
    #("chat_id", json.int(chat_id)),
    #("text", json.string(text)),
  ])
  |> json.to_string
  
  let req = request.to(url)
    |> result.unwrap(request.new())
    |> request.set_method(http.Post)
    |> request.set_header("content-type", "application/json")
    |> request.set_body(body)
  
  case httpc.send(req) {
    Ok(resp) -> {
      case resp.status {
        200 -> io.println("‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ")
        _ -> io.println("‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: HTTP " <> int.to_string(resp.status))
      }
    }
    Error(_) -> io.println("‚ùå Network error")
  }
  
  Nil
}
