/// Reasoning step
type ReasoningStep = {
  step_number: Int,
  thought: String,
  reasoning: String,
  conclusion: String,
  confidence: Float,
  timestamp: Int
}

/// Complete reasoning chain
type ReasoningChain = {
  id: String,
  goal: String,
  steps: List<ReasoningStep>,
  final_answer: String,
  confidence: Float,
  total_time: Int,
  created_at: Int
}

/// Perform reasoning on a problem
/// @param goal - The goal/question to reason about
/// @param context - Additional context
/// @param max_steps - Maximum reasoning steps
fn think(goal: String, context: String, max_steps: Int) -> Result<ReasoningChain, String>

/// Perform step-by-step reasoning
/// @param goal - The goal
/// @param context - Context data
/// @param callback - Called for each step
fn reason(goal: String, context: Map<String, Value>, callback: fn(ReasoningStep) -> Nil) -> Result<ReasoningChain, String>

/// Create a plan for goal
/// @param goal - Goal to achieve
/// @param available_tools - Available tools
/// @returns Plan as steps
fn plan(goal: String, available_tools: List<String>) -> Result<List<String>, String>

/// Reflect on previous reasoning
/// @param chain_id - Reasoning chain ID
/// @param feedback - Feedback to incorporate
fn reflect(chain_id: String, feedback: String) -> Result<ReasoningChain, String>

event reasoning.step(ReasoningStep)
event reasoning.complete(ReasoningChain)