name: ai_performance_optimizer
version: 1.0.0
description: AI-powered оптимизация производительности - находит узкие места и предлагает улучшения

metadata:
  author: VIBEE Team
  category: ai_optimization
  tags: [ai, performance, optimization, profiling]
  created: 2024-01-10

types:
  PerformanceProfile:
    function_name: string
    execution_time_ms: number
    memory_usage_mb: number
    cpu_usage_percent: number
    call_count: number
    hotspots: list<Hotspot>
    
  Hotspot:
    location: Location
    type: string  # cpu, memory, io, network
    severity: string  # critical, high, medium, low
    impact_percent: number
    
  OptimizationHint:
    hint_id: string
    title: string
    description: string
    code_before: string
    code_after: string
    expected_improvement: ImprovementMetrics
    difficulty: string
    priority: number
    
  ImprovementMetrics:
    speed_improvement_percent: number
    memory_reduction_percent: number
    complexity_reduction: number
    
  OptimizationResult:
    applied_hints: list<OptimizationHint>
    actual_improvement: ImprovementMetrics
    benchmark_results: BenchmarkResults
    
  BenchmarkResults:
    before: PerformanceMetrics
    after: PerformanceMetrics
    improvement: PerformanceMetrics
    
  PerformanceMetrics:
    execution_time_ms: number
    memory_usage_mb: number
    throughput_ops_per_sec: number

constants:
  OPTIMIZATION_PATTERNS:
    list_operations:
      pattern: "list |> list.filter(...) |> list.map(...)"
      optimization: "[... for ... in list if ...]"
      improvement: "30-50% faster, less memory"
      
    nested_loops:
      pattern: "for x in list1 { for y in list2 { ... } }"
      optimization: "Use hash map or set for O(1) lookup"
      improvement: "O(n²) → O(n)"
      
    string_concatenation:
      pattern: "str1 <> str2 <> str3 <> ..."
      optimization: "Use string builder or list.join"
      improvement: "O(n²) → O(n)"
      
    repeated_computation:
      pattern: "expensive_function() called multiple times"
      optimization: "Cache result or memoize"
      improvement: "Depends on call frequency"
      
    unnecessary_allocations:
      pattern: "Creating temporary objects in loop"
      optimization: "Reuse objects or use iterators"
      improvement: "Reduce GC pressure"

  AI_PROMPTS:
    analyze_performance: |
      Ты - эксперт по оптимизации производительности VIBEE кода.
      
      Код для анализа:
      ```vibee
      {code}
      ```
      
      Профиль производительности:
      - Время выполнения: {execution_time}ms
      - Память: {memory_usage}MB
      - CPU: {cpu_usage}%
      - Количество вызовов: {call_count}
      
      Задача: Найди узкие места и предложи оптимизации.
      
      Проверь:
      1. Алгоритмическую сложность (O-notation)
      2. Использование памяти
      3. Ненужные аллокации
      4. Повторяющиеся вычисления
      5. Неэффективные структуры данных
      6. I/O операции
      
      Формат ответа:
      Узкие места:
      1. Место: <location>
         Проблема: <описание>
         Текущая сложность: <O-notation>
         Impact: <процент от общего времени>
      
      Оптимизации:
      1. Название: <краткое название>
         До:
         ```vibee
         <текущий код>
         ```
         После:
         ```vibee
         <оптимизированный код>
         ```
         Улучшение: <метрики>
         Сложность: <easy/medium/hard>
         Приоритет: <1-10>
      
    suggest_algorithm: |
      Ты - эксперт по алгоритмам и структурам данных.
      
      Текущий код:
      ```vibee
      {code}
      ```
      
      Текущая сложность: {current_complexity}
      Проблема: {problem_description}
      
      Задача: Предложи более эффективный алгоритм.
      
      Рассмотри:
      - Хеш-таблицы для O(1) lookup
      - Сортировка для бинарного поиска
      - Динамическое программирование
      - Жадные алгоритмы
      - Divide and conquer
      
      Формат ответа:
      Рекомендуемый алгоритм: <название>
      Сложность: <O-notation>
      Код:
      ```vibee
      <оптимизированный код>
      ```
      Объяснение: <почему это лучше>
      Trade-offs: <компромиссы>
      
    memory_optimization: |
      Ты - эксперт по оптимизации памяти.
      
      Код:
      ```vibee
      {code}
      ```
      
      Использование памяти: {memory_usage}MB
      Проблема: {memory_issue}
      
      Задача: Оптимизируй использование памяти.
      
      Проверь:
      - Утечки памяти
      - Ненужные копирования
      - Большие временные объекты
      - Неэффективные структуры данных
      - Возможность streaming
      
      Формат ответа:
      Проблемы:
      - <список проблем>
      
      Решения:
      ```vibee
      <оптимизированный код>
      ```
      
      Экономия памяти: <процент>

behaviors:
  analyze_performance:
    input:
      code: string
      profile: PerformanceProfile
    output:
      hotspots: list<Hotspot>
      hints: list<OptimizationHint>
    description: Анализ производительности с AI
    steps:
      - Профилировать код
      - Отправить на анализ AI
      - Получить список узких мест
      - Сгенерировать hints
      - Приоритизировать hints
      - Вернуть результаты
      
  suggest_optimizations:
    input:
      hotspot: Hotspot
      code: string
    output:
      hints: list<OptimizationHint>
    description: Предложения по оптимизации
    steps:
      - Проанализировать узкое место
      - Определить тип проблемы
      - Сгенерировать варианты оптимизации
      - Оценить улучшения
      - Ранжировать по приоритету
      - Вернуть hints
      
  apply_optimization:
    input:
      hint: OptimizationHint
      code: string
    output:
      optimized_code: string
      result: OptimizationResult
    description: Применение оптимизации
    steps:
      - Применить изменения
      - Запустить тесты
      - Измерить производительность
      - Сравнить с baseline
      - Валидировать улучшение
      - Вернуть результат
      
  benchmark_code:
    input:
      code: string
      iterations: number
    output:
      metrics: PerformanceMetrics
    description: Бенчмарк кода
    steps:
      - Скомпилировать код
      - Прогреть JIT
      - Запустить iterations раз
      - Измерить метрики
      - Усреднить результаты
      - Вернуть metrics
      
  compare_algorithms:
    input:
      algorithm_a: string
      algorithm_b: string
      test_data: list<any>
    output:
      comparison: AlgorithmComparison
    description: Сравнение алгоритмов
    steps:
      - Бенчмарк algorithm_a
      - Бенчмарк algorithm_b
      - Сравнить метрики
      - Определить winner
      - Вернуть comparison

functions:
  - name: profile_code
    params:
      code: string
      input_data: any
    returns: PerformanceProfile
    description: Профилирование кода
    
  - name: detect_hotspots
    params:
      profile: PerformanceProfile
      threshold_percent: number
    returns: list<Hotspot>
    description: Определение узких мест
    
  - name: estimate_improvement
    params:
      current_code: string
      optimized_code: string
    returns: ImprovementMetrics
    description: Оценка улучшения
    
  - name: validate_optimization
    params:
      original: string
      optimized: string
      test_cases: list<TestCase>
    returns: boolean
    description: Валидация оптимизации

tests:
  - name: detect_list_operation_hotspot
    behavior: analyze_performance
    input:
      code: |
        list
          |> list.filter(fn(x) { x > 0 })
          |> list.map(fn(x) { x * 2 })
      profile:
        execution_time_ms: 100
        memory_usage_mb: 50
    expected:
      hotspots: length > 0
      hints: length > 0
      hints[0].title: contains("list comprehension")
      
  - name: suggest_algorithm_optimization
    behavior: suggest_optimizations
    input:
      hotspot:
        type: "cpu"
        severity: "high"
      code: |
        for x in list1 {
          for y in list2 {
            if x == y { found = true }
          }
        }
    expected:
      hints: length > 0
      hints[0].expected_improvement.speed_improvement_percent: > 50
      
  - name: apply_list_comprehension
    behavior: apply_optimization
    input:
      hint:
        code_before: "list |> list.filter(...) |> list.map(...)"
        code_after: "[... for ... in list if ...]"
      code: "list |> list.filter(fn(x) { x > 0 }) |> list.map(fn(x) { x * 2 })"
    expected:
      optimized_code: contains("[x * 2 for x in list if x > 0]")
      result.actual_improvement.speed_improvement_percent: > 30

examples:
  - name: "Оптимизация списков"
    description: "AI находит неэффективные операции со списками"
    input:
      code: |
        pub process_items(items) = {
          items
            |> list.filter(fn(i) { i.active })
            |> list.map(fn(i) { i.price })
            |> list.filter(fn(p) { p > 100 })
        }
      profile:
        execution_time_ms: 150
        memory_usage_mb: 80
    output:
      hint:
        title: "Объединить filter операции"
        code_after: |
          pub process_items(items) = {
            [i.price for i in items if i.active && i.price > 100]
          }
        improvement: "50% faster, 40% less memory"
        
  - name: "Оптимизация алгоритма"
    description: "AI предлагает более эффективный алгоритм"
    input:
      code: |
        pub find_duplicates(list) = {
          for x in list {
            for y in list {
              if x == y && x != y { return true }
            }
          }
          false
        }
      complexity: "O(n²)"
    output:
      hint:
        title: "Использовать Set для O(n)"
        code_after: |
          pub find_duplicates(list) = {
            let seen = set.new()
            for x in list {
              if set.contains(seen, x) { return true }
              set.insert(seen, x)
            }
            false
          }
        improvement: "O(n²) → O(n), 100x faster на больших данных"
        
  - name: "Оптимизация памяти"
    description: "AI находит утечки и лишние аллокации"
    input:
      code: |
        pub process_large_file(path) = {
          let content = file.read_all(path)  // Загружает весь файл
          content
            |> string.split("\n")
            |> list.map(process_line)
        }
      memory_usage_mb: 500
    output:
      hint:
        title: "Использовать streaming"
        code_after: |
          pub process_large_file(path) = {
            file.stream_lines(path)
              |> stream.map(process_line)
              |> stream.collect()
          }
        improvement: "500MB → 10MB, streaming обработка"

optimization_categories:
  algorithmic:
    - "Улучшение сложности (O-notation)"
    - "Выбор структур данных"
    - "Кеширование результатов"
    - "Мемоизация"
    
  memory:
    - "Уменьшение аллокаций"
    - "Переиспользование объектов"
    - "Streaming вместо загрузки"
    - "Ленивые вычисления"
    
  io:
    - "Батчинг операций"
    - "Асинхронный I/O"
    - "Буферизация"
    - "Параллельная обработка"
    
  code_structure:
    - "Инлайнинг функций"
    - "Удаление мертвого кода"
    - "Оптимизация циклов"
    - "Tail call optimization"

metrics:
  detection_accuracy: "> 90%"
  improvement_prediction: "±10%"
  false_positives: "< 5%"
  average_speedup: "> 2x"
