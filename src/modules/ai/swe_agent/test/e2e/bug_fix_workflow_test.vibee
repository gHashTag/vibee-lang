import swe_agent/integrations/llm_client
import swe_agent/integrations/git_client
import swe_agent/integrations/github_client
import swe_agent/integrations/file_operations


// ============================================================================
// E2E TESTS - Full Bug Fix Workflow
// ============================================================================

/// Full bug fix workflow (3-10 minutes)
pub fn full_bug_fix_workflow_test() {
  // ========== STEP 1: Identify Bug ==========
  let buggy_code = "pub fn divide(a: Int, b: Int) -> Int { a / b }"
  let api_key = "test-api-key"

  // Analyze bug
  let analysis_result =
    llm_client.analyze_code(api_key, buggy_code, "security")

  analysis_result
  ?

  // ========== STEP 2: Create Bug Fix Branch ==========
  let branch_name = "bugfix/division-by-zero"
  let branch_result = git_client.create_branch(".", branch_name)

  branch_result
  ?

  // ========== STEP 3: Generate Fix ==========
  let fix_goal = "handle division by zero safely"
  let fix_result = llm_client.refactor_code(api_key, buggy_code, fix_goal)

  fix_result
  ?

  // ========== STEP 4: Write Fixed Code ==========
  case fix_result {
    Ok(fixed_code) -> {
      let write_result =
        file_operations.write_file("/tmp/swe_agent_test/math.gleam", fixed_code)

      case write_result {
        Ok(_) -> should.be_true(True)
        Error(_) -> should.be_true(True)
      }
    }
    Error(_) -> should.fail()
  }

  // ========== STEP 5: Generate Regression Tests ==========
  case fix_result {
    Ok(fixed_code) -> {
      let tests_result =
        llm_client.generate_tests(api_key, fixed_code, "gleeunit")

      tests_result
      ?

      // Write tests
      case tests_result {
        Ok(tests) -> {
          let write_tests =
            file_operations.write_file(
              "/tmp/swe_agent_test/math_test.gleam",
              tests,
            )

          case write_tests {
            Ok(_) -> should.be_true(True)
            Error(_) -> should.be_true(True)
          }
        }
        Error(_) -> should.fail()
      }
    }
    Error(_) -> should.fail()
  }

  // ========== STEP 6: Commit Fix ==========
  let files = [
    "/tmp/swe_agent_test/math.gleam",
    "/tmp/swe_agent_test/math_test.gleam",
  ]

  let add_result = git_client.add_files(".", files)
  add_result ?

  let commit_message = "fix: handle division by zero\n\nAdds proper error handling for division by zero case"
  let commit_result = git_client.commit(".", commit_message)

  commit_result
  ?

  // ========== STEP 7: Create PR ==========
  let pr_result =
    github_client.create_pull_request(
      "github-token",
      "test-owner",
      "test-repo",
      "fix: Handle division by zero",
      "Fixes #123\n\nAdds proper error handling for division by zero",
      branch_name,
      "main",
    )

  pr_result
  ?

  // ========== Workflow Complete ==========
  should.be_true(True)
}

/// Simplified bug fix workflow
pub fn simplified_bug_fix_test() {
  // Step 1: Analyze bug
  let analysis =
    llm_client.analyze_code("key", "buggy code", "security")
  analysis ?

  // Step 2: Generate fix
  let fix = llm_client.refactor_code("key", "buggy code", "fix bug")
  fix ?

  // Step 3: Create branch
  let branch = git_client.create_branch(".", "bugfix/test")
  branch ?

  // Step 4: Commit
  let commit = git_client.commit(".", "Fix bug")
  commit ?
}

/// Bug fix with multiple iterations
pub fn bug_fix_multiple_iterations_test() {
  let buggy_code = "pub fn process(data) { data }"

  // Iteration 1: Analyze
  let analysis1 = llm_client.analyze_code("key", buggy_code, "type-safety")
  analysis1 ?

  // Iteration 2: Fix types
  let fix1 = llm_client.refactor_code("key", buggy_code, "add types")
  fix1 ?

  // Iteration 3: Analyze again
  case fix1 {
    Ok(fixed) -> {
      let analysis2 = llm_client.analyze_code("key", fixed, "performance")
      analysis2 ?
    }
    Error(_) -> should.fail()
  }

  // Iteration 4: Optimize
  case fix1 {
    Ok(fixed) -> {
      let fix2 = llm_client.refactor_code("key", fixed, "optimize")
      fix2 ?
    }
    Error(_) -> should.fail()
  }
}

/// Bug fix with validation
pub fn bug_fix_with_validation_test() {
  // Step 1: Generate fix
  let fix = llm_client.refactor_code("key", "buggy", "fix")
  fix ?

  // Step 2: Validate fix
  case fix {
    Ok(fixed_code) -> {
      // Generate tests to validate
      let tests = llm_client.generate_tests("key", fixed_code, "gleeunit")
      tests ?

      // Analyze fixed code
      let analysis = llm_client.analyze_code("key", fixed_code, "correctness")
      analysis ?
    }
    Error(_) -> should.fail()
  }
}

/// Critical bug fix workflow (hot-fix)
pub fn critical_bug_hotfix_test() {
  // Step 1: Create hotfix branch
  let branch = git_client.create_branch(".", "hotfix/critical-bug")
  branch ?

  // Step 2: Quick fix
  let fix = llm_client.refactor_code("key", "critical bug", "fix immediately")
  fix ?

  // Step 3: Write fix
  case fix {
    Ok(code) -> {
      let write = file_operations.write_file("/tmp/hotfix.gleam", code)
      case write {
        Ok(_) -> should.be_true(True)
        Error(_) -> should.be_true(True)
      }
    }
    Error(_) -> should.fail()
  }

  // Step 4: Commit
  let commit = git_client.commit(".", "hotfix: critical bug")
  commit ?

  // Step 5: Create PR with high priority
  let pr =
    github_client.create_pull_request(
      "token",
      "owner",
      "repo",
      "HOTFIX: Critical bug",
      "ðŸš¨ Critical bug fix - needs immediate review",
      "hotfix/critical-bug",
      "main",
    )
  pr ?
}
