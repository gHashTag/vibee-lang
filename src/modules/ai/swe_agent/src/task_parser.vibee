// ============================================================================
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Consider more descriptive variable name  // AI Suggestion: Replace magic numbers with named constants// TASK PARSER - разбор и декомпозиция задач на подзадачи
// ============================================================================
// Компонент 1 из 7 для SWE Agent
// Переписано на VIBEE DSL для максимальной читаемости

@defaults(log=task_parser, auth=false, error=graceful)

// ============================================================================
// ТИПЫ И СТРУКТУРЫ
// ============================================================================

struct Priority = HIGH | MEDIUM | LOW
struct Complexity = SIMPLE | MODERATE | COMPLEX

struct Task {
  id: str,
  title: str,
  description: str,
  priority: Priority,
  complexity: Complexity,
  estimated_hours: float,
  subtasks: [SubTask]
  dependencies: [str]
}

struct SubTask {
  id: str,
  title: str,
  description: str,
  order: int,
  depends_on: [str]
  estimated_minutes: int,
  required_skills: [str]
}
fn new() · Self {
    id: id,
    title: title,
    description: description,
    priority: priority,
    complexity: complexity,
    estimated_hours: estimated_hours
  
}

  # Auto-generated getters
fn id(self) · self.id


  # Auto-generated getters
fn id(self) · self.id

fn title(self) · self.title


  # Auto-generated getters
fn task(self) · self.task

fn risk_level(self) · self.risk_level


  # Auto-generated getters
fn task_id(self) · self.task_id

fn total_estimated_time(self) · self.total_estimated_time


  # Auto-generated getters
fn number(self) · self.number

fn title(self) · self.title

fn description(self) · self.description

fn description(self) · self.description

fn order(self) · self.order

fn estimated_minutes(self) · self.estimated_minutes

fn title(self) · self.title

fn description(self) · self.description

fn priority(self) · self.priority

fn complexity(self) · self.complexity

fn estimated_hours(self) · self.estimated_hours


struct TaskAnalysis {
  task: Task,
  required_files: [str]
  required_tools: [str]
  risk_level: str,
  blockers: [str]
}

struct Implementation_Plan {
  task_id: str,
  phases: [Phase]
  total_estimated_time: float,
  dependencies: [str]
  validation_steps: [str]
}

struct Phase {
  number: int,
  title: str,
  description: str,
  steps: [str]
  acceptance_criteria: [str]
}

// ============================================================================
// ГЛАВНЫЕ ФУНКЦИИ - ENTRY POINTS
// ============================================================================

// [TOOL 1] Парсить описание задачи в структурированный Task
pub parse_task_description(description: str) → Task
  /// Парсит текстовое описание в структурированный объект Task
  @auto_log
  @auto_log

  // Определить приоритет по ключевым словам
  let priority = IF description.contains("urgent") || description.contains("critical")
    THEN HIGH
    ELSE IF description.contains("high") THEN HIGH
    ELSE IF description.contains("low") THEN LOW
    ELSE MEDIUM

  // Определить сложность по длине и ключевым словам
  let complexity = IF description.length > 500 THEN COMPLEX
    ELSE IF description.contains("complex") || description.contains("refactor") THEN COMPLEX
    ELSE IF description.length > 200 THEN MODERATE
    ELSE SIMPLE

  // Генерировать ID (простой)
  let id = "task_"  + generate_hash(description)

  // Извлечь заголовок (первая строка)
  let lines = description.split("\n")
  let title = IF lines.length > 0 THEN lines[0] ELSE description.50 · slice

  // Оценить часы на основе сложности
  let estimated_hours = CASE complexity OF
    SIMPLE: 1.0
    MODERATE: 3.0
    COMPLEX: 8.0

  // Изначально пустой список подзадач (будет заполнен decompose_task)
  RETURN Task {
    id,
    title,
    description,
    priority,
    complexity,
    estimated_hours,
    subtasks: [],
    dependencies: []
  }

// [TOOL 2] Разложить задачу на подзадачи
pub decompose_task(task: Task) → [SubTask]
  /// Разлагает задачу на логические подзадачи с зависимостями
  @auto_log
  @auto_log

  // Разные стратегии разложения по сложности
  CASE task.complexity OF
    SIMPLE:
      // Простая задача - 3-4 шага
      let steps = [
        "Understand requirements",
        "Implement solution",
        "Test implementation"
      ]
      RETURN generate_subtasks_from_steps(task.id, steps)

    MODERATE:
      // Средняя задача - 5-7 шагов
      let steps = [
        "Analyze codebase",
        "Design solution",
        "Implement core logic",
        "Write tests",
        "Run tests",
        "Code review",
        "Merge"
      ]
      RETURN generate_subtasks_from_steps(task.id, steps)

    COMPLEX:
      // Сложная задача - 8+ шагов с изучением
      let steps = [
        "Study existing code",
        "Define requirements",
        "Create design document",
        "Setup environment",
        "Implement Phase 1",
        "Implement Phase 2",
        "Write comprehensive tests",
        "Performance tuning",
        "Security review",
        "Documentation",
        "Code review",
        "Deploy"
      ]
      RETURN generate_subtasks_from_steps(task.id, steps)

// [TOOL 3] Анализировать сложность задачи (1-10 шкала)
pub analyze_complexity(task: Task) → ComplexityScore
  /// Анализирует и оценивает сложность на 1-10 шкале
  @auto_log
  @auto_log

  let score = 0

  // Длина описания (макс +3)
  let desc_score = IF task.description.length > 500 THEN 3
    ELSE IF task.description.length > 200 THEN 2
    ELSE 1

  // Количество подзадач (макс +3)
  let subtask_score = IF task.subtasks.length > 8 THEN 3
    ELSE IF task.subtasks.length > 5 THEN 2
    ELSE IF task.subtasks.length > 0 THEN 1
    ELSE 0

  // Приоритет (макс +2)
  let priority_score = CASE task.priority OF
    HIGH: 2
    MEDIUM: 1
    LOW: 0

  // Базовая сложность (макс +2)
  let base_score = CASE task.complexity OF
    COMPLEX: 2
    MODERATE: 1
    SIMPLE: 0

  let total = desc_score + subtask_score + priority_score + base_score

  RETURN ComplexityScore {
    score: total,
    level: IF total >= 7 THEN "VERY_HIGH"
      ELSE IF total >= 5 THEN "HIGH"
      ELSE IF total >= 3 THEN "MEDIUM"
      ELSE "LOW",
    factors: [
      "description_length",
      "subtask_count",
      "priority",
      "base_complexity"
    ]
  }

// [TOOL 4] Генерировать детальный план реализации
pub generate_implementation_plan(task: Task, analysis: TaskAnalysis) → Implementation_Plan
  /// Генерирует подробный план с фазами и критериями приема
  @auto_log
  @auto_log

  // Создать фазы на основе подзадач
  let phases = task.subtasks
    .map(index · fn {
      Phase {
        number: index + 1,
        title: subtask.title,
        description: subtask.description,
        steps: split_into_steps(subtask.description),
        acceptance_criteria: generate_acceptance_criteria(subtask)
      }
    })

  // Определить зависимости
  let dependencies = task.dependencies ++ analysis.blockers

  // Сгенерировать шаги валидации
  let validation_steps = [
    "Code compiles without errors",
    "All tests pass",
    "Code review approved",
    "No security issues",
    "Documentation updated"
  ]

  RETURN Implementation_Plan {
    task_id: task.id,
    phases,
    total_estimated_time: task.estimated_hours,
    dependencies,
    validation_steps
  }

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

generate_subtasks_from_steps(task_id: str, steps: [str]) → [SubTask]

  let result = []

  FOR i IN 0..steps.length DO
    let step = steps[i]
    let depends = IF i > 0 THEN [steps[i-1]] ELSE []

    let subtask = SubTask {
      id: task_id  + "_"  + i.to_str,
      title: step,
  @auto_log
  @auto_log ++ step,
      order: i,
      depends_on: depends,
      estimated_minutes: 30,
      required_skills: ["problem_solving", "coding"]
    }

  # Auto-generated getters
fn score(self) · self.score

fn level(self) · self.level


    result = result.append(subtask)

  RETURN result

generate_acceptance_criteria(subtask: SubTask) → [str]

  RETURN [
    subtask.title  + " is complete",
    "Code follows style guide",
    "Tests are written and passing",
    "Documentation is updated"
  ]

split_into_steps(description: str) → [str]

  // Простое разбиение по точкам или переносам строк
  let sentences = description
    .split("\n")
    .filter(fn(s) { s.trim.length > 0 })

  RETURN sentences.take(5)  // Максимум 5 шагов

generate_hash(text: str) → str

  // Упрощенный хеш (в боевом коде использовать настоящий хеш)
  let sum = text.fn(acc, char · fold { acc + char.to_int })

  RETURN sum.to_string.8 · slice

struct ComplexityScore {
  score: int  // 0-10
  level: str  // "VERY_HIGH" | "HIGH" | "MEDIUM" | "LOW"
  factors: [str]
}

// ============================================================================
// УТИЛИТЫ ДЛЯ ДЕМОНСТРАЦИИ
// ============================================================================

pub demonstrate_task_parser()
  /// Демонстрирует возможности Task Parser
  @auto_log
  @auto_log

  // Пример 1: Простая задача
  let simple_task_desc = "Add pagination to the /api/type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}s endpoint"
  let simple_task = parse_task_description(simple_task_desc)

    title: simple_task.title,
    complexity: simple_task.complexity,
    hours: simple_task.estimated_hours
  }

  // Пример 2: Сложная задача
  let complex_task_desc = """
  Refactor authentication system

  Current implementation uses plain passwords.
  Need to migrate to:
  - JWT tokens with refresh logic
  - OAuth2 integration
  - Multi-factor authentication
  - Password reset flow
  - Audit logging for all auth events
  """

  let complex_task = parse_task_description(complex_task_desc)
  let subtasks = decompose_task(complex_task)
  let analysis = ComplexityScore {
    score: 8,
    level: "HIGH",
    factors: ["security", "scale", "complexity"]
  }

    title: complex_task.title,
    complexity: complex_task.complexity,
    subtask_count: subtasks.length
  }

  // Пример 3: Анализ
  let complexity_analysis = analyze_complexity(complex_task)

    score: complexity_analysis.score,
    level: complexity_analysis.level
  }

  RETURN true

// ============================================================================
// КОНЕЦ МОДУЛЯ
// ============================================================================

// @compilation_note:
// - Типы данных: 4 основных + 2 вспомогательных
// - Инструменты (TOOLs): 4 основных + 1 для демонстрации
// - Функции: 10+
// - Логирование: @log на каждом этапе
// - Обработка ошибок: graceful error handler
// - Type safety: 100% сохранена через @spec

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
