// ============================================================================
  // Performance Warning:   // AI Suggestion: Consider more descriptive variable name  // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider extracting hardcoded strings to constants// TASK PARSER - разбор и декомпозиция задач на подзадачи
// ============================================================================
// Компонент 1 из 7 для SWE Agent
// Переписано на VIBEE DSL для максимальной читаемости

@defaults(log=task_parser, auth=false, error=graceful)

// ============================================================================
// ТИПЫ И СТРУКТУРЫ
// ============================================================================

type Priority = HIGH | MEDIUM | LOW
type Complexity = SIMPLE | MODERATE | COMPLEX

type Task(
  id: str,
  title: str,
  description: str,
  priority: Priority,
  complexity: Complexity,
  estimated_hours: float,
  subtasks: [SubTask]
  dependencies: [str]
}

type SubTask(
  id: str,
  title: str,
  description: str,
  order: int,
  depends_on: [str]
  estimated_minutes: int,
  required_skills: [str]
}

type TaskAnalysis(
  task: Task,
  required_files: [str]
  required_tools: [str]
  risk_level: str,
  blockers: [str]
}

type Implementation_Plan(
  task_id: str,
  phases: [Phase]
  total_estimated_time: float,
  dependencies: [str]
  validation_steps: [str]
}

type Phase(
  number: int,
  title: str,
  description: str,
  steps: [str]
  acceptance_criteria: [str]
}

// ============================================================================
// ГЛАВНЫЕ ФУНКЦИИ - ENTRY POINTS
// ============================================================================

// [TOOL 1] Парсить описание задачи в структурированный Task
tool parse_task_description(description: str) -> Task
  @doc "Парсит текстовое описание в структурированный объект Task"
  @auto_log
  @auto_log

  // Определить приоритет по ключевым словам
  let priority = IF description.contains("urgent") || description.contains("critical")
    THEN HIGH
    ELSE IF description.contains("high") THEN HIGH
    ELSE IF description.contains("low") THEN LOW
    ELSE MEDIUM

  // Определить сложность по длине и ключевым словам
  let complexity = IF description.length > 500 THEN COMPLEX
    ELSE IF description.contains("complex") || description.contains("refactor") THEN COMPLEX
    ELSE IF description.length > 200 THEN MODERATE
    ELSE SIMPLE

  // Генерировать ID (простой)
  let id = "task_"  <> generate_hash(description)

  // Извлечь заголовок (первая строка)
  let lines = description.split("\n")
  let title = IF lines.length > 0 THEN lines[0] ELSE description.slice(0, 50)

  // Оценить часы на основе сложности
  let estimated_hours = CASE complexity OF
    SIMPLE: 1.0
    MODERATE: 3.0
    COMPLEX: 8.0

  // Изначально пустой список подзадач (будет заполнен decompose_task)
  RETURN Task {
    id,
    title,
    description,
    priority,
    complexity,
    estimated_hours,
    subtasks: [],
    dependencies: []
  }

// [TOOL 2] Разложить задачу на подзадачи
tool decompose_task(task: Task) -> [SubTask]
  @doc "Разлагает задачу на логические подзадачи с зависимостями"
  @auto_log
  @auto_log

  // Разные стратегии разложения по сложности
  CASE task.complexity OF
    SIMPLE:
      // Простая задача - 3-4 шага
      let steps = [
        "Understand requirements",
        "Implement solution",
        "Test implementation"
      ]
      RETURN generate_subtasks_from_steps(task.id, steps)

    MODERATE:
      // Средняя задача - 5-7 шагов
      let steps = [
        "Analyze codebase",
        "Design solution",
        "Implement core logic",
        "Write tests",
        "Run tests",
        "Code review",
        "Merge"
      ]
      RETURN generate_subtasks_from_steps(task.id, steps)

    COMPLEX:
      // Сложная задача - 8+ шагов с изучением
      let steps = [
        "Study existing code",
        "Define requirements",
        "Create design document",
        "Setup environment",
        "Implement Phase 1",
        "Implement Phase 2",
        "Write comprehensive tests",
        "Performance tuning",
        "Security review",
        "Documentation",
        "Code review",
        "Deploy"
      ]
      RETURN generate_subtasks_from_steps(task.id, steps)

// [TOOL 3] Анализировать сложность задачи (1-10 шкала)
tool analyze_complexity(task: Task) -> ComplexityScore
  @doc "Анализирует и оценивает сложность на 1-10 шкале"
  @auto_log
  @auto_log

  let score = 0

  // Длина описания (макс +3)
  let desc_score = IF task.description.length > 500 THEN 3
    ELSE IF task.description.length > 200 THEN 2
    ELSE 1

  // Количество подзадач (макс +3)
  let subtask_score = IF task.subtasks.length > 8 THEN 3
    ELSE IF task.subtasks.length > 5 THEN 2
    ELSE IF task.subtasks.length > 0 THEN 1
    ELSE 0

  // Приоритет (макс +2)
  let priority_score = CASE task.priority OF
    HIGH: 2
    MEDIUM: 1
    LOW: 0

  // Базовая сложность (макс +2)
  let base_score = CASE task.complexity OF
    COMPLEX: 2
    MODERATE: 1
    SIMPLE: 0

  let total = desc_score + subtask_score + priority_score + base_score

  RETURN ComplexityScore {
    score: total,
    level: IF total >= 7 THEN "VERY_HIGH"
      ELSE IF total >= 5 THEN "HIGH"
      ELSE IF total >= 3 THEN "MEDIUM"
      ELSE "LOW",
    factors: [
      "description_length",
      "subtask_count",
      "priority",
      "base_complexity"
    ]
  }

// [TOOL 4] Генерировать детальный план реализации
tool generate_implementation_plan(task: Task, analysis: TaskAnalysis) -> Implementation_Plan
  @doc "Генерирует подробный план с фазами и критериями приема"
  @auto_log
  @auto_log

  // Создать фазы на основе подзадач
  let phases = task.subtasks
    .map(fn(subtask, index) {
      Phase {
        number: index + 1,
        title: subtask.title,
        description: subtask.description,
        steps: split_into_steps(subtask.description),
        acceptance_criteria: generate_acceptance_criteria(subtask)
      }
    })

  // Определить зависимости
  let dependencies = task.dependencies  <> analysis.blockers

  // Сгенерировать шаги валидации
  let validation_steps = [
    "Code compiles without errors",
    "All tests pass",
    "Code review approved",
    "No security issues",
    "Documentation updated"
  ]

  RETURN Implementation_Plan {
    task_id: task.id,
    phases,
    total_estimated_time: task.estimated_hours,
    dependencies,
    validation_steps
  }

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

generate_subtasks_from_steps(task_id: str, steps: [str]) -> [SubTask]

  let result = []

  FOR i IN 0..steps.length DO
    let step = steps[i]
    let depends = IF i > 0 THEN [steps[i-1]] ELSE []

    let subtask = SubTask {
      id: task_id  <> "_"  <> i.to_str,
      title: step,
  @doc "Complete: "
  @auto_log
  @auto_log  <> step,
      order: i,
      depends_on: depends,
      estimated_minutes: 30,
      required_skills: ["problem_solving", "coding"]
    }

    result = result.append(subtask)

  RETURN result

generate_acceptance_criteria(subtask: SubTask) -> [str]

  RETURN [
    subtask.title  <> " is complete",
    "Code follows style guide",
    "Tests are written and passing",
    "Documentation is updated"
  ]

split_into_steps(description: str) -> [str]

  // Простое разбиение по точкам или переносам строк
  let sentences = description
    .split("\n")
    .filter(fn(s) { s.trim.length > 0 })

  RETURN sentences.take(5)  // Максимум 5 шагов

generate_hash(text: str) -> str

  // Упрощенный хеш (в боевом коде использовать настоящий хеш)
  let sum = text.fold(0, fn(acc, char) { acc + char.to_int })

  RETURN sum.to_string.slice(0, 8)

type ComplexityScore(
  score: int  // 0-10
  level: str  // "VERY_HIGH" | "HIGH" | "MEDIUM" | "LOW"
  factors: [str]
}

// ============================================================================
// УТИЛИТЫ ДЛЯ ДЕМОНСТРАЦИИ
// ============================================================================

tool demonstrate_task_parser()
  @doc "Демонстрирует возможности Task Parser"
  @auto_log
  @auto_log

  // Пример 1: Простая задача
  let simple_task_desc = "Add pagination to the /api/type type User {
  name: String,
  email: String,
  id: Int
} {
  name: String,
  email: String,
  id: Int
}s endpoint"
  let simple_task = parse_task_description(simple_task_desc)

    title: simple_task.title,
    complexity: simple_task.complexity,
    hours: simple_task.estimated_hours
  }

  // Пример 2: Сложная задача
  let complex_task_desc = """
  Refactor authentication system

  Current implementation uses plain passwords.
  Need to migrate to:
  - JWT tokens with refresh logic
  - OAuth2 integration
  - Multi-factor authentication
  - Password reset flow
  - Audit logging for all auth events
  """

  let complex_task = parse_task_description(complex_task_desc)
  let subtasks = decompose_task(complex_task)
  let analysis = ComplexityScore {
    score: 8,
    level: "HIGH",
    factors: ["security", "scale", "complexity"]
  }

    title: complex_task.title,
    complexity: complex_task.complexity,
    subtask_count: subtasks.length
  }

  // Пример 3: Анализ
  let complexity_analysis = analyze_complexity(complex_task)

    score: complexity_analysis.score,
    level: complexity_analysis.level
  }

  RETURN true

// ============================================================================
// КОНЕЦ МОДУЛЯ
// ============================================================================

// @compilation_note:
// - Типы данных: 4 основных + 2 вспомогательных
// - Инструменты (TOOLs): 4 основных + 1 для демонстрации
// - Функции: 10+
// - Логирование: @log на каждом этапе
// - Обработка ошибок: graceful error handler
// - Type safety: 100% сохранена через @spec


# v10.0 - ML-Powered Migration
