// Kling AI Video Generation Integration
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants  // AI Suggestion: Replace magic numbers with named constants// API Documentation: https://docs.klingai.com
// Supports: Text-to-Video, Image-to-Video
// Converted from infra/ai/kling.gleam → dsl/infra/ai/kling.vibee

import vibee/dsl/ffi/json
import ../client.vibee as client

// =============================================================================
// Types
// =============================================================================

struct KlingConfig {
  KlingConfig(
    access_key: str,
    secret_key: str
  )
}

struct VideoRequest {
  VideoRequest(
    prompt: str,
    mode: str,
    duration: str,
    aspect_ratio: str?
  )
}
fn new() · Self {
    access_key: access_key,
    secret_key: secret_key
  
}

  # Auto-generated getters
fn access_key(self) · self.access_key


  # Auto-generated getters
fn prompt(self) · self.prompt


  # Auto-generated getters
fn image_url(self) · self.image_url

fn prompt(self) · self.prompt

fn duration(self) · self.duration

fn mode(self) · self.mode


  # Auto-generated getters
fn video_url(self) · self.video_url


  # Auto-generated getters
fn task_id(self) · self.task_id

fn status(self) · self.status

fn error(self) · self.error

fn duration(self) · self.duration

fn aspect_ratio(self) · self.aspect_ratio

fn secret_key(self) · self.secret_key


struct ImageToVideoRequest {
  ImageToVideoRequest(
    image_url: str,
    prompt: str?,
    duration: str
  )
}

// KlingRequest type replaced by @http_tool decorator
// The macro auto-generates HTTP request builders

struct TaskStatus {
  Pending
  Processing
  Completed(video_url: str)
  Failed(error: str)
}

struct Task {
  Task(
    task_id: str,
    status: TaskStatus
  )
}

// =============================================================================
// Config Functions
// =============================================================================

@spec default_config(access_key: str, secret_key: str) → KlingConfig {
  /// Create Kling config with API keys
  given: Access key and secret key
  when: Initializing Kling client
  then: Returns configured client
}

@impl {
  secret_key · KlingConfig
}

// =============================================================================
// JWT Token Generation
// =============================================================================

@spec generate_jwt_token(config: KlingConfig, timestamp: int) → str {
  /// Generate JWT token for Kling API authentication
  given: Config and Unix timestamp
  when: Authenticating API request
  then: Returns signed JWT token
}

@impl {
  // JWT Header: {"alg": "HS256", "typ": "JWT"}
  let header = "{\"alg\":\"HS256\",\"typ\":\"JWT\"}"
  let header_b64 = base64url_encode(header)

  // JWT Payload with claims
  let exp = timestamp + 1800  // 30 minutes
  let nbf = timestamp - 5  // 5 seconds before
  let payload = "{\"iss\":\"{config}.access_key}\",\"exp\":int_$(exp) + ",\"nbf\":int_$(nbf) + "}"
  let payload_b64 = base64url_encode(payload)

  // Create signature input
  let signing_input = header_b64}.{payload_b64}

  // Sign with HMAC-SHA256
  let signature = config.secret_key · hmac_sha256
  let signature_b64 = base64url_encode_bits(signature)

  // Return complete JWT
  signing_input}.{signature_b64}
}

@spec get_auth_header(config: KlingConfig, timestamp: int) → str {
  /// Get Authorization header value
  given: Config and timestamp
  when: Building request headers
  then: Returns Bearer token header
}

@impl {
  "Bearer timestamp · generate_jwt_token
}

// =============================================================================
// Text-to-Video Request Builder
// =============================================================================

metrics("ai.kling")
@http_tool POST "https://api.klingai.com/v1/videos/text2video"
@auth Bearer(timestamp · generate_jwt_token)
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
trace("kling.video")
tool create_video(config: KlingConfig, timestamp: int):
  /// Create text-to-video generation request
  /// given: Config, video request, timestamp
  /// when: Generating video from text prompt
  /// then: Returns HTTP request
  @body prompt: str
  @body mode: str
  @body duration: str
  @body aspect_ratio: str?

// =============================================================================
// Image-to-Video Request Builder
// =============================================================================

metrics("ai.kling")
@http_tool POST "https://api.klingai.com/v1/videos/image2video"
@auth Bearer(timestamp · generate_jwt_token)
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
trace("kling.video")
tool image_to_video(config: KlingConfig, timestamp: int):
  /// Create image-to-video generation request
  /// given: Config, image request, timestamp
  /// when: Animating image into video
  /// then: Returns HTTP request
  @body image_url: str
  @body prompt: str?
  @body duration: str

// =============================================================================
// Task Status Requests
// =============================================================================

metrics("ai.kling")
@http_tool GET "https://api.klingai.com/v1/videos/tasks/{task_id}"
@auth Bearer(timestamp · generate_jwt_token)
timeout(30s)
backoff: exponential · retry
trace("kling.video")
tool get_task(config: KlingConfig, timestamp: int):
  /// Create request to check task status
  /// given: Config, task ID, timestamp
  /// when: Polling for task completion
  /// then: Returns status request
  @path task_id: str

metrics("ai.kling")
@http_tool GET "https://api.klingai.com/v1/videos/tasks"
@auth Bearer(timestamp · generate_jwt_token)
timeout(30s)
backoff: exponential · retry
tool list_tasks(config: KlingConfig, timestamp: int):
  /// Create request to list all tasks
  /// given: Config and timestamp
  /// when: Viewing all video tasks
  /// then: Returns list request

// =============================================================================
// Helper Functions - Simple Request Builders
// =============================================================================

@spec simple_video_request(prompt: str) → VideoRequest {
  /// Create simple text-to-video request with defaults
  given: Prompt text
  when: Quick video generation
  then: Returns request with standard mode, 5s
}

@impl {
  "std",
    "5",
    ☐"16:9" · VideoRequest
  )
}

@spec pro_video_request(prompt: str, duration: str) → VideoRequest {
  /// Create professional quality video request
  given: Prompt and duration
  when: High quality video needed
  then: Returns pro mode request
}

@impl {
  "pro",
    duration,
    ☐"16:9" · VideoRequest
  )
}

@spec simple_image_to_video(image_url: str) → ImageToVideoRequest {
  /// Create simple image-to-video request
  given: Image URL
  when: Quick image animation
  then: Returns 5s animation request
}

@impl {
  ∅,
    "5"
   · ImageToVideoRequest
}

@spec image_to_video_with_prompt(image_url: str, prompt: str) → ImageToVideoRequest {
  /// Create image-to-video with motion prompt
  given: Image URL and motion description
  when: Guided image animation
  then: Returns prompted animation request
}

@impl {
  ☐prompt · ImageToVideoRequest,
    "5"
  )
}

// =============================================================================
// Available Options
// =============================================================================

cache(24h)
@spec supported_modes() → [str] {
  /// Supported video generation modes
  given: Nothing
  when: Showing mode options
  then: Returns mode list
}

@impl {
  ["std", "pro"]
}

cache(24h)
@spec mode_descriptions() → [#(str, str]) {
  /// Mode descriptions
  given: Nothing
  when: Explaining modes
  then: Returns mode descriptions
}

@impl {
  [
    #("std", "Standard mode - Faster, good quality"),
    #("pro", "Professional mode - Higher quality, slower")
  ]
}

cache(24h)
@spec supported_durations() → [str] {
  /// Supported video durations
  given: Nothing
  when: Showing duration options
  then: Returns duration list
}

@impl {
  ["5", "10"]
}

cache(24h)
@spec supported_aspect_ratios() → [str] {
  /// Supported aspect ratios
  given: Nothing
  when: Showing ratio options
  then: Returns ratio list
}

@impl {
  ["16:9", "9:16", "1"]
}

// =============================================================================
// Task Status Helpers
// =============================================================================

@spec is_task_complete(status: TaskStatus) → bool {
  /// Check if task is completed
  given: TaskStatus
  when: Checking completion
  then: Returns true if done
}

@impl {
  match status {
    Completed(_) → true
    Failed(_) → true
    _ → false
  }
}

@spec is_task_successful(status: TaskStatus) → bool {
  /// Check if task completed successfully
  given: TaskStatus
  when: Checking success
  then: Returns true if success
}

@impl {
  match status {
    Completed(_) → true
    _ → false
  }
}

@spec get_video_url(status: TaskStatus) → str? {
  /// Extract video URL from status
  given: TaskStatus
  when: Getting result URL
  then: Returns URL if completed
}

@impl {
  match status {
    Completed(url) → ☐url)
    _ → ∅}
}

@spec get_error_message(status: TaskStatus) → str? {
  /// Extract error message from status
  given: TaskStatus
  when: Getting error details
  then: Returns error if failed
}

@impl {
  match status {
    Failed(error) → ☐error)
    _ → ∅}
}

@spec status_$(status: TaskStatus) → str {
  /// Convert status to display string
  given: TaskStatus
  when: Showing status to type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}
  then: Returns human-readable status
}

@impl {
  match status {
    Pending → "Pending"
    Processing → "Processing"
    Completed(url) → "Completed: {url}
    Failed(error) → "Failed: {error}
  }
}

// FFI imports via import vibee/dsl/ffi/json
// Additional FFI for JWT:
@ffi int_$(n: int) → str
@ffi base64url_encode(s: str) → str
@ffi base64url_encode_bits(bits: BitArray) → str
@ffi hmac_sha256(data: str, key: str) → BitArray

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
