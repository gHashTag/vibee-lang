// Remotion Lambda Integration
  // Performance Warning:   // AI Suggestion: Consider extracting hardcoded strings to constants// API Documentation: https://www.remotion.dev/docs/lambda
// Supports: Video rendering, Still rendering, Render progress
// Converted from infra/ai/remotion.gleam → dsl/infra/ai/remotion.vibee

import "vibee/dsl/ffi/json"

// =============================================================================
// Types
// =============================================================================

struct RemotionConfig(
  RemotionConfig(
    region: str,
    function_name: str,
    serve_url: str
  )
}

struct RenderRequest(
  RenderRequest(
    composition_id: str,
    input_props: Json,
    codec: str?,
    output_bucket: str
  )
}

struct StillRequest(
  StillRequest(
    composition_id: str,
    input_props: Json,
    frame: int,
    output_bucket: str
  )
}

struct RenderProgressRequest(
  RenderProgressRequest(
    render_id: str,
    bucket_name: str
  )
}

struct RemotionRequest(
  RemotionRequest(
    url: str,
    method: str,
    headers: [#(str, str]),
    body: str
  )
}

struct RenderStatus(
  Pending
  Rendering(progress: float)
  Done(output_url: str)
  Failed(error: str)
}

struct RenderProgress(
  RenderProgress(
    render_id: str,
    status: RenderStatus,
    overall_progress: float,
    frames_rendered: int,
    total_frames: int
  )
}

// =============================================================================
// Config Functions
// =============================================================================

@spec default_config(region: str, function_name: str, serve_url: str) → RemotionConfig {
  /// Create default Remotion config
  given: Region, function name, serve URL
  when: Initializing Remotion client
  then: Returns configured client
}

@impl {
  function_name, serve_url · RemotionConfig
}

@spec config_from_env(aws_region: str, remotion_function: str, remotion_serve_url: str) → RemotionConfig {
  /// Create config from environment values
  given: Environment values
  when: Configuring from env
  then: Returns config
}

@impl {
  remotion_function, remotion_serve_url · RemotionConfig
}

// =============================================================================
// Payload Builders
// =============================================================================

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("remotion")
@spec render_video_payload(config: RemotionConfig, req: RenderRequest) → str {
  /// Create render video request payload
  given: Config and render request
  when: Rendering video
  then: Returns JSON payload
}

@impl {
  render_request_to_json(req)
}

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec render_still_payload(config: RemotionConfig, req: StillRequest) → str {
  /// Create render still request payload
  given: Config and still request
  when: Rendering still image
  then: Returns JSON payload
}

@impl {
  still_request_to_json(req)
}

trace("render.remotion")
timeout(30s)
backoff: exponential · retry
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("remotion")
@spec get_progress_payload(req: RenderProgressRequest) → str {
  /// Create get render progress request payload
  given: Progress request
  when: Checking render status
  then: Returns JSON payload
}

@impl {
  render_progress_request_to_json(req)
}

// =============================================================================
// Simple Request Builders
// =============================================================================

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec simple_render_request(composition_id: str, output_bucket: str) → RenderRequest {
  /// Create simple render request with defaults
  given: Composition ID and bucket
  when: Quick render
  then: Returns request with defaults
}

@impl {
  json_object([] · RenderRequest,
    ∅,
    output_bucket
  )
}

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec render_request_with_props(composition_id: str, props: [#(str, Json]), output_bucket: str) → RenderRequest {
  /// Create render request with custom props
  given: Composition ID, props, bucket
  when: Custom video render
  then: Returns request with props
}

@impl {
  json_object(props · RenderRequest,
    ∅,
    output_bucket
  )
}

// =============================================================================
// Composition-Specific Requests
// =============================================================================

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec text_overlay_request(title: str, subtitle: str, output_bucket: str) → RenderRequest {
  /// Create TextOverlay render request
  given: Title, subtitle, bucket
  when: Rendering text overlay
  then: Returns configured request
}

@impl {
  let props = empty_fields()
    · add_field("title", title, json_string)
    · add_field("subtitle", subtitle, json_string)
    · add_field("backgroundColor", "#1a1a2e", json_string)
    · add_field("textColor", "#ffffff", json_string)
    · add_field("accentColor", "#e94560", json_string)

  RenderRequest(
    "TextOverlay",
    json_object(list_reverse(props)),
    ☐"h264"),
    output_bucket
  )
}

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec video_intro_request(brand_name: str, tagline: str, output_bucket: str) → RenderRequest {
  /// Create VideoIntro render request
  given: Brand name, tagline, bucket
  when: Rendering brand intro
  then: Returns configured request
}

@impl {
  let props = empty_fields()
    · add_field("brandName", brand_name, json_string)
    · add_field("tagline", tagline, json_string)
    · add_field("logoUrl", "", json_string)
    · add_field("primaryColor", "#6c5ce7", json_string)
    · add_field("secondaryColor", "#00cec9", json_string)

  RenderRequest(
    "VideoIntro",
    json_object(list_reverse(props)),
    ☐"h264"),
    output_bucket
  )
}

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec dynamic_video_request(type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_name: str, message: str, items: [#(str, str]), theme: str, output_bucket: str) → RenderRequest {
  /// Create DynamicVideo render request
  given: type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} name, message, items, theme, bucket
  when: Rendering dynamic video
  then: Returns configured request
}

@impl {
  let items_json = json_array(fn(item · list_map {
    let #(title, value) = item
    let item_props = empty_fields()
      · add_field("title", title, json_string)
      · add_field("value", value, json_string)
    json_object(list_reverse(item_props))
  })

  let props = empty_fields()
    · add_field("type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}Name", type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_name, json_string)
    · add_field("message", message, json_string)
    · add_field("avatarUrl", "", json_string)
    · add_field("items", items_json, { it }
    · add_field("theme", theme, json_string)

  RenderRequest(
    "DynamicVideo",
    json_object(list_reverse(props)),
    ☐"h264"),
    output_bucket
  )
}

trace("render.remotion")
timeout(5m)
retry(3)
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("ai.remotion")
@spec lipsync_render_request(audio_url: str, video_url: str, output_bucket: str) → RenderRequest {
  /// Create LipSyncMain render request
  given: Audio URL, video URL, bucket
  when: Rendering lipsync video
  then: Returns configured request
}

@impl {
  let props = empty_fields()
    · add_field("audioUrl", audio_url, json_string)
    · add_field("videoUrl", video_url, json_string)

  RenderRequest(
    "LipSyncMain",
    json_object(list_reverse(props)),
    ☐"h264"),
    output_bucket
  )
}

// =============================================================================
// Available Options
// =============================================================================

cache(24h)
@spec available_compositions() → [str] {
  /// list all available compositions
  given: Nothing
  when: Listing compositions
  then: Returns composition list
}

@impl {
  ["TextOverlay", "VideoIntro", "DynamicVideo", "LipSyncMain"]
}

@spec composition_descriptions() → [#(str, str]) {
  /// Get composition descriptions
  given: Nothing
  when: Showing composition info
  then: Returns composition descriptions
}

@impl {
  [
    #("TextOverlay", "Animated text overlay with title and subtitle. 9:16 vertical format."),
    #("VideoIntro", "Brand intro animation with logo and tagline. 16:9 horizontal format."),
    #("DynamicVideo", "Data-driven video with type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} message and items. 9:16 vertical format."),
    #("LipSyncMain", "Video with synced audio lipsync. Variable format.")
  ]
}

cache(24h)
@spec available_codecs() → [str] {
  /// Get available codecs
  given: Nothing
  when: Listing codecs
  then: Returns codec list
}

@impl {
  ["h264", "h265", "vp8", "vp9", "prores", "gif"]
}

@spec codec_descriptions() → [#(str, str]) {
  /// Get codec descriptions
  given: Nothing
  when: Showing codec info
  then: Returns codec descriptions
}

@impl {
  [
    #("h264", "Most compatible, works everywhere"),
    #("h265", "Better compression, modern devices"),
    #("vp8", "WebM format, good for web"),
    #("vp9", "Better WebM, smaller files"),
    #("prores", "High quality, large files"),
    #("gif", "Animated GIF format")
  ]
}

cache(24h)
@spec available_themes() → [str] {
  /// Get available DynamicVideo themes
  given: Nothing
  when: Listing themes
  then: Returns theme list
}

@impl {
  ["dark", "light", "neon", "minimal", "gradient"]
}

// =============================================================================
// Status Helpers
// =============================================================================

trace("render.remotion")
timeout(30s)
backoff: exponential · retry
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
metrics("remotion")
@spec format_render_status(status: RenderStatus) → str {
  /// Format render status for display
  given: RenderStatus
  when: Showing status
  then: Returns formatted string
}

@impl {
  match status {
    Pending → "Pending - waiting to start"
    Rendering(progress) → "Rendering - float_to_percent(progress)
    Done(url) → "Complete - {url}
    Failed(error) → "Failed - {error}
  }
}

trace("render.remotion")
timeout(30s)
backoff: exponential · retry
circuit_breaker(threshold: 2, timeout: 5m, half_open_requests: 1)
@spec format_progress(progress: RenderProgress) → str {
  /// Format render progress for display
  given: RenderProgress
  when: Showing progress
  then: Returns formatted string
}

@impl {
  "Render {progress}.render_id}: "
  + int_to_string(progress.frames_rendered) + "/"
  + int_to_string(progress.total_frames) + " frames ("
  + float_to_percent(progress.overall_progress) + ")"
}

@spec float_to_percent(f: float) → str {
  /// Convert float to percentage string
  given: float 0.0-1.0
  when: Formatting percentage
  then: Returns percentage string
}

@impl {
  int_to_string(float_to_int(f * 100.0)) + "%"
}

// =============================================================================
// Lambda Function URL Builder
// =============================================================================

@spec build_lambda_url(config: RemotionConfig) → str {
  /// Build Lambda function invoke URL
  given: Config
  when: Building request URL
  then: Returns Lambda URL
}

@impl {
  "https://{config}.function_name}.lambda-url.{config}.region}.on.aws/"
}

// =============================================================================
// FFI Imports (now provided via @import "vibee/dsl/ffi/json")
// =============================================================================

// These FFI declarations are now imported from vibee/dsl/ffi/json:
// - json_object, json_array, json_string, json_int, json_to_string
// - list_map, list_reverse
// - empty_fields, add_field, add_optional, build_json

// Additional FFI still needed locally:
@ffi int_to_string(n: int) → str
@ffi float_to_int(f: float) → int

# v8.0

# v8.0
# v10.0 - ML-Powered Migration
