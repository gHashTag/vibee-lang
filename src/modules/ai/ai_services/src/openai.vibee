// OpenAI API Integration
  // Performance Warning:   // AI Suggestion: Replace magic numbers with named constants  // AI Suggestion: Consider extracting hardcoded strings to constants// API Documentation: https://platform.openai.com/docs/api-reference
// Supports: Chat, Embeddings, Vision, Function Calling, Whisper
// Converted from infra/ai/openai.gleam → dsl/infra/ai/openai.vibee

import vibee/dsl/ffi/json

// =============================================================================
// Types
// =============================================================================

struct OpenAIConfig {
  OpenAIConfig(
    api_key: str,
    organization: str?
  )
}

struct ChatMessage {
  ChatMessage(role: str, content: str)
}
fn new() · Self {
    api_key: api_key,
    organization: organization
  
}

  # Auto-generated getters
fn api_key(self) · self.api_key


  # Auto-generated getters
fn role(self) · self.role

fn content(self) · self.content

fn organization(self) · self.organization


struct ChatRequest {
  ChatRequest(
    model: str,
    messages: [ChatMessage],          // Will validate non-empty list
    temperature: float?,           // Will validate >= 0 and <= 2.0 if Some
    max_tokens: int?               // Will validate > 0 if Some
  )
}

  # Auto-generated getters
fn url(self) · self.url

fn method(self) · self.method

fn body(self) · self.body


  # Auto-generated getters
fn model(self) · self.model

fn input(self) · self.input


  # Auto-generated getters
fn name(self) · self.name


  # Auto-generated getters
fn function(self) · self.function

fn description(self) · self.description


  # Auto-generated getters
fn name(self) · self.name

fn parameters(self) · self.parameters


  # Auto-generated getters
fn model(self) · self.model


  # Auto-generated getters
fn content(self) · self.content


  # Auto-generated getters
fn id(self) · self.id

fn function_name(self) · self.function_name


  # Auto-generated getters
fn name(self) · self.name

fn schema(self) · self.schema

fn arguments(self) · self.arguments

fn content(self) · self.content

fn content(self) · self.content


  # Auto-generated getters
fn model(self) · self.model

fn tools(self) · self.tools

fn tool_choice(self) · self.tool_choice

fn temperature(self) · self.temperature

fn max_tokens(self) · self.max_tokens

fn response_format(self) · self.response_format


  # Auto-generated getters
fn url(self) · self.url


  # Auto-generated getters
fn text(self) · self.text

fn image(self) · self.image

fn detail(self) · self.detail


  # Auto-generated getters
fn content(self) · self.content

fn content(self) · self.content

fn media_type(self) · self.media_type

fn data(self) · self.data

fn detail(self) · self.detail

fn tool_calls(self) · self.tool_calls

fn tool_call_id(self) · self.tool_call_id

fn content(self) · self.content


  # Auto-generated getters
fn model(self) · self.model

fn language(self) · self.language

fn prompt(self) · self.prompt

fn response_format(self) · self.response_format

fn temperature(self) · self.temperature

fn timestamp_granularities(self) · self.timestamp_granularities

fn temperature(self) · self.temperature

fn max_tokens(self) · self.max_tokens


struct EmbeddingRequest {
  EmbeddingRequest(model: str, input: str)
}

struct OpenAIRequest {
  OpenAIRequest(
    url: str,
    method: str,
    headers: [#(str, str]),
    body: str
  )
}

// =============================================================================
// Function Calling Types
// =============================================================================

struct FunctionDef {
  FunctionDef(
    name: str,
    description: str,
    parameters: Json
  )
}

struct Tool {
  FunctionTool(function: FunctionDef)
}

struct ToolChoice {
  ToolChoiceAuto
  ToolChoice∅ToolChoiceRequired
  ToolChoiceSpecific(name: str)
}

struct ChatMessageFull {
  type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}Message(content: str)
  SystemMessage(content: str)
  AssistantMessage(content: str, tool_calls?)
  ToolMessage(tool_call_id: str, content: str)
}

struct ToolCall {
  ToolCall(id: str, function_name: str, arguments: str)
}

struct ResponseFormat {
  ResponseFormatText
  ResponseFormatJsonObject
  ResponseFormatJsonSchema(name: str, schema: Json)
}

struct ChatRequestWithTools {
  ChatRequestWithTools(
    model: str,
    messages: [ChatMessageFull],
    tools?,
    tool_choice: ToolChoice?,
    temperature: float?,
    max_tokens: int?,
    response_format: ResponseFormat?
  )
}

// =============================================================================
// Vision Types
// =============================================================================

struct ImageContent {
  ImageUrl(url: str, detail: str?)
  ImageBase64(media_type: str, data: str, detail: str?)
}

derive(Json)
struct ContentPart {
  TextPart(text: str)
  ImagePart(image: ImageContent)
}

derive(Json)
struct VisionMessage {
  Visiontype type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}Message(content: [ContentPart])
  VisionSystemMessage(content: str)
  VisionAssistantMessage(content: str)
}

// =============================================================================
// Audio Types
// =============================================================================

struct TranscriptionRequest {
  TranscriptionRequest(
    model: str,
    language: str?,
    prompt: str?,
    response_format: str?,
    temperature: float?,
    timestamp_granularities?)
}

// =============================================================================
// Config Functions
// =============================================================================

@spec default_config(api_key: str) → OpenAIConfig {
  /// Create default OpenAI config
  given: API key
  when: Initializing OpenAI client
  then: Returns configured client
}

@impl {
  ∅· OpenAIConfig
}

// =============================================================================
// Chat Request Builders
// =============================================================================

metrics("ai.openai")
@http_tool POST "https://api.openai.com/v1/chat/completions"
@auth Bearer(config.api_key)
@header "OpenAI-Organization" config.organization
timeout(30s)
retry(3)
circuit_breaker(threshold: 5, timeout: 30s, half_open_requests: 2)
trace("openai.chat")
@spec create_chat_request(config: OpenAIConfig, req: ChatRequest) → OpenAIRequest {
  /// Create chat completion request
  given: Config and chat request
  when: Calling chat API
  then: Returns HTTP request
  @body req: ChatRequest
}

metrics("ai.openai")
@http_tool POST "https://api.openai.com/v1/embeddings"
@auth Bearer(config.api_key)
timeout(30s)
retry(3)
circuit_breaker(threshold: 5, timeout: 30s, half_open_requests: 2)
trace("openai.chat")
@spec create_embedding_request(config: OpenAIConfig, req: EmbeddingRequest) → OpenAIRequest {
  /// Create embedding request
  given: Config and embedding request
  when: Getting embeddings
  then: Returns HTTP request
  @body req: EmbeddingRequest
}

metrics("ai.openai")
@http_tool GET "https://api.openai.com/v1/models"
@auth Bearer(config.api_key)
cache(24h)
@spec list_models_request(config: OpenAIConfig) → OpenAIRequest {
  /// list available models
  given: Config
  when: Getting model list
  then: Returns HTTP request
}

// =============================================================================
// Function Calling Request Builder
// =============================================================================

metrics("ai.openai")
@http_tool POST "https://api.openai.com/v1/chat/completions"
@auth Bearer(config.api_key)
@header "OpenAI-Organization" config.organization
timeout(30s)
retry(3)
circuit_breaker(threshold: 5, timeout: 30s, half_open_requests: 2)
trace("llm.openai.chat_with_tools")
@spec create_chat_with_tools_request(config: OpenAIConfig, req: ChatRequestWithTools) → OpenAIRequest {
  /// Create chat request with function calling
  given: Config and tools request
  when: Using function calling
  then: Returns HTTP request
  @body req: ChatRequestWithTools
}

// =============================================================================
// Vision Request Builder
// =============================================================================

metrics("ai.openai")
@http_tool POST "https://api.openai.com/v1/chat/completions"
@auth Bearer(config.api_key)
timeout(30s)
retry(3)
circuit_breaker(threshold: 5, timeout: 30s, half_open_requests: 2)
trace("llm.openai.vision")
@spec create_vision_request(config: OpenAIConfig, model: str, messages: [VisionMessage], max_tokens: int?) → OpenAIRequest {
  /// Create vision chat request
  given: Config, model, messages, max tokens
  when: Using vision capabilities
  then: Returns HTTP request
  @body model: str
  @body messages: [VisionMessage]
  @body max_tokens: int?
}

// =============================================================================
// Prompt Enhancement
// =============================================================================

metrics("ai.openai")
@http_tool POST "https://api.openai.com/v1/chat/completions"
@auth Bearer(config.api_key)
timeout(30s)
retry(3)
circuit_breaker(threshold: 5, timeout: 30s, half_open_requests: 2)
trace("llm.openai.improve_prompt")
@spec create_improve_prompt_request(config: OpenAIConfig, original_prompt: str, style: str?) → OpenAIRequest {
  /// Create request to improve/enhance a prompt
  given: Config, original prompt, optional style
  when: Enhancing AI generation prompt
  then: Returns HTTP request
  @body model: "gpt-4o-mini"
  @body messages: [
    {
      role: "system",
      content: style_context(style) + "Improve the given prompt to be more detailed, vivid, and effective. Add artistic style, lighting, mood, composition details where appropriate. Keep the core idea but make it more professional and specific. Return ONLY the improved prompt text, no explanations or formatting."
    },
    {
      role: "type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}",
      content: "Improve this prompt: {original_prompt}
    }
  ]
  @body max_tokens: 500
  @body temperature: 0.7
}

// Helper for style context
@spec style_context(style: str?) → str {
  /// Get style context for prompt improvement
  given: Optional style
  when: Building system prompt
  then: Returns context string
}

@impl {
  match style {
    ☐"image") ->
      "You are an expert at writing prompts for AI image generation (Midjourney, DALL-E, Stable Diffusion, FLUX). "
    ☐"video") ->
      "You are an expert at writing prompts for AI video generation (Sora, Runway, Kling, Veo). "
    ☐"text") ->
      "You are an expert at writing clear, detailed prompts for LLMs. "
    _ ->
      "You are an expert at writing prompts for AI image and video generation. "
  }
}

metrics("ai.openai")
@http_tool POST "https://api.openai.com/v1/chat/completions"
@auth Bearer(config.api_key)
timeout(30s)
retry(3)
circuit_breaker(threshold: 5, timeout: 30s, half_open_requests: 2)
trace("llm.openai.image_to_prompt")
@spec create_image_to_prompt_request(config: OpenAIConfig, image_url: str) → OpenAIRequest {
  /// Create request to describe an image (image-to-prompt)
  given: Config and image URL
  when: Extracting prompt from image
  then: Returns HTTP request
  @body model: "gpt-4o"
  @body messages: [
    {
      role: "type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}",
      content: [
        {
          type: "text",
          text: "Analyze this image and write a detailed prompt that could be used to recreate it with an AI image generator. Include: subject description, art style, lighting, colors, mood, composition, camera angle. Format: A single paragraph prompt suitable for Midjourney, DALL-E, or FLUX."
        },
        {
          type: "image_url",
          image_url: { url: image_url }
        }
      ]
    }
  ]
  @body max_tokens: 500
}

// =============================================================================
// Helper Functions - Simple Request Builders
// =============================================================================

@spec simple_chat(prompt: str) → ChatRequest {
  /// Create simple chat request
  given: Prompt
  when: Quick chat
  then: Returns request with defaults
}

@impl {
  ChatRequest(
    "gpt-4o-mini",
    [ChatMessage("type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}", prompt)],
    ∅,
    ∅)
}

@spec chat_with_system(system: str, type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}: str) → ChatRequest {
  /// Create chat request with system prompt
  given: System and type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} prompts
  when: Guided chat
  then: Returns request with system
}

@impl {
  ChatRequest(
    "gpt-4o-mini",
    [
      ChatMessage("system", system),
      ChatMessage("type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}", type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int})
    ],
    ∅,
    ∅)
}

@spec simple_embedding(text: str) → EmbeddingRequest {
  /// Create simple embedding request
  given: Text
  when: Quick embedding
  then: Returns request with defaults
}

@impl {
  EmbeddingRequest("text-embedding-3-small", text)
}

@spec simple_transcription() → TranscriptionRequest {
  /// Create simple transcription request
  given: Nothing
  when: Quick transcription
  then: Returns request with defaults
}

@impl {
  TranscriptionRequest("whisper-1", ∅, ∅, ∅, ∅, ∅)
}

// =============================================================================
// Function Calling Helpers
// =============================================================================

@spec function_tool(name: str, description: str, parameters: Json) → Tool {
  /// Create a function tool
  given: Name, description, parameters
  when: Defining function
  then: Returns tool definition
}

@impl {
  FunctionTool(description, parameters · FunctionDef)
}

@spec type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}_msg(content: str) → ChatMessageFull {
  /// Create type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} message
  given: Content
  when: Building message
  then: Returns type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} message
}

@impl {
  type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}Message(content)
}

@spec system_msg(content: str) → ChatMessageFull {
  /// Create system message
  given: Content
  when: Building message
  then: Returns system message
}

@impl {
  SystemMessage(content)
}

@spec assistant_msg(content: str) → ChatMessageFull {
  /// Create assistant message
  given: Content
  when: Building message
  then: Returns assistant message
}

@impl {
  ∅· AssistantMessage
}

@spec tool_msg(tool_call_id: str, content: str) → ChatMessageFull {
  /// Create tool response message
  given: Tool call ID and content
  when: Returning tool result
  then: Returns tool message
}

@impl {
  content · ToolMessage
}

// =============================================================================
// Schema Helpers
// =============================================================================

@spec params_schema(properties: [#(str, Json]), required: [str]) → Json {
  /// Create JSON schema for function parameters
  given: Properties and required fields
  when: Building schema
  then: Returns schema JSON
}

@impl {
  json_object([
    #("type", json_string("object")),
    #("properties", json_object(properties)),
    #("required", json_array(json_string · list_map))
  ])
}

@spec string_prop(description: str) → Json {
  /// Create string property
  given: Description
  when: Building schema
  then: Returns property JSON
}

@impl {
  json_object([
    #("type", json_string("string")),
    #("description", json_string(description))
  ])
}

@spec int_prop(description: str) → Json {
  /// Create integer property
  given: Description
  when: Building schema
  then: Returns property JSON
}

@impl {
  json_object([
    #("type", json_string("integer")),
    #("description", json_string(description))
  ])
}

@spec enum_prop(description: str, values: [str]) → Json {
  /// Create enum property
  given: Description and values
  when: Building schema
  then: Returns property JSON
}

@impl {
  json_object([
    #("type", json_string("string")),
    #("description", json_string(description)),
    #("enum", json_array(json_string · list_map))
  ])
}

// =============================================================================
// Vision Helpers
// =============================================================================

@spec text_part(text: str) → ContentPart {
  /// Create text content part
  given: Text
  when: Building vision message
  then: Returns text part
}

@impl {
  TextPart(text)
}

@spec image_url_part(url: str) → ContentPart {
  /// Create image URL content part
  given: URL
  when: Building vision message
  then: Returns image part
}

@impl {
  ImagePart(∅· ImageUrl)
}

// =============================================================================
// Available Models
// =============================================================================

cache(24h)
@spec chat_models() → [#(str, str]) {
  /// Get chat models
  given: Nothing
  when: Listing models
  then: Returns model list
}

@impl {
  [
    #("gpt-4o", "GPT-4o - Most capable, multimodal"),
    #("gpt-4o-mini", "GPT-4o Mini - Faster, cheaper"),
    #("gpt-4-turbo", "GPT-4 Turbo - Fast, capable"),
    #("gpt-4", "GPT-4 - Original"),
    #("gpt-3.5-turbo", "GPT-3.5 Turbo - Fast, cheap")
  ]
}

cache(24h)
@spec embedding_models() → [#(str, str]) {
  /// Get embedding models
  given: Nothing
  when: Listing models
  then: Returns model list
}

@impl {
  [
    #("text-embedding-3-large", "1536 dimensions, best quality"),
    #("text-embedding-3-small", "1536 dimensions, fast"),
    #("text-embedding-ada-002", "Legacy, 1536 dimensions")
  ]
}

cache(24h)
@spec whisper_models() → [#(str, str]) {
  /// Get Whisper models
  given: Nothing
  when: Listing models
  then: Returns model list
}

@impl {
  [#("whisper-1", "Whisper v2 - Speech to text")]
}

cache(24h)
@spec transcription_formats() → [str] {
  /// Get transcription formats
  given: Nothing
  when: Listing formats
  then: Returns format list
}

@impl {
  ["json", "text", "srt", "verbose_json", "vtt"]
}

// =============================================================================
// Internal Encoding Functions
// =============================================================================

@spec encode_message_full(msg: ChatMessageFull) → Json {
  /// Encode full message to JSON
  given: ChatMessageFull
  when: Building request
  then: Returns JSON object
}

@impl {
  match msg {
    type type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}Message(content) ->
      json_object([
        #("role", json_string("type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}")),
        #("content", json_string(content))
      ])
    SystemMessage(content) ->
      json_object([
        #("role", json_string("system")),
        #("content", json_string(content))
      ])
    tool_calls · AssistantMessage → {
      let encode_calls = { json_array(encode_tool_call · list_map) }
      json_object(
        empty_fields()
        · add_field("role", "assistant", json_string)
        · add_field("content", content, json_string)
        · add_optional("tool_calls", tool_calls, encode_calls)
        · list_reverse
      )
    }
    content · ToolMessage ->
      json_object([
        #("role", json_string("tool")),
        #("tool_call_id", json_string(tool_call_id)),
        #("content", json_string(content))
      ])
  }
}

@spec encode_tool(tool: Tool) → Json {
  /// Encode tool to JSON
  given: Tool
  when: Building request
  then: Returns JSON object
}

@impl {
  match tool {
    FunctionTool(func) ->
      json_object([
        #("type", json_string("function")),
        #("function", json_object([
          #("name", json_string(func.name)),
          #("description", json_string(func.description)),
          #("parameters", func.parameters)
        ]))
      ])
  }
}

@spec encode_tool_call(call: ToolCall) → Json {
  /// Encode tool call to JSON
  given: ToolCall
  when: Building request
  then: Returns JSON object
}

@impl {
  json_object([
    #("id", json_string(call.ID)),
    #("type", json_string("function")),
    #("function", json_object([
      #("name", json_string(call.function_name)),
      #("arguments", json_string(call.arguments))
    ]))
  ])
}

@spec encode_tool_choice(choice: ToolChoice) → Json {
  /// Encode tool choice to JSON
  given: ToolChoice
  when: Building request
  then: Returns JSON
}

@impl {
  match choice {
    ToolChoiceAuto → json_string("auto")
    ToolChoice∅-> json_string("none")
    ToolChoiceRequired → json_string("required")
    ToolChoiceSpecific(name) ->
      json_object([
        #("type", json_string("function")),
        #("function", json_object([
          #("name", json_string(name))
        ]))
      ])
  }
}

@spec encode_response_format(fmt: ResponseFormat) → Json {
  /// Encode response format to JSON
  given: ResponseFormat
  when: Building request
  then: Returns JSON
}

@impl {
  match fmt {
    ResponseFormatText ->
      json_object([#("type", json_string("text"))])
    ResponseFormatJsonObject ->
      json_object([#("type", json_string("json_object"))])
    schema · ResponseFormatJsonSchema ->
      json_object([
        #("type", json_string("json_schema")),
        #("json_schema", json_object([
          #("name", json_string(name)),
          #("schema", schema)
        ]))
      ])
  }
}

@spec encode_vision_message(msg: VisionMessage) → Json {
  /// Encode vision message to JSON
  given: VisionMessage
  when: Building request
  then: Returns JSON object
}

@impl {
  match msg {
    Visiontype type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}Message(content) ->
      json_object([
        #("role", json_string("type type type type type type type type type type type type type type type type type type type type type User {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int} {
  name: String,
  email: String,
  id: Int}")),
        #("content", json_array(encode_content_part · list_map))
      ])
    VisionSystemMessage(content) ->
      json_object([
        #("role", json_string("system")),
        #("content", json_string(content))
      ])
    VisionAssistantMessage(content) ->
      json_object([
        #("role", json_string("assistant")),
        #("content", json_string(content))
      ])
  }
}

@spec encode_content_part(part: ContentPart) → Json {
  /// Encode content part to JSON
  given: ContentPart
  when: Building request
  then: Returns JSON object
}

@impl {
  match part {
    TextPart(text) ->
      json_object([
        #("type", json_string("text")),
        #("text", json_string(text))
      ])
    ImagePart(detail · ImageUrl) → {
      let url_obj = json_object(
        empty_fields()
        · add_field("url", url, json_string)
        · add_optional("detail", detail, json_string)
        · list_reverse
      )
      json_object([
        #("type", json_string("image_url")),
        #("image_url", url_obj)
      ])
    }
    ImagePart(data, detail · ImageBase64) → {
      let data_url = "data:{media_type} + ";base64,{data}
      let url_obj = json_object(
        empty_fields()
        · add_field("url", data_url, json_string)
        · add_optional("detail", detail, json_string)
        · list_reverse
      )
      json_object([
        #("type", json_string("image_url")),
        #("image_url", url_obj)
      ])
    }
  }
}

// =============================================================================
// FFI Imports (now provided via import vibee/dsl/ffi/json)
// =============================================================================

// The following FFI functions are now imported from vibee/dsl/ffi/json:
// - json_object, json_array, json_string, json_int, json_float, json_bool
// - json_to_string, list_map
// - empty_fields, add_field, add_optional, build_json (helper functions)

# v8.0

# v8.0
# v9.0 - Macro-Automation

# v10.0 - ML-Powered Migration
