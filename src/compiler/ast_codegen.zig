// ============================================================================
// VIBEEC AST CODE GENERATOR
// Generates target language code from VIBEE AST
// Supports: Zig, Rust, Go
// ============================================================================

const std = @import("std");
const ast = @import("ast.zig");

pub const Target = enum {
    Zig,
    Rust,
    Go,
    
    pub fn extension(self: Target) []const u8 {
        return switch (self) {
            .Zig => ".zig",
            .Rust => ".rs",
            .Go => ".go",
        };
    }
};

pub const CodeGenerator = struct {
    allocator: std.mem.Allocator,
    output: std.ArrayList(u8),
    target: Target,
    indent_level: usize,
    
    pub fn init(allocator: std.mem.Allocator, target: Target) CodeGenerator {
        return CodeGenerator{
            .allocator = allocator,
            .output = std.ArrayList(u8).init(allocator),
            .target = target,
            .indent_level = 0,
        };
    }
    
    pub fn deinit(self: *CodeGenerator) void {
        self.output.deinit();
    }
    
    pub fn generate(self: *CodeGenerator, node: *ast.Node) ![]const u8 {
        try self.emitHeader();
        try self.emitNode(node);
        return self.output.toOwnedSlice();
    }
    
    // ========================================================================
    // HEADER
    // ========================================================================
    
    fn emitHeader(self: *CodeGenerator) !void {
        switch (self.target) {
            .Zig => {
                try self.write("// Generated by VIBEEC\n");
                try self.write("const std = @import(\"std\");\n\n");
            },
            .Rust => {
                try self.write("// Generated by VIBEEC\n");
                try self.write("#![allow(unused)]\n\n");
            },
            .Go => {
                try self.write("// Generated by VIBEEC\n");
                try self.write("package main\n\n");
            },
        }
    }
    
    // ========================================================================
    // NODE EMISSION
    // ========================================================================
    
    fn emitNode(self: *CodeGenerator, node: *ast.Node) std.mem.Allocator.Error!void {
        switch (node.node_type) {
            .Program => try self.emitProgram(node),
            .FunctionDecl => try self.emitFunction(node),
            .ConstDecl => try self.emitConst(node),
            .LetDecl => try self.emitLet(node),
            .VarDecl => try self.emitVar(node),
            .Block => try self.emitBlock(node),
            .IfStmt => try self.emitIf(node),
            .ForStmt => try self.emitFor(node),
            .WhileStmt => try self.emitWhile(node),
            .ReturnStmt => try self.emitReturn(node),
            .BinaryExpr => try self.emitBinary(node),
            .UnaryExpr => try self.emitUnary(node),
            .CallExpr => try self.emitCall(node),
            .MemberExpr => try self.emitMember(node),
            .IndexExpr => try self.emitIndex(node),
            .IntLiteral => try self.emitInt(node),
            .FloatLiteral => try self.emitFloat(node),
            .StringLiteral => try self.emitString(node),
            .BoolLiteral => try self.emitBool(node),
            .Identifier => try self.emitIdentifier(node),
            .ArrayLiteral => try self.emitArray(node),
            .TestDecl => try self.emitTest(node),
            .NoneLiteral => try self.emitNone(),
            else => {},
        }
    }
    
    // ========================================================================
    // DECLARATIONS
    // ========================================================================
    
    fn emitProgram(self: *CodeGenerator, node: *ast.Node) !void {
        for (node.data.program.declarations) |decl| {
            try self.emitNode(decl);
            try self.write("\n");
        }
    }
    
    fn emitFunction(self: *CodeGenerator, node: *ast.Node) !void {
        const f = node.data.function_decl;
        
        switch (self.target) {
            .Zig => {
                if (f.is_pub) try self.write("pub ");
                try self.write("fn ");
                try self.write(f.name);
                try self.write("(");
                
                for (f.params, 0..) |param, i| {
                    if (i > 0) try self.write(", ");
                    try self.write(param.name);
                    try self.write(": ");
                    if (param.type_annotation) |t| {
                        try self.emitType(t);
                    } else {
                        try self.write("anytype");
                    }
                }
                
                try self.write(") ");
                if (f.return_type) |rt| {
                    try self.emitType(rt);
                    try self.write(" ");
                }
            },
            .Rust => {
                if (f.is_pub) try self.write("pub ");
                try self.write("fn ");
                try self.write(f.name);
                try self.write("(");
                
                for (f.params, 0..) |param, i| {
                    if (i > 0) try self.write(", ");
                    try self.write(param.name);
                    try self.write(": ");
                    if (param.type_annotation) |t| {
                        try self.emitTypeRust(t);
                    } else {
                        try self.write("impl Any");
                    }
                }
                
                try self.write(")");
                if (f.return_type) |rt| {
                    try self.write(" -> ");
                    try self.emitTypeRust(rt);
                }
                try self.write(" ");
            },
            .Go => {
                try self.write("func ");
                try self.write(f.name);
                try self.write("(");
                
                for (f.params, 0..) |param, i| {
                    if (i > 0) try self.write(", ");
                    try self.write(param.name);
                    try self.write(" ");
                    if (param.type_annotation) |t| {
                        try self.emitTypeGo(t);
                    } else {
                        try self.write("interface{}");
                    }
                }
                
                try self.write(")");
                if (f.return_type) |rt| {
                    try self.write(" ");
                    try self.emitTypeGo(rt);
                }
                try self.write(" ");
            },
        }
        
        if (f.body) |body| {
            try self.emitNode(body);
        } else {
            try self.write("{}");
        }
        try self.write("\n");
    }
    
    fn emitConst(self: *CodeGenerator, node: *ast.Node) !void {
        const c = node.data.const_decl;
        
        switch (self.target) {
            .Zig => {
                try self.writeIndent();
                try self.write("const ");
                try self.write(c.name);
                if (c.type_annotation) |t| {
                    try self.write(": ");
                    try self.emitType(t);
                }
                try self.write(" = ");
                try self.emitNode(c.value);
                try self.write(";\n");
            },
            .Rust => {
                try self.writeIndent();
                try self.write("const ");
                try self.write(c.name);
                try self.write(": ");
                if (c.type_annotation) |t| {
                    try self.emitTypeRust(t);
                } else {
                    try self.write("_");
                }
                try self.write(" = ");
                try self.emitNode(c.value);
                try self.write(";\n");
            },
            .Go => {
                try self.writeIndent();
                try self.write("const ");
                try self.write(c.name);
                try self.write(" = ");
                try self.emitNode(c.value);
                try self.write("\n");
            },
        }
    }
    
    fn emitLet(self: *CodeGenerator, node: *ast.Node) !void {
        const l = node.data.let_decl;
        
        switch (self.target) {
            .Zig => {
                try self.writeIndent();
                try self.write("const ");
                try self.write(l.name);
                if (l.type_annotation) |t| {
                    try self.write(": ");
                    try self.emitType(t);
                }
                try self.write(" = ");
                try self.emitNode(l.value);
                try self.write(";\n");
            },
            .Rust => {
                try self.writeIndent();
                try self.write("let ");
                try self.write(l.name);
                if (l.type_annotation) |t| {
                    try self.write(": ");
                    try self.emitTypeRust(t);
                }
                try self.write(" = ");
                try self.emitNode(l.value);
                try self.write(";\n");
            },
            .Go => {
                try self.writeIndent();
                try self.write(l.name);
                try self.write(" := ");
                try self.emitNode(l.value);
                try self.write("\n");
            },
        }
    }
    
    fn emitVar(self: *CodeGenerator, node: *ast.Node) !void {
        const v = node.data.var_decl;
        
        switch (self.target) {
            .Zig => {
                try self.writeIndent();
                try self.write("var ");
                try self.write(v.name);
                if (v.type_annotation) |t| {
                    try self.write(": ");
                    try self.emitType(t);
                }
                if (v.value) |val| {
                    try self.write(" = ");
                    try self.emitNode(val);
                }
                try self.write(";\n");
            },
            .Rust => {
                try self.writeIndent();
                try self.write("let mut ");
                try self.write(v.name);
                if (v.type_annotation) |t| {
                    try self.write(": ");
                    try self.emitTypeRust(t);
                }
                if (v.value) |val| {
                    try self.write(" = ");
                    try self.emitNode(val);
                }
                try self.write(";\n");
            },
            .Go => {
                try self.writeIndent();
                try self.write("var ");
                try self.write(v.name);
                if (v.type_annotation) |t| {
                    try self.write(" ");
                    try self.emitTypeGo(t);
                }
                if (v.value) |val| {
                    try self.write(" = ");
                    try self.emitNode(val);
                }
                try self.write("\n");
            },
        }
    }
    
    fn emitTest(self: *CodeGenerator, node: *ast.Node) !void {
        const t = node.data.test_decl;
        
        switch (self.target) {
            .Zig => {
                try self.write("test \"");
                try self.write(t.name);
                try self.write("\" ");
                try self.emitNode(t.body);
                try self.write("\n");
            },
            .Rust => {
                try self.write("#[test]\n");
                try self.write("fn test_");
                // Replace spaces with underscores
                for (t.name) |c| {
                    if (c == ' ') {
                        try self.output.append('_');
                    } else {
                        try self.output.append(c);
                    }
                }
                try self.write("() ");
                try self.emitNode(t.body);
                try self.write("\n");
            },
            .Go => {
                try self.write("func Test");
                // Capitalize first letter
                if (t.name.len > 0) {
                    const first = std.ascii.toUpper(t.name[0]);
                    try self.output.append(first);
                    for (t.name[1..]) |c| {
                        if (c == ' ') {
                            try self.output.append('_');
                        } else {
                            try self.output.append(c);
                        }
                    }
                }
                try self.write("(t *testing.T) ");
                try self.emitNode(t.body);
                try self.write("\n");
            },
        }
    }
    
    // ========================================================================
    // STATEMENTS
    // ========================================================================
    
    fn emitBlock(self: *CodeGenerator, node: *ast.Node) !void {
        try self.write("{\n");
        self.indent_level += 1;
        
        for (node.data.block.statements) |stmt| {
            try self.emitNode(stmt);
        }
        
        self.indent_level -= 1;
        try self.writeIndent();
        try self.write("}");
    }
    
    fn emitIf(self: *CodeGenerator, node: *ast.Node) !void {
        const i = node.data.if_stmt;
        
        try self.writeIndent();
        try self.write("if ");
        
        switch (self.target) {
            .Zig => {
                try self.write("(");
                try self.emitNode(i.condition);
                try self.write(") ");
            },
            .Rust, .Go => {
                try self.emitNode(i.condition);
                try self.write(" ");
            },
        }
        
        try self.emitNode(i.then_branch);
        
        if (i.else_branch) |eb| {
            try self.write(" else ");
            try self.emitNode(eb);
        }
        try self.write("\n");
    }
    
    fn emitFor(self: *CodeGenerator, node: *ast.Node) !void {
        const f = node.data.for_stmt;
        
        try self.writeIndent();
        
        switch (self.target) {
            .Zig => {
                try self.write("for (");
                try self.emitNode(f.iterable);
                try self.write(") |");
                try self.write(f.variable);
                try self.write("| ");
            },
            .Rust => {
                try self.write("for ");
                try self.write(f.variable);
                try self.write(" in ");
                try self.emitNode(f.iterable);
                try self.write(" ");
            },
            .Go => {
                try self.write("for _, ");
                try self.write(f.variable);
                try self.write(" := range ");
                try self.emitNode(f.iterable);
                try self.write(" ");
            },
        }
        
        try self.emitNode(f.body);
        try self.write("\n");
    }
    
    fn emitWhile(self: *CodeGenerator, node: *ast.Node) !void {
        const w = node.data.while_stmt;
        
        try self.writeIndent();
        
        switch (self.target) {
            .Zig => {
                try self.write("while (");
                try self.emitNode(w.condition);
                try self.write(") ");
            },
            .Rust => {
                try self.write("while ");
                try self.emitNode(w.condition);
                try self.write(" ");
            },
            .Go => {
                try self.write("for ");
                try self.emitNode(w.condition);
                try self.write(" ");
            },
        }
        
        try self.emitNode(w.body);
        try self.write("\n");
    }
    
    fn emitReturn(self: *CodeGenerator, node: *ast.Node) !void {
        const r = node.data.return_stmt;
        
        try self.writeIndent();
        try self.write("return");
        
        if (r.value) |v| {
            try self.write(" ");
            try self.emitNode(v);
        }
        
        switch (self.target) {
            .Zig, .Rust => try self.write(";\n"),
            .Go => try self.write("\n"),
        }
    }
    
    // ========================================================================
    // EXPRESSIONS
    // ========================================================================
    
    fn emitBinary(self: *CodeGenerator, node: *ast.Node) !void {
        const b = node.data.binary_expr;
        
        try self.write("(");
        try self.emitNode(b.left);
        
        const op = switch (b.operator) {
            .Add => " + ",
            .Sub => " - ",
            .Mul => " * ",
            .Div => " / ",
            .Mod => " % ",
            .And => " && ",
            .Or => " || ",
            .BitAnd => " & ",
            .BitOr => " | ",
            .BitXor => " ^ ",
            .Shl => " << ",
            .Shr => " >> ",
            .Eq => " == ",
            .Ne => " != ",
            .Lt => " < ",
            .Le => " <= ",
            .Gt => " > ",
            .Ge => " >= ",
            .Range => "..",
            .RangeInc => "..=",
        };
        try self.write(op);
        
        try self.emitNode(b.right);
        try self.write(")");
    }
    
    fn emitUnary(self: *CodeGenerator, node: *ast.Node) !void {
        const u = node.data.unary_expr;
        
        const op = switch (u.operator) {
            .Neg => "-",
            .Not => "!",
            .BitNot => "~",
        };
        try self.write(op);
        try self.emitNode(u.operand);
    }
    
    fn emitCall(self: *CodeGenerator, node: *ast.Node) !void {
        const c = node.data.call_expr;
        
        try self.emitNode(c.callee);
        try self.write("(");
        
        for (c.arguments, 0..) |arg, i| {
            if (i > 0) try self.write(", ");
            try self.emitNode(arg);
        }
        
        try self.write(")");
    }
    
    fn emitMember(self: *CodeGenerator, node: *ast.Node) !void {
        const m = node.data.member_expr;
        
        try self.emitNode(m.object);
        try self.write(".");
        try self.write(m.member);
    }
    
    fn emitIndex(self: *CodeGenerator, node: *ast.Node) !void {
        const idx = node.data.index_expr;
        
        try self.emitNode(idx.object);
        try self.write("[");
        try self.emitNode(idx.index);
        try self.write("]");
    }
    
    // ========================================================================
    // LITERALS
    // ========================================================================
    
    fn emitInt(self: *CodeGenerator, node: *ast.Node) !void {
        try self.write(node.data.int_literal.raw);
    }
    
    fn emitFloat(self: *CodeGenerator, node: *ast.Node) !void {
        try self.write(node.data.float_literal.raw);
    }
    
    fn emitString(self: *CodeGenerator, node: *ast.Node) !void {
        try self.write(node.data.string_literal.raw);
    }
    
    fn emitBool(self: *CodeGenerator, node: *ast.Node) !void {
        if (node.data.bool_literal.value) {
            try self.write("true");
        } else {
            try self.write("false");
        }
    }
    
    fn emitIdentifier(self: *CodeGenerator, node: *ast.Node) !void {
        try self.write(node.data.identifier.name);
    }
    
    fn emitArray(self: *CodeGenerator, node: *ast.Node) !void {
        const arr = node.data.array_literal;
        
        switch (self.target) {
            .Zig => {
                try self.write(".{");
                for (arr.elements, 0..) |elem, i| {
                    if (i > 0) try self.write(", ");
                    try self.emitNode(elem);
                }
                try self.write("}");
            },
            .Rust => {
                try self.write("vec![");
                for (arr.elements, 0..) |elem, i| {
                    if (i > 0) try self.write(", ");
                    try self.emitNode(elem);
                }
                try self.write("]");
            },
            .Go => {
                try self.write("[]interface{}{");
                for (arr.elements, 0..) |elem, i| {
                    if (i > 0) try self.write(", ");
                    try self.emitNode(elem);
                }
                try self.write("}");
            },
        }
    }
    
    fn emitNone(self: *CodeGenerator) !void {
        switch (self.target) {
            .Zig => try self.write("null"),
            .Rust => try self.write("None"),
            .Go => try self.write("nil"),
        }
    }
    
    // ========================================================================
    // TYPES
    // ========================================================================
    
    fn emitType(self: *CodeGenerator, node: *ast.Node) !void {
        const t = node.data.type_annotation;
        
        if (t.is_optional) try self.write("?");
        if (t.is_array) try self.write("[]");
        
        // Map VIBEE types to Zig types
        const zig_type = mapTypeZig(t.name);
        try self.write(zig_type);
    }
    
    fn emitTypeRust(self: *CodeGenerator, node: *ast.Node) !void {
        const t = node.data.type_annotation;
        
        if (t.is_optional) try self.write("Option<");
        if (t.is_array) try self.write("Vec<");
        
        const rust_type = mapTypeRust(t.name);
        try self.write(rust_type);
        
        if (t.is_array) try self.write(">");
        if (t.is_optional) try self.write(">");
    }
    
    fn emitTypeGo(self: *CodeGenerator, node: *ast.Node) !void {
        const t = node.data.type_annotation;
        
        if (t.is_optional) try self.write("*");
        if (t.is_array) try self.write("[]");
        
        const go_type = mapTypeGo(t.name);
        try self.write(go_type);
    }
    
    fn mapTypeZig(name: []const u8) []const u8 {
        if (std.mem.eql(u8, name, "Int")) return "i64";
        if (std.mem.eql(u8, name, "Float")) return "f64";
        if (std.mem.eql(u8, name, "Bool")) return "bool";
        if (std.mem.eql(u8, name, "String")) return "[]const u8";
        if (std.mem.eql(u8, name, "Void")) return "void";
        return name;
    }
    
    fn mapTypeRust(name: []const u8) []const u8 {
        if (std.mem.eql(u8, name, "Int")) return "i64";
        if (std.mem.eql(u8, name, "Float")) return "f64";
        if (std.mem.eql(u8, name, "Bool")) return "bool";
        if (std.mem.eql(u8, name, "String")) return "String";
        if (std.mem.eql(u8, name, "Void")) return "()";
        return name;
    }
    
    fn mapTypeGo(name: []const u8) []const u8 {
        if (std.mem.eql(u8, name, "Int")) return "int64";
        if (std.mem.eql(u8, name, "Float")) return "float64";
        if (std.mem.eql(u8, name, "Bool")) return "bool";
        if (std.mem.eql(u8, name, "String")) return "string";
        if (std.mem.eql(u8, name, "Void")) return "";
        return name;
    }
    
    // ========================================================================
    // HELPERS
    // ========================================================================
    
    fn write(self: *CodeGenerator, s: []const u8) !void {
        try self.output.appendSlice(s);
    }
    
    fn writeIndent(self: *CodeGenerator) !void {
        for (0..self.indent_level) |_| {
            try self.write("    ");
        }
    }
};

// ============================================================================
// CONVENIENCE FUNCTIONS
// ============================================================================

pub fn generateZig(allocator: std.mem.Allocator, tree: *ast.Node) ![]const u8 {
    var gen = CodeGenerator.init(allocator, .Zig);
    return gen.generate(tree);
}

pub fn generateRust(allocator: std.mem.Allocator, tree: *ast.Node) ![]const u8 {
    var gen = CodeGenerator.init(allocator, .Rust);
    return gen.generate(tree);
}

pub fn generateGo(allocator: std.mem.Allocator, tree: *ast.Node) ![]const u8 {
    var gen = CodeGenerator.init(allocator, .Go);
    return gen.generate(tree);
}

// ============================================================================
// TESTS
// ============================================================================

const vibee_parser = @import("vibee_parser.zig");

fn testGenerate(source: []const u8, target: Target) ![]const u8 {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const allocator = arena.allocator();
    
    const tree = try vibee_parser.parseSource(allocator, source);
    var gen = CodeGenerator.init(allocator, target);
    return gen.generate(tree);
}

test "generate zig function" {
    const code = try testGenerate("fn add(a: Int, b: Int) -> Int { return a + b }", .Zig);
    try std.testing.expect(std.mem.indexOf(u8, code, "fn add") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "i64") != null);
}

test "generate rust function" {
    const code = try testGenerate("fn add(a: Int, b: Int) -> Int { return a + b }", .Rust);
    try std.testing.expect(std.mem.indexOf(u8, code, "fn add") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "i64") != null);
}

test "generate go function" {
    const code = try testGenerate("fn add(a: Int, b: Int) -> Int { return a + b }", .Go);
    try std.testing.expect(std.mem.indexOf(u8, code, "func add") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "int64") != null);
}

test "generate const" {
    const code = try testGenerate("const PI: Float = 3.14", .Zig);
    try std.testing.expect(std.mem.indexOf(u8, code, "const PI") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "3.14") != null);
}

test "generate if statement" {
    const code = try testGenerate("if x > 0 { return 1 }", .Zig);
    try std.testing.expect(std.mem.indexOf(u8, code, "if") != null);
    try std.testing.expect(std.mem.indexOf(u8, code, "return") != null);
}
