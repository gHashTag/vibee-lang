/// Vibee Lang Code Generator
/// Generates target code from IR

use crate::ir::{IRModule, IRFunction, IRBlock, IRInst, IRTerminator, Reg}

// Target architectures
pub enum Target {
    LLVM,
    WASM,
    JavaScript,
    Native,
}

// Code generator trait
pub trait CodeGen {
    fn generate(self, module: IRModule) -> String
}

// LLVM IR Generator
pub struct LLVMCodeGen {
    output: String,
    indent: Int,
}

impl LLVMCodeGen {
    pub fn new() -> LLVMCodeGen {
        LLVMCodeGen { output: String::new(), indent: 0 }
    }
    
    fn emit(mut self, s: String) {
        for _ in 0..self.indent {
            self.output += "  "
        }
        self.output += s
        self.output += "\n"
    }
    
    fn reg_name(self, reg: Reg) -> String {
        format!("%r{}", reg)
    }
}

impl CodeGen for LLVMCodeGen {
    fn generate(mut self, module: IRModule) -> String {
        // Module header
        self.emit(format!("; ModuleID = '{}'", module.name))
        self.emit("target triple = \"x86_64-unknown-linux-gnu\"")
        self.emit("")
        
        // Struct definitions
        for s in module.structs.iter() {
            let fields: Vec<String> = s.fields.iter()
                .map(|(_, ty)| self.type_to_llvm(ty.clone()))
                .collect()
            self.emit(format!("%struct.{} = type {{ {} }}", s.name, fields.join(", ")))
        }
        self.emit("")
        
        // Function definitions
        for func in module.functions.iter() {
            self.generate_function(func.clone())
        }
        
        // Runtime declarations
        self.emit("; Runtime declarations")
        self.emit("declare i8* @malloc(i64)")
        self.emit("declare void @free(i8*)")
        self.emit("declare i32 @printf(i8*, ...)")
        self.emit("declare i32 @puts(i8*)")
        
        self.output
    }
}

impl LLVMCodeGen {
    fn generate_function(mut self, func: IRFunction) {
        let params: Vec<String> = func.params.iter()
            .enumerate()
            .map(|(i, (_, ty))| format!("{} %r{}", self.type_to_llvm(ty.clone()), i))
            .collect()
        
        let ret_type = self.type_to_llvm(func.ret_type.clone())
        self.emit(format!("define {} @{}({}) {{", ret_type, func.name, params.join(", ")))
        self.indent += 1
        
        for block in func.blocks.iter() {
            self.generate_block(block.clone())
        }
        
        self.indent -= 1
        self.emit("}")
        self.emit("")
    }
    
    fn generate_block(mut self, block: IRBlock) {
        self.emit(format!("{}:", block.label))
        self.indent += 1
        
        for inst in block.instructions.iter() {
            self.generate_inst(inst.clone())
        }
        
        self.generate_terminator(block.terminator)
        self.indent -= 1
    }
    
    fn generate_inst(mut self, inst: IRInst) {
        match inst {
            IRInst::ConstInt(reg, val) => {
                self.emit(format!("{} = add i64 0, {}", self.reg_name(reg), val))
            },
            IRInst::ConstFloat(reg, val) => {
                self.emit(format!("{} = fadd double 0.0, {}", self.reg_name(reg), val))
            },
            IRInst::ConstBool(reg, val) => {
                let v = if val { 1 } else { 0 }
                self.emit(format!("{} = add i1 0, {}", self.reg_name(reg), v))
            },
            IRInst::ConstString(reg, val) => {
                let escaped = val.replace("\\", "\\\\").replace("\"", "\\\"")
                self.emit(format!("{} = getelementptr [{}  x i8], [{}  x i8]* @.str.{}, i32 0, i32 0", 
                    self.reg_name(reg), val.len() + 1, val.len() + 1, reg))
            },
            IRInst::Add(dst, left, right) => {
                self.emit(format!("{} = add i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Sub(dst, left, right) => {
                self.emit(format!("{} = sub i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Mul(dst, left, right) => {
                self.emit(format!("{} = mul i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Div(dst, left, right) => {
                self.emit(format!("{} = sdiv i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Mod(dst, left, right) => {
                self.emit(format!("{} = srem i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Neg(dst, src) => {
                self.emit(format!("{} = sub i64 0, {}", self.reg_name(dst), self.reg_name(src)))
            },
            IRInst::Eq(dst, left, right) => {
                self.emit(format!("{} = icmp eq i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::NotEq(dst, left, right) => {
                self.emit(format!("{} = icmp ne i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Lt(dst, left, right) => {
                self.emit(format!("{} = icmp slt i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Gt(dst, left, right) => {
                self.emit(format!("{} = icmp sgt i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::LtEq(dst, left, right) => {
                self.emit(format!("{} = icmp sle i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::GtEq(dst, left, right) => {
                self.emit(format!("{} = icmp sge i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::And(dst, left, right) => {
                self.emit(format!("{} = and i1 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Or(dst, left, right) => {
                self.emit(format!("{} = or i1 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Not(dst, src) => {
                self.emit(format!("{} = xor i1 {}, true", self.reg_name(dst), self.reg_name(src)))
            },
            IRInst::BitAnd(dst, left, right) => {
                self.emit(format!("{} = and i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::BitOr(dst, left, right) => {
                self.emit(format!("{} = or i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::BitXor(dst, left, right) => {
                self.emit(format!("{} = xor i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::BitNot(dst, src) => {
                self.emit(format!("{} = xor i64 {}, -1", self.reg_name(dst), self.reg_name(src)))
            },
            IRInst::Shl(dst, left, right) => {
                self.emit(format!("{} = shl i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Shr(dst, left, right) => {
                self.emit(format!("{} = ashr i64 {}, {}", 
                    self.reg_name(dst), self.reg_name(left), self.reg_name(right)))
            },
            IRInst::Call(dst, name, args) => {
                let arg_strs: Vec<String> = args.iter()
                    .map(|r| format!("i64 {}", self.reg_name(*r)))
                    .collect()
                self.emit(format!("{} = call i64 @{}({})", 
                    self.reg_name(dst), name, arg_strs.join(", ")))
            },
            IRInst::Move(dst, src) => {
                self.emit(format!("{} = add i64 0, {}", self.reg_name(dst), self.reg_name(src)))
            },
            IRInst::Phi(dst, branches) => {
                let branch_strs: Vec<String> = branches.iter()
                    .map(|(label, reg)| format!("[ {}, %{} ]", self.reg_name(*reg), label))
                    .collect()
                self.emit(format!("{} = phi i64 {}", self.reg_name(dst), branch_strs.join(", ")))
            },
            _ => {},
        }
    }
    
    fn generate_terminator(mut self, term: IRTerminator) {
        match term {
            IRTerminator::Return(Some(reg)) => {
                self.emit(format!("ret i64 {}", self.reg_name(reg)))
            },
            IRTerminator::Return(None) => {
                self.emit("ret void")
            },
            IRTerminator::Jump(label) => {
                self.emit(format!("br label %{}", label))
            },
            IRTerminator::Branch(cond, then_label, else_label) => {
                self.emit(format!("br i1 {}, label %{}, label %{}", 
                    self.reg_name(cond), then_label, else_label))
            },
            IRTerminator::Unreachable => {
                self.emit("unreachable")
            },
            _ => {},
        }
    }
    
    fn type_to_llvm(self, ty: TypeInfo) -> String {
        match ty {
            TypeInfo::Unit => "void",
            TypeInfo::Bool => "i1",
            TypeInfo::Int => "i64",
            TypeInfo::Float => "double",
            TypeInfo::Char => "i8",
            TypeInfo::String => "i8*",
            TypeInfo::Array(_) => "i8*",
            TypeInfo::Struct(name, _) => format!("%struct.{}*", name),
            _ => "i64",
        }.to_string()
    }
}

// WebAssembly Generator
pub struct WASMCodeGen {
    output: String,
    indent: Int,
}

impl WASMCodeGen {
    pub fn new() -> WASMCodeGen {
        WASMCodeGen { output: String::new(), indent: 0 }
    }
    
    fn emit(mut self, s: String) {
        for _ in 0..self.indent {
            self.output += "  "
        }
        self.output += s
        self.output += "\n"
    }
}

impl CodeGen for WASMCodeGen {
    fn generate(mut self, module: IRModule) -> String {
        self.emit("(module")
        self.indent += 1
        
        // Memory
        self.emit("(memory 1)")
        self.emit("(export \"memory\" (memory 0))")
        self.emit("")
        
        // Functions
        for func in module.functions.iter() {
            self.generate_function(func.clone())
        }
        
        self.indent -= 1
        self.emit(")")
        
        self.output
    }
}

impl WASMCodeGen {
    fn generate_function(mut self, func: IRFunction) {
        let params: Vec<String> = func.params.iter()
            .map(|(name, ty)| format!("(param ${} {})", name, self.type_to_wasm(ty.clone())))
            .collect()
        
        let ret = if func.ret_type != TypeInfo::Unit {
            format!("(result {})", self.type_to_wasm(func.ret_type.clone()))
        } else { String::new() }
        
        self.emit(format!("(func ${} {} {}", func.name, params.join(" "), ret))
        self.indent += 1
        
        // Local variables
        for i in func.params.len()..func.reg_count as usize {
            self.emit(format!("(local $r{} i64)", i))
        }
        
        // Generate blocks
        for block in func.blocks.iter() {
            self.generate_block(block.clone())
        }
        
        self.indent -= 1
        self.emit(")")
        
        // Export if main
        if func.name == "main" {
            self.emit(format!("(export \"main\" (func ${}))", func.name))
        }
        self.emit("")
    }
    
    fn generate_block(mut self, block: IRBlock) {
        self.emit(format!(";; block: {}", block.label))
        
        for inst in block.instructions.iter() {
            self.generate_inst(inst.clone())
        }
        
        self.generate_terminator(block.terminator)
    }
    
    fn generate_inst(mut self, inst: IRInst) {
        match inst {
            IRInst::ConstInt(reg, val) => {
                self.emit(format!("i64.const {}", val))
                self.emit(format!("local.set $r{}", reg))
            },
            IRInst::ConstFloat(reg, val) => {
                self.emit(format!("f64.const {}", val))
                self.emit(format!("local.set $r{}", reg))
            },
            IRInst::Add(dst, left, right) => {
                self.emit(format!("local.get $r{}", left))
                self.emit(format!("local.get $r{}", right))
                self.emit("i64.add")
                self.emit(format!("local.set $r{}", dst))
            },
            IRInst::Sub(dst, left, right) => {
                self.emit(format!("local.get $r{}", left))
                self.emit(format!("local.get $r{}", right))
                self.emit("i64.sub")
                self.emit(format!("local.set $r{}", dst))
            },
            IRInst::Mul(dst, left, right) => {
                self.emit(format!("local.get $r{}", left))
                self.emit(format!("local.get $r{}", right))
                self.emit("i64.mul")
                self.emit(format!("local.set $r{}", dst))
            },
            IRInst::Div(dst, left, right) => {
                self.emit(format!("local.get $r{}", left))
                self.emit(format!("local.get $r{}", right))
                self.emit("i64.div_s")
                self.emit(format!("local.set $r{}", dst))
            },
            IRInst::Eq(dst, left, right) => {
                self.emit(format!("local.get $r{}", left))
                self.emit(format!("local.get $r{}", right))
                self.emit("i64.eq")
                self.emit(format!("local.set $r{}", dst))
            },
            IRInst::Lt(dst, left, right) => {
                self.emit(format!("local.get $r{}", left))
                self.emit(format!("local.get $r{}", right))
                self.emit("i64.lt_s")
                self.emit(format!("local.set $r{}", dst))
            },
            IRInst::Call(dst, name, args) => {
                for arg in args.iter() {
                    self.emit(format!("local.get $r{}", arg))
                }
                self.emit(format!("call ${}", name))
                self.emit(format!("local.set $r{}", dst))
            },
            _ => {},
        }
    }
    
    fn generate_terminator(mut self, term: IRTerminator) {
        match term {
            IRTerminator::Return(Some(reg)) => {
                self.emit(format!("local.get $r{}", reg))
                self.emit("return")
            },
            IRTerminator::Return(None) => {
                self.emit("return")
            },
            _ => {},
        }
    }
    
    fn type_to_wasm(self, ty: TypeInfo) -> String {
        match ty {
            TypeInfo::Int => "i64",
            TypeInfo::Float => "f64",
            TypeInfo::Bool => "i32",
            _ => "i64",
        }.to_string()
    }
}

// JavaScript Generator
pub struct JSCodeGen {
    output: String,
    indent: Int,
}

impl JSCodeGen {
    pub fn new() -> JSCodeGen {
        JSCodeGen { output: String::new(), indent: 0 }
    }
    
    fn emit(mut self, s: String) {
        for _ in 0..self.indent {
            self.output += "  "
        }
        self.output += s
        self.output += "\n"
    }
}

impl CodeGen for JSCodeGen {
    fn generate(mut self, module: IRModule) -> String {
        self.emit("// Generated by Vibee Lang Compiler")
        self.emit("'use strict';")
        self.emit("")
        
        // Runtime helpers
        self.emit("const __vibee_runtime = {")
        self.indent += 1
        self.emit("array_new: (len) => new Array(len).fill(0),")
        self.emit("array_get: (arr, idx) => arr[idx],")
        self.emit("array_set: (arr, idx, val) => { arr[idx] = val; },")
        self.emit("array_len: (arr) => arr.length,")
        self.indent -= 1
        self.emit("};")
        self.emit("")
        
        // Functions
        for func in module.functions.iter() {
            self.generate_function(func.clone())
        }
        
        // Main call
        self.emit("// Entry point")
        self.emit("if (typeof main === 'function') { main(); }")
        
        self.output
    }
}

impl JSCodeGen {
    fn generate_function(mut self, func: IRFunction) {
        let params: Vec<String> = func.params.iter()
            .map(|(name, _)| name.clone())
            .collect()
        
        self.emit(format!("function {}({}) {{", func.name, params.join(", ")))
        self.indent += 1
        
        // Local variables
        let mut locals = Vec::new()
        for i in func.params.len()..func.reg_count as usize {
            locals.push(format!("r{}", i))
        }
        if !locals.is_empty() {
            self.emit(format!("let {};", locals.join(", ")))
        }
        
        // Generate blocks
        for block in func.blocks.iter() {
            self.generate_block(block.clone())
        }
        
        self.indent -= 1
        self.emit("}")
        self.emit("")
    }
    
    fn generate_block(mut self, block: IRBlock) {
        self.emit(format!("// {}", block.label))
        
        for inst in block.instructions.iter() {
            self.generate_inst(inst.clone())
        }
        
        self.generate_terminator(block.terminator)
    }
    
    fn generate_inst(mut self, inst: IRInst) {
        match inst {
            IRInst::ConstInt(reg, val) => {
                self.emit(format!("r{} = {};", reg, val))
            },
            IRInst::ConstFloat(reg, val) => {
                self.emit(format!("r{} = {};", reg, val))
            },
            IRInst::ConstBool(reg, val) => {
                self.emit(format!("r{} = {};", reg, val))
            },
            IRInst::ConstString(reg, val) => {
                self.emit(format!("r{} = \"{}\";", reg, val))
            },
            IRInst::Add(dst, left, right) => {
                self.emit(format!("r{} = r{} + r{};", dst, left, right))
            },
            IRInst::Sub(dst, left, right) => {
                self.emit(format!("r{} = r{} - r{};", dst, left, right))
            },
            IRInst::Mul(dst, left, right) => {
                self.emit(format!("r{} = r{} * r{};", dst, left, right))
            },
            IRInst::Div(dst, left, right) => {
                self.emit(format!("r{} = Math.floor(r{} / r{});", dst, left, right))
            },
            IRInst::Mod(dst, left, right) => {
                self.emit(format!("r{} = r{} % r{};", dst, left, right))
            },
            IRInst::Eq(dst, left, right) => {
                self.emit(format!("r{} = r{} === r{};", dst, left, right))
            },
            IRInst::NotEq(dst, left, right) => {
                self.emit(format!("r{} = r{} !== r{};", dst, left, right))
            },
            IRInst::Lt(dst, left, right) => {
                self.emit(format!("r{} = r{} < r{};", dst, left, right))
            },
            IRInst::Gt(dst, left, right) => {
                self.emit(format!("r{} = r{} > r{};", dst, left, right))
            },
            IRInst::And(dst, left, right) => {
                self.emit(format!("r{} = r{} && r{};", dst, left, right))
            },
            IRInst::Or(dst, left, right) => {
                self.emit(format!("r{} = r{} || r{};", dst, left, right))
            },
            IRInst::Not(dst, src) => {
                self.emit(format!("r{} = !r{};", dst, src))
            },
            IRInst::Call(dst, name, args) => {
                let arg_strs: Vec<String> = args.iter()
                    .map(|r| format!("r{}", r))
                    .collect()
                self.emit(format!("r{} = {}({});", dst, name, arg_strs.join(", ")))
            },
            IRInst::ArrayNew(dst, len) => {
                self.emit(format!("r{} = __vibee_runtime.array_new({});", dst, len))
            },
            IRInst::ArrayGet(dst, arr, idx) => {
                self.emit(format!("r{} = r{}[r{}];", dst, arr, idx))
            },
            IRInst::ArraySet(arr, idx, val) => {
                self.emit(format!("r{}[r{}] = r{};", arr, idx, val))
            },
            _ => {},
        }
    }
    
    fn generate_terminator(mut self, term: IRTerminator) {
        match term {
            IRTerminator::Return(Some(reg)) => {
                self.emit(format!("return r{};", reg))
            },
            IRTerminator::Return(None) => {
                self.emit("return;")
            },
            _ => {},
        }
    }
}

// Public API
pub fn generate(module: IRModule, target: Target) -> String {
    match target {
        Target::LLVM => LLVMCodeGen::new().generate(module),
        Target::WASM => WASMCodeGen::new().generate(module),
        Target::JavaScript => JSCodeGen::new().generate(module),
        Target::Native => LLVMCodeGen::new().generate(module),
    }
}

test "generate llvm" {
    let ir = IRModule {
        name: "test",
        functions: vec![],
        globals: vec![],
        structs: vec![],
    }
    let output = generate(ir, Target::LLVM)
    assert(output.contains("ModuleID"))
}
